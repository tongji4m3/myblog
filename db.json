{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/my_hexo/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/icp.png","path":"medias/icp.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/cover.jpg","path":"medias/cover.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/reward/wechat.jpg","path":"medias/reward/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"2822f616502c540e80d741ac696406db5084f8af","modified":1601639408157},{"_id":"themes/my_hexo/.gitignore","hash":"727607929a51db7ea10968f547c26041eee9cfff","modified":1601106471000},{"_id":"themes/my_hexo/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1601106471000},{"_id":"themes/my_hexo/README.md","hash":"56299cf1fe60a11fef61b3948fe148f995df747e","modified":1601106471000},{"_id":"themes/my_hexo/README_CN.md","hash":"0fdf818476a444663cc8ffa2f194199d9fd93508","modified":1601343393696},{"_id":"themes/my_hexo/_config.yml","hash":"561ab871deabd221e0a3c525419a2cb130addbbe","modified":1612399972069},{"_id":"source/404/index.md","hash":"adc4e1296fa512139519930ee498ac9d95a1fb25","modified":1601200416358},{"_id":"source/_data/friends.json","hash":"8828a88b0cd35bb91b7951a9826c3b0a5f04bf1c","modified":1601283996719},{"_id":"source/about/index.md","hash":"3f969cb7ab37ad41aa25bcdb4fe165b0256359a0","modified":1601199515722},{"_id":"source/categories/index.md","hash":"130625d0bdd8cf8d513ada545a00766000e099ed","modified":1601199466287},{"_id":"source/contact/index.md","hash":"b4d65c2b202c7f339dead9ef10af31793b0f762b","modified":1601199966504},{"_id":"source/tags/index.md","hash":"fc35ab5abf719ac3dc4092d260e3321d766cd546","modified":1601199450443},{"_id":"source/friends/index.md","hash":"09a403a4c3cd449ca3a4cdbdd5e2b79531bc5967","modified":1601216799511},{"_id":"themes/my_hexo/languages/zh-CN.yml","hash":"a957b05f70265a86a87d922e18488571809d2472","modified":1601106471000},{"_id":"themes/my_hexo/languages/default.yml","hash":"54ccc01b097c5bf6820f0edfcece1a87b78ab32d","modified":1601106471000},{"_id":"themes/my_hexo/layout/404.ejs","hash":"9c8ca67377211e5d60fdde272a975faa9a91a22a","modified":1601106471000},{"_id":"themes/my_hexo/languages/zh-HK.yml","hash":"ae34ac0e175c3037675722e436637efbceea32f0","modified":1601106471000},{"_id":"themes/my_hexo/layout/about.ejs","hash":"41849f9300b8dc47048333fcf4a897dd8a2a13ca","modified":1601106471000},{"_id":"themes/my_hexo/layout/archive.ejs","hash":"cdac701de8370f9f3794a0eed4165983993a1ca7","modified":1601106471000},{"_id":"themes/my_hexo/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1601106471000},{"_id":"themes/my_hexo/layout/category.ejs","hash":"00019bca11fb46477f22017cb1f5ad8444da0580","modified":1601106471000},{"_id":"themes/my_hexo/layout/contact.ejs","hash":"72fb5af3fc2f8955e2eb10926bbe4532a04ccd1b","modified":1601106471000},{"_id":"themes/my_hexo/layout/friends.ejs","hash":"f5d6459bed0f4ecb214f2dbff5b2207a80c44f66","modified":1601106471000},{"_id":"themes/my_hexo/layout/index.ejs","hash":"4dc6f08e7709cc04e886be72dbf0d06469f0effc","modified":1601106471000},{"_id":"themes/my_hexo/layout/layout.ejs","hash":"22125624381b8d4dd50cb17ffe0631c838557364","modified":1601106471000},{"_id":"themes/my_hexo/layout/post.ejs","hash":"90b5a4c1f70e4756db569c15a7c6cad0c77c4500","modified":1601106471000},{"_id":"themes/my_hexo/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1601106471000},{"_id":"themes/my_hexo/layout/tag.ejs","hash":"85a4b05bd8a6ad0f17ff2e97dae56949b379c204","modified":1601106471000},{"_id":"themes/my_hexo/source/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1601106471000},{"_id":"source/_posts/JVM笔记/第11章_后端编译与优化.md","hash":"f12227cd573b326ca53891e474a96b07a65bc8b2","modified":1605182249116},{"_id":"source/_posts/JVM笔记/第10章_前端编译与优化.md","hash":"363242161550b987fefdefbc7dd2daa643e0ccaf","modified":1605182249129},{"_id":"source/_posts/JVM笔记/第12章_Java内存模型与线程.md","hash":"700f95c5ffdf288fd00e29d80665d97736a75e50","modified":1605182249160},{"_id":"source/_posts/JVM笔记/第13章_线程安全与锁优化.md","hash":"8b148eb07ba5a416096200897bb73500260a82f3","modified":1605182249108},{"_id":"source/_posts/JVM笔记/第2章.md","hash":"635f650ed624622aa1833b04d5b8f188a821db30","modified":1605182249113},{"_id":"source/_posts/JVM笔记/第7章_虚拟机类加载机制.md","hash":"901e73763d376599b9a417295eb7bda89300865f","modified":1605182249170},{"_id":"source/_posts/JVM笔记/第6章.md","hash":"2b29ed65c0f96d641188e6da17599addb89bc430","modified":1605182249119},{"_id":"source/_posts/JVM笔记/第3章.md","hash":"2de256fc1903d2ca70da622e9dba0409759aba65","modified":1605182249140},{"_id":"source/_posts/JVM笔记/第8章_虚拟机字节码执行引擎.md","hash":"1f2c92d1f726caceed66d653172677fe34bd6ae7","modified":1605182249191},{"_id":"source/_posts/Java笔记/IO.md","hash":"12fcdffbcd0753de7d1c79a53532ee5cf50f514b","modified":1605182249180},{"_id":"source/_posts/Java笔记/JAVASE.md","hash":"56406e3b19c73e14196c9e0fd8903dc6a6a9f7c7","modified":1605182249207},{"_id":"source/_posts/Java笔记/Javaweb踩过的坑.md","hash":"b4845616ecfe697d8f57becfb0ee422fe1e5dd0a","modified":1605182249219},{"_id":"source/_posts/Java笔记/Java基础.md","hash":"574677fc21170aa079b40615a9cc38fe14043a2e","modified":1605182249229},{"_id":"source/_posts/Java笔记/String.md","hash":"4af06d2492e4e1b2d23d4fda10c69e7f1336e536","modified":1605182249257},{"_id":"source/_posts/Java笔记/常用对象.md","hash":"cf59ad78dc37a25fbc8430bc7fb10002390aa93d","modified":1605182249239},{"_id":"source/_posts/Java笔记/异常.md","hash":"a76d2bd2032a3b2d1e63b2335ffd30a4265542a4","modified":1605182249275},{"_id":"source/_posts/Redis笔记/10.RDB持久化.md","hash":"555d55c1abf8a49cc9c5648dff2b7f3a52bccc81","modified":1605182249823},{"_id":"source/_posts/Redis笔记/11.AOF持久化.md","hash":"af34c76d52b37a7afc6a9c758426100f9c63449c","modified":1605182249817},{"_id":"source/_posts/Redis笔记/15.复制.md","hash":"2316f1c6ea0e7a4a93df5672da44498520e9e9c8","modified":1605182249809},{"_id":"source/_posts/Redis笔记/16.Sentinel.md","hash":"c3846a65b47a8f7f4b034af329c4fb67aec7ecb9","modified":1612398960770},{"_id":"source/_posts/Redis笔记/2.简单字符串.md","hash":"282156c9ac7691d4c1726ea0493bcce4b0f0110c","modified":1605182249851},{"_id":"source/_posts/Redis笔记/4.字典.md","hash":"24d849dc12f53651c7288348c1362c0b86122408","modified":1605182249867},{"_id":"source/_posts/Redis笔记/3.链表.md","hash":"fb358680b85e93d62fa2b4e01530b62442fa2af3","modified":1605182249840},{"_id":"source/_posts/Redis笔记/6.整数集合.md","hash":"5813892ed130e4a6a85888e402b4619626674e56","modified":1605182249873},{"_id":"source/_posts/Redis笔记/5.跳跃表.md","hash":"46dc574ececd2f46d57f58ce2ed3e1b3cf62b8f4","modified":1605182249859},{"_id":"source/_posts/Redis笔记/7.压缩列表.md","hash":"ae65b58a58e8ef871c31344bb6cd3164d17e775c","modified":1605182249902},{"_id":"source/_posts/Redis笔记/8.对象.md","hash":"b5a63170898913fb2ca10bbefa2e2ddfd3a91187","modified":1605182249894},{"_id":"source/_posts/Redis笔记/9.数据库.md","hash":"d3b82b58b38a5aa5a367977fc0f6f7f7fc873fb7","modified":1605182249883},{"_id":"source/_posts/Tools笔记/Hadoop搭建及使用文档.md","hash":"102dbc600a50f13bb3baddb0ecb236cccdfbf739","modified":1605182249906},{"_id":"source/_posts/Tools笔记/VMware.md","hash":"9413164150d396a90cb3c0d70a3fd2acca09bfb2","modified":1605182249912},{"_id":"source/_posts/Tools笔记/Vue.md","hash":"cb50dd5de6aebbb27e5c8519f1edae954914b107","modified":1605182249931},{"_id":"source/_posts/Tools笔记/Windows新建一个md文件的几种方法.md","hash":"b06b8d786dad5c74fb1df3b7e549a0adcb22e677","modified":1605182249919},{"_id":"source/_posts/Tools笔记/docker.md","hash":"13221e4464f254d6515c87c6ab874462661e7482","modified":1605182249947},{"_id":"source/_posts/Tools笔记/idea.md","hash":"0ac5f1c0e032ff6d61d20243703b8ccd3706ced8","modified":1605182249953},{"_id":"source/_posts/Tools笔记/hexo.md","hash":"b6288c7f417f5a45a687c253fd5dd63349f34d31","modified":1605182249942},{"_id":"source/_posts/Tools笔记/linux.md","hash":"9ed5f5c239f83d902f773d8eecb2b1f9e7b78302","modified":1605182249962},{"_id":"source/_posts/Tools笔记/markdown.md","hash":"c47c034bdb452e85a78d2a4bf7e4dafb140a4c45","modified":1605182249977},{"_id":"source/_posts/Tools笔记/ssh.md","hash":"a0580f0d72a9c604381301e9a67e2d58445a0586","modified":1605182249994},{"_id":"source/_posts/Tools笔记/图床.md","hash":"1ae20abbaedba052ac684fe2e85a50adacdf57ea","modified":1605182249987},{"_id":"source/_posts/Tools笔记/重装系统.md","hash":"5830ce1f07d1d8235266ec178343ab0b6fc035e6","modified":1605182250016},{"_id":"source/_posts/Tools笔记/windows.md","hash":"c704c31b3a8a5d7d943d5c701c51157bd2e8c248","modified":1605182249969},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_01_两数之和.md","hash":"3cdf7db12cdd1f9885b4c48f95253cccbd224b34","modified":1605182249291},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_02_两数相加.md","hash":"8bd3d70ff469678a81efa61346ec2b8bc8429f39","modified":1605182249266},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_04_ 寻找两个正序数组的中位数.md","hash":"d38f646a4f6612e78d1ca69f570b5933ea859810","modified":1605182249309},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_03_ 无重复字符的最长子串.md","hash":"7545585ce6c440febf8f4ef9e4ed3e3c864284bb","modified":1605182249301},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_05_最长回文子串.md","hash":"66d5eb921934ce667e5f645f6b967e3e3cb88a3b","modified":1605182249354},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_101. 对称二叉树.md","hash":"08412f4c1d7a62713532dd0de5d713accb402e27","modified":1605182249319},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_102. 二叉树的层序遍历.md","hash":"7bf57696c219dd3544e7b39be46b66afa0706979","modified":1605182249347},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_104. 二叉树的最大深度.md","hash":"9401d32b728c9fdf0f2ac2e4528dc394dded5e4d","modified":1605182249386},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_105. 从前序与中序遍历序列构造二叉树.md","hash":"a4a37ae17d20890abc6978c5fbfb6051b297cb60","modified":1605182249339},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_10_正则表达式匹配.md","hash":"6f88a1280f81cc97a1a8da99f0731c31dc8b2e86","modified":1605182249363},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_114. 二叉树展开为链表.md","hash":"42c96a5fdac2ebe86e8159e95e3061ea35af8918","modified":1605182249410},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_11_盛最多水的容器.md","hash":"6d5d588f1f00ffc5d0cc7fc8b140013d9a5dc8ef","modified":1605182249402},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_121. 买卖股票的最佳时机.md","hash":"6bef5feb14801a21da0268ad02e8d1fc3db77f81","modified":1605182249371},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_136. 只出现一次的数字.md","hash":"6878e3cc3445813337ae4364de665df99c22b498","modified":1605182249395},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_139. 单词拆分.md","hash":"31e580cc3a49e886b0ef4f9e578088e1634c1d0a","modified":1605182249442},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_146. LRU缓存机制.md","hash":"e02f126520e6c050a92624e64f85e5cdf677f92b","modified":1605182249450},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_142. 环形链表 II.md","hash":"c9e15dc51f8deff56ac65a12a565aef5a860845d","modified":1605182249419},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_141. 环形链表.md","hash":"10244f5ab6abb3ab4445007d68f4ff4d7f64f6af","modified":1605182249434},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_148. 排序链表.md","hash":"ce858d80b3e1fee7df14e2d12a81d46e859d6802","modified":1605182249466},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_152. 乘积最大子数组.md","hash":"a783494346997651152580d14bf6833bf6747795","modified":1605182249480},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_155. 最小栈.md","hash":"56985320e088504ddc6bd82abe65f9b3db9d8404","modified":1605182249459},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_15_三数之和.md","hash":"6a184edff1e73f49ba4dcb0ce52f3bafcee018ed","modified":1605182249505},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_17_ 电话号码的字母组合.md","hash":"fcc1749316755666e3e3eec434396ed10cb2201e","modified":1605182249488},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_19_删除链表的倒数第N个节点.md","hash":"3248ead723f1354d23e3510f61bfb128365d3c89","modified":1605182249497},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_207. 课程表.md","hash":"12f4d098616ee63c12a1323541f1d4b16f4c9211","modified":1612399582536},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_20_ 有效的括号.md","hash":"f89395ca6ba5e224201a0985f7fd4cd8c87124b6","modified":1605182249545},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_208. 实现 Trie (前缀树).md","hash":"a264f4b39b547e30e7e5d494952cfa320fdca28e","modified":1612399572042},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_21_ 合并两个有序链表.md","hash":"111644f39d35b6650fc646e9f80c6a455560d2ad","modified":1605182249537},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_221. 最大正方形.md","hash":"9a62cfac3635005dfe6683683d5d0f83d9225723","modified":1612399558306},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_22_括号生成.md","hash":"f54c991d60e1b791337370d5aa9db32e70194a4a","modified":1605182249587},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_23_合并K个排序链表.md","hash":"9eca21c6a8829faf4361226adf02016374f482eb","modified":1605182249578},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_31_ 下一个排列.md","hash":"ac1e541ab4e2e6609623fe29c61e2460c77c4bfe","modified":1605182249569},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_32_最长有效括号.md","hash":"88027d7b1a202853867f0071cee819cc0504a18d","modified":1605182249595},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_33_ 搜索旋转排序数组.md","hash":"1fde9a72f681f6db044bc28cc540234275b7a540","modified":1605182249619},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_39. 组合总和.md","hash":"dec1805de8deb03236ee885a2898fc1c26839b06","modified":1605182249627},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_34. 在排序数组中查找元素的第一个和最后一个位置.md","hash":"32ec08ebfdd05e086fc80b7d2cc4a5b91893cefa","modified":1605182249605},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_46. 全排列.md","hash":"21fe86de60c1528a4bab11349a8d3bbe2be384e7","modified":1605182249652},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_42. 接雨水.md","hash":"b0a117e67a1bedddf2f6fa97bce1a1a37f48d0de","modified":1605182249635},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_49. 字母异位词分组.md","hash":"1709dad2261860b11f1d3b214ed083c4bab590ca","modified":1605182249671},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_48. 旋转图像.md","hash":"7a17c9a5621e3a1c24c8be474554adbb358575d1","modified":1605182249643},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_53. 最大子序和.md","hash":"58293b7aac750369dfcb24ca36dbbcfbeab161a0","modified":1605182249676},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_55. 跳跃游戏.md","hash":"4d8a7000b4b52483cfa79ed8d2c9b8216c580138","modified":1605182249705},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_56. 合并区间.md","hash":"cd7b6a2b1c90c994d47e76d8576753dc0ec802a6","modified":1605182249662},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_64. 最小路径和.md","hash":"b0256de608561d025df310e7e245445ab641accc","modified":1605182249684},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_62. 不同路径.md","hash":"709c8b96b131ae3904c6fff29752f72bcc96a0b8","modified":1605182249691},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_70. 爬楼梯.md","hash":"b25a648cbb44d80a97ce138cc898ef1b75f2d19c","modified":1605182249720},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_72. 编辑距离.md","hash":"2e625b9a71b8f1e12a8cacc2a14074f38fa313f9","modified":1605182249751},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_75. 颜色分类.md","hash":"1de19ab9b415f515341209b1cedb26f042a02f21","modified":1605182249713},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_76. 最小覆盖子串.md","hash":"9d128d0983ca7f6139d179213705b9f0b8a762ad","modified":1605182249735},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_78. 子集.md","hash":"aaa021f5fd36de41eecb5c83fece15bca34bec35","modified":1605182249729},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_79. 单词搜索.md","hash":"f1aa64a9d7bc852a58e58ee4b03ec2ccc1c375d4","modified":1605182249758},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_84. 柱状图中最大的矩形.md","hash":"efca5bd1ff363c32b3a6607efe8843ba9bce062d","modified":1605182249773},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_94. 二叉树的中序遍历.md","hash":"5fbe007388d801c9a432ce26935124068f006aaf","modified":1605182249783},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_96. 不同的二叉搜索树.md","hash":"44e4b1728ac81fe73cf51b87450814108ec3079a","modified":1605182249767},{"_id":"source/_posts/计算机网络/01_计算机网络和因特网.md","hash":"9ca4f989e0c9b05a62de8cdb6609be188b1d1f48","modified":1612398908040},{"_id":"source/_posts/LeetCode笔记/LeetCode刷题笔记_98. 验证二叉搜索树.md","hash":"cca805465bc36ca8a521e72179aa724d5cce3085","modified":1605182249795},{"_id":"source/_posts/计算机网络/02_应用层.md","hash":"9371c8dda38b6d09ab2a866c0a063136fe20f31b","modified":1605182250036},{"_id":"source/_posts/计算机网络/03_运输层.md","hash":"3fdda756f71468322c595e0e5cf57268e98f3f83","modified":1605182250009},{"_id":"source/_posts/项目笔记/Web游戏_俄罗斯方块.md","hash":"8348175b8c62a9e48317f79db2a230d8096b99be","modified":1605182250051},{"_id":"source/_posts/项目笔记/Web项目-简单的购物网站.md","hash":"68b82c74b8f523774ccf3c709ef089f79947f417","modified":1612398926531},{"_id":"source/_posts/项目笔记/处理机管理-电梯调度.md","hash":"1582699bce0688f1c17d91faf27d883fd5dbaf25","modified":1605182250059},{"_id":"source/_posts/项目笔记/操作系统_内存管理项目.md","hash":"57d1085086034f6634a4a8f3675c15505874db91","modified":1605182250067},{"_id":"source/_posts/项目笔记/操作系统_文件系统管理项目.md","hash":"cd12dc6c4f55b326c13c1bd31c599a014f49b915","modified":1605182250081},{"_id":"themes/my_hexo/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/bg-cover-content.ejs","hash":"2fdb3ff1e571663daf91b8634ec2968b4f55ce84","modified":1601277376507},{"_id":"themes/my_hexo/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/disqus.ejs","hash":"b2dc2c8b5ed56815e55cc2ea54a6dc4eeba2375d","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/footer.ejs","hash":"c4b917d3ac0f5996b02e646639d5d414e161f9df","modified":1601368687022},{"_id":"themes/my_hexo/layout/_partial/gitalk.ejs","hash":"2aa8fbb04b046fa7679092a48372d7e036835dff","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/gitment.ejs","hash":"90f6218512ef2eab63ada7ad2fc766ae635a2297","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/head.ejs","hash":"79480f22a18d84e8f54a72e9b5dcd26356e8f039","modified":1601706694921},{"_id":"themes/my_hexo/layout/_partial/header.ejs","hash":"59e38c70f3d8e7165e686e5e84a627835f4321b0","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/index-cover.ejs","hash":"76b4a37e0364380b143fdf94bf1a5e6941564414","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/minivaline.ejs","hash":"5f09386aece8f9cf31f6059bbde79cd6c5171493","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/mobile-nav.ejs","hash":"cb0cb452be1cd1857ba600f04025b506f3b6fc79","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/navigation.ejs","hash":"78b70ff24b3039c871331ebec114b936c1756cc8","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/post-cover.ejs","hash":"d1c873c5de54498c722e155aadb8c0ec39485dfa","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/post-detail-toc.ejs","hash":"ff3ceb93a03af5d9d120710347570ecaafc00979","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/post-detail.ejs","hash":"d05926e79aa6dfc235193b9d8c6aa03118b0eade","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/prev-next.ejs","hash":"c76b78782ea82340104fccc089417572e0adece4","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/reprint-statement.ejs","hash":"0ce3f9361f558b99cc2f059c5e50b0e2a152ae38","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/reward.ejs","hash":"ffc55bc7e73bc698bfc58d8e3780c336b83282cf","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/search.ejs","hash":"b39db4e38cf230a83e83dbbfae5560519f59abfa","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/social-link.ejs","hash":"ee0a23d94a559ff5d8d5f4b40a2fc06b6ee37c15","modified":1601341415854},{"_id":"themes/my_hexo/layout/_partial/share.ejs","hash":"c941730a2471d6aab367cbb6e09ed08b56c83143","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/valine.ejs","hash":"0e4c0a6154aa34007849928ca88f05b6185b256e","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/category-cloud.ejs","hash":"1b3df1009234c0112424b497b18b4ad8240b3bc7","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/category-radar.ejs","hash":"1d8747fda89a0b2ca3c7008867cbfeecad0578a6","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/dream.ejs","hash":"9a472ad5591100cdb65d0df9d01034163bd6dd9d","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/music.ejs","hash":"e9e3e327d5de9d7aeadbde32e1d558652d9e9195","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/my-gallery.ejs","hash":"65a2d2f9722f84c7fd98f6bdf79087a14848ebd8","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/my-projects.ejs","hash":"ef60b64021fa349b0048425d858dfcf6c906fede","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/post-calendar.ejs","hash":"48821e644bc73553d7c5c56d2e8ee111a70cd776","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/post-charts.ejs","hash":"ab5f986f428215941aeaa0c88aefd440c47d3bcf","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/recommend.ejs","hash":"8551137e94ca4e2e3b8b63d5626255884cb60cb5","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/tag-wordcloud.ejs","hash":"487aacb2454d6bf0d21cdb07ddd1fd5ddbca9038","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/video.ejs","hash":"a0e002377af2a7f7e4da6d9a644de97adb035925","modified":1601106471000},{"_id":"themes/my_hexo/source/css/matery.css","hash":"87bd1dacf48c9daab7ea43466368247f1e4107d1","modified":1601106471000},{"_id":"themes/my_hexo/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1601106471000},{"_id":"themes/my_hexo/source/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1601106471000},{"_id":"themes/my_hexo/source/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1601106471000},{"_id":"themes/my_hexo/source/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1601106471000},{"_id":"themes/my_hexo/source/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/logo.png","hash":"488870f0f476a2349ac258b7c42a4c732eaef5a0","modified":1601340508586},{"_id":"source/_posts/Java笔记/Java编程思想/02_一切皆是对象.md","hash":"c9ef024000b0a7e10fd7d975a135daddb0d86882","modified":1612399186743},{"_id":"source/_posts/Java笔记/Java编程思想/03_操作符.md","hash":"a5e37f19bb55d56fbe6fa0e4d2062d1f8af896f5","modified":1612399423814},{"_id":"source/_posts/Java笔记/Java编程思想/06_访问权限控制.md","hash":"091b951a1541a312c6b106648e8bd362e4fd5d33","modified":1612399226446},{"_id":"source/_posts/Java笔记/Java编程思想/07_复用类.md","hash":"442b6b569be061bff9dcfdd7593e60e12e041087","modified":1612399332610},{"_id":"source/_posts/Java笔记/Java编程思想/05_初始化与清理.md","hash":"64328501a7dadadd47abae4bf6aad3d9f2b84a8f","modified":1612399219711},{"_id":"source/_posts/Java笔记/Java编程思想/08_多态.md","hash":"e22aac96ddfc752b07a046123d504e82528fc047","modified":1612399348978},{"_id":"source/_posts/Java笔记/Java编程思想/10_内部类.md","hash":"fd05287ca820eec97ab91e204307da21a84fb73d","modified":1612399401705},{"_id":"source/_posts/Java笔记/Java编程思想/11_持有对象.md","hash":"de3a9662ce0d8c5f2b33fe64dd0c21ac6e37fe4a","modified":1612399252974},{"_id":"source/_posts/Java笔记/Java编程思想/12_通过异常处理错误.md","hash":"3986553c5e1f0fa487a27e267dc5244f3af592dd","modified":1612399260875},{"_id":"source/_posts/Java笔记/Java编程思想/13_字符串.md","hash":"28305c95018dcb66da38f3253b478010d676814e","modified":1612399266999},{"_id":"source/_posts/Java笔记/Java编程思想/14_类型信息.md","hash":"7ba70c08cc60b766c11a4463b1f3eccdb7f40a2b","modified":1612399379706},{"_id":"source/_posts/Java笔记/Java编程思想/15_泛型.md","hash":"69ff7de77aa94af320337792cf75e8e9c28ff4f3","modified":1612399368466},{"_id":"source/_posts/设计模式笔记/单件模式/单件模式.md","hash":"5ce1661bbf787435010b534d9d8c1effb135ce48","modified":1605182250260},{"_id":"source/_posts/设计模式笔记/命令模式/命令模式.md","hash":"0cfe3e1349745a89fad51c1274ff2847084ccc05","modified":1605182250269},{"_id":"source/_posts/设计模式笔记/外观模式/外观模式.md","hash":"fbcaa208cf14dac2c11b644bf05026970e7327cb","modified":1605182250275},{"_id":"source/_posts/设计模式笔记/命令模式/命令模式.mdj","hash":"1814a828040d1fa67cda4e5f2c1ca16075c8fb3e","modified":1601780106438},{"_id":"source/_posts/设计模式笔记/模板方法模式/模板方法模式.md","hash":"a671690de69757f4a05a4d3fda1390256f5c61cb","modified":1605182250319},{"_id":"source/_posts/设计模式笔记/工厂模式/工厂方法模式.md","hash":"36b9a25d91f2b6dc358a24fa2f9ca6c47a44a136","modified":1612398945195},{"_id":"source/_posts/设计模式笔记/工厂模式/抽象工厂模式.md","hash":"90d931e35bb2934a8e10567e8b79373ecc54575b","modified":1605182250290},{"_id":"source/_posts/设计模式笔记/策略模式/策略模式.md","hash":"1a885ebf85f3154181598b38c4d7473fac16e8b2","modified":1605182250284},{"_id":"source/_posts/设计模式笔记/装饰者模式/装饰者模式.md","hash":"1c5f6c8f351468b01168e5a999dbefcef2d60f48","modified":1605182250307},{"_id":"source/_posts/设计模式笔记/观察者模式/观察者模式.md","hash":"3deb7dbcd067cdab6103fa1bc4bdbb3fb45b0991","modified":1605182250326},{"_id":"source/_posts/设计模式笔记/适配器模式/适配器模式.md","hash":"f3ce8c16c6ffcb5986036f0c04f66868a171f436","modified":1605182250333},{"_id":"source/_posts/设计模式笔记/适配器模式/适配器模式.mdj","hash":"edbe796bf2fbd2e53d791dbb31f7ffdaf027ca0a","modified":1601866079469},{"_id":"source/_posts/项目笔记/dataStructureProjects/8种排序算法的比较案例.md","hash":"1e09825dd9ede9c8aff445892aa873cae63bb22f","modified":1605182250339},{"_id":"source/_posts/项目笔记/dataStructureProjects/两个有序链表序列的交集.md","hash":"4fc490331c015367bfab140feefd57b41452946a","modified":1605182250369},{"_id":"source/_posts/项目笔记/dataStructureProjects/修理牧场.md","hash":"718e64d4b2860280d0e3af04559c0ec6fe3c207c","modified":1605182250347},{"_id":"source/_posts/项目笔记/dataStructureProjects/字符串排序算法的调研与实现.md","hash":"b423d7a9ad4932e0e439d37f8003e280a99ace09","modified":1605182250361},{"_id":"source/_posts/项目笔记/dataStructureProjects/勇闯迷宫游戏.md","hash":"525322eae688d420c9aa062a9d73fd1bc94c53eb","modified":1605182250377},{"_id":"source/_posts/项目笔记/dataStructureProjects/家谱管理系统.md","hash":"100fbb389a7257c2180e248b742d7802f40e77fc","modified":1605182250387},{"_id":"source/_posts/项目笔记/dataStructureProjects/模拟银行业务.md","hash":"e25fdde7ab6aaac42612fd6d953733a266ee9ef9","modified":1605182250396},{"_id":"source/_posts/项目笔记/dataStructureProjects/电网建设造价模拟系统.md","hash":"e311938b85454fbb9d92dda1c2f0ebb703723455","modified":1605182250415},{"_id":"source/_posts/项目笔记/dataStructureProjects/算数表达式求解.md","hash":"e1b4b388fb22bc9c83473f83121240c70de7a873","modified":1605182250409},{"_id":"source/_posts/项目笔记/dataStructureProjects/考试报名系统.md","hash":"dc1abeb665ac27b0b89c579c758f446e3b68271a","modified":1605182250422},{"_id":"themes/my_hexo/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1601106471000},{"_id":"source/_posts/设计模式笔记/工厂模式/工厂模式.mdj","hash":"cca835843412354b82c188bdcab7010dbfa0785a","modified":1601541192863},{"_id":"source/_posts/设计模式笔记/策略模式/策略模式.mdj","hash":"31f24599f2aa5e5deb2334241199202063b45fc4","modified":1600860937179},{"_id":"source/_posts/设计模式笔记/装饰者模式/装饰者模式.mdj","hash":"341e088f6c8c09d3bd353b21ae012ac9ba6d6165","modified":1601111107947},{"_id":"source/_posts/设计模式笔记/观察者模式/观察者模式.mdj","hash":"69d60dc0b4c3f762b18eafc066eab6230fd58d8a","modified":1600934253970},{"_id":"themes/my_hexo/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/reward/wechat.jpg","hash":"4ab47898643c36db9b679e3dfa1dc050ad13e476","modified":1601278131468},{"_id":"source/_posts/设计模式笔记/模板方法模式/模板方法模式.mdj","hash":"0edeec8b7a60cba3591b6b6bcdb930f4550a2a45","modified":1603596521440},{"_id":"source/_posts/设计模式笔记/工厂模式/upload/image-20201001162740771.png","hash":"5131bcb5cbe3a753b574e8d82acf6fddcd5acd75","modified":1601540860803},{"_id":"source/_posts/设计模式笔记/工厂模式/upload/image-20201001163131160.png","hash":"c97570019c26ec2fa57344e7d6c8811c51c791e9","modified":1601541091192},{"_id":"source/_posts/设计模式笔记/工厂模式/抽象工厂模式.mdj","hash":"d76763745392f1b0449d13122f870b4706da3fe3","modified":1601541125674},{"_id":"source/_posts/设计模式笔记/适配器模式/upload/image-20201005103843452.png","hash":"ea017f7f1e4b9a6e14c0fedfe515da24cfad2466","modified":1601865523467},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/avatar.jpg","hash":"5df0399b8097fc06d8fa3641da3db1a22aaca936","modified":1601293366757},{"_id":"themes/my_hexo/source/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1601106471000},{"_id":"source/_posts/设计模式笔记/观察者模式/upload/image-20200924112457998.png","hash":"37e0240629ba0b58cebfc513357ab50f0ba38951","modified":1600917898033},{"_id":"themes/my_hexo/source/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/reward/alipay.jpg","hash":"2d9fc663c295daa53adc716234a018679ea23c3e","modified":1601278314468},{"_id":"themes/my_hexo/source/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1601106471000},{"_id":"public/search.xml","hash":"81b0c575fb1ad9bd1acb7880ee8258d1bf1c7d12","modified":1612400574288},{"_id":"public/atom.xml","hash":"19343a7e9bc4376d762a4866d870b7b4263c26a2","modified":1612400574288},{"_id":"public/sitemap.xml","hash":"be2b7852871b4ec272573c9762aeddf645ad4f83","modified":1612400574288},{"_id":"public/baidusitemap.xml","hash":"55c0f680f9570c7e2b18d5d9c3bff5aa225b2414","modified":1612400574288},{"_id":"public/categories/index.html","hash":"2685fb7b96d64196a21f5af17e84724a9dd27414","modified":1612400574288},{"_id":"public/about/index.html","hash":"7c38874ebefbe6e2c9f706671836627e04888ca4","modified":1612400574288},{"_id":"public/tags/index.html","hash":"9d1bdea7db4e12461b8467bc889bd2312e752829","modified":1612400574288},{"_id":"public/404/index.html","hash":"5a295c69f99240475296b88d4aeb6f33b75e90a1","modified":1612400574288},{"_id":"public/contact/index.html","hash":"35e2554c10a03f619445e80689a1e8f5df093b79","modified":1612400574288},{"_id":"public/friends/index.html","hash":"6360919c320ec59cf954e18d4c9604eff09efe20","modified":1612400574288},{"_id":"public/posts/9ec9055a.html","hash":"85984171f3b3bf194e9197c5de15c8ea02bda6ee","modified":1612400574288},{"_id":"public/posts/3a03a942.html","hash":"7c25a4278818892318985733a5392ca9212414b9","modified":1612400574288},{"_id":"public/posts/d2c6f132.html","hash":"63f4cdd14ce4811e7704d71fcce3b5c146c1a3a2","modified":1612400574288},{"_id":"public/posts/9deeb220.html","hash":"fdc66f3eaa38a7ffa1433bb4ca8c8721dfa888bb","modified":1612400574288},{"_id":"public/posts/4411b5fd.html","hash":"ab1c810671cfb0fc5f18ced5a127032d26f04653","modified":1612400574288},{"_id":"public/posts/6c3751ad.html","hash":"83f2d383d33639ede3c38c2ce3a8bf7d5de48d53","modified":1612400574288},{"_id":"public/posts/49e32910.html","hash":"b39094c48bb7132e94600c9d3763fe7e92639fd7","modified":1612400574288},{"_id":"public/posts/bf34118e.html","hash":"adf2cf6bfd93b776ef87c83576aa3410971d7979","modified":1612400574288},{"_id":"public/posts/eaca0a57.html","hash":"472a6442006af6a0f8559cd91d6e2d2621876abe","modified":1612400574288},{"_id":"public/posts/1ae46459.html","hash":"5b50ba6f000f616e96fd35600bf6c5c74f06c1dc","modified":1612400574288},{"_id":"public/posts/2edde9de.html","hash":"63beea65a0044304f10672f3687c35d23820c51a","modified":1612400574288},{"_id":"public/posts/73458eba.html","hash":"da64214bfbcce86dfd27f6767dbd8d9bc548c5b0","modified":1612400574288},{"_id":"public/posts/5631a281.html","hash":"58f61dfc06cdb21afd0dc1bbfad051fbe8eb06d1","modified":1612400574288},{"_id":"public/posts/4f7140bc.html","hash":"873e52127dda6a959805c123ac71662237c71910","modified":1612400574288},{"_id":"public/posts/256ce7dc.html","hash":"9856096ee46c4a638552c1537f5c99bf3edc70c7","modified":1612400574288},{"_id":"public/posts/3c67b570.html","hash":"befcf2efa199cfa9b34ac1d037f6084684849679","modified":1612400574288},{"_id":"public/posts/6bd9c708.html","hash":"86e9202cc55e666ca64a1da4f16865456eb1eb25","modified":1612400574288},{"_id":"public/posts/e41403a7.html","hash":"7898ff1ae27b5a65f18f687c1852c3d04612b191","modified":1612400574288},{"_id":"public/posts/f70eccfd.html","hash":"29c3933f618b721603c5c2d7da8c8661ab11daaa","modified":1612400574288},{"_id":"public/posts/ec339b68.html","hash":"143d55359df5a8cb59b36b6a3a7e84e94fae2e02","modified":1612400574288},{"_id":"public/posts/4bdc9a59.html","hash":"74cfbea8ddf3d089af1099cf1781a9d35b96a4f1","modified":1612400574288},{"_id":"public/posts/b89933c6.html","hash":"36561f0c37555d0658daa9cf8764e2cc9747a75b","modified":1612400574288},{"_id":"public/posts/98f870a2.html","hash":"271c107f7d1d1ab65620253dfebc7af5a9504daf","modified":1612400574288},{"_id":"public/posts/2e019a64.html","hash":"ab4b6824f9bf06fba32c90d026367465126415c3","modified":1612400574288},{"_id":"public/posts/a5c35f1a.html","hash":"95c446ac05630cabb39610a6cad83f48d91c1360","modified":1612400574288},{"_id":"public/posts/7730ae65.html","hash":"013767229c429892167bdd145347b24910a90544","modified":1612400574288},{"_id":"public/posts/267cb657.html","hash":"719410900c1da1f9241ba5af7c710d55eed9fc71","modified":1612400574288},{"_id":"public/posts/98ef9b01.html","hash":"b219d052b392fd910b7cf4a248aa9eefe3cbeac5","modified":1612400574288},{"_id":"public/posts/80a83e6.html","hash":"afc8b4a6ad58c4fc13f26deb2496c069274141e9","modified":1612400574288},{"_id":"public/posts/eee4fbd1.html","hash":"bac17d76d990c980c679379f4598ef6dcebc7b2c","modified":1612400574288},{"_id":"public/posts/f6b4575b.html","hash":"394b29dafb10b37cabead04552479f1f593f1319","modified":1612400574288},{"_id":"public/posts/a3175fad.html","hash":"34a18b0aa9037e1819d74d8c4f04b886c6b5c526","modified":1612400574288},{"_id":"public/posts/cbdc6ef6.html","hash":"24960e734b4b006a5757d015fff557fa7d9f47cd","modified":1612400574288},{"_id":"public/posts/e6a53be5.html","hash":"ed42c1c822de1661e131eb64d4ec0138efca7212","modified":1612400574288},{"_id":"public/posts/27ebf426.html","hash":"696088733c5d2a2ade71390588425e4b47d7ba54","modified":1612400574288},{"_id":"public/posts/4ea31ca4.html","hash":"9837d6b13abe3136be0bdd828b019e44710268ee","modified":1612400574288},{"_id":"public/posts/303ff37b.html","hash":"cd3a5c28343ca5aa66fb9594174468ebac72dcbd","modified":1612400574288},{"_id":"public/posts/1ecd581d.html","hash":"1183de96256b868cee973d6110821ec7f3ba31f2","modified":1612400574288},{"_id":"public/posts/b379f77c.html","hash":"d8a2e5a28ff7dba567d9ab4475fab0f3390739bc","modified":1612400574288},{"_id":"public/posts/9f1ebbb4.html","hash":"790d2c49aabaf59e6351d57ed5d28f3ead5959b8","modified":1612400574288},{"_id":"public/posts/27a1f8de.html","hash":"d30606435cea29669ac6bc988018f8e5f8b78722","modified":1612400574288},{"_id":"public/posts/ce3193b6.html","hash":"8234003bcfb8a3d1932f303890729c4546c90fff","modified":1612400574288},{"_id":"public/posts/78dd2f11.html","hash":"264cd651065fb622ab11b272a149c6d601bc10c5","modified":1612400574288},{"_id":"public/posts/db5a7195.html","hash":"7809df08e3458ba8e5e16a09773f80fd7503fc2b","modified":1612400574288},{"_id":"public/posts/c3f1ef69.html","hash":"da4ad282368f44c3a41acf9f04e5241696e9b4e0","modified":1612400574288},{"_id":"public/posts/65fb0b69.html","hash":"cde8f776cbc928bd481fa84827e8317f1d7dfcb5","modified":1612400574288},{"_id":"public/posts/95af1e01.html","hash":"5c5d94e690eabca7c01679836c7192e376acaed3","modified":1612400574288},{"_id":"public/posts/988064b3.html","hash":"f81ac8dd6395c79f02085a3fe3ac2dd25dad02a0","modified":1612400574288},{"_id":"public/posts/92288fa0.html","hash":"61ced84e753358bbee90ac63d5061c49ddf59054","modified":1612400574288},{"_id":"public/posts/b05d8834.html","hash":"720152965359ba1247df0d103b215c43534e01d1","modified":1612400574288},{"_id":"public/posts/6fa1fa98.html","hash":"a9c01aad9df8d94e33ddfa085693c075604da383","modified":1612400574288},{"_id":"public/posts/7dd93822.html","hash":"14711d4130a8411c2597563018dfba91e73ca68e","modified":1612400574288},{"_id":"public/posts/50d6952b.html","hash":"010f291f0a480fdbe97b817d85daf755be36e354","modified":1612400574288},{"_id":"public/posts/f5d941ba.html","hash":"a6846c7cc38f0c64806d2b9b67619a4f46d96c2d","modified":1612400574288},{"_id":"public/posts/7b573481.html","hash":"ddc48c7cdead3daf7cb455773e8fec4c436510fb","modified":1612400574288},{"_id":"public/posts/17a31575.html","hash":"23ea03824f2fe15029685796a75a39ea201435d3","modified":1612400574288},{"_id":"public/posts/5e9da042.html","hash":"7fa4c78fa23ea53eb8045cf215cccd48b522120f","modified":1612400574288},{"_id":"public/posts/89c780d6.html","hash":"b6eb678400f0636ec2d3b5f13feba36e12744aae","modified":1612400574288},{"_id":"public/posts/70095889.html","hash":"87a9a95d0ad7777d584ae0a9c7e4740c04ce8a57","modified":1612400574288},{"_id":"public/posts/97b1758e.html","hash":"79828e08cc4f03b509f954e1e956c3b16b04f931","modified":1612400574288},{"_id":"public/posts/90dcb197.html","hash":"0f19a6f2a7f90dde3bed57465ca49e0be380e1c9","modified":1612400574288},{"_id":"public/posts/9d5e02d.html","hash":"7cd42dcf07e8c78637c5d907e10042db75598c3d","modified":1612400574288},{"_id":"public/posts/484ffed8.html","hash":"227cc149dcce3d25b55ab9568e5b759d9c45bfc9","modified":1612400574288},{"_id":"public/posts/d8f0e349.html","hash":"1590e5fe7f4c2c3ce959a87fb3c525659257647f","modified":1612400574288},{"_id":"public/posts/4ef3d1ce.html","hash":"52001deab2da9d038a9af8e50b2fb5da0297a68a","modified":1612400574288},{"_id":"public/posts/5f8f47ab.html","hash":"6a0a289a7d6517474d77f1246b67bf9247dc6712","modified":1612400574288},{"_id":"public/posts/4c8e0e7.html","hash":"78724a57d54defd3cd10f7827e9262c03cf3ee70","modified":1612400574288},{"_id":"public/posts/d398cc0d.html","hash":"af5ae2e9f2640f1d9ec664b37f2ea70c4a1bcd11","modified":1612400574288},{"_id":"public/posts/6ad4e130.html","hash":"a34e25d4f182fdfae14b1c1ae7ab4af1a326fdb2","modified":1612400574288},{"_id":"public/posts/1c948532.html","hash":"38494f615b818d7510598717ca8ab8497625ebd1","modified":1612400574288},{"_id":"public/posts/1dd3d1a6.html","hash":"486df9d3a3bb232b0d4fa1cbea5266c9510b279b","modified":1612400574288},{"_id":"public/posts/f4b07493.html","hash":"893062541b0596ce9f2e06aa97c6e5ed297be83e","modified":1612400574288},{"_id":"public/posts/6db92529.html","hash":"81404f4b3548d3ff15ad103642a7075fb6804dd3","modified":1612400574288},{"_id":"public/posts/8f00f39.html","hash":"9fd45e3a4c8db00e869fcff0a3fbf1d69c07dbdd","modified":1612400574288},{"_id":"public/posts/ada9b038.html","hash":"db1b8ae32eb13b61b50f2cc5b7fd6fcc12514dcc","modified":1612400574288},{"_id":"public/posts/4a119d3f.html","hash":"03caa9bac2ca50b704563c2dfbecf89d0bafc68a","modified":1612400574288},{"_id":"public/posts/1a7d60e1.html","hash":"a45eff632e16c2c621ef7f7cce556f81cfefc119","modified":1612400574288},{"_id":"public/posts/bd04cd52.html","hash":"ee4c574c8a69edde29050085b651cf6632155486","modified":1612400574288},{"_id":"public/posts/a41ffc13.html","hash":"11f2cb6d0922a873891a0752b2a27ca5fb13b864","modified":1612400574288},{"_id":"public/posts/a8f59b26.html","hash":"cda363f48149c4b4c302abccad51ac6209dfd3d0","modified":1612400574288},{"_id":"public/posts/442dad20.html","hash":"7bdf1e2cc682c41ced07a535e92f728537bba1d0","modified":1612400574288},{"_id":"public/posts/332a9db6.html","hash":"bfa13aa51b0cc6847ab4bea31d2c4c2b66abd9d8","modified":1612400574288},{"_id":"public/posts/4d9be10b.html","hash":"922174f6c15d2a6b14e4316b1a30ff44d0055af3","modified":1612400574288},{"_id":"public/posts/d492b0b1.html","hash":"ce44201524248e7d3587a56c7790d584b6049959","modified":1612400574288},{"_id":"public/posts/d3ff74a8.html","hash":"50656ea855bcac841840600155fd733b4f2b992c","modified":1612400574288},{"_id":"public/posts/3df11584.html","hash":"1aff1f562fb16f8eb56f57c03597fae8b1742370","modified":1612400574288},{"_id":"public/posts/2387e0dc.html","hash":"1def21132780380ae7061eabc487adc08cbf804f","modified":1612400574288},{"_id":"public/posts/cae445e9.html","hash":"35a78176efb90f6cf3536210b5825e676719d45a","modified":1612400574288},{"_id":"public/posts/7fad8389.html","hash":"e45b5367bb3e7b0143f2f42a1c21cb3379a3ac29","modified":1612400574288},{"_id":"public/posts/e6a4d233.html","hash":"e477dc49a46d7c87cf4392ef2f89e88bc2325690","modified":1612400574288},{"_id":"public/posts/96ce26bc.html","hash":"0491caff21067176430f8cd4f6635b73a39a7080","modified":1612400574288},{"_id":"public/posts/1807ce75.html","hash":"84d73fae9c257de6f11123bc5fd9d6765c4ef235","modified":1612400574288},{"_id":"public/posts/6f00fee3.html","hash":"63cb53d40516a841806dd3a5e3d7c7f21264686d","modified":1612400574288},{"_id":"public/posts/ffbfe372.html","hash":"adf75bc11d11f0c0663c11e46dc8d13d556befd4","modified":1612400574288},{"_id":"public/posts/f8d2276b.html","hash":"037eed9bfa9f2c9c5f9e16f17fa9bd0630e7354b","modified":1612400574288},{"_id":"public/posts/e0571985.html","hash":"0a610d0b777249119be170b375640991286e1bcb","modified":1612400574288},{"_id":"public/posts/5ef01499.html","hash":"4cc1a6e9d8eff036eeb5fb184ca92e7e59353f8c","modified":1612400574288},{"_id":"public/posts/20416824.html","hash":"5daf16d5ea8ef0c4f02ad6fd3ef12083b2bda6fb","modified":1612400574288},{"_id":"public/posts/b793b1ac.html","hash":"aa054145154fa633c62b162186757a48dbe86bc5","modified":1612400574288},{"_id":"public/posts/c094813a.html","hash":"d3d4f24c16edcb6d6c0a3fe13882799159b51bfa","modified":1612400574288},{"_id":"public/posts/2e9ae016.html","hash":"12196ca9d85cecc397399963df59b603cd18e388","modified":1612400574288},{"_id":"public/posts/d98fb07b.html","hash":"b5ca24ad1282c875aa1646e851f7286390e803cf","modified":1612400574288},{"_id":"public/posts/ae8880ed.html","hash":"749b7aaff5a0081f4aeadfe3dbafba2e53553d17","modified":1612400574288},{"_id":"public/posts/3781d157.html","hash":"af4f1d05dc2cb02e122d65c45df0c300da18b3fe","modified":1612400574288},{"_id":"public/posts/4086e1c1.html","hash":"3b509995d08a59308c6b347802dda7d4d689f27e","modified":1612400574288},{"_id":"public/posts/12770aa6.html","hash":"eb811e31f81ac9463b374a946479df41dfa0c3c0","modified":1612400574288},{"_id":"public/posts/f5cf27a1.html","hash":"c982649ba42e642c41be66fd112dd6c37f794371","modified":1612400574288},{"_id":"public/posts/1bc1468d.html","hash":"b969ad60fb05a7c83b72ccdb08e80e80d20e21b3","modified":1612400574288},{"_id":"public/posts/582aa7a5.html","hash":"442f48dc38946721b5913fcbbbfeb8167ea134da","modified":1612400574288},{"_id":"public/posts/1cac8294.html","hash":"d4db0a86b45efeaac0d017ec6ae9975e2b4b0c04","modified":1612400574288},{"_id":"public/posts/6babb202.html","hash":"b22207b61939b94068c21a7a1f274149d8be58fb","modified":1612400574288},{"_id":"public/posts/75dd475a.html","hash":"d55492a484272065ce6e4e787619ed67a9034b8e","modified":1612400574288},{"_id":"public/posts/ebb9d2f9.html","hash":"071e10c5cfe749b43aa3c1fe2fb5dc23ade5c643","modified":1612400574288},{"_id":"public/posts/2da77cc.html","hash":"5a0159bf9a200b3e3b80a1065274e8190443378f","modified":1612400574288},{"_id":"public/posts/5b7b3d5.html","hash":"48b1528471824108f02f9f2a3270a646d33e86a5","modified":1612400574288},{"_id":"public/posts/9cbee26f.html","hash":"f51020ff34a97f8cbda79fcdadbdb6459a931ff7","modified":1612400574288},{"_id":"public/posts/2d8f53b2.html","hash":"e11fa232e6332520bf180c32fb647249090e55ae","modified":1612400574288},{"_id":"public/posts/1a12af4c.html","hash":"144e7fec94f4a2144aaf529819c00716d801ec4f","modified":1612400574288},{"_id":"public/posts/d70d769a.html","hash":"1f968a48663787e9692d951acce7525080619eb5","modified":1612400574288},{"_id":"public/posts/a0a3a5a1.html","hash":"14c0d64a6a5c0ade16d1df02251fa705120e6aa2","modified":1612400574288},{"_id":"public/posts/e7b0c3c0.html","hash":"71ef58c2f1490ade19dfd6246401de7c88cde063","modified":1612400574288},{"_id":"public/posts/48185b72.html","hash":"be8006d7953ce0fc642efd3d328ed17899c4d533","modified":1612400574288},{"_id":"public/posts/80898847.html","hash":"a1671b5b7236263333bfea358deaa8a7d884dcb6","modified":1612400574288},{"_id":"public/posts/31c6b392.html","hash":"ae82976b7641a07fa817767f7a740f4593f2278f","modified":1612400574288},{"_id":"public/posts/8768c3df.html","hash":"6b59d986c3cfe19e67202d498d39b7011fd682b7","modified":1612400574288},{"_id":"public/posts/e550d2e.html","hash":"982a70c3a1148f2390f2f7c73f6169442328e5e2","modified":1612400574288},{"_id":"public/posts/629471e8.html","hash":"85f9a26ec56815e40f45e78fed9cf16d34e972dc","modified":1612400574288},{"_id":"public/posts/38c2cf7b.html","hash":"597ad7a839582c02ff8eabab5f7cb8ed8d2b8369","modified":1612400574288},{"_id":"public/posts/ada3a5c8.html","hash":"6727e97f106c38f97c6f6ccb6d9ddc4927bf02c7","modified":1612400574288},{"_id":"public/posts/649c347b.html","hash":"173c0a236f99cc7cd1712fe55c6e8d8f5fc9492e","modified":1612400574288},{"_id":"public/posts/d9face0f.html","hash":"2e70cb3f1b694d4c4036fc13cb1562ad8084f350","modified":1612400574288},{"_id":"public/posts/26a57fef.html","hash":"c7c178c91ec3b024ee9f18426e8abeb1695f5cc0","modified":1612400574288},{"_id":"public/posts/bee2295f.html","hash":"c93459c4784b42f86ccf2b29d9c6c9a52e844b90","modified":1612400574288},{"_id":"public/posts/96c9e0d0.html","hash":"6dbbaf2629f0171bb8e752fa93194528655faf1f","modified":1612400574288},{"_id":"public/posts/cdafbbdb.html","hash":"b7ac0ed48d5da641ec584569b6fdd4925799eff2","modified":1612400574288},{"_id":"public/posts/12863071.html","hash":"f887bd36ca9f3caaa4ba940b852e036bba7065f5","modified":1612400574288},{"_id":"public/archives/index.html","hash":"e155e3c0315d883fb4de051ab3592025e9089d2e","modified":1612400574288},{"_id":"public/archives/page/2/index.html","hash":"a245c6c12e4ca6f756aaea0bddc7775ef1668266","modified":1612400574288},{"_id":"public/archives/page/3/index.html","hash":"d9200d543131fe10d058457c321bdce3d490c969","modified":1612400574288},{"_id":"public/archives/page/4/index.html","hash":"46deccf4e4d5397a5b97464cdfe80796fef5d599","modified":1612400574288},{"_id":"public/archives/page/5/index.html","hash":"85c44b1d48ef004f339600fae07db76abb67a11a","modified":1612400574288},{"_id":"public/archives/page/6/index.html","hash":"a6174b53eb00865f2e9ea386acf88ec5d8e6b98b","modified":1612400574288},{"_id":"public/archives/page/7/index.html","hash":"d74676a658328fccc377a3e53be87858a25e9549","modified":1612400574288},{"_id":"public/archives/page/8/index.html","hash":"fdd1cc47762f032c6a474dad96dc46a5bb22ec00","modified":1612400574288},{"_id":"public/archives/page/9/index.html","hash":"798fbdc5b4f33d5fc4d181c904535d20829cf78f","modified":1612400574288},{"_id":"public/archives/page/10/index.html","hash":"51f244b4c6758f5123292f3c205aa9d5a30d4e78","modified":1612400574288},{"_id":"public/archives/page/11/index.html","hash":"a44c946682c76e2ed0f39e9c11da3b1277e2f82c","modified":1612400574288},{"_id":"public/archives/page/12/index.html","hash":"ef0d0cda791c31be7971dc2d0e681b416ee5d884","modified":1612400574288},{"_id":"public/archives/2019/index.html","hash":"f8e768cc02df45c561f26069dab8d0526ab2c13a","modified":1612400574288},{"_id":"public/archives/2019/12/index.html","hash":"d81511d33d12b9703c245a059cb4c10de6ed205b","modified":1612400574288},{"_id":"public/archives/2020/index.html","hash":"7665466e803a11085e33c640dcd65e75c122ce5a","modified":1612400574288},{"_id":"public/archives/2020/page/2/index.html","hash":"4a117bdaa2714c1009af6805636ed81b65bca26a","modified":1612400574288},{"_id":"public/archives/2020/page/4/index.html","hash":"85316f86ba1a83653f86331a0cfef3829d143322","modified":1612400574288},{"_id":"public/archives/2020/page/3/index.html","hash":"0466af4f06a6aa09e8ea1d852d4304181e8e8d5d","modified":1612400574288},{"_id":"public/archives/2020/page/5/index.html","hash":"87bafd5e6977aab76f2c498630958b3253bec0e7","modified":1612400574288},{"_id":"public/archives/2020/page/6/index.html","hash":"933cdbd6ffba595eef837b3aa076028cd14152ff","modified":1612400574288},{"_id":"public/archives/2020/page/8/index.html","hash":"1b334fe7a2a95432393b168c0058ecc1dab46a4a","modified":1612400574288},{"_id":"public/archives/2020/page/7/index.html","hash":"afc8f13beb7502dd7bb16b82c9567180739c9375","modified":1612400574288},{"_id":"public/archives/2020/page/9/index.html","hash":"642d52fdeb1e985513111fc8e9237fd3edc4680f","modified":1612400574288},{"_id":"public/archives/2020/page/10/index.html","hash":"e090c59482b1e345ebd6884c961fff82d6398cec","modified":1612400574288},{"_id":"public/archives/2020/page/11/index.html","hash":"0dee93996f8b9046f0dc71124ac4a01220778376","modified":1612400574288},{"_id":"public/archives/2020/page/12/index.html","hash":"d4e6011dafbc4884ce543fa024b2b28d55d54cfa","modified":1612400574288},{"_id":"public/archives/2020/01/index.html","hash":"6b641071664df48b2e9476f07620cc8c33afbe6a","modified":1612400574288},{"_id":"public/archives/2020/02/index.html","hash":"1b24eecffcbecb652dbabd05e6528e5ceba8406e","modified":1612400574288},{"_id":"public/archives/2020/03/index.html","hash":"388cb995c6106552396b0ac3388109fcfdfba199","modified":1612400574288},{"_id":"public/archives/2020/03/page/2/index.html","hash":"47764cccb91d740a8bb6e2413d36a36bde4fd8da","modified":1612400574288},{"_id":"public/archives/2020/04/index.html","hash":"c622a5eed775694d92948f5ef6fb65fde4bef5a0","modified":1612400574288},{"_id":"public/archives/2020/04/page/2/index.html","hash":"a755851bef70887adf1908b1b97c3cf39e454809","modified":1612400574288},{"_id":"public/archives/2020/05/index.html","hash":"077aaa6d6083c2409c13895a35b302c69cbe2334","modified":1612400574288},{"_id":"public/archives/2020/06/index.html","hash":"b3a1f40237fbd9faeeec33820fb753d38d560bff","modified":1612400574288},{"_id":"public/archives/2020/05/page/2/index.html","hash":"bf0627188d4298a50c579ad54cfa6d4b057c3440","modified":1612400574288},{"_id":"public/archives/2020/07/index.html","hash":"dd25aca86eb24ccfab0c3bc58595d426a41c3456","modified":1612400574288},{"_id":"public/archives/2020/07/page/2/index.html","hash":"6c4098538aa9cdaf1f7758f784cfffdde20bb4bf","modified":1612400574288},{"_id":"public/archives/2020/08/index.html","hash":"9484faee22bb57fe83c08881d41ed74449f6bd88","modified":1612400574288},{"_id":"public/archives/2020/09/index.html","hash":"e40bce9727c19c0bbb290fc10eec43d366c5ce84","modified":1612400574288},{"_id":"public/archives/2020/10/index.html","hash":"9a116894dbb54ca0b7fd6de0391d4b8155e12f4e","modified":1612400574288},{"_id":"public/archives/2020/10/page/2/index.html","hash":"01366ff8fb7eb306f5f0684c420f179ec845ba82","modified":1612400574288},{"_id":"public/archives/2020/11/index.html","hash":"ff407d59181f5ce41f3d57b222745ec1f52aedfb","modified":1612400574288},{"_id":"public/categories/JVM学习笔记/index.html","hash":"c53aa872ce4dbc8691f255465b0a283c773b453d","modified":1612400574288},{"_id":"public/categories/Redis学习笔记/index.html","hash":"8a072d85936efae7bbd54b03c419d7312ac8fdaa","modified":1612400574288},{"_id":"public/categories/Java基础/index.html","hash":"733f7dd86ea2f6ba6b3e9ac4fee6c2a8811ab389","modified":1612400574288},{"_id":"public/categories/常用工具/index.html","hash":"0a3eb7f1578b6235f51cf2568dd8af620e238de8","modified":1612400574288},{"_id":"public/categories/常用工具/page/2/index.html","hash":"9875d126eef62402b82ea1bc728ee5f6357d91db","modified":1612400574288},{"_id":"public/categories/LeetCode笔记/index.html","hash":"76f8fbe4204430314776f39adb3714db4aa506ac","modified":1612400574288},{"_id":"public/categories/LeetCode笔记/page/2/index.html","hash":"ae547881e97ef18ded6c17c32276c6c243c5fd48","modified":1612400574288},{"_id":"public/categories/LeetCode笔记/page/3/index.html","hash":"3c0cf83f75038db05d0e5eb82d807a5faa0f51a0","modified":1612400574288},{"_id":"public/categories/LeetCode笔记/page/4/index.html","hash":"b62455783eb40139f70d02afb0379a8cd69a7d8f","modified":1612400574288},{"_id":"public/categories/LeetCode笔记/page/5/index.html","hash":"6570d083bdb874bef6e641bc1da404e5489afaf7","modified":1612400574288},{"_id":"public/categories/计算机网络/index.html","hash":"1fd92c9cf922a4df2901dc52a3048eb0ec310f79","modified":1612400574288},{"_id":"public/categories/项目文档/page/2/index.html","hash":"74174aad116c5a4ed95bb5a917d03a2c35ab0597","modified":1612400574288},{"_id":"public/categories/项目文档/index.html","hash":"d948fcdc9432bb62fcce6d65c3fd51d99ad63889","modified":1612400574288},{"_id":"public/categories/Java编程思想/index.html","hash":"051889bf46c252fdfd2d3b60e6ba5bb0c738c929","modified":1612400574288},{"_id":"public/categories/设计模式笔记/index.html","hash":"fd91227bedeaff840327597a7b53a5db3a359a30","modified":1612400574288},{"_id":"public/index.html","hash":"33edbaf013df48a61d8473f82f00fde391316930","modified":1612400574288},{"_id":"public/page/2/index.html","hash":"4ce9daa1c9b8f79d3c33015a01e58d97d91aea70","modified":1612400574288},{"_id":"public/page/3/index.html","hash":"3374c855f48db7d9db0fa6fccf792012a8416d8a","modified":1612400574288},{"_id":"public/page/4/index.html","hash":"687a791ec595bc9d2f9249eefee851a61926a505","modified":1612400574288},{"_id":"public/page/5/index.html","hash":"5a52be31f53122adb0e8677d1f0ec07c00922735","modified":1612400574288},{"_id":"public/page/6/index.html","hash":"145ed75f8ac89f37b78f306a673591dc2502e94d","modified":1612400574288},{"_id":"public/page/7/index.html","hash":"0e13e9abfce5a057469b862126d0f3896d384737","modified":1612400574288},{"_id":"public/page/8/index.html","hash":"70db3f051f6fc014d6c637c36ce6aa6a3687d844","modified":1612400574288},{"_id":"public/page/9/index.html","hash":"02c235dc1c2ff5dd3def50c26e30cfd77352a4a0","modified":1612400574288},{"_id":"public/page/10/index.html","hash":"abf645c15e03942c6329dd8e8890f56ea394eecb","modified":1612400574288},{"_id":"public/page/11/index.html","hash":"c7c8554516d05d117c333bef12da75c9e16a88ae","modified":1612400574288},{"_id":"public/page/12/index.html","hash":"c04853b8ede06f656df15e0422da6826f737d09b","modified":1612400574288},{"_id":"public/tags/深入理解Java虚拟机/index.html","hash":"c640e2f6bbfbdbd1f9a20a165d5e7a92dcabac23","modified":1612400574288},{"_id":"public/tags/JVM/index.html","hash":"1a191f3721155cbdc0586b4f77243cb8c5092649","modified":1612400574288},{"_id":"public/tags/编译器/index.html","hash":"6f3cfcf1684a2714d7a9d53355525e09a6d155b4","modified":1612400574288},{"_id":"public/tags/Javac/index.html","hash":"d62260771de364eb56ae0ed89a744f32a2a3507e","modified":1612400574288},{"_id":"public/tags/语法糖/index.html","hash":"25a925c5b0a6c1b56d39e2da83d710d401b89b1d","modified":1612400574288},{"_id":"public/tags/线程/index.html","hash":"f86ddb2c3458f326732aa6e71284b76ef281172e","modified":1612400574288},{"_id":"public/tags/锁/index.html","hash":"3a35546bdc454c753fb2b8ec83ef1fb0e4d317fb","modified":1612400574288},{"_id":"public/tags/内存模型/index.html","hash":"c548cc0cf39b70a86e743daec91db75ec95fed02","modified":1612400574288},{"_id":"public/tags/运行时数据区/index.html","hash":"49d759e35fbbc503d9fd688024f50d53cee543a2","modified":1612400574288},{"_id":"public/tags/垃圾收集器/index.html","hash":"b9a54ec5c6d596922e06abb3e43c14bfba635511","modified":1612400574288},{"_id":"public/tags/Class/index.html","hash":"5471bf1aa18f0dee1f56a6730c37c11b6510d0b2","modified":1612400574288},{"_id":"public/tags/Java基础/index.html","hash":"a9ea23c2e2adc7fb6177d893698127adb060e4a4","modified":1612400574288},{"_id":"public/tags/Java基础/page/2/index.html","hash":"1b8bdac1b6462cfaaaeb71136c4b25b1e0877d6d","modified":1612400574288},{"_id":"public/tags/JavaWeb/index.html","hash":"d1a78960a769660aaa2e3b8b10a488e8792a35cb","modified":1612400574288},{"_id":"public/tags/栈帧/index.html","hash":"507bb17a0bdb2ea586a82024364da5027cec9b72","modified":1612400574288},{"_id":"public/tags/方法调用/index.html","hash":"f65646fbef12fc67515da4d75acc3cc94f048901","modified":1612400574288},{"_id":"public/tags/类加载器/index.html","hash":"d22f22d1bbd5028e671a5bae273e4d6c0ac32c9a","modified":1612400574288},{"_id":"public/tags/IO/index.html","hash":"e28cede678ec5e2dd6bf14580754b7f2582ddb6e","modified":1612400574288},{"_id":"public/tags/对象/index.html","hash":"d450d159d9b800466e03075930222698acebdf66","modified":1612400574288},{"_id":"public/tags/异常/index.html","hash":"ae09527f43c092032a312626c22c350e1b81d9dc","modified":1612400574288},{"_id":"public/tags/String/index.html","hash":"9cb13b09be42a26cf08784dc10dea751e9020b06","modified":1612400574288},{"_id":"public/tags/Redis/index.html","hash":"9fd81e6a61396e5f8fa9b22685ccec8352b9ab95","modified":1612400574288},{"_id":"public/tags/RDB/index.html","hash":"4f007e58ed3a20997e910ba017fd8ec3165c3203","modified":1612400574288},{"_id":"public/tags/数据库/index.html","hash":"f876a02493f656636c02b11bdfca52a473471d13","modified":1612400574288},{"_id":"public/tags/AOF/index.html","hash":"21409431e992f7dd44cb67524ade631da89bf2a0","modified":1612400574288},{"_id":"public/tags/复制/index.html","hash":"16177979474b3a1e60cef4b43abfb898fbec55e0","modified":1612400574288},{"_id":"public/tags/数据结构/index.html","hash":"1bf63d6991d3682a29fd76986c9e984476ce72b0","modified":1612400574288},{"_id":"public/tags/数据结构/page/2/index.html","hash":"b5dc9f18c10cb166b8ae6ab7bf4c8cb6ccf7d64f","modified":1612400574288},{"_id":"public/tags/字符串/index.html","hash":"d5d98648fccc60ead7297681cacc432e3912f344","modified":1612400574288},{"_id":"public/tags/字符串/page/2/index.html","hash":"fe0a046877b30da0688db38bbf35a03528b48bd8","modified":1612400574288},{"_id":"public/tags/字典/index.html","hash":"c2c59ea605f69eb530e3f6b8bc683fd8a711aa8d","modified":1612400574288},{"_id":"public/tags/Sentinel/index.html","hash":"8f0832ab1895f3b41be2e511a74fd657b520f9c9","modified":1612400574288},{"_id":"public/tags/整数集合/index.html","hash":"815340bee3fc11d81ac99c1cbf301d5c4c091936","modified":1612400574288},{"_id":"public/tags/指针/index.html","hash":"c01e1871daccf87e0327569e355d7feeb54b5011","modified":1612400574288},{"_id":"public/tags/链表/index.html","hash":"28b515e63aba58d2ac87579196c83e19011e55d8","modified":1612400574288},{"_id":"public/tags/跳跃表/index.html","hash":"f32aa7a1396f4e87d4b519f08135b784ca4475e4","modified":1612400574288},{"_id":"public/tags/压缩列表/index.html","hash":"a5650d8a30c9d18bca2ba98d1639ddab41dc5201","modified":1612400574288},{"_id":"public/tags/工具/page/2/index.html","hash":"3603fd020112fea79f4888e7d1f70b150d2fac15","modified":1612400574288},{"_id":"public/tags/工具/index.html","hash":"adcc5af35595efa04d9f80a03ab1dde7a571bb00","modified":1612400574288},{"_id":"public/tags/NLP/index.html","hash":"7e2bebc1ab2d87212566a9316b7e93cf84bc8910","modified":1612400574288},{"_id":"public/tags/Hadoop/index.html","hash":"a86dde6ebc8959ad9084e45ddfc7ac08e897fb7c","modified":1612400574288},{"_id":"public/tags/Vue/index.html","hash":"f4859c1bc296e7e302ad85b0336d98532623dd1f","modified":1612400574288},{"_id":"public/tags/VMware/index.html","hash":"a134f5b311a3701c96af95ceaaf5c6cec0486f51","modified":1612400574288},{"_id":"public/tags/markdown/index.html","hash":"904f8ccc35d30916c2d273ae2ff45eb3e0ffd6b6","modified":1612400574288},{"_id":"public/tags/Docker/index.html","hash":"438bae1429192b256750838e1524f1543c9ea3e2","modified":1612400574288},{"_id":"public/tags/idea/index.html","hash":"891d3560c91df4b538105243865ca17ab0540502","modified":1612400574288},{"_id":"public/tags/hexo/index.html","hash":"8f097e6172af407f2cc264559335c93d8a1936ce","modified":1612400574288},{"_id":"public/tags/linux/index.html","hash":"0ee941db069b8ae24e0c48e7f810d44a3f3ab32b","modified":1612400574288},{"_id":"public/tags/图床/index.html","hash":"8717bf2079f151e08d9cdb4bb51244545418e2cf","modified":1612400574288},{"_id":"public/tags/SSH/index.html","hash":"6e905c6295a309b5f11f5f8ec7ef50e355704072","modified":1612400574288},{"_id":"public/tags/windows/index.html","hash":"d0c0555a4b768aa956559af10ecfeb1d4535bbe8","modified":1612400574288},{"_id":"public/tags/LeetCode/page/2/index.html","hash":"94717ace75acc0cf764ccba1e9deb7ef8a3e76f9","modified":1612400574288},{"_id":"public/tags/LeetCode/index.html","hash":"687cb4f6d24040586eb4f354f5c213aae7987260","modified":1612400574288},{"_id":"public/tags/LeetCode/page/3/index.html","hash":"88f33b6e4615a09d9754482df687f4466ba8c5de","modified":1612400574288},{"_id":"public/tags/LeetCode/page/5/index.html","hash":"e86cffb8631546ccff199c3b8026f5e9464f8111","modified":1612400574288},{"_id":"public/tags/LeetCode/page/4/index.html","hash":"e12c71daaa5c1254b1108e89a846913dca07a162","modified":1612400574288},{"_id":"public/tags/Java/page/2/index.html","hash":"e0e4b3f6de59fb3f3c83049dd666e5318de058ef","modified":1612400574288},{"_id":"public/tags/Java/index.html","hash":"483569e371c2b1b5ae07a12c7b28c4df2a088426","modified":1612400574288},{"_id":"public/tags/Java/page/3/index.html","hash":"ceff10b4f7b1791566569b2365eb54599cf4d296","modified":1612400574288},{"_id":"public/tags/Java/page/4/index.html","hash":"4ccfc20ebe0a2946ebcb3e63dbfb89f9f2d800d6","modified":1612400574288},{"_id":"public/tags/HashMap/index.html","hash":"4c6d29c1220f5e5c13c8a4e0a50c4e7570027146","modified":1612400574288},{"_id":"public/tags/二叉树/index.html","hash":"3452a3108e3025a91b3837a0264e809134f5c274","modified":1612400574288},{"_id":"public/tags/递归/index.html","hash":"7759944562f12af548bd28344fa01a5dc5ba774c","modified":1612400574288},{"_id":"public/tags/层次遍历/index.html","hash":"d5933ee50db8cc7d454e1940a9924ed0c00ac978","modified":1612400574288},{"_id":"public/tags/数组/index.html","hash":"9668b2e393b79854af615c43fa41de10adb3fee2","modified":1612400574288},{"_id":"public/tags/算法/index.html","hash":"6ebf6b884cb51a7c8cd48fa61117dea08143c4d5","modified":1612400574288},{"_id":"public/tags/遍历/index.html","hash":"e96223f9dd47ecd370aadbdc074fbf76c244b3a1","modified":1612400574288},{"_id":"public/tags/动态规划/index.html","hash":"55b3d3549b8a5f29c530ed6e192cfbdd797f6d29","modified":1612400574288},{"_id":"public/tags/异或/index.html","hash":"ece6ccc88307615dcd6256df1e90eb8fa6a3225d","modified":1612400574288},{"_id":"public/tags/Map/index.html","hash":"335901049cd6e250be0f139bb7b39028143385f5","modified":1612400574288},{"_id":"public/tags/LRU/index.html","hash":"39351d9c7653fbc652e0add3c65e6422bacc38fe","modified":1612400574288},{"_id":"public/tags/排序/index.html","hash":"4d90a4dd92ee0902f3d31d181b427efec9ec9b81","modified":1612400574288},{"_id":"public/tags/快慢指针/index.html","hash":"a2baceac7a3cb8a544d9a8db950a182089c88bb3","modified":1612400574288},{"_id":"public/tags/栈/index.html","hash":"c5d5ae58050cd8993cf62eb634c748d5c4f4d3e7","modified":1612400574288},{"_id":"public/tags/图/index.html","hash":"367eee8330078ae6ee729c8eeb4d37463c618fbf","modified":1612400574288},{"_id":"public/tags/dfs/index.html","hash":"97faf620115f8a0291e004f355741d15ecea4394","modified":1612400574288},{"_id":"public/tags/树/index.html","hash":"a66dfab54e42a7cb70737f917e66aa60c7f3b37d","modified":1612400574288},{"_id":"public/tags/二维数组/index.html","hash":"f95b18c14c61e2ceb61c637692ec187d489d8116","modified":1612400574288},{"_id":"public/tags/全排列/index.html","hash":"997d196779c1a5decaca0c100cae91a88fa43631","modified":1612400574288},{"_id":"public/tags/归并/index.html","hash":"4c3d312097a0e4eb2129daf181e2ec381726726f","modified":1612400574288},{"_id":"public/tags/二分搜索/index.html","hash":"453158c06be0be9c92b6d15fff1fdb015c573f10","modified":1612400574288},{"_id":"public/tags/回溯/index.html","hash":"2c58a5f731189b629f571099541b7f17b928bc69","modified":1612400574288},{"_id":"public/tags/矩阵/index.html","hash":"830084969d016ca38326c75fda2795926217e2a0","modified":1612400574288},{"_id":"public/tags/快排/index.html","hash":"83f63192419f78cbbbae1363345c3526f04686bb","modified":1612400574288},{"_id":"public/tags/滑动窗口/index.html","hash":"7041a75c45e0801ae9540931f25ea54192df0fb6","modified":1612400574288},{"_id":"public/tags/深搜/index.html","hash":"bd8e8794b99778de9a7a1602baaa162103bc0d75","modified":1612400574288},{"_id":"public/tags/解空间树/index.html","hash":"ecaf65eba1c61874a63c4e4d8741d6d6237f22bf","modified":1612400574288},{"_id":"public/tags/计算机网络/index.html","hash":"1433e087dd0d572613bb0fbaa3c53775597a1208","modified":1612400574288},{"_id":"public/tags/OSI参考模型/index.html","hash":"e082d324bd4942e538e398ea89ac2643957415e9","modified":1612400574288},{"_id":"public/tags/TCP-IP/index.html","hash":"c7c49aecae1c81924544538a490388f88244c21a","modified":1612400574288},{"_id":"public/tags/运输层/index.html","hash":"35e3cae0d0ffb95c5df0c46d81826209b361c595","modified":1612400574288},{"_id":"public/tags/TCP/index.html","hash":"9704d4b81481530cd74ba60b86dedc4bb638772d","modified":1612400574288},{"_id":"public/tags/UDP/index.html","hash":"27bb162fcaf246068046f3b99b3434957cd64557","modified":1612400574288},{"_id":"public/tags/DNS/index.html","hash":"9985e16d1f93a75d2ca05d1107364c72e63034de","modified":1612400574288},{"_id":"public/tags/应用层/index.html","hash":"b643069757c95d24a4e1ba31eca113b480b4dd33","modified":1612400574288},{"_id":"public/tags/HTTP/index.html","hash":"64a8947114e57c068edaa5a5ac22c80910798a34","modified":1612400574288},{"_id":"public/tags/HTML/index.html","hash":"b75d66e9b92478846587caa5a1c3d10b7aa2fd53","modified":1612400574288},{"_id":"public/tags/JavaScript/index.html","hash":"f051987db99c7d303e8170720d3aa8ef386d7e93","modified":1612400574288},{"_id":"public/tags/Springboot/index.html","hash":"7b7d23422a3f847be313b86059ed34f9c6a049dc","modified":1612400574288},{"_id":"public/tags/CSS/index.html","hash":"3f880879066f1da52cd5ee8f1103ea52ba18cd38","modified":1612400574288},{"_id":"public/tags/操作系统/index.html","hash":"0a1a62cda14f2ff6f2b1e9a7ffa175edfb847ea4","modified":1612400574288},{"_id":"public/tags/Swing/index.html","hash":"17faa5bfefbaa5bb38b5f33786fb4f77ba217004","modified":1612400574288},{"_id":"public/tags/内存管理/index.html","hash":"3eeb7c1b2e4e988bdefc83850520e80c65d79b9b","modified":1612400574288},{"_id":"public/tags/文件管理/index.html","hash":"045bedadf51dcc7893ff30e76703e6818c233494","modified":1612400574288},{"_id":"public/tags/操作符/index.html","hash":"35095c303773d7f6d6b682ea4da7d1c79fbefcf6","modified":1612400574288},{"_id":"public/tags/类/index.html","hash":"d14db75fe69d83c2a013286fd471fa18d1290225","modified":1612400574288},{"_id":"public/tags/数据类型/index.html","hash":"5a3b5606471e69b00dbf1d15888700ca7ccbb6b3","modified":1612400574288},{"_id":"public/tags/继承/index.html","hash":"06f8431886c13fcf6f52c831a96598163b704f4d","modified":1612400574288},{"_id":"public/tags/多态/index.html","hash":"33d3551efb652e60acec36ee14c32531af9b396e","modified":1612400574288},{"_id":"public/tags/构造函数/index.html","hash":"cc4e3759e8f21057f21b17a8dbc9eb8a44ea0c9a","modified":1612400574288},{"_id":"public/tags/初始化/index.html","hash":"7aa241558132c43adb6fdb27fae29adac563ffd2","modified":1612400574288},{"_id":"public/tags/类加载/index.html","hash":"f9ba02c842f481f7a5e4907f51b41ecfa462586e","modified":1612400574288},{"_id":"public/tags/修饰符/index.html","hash":"33b20bf49e16e67ad52981114f834641c0ca8a99","modified":1612400574288},{"_id":"public/tags/访问权限/index.html","hash":"c40e2b8d2e1ff9d9bc47345a999a0a09461312bd","modified":1612400574288},{"_id":"public/tags/内部类/index.html","hash":"84b8bb2d4dd56cf3ff2473b8837c093de8490e77","modified":1612400574288},{"_id":"public/tags/Collection/index.html","hash":"d29b4441124830003664cfe4eac4c0830871bb34","modified":1612400574288},{"_id":"public/tags/集合/index.html","hash":"7d0cb24b70b6ccc833580964307c6e52877297ad","modified":1612400574288},{"_id":"public/tags/正则表达式/index.html","hash":"dba80b15e42c6bbd3a42f974b97d39515c055cd2","modified":1612400574288},{"_id":"public/tags/Exception/index.html","hash":"725425c4ce537368043e22015a41bcd777ee2a51","modified":1612400574288},{"_id":"public/tags/反射/index.html","hash":"ae98fd1de4158ff6b8546472aa31e8252efc62d5","modified":1612400574288},{"_id":"public/tags/泛型/index.html","hash":"fdaedf80793a00c0b40d127b206f7359fd92b6e9","modified":1612400574288},{"_id":"public/tags/设计模式/index.html","hash":"d20db6c4579ee9862dc425f555b2dd52e32ea071","modified":1612400574288},{"_id":"public/tags/UML/index.html","hash":"5a708af2a00e4d805a999a2498e90fc80f99aca2","modified":1612400574288},{"_id":"public/tags/c/index.html","hash":"e598940eb577d71d301d17b62f9079f154cfaff2","modified":1612400574288},{"_id":"public/tags/排序算法/index.html","hash":"b2717a20e82947b9ed346278ff4d2277e5247b60","modified":1612400574288},{"_id":"public/tags/快速排序/index.html","hash":"1b59c7250a34af3c8939e6bf02379950f09a6ff2","modified":1612400574288},{"_id":"public/tags/堆/index.html","hash":"27402ae908394a0446f24fe3bc79254ebe2b8eb0","modified":1612400574288},{"_id":"public/tags/最小生成树/index.html","hash":"774eeea6e633d9bcb2e1df8858043dfed630e01f","modified":1612400574288},{"_id":"public/CNAME","hash":"2822f616502c540e80d741ac696406db5084f8af","modified":1612400574288},{"_id":"public/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1612400574288},{"_id":"public/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1612400574288},{"_id":"public/medias/logo.png","hash":"488870f0f476a2349ac258b7c42a4c732eaef5a0","modified":1612400574288},{"_id":"public/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1612400574288},{"_id":"public/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1612400574288},{"_id":"public/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1612400574288},{"_id":"public/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1612400574288},{"_id":"public/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1612400574288},{"_id":"public/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1612400574288},{"_id":"public/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1612400574288},{"_id":"public/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1612400574288},{"_id":"public/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1612400574288},{"_id":"public/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1612400574288},{"_id":"public/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1612400574288},{"_id":"public/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1612400574288},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1612400574288},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1612400574288},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1612400574288},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1612400574288},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1612400574288},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1612400574288},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1612400574288},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1612400574288},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1612400574288},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1612400574288},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1612400574288},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1612400574288},{"_id":"public/css/prism-tomorrow.css","hash":"3b99487dfc9b4e51e9105a93743b92a761840e34","modified":1612400574288},{"_id":"public/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1612400574288},{"_id":"public/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1612400574288},{"_id":"public/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1612400574288},{"_id":"public/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1612400574288},{"_id":"public/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1612400574288},{"_id":"public/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1612400574288},{"_id":"public/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1612400574288},{"_id":"public/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1612400574288},{"_id":"public/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1612400574288},{"_id":"public/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1612400574288},{"_id":"public/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1612400574288},{"_id":"public/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1612400574288},{"_id":"public/medias/reward/wechat.jpg","hash":"4ab47898643c36db9b679e3dfa1dc050ad13e476","modified":1612400574288},{"_id":"public/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1612400574288},{"_id":"public/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1612400574288},{"_id":"public/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1612400574288},{"_id":"public/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1612400574288},{"_id":"public/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1612400574288},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1612400574288},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1612400574288},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1612400574288},{"_id":"public/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1612400574288},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1612400574288},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1612400574288},{"_id":"public/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1612400574288},{"_id":"public/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1612400574288},{"_id":"public/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1612400574288},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1612400574288},{"_id":"public/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1612400574288},{"_id":"public/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1612400574288},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1612400574288},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1612400574288},{"_id":"public/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1612400574288},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1612400574288},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1612400574288},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1612400574288},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1612400574288},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1612400574288},{"_id":"public/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1612400574288},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1612400574288},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1612400574288},{"_id":"public/css/matery.css","hash":"87bd1dacf48c9daab7ea43466368247f1e4107d1","modified":1612400574288},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1612400574288},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1612400574288},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1612400574288},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1612400574288},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1612400574288},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1612400574288},{"_id":"public/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1612400574288},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1612400574288},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1612400574288},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1612400574288},{"_id":"public/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1612400574288},{"_id":"public/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1612400574288},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1612400574288},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1612400574288},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1612400574288},{"_id":"public/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1612400574288},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1612400574288},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1612400574288},{"_id":"public/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1612400574288},{"_id":"public/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1612400574288},{"_id":"public/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1612400574288},{"_id":"public/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1612400574288},{"_id":"public/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1612400574288},{"_id":"public/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1612400574288},{"_id":"public/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1612400574288},{"_id":"public/medias/reward/alipay.jpg","hash":"2d9fc663c295daa53adc716234a018679ea23c3e","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1612400574288},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1612400574288},{"_id":"public/medias/avatar.jpg","hash":"5df0399b8097fc06d8fa3641da3db1a22aaca936","modified":1612400574288},{"_id":"public/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1612400574288},{"_id":"public/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1612400574288}],"Category":[{"name":"JVM学习笔记","_id":"ckkq5o6vm0008jotpdcd18avl"},{"name":"Java基础","_id":"ckkq5o6vy000pjotphv84crnp"},{"name":"Redis学习笔记","_id":"ckkq5o6wc001gjotp1ncuca7s"},{"name":"常用工具","_id":"ckkq5o6wu002ijotp29ww1cdu"},{"name":"LeetCode笔记","_id":"ckkq5o6xc003ujotph3mjhfun"},{"name":"计算机网络","_id":"ckkq5o6z2008fjotp22c677nj"},{"name":"项目文档","_id":"ckkq5o6z6008tjotpf55cbdcd"},{"name":"Java编程思想","_id":"ckkq5o73000mfjotpatau6s66"},{"name":"设计模式笔记","_id":"ckkq5o73f00ndjotp3stefydk"}],"Data":[{"_id":"friends","data":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}],"Page":[{"title":"目录","date":"2020-09-27T09:36:30.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 目录\ndate: 2020-09-27 17:36:30\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2020-09-27T09:37:46.287Z","path":"categories/index.html","comments":1,"_id":"ckkq5o6sy0000jotp3blddr96","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"关于我","date":"2020-07-20T04:01:43.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2020-07-20 12:01:43\ntype: \"about\"\nlayout: \"about\"\n---","updated":"2020-09-27T09:38:35.722Z","path":"about/index.html","comments":1,"_id":"ckkq5o6t10001jotp31zhhhcb","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"404","date":"2020-07-20T05:10:05.000Z","type":"404","layout":"404","description":"Oops～，我崩溃了！找不到你想要的页面 :(","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2020-07-20 13:10:05\ntype: \"404\"\nlayout: \"404\"\ndescription: \"Oops～，我崩溃了！找不到你想要的页面 :(\"\n---","updated":"2020-09-27T09:53:36.358Z","path":"404/index.html","comments":1,"_id":"ckkq5o6t30002jotpfq82hkkc","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"标签","date":"2020-07-20T04:02:07.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-07-20 12:02:07\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2020-09-27T09:37:30.443Z","path":"tags/index.html","comments":1,"_id":"ckkq5o6t40003jotpcedt4w9j","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"友情链接","date":"2020-09-27T09:36:30.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: 友情链接\ndate: 2020-09-27 17:36:30\ntype: \"friends\"\nlayout: \"friends\"\n---","updated":"2020-09-27T14:26:39.511Z","path":"friends/index.html","comments":1,"_id":"ckkq5o6t60004jotp7qgi5c3y","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"留言板","date":"2020-09-27T09:43:59.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: 留言板\ndate: 2020-09-27 17:43:59\ntype: \"contact\"\nlayout: \"contact\"\n---","updated":"2020-09-27T09:46:06.504Z","path":"contact/index.html","comments":1,"_id":"ckkq5o6t80005jotp5mcg86z1","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""}],"Post":[{"title":"深入理解Java虚拟机--后端编译与优化","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习<<深入理解Java虚拟机>>所做的笔记,此为书上第11章--后端编译与优化。","abbrlink":"78dd2f11","date":"2020-07-19T16:00:00.000Z","_content":"\n# 概述\n\n编译器在何时,何种状态下把Class文件转换成与本地基础设施相关的二进制机器码,都可以视为整个编译过程的后端\n\n所以有提前编译器,即时编译器两种\n\n# 即时编译器\n\njava最初都是通过解释器进行解释执行的,当虚拟机发现某个方法或代码块运行特别频繁,就会认为是热点代码,在运行时,则把这些代码编译成本地机器码,并且以各种手段尽可能地进行代码优化\n\n## 解释器与编译器\n\nhotspot虚拟机内部同时包含解释器与编译器,当程序需要迅速启动和执行时,解释器可以首先发挥作用,省去编译时间,立即运行。随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地机器码，减少解释器的中间损耗，获得更高执行效率\n\n解释器节约内存，编译器提高效率\n\n解释器也可以作为编译器激进优化时后备的逃生门，即编译器可能根据概率选大多数提高运行速度的优化手段，但不是每一次都正确的，当激进优化假设不成立时可以通过逆优化退回到解释状态继续执行\n\n内置了两个即时编译器 C1(客户端编译器),C2(服务端编译器)\n\n分层模式之前，采用解释器与其中一个编译器直接搭配的方式工作，虚拟机会根据自身版本和宿主机的硬件性能自动选择运行模式\n\n一般都使用混合模式\n\n### 分层编译\n\n由于即时编译器编译本地代码需要占用程序运行时间，且要编译处优化程度高的代码，所花费时间便越长，为了在程序启动响应速度与运行效率之间取得平衡，就采用分层编译\n\n+ 第0层，纯解释执行，而且解释器不开启性能监控\n+ 第1层，使用C1将字节码编译成本地代码，不开启性能监控\n+ 第2层，使用C1将字节码编译成本地代码，仅开启方法及回边统计等有限的性能监控\n+ 第3层，使用C1将字节码编译成本地代码，开启全部性能监控\n+ 第1层，使用C2将字节码编译成本地代码，开启全部性能监控.还会根据性能监控信息进行一些不可靠的激进优化\n\n实施分层编译后，解释器，C1,C2同时工作，热点代码可能会多次编译，用C1获得更高的编译速度，用C2获得更好的编译质量，在解释执行时也无须额外承担收集性能监控信息的任务，而在C2采用高复杂度的优化算法时，C1可先采用简单优化为他争取更多的编译时间\n\n## 编译对象与触发条件\n\n热点代码:被多次调用的方法,被多次执行的循环体\n\n这两种情况编译的对象都是整个方法体,而不是单独的循环体\n\n对于后者,只是执行入口稍有不同,编译时会传入执行入口点字节码序号,以为编译发生在方法执行过程中,所以叫做栈上替换,即方法的栈帧还在栈上,方法就被替换了\n\n### 热点探测\n\n1. 基于采样的热点探测,虚拟机会周期性的检查各个线程的调用栈顶,如果发现某个方法经常出现在栈顶,就是热点代码。缺点是很难精确的确认一个方法的热度\n2. 基于计数器的热点探测，虚拟机会为每个方法建立计数器，统计方法的执行次数。相对更加精确严谨\n\n### HotSpot虚拟机实现\n\n采用基于计数器的热点探测，准备了方法调用计数器，回边计数器（指循环边界往回跳转），计数器阈值一旦溢出，就触发即时编译。\n\n执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成，当编译工作完成，该方法调用入口就会被系统改为新值，下一次调用该方法就会使用已编译版本\n\n#### 方法调用计数器\n\n方法调用计数器不是方法被调用的绝对次数，而是相对的执行频率，即一段时间内方法被调用的次数。\n\n当超过一段时间，方法的调用次数仍然不足以让它提交到即时编译器编译，则该方法的调用计数器就会减半。这个过程称为方法调用计数器热度的衰减。这段时间称为半衰周期![IMG_20200828_0846415](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200828_0846415.jpg)\n\n#### 回边计数器\n统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为回边，目的是触发栈上的替换编译\n当超过阈值时，将会提交一个栈上替换编译请求，并且把回边计数器值稍微降低，以便继续在解释器中执行循环，等待编译器输出编译结果\n回边计数器没有计数热点衰减，统计的是该方法循环执行的绝对次数\n\n## 编译过程\n默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行\n### 客户端编译器\n是一个相对简单快速的三段式编译器，主要关注点在局部性的优化，而放弃了许多耗时较长的全局优化手段\n1. 一个平台独立的前端将字节码构造成一种高级中间代码表示（HIR）\n2.  一个平台相关的后端将 HIR产生低级中间代码表示（LIR)\n3.  在平台相关的后端使用线性扫描算法，产生机器代码\n\n### 服务端编译器\n专门面向服务端的典型应用场景。是一个能容忍很高优化复杂度的高级编译器。执行大部分经典的优化操作和一些不稳定的预测性的激进优化（如分支频率预测等）\n\n## 实战：查看及分析即使编译结果\nJava虚拟机的即使编译过程对用户和程序都是完全透明的\n空循环在最终的本地代码中实际上是不会执行的\n\n# 提前编译器\n\n## 提前编译的优劣得失\n\n### 两条分支\n\n1. 在程序运行之前把程序代码编译成机器码的静态翻译工作.他的价值就是即时编译器的最大弱点:即时编译要占用程序运行时间和运算资源。所以在静态编译中进行耗时的优化，生成高质量代码。副作用是安装的时候很慢\n2. 把原本即时编译器在运行时要做的编译工作提前做好并保存下来,下次运行这些代码直接把他加载进来使用。本质上是给即时编译器做缓存加速，去改善Java程序的启动时间以及需要一段时间预热才能达到最高性能的问题。可以叫做即时编译缓存。缺点是这种提前编译方式不仅要和目标机器相关，而且还必须与HotSpot虚拟机的运行参数绑定\n\n### 即时编译器的天然优势\n\n#### 性能分析制导优化\n\n在解释器或客户端编译器运行过程中，会不断收集性能监控信息。这些信息一般在静态分析时无法得到，或者不可能存在确定的唯一解。然而在动态运行时却可以明显看出他们的偏好，可以把热点代码集中优化分配资源。\n#### 激进预测性优化\n可以大胆的按照高概率的假设进行优化,万一出错,大不了回退到低价编译器甚至解释器上去执行\n#### 链接时优化\nJava语言天生是动态链接的,一个个Class文件在运行期被加载到虚拟机内存中,然后在即时编译器里产生优化后的代码\n\n# 编译器优化技术\n编译器的目标是由程序代码翻译为本地机器码的过程,但是输出代码优化质量的高低才是决定编译器优秀与否的关键\n即时编译器对代码优化变化是在代码的中间表示或机器码上的,而不是Java源码上的\n优化的代码所达到效果相同,但是省略很多代码语句,体现在字节码和机器码的指令上的差距就越大\n## 方法内联\n是编译器最重要的优化手段,一般都会放在优化序列最靠前的位置\n没有方法内联,多数其它优化都无法有效进行,因为分开看很多方法里面的操作可能是有意义的\n优化行为理解起来就是把目标方法的代码原封不动地\"复制\"到发起调用的方法之中,但是Java实现挺复杂的\n### 目的\n1. 去除方法调用的成本(如查找方法版本,建立栈帧等)\n2. 为其他优化建立良好的基础\n\n### Java实现方法内联问题\n一般只有私有方法,实例构造器,父类方法,静态方法,final方法才会在编译期进行解析。其他的Java方法调用都必须在运行时进行方法接收者的多态选择，可能存在多于一个版本的方法接收者。所以默认的实例方法是虚方法。\n所以方法应该根据实际类型动态分配，而实际类型必须在实际运行到这行代码才能确定，很难在编译时得到绝对准确的结论\nJava对象默认的方法就是虚方法，Java间接鼓励了程序员使用大量的虚方法来实现程序逻辑\n### Java实现方法内联方法\n使用类型继承关系分析，用于确定在目前已加载的类的接口和父类的信息。这样，编译器在进行内联时就会分不同情况采取不同的处理：\n1. 如果是非虚方法，直接内联\n2. 如果是虚方法，而且只有一个版本，就假设只有这个。不过属于激进预测性优化，必须预留号逃生门，即当假设不成立时的退路。如果之后加载了导致继承关系发生变化的新类，则必须抛弃已经编译的代码，退回到解释状态继续执行，或者重新进行编译。\n3. 如果有多个版本，则使用内联缓存。内联缓存是一个建立在目标方法正常入口之前的缓存。在未发生方法调用前，内联缓存状态为空，当第一次调用时，缓存记录下方法接受者的版本信息，并且每次进行方法调用时都比较接收者的版本，每个每次进来调用方法的接收者都是一样的，他就是一个单态内联缓存\n\n所以在多数情况下，Java虚拟机进行的方法内联都是一种激进优化，如果真的出现小概率事件，才会使用逃生门回到解释状态重新执行。\n\n\n## 逃逸分析\n最前沿的优化技术之一，是为其他优化提供依据的分析技术。但是逃逸计算成本非常高，可能出现效果不稳定的情况\n### 原理\n分析对象动态作用域，当一个对象在方法里面被定义后，他可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种叫方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量这种叫线程逃逸。\n如果能证明一个对象不会逃逸到方法或线程之外，或逃逸程度比较低，可以使用以下技术\n### 栈上分配\nJava几乎都是堆上分配创建对象的内存空间，堆中对象对于各个线程都是共享可见的，只要持有这个对象的引用，就可以访问到堆中存储的对象数据。\n如果确定一个对象不会逃逸到线程之外，那么可以让改对象在栈上分配内存。可以支持方法逃逸，不支持线程逃逸\n### 标量替换\n若一个数据已无法分解为更小的数据，就是标量。（int,long,reference等）\n如果把java对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就是标量替换。\n假如逃逸分析能证明一个对象不会被方法外部使用，并且该对象可以拆分，那么真正执行时可能不会创建这个对象，而是创建它的若干个成员变量。是栈上分配的特例，实现更简单，对逃逸要求更高\n### 同步消除\n线程同步是相对耗时的操作。如果一个变量不会逃逸出线程，他就没有读写竞争，就可以消除对该变量实施的同步措施\n\n\n## 公共子表达式消除\n语言无关的经典优化技术之一\n如果一个表达式E在之前被计算过，并且从之前到现在E中所有变量值不变，则可以用前面计算好的结果代替E\n## 数组边界检查消除\n语言相关的经典优化技术之一\nJava动态安全，访问数组元素系统会自动进行上下界的范围检查，对开发者友好，但是每次数组元素的读写都有一次隐式地条件判定操作，是一种性能负担。\n如果数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围在数组长度内，就可以把循环中的上下界检查消除掉\n\n# 实战：深入理解Graal编译器\nGraal编译器：即时编译器和提前编译器共同的最新成果。有望成为一款高质量编译效率，高输出质量，支持提前编译，即时编译。","source":"_posts/JVM笔记/第11章_后端编译与优化.md","raw":"---\ntitle: 深入理解Java虚拟机--后端编译与优化\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第11章--后端编译与优化。'\ncategories: JVM学习笔记\ntags:\n  - 深入理解Java虚拟机\n  - JVM\n  - 编译器\nabbrlink: 78dd2f11\ndate: 2020-07-20 00:00:00\n---\n\n# 概述\n\n编译器在何时,何种状态下把Class文件转换成与本地基础设施相关的二进制机器码,都可以视为整个编译过程的后端\n\n所以有提前编译器,即时编译器两种\n\n# 即时编译器\n\njava最初都是通过解释器进行解释执行的,当虚拟机发现某个方法或代码块运行特别频繁,就会认为是热点代码,在运行时,则把这些代码编译成本地机器码,并且以各种手段尽可能地进行代码优化\n\n## 解释器与编译器\n\nhotspot虚拟机内部同时包含解释器与编译器,当程序需要迅速启动和执行时,解释器可以首先发挥作用,省去编译时间,立即运行。随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地机器码，减少解释器的中间损耗，获得更高执行效率\n\n解释器节约内存，编译器提高效率\n\n解释器也可以作为编译器激进优化时后备的逃生门，即编译器可能根据概率选大多数提高运行速度的优化手段，但不是每一次都正确的，当激进优化假设不成立时可以通过逆优化退回到解释状态继续执行\n\n内置了两个即时编译器 C1(客户端编译器),C2(服务端编译器)\n\n分层模式之前，采用解释器与其中一个编译器直接搭配的方式工作，虚拟机会根据自身版本和宿主机的硬件性能自动选择运行模式\n\n一般都使用混合模式\n\n### 分层编译\n\n由于即时编译器编译本地代码需要占用程序运行时间，且要编译处优化程度高的代码，所花费时间便越长，为了在程序启动响应速度与运行效率之间取得平衡，就采用分层编译\n\n+ 第0层，纯解释执行，而且解释器不开启性能监控\n+ 第1层，使用C1将字节码编译成本地代码，不开启性能监控\n+ 第2层，使用C1将字节码编译成本地代码，仅开启方法及回边统计等有限的性能监控\n+ 第3层，使用C1将字节码编译成本地代码，开启全部性能监控\n+ 第1层，使用C2将字节码编译成本地代码，开启全部性能监控.还会根据性能监控信息进行一些不可靠的激进优化\n\n实施分层编译后，解释器，C1,C2同时工作，热点代码可能会多次编译，用C1获得更高的编译速度，用C2获得更好的编译质量，在解释执行时也无须额外承担收集性能监控信息的任务，而在C2采用高复杂度的优化算法时，C1可先采用简单优化为他争取更多的编译时间\n\n## 编译对象与触发条件\n\n热点代码:被多次调用的方法,被多次执行的循环体\n\n这两种情况编译的对象都是整个方法体,而不是单独的循环体\n\n对于后者,只是执行入口稍有不同,编译时会传入执行入口点字节码序号,以为编译发生在方法执行过程中,所以叫做栈上替换,即方法的栈帧还在栈上,方法就被替换了\n\n### 热点探测\n\n1. 基于采样的热点探测,虚拟机会周期性的检查各个线程的调用栈顶,如果发现某个方法经常出现在栈顶,就是热点代码。缺点是很难精确的确认一个方法的热度\n2. 基于计数器的热点探测，虚拟机会为每个方法建立计数器，统计方法的执行次数。相对更加精确严谨\n\n### HotSpot虚拟机实现\n\n采用基于计数器的热点探测，准备了方法调用计数器，回边计数器（指循环边界往回跳转），计数器阈值一旦溢出，就触发即时编译。\n\n执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成，当编译工作完成，该方法调用入口就会被系统改为新值，下一次调用该方法就会使用已编译版本\n\n#### 方法调用计数器\n\n方法调用计数器不是方法被调用的绝对次数，而是相对的执行频率，即一段时间内方法被调用的次数。\n\n当超过一段时间，方法的调用次数仍然不足以让它提交到即时编译器编译，则该方法的调用计数器就会减半。这个过程称为方法调用计数器热度的衰减。这段时间称为半衰周期![IMG_20200828_0846415](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200828_0846415.jpg)\n\n#### 回边计数器\n统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为回边，目的是触发栈上的替换编译\n当超过阈值时，将会提交一个栈上替换编译请求，并且把回边计数器值稍微降低，以便继续在解释器中执行循环，等待编译器输出编译结果\n回边计数器没有计数热点衰减，统计的是该方法循环执行的绝对次数\n\n## 编译过程\n默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行\n### 客户端编译器\n是一个相对简单快速的三段式编译器，主要关注点在局部性的优化，而放弃了许多耗时较长的全局优化手段\n1. 一个平台独立的前端将字节码构造成一种高级中间代码表示（HIR）\n2.  一个平台相关的后端将 HIR产生低级中间代码表示（LIR)\n3.  在平台相关的后端使用线性扫描算法，产生机器代码\n\n### 服务端编译器\n专门面向服务端的典型应用场景。是一个能容忍很高优化复杂度的高级编译器。执行大部分经典的优化操作和一些不稳定的预测性的激进优化（如分支频率预测等）\n\n## 实战：查看及分析即使编译结果\nJava虚拟机的即使编译过程对用户和程序都是完全透明的\n空循环在最终的本地代码中实际上是不会执行的\n\n# 提前编译器\n\n## 提前编译的优劣得失\n\n### 两条分支\n\n1. 在程序运行之前把程序代码编译成机器码的静态翻译工作.他的价值就是即时编译器的最大弱点:即时编译要占用程序运行时间和运算资源。所以在静态编译中进行耗时的优化，生成高质量代码。副作用是安装的时候很慢\n2. 把原本即时编译器在运行时要做的编译工作提前做好并保存下来,下次运行这些代码直接把他加载进来使用。本质上是给即时编译器做缓存加速，去改善Java程序的启动时间以及需要一段时间预热才能达到最高性能的问题。可以叫做即时编译缓存。缺点是这种提前编译方式不仅要和目标机器相关，而且还必须与HotSpot虚拟机的运行参数绑定\n\n### 即时编译器的天然优势\n\n#### 性能分析制导优化\n\n在解释器或客户端编译器运行过程中，会不断收集性能监控信息。这些信息一般在静态分析时无法得到，或者不可能存在确定的唯一解。然而在动态运行时却可以明显看出他们的偏好，可以把热点代码集中优化分配资源。\n#### 激进预测性优化\n可以大胆的按照高概率的假设进行优化,万一出错,大不了回退到低价编译器甚至解释器上去执行\n#### 链接时优化\nJava语言天生是动态链接的,一个个Class文件在运行期被加载到虚拟机内存中,然后在即时编译器里产生优化后的代码\n\n# 编译器优化技术\n编译器的目标是由程序代码翻译为本地机器码的过程,但是输出代码优化质量的高低才是决定编译器优秀与否的关键\n即时编译器对代码优化变化是在代码的中间表示或机器码上的,而不是Java源码上的\n优化的代码所达到效果相同,但是省略很多代码语句,体现在字节码和机器码的指令上的差距就越大\n## 方法内联\n是编译器最重要的优化手段,一般都会放在优化序列最靠前的位置\n没有方法内联,多数其它优化都无法有效进行,因为分开看很多方法里面的操作可能是有意义的\n优化行为理解起来就是把目标方法的代码原封不动地\"复制\"到发起调用的方法之中,但是Java实现挺复杂的\n### 目的\n1. 去除方法调用的成本(如查找方法版本,建立栈帧等)\n2. 为其他优化建立良好的基础\n\n### Java实现方法内联问题\n一般只有私有方法,实例构造器,父类方法,静态方法,final方法才会在编译期进行解析。其他的Java方法调用都必须在运行时进行方法接收者的多态选择，可能存在多于一个版本的方法接收者。所以默认的实例方法是虚方法。\n所以方法应该根据实际类型动态分配，而实际类型必须在实际运行到这行代码才能确定，很难在编译时得到绝对准确的结论\nJava对象默认的方法就是虚方法，Java间接鼓励了程序员使用大量的虚方法来实现程序逻辑\n### Java实现方法内联方法\n使用类型继承关系分析，用于确定在目前已加载的类的接口和父类的信息。这样，编译器在进行内联时就会分不同情况采取不同的处理：\n1. 如果是非虚方法，直接内联\n2. 如果是虚方法，而且只有一个版本，就假设只有这个。不过属于激进预测性优化，必须预留号逃生门，即当假设不成立时的退路。如果之后加载了导致继承关系发生变化的新类，则必须抛弃已经编译的代码，退回到解释状态继续执行，或者重新进行编译。\n3. 如果有多个版本，则使用内联缓存。内联缓存是一个建立在目标方法正常入口之前的缓存。在未发生方法调用前，内联缓存状态为空，当第一次调用时，缓存记录下方法接受者的版本信息，并且每次进行方法调用时都比较接收者的版本，每个每次进来调用方法的接收者都是一样的，他就是一个单态内联缓存\n\n所以在多数情况下，Java虚拟机进行的方法内联都是一种激进优化，如果真的出现小概率事件，才会使用逃生门回到解释状态重新执行。\n\n\n## 逃逸分析\n最前沿的优化技术之一，是为其他优化提供依据的分析技术。但是逃逸计算成本非常高，可能出现效果不稳定的情况\n### 原理\n分析对象动态作用域，当一个对象在方法里面被定义后，他可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种叫方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量这种叫线程逃逸。\n如果能证明一个对象不会逃逸到方法或线程之外，或逃逸程度比较低，可以使用以下技术\n### 栈上分配\nJava几乎都是堆上分配创建对象的内存空间，堆中对象对于各个线程都是共享可见的，只要持有这个对象的引用，就可以访问到堆中存储的对象数据。\n如果确定一个对象不会逃逸到线程之外，那么可以让改对象在栈上分配内存。可以支持方法逃逸，不支持线程逃逸\n### 标量替换\n若一个数据已无法分解为更小的数据，就是标量。（int,long,reference等）\n如果把java对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就是标量替换。\n假如逃逸分析能证明一个对象不会被方法外部使用，并且该对象可以拆分，那么真正执行时可能不会创建这个对象，而是创建它的若干个成员变量。是栈上分配的特例，实现更简单，对逃逸要求更高\n### 同步消除\n线程同步是相对耗时的操作。如果一个变量不会逃逸出线程，他就没有读写竞争，就可以消除对该变量实施的同步措施\n\n\n## 公共子表达式消除\n语言无关的经典优化技术之一\n如果一个表达式E在之前被计算过，并且从之前到现在E中所有变量值不变，则可以用前面计算好的结果代替E\n## 数组边界检查消除\n语言相关的经典优化技术之一\nJava动态安全，访问数组元素系统会自动进行上下界的范围检查，对开发者友好，但是每次数组元素的读写都有一次隐式地条件判定操作，是一种性能负担。\n如果数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围在数组长度内，就可以把循环中的上下界检查消除掉\n\n# 实战：深入理解Graal编译器\nGraal编译器：即时编译器和提前编译器共同的最新成果。有望成为一款高质量编译效率，高输出质量，支持提前编译，即时编译。","slug":"JVM笔记/第11章_后端编译与优化","published":1,"updated":"2020-11-12T11:57:29.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6vh0006jotp5wf6fzsk","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>编译器在何时,何种状态下把Class文件转换成与本地基础设施相关的二进制机器码,都可以视为整个编译过程的后端</p>\n<p>所以有提前编译器,即时编译器两种</p>\n<h1 id=\"即时编译器\"><a href=\"#即时编译器\" class=\"headerlink\" title=\"即时编译器\"></a>即时编译器</h1><p>java最初都是通过解释器进行解释执行的,当虚拟机发现某个方法或代码块运行特别频繁,就会认为是热点代码,在运行时,则把这些代码编译成本地机器码,并且以各种手段尽可能地进行代码优化</p>\n<h2 id=\"解释器与编译器\"><a href=\"#解释器与编译器\" class=\"headerlink\" title=\"解释器与编译器\"></a>解释器与编译器</h2><p>hotspot虚拟机内部同时包含解释器与编译器,当程序需要迅速启动和执行时,解释器可以首先发挥作用,省去编译时间,立即运行。随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地机器码，减少解释器的中间损耗，获得更高执行效率</p>\n<p>解释器节约内存，编译器提高效率</p>\n<p>解释器也可以作为编译器激进优化时后备的逃生门，即编译器可能根据概率选大多数提高运行速度的优化手段，但不是每一次都正确的，当激进优化假设不成立时可以通过逆优化退回到解释状态继续执行</p>\n<p>内置了两个即时编译器 C1(客户端编译器),C2(服务端编译器)</p>\n<p>分层模式之前，采用解释器与其中一个编译器直接搭配的方式工作，虚拟机会根据自身版本和宿主机的硬件性能自动选择运行模式</p>\n<p>一般都使用混合模式</p>\n<h3 id=\"分层编译\"><a href=\"#分层编译\" class=\"headerlink\" title=\"分层编译\"></a>分层编译</h3><p>由于即时编译器编译本地代码需要占用程序运行时间，且要编译处优化程度高的代码，所花费时间便越长，为了在程序启动响应速度与运行效率之间取得平衡，就采用分层编译</p>\n<ul>\n<li>第0层，纯解释执行，而且解释器不开启性能监控</li>\n<li>第1层，使用C1将字节码编译成本地代码，不开启性能监控</li>\n<li>第2层，使用C1将字节码编译成本地代码，仅开启方法及回边统计等有限的性能监控</li>\n<li>第3层，使用C1将字节码编译成本地代码，开启全部性能监控</li>\n<li>第1层，使用C2将字节码编译成本地代码，开启全部性能监控.还会根据性能监控信息进行一些不可靠的激进优化</li>\n</ul>\n<p>实施分层编译后，解释器，C1,C2同时工作，热点代码可能会多次编译，用C1获得更高的编译速度，用C2获得更好的编译质量，在解释执行时也无须额外承担收集性能监控信息的任务，而在C2采用高复杂度的优化算法时，C1可先采用简单优化为他争取更多的编译时间</p>\n<h2 id=\"编译对象与触发条件\"><a href=\"#编译对象与触发条件\" class=\"headerlink\" title=\"编译对象与触发条件\"></a>编译对象与触发条件</h2><p>热点代码:被多次调用的方法,被多次执行的循环体</p>\n<p>这两种情况编译的对象都是整个方法体,而不是单独的循环体</p>\n<p>对于后者,只是执行入口稍有不同,编译时会传入执行入口点字节码序号,以为编译发生在方法执行过程中,所以叫做栈上替换,即方法的栈帧还在栈上,方法就被替换了</p>\n<h3 id=\"热点探测\"><a href=\"#热点探测\" class=\"headerlink\" title=\"热点探测\"></a>热点探测</h3><ol>\n<li>基于采样的热点探测,虚拟机会周期性的检查各个线程的调用栈顶,如果发现某个方法经常出现在栈顶,就是热点代码。缺点是很难精确的确认一个方法的热度</li>\n<li>基于计数器的热点探测，虚拟机会为每个方法建立计数器，统计方法的执行次数。相对更加精确严谨</li>\n</ol>\n<h3 id=\"HotSpot虚拟机实现\"><a href=\"#HotSpot虚拟机实现\" class=\"headerlink\" title=\"HotSpot虚拟机实现\"></a>HotSpot虚拟机实现</h3><p>采用基于计数器的热点探测，准备了方法调用计数器，回边计数器（指循环边界往回跳转），计数器阈值一旦溢出，就触发即时编译。</p>\n<p>执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成，当编译工作完成，该方法调用入口就会被系统改为新值，下一次调用该方法就会使用已编译版本</p>\n<h4 id=\"方法调用计数器\"><a href=\"#方法调用计数器\" class=\"headerlink\" title=\"方法调用计数器\"></a>方法调用计数器</h4><p>方法调用计数器不是方法被调用的绝对次数，而是相对的执行频率，即一段时间内方法被调用的次数。</p>\n<p>当超过一段时间，方法的调用次数仍然不足以让它提交到即时编译器编译，则该方法的调用计数器就会减半。这个过程称为方法调用计数器热度的衰减。这段时间称为半衰周期<img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200828_0846415.jpg\" alt=\"IMG_20200828_0846415\"></p>\n<h4 id=\"回边计数器\"><a href=\"#回边计数器\" class=\"headerlink\" title=\"回边计数器\"></a>回边计数器</h4><p>统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为回边，目的是触发栈上的替换编译<br>当超过阈值时，将会提交一个栈上替换编译请求，并且把回边计数器值稍微降低，以便继续在解释器中执行循环，等待编译器输出编译结果<br>回边计数器没有计数热点衰减，统计的是该方法循环执行的绝对次数</p>\n<h2 id=\"编译过程\"><a href=\"#编译过程\" class=\"headerlink\" title=\"编译过程\"></a>编译过程</h2><p>默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行</p>\n<h3 id=\"客户端编译器\"><a href=\"#客户端编译器\" class=\"headerlink\" title=\"客户端编译器\"></a>客户端编译器</h3><p>是一个相对简单快速的三段式编译器，主要关注点在局部性的优化，而放弃了许多耗时较长的全局优化手段</p>\n<ol>\n<li>一个平台独立的前端将字节码构造成一种高级中间代码表示（HIR）</li>\n<li>一个平台相关的后端将 HIR产生低级中间代码表示（LIR)</li>\n<li>在平台相关的后端使用线性扫描算法，产生机器代码</li>\n</ol>\n<h3 id=\"服务端编译器\"><a href=\"#服务端编译器\" class=\"headerlink\" title=\"服务端编译器\"></a>服务端编译器</h3><p>专门面向服务端的典型应用场景。是一个能容忍很高优化复杂度的高级编译器。执行大部分经典的优化操作和一些不稳定的预测性的激进优化（如分支频率预测等）</p>\n<h2 id=\"实战：查看及分析即使编译结果\"><a href=\"#实战：查看及分析即使编译结果\" class=\"headerlink\" title=\"实战：查看及分析即使编译结果\"></a>实战：查看及分析即使编译结果</h2><p>Java虚拟机的即使编译过程对用户和程序都是完全透明的<br>空循环在最终的本地代码中实际上是不会执行的</p>\n<h1 id=\"提前编译器\"><a href=\"#提前编译器\" class=\"headerlink\" title=\"提前编译器\"></a>提前编译器</h1><h2 id=\"提前编译的优劣得失\"><a href=\"#提前编译的优劣得失\" class=\"headerlink\" title=\"提前编译的优劣得失\"></a>提前编译的优劣得失</h2><h3 id=\"两条分支\"><a href=\"#两条分支\" class=\"headerlink\" title=\"两条分支\"></a>两条分支</h3><ol>\n<li>在程序运行之前把程序代码编译成机器码的静态翻译工作.他的价值就是即时编译器的最大弱点:即时编译要占用程序运行时间和运算资源。所以在静态编译中进行耗时的优化，生成高质量代码。副作用是安装的时候很慢</li>\n<li>把原本即时编译器在运行时要做的编译工作提前做好并保存下来,下次运行这些代码直接把他加载进来使用。本质上是给即时编译器做缓存加速，去改善Java程序的启动时间以及需要一段时间预热才能达到最高性能的问题。可以叫做即时编译缓存。缺点是这种提前编译方式不仅要和目标机器相关，而且还必须与HotSpot虚拟机的运行参数绑定</li>\n</ol>\n<h3 id=\"即时编译器的天然优势\"><a href=\"#即时编译器的天然优势\" class=\"headerlink\" title=\"即时编译器的天然优势\"></a>即时编译器的天然优势</h3><h4 id=\"性能分析制导优化\"><a href=\"#性能分析制导优化\" class=\"headerlink\" title=\"性能分析制导优化\"></a>性能分析制导优化</h4><p>在解释器或客户端编译器运行过程中，会不断收集性能监控信息。这些信息一般在静态分析时无法得到，或者不可能存在确定的唯一解。然而在动态运行时却可以明显看出他们的偏好，可以把热点代码集中优化分配资源。</p>\n<h4 id=\"激进预测性优化\"><a href=\"#激进预测性优化\" class=\"headerlink\" title=\"激进预测性优化\"></a>激进预测性优化</h4><p>可以大胆的按照高概率的假设进行优化,万一出错,大不了回退到低价编译器甚至解释器上去执行</p>\n<h4 id=\"链接时优化\"><a href=\"#链接时优化\" class=\"headerlink\" title=\"链接时优化\"></a>链接时优化</h4><p>Java语言天生是动态链接的,一个个Class文件在运行期被加载到虚拟机内存中,然后在即时编译器里产生优化后的代码</p>\n<h1 id=\"编译器优化技术\"><a href=\"#编译器优化技术\" class=\"headerlink\" title=\"编译器优化技术\"></a>编译器优化技术</h1><p>编译器的目标是由程序代码翻译为本地机器码的过程,但是输出代码优化质量的高低才是决定编译器优秀与否的关键<br>即时编译器对代码优化变化是在代码的中间表示或机器码上的,而不是Java源码上的<br>优化的代码所达到效果相同,但是省略很多代码语句,体现在字节码和机器码的指令上的差距就越大</p>\n<h2 id=\"方法内联\"><a href=\"#方法内联\" class=\"headerlink\" title=\"方法内联\"></a>方法内联</h2><p>是编译器最重要的优化手段,一般都会放在优化序列最靠前的位置<br>没有方法内联,多数其它优化都无法有效进行,因为分开看很多方法里面的操作可能是有意义的<br>优化行为理解起来就是把目标方法的代码原封不动地”复制”到发起调用的方法之中,但是Java实现挺复杂的</p>\n<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><ol>\n<li>去除方法调用的成本(如查找方法版本,建立栈帧等)</li>\n<li>为其他优化建立良好的基础</li>\n</ol>\n<h3 id=\"Java实现方法内联问题\"><a href=\"#Java实现方法内联问题\" class=\"headerlink\" title=\"Java实现方法内联问题\"></a>Java实现方法内联问题</h3><p>一般只有私有方法,实例构造器,父类方法,静态方法,final方法才会在编译期进行解析。其他的Java方法调用都必须在运行时进行方法接收者的多态选择，可能存在多于一个版本的方法接收者。所以默认的实例方法是虚方法。<br>所以方法应该根据实际类型动态分配，而实际类型必须在实际运行到这行代码才能确定，很难在编译时得到绝对准确的结论<br>Java对象默认的方法就是虚方法，Java间接鼓励了程序员使用大量的虚方法来实现程序逻辑</p>\n<h3 id=\"Java实现方法内联方法\"><a href=\"#Java实现方法内联方法\" class=\"headerlink\" title=\"Java实现方法内联方法\"></a>Java实现方法内联方法</h3><p>使用类型继承关系分析，用于确定在目前已加载的类的接口和父类的信息。这样，编译器在进行内联时就会分不同情况采取不同的处理：</p>\n<ol>\n<li>如果是非虚方法，直接内联</li>\n<li>如果是虚方法，而且只有一个版本，就假设只有这个。不过属于激进预测性优化，必须预留号逃生门，即当假设不成立时的退路。如果之后加载了导致继承关系发生变化的新类，则必须抛弃已经编译的代码，退回到解释状态继续执行，或者重新进行编译。</li>\n<li>如果有多个版本，则使用内联缓存。内联缓存是一个建立在目标方法正常入口之前的缓存。在未发生方法调用前，内联缓存状态为空，当第一次调用时，缓存记录下方法接受者的版本信息，并且每次进行方法调用时都比较接收者的版本，每个每次进来调用方法的接收者都是一样的，他就是一个单态内联缓存</li>\n</ol>\n<p>所以在多数情况下，Java虚拟机进行的方法内联都是一种激进优化，如果真的出现小概率事件，才会使用逃生门回到解释状态重新执行。</p>\n<h2 id=\"逃逸分析\"><a href=\"#逃逸分析\" class=\"headerlink\" title=\"逃逸分析\"></a>逃逸分析</h2><p>最前沿的优化技术之一，是为其他优化提供依据的分析技术。但是逃逸计算成本非常高，可能出现效果不稳定的情况</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>分析对象动态作用域，当一个对象在方法里面被定义后，他可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种叫方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量这种叫线程逃逸。<br>如果能证明一个对象不会逃逸到方法或线程之外，或逃逸程度比较低，可以使用以下技术</p>\n<h3 id=\"栈上分配\"><a href=\"#栈上分配\" class=\"headerlink\" title=\"栈上分配\"></a>栈上分配</h3><p>Java几乎都是堆上分配创建对象的内存空间，堆中对象对于各个线程都是共享可见的，只要持有这个对象的引用，就可以访问到堆中存储的对象数据。<br>如果确定一个对象不会逃逸到线程之外，那么可以让改对象在栈上分配内存。可以支持方法逃逸，不支持线程逃逸</p>\n<h3 id=\"标量替换\"><a href=\"#标量替换\" class=\"headerlink\" title=\"标量替换\"></a>标量替换</h3><p>若一个数据已无法分解为更小的数据，就是标量。（int,long,reference等）<br>如果把java对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就是标量替换。<br>假如逃逸分析能证明一个对象不会被方法外部使用，并且该对象可以拆分，那么真正执行时可能不会创建这个对象，而是创建它的若干个成员变量。是栈上分配的特例，实现更简单，对逃逸要求更高</p>\n<h3 id=\"同步消除\"><a href=\"#同步消除\" class=\"headerlink\" title=\"同步消除\"></a>同步消除</h3><p>线程同步是相对耗时的操作。如果一个变量不会逃逸出线程，他就没有读写竞争，就可以消除对该变量实施的同步措施</p>\n<h2 id=\"公共子表达式消除\"><a href=\"#公共子表达式消除\" class=\"headerlink\" title=\"公共子表达式消除\"></a>公共子表达式消除</h2><p>语言无关的经典优化技术之一<br>如果一个表达式E在之前被计算过，并且从之前到现在E中所有变量值不变，则可以用前面计算好的结果代替E</p>\n<h2 id=\"数组边界检查消除\"><a href=\"#数组边界检查消除\" class=\"headerlink\" title=\"数组边界检查消除\"></a>数组边界检查消除</h2><p>语言相关的经典优化技术之一<br>Java动态安全，访问数组元素系统会自动进行上下界的范围检查，对开发者友好，但是每次数组元素的读写都有一次隐式地条件判定操作，是一种性能负担。<br>如果数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围在数组长度内，就可以把循环中的上下界检查消除掉</p>\n<h1 id=\"实战：深入理解Graal编译器\"><a href=\"#实战：深入理解Graal编译器\" class=\"headerlink\" title=\"实战：深入理解Graal编译器\"></a>实战：深入理解Graal编译器</h1><p>Graal编译器：即时编译器和提前编译器共同的最新成果。有望成为一款高质量编译效率，高输出质量，支持提前编译，即时编译。</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>编译器在何时,何种状态下把Class文件转换成与本地基础设施相关的二进制机器码,都可以视为整个编译过程的后端</p>\n<p>所以有提前编译器,即时编译器两种</p>\n<h1 id=\"即时编译器\"><a href=\"#即时编译器\" class=\"headerlink\" title=\"即时编译器\"></a>即时编译器</h1><p>java最初都是通过解释器进行解释执行的,当虚拟机发现某个方法或代码块运行特别频繁,就会认为是热点代码,在运行时,则把这些代码编译成本地机器码,并且以各种手段尽可能地进行代码优化</p>\n<h2 id=\"解释器与编译器\"><a href=\"#解释器与编译器\" class=\"headerlink\" title=\"解释器与编译器\"></a>解释器与编译器</h2><p>hotspot虚拟机内部同时包含解释器与编译器,当程序需要迅速启动和执行时,解释器可以首先发挥作用,省去编译时间,立即运行。随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地机器码，减少解释器的中间损耗，获得更高执行效率</p>\n<p>解释器节约内存，编译器提高效率</p>\n<p>解释器也可以作为编译器激进优化时后备的逃生门，即编译器可能根据概率选大多数提高运行速度的优化手段，但不是每一次都正确的，当激进优化假设不成立时可以通过逆优化退回到解释状态继续执行</p>\n<p>内置了两个即时编译器 C1(客户端编译器),C2(服务端编译器)</p>\n<p>分层模式之前，采用解释器与其中一个编译器直接搭配的方式工作，虚拟机会根据自身版本和宿主机的硬件性能自动选择运行模式</p>\n<p>一般都使用混合模式</p>\n<h3 id=\"分层编译\"><a href=\"#分层编译\" class=\"headerlink\" title=\"分层编译\"></a>分层编译</h3><p>由于即时编译器编译本地代码需要占用程序运行时间，且要编译处优化程度高的代码，所花费时间便越长，为了在程序启动响应速度与运行效率之间取得平衡，就采用分层编译</p>\n<ul>\n<li>第0层，纯解释执行，而且解释器不开启性能监控</li>\n<li>第1层，使用C1将字节码编译成本地代码，不开启性能监控</li>\n<li>第2层，使用C1将字节码编译成本地代码，仅开启方法及回边统计等有限的性能监控</li>\n<li>第3层，使用C1将字节码编译成本地代码，开启全部性能监控</li>\n<li>第1层，使用C2将字节码编译成本地代码，开启全部性能监控.还会根据性能监控信息进行一些不可靠的激进优化</li>\n</ul>\n<p>实施分层编译后，解释器，C1,C2同时工作，热点代码可能会多次编译，用C1获得更高的编译速度，用C2获得更好的编译质量，在解释执行时也无须额外承担收集性能监控信息的任务，而在C2采用高复杂度的优化算法时，C1可先采用简单优化为他争取更多的编译时间</p>\n<h2 id=\"编译对象与触发条件\"><a href=\"#编译对象与触发条件\" class=\"headerlink\" title=\"编译对象与触发条件\"></a>编译对象与触发条件</h2><p>热点代码:被多次调用的方法,被多次执行的循环体</p>\n<p>这两种情况编译的对象都是整个方法体,而不是单独的循环体</p>\n<p>对于后者,只是执行入口稍有不同,编译时会传入执行入口点字节码序号,以为编译发生在方法执行过程中,所以叫做栈上替换,即方法的栈帧还在栈上,方法就被替换了</p>\n<h3 id=\"热点探测\"><a href=\"#热点探测\" class=\"headerlink\" title=\"热点探测\"></a>热点探测</h3><ol>\n<li>基于采样的热点探测,虚拟机会周期性的检查各个线程的调用栈顶,如果发现某个方法经常出现在栈顶,就是热点代码。缺点是很难精确的确认一个方法的热度</li>\n<li>基于计数器的热点探测，虚拟机会为每个方法建立计数器，统计方法的执行次数。相对更加精确严谨</li>\n</ol>\n<h3 id=\"HotSpot虚拟机实现\"><a href=\"#HotSpot虚拟机实现\" class=\"headerlink\" title=\"HotSpot虚拟机实现\"></a>HotSpot虚拟机实现</h3><p>采用基于计数器的热点探测，准备了方法调用计数器，回边计数器（指循环边界往回跳转），计数器阈值一旦溢出，就触发即时编译。</p>\n<p>执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成，当编译工作完成，该方法调用入口就会被系统改为新值，下一次调用该方法就会使用已编译版本</p>\n<h4 id=\"方法调用计数器\"><a href=\"#方法调用计数器\" class=\"headerlink\" title=\"方法调用计数器\"></a>方法调用计数器</h4><p>方法调用计数器不是方法被调用的绝对次数，而是相对的执行频率，即一段时间内方法被调用的次数。</p>\n<p>当超过一段时间，方法的调用次数仍然不足以让它提交到即时编译器编译，则该方法的调用计数器就会减半。这个过程称为方法调用计数器热度的衰减。这段时间称为半衰周期<img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200828_0846415.jpg\" alt=\"IMG_20200828_0846415\"></p>\n<h4 id=\"回边计数器\"><a href=\"#回边计数器\" class=\"headerlink\" title=\"回边计数器\"></a>回边计数器</h4><p>统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为回边，目的是触发栈上的替换编译<br>当超过阈值时，将会提交一个栈上替换编译请求，并且把回边计数器值稍微降低，以便继续在解释器中执行循环，等待编译器输出编译结果<br>回边计数器没有计数热点衰减，统计的是该方法循环执行的绝对次数</p>\n<h2 id=\"编译过程\"><a href=\"#编译过程\" class=\"headerlink\" title=\"编译过程\"></a>编译过程</h2><p>默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行</p>\n<h3 id=\"客户端编译器\"><a href=\"#客户端编译器\" class=\"headerlink\" title=\"客户端编译器\"></a>客户端编译器</h3><p>是一个相对简单快速的三段式编译器，主要关注点在局部性的优化，而放弃了许多耗时较长的全局优化手段</p>\n<ol>\n<li>一个平台独立的前端将字节码构造成一种高级中间代码表示（HIR）</li>\n<li>一个平台相关的后端将 HIR产生低级中间代码表示（LIR)</li>\n<li>在平台相关的后端使用线性扫描算法，产生机器代码</li>\n</ol>\n<h3 id=\"服务端编译器\"><a href=\"#服务端编译器\" class=\"headerlink\" title=\"服务端编译器\"></a>服务端编译器</h3><p>专门面向服务端的典型应用场景。是一个能容忍很高优化复杂度的高级编译器。执行大部分经典的优化操作和一些不稳定的预测性的激进优化（如分支频率预测等）</p>\n<h2 id=\"实战：查看及分析即使编译结果\"><a href=\"#实战：查看及分析即使编译结果\" class=\"headerlink\" title=\"实战：查看及分析即使编译结果\"></a>实战：查看及分析即使编译结果</h2><p>Java虚拟机的即使编译过程对用户和程序都是完全透明的<br>空循环在最终的本地代码中实际上是不会执行的</p>\n<h1 id=\"提前编译器\"><a href=\"#提前编译器\" class=\"headerlink\" title=\"提前编译器\"></a>提前编译器</h1><h2 id=\"提前编译的优劣得失\"><a href=\"#提前编译的优劣得失\" class=\"headerlink\" title=\"提前编译的优劣得失\"></a>提前编译的优劣得失</h2><h3 id=\"两条分支\"><a href=\"#两条分支\" class=\"headerlink\" title=\"两条分支\"></a>两条分支</h3><ol>\n<li>在程序运行之前把程序代码编译成机器码的静态翻译工作.他的价值就是即时编译器的最大弱点:即时编译要占用程序运行时间和运算资源。所以在静态编译中进行耗时的优化，生成高质量代码。副作用是安装的时候很慢</li>\n<li>把原本即时编译器在运行时要做的编译工作提前做好并保存下来,下次运行这些代码直接把他加载进来使用。本质上是给即时编译器做缓存加速，去改善Java程序的启动时间以及需要一段时间预热才能达到最高性能的问题。可以叫做即时编译缓存。缺点是这种提前编译方式不仅要和目标机器相关，而且还必须与HotSpot虚拟机的运行参数绑定</li>\n</ol>\n<h3 id=\"即时编译器的天然优势\"><a href=\"#即时编译器的天然优势\" class=\"headerlink\" title=\"即时编译器的天然优势\"></a>即时编译器的天然优势</h3><h4 id=\"性能分析制导优化\"><a href=\"#性能分析制导优化\" class=\"headerlink\" title=\"性能分析制导优化\"></a>性能分析制导优化</h4><p>在解释器或客户端编译器运行过程中，会不断收集性能监控信息。这些信息一般在静态分析时无法得到，或者不可能存在确定的唯一解。然而在动态运行时却可以明显看出他们的偏好，可以把热点代码集中优化分配资源。</p>\n<h4 id=\"激进预测性优化\"><a href=\"#激进预测性优化\" class=\"headerlink\" title=\"激进预测性优化\"></a>激进预测性优化</h4><p>可以大胆的按照高概率的假设进行优化,万一出错,大不了回退到低价编译器甚至解释器上去执行</p>\n<h4 id=\"链接时优化\"><a href=\"#链接时优化\" class=\"headerlink\" title=\"链接时优化\"></a>链接时优化</h4><p>Java语言天生是动态链接的,一个个Class文件在运行期被加载到虚拟机内存中,然后在即时编译器里产生优化后的代码</p>\n<h1 id=\"编译器优化技术\"><a href=\"#编译器优化技术\" class=\"headerlink\" title=\"编译器优化技术\"></a>编译器优化技术</h1><p>编译器的目标是由程序代码翻译为本地机器码的过程,但是输出代码优化质量的高低才是决定编译器优秀与否的关键<br>即时编译器对代码优化变化是在代码的中间表示或机器码上的,而不是Java源码上的<br>优化的代码所达到效果相同,但是省略很多代码语句,体现在字节码和机器码的指令上的差距就越大</p>\n<h2 id=\"方法内联\"><a href=\"#方法内联\" class=\"headerlink\" title=\"方法内联\"></a>方法内联</h2><p>是编译器最重要的优化手段,一般都会放在优化序列最靠前的位置<br>没有方法内联,多数其它优化都无法有效进行,因为分开看很多方法里面的操作可能是有意义的<br>优化行为理解起来就是把目标方法的代码原封不动地”复制”到发起调用的方法之中,但是Java实现挺复杂的</p>\n<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><ol>\n<li>去除方法调用的成本(如查找方法版本,建立栈帧等)</li>\n<li>为其他优化建立良好的基础</li>\n</ol>\n<h3 id=\"Java实现方法内联问题\"><a href=\"#Java实现方法内联问题\" class=\"headerlink\" title=\"Java实现方法内联问题\"></a>Java实现方法内联问题</h3><p>一般只有私有方法,实例构造器,父类方法,静态方法,final方法才会在编译期进行解析。其他的Java方法调用都必须在运行时进行方法接收者的多态选择，可能存在多于一个版本的方法接收者。所以默认的实例方法是虚方法。<br>所以方法应该根据实际类型动态分配，而实际类型必须在实际运行到这行代码才能确定，很难在编译时得到绝对准确的结论<br>Java对象默认的方法就是虚方法，Java间接鼓励了程序员使用大量的虚方法来实现程序逻辑</p>\n<h3 id=\"Java实现方法内联方法\"><a href=\"#Java实现方法内联方法\" class=\"headerlink\" title=\"Java实现方法内联方法\"></a>Java实现方法内联方法</h3><p>使用类型继承关系分析，用于确定在目前已加载的类的接口和父类的信息。这样，编译器在进行内联时就会分不同情况采取不同的处理：</p>\n<ol>\n<li>如果是非虚方法，直接内联</li>\n<li>如果是虚方法，而且只有一个版本，就假设只有这个。不过属于激进预测性优化，必须预留号逃生门，即当假设不成立时的退路。如果之后加载了导致继承关系发生变化的新类，则必须抛弃已经编译的代码，退回到解释状态继续执行，或者重新进行编译。</li>\n<li>如果有多个版本，则使用内联缓存。内联缓存是一个建立在目标方法正常入口之前的缓存。在未发生方法调用前，内联缓存状态为空，当第一次调用时，缓存记录下方法接受者的版本信息，并且每次进行方法调用时都比较接收者的版本，每个每次进来调用方法的接收者都是一样的，他就是一个单态内联缓存</li>\n</ol>\n<p>所以在多数情况下，Java虚拟机进行的方法内联都是一种激进优化，如果真的出现小概率事件，才会使用逃生门回到解释状态重新执行。</p>\n<h2 id=\"逃逸分析\"><a href=\"#逃逸分析\" class=\"headerlink\" title=\"逃逸分析\"></a>逃逸分析</h2><p>最前沿的优化技术之一，是为其他优化提供依据的分析技术。但是逃逸计算成本非常高，可能出现效果不稳定的情况</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>分析对象动态作用域，当一个对象在方法里面被定义后，他可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种叫方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量这种叫线程逃逸。<br>如果能证明一个对象不会逃逸到方法或线程之外，或逃逸程度比较低，可以使用以下技术</p>\n<h3 id=\"栈上分配\"><a href=\"#栈上分配\" class=\"headerlink\" title=\"栈上分配\"></a>栈上分配</h3><p>Java几乎都是堆上分配创建对象的内存空间，堆中对象对于各个线程都是共享可见的，只要持有这个对象的引用，就可以访问到堆中存储的对象数据。<br>如果确定一个对象不会逃逸到线程之外，那么可以让改对象在栈上分配内存。可以支持方法逃逸，不支持线程逃逸</p>\n<h3 id=\"标量替换\"><a href=\"#标量替换\" class=\"headerlink\" title=\"标量替换\"></a>标量替换</h3><p>若一个数据已无法分解为更小的数据，就是标量。（int,long,reference等）<br>如果把java对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就是标量替换。<br>假如逃逸分析能证明一个对象不会被方法外部使用，并且该对象可以拆分，那么真正执行时可能不会创建这个对象，而是创建它的若干个成员变量。是栈上分配的特例，实现更简单，对逃逸要求更高</p>\n<h3 id=\"同步消除\"><a href=\"#同步消除\" class=\"headerlink\" title=\"同步消除\"></a>同步消除</h3><p>线程同步是相对耗时的操作。如果一个变量不会逃逸出线程，他就没有读写竞争，就可以消除对该变量实施的同步措施</p>\n<h2 id=\"公共子表达式消除\"><a href=\"#公共子表达式消除\" class=\"headerlink\" title=\"公共子表达式消除\"></a>公共子表达式消除</h2><p>语言无关的经典优化技术之一<br>如果一个表达式E在之前被计算过，并且从之前到现在E中所有变量值不变，则可以用前面计算好的结果代替E</p>\n<h2 id=\"数组边界检查消除\"><a href=\"#数组边界检查消除\" class=\"headerlink\" title=\"数组边界检查消除\"></a>数组边界检查消除</h2><p>语言相关的经典优化技术之一<br>Java动态安全，访问数组元素系统会自动进行上下界的范围检查，对开发者友好，但是每次数组元素的读写都有一次隐式地条件判定操作，是一种性能负担。<br>如果数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围在数组长度内，就可以把循环中的上下界检查消除掉</p>\n<h1 id=\"实战：深入理解Graal编译器\"><a href=\"#实战：深入理解Graal编译器\" class=\"headerlink\" title=\"实战：深入理解Graal编译器\"></a>实战：深入理解Graal编译器</h1><p>Graal编译器：即时编译器和提前编译器共同的最新成果。有望成为一款高质量编译效率，高输出质量，支持提前编译，即时编译。</p>\n"},{"title":"深入理解Java虚拟机--前端编译与优化","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习<<深入理解Java虚拟机>>所做的笔记,此为书上第10章--前端编译与优化。","abbrlink":"c3f1ef69","date":"2020-07-16T16:00:00.000Z","_content":"\n\n# 概述\n\n编译期可能指以下几种:\n\n1. 前端编译器:把java文件转为class文件的过程,如Javac\n2. 即时编译器(JIT编译器):运行期把字节码转变为本地机器码的过程,如hotspot虚拟机的C1,C2编译器\n3. 静态的提前编译器:直接把程序编译成与目标指令集相关的二进制代码的过程\n\nJava中,即时编译器在运行期的优化过程,支撑了程序执行效率的不断提升,而前端编译器在编译期的优化过程,则是支撑着程序员的编码效率和语言使用者的幸福感的提高\n\n# Javac编译器\n\n## 编译过程\n\n1. 准备过程:初始化插入式注解处理器\n2. 解析与填充符号表过程\n\t+ 词法,语法分析,构造出抽象语法树\n\t+ 填充符号表,产生符号地址和符号信息\n3. 插入式注解处理器的注解处理过程:插入式注解处理器的执行阶段\n4. 语义分析与字节码生成过程\n\t+ 标注检查.对语法的静态信息进行检查\n\t+ 数据流及控制流分析。对程序动态运行过程进行检查\n\t+ 解语法糖。将简化代码编写的语法糖还原为原有的形式\n\t+ 字节码生成。将前面各个步骤所生成的信息转换成字节码\n\n上述动作中，执行插入式注解时有可能会产生新的符号，如果有新符号产生，就必须回到之前的解析，填充符号表的过程中重新处理这些新符号\n\n## 解析与填充符号表\n\n### 词法,语法分析\n\n词法分析是将源代码的字符流转变为标记集合的过程,标记是编译时的最小元素，例如int就是一个标记\n\n语法分析是根据标记序列构造抽象语法树的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式\n\n### 填充符号表\n\n符号表是一组符号地址和符号信息构成的数据结构，可以当作以键值对存储的哈希表\n\n## 注解处理器\n\n插入式注解处理器：注解一般是在运行期起作用，而这提前到编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。\n\n可以把插入式注解处理器看作是编译器的插件，如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为轮次。\n\n插入式注解处理器可以实现很多功能，如通过注解来实现自动产生getter/setter方法，产生equals（），hashCode（）方法\n\n## 语义分析与字节码生成\n\n抽象语法树能表示一个结构正确的源程序，但无法保证源程序的语义符合逻辑。语义分析主要任务是对结构正确的源程序进行上下文相关性质的检查，例如类型检查等\n\n编译时在IDE中看到由红线标注的错误提示，其中绝大部分都是由语义分析阶段的检查结果\n\n### 标注检查\n\n检查变量使用前是否被声明，变量与赋值之间的数据类型是否匹配等\n\n常量折叠：`int a=1+2`,会变成 a=3\n\n### 数据及控制流分析\n\n检查出诸如程序局部变量在使用前是否有赋值，方法的每条路径是否都有返回值，是否所有的受查异常都被正确处理了等问题\n\n### 解语法糖\n\n在语言中添加某种语法，对语言的编译结果和功能没有实际影响，但能方便程序员使用该语言。减少代码量，增加程序可读性，减少程序代码出错的机会\n\n### 字节码生成\n\n实例构造器<init>()方法和类构造器<cinit>(),就是这个阶段添加到语法树的\n\n<init>()，<cinit>()的产生是代码收敛的过程，编译器会把语句块，变量初始化，调用父类的实例构造器等操作收敛到他们两个方法上\n\n并且保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序执行\n\n# Java语法糖的味道\n\n## 泛型\n\n泛型本质是参数化类型或参数化多态的应用。即可以将操作的数据类型指定为方法签名中的一种特殊参数\n\nJava的泛型是“类型擦除式泛型”，只在程序源码中出现，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型（Raw Type），并且在相应的地方插入了强制转型代码\n\n所以ArrayList<Integer>,ArrayList<String> 在运行期是同一种类型\n\n无论在使用效果还是运行效率上，都全面落后于具现化式泛型，唯一优点就是实现擦除式泛型只需要在Java编译器上改进即可...\n\n### 类型擦除\nJava选择把已有的类型泛型化，如ArrayList原地泛型化为ArrayList<T>\n\t\t裸类型应被视为所有该类型泛型化实例的共同父类型\n\t\t让所有泛型化的实例类型，如ArrayList<Integer>,ArrayList<String> 都自动成为ArrayList的子类型\n\t\tJava裸类型的实现：简单粗暴地直接在编译期把ArrayList<Integer>还原为ArrayList，只在元素访问，修改时自动插入一些强制类型转换和检查指令\n\n不过擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息。所以编码时能通过反射手段取得参数化类型\n\n### 问题\n\n#### 对原始类型数据不支持\n\n因为不支持int这些基本类型与Object之间的强制转型，一旦把泛型信息擦除后，到要插入强制转型代码地方就不能进行下去。Java就不支持原生类型的泛型，只能用ArrayList<Integer>,导致了无数构造包装类的装箱，拆箱的开销\n\n#### 代码啰嗦\n\n运行期无法取得泛型类型信息\n\n#### 带来了模棱两可的模糊状况\n\n当泛型遇到重载时\n\n## 自动装箱，拆箱，循环遍历\n\n循环遍历则是把代码还原成迭代器的实现，所以需要被遍历的类实现Iterator接口\n\n变长参数在调用时变成一个数组类型的参数\n\n```java\nInteger a = 1;\nInteger b = 2;\nInteger c = 3;\nInteger d = 3;\nInteger e = 321;\nInteger f = 321;\nLong g = 3L;\nSystem.out.println(c==d);//true\nSystem.out.println(e==f);//false\nSystem.out.println(c==(a+b));//true\nSystem.out.println(c.equals(a+b));//true\nSystem.out.println(g==(a+b));//true\nSystem.out.println(g.equals(a+b));//false\n```\n\n\n\n鉴于包装类的 == 运算在不遇到算术运算的情况下不会自动拆箱，以及他们的equals()方法不处理数据转型的关系，实际编码中尽量避免这样使用自动装箱，拆箱\n\n## 条件编译\n\nJava语言编译方式：编译器并非一个个地编译java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表中再进行编译，因此各个文件之间能够互相提供符号信息\n\nJava的条件编译：使用条件为常量的if语句，它在编译期就会运行\n\n```java\n\npublic static void main(String[] args)\n{\n    if(true)\n    {\n        System.out.println(\"1\");\n    }\n    else\n    {\n        System.out.println(\"2\");\n    }\n}\n```\n\n该代码编译后Class文件的反编译结果：\n\n```java\npublic static void main(String[] args)\n{\n   System.out.println(\"1\");\n}\n```\n\n编译器将会把分支中不成立的代码消除掉。\n\n这种语法糖只能写在方法体内部，只能实现语句基本块级别的条件编译，而没有办法实现根据条件调整整个Java类的结构\n\n","source":"_posts/JVM笔记/第10章_前端编译与优化.md","raw":"---\ntitle: 深入理解Java虚拟机--前端编译与优化\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第10章--前端编译与优化。'\ncategories: JVM学习笔记\ntags:\n  - 深入理解Java虚拟机\n  - JVM\n  - Javac\n  - 语法糖\nabbrlink: c3f1ef69\ndate: 2020-07-17 00:00:00\n---\n\n\n# 概述\n\n编译期可能指以下几种:\n\n1. 前端编译器:把java文件转为class文件的过程,如Javac\n2. 即时编译器(JIT编译器):运行期把字节码转变为本地机器码的过程,如hotspot虚拟机的C1,C2编译器\n3. 静态的提前编译器:直接把程序编译成与目标指令集相关的二进制代码的过程\n\nJava中,即时编译器在运行期的优化过程,支撑了程序执行效率的不断提升,而前端编译器在编译期的优化过程,则是支撑着程序员的编码效率和语言使用者的幸福感的提高\n\n# Javac编译器\n\n## 编译过程\n\n1. 准备过程:初始化插入式注解处理器\n2. 解析与填充符号表过程\n\t+ 词法,语法分析,构造出抽象语法树\n\t+ 填充符号表,产生符号地址和符号信息\n3. 插入式注解处理器的注解处理过程:插入式注解处理器的执行阶段\n4. 语义分析与字节码生成过程\n\t+ 标注检查.对语法的静态信息进行检查\n\t+ 数据流及控制流分析。对程序动态运行过程进行检查\n\t+ 解语法糖。将简化代码编写的语法糖还原为原有的形式\n\t+ 字节码生成。将前面各个步骤所生成的信息转换成字节码\n\n上述动作中，执行插入式注解时有可能会产生新的符号，如果有新符号产生，就必须回到之前的解析，填充符号表的过程中重新处理这些新符号\n\n## 解析与填充符号表\n\n### 词法,语法分析\n\n词法分析是将源代码的字符流转变为标记集合的过程,标记是编译时的最小元素，例如int就是一个标记\n\n语法分析是根据标记序列构造抽象语法树的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式\n\n### 填充符号表\n\n符号表是一组符号地址和符号信息构成的数据结构，可以当作以键值对存储的哈希表\n\n## 注解处理器\n\n插入式注解处理器：注解一般是在运行期起作用，而这提前到编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。\n\n可以把插入式注解处理器看作是编译器的插件，如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为轮次。\n\n插入式注解处理器可以实现很多功能，如通过注解来实现自动产生getter/setter方法，产生equals（），hashCode（）方法\n\n## 语义分析与字节码生成\n\n抽象语法树能表示一个结构正确的源程序，但无法保证源程序的语义符合逻辑。语义分析主要任务是对结构正确的源程序进行上下文相关性质的检查，例如类型检查等\n\n编译时在IDE中看到由红线标注的错误提示，其中绝大部分都是由语义分析阶段的检查结果\n\n### 标注检查\n\n检查变量使用前是否被声明，变量与赋值之间的数据类型是否匹配等\n\n常量折叠：`int a=1+2`,会变成 a=3\n\n### 数据及控制流分析\n\n检查出诸如程序局部变量在使用前是否有赋值，方法的每条路径是否都有返回值，是否所有的受查异常都被正确处理了等问题\n\n### 解语法糖\n\n在语言中添加某种语法，对语言的编译结果和功能没有实际影响，但能方便程序员使用该语言。减少代码量，增加程序可读性，减少程序代码出错的机会\n\n### 字节码生成\n\n实例构造器<init>()方法和类构造器<cinit>(),就是这个阶段添加到语法树的\n\n<init>()，<cinit>()的产生是代码收敛的过程，编译器会把语句块，变量初始化，调用父类的实例构造器等操作收敛到他们两个方法上\n\n并且保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序执行\n\n# Java语法糖的味道\n\n## 泛型\n\n泛型本质是参数化类型或参数化多态的应用。即可以将操作的数据类型指定为方法签名中的一种特殊参数\n\nJava的泛型是“类型擦除式泛型”，只在程序源码中出现，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型（Raw Type），并且在相应的地方插入了强制转型代码\n\n所以ArrayList<Integer>,ArrayList<String> 在运行期是同一种类型\n\n无论在使用效果还是运行效率上，都全面落后于具现化式泛型，唯一优点就是实现擦除式泛型只需要在Java编译器上改进即可...\n\n### 类型擦除\nJava选择把已有的类型泛型化，如ArrayList原地泛型化为ArrayList<T>\n\t\t裸类型应被视为所有该类型泛型化实例的共同父类型\n\t\t让所有泛型化的实例类型，如ArrayList<Integer>,ArrayList<String> 都自动成为ArrayList的子类型\n\t\tJava裸类型的实现：简单粗暴地直接在编译期把ArrayList<Integer>还原为ArrayList，只在元素访问，修改时自动插入一些强制类型转换和检查指令\n\n不过擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息。所以编码时能通过反射手段取得参数化类型\n\n### 问题\n\n#### 对原始类型数据不支持\n\n因为不支持int这些基本类型与Object之间的强制转型，一旦把泛型信息擦除后，到要插入强制转型代码地方就不能进行下去。Java就不支持原生类型的泛型，只能用ArrayList<Integer>,导致了无数构造包装类的装箱，拆箱的开销\n\n#### 代码啰嗦\n\n运行期无法取得泛型类型信息\n\n#### 带来了模棱两可的模糊状况\n\n当泛型遇到重载时\n\n## 自动装箱，拆箱，循环遍历\n\n循环遍历则是把代码还原成迭代器的实现，所以需要被遍历的类实现Iterator接口\n\n变长参数在调用时变成一个数组类型的参数\n\n```java\nInteger a = 1;\nInteger b = 2;\nInteger c = 3;\nInteger d = 3;\nInteger e = 321;\nInteger f = 321;\nLong g = 3L;\nSystem.out.println(c==d);//true\nSystem.out.println(e==f);//false\nSystem.out.println(c==(a+b));//true\nSystem.out.println(c.equals(a+b));//true\nSystem.out.println(g==(a+b));//true\nSystem.out.println(g.equals(a+b));//false\n```\n\n\n\n鉴于包装类的 == 运算在不遇到算术运算的情况下不会自动拆箱，以及他们的equals()方法不处理数据转型的关系，实际编码中尽量避免这样使用自动装箱，拆箱\n\n## 条件编译\n\nJava语言编译方式：编译器并非一个个地编译java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表中再进行编译，因此各个文件之间能够互相提供符号信息\n\nJava的条件编译：使用条件为常量的if语句，它在编译期就会运行\n\n```java\n\npublic static void main(String[] args)\n{\n    if(true)\n    {\n        System.out.println(\"1\");\n    }\n    else\n    {\n        System.out.println(\"2\");\n    }\n}\n```\n\n该代码编译后Class文件的反编译结果：\n\n```java\npublic static void main(String[] args)\n{\n   System.out.println(\"1\");\n}\n```\n\n编译器将会把分支中不成立的代码消除掉。\n\n这种语法糖只能写在方法体内部，只能实现语句基本块级别的条件编译，而没有办法实现根据条件调整整个Java类的结构\n\n","slug":"JVM笔记/第10章_前端编译与优化","published":1,"updated":"2020-11-12T11:57:29.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6vk0007jotpcqcm0hu4","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>编译期可能指以下几种:</p>\n<ol>\n<li>前端编译器:把java文件转为class文件的过程,如Javac</li>\n<li>即时编译器(JIT编译器):运行期把字节码转变为本地机器码的过程,如hotspot虚拟机的C1,C2编译器</li>\n<li>静态的提前编译器:直接把程序编译成与目标指令集相关的二进制代码的过程</li>\n</ol>\n<p>Java中,即时编译器在运行期的优化过程,支撑了程序执行效率的不断提升,而前端编译器在编译期的优化过程,则是支撑着程序员的编码效率和语言使用者的幸福感的提高</p>\n<h1 id=\"Javac编译器\"><a href=\"#Javac编译器\" class=\"headerlink\" title=\"Javac编译器\"></a>Javac编译器</h1><h2 id=\"编译过程\"><a href=\"#编译过程\" class=\"headerlink\" title=\"编译过程\"></a>编译过程</h2><ol>\n<li>准备过程:初始化插入式注解处理器</li>\n<li>解析与填充符号表过程<ul>\n<li>词法,语法分析,构造出抽象语法树</li>\n<li>填充符号表,产生符号地址和符号信息</li>\n</ul>\n</li>\n<li>插入式注解处理器的注解处理过程:插入式注解处理器的执行阶段</li>\n<li>语义分析与字节码生成过程<ul>\n<li>标注检查.对语法的静态信息进行检查</li>\n<li>数据流及控制流分析。对程序动态运行过程进行检查</li>\n<li>解语法糖。将简化代码编写的语法糖还原为原有的形式</li>\n<li>字节码生成。将前面各个步骤所生成的信息转换成字节码</li>\n</ul>\n</li>\n</ol>\n<p>上述动作中，执行插入式注解时有可能会产生新的符号，如果有新符号产生，就必须回到之前的解析，填充符号表的过程中重新处理这些新符号</p>\n<h2 id=\"解析与填充符号表\"><a href=\"#解析与填充符号表\" class=\"headerlink\" title=\"解析与填充符号表\"></a>解析与填充符号表</h2><h3 id=\"词法-语法分析\"><a href=\"#词法-语法分析\" class=\"headerlink\" title=\"词法,语法分析\"></a>词法,语法分析</h3><p>词法分析是将源代码的字符流转变为标记集合的过程,标记是编译时的最小元素，例如int就是一个标记</p>\n<p>语法分析是根据标记序列构造抽象语法树的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式</p>\n<h3 id=\"填充符号表\"><a href=\"#填充符号表\" class=\"headerlink\" title=\"填充符号表\"></a>填充符号表</h3><p>符号表是一组符号地址和符号信息构成的数据结构，可以当作以键值对存储的哈希表</p>\n<h2 id=\"注解处理器\"><a href=\"#注解处理器\" class=\"headerlink\" title=\"注解处理器\"></a>注解处理器</h2><p>插入式注解处理器：注解一般是在运行期起作用，而这提前到编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。</p>\n<p>可以把插入式注解处理器看作是编译器的插件，如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为轮次。</p>\n<p>插入式注解处理器可以实现很多功能，如通过注解来实现自动产生getter/setter方法，产生equals（），hashCode（）方法</p>\n<h2 id=\"语义分析与字节码生成\"><a href=\"#语义分析与字节码生成\" class=\"headerlink\" title=\"语义分析与字节码生成\"></a>语义分析与字节码生成</h2><p>抽象语法树能表示一个结构正确的源程序，但无法保证源程序的语义符合逻辑。语义分析主要任务是对结构正确的源程序进行上下文相关性质的检查，例如类型检查等</p>\n<p>编译时在IDE中看到由红线标注的错误提示，其中绝大部分都是由语义分析阶段的检查结果</p>\n<h3 id=\"标注检查\"><a href=\"#标注检查\" class=\"headerlink\" title=\"标注检查\"></a>标注检查</h3><p>检查变量使用前是否被声明，变量与赋值之间的数据类型是否匹配等</p>\n<p>常量折叠：<code>int a=1+2</code>,会变成 a=3</p>\n<h3 id=\"数据及控制流分析\"><a href=\"#数据及控制流分析\" class=\"headerlink\" title=\"数据及控制流分析\"></a>数据及控制流分析</h3><p>检查出诸如程序局部变量在使用前是否有赋值，方法的每条路径是否都有返回值，是否所有的受查异常都被正确处理了等问题</p>\n<h3 id=\"解语法糖\"><a href=\"#解语法糖\" class=\"headerlink\" title=\"解语法糖\"></a>解语法糖</h3><p>在语言中添加某种语法，对语言的编译结果和功能没有实际影响，但能方便程序员使用该语言。减少代码量，增加程序可读性，减少程序代码出错的机会</p>\n<h3 id=\"字节码生成\"><a href=\"#字节码生成\" class=\"headerlink\" title=\"字节码生成\"></a>字节码生成</h3><p>实例构造器<init>()方法和类构造器<cinit>(),就是这个阶段添加到语法树的</p>\n<p><init>()，<cinit>()的产生是代码收敛的过程，编译器会把语句块，变量初始化，调用父类的实例构造器等操作收敛到他们两个方法上</p>\n<p>并且保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序执行</p>\n<h1 id=\"Java语法糖的味道\"><a href=\"#Java语法糖的味道\" class=\"headerlink\" title=\"Java语法糖的味道\"></a>Java语法糖的味道</h1><h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>泛型本质是参数化类型或参数化多态的应用。即可以将操作的数据类型指定为方法签名中的一种特殊参数</p>\n<p>Java的泛型是“类型擦除式泛型”，只在程序源码中出现，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型（Raw Type），并且在相应的地方插入了强制转型代码</p>\n<p>所以ArrayList<Integer>,ArrayList<String> 在运行期是同一种类型</p>\n<p>无论在使用效果还是运行效率上，都全面落后于具现化式泛型，唯一优点就是实现擦除式泛型只需要在Java编译器上改进即可…</p>\n<h3 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h3><p>Java选择把已有的类型泛型化，如ArrayList原地泛型化为ArrayList<T><br>        裸类型应被视为所有该类型泛型化实例的共同父类型<br>        让所有泛型化的实例类型，如ArrayList<Integer>,ArrayList<String> 都自动成为ArrayList的子类型<br>        Java裸类型的实现：简单粗暴地直接在编译期把ArrayList<Integer>还原为ArrayList，只在元素访问，修改时自动插入一些强制类型转换和检查指令</p>\n<p>不过擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息。所以编码时能通过反射手段取得参数化类型</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><h4 id=\"对原始类型数据不支持\"><a href=\"#对原始类型数据不支持\" class=\"headerlink\" title=\"对原始类型数据不支持\"></a>对原始类型数据不支持</h4><p>因为不支持int这些基本类型与Object之间的强制转型，一旦把泛型信息擦除后，到要插入强制转型代码地方就不能进行下去。Java就不支持原生类型的泛型，只能用ArrayList<Integer>,导致了无数构造包装类的装箱，拆箱的开销</p>\n<h4 id=\"代码啰嗦\"><a href=\"#代码啰嗦\" class=\"headerlink\" title=\"代码啰嗦\"></a>代码啰嗦</h4><p>运行期无法取得泛型类型信息</p>\n<h4 id=\"带来了模棱两可的模糊状况\"><a href=\"#带来了模棱两可的模糊状况\" class=\"headerlink\" title=\"带来了模棱两可的模糊状况\"></a>带来了模棱两可的模糊状况</h4><p>当泛型遇到重载时</p>\n<h2 id=\"自动装箱，拆箱，循环遍历\"><a href=\"#自动装箱，拆箱，循环遍历\" class=\"headerlink\" title=\"自动装箱，拆箱，循环遍历\"></a>自动装箱，拆箱，循环遍历</h2><p>循环遍历则是把代码还原成迭代器的实现，所以需要被遍历的类实现Iterator接口</p>\n<p>变长参数在调用时变成一个数组类型的参数</p>\n<pre class=\" language-java\"><code class=\"language-java\">Integer a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nInteger b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\nInteger c <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\nInteger d <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\nInteger e <span class=\"token operator\">=</span> <span class=\"token number\">321</span><span class=\"token punctuation\">;</span>\nInteger f <span class=\"token operator\">=</span> <span class=\"token number\">321</span><span class=\"token punctuation\">;</span>\nLong g <span class=\"token operator\">=</span> 3L<span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>c<span class=\"token operator\">==</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//true</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>e<span class=\"token operator\">==</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//false</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>c<span class=\"token operator\">==</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">+</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//true</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">+</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//true</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>g<span class=\"token operator\">==</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">+</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//true</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">+</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//false</span></code></pre>\n<p>鉴于包装类的 == 运算在不遇到算术运算的情况下不会自动拆箱，以及他们的equals()方法不处理数据转型的关系，实际编码中尽量避免这样使用自动装箱，拆箱</p>\n<h2 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h2><p>Java语言编译方式：编译器并非一个个地编译java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表中再进行编译，因此各个文件之间能够互相提供符号信息</p>\n<p>Java的条件编译：使用条件为常量的if语句，它在编译期就会运行</p>\n<pre class=\" language-java\"><code class=\"language-java\">\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>该代码编译后Class文件的反编译结果：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n   System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>编译器将会把分支中不成立的代码消除掉。</p>\n<p>这种语法糖只能写在方法体内部，只能实现语句基本块级别的条件编译，而没有办法实现根据条件调整整个Java类的结构</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>编译期可能指以下几种:</p>\n<ol>\n<li>前端编译器:把java文件转为class文件的过程,如Javac</li>\n<li>即时编译器(JIT编译器):运行期把字节码转变为本地机器码的过程,如hotspot虚拟机的C1,C2编译器</li>\n<li>静态的提前编译器:直接把程序编译成与目标指令集相关的二进制代码的过程</li>\n</ol>\n<p>Java中,即时编译器在运行期的优化过程,支撑了程序执行效率的不断提升,而前端编译器在编译期的优化过程,则是支撑着程序员的编码效率和语言使用者的幸福感的提高</p>\n<h1 id=\"Javac编译器\"><a href=\"#Javac编译器\" class=\"headerlink\" title=\"Javac编译器\"></a>Javac编译器</h1><h2 id=\"编译过程\"><a href=\"#编译过程\" class=\"headerlink\" title=\"编译过程\"></a>编译过程</h2><ol>\n<li>准备过程:初始化插入式注解处理器</li>\n<li>解析与填充符号表过程<ul>\n<li>词法,语法分析,构造出抽象语法树</li>\n<li>填充符号表,产生符号地址和符号信息</li>\n</ul>\n</li>\n<li>插入式注解处理器的注解处理过程:插入式注解处理器的执行阶段</li>\n<li>语义分析与字节码生成过程<ul>\n<li>标注检查.对语法的静态信息进行检查</li>\n<li>数据流及控制流分析。对程序动态运行过程进行检查</li>\n<li>解语法糖。将简化代码编写的语法糖还原为原有的形式</li>\n<li>字节码生成。将前面各个步骤所生成的信息转换成字节码</li>\n</ul>\n</li>\n</ol>\n<p>上述动作中，执行插入式注解时有可能会产生新的符号，如果有新符号产生，就必须回到之前的解析，填充符号表的过程中重新处理这些新符号</p>\n<h2 id=\"解析与填充符号表\"><a href=\"#解析与填充符号表\" class=\"headerlink\" title=\"解析与填充符号表\"></a>解析与填充符号表</h2><h3 id=\"词法-语法分析\"><a href=\"#词法-语法分析\" class=\"headerlink\" title=\"词法,语法分析\"></a>词法,语法分析</h3><p>词法分析是将源代码的字符流转变为标记集合的过程,标记是编译时的最小元素，例如int就是一个标记</p>\n<p>语法分析是根据标记序列构造抽象语法树的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式</p>\n<h3 id=\"填充符号表\"><a href=\"#填充符号表\" class=\"headerlink\" title=\"填充符号表\"></a>填充符号表</h3><p>符号表是一组符号地址和符号信息构成的数据结构，可以当作以键值对存储的哈希表</p>\n<h2 id=\"注解处理器\"><a href=\"#注解处理器\" class=\"headerlink\" title=\"注解处理器\"></a>注解处理器</h2><p>插入式注解处理器：注解一般是在运行期起作用，而这提前到编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。</p>\n<p>可以把插入式注解处理器看作是编译器的插件，如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为轮次。</p>\n<p>插入式注解处理器可以实现很多功能，如通过注解来实现自动产生getter/setter方法，产生equals（），hashCode（）方法</p>\n<h2 id=\"语义分析与字节码生成\"><a href=\"#语义分析与字节码生成\" class=\"headerlink\" title=\"语义分析与字节码生成\"></a>语义分析与字节码生成</h2><p>抽象语法树能表示一个结构正确的源程序，但无法保证源程序的语义符合逻辑。语义分析主要任务是对结构正确的源程序进行上下文相关性质的检查，例如类型检查等</p>\n<p>编译时在IDE中看到由红线标注的错误提示，其中绝大部分都是由语义分析阶段的检查结果</p>\n<h3 id=\"标注检查\"><a href=\"#标注检查\" class=\"headerlink\" title=\"标注检查\"></a>标注检查</h3><p>检查变量使用前是否被声明，变量与赋值之间的数据类型是否匹配等</p>\n<p>常量折叠：<code>int a=1+2</code>,会变成 a=3</p>\n<h3 id=\"数据及控制流分析\"><a href=\"#数据及控制流分析\" class=\"headerlink\" title=\"数据及控制流分析\"></a>数据及控制流分析</h3><p>检查出诸如程序局部变量在使用前是否有赋值，方法的每条路径是否都有返回值，是否所有的受查异常都被正确处理了等问题</p>\n<h3 id=\"解语法糖\"><a href=\"#解语法糖\" class=\"headerlink\" title=\"解语法糖\"></a>解语法糖</h3><p>在语言中添加某种语法，对语言的编译结果和功能没有实际影响，但能方便程序员使用该语言。减少代码量，增加程序可读性，减少程序代码出错的机会</p>\n<h3 id=\"字节码生成\"><a href=\"#字节码生成\" class=\"headerlink\" title=\"字节码生成\"></a>字节码生成</h3><p>实例构造器<init>()方法和类构造器<cinit>(),就是这个阶段添加到语法树的</p>\n<p><init>()，<cinit>()的产生是代码收敛的过程，编译器会把语句块，变量初始化，调用父类的实例构造器等操作收敛到他们两个方法上</p>\n<p>并且保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序执行</p>\n<h1 id=\"Java语法糖的味道\"><a href=\"#Java语法糖的味道\" class=\"headerlink\" title=\"Java语法糖的味道\"></a>Java语法糖的味道</h1><h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>泛型本质是参数化类型或参数化多态的应用。即可以将操作的数据类型指定为方法签名中的一种特殊参数</p>\n<p>Java的泛型是“类型擦除式泛型”，只在程序源码中出现，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型（Raw Type），并且在相应的地方插入了强制转型代码</p>\n<p>所以ArrayList<Integer>,ArrayList<String> 在运行期是同一种类型</p>\n<p>无论在使用效果还是运行效率上，都全面落后于具现化式泛型，唯一优点就是实现擦除式泛型只需要在Java编译器上改进即可…</p>\n<h3 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h3><p>Java选择把已有的类型泛型化，如ArrayList原地泛型化为ArrayList<T><br>        裸类型应被视为所有该类型泛型化实例的共同父类型<br>        让所有泛型化的实例类型，如ArrayList<Integer>,ArrayList<String> 都自动成为ArrayList的子类型<br>        Java裸类型的实现：简单粗暴地直接在编译期把ArrayList<Integer>还原为ArrayList，只在元素访问，修改时自动插入一些强制类型转换和检查指令</p>\n<p>不过擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息。所以编码时能通过反射手段取得参数化类型</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><h4 id=\"对原始类型数据不支持\"><a href=\"#对原始类型数据不支持\" class=\"headerlink\" title=\"对原始类型数据不支持\"></a>对原始类型数据不支持</h4><p>因为不支持int这些基本类型与Object之间的强制转型，一旦把泛型信息擦除后，到要插入强制转型代码地方就不能进行下去。Java就不支持原生类型的泛型，只能用ArrayList<Integer>,导致了无数构造包装类的装箱，拆箱的开销</p>\n<h4 id=\"代码啰嗦\"><a href=\"#代码啰嗦\" class=\"headerlink\" title=\"代码啰嗦\"></a>代码啰嗦</h4><p>运行期无法取得泛型类型信息</p>\n<h4 id=\"带来了模棱两可的模糊状况\"><a href=\"#带来了模棱两可的模糊状况\" class=\"headerlink\" title=\"带来了模棱两可的模糊状况\"></a>带来了模棱两可的模糊状况</h4><p>当泛型遇到重载时</p>\n<h2 id=\"自动装箱，拆箱，循环遍历\"><a href=\"#自动装箱，拆箱，循环遍历\" class=\"headerlink\" title=\"自动装箱，拆箱，循环遍历\"></a>自动装箱，拆箱，循环遍历</h2><p>循环遍历则是把代码还原成迭代器的实现，所以需要被遍历的类实现Iterator接口</p>\n<p>变长参数在调用时变成一个数组类型的参数</p>\n<pre><code class=\"java\">Integer a = 1;\nInteger b = 2;\nInteger c = 3;\nInteger d = 3;\nInteger e = 321;\nInteger f = 321;\nLong g = 3L;\nSystem.out.println(c==d);//true\nSystem.out.println(e==f);//false\nSystem.out.println(c==(a+b));//true\nSystem.out.println(c.equals(a+b));//true\nSystem.out.println(g==(a+b));//true\nSystem.out.println(g.equals(a+b));//false</code></pre>\n<p>鉴于包装类的 == 运算在不遇到算术运算的情况下不会自动拆箱，以及他们的equals()方法不处理数据转型的关系，实际编码中尽量避免这样使用自动装箱，拆箱</p>\n<h2 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h2><p>Java语言编译方式：编译器并非一个个地编译java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表中再进行编译，因此各个文件之间能够互相提供符号信息</p>\n<p>Java的条件编译：使用条件为常量的if语句，它在编译期就会运行</p>\n<pre><code class=\"java\">\npublic static void main(String[] args)\n{\n    if(true)\n    {\n        System.out.println(&quot;1&quot;);\n    }\n    else\n    {\n        System.out.println(&quot;2&quot;);\n    }\n}</code></pre>\n<p>该代码编译后Class文件的反编译结果：</p>\n<pre><code class=\"java\">public static void main(String[] args)\n{\n   System.out.println(&quot;1&quot;);\n}</code></pre>\n<p>编译器将会把分支中不成立的代码消除掉。</p>\n<p>这种语法糖只能写在方法体内部，只能实现语句基本块级别的条件编译，而没有办法实现根据条件调整整个Java类的结构</p>\n"},{"title":"深入理解Java虚拟机--线程安全与锁优化","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习<<深入理解Java虚拟机>>所做的笔记,此为书上第13章--线程安全与锁优化。","abbrlink":"27a1f8de","date":"2020-07-25T16:00:00.000Z","_content":"\n# 线程安全\n\n当多个线程同时访问一个对象时,如果不用考虑这些线程在运行时环境下的调度和交替执行,也不需要进行额外的同步,或者在调用方进行任何其他的协调操作,调用这个对象的行为都可以获得正确的结果,就称他为线程安全的\n\n代码本身封装了所有必要的正确性保证手段(如互斥同步等),令调用者无须关心多线程下的调用问题,更无须自己实现任何措施来保证多线程环境下的正确调用.一般弱化为单次调用\n\n\n\n## Java中的线程安全\n\n以多个线程间存在共享数据的访问为前提\n\n### 不可变\n\n不可变对象一定是线程安全的。只要一个不可变对象被正确的创建出来了，那其外部的可见状态让永远不会改变，永远不会看到他在多个线程之中处于不一致的状态。\n\n用final修饰，或者一个对象自行保证其行为不会对其状态产生任何影响，如String\n\n### 绝对线程安全\n\n在Java API中标注自己是线程安全的类，绝大多数都不是绝对的线程安全\n\n### 相对线程安全\n\n通常意义上的线程安全，需要保证对这个对象的单次操作是线程安全的，在调用的时候不需要进行额外的保障操作。\n\n### 线程兼容\n\n对象本身不是线程安全的。如ArrayList，HashMap等\n\n### 线程对立\n\n不管调用端是否采用了同步措施，都无法在多线程环境中并发使用代码。很少出现，通常有害，尽量避免\n\n## 线程安全的实现方法\n\n### 互斥同步\n\n同步：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用\n\n互斥：实现同步的一个手段\n\nsynchronized关键字，在经过javac编译后，会在同步块前后分别形成monitorenter,monitorexit两条字节码指令。需要一个reference类型的参数来指明要锁定，解锁的对象。\n\n如果没有明确规定，则如果是实例方法就用对象实例作为锁，否则用该类型的Class对象作为锁\n\n在执行monitorenter指令时，首先要去尝试获取对象的锁。如果该对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加1，而在执行monitorexit指令时会把锁计数器值-1。一旦计数器的值为0，锁立即被释放。如果获取对象锁失败，当前线程就应该被阻塞等待，直到请求锁定的对象被持有他的对象释放为止。\n\n1. 被synchronized关键字修饰的同步块对同一个线程来说是可重入的。\n\n2. 被synchronized关键字修饰的同步块在持有锁的线程释放锁之前，会无条件阻塞后面其他线程的进入。\n\n\t\n\n### 重入锁（ReentrantLock)\n与synchronized的不同：\n1. 等待可中断：正在等待的线程可以放弃等待，改为处理其他事情。\n2. 公平锁：可以通过设置，按照申请锁的时间顺序来依次获得锁\n3. 锁锁定多个对象：一个ReentrantLock对象可以同时绑定多个Condition对象\n\n在ReentrantLock与synchronized同时满足时优先使用synchronized：\n1. synchronized是Java语言层面的同步，足够清晰\n2. synchronized由Java虚拟机保证即使出现异常，锁也能被正确释放\n3. Java虚拟机更容易针对synchronized进行优化\n\n### 非阻塞同步\n互斥同步是一种悲观的并发策略：其总是认为如果不去加锁，就肯定出问题。所以无论是否出现竞争，他都会加锁。\n基于冲突检测的乐观并发策略（无锁）：不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。\n\n需要保证操作和冲突检测这两个步骤具有原子性。例如：\n测试并设置（TAS），比较和交换（CAS）\nCAS（变量的内存地址V，旧的预期值A，准备设置的新值B):仅当V符合A时，处理器才会用B更新V的值，否则就不执行更新。无论是否更新V，都会返回A，整个操作是原子操作\nJava提供compareAndSet操作，一般使用逻辑：\n```java\nfor(;;)\n{\n\tint current=get();\n\tint next=current+1;\n\tif(compareAndSet(current,next))\n\t{\n\t\treturn next;\n\t}\n}\n```\n可能出现ABA问题，可以通过：提供一个带有标记的原子引用类控制变量值的版本来保证CAS的正确性\n\n### 无同步方案\n#### 可重入代码\n是线程安全代码的一个子集。如果一个方法的返回结果是可以预测的，只要输入相同的数据，就能返回相同的结果，就满足可重入的要求，就是线程安全的。\n#### 线程本地存储\n如果一段代码中所需要的数据必须与其他代码共享，但是这些共享数据的代码能保证在同一个线程中执行。如Web交互模型中的“一个请求对应一个服务器线程”\n\n# 锁优化\n## 自旋锁与只适应自旋\n自旋锁：很多应用上，共享数据的锁定状态只会持续很短一段时间。可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环。自旋有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就会用传统的方式挂起线程。\n只适应自旋：自旋的时间不是固定的，而是由前一个在同一个锁上的自旋时间以及锁的拥有者的状态来决定\n## 锁消除\n即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。来源于逃逸分析技术。如果判断一段代码中所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的\n## 锁粗化\n原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，就应该把加锁同步的范围粗化到整个操作序列的外部。\n## 轻量级锁\n在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量造成的性能消耗\n### 对象的内存布局\n对象头：\n第一部分是MarkWord用于存储对象自身的运行时数据，如HashCode，GC分代年龄等\n另一部分存储指向方法区对象类型数据的指针。\n如果是数组对象，还有一个额外的部分存储数组长度\n\nMarkWord根据对象的状态复用自己的存储空间。\n轻量级锁能提升程序同步性能的依据：对于绝大部分的锁，在整个同步期间都是没有竞争的\n\n### 偏向锁\n在无竞争的情况下把整个同步都消除掉，这个锁会偏向于第一个获得他的线程","source":"_posts/JVM笔记/第13章_线程安全与锁优化.md","raw":"---\ntitle: 深入理解Java虚拟机--线程安全与锁优化\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第13章--线程安全与锁优化。'\ncategories: JVM学习笔记\ntags:\n  - 深入理解Java虚拟机\n  - 线程\n  - 锁\nabbrlink: 27a1f8de\ndate: 2020-07-26 00:00:00\n---\n\n# 线程安全\n\n当多个线程同时访问一个对象时,如果不用考虑这些线程在运行时环境下的调度和交替执行,也不需要进行额外的同步,或者在调用方进行任何其他的协调操作,调用这个对象的行为都可以获得正确的结果,就称他为线程安全的\n\n代码本身封装了所有必要的正确性保证手段(如互斥同步等),令调用者无须关心多线程下的调用问题,更无须自己实现任何措施来保证多线程环境下的正确调用.一般弱化为单次调用\n\n\n\n## Java中的线程安全\n\n以多个线程间存在共享数据的访问为前提\n\n### 不可变\n\n不可变对象一定是线程安全的。只要一个不可变对象被正确的创建出来了，那其外部的可见状态让永远不会改变，永远不会看到他在多个线程之中处于不一致的状态。\n\n用final修饰，或者一个对象自行保证其行为不会对其状态产生任何影响，如String\n\n### 绝对线程安全\n\n在Java API中标注自己是线程安全的类，绝大多数都不是绝对的线程安全\n\n### 相对线程安全\n\n通常意义上的线程安全，需要保证对这个对象的单次操作是线程安全的，在调用的时候不需要进行额外的保障操作。\n\n### 线程兼容\n\n对象本身不是线程安全的。如ArrayList，HashMap等\n\n### 线程对立\n\n不管调用端是否采用了同步措施，都无法在多线程环境中并发使用代码。很少出现，通常有害，尽量避免\n\n## 线程安全的实现方法\n\n### 互斥同步\n\n同步：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用\n\n互斥：实现同步的一个手段\n\nsynchronized关键字，在经过javac编译后，会在同步块前后分别形成monitorenter,monitorexit两条字节码指令。需要一个reference类型的参数来指明要锁定，解锁的对象。\n\n如果没有明确规定，则如果是实例方法就用对象实例作为锁，否则用该类型的Class对象作为锁\n\n在执行monitorenter指令时，首先要去尝试获取对象的锁。如果该对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加1，而在执行monitorexit指令时会把锁计数器值-1。一旦计数器的值为0，锁立即被释放。如果获取对象锁失败，当前线程就应该被阻塞等待，直到请求锁定的对象被持有他的对象释放为止。\n\n1. 被synchronized关键字修饰的同步块对同一个线程来说是可重入的。\n\n2. 被synchronized关键字修饰的同步块在持有锁的线程释放锁之前，会无条件阻塞后面其他线程的进入。\n\n\t\n\n### 重入锁（ReentrantLock)\n与synchronized的不同：\n1. 等待可中断：正在等待的线程可以放弃等待，改为处理其他事情。\n2. 公平锁：可以通过设置，按照申请锁的时间顺序来依次获得锁\n3. 锁锁定多个对象：一个ReentrantLock对象可以同时绑定多个Condition对象\n\n在ReentrantLock与synchronized同时满足时优先使用synchronized：\n1. synchronized是Java语言层面的同步，足够清晰\n2. synchronized由Java虚拟机保证即使出现异常，锁也能被正确释放\n3. Java虚拟机更容易针对synchronized进行优化\n\n### 非阻塞同步\n互斥同步是一种悲观的并发策略：其总是认为如果不去加锁，就肯定出问题。所以无论是否出现竞争，他都会加锁。\n基于冲突检测的乐观并发策略（无锁）：不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。\n\n需要保证操作和冲突检测这两个步骤具有原子性。例如：\n测试并设置（TAS），比较和交换（CAS）\nCAS（变量的内存地址V，旧的预期值A，准备设置的新值B):仅当V符合A时，处理器才会用B更新V的值，否则就不执行更新。无论是否更新V，都会返回A，整个操作是原子操作\nJava提供compareAndSet操作，一般使用逻辑：\n```java\nfor(;;)\n{\n\tint current=get();\n\tint next=current+1;\n\tif(compareAndSet(current,next))\n\t{\n\t\treturn next;\n\t}\n}\n```\n可能出现ABA问题，可以通过：提供一个带有标记的原子引用类控制变量值的版本来保证CAS的正确性\n\n### 无同步方案\n#### 可重入代码\n是线程安全代码的一个子集。如果一个方法的返回结果是可以预测的，只要输入相同的数据，就能返回相同的结果，就满足可重入的要求，就是线程安全的。\n#### 线程本地存储\n如果一段代码中所需要的数据必须与其他代码共享，但是这些共享数据的代码能保证在同一个线程中执行。如Web交互模型中的“一个请求对应一个服务器线程”\n\n# 锁优化\n## 自旋锁与只适应自旋\n自旋锁：很多应用上，共享数据的锁定状态只会持续很短一段时间。可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环。自旋有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就会用传统的方式挂起线程。\n只适应自旋：自旋的时间不是固定的，而是由前一个在同一个锁上的自旋时间以及锁的拥有者的状态来决定\n## 锁消除\n即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。来源于逃逸分析技术。如果判断一段代码中所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的\n## 锁粗化\n原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，就应该把加锁同步的范围粗化到整个操作序列的外部。\n## 轻量级锁\n在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量造成的性能消耗\n### 对象的内存布局\n对象头：\n第一部分是MarkWord用于存储对象自身的运行时数据，如HashCode，GC分代年龄等\n另一部分存储指向方法区对象类型数据的指针。\n如果是数组对象，还有一个额外的部分存储数组长度\n\nMarkWord根据对象的状态复用自己的存储空间。\n轻量级锁能提升程序同步性能的依据：对于绝大部分的锁，在整个同步期间都是没有竞争的\n\n### 偏向锁\n在无竞争的情况下把整个同步都消除掉，这个锁会偏向于第一个获得他的线程","slug":"JVM笔记/第13章_线程安全与锁优化","published":1,"updated":"2020-11-12T11:57:29.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6vo000ajotp79sr9reb","content":"<h1 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h1><p>当多个线程同时访问一个对象时,如果不用考虑这些线程在运行时环境下的调度和交替执行,也不需要进行额外的同步,或者在调用方进行任何其他的协调操作,调用这个对象的行为都可以获得正确的结果,就称他为线程安全的</p>\n<p>代码本身封装了所有必要的正确性保证手段(如互斥同步等),令调用者无须关心多线程下的调用问题,更无须自己实现任何措施来保证多线程环境下的正确调用.一般弱化为单次调用</p>\n<h2 id=\"Java中的线程安全\"><a href=\"#Java中的线程安全\" class=\"headerlink\" title=\"Java中的线程安全\"></a>Java中的线程安全</h2><p>以多个线程间存在共享数据的访问为前提</p>\n<h3 id=\"不可变\"><a href=\"#不可变\" class=\"headerlink\" title=\"不可变\"></a>不可变</h3><p>不可变对象一定是线程安全的。只要一个不可变对象被正确的创建出来了，那其外部的可见状态让永远不会改变，永远不会看到他在多个线程之中处于不一致的状态。</p>\n<p>用final修饰，或者一个对象自行保证其行为不会对其状态产生任何影响，如String</p>\n<h3 id=\"绝对线程安全\"><a href=\"#绝对线程安全\" class=\"headerlink\" title=\"绝对线程安全\"></a>绝对线程安全</h3><p>在Java API中标注自己是线程安全的类，绝大多数都不是绝对的线程安全</p>\n<h3 id=\"相对线程安全\"><a href=\"#相对线程安全\" class=\"headerlink\" title=\"相对线程安全\"></a>相对线程安全</h3><p>通常意义上的线程安全，需要保证对这个对象的单次操作是线程安全的，在调用的时候不需要进行额外的保障操作。</p>\n<h3 id=\"线程兼容\"><a href=\"#线程兼容\" class=\"headerlink\" title=\"线程兼容\"></a>线程兼容</h3><p>对象本身不是线程安全的。如ArrayList，HashMap等</p>\n<h3 id=\"线程对立\"><a href=\"#线程对立\" class=\"headerlink\" title=\"线程对立\"></a>线程对立</h3><p>不管调用端是否采用了同步措施，都无法在多线程环境中并发使用代码。很少出现，通常有害，尽量避免</p>\n<h2 id=\"线程安全的实现方法\"><a href=\"#线程安全的实现方法\" class=\"headerlink\" title=\"线程安全的实现方法\"></a>线程安全的实现方法</h2><h3 id=\"互斥同步\"><a href=\"#互斥同步\" class=\"headerlink\" title=\"互斥同步\"></a>互斥同步</h3><p>同步：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用</p>\n<p>互斥：实现同步的一个手段</p>\n<p>synchronized关键字，在经过javac编译后，会在同步块前后分别形成monitorenter,monitorexit两条字节码指令。需要一个reference类型的参数来指明要锁定，解锁的对象。</p>\n<p>如果没有明确规定，则如果是实例方法就用对象实例作为锁，否则用该类型的Class对象作为锁</p>\n<p>在执行monitorenter指令时，首先要去尝试获取对象的锁。如果该对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加1，而在执行monitorexit指令时会把锁计数器值-1。一旦计数器的值为0，锁立即被释放。如果获取对象锁失败，当前线程就应该被阻塞等待，直到请求锁定的对象被持有他的对象释放为止。</p>\n<ol>\n<li><p>被synchronized关键字修饰的同步块对同一个线程来说是可重入的。</p>\n</li>\n<li><p>被synchronized关键字修饰的同步块在持有锁的线程释放锁之前，会无条件阻塞后面其他线程的进入。</p>\n</li>\n</ol>\n<h3 id=\"重入锁（ReentrantLock\"><a href=\"#重入锁（ReentrantLock\" class=\"headerlink\" title=\"重入锁（ReentrantLock)\"></a>重入锁（ReentrantLock)</h3><p>与synchronized的不同：</p>\n<ol>\n<li>等待可中断：正在等待的线程可以放弃等待，改为处理其他事情。</li>\n<li>公平锁：可以通过设置，按照申请锁的时间顺序来依次获得锁</li>\n<li>锁锁定多个对象：一个ReentrantLock对象可以同时绑定多个Condition对象</li>\n</ol>\n<p>在ReentrantLock与synchronized同时满足时优先使用synchronized：</p>\n<ol>\n<li>synchronized是Java语言层面的同步，足够清晰</li>\n<li>synchronized由Java虚拟机保证即使出现异常，锁也能被正确释放</li>\n<li>Java虚拟机更容易针对synchronized进行优化</li>\n</ol>\n<h3 id=\"非阻塞同步\"><a href=\"#非阻塞同步\" class=\"headerlink\" title=\"非阻塞同步\"></a>非阻塞同步</h3><p>互斥同步是一种悲观的并发策略：其总是认为如果不去加锁，就肯定出问题。所以无论是否出现竞争，他都会加锁。<br>基于冲突检测的乐观并发策略（无锁）：不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。</p>\n<p>需要保证操作和冲突检测这两个步骤具有原子性。例如：<br>测试并设置（TAS），比较和交换（CAS）<br>CAS（变量的内存地址V，旧的预期值A，准备设置的新值B):仅当V符合A时，处理器才会用B更新V的值，否则就不执行更新。无论是否更新V，都会返回A，整个操作是原子操作<br>Java提供compareAndSet操作，一般使用逻辑：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> current<span class=\"token operator\">=</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> next<span class=\"token operator\">=</span>current<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>可能出现ABA问题，可以通过：提供一个带有标记的原子引用类控制变量值的版本来保证CAS的正确性</p>\n<h3 id=\"无同步方案\"><a href=\"#无同步方案\" class=\"headerlink\" title=\"无同步方案\"></a>无同步方案</h3><h4 id=\"可重入代码\"><a href=\"#可重入代码\" class=\"headerlink\" title=\"可重入代码\"></a>可重入代码</h4><p>是线程安全代码的一个子集。如果一个方法的返回结果是可以预测的，只要输入相同的数据，就能返回相同的结果，就满足可重入的要求，就是线程安全的。</p>\n<h4 id=\"线程本地存储\"><a href=\"#线程本地存储\" class=\"headerlink\" title=\"线程本地存储\"></a>线程本地存储</h4><p>如果一段代码中所需要的数据必须与其他代码共享，但是这些共享数据的代码能保证在同一个线程中执行。如Web交互模型中的“一个请求对应一个服务器线程”</p>\n<h1 id=\"锁优化\"><a href=\"#锁优化\" class=\"headerlink\" title=\"锁优化\"></a>锁优化</h1><h2 id=\"自旋锁与只适应自旋\"><a href=\"#自旋锁与只适应自旋\" class=\"headerlink\" title=\"自旋锁与只适应自旋\"></a>自旋锁与只适应自旋</h2><p>自旋锁：很多应用上，共享数据的锁定状态只会持续很短一段时间。可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环。自旋有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就会用传统的方式挂起线程。<br>只适应自旋：自旋的时间不是固定的，而是由前一个在同一个锁上的自旋时间以及锁的拥有者的状态来决定</p>\n<h2 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h2><p>即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。来源于逃逸分析技术。如果判断一段代码中所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的</p>\n<h2 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h2><p>原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，就应该把加锁同步的范围粗化到整个操作序列的外部。</p>\n<h2 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h2><p>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量造成的性能消耗</p>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><p>对象头：<br>第一部分是MarkWord用于存储对象自身的运行时数据，如HashCode，GC分代年龄等<br>另一部分存储指向方法区对象类型数据的指针。<br>如果是数组对象，还有一个额外的部分存储数组长度</p>\n<p>MarkWord根据对象的状态复用自己的存储空间。<br>轻量级锁能提升程序同步性能的依据：对于绝大部分的锁，在整个同步期间都是没有竞争的</p>\n<h3 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h3><p>在无竞争的情况下把整个同步都消除掉，这个锁会偏向于第一个获得他的线程</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h1><p>当多个线程同时访问一个对象时,如果不用考虑这些线程在运行时环境下的调度和交替执行,也不需要进行额外的同步,或者在调用方进行任何其他的协调操作,调用这个对象的行为都可以获得正确的结果,就称他为线程安全的</p>\n<p>代码本身封装了所有必要的正确性保证手段(如互斥同步等),令调用者无须关心多线程下的调用问题,更无须自己实现任何措施来保证多线程环境下的正确调用.一般弱化为单次调用</p>\n<h2 id=\"Java中的线程安全\"><a href=\"#Java中的线程安全\" class=\"headerlink\" title=\"Java中的线程安全\"></a>Java中的线程安全</h2><p>以多个线程间存在共享数据的访问为前提</p>\n<h3 id=\"不可变\"><a href=\"#不可变\" class=\"headerlink\" title=\"不可变\"></a>不可变</h3><p>不可变对象一定是线程安全的。只要一个不可变对象被正确的创建出来了，那其外部的可见状态让永远不会改变，永远不会看到他在多个线程之中处于不一致的状态。</p>\n<p>用final修饰，或者一个对象自行保证其行为不会对其状态产生任何影响，如String</p>\n<h3 id=\"绝对线程安全\"><a href=\"#绝对线程安全\" class=\"headerlink\" title=\"绝对线程安全\"></a>绝对线程安全</h3><p>在Java API中标注自己是线程安全的类，绝大多数都不是绝对的线程安全</p>\n<h3 id=\"相对线程安全\"><a href=\"#相对线程安全\" class=\"headerlink\" title=\"相对线程安全\"></a>相对线程安全</h3><p>通常意义上的线程安全，需要保证对这个对象的单次操作是线程安全的，在调用的时候不需要进行额外的保障操作。</p>\n<h3 id=\"线程兼容\"><a href=\"#线程兼容\" class=\"headerlink\" title=\"线程兼容\"></a>线程兼容</h3><p>对象本身不是线程安全的。如ArrayList，HashMap等</p>\n<h3 id=\"线程对立\"><a href=\"#线程对立\" class=\"headerlink\" title=\"线程对立\"></a>线程对立</h3><p>不管调用端是否采用了同步措施，都无法在多线程环境中并发使用代码。很少出现，通常有害，尽量避免</p>\n<h2 id=\"线程安全的实现方法\"><a href=\"#线程安全的实现方法\" class=\"headerlink\" title=\"线程安全的实现方法\"></a>线程安全的实现方法</h2><h3 id=\"互斥同步\"><a href=\"#互斥同步\" class=\"headerlink\" title=\"互斥同步\"></a>互斥同步</h3><p>同步：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用</p>\n<p>互斥：实现同步的一个手段</p>\n<p>synchronized关键字，在经过javac编译后，会在同步块前后分别形成monitorenter,monitorexit两条字节码指令。需要一个reference类型的参数来指明要锁定，解锁的对象。</p>\n<p>如果没有明确规定，则如果是实例方法就用对象实例作为锁，否则用该类型的Class对象作为锁</p>\n<p>在执行monitorenter指令时，首先要去尝试获取对象的锁。如果该对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加1，而在执行monitorexit指令时会把锁计数器值-1。一旦计数器的值为0，锁立即被释放。如果获取对象锁失败，当前线程就应该被阻塞等待，直到请求锁定的对象被持有他的对象释放为止。</p>\n<ol>\n<li><p>被synchronized关键字修饰的同步块对同一个线程来说是可重入的。</p>\n</li>\n<li><p>被synchronized关键字修饰的同步块在持有锁的线程释放锁之前，会无条件阻塞后面其他线程的进入。</p>\n</li>\n</ol>\n<h3 id=\"重入锁（ReentrantLock\"><a href=\"#重入锁（ReentrantLock\" class=\"headerlink\" title=\"重入锁（ReentrantLock)\"></a>重入锁（ReentrantLock)</h3><p>与synchronized的不同：</p>\n<ol>\n<li>等待可中断：正在等待的线程可以放弃等待，改为处理其他事情。</li>\n<li>公平锁：可以通过设置，按照申请锁的时间顺序来依次获得锁</li>\n<li>锁锁定多个对象：一个ReentrantLock对象可以同时绑定多个Condition对象</li>\n</ol>\n<p>在ReentrantLock与synchronized同时满足时优先使用synchronized：</p>\n<ol>\n<li>synchronized是Java语言层面的同步，足够清晰</li>\n<li>synchronized由Java虚拟机保证即使出现异常，锁也能被正确释放</li>\n<li>Java虚拟机更容易针对synchronized进行优化</li>\n</ol>\n<h3 id=\"非阻塞同步\"><a href=\"#非阻塞同步\" class=\"headerlink\" title=\"非阻塞同步\"></a>非阻塞同步</h3><p>互斥同步是一种悲观的并发策略：其总是认为如果不去加锁，就肯定出问题。所以无论是否出现竞争，他都会加锁。<br>基于冲突检测的乐观并发策略（无锁）：不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。</p>\n<p>需要保证操作和冲突检测这两个步骤具有原子性。例如：<br>测试并设置（TAS），比较和交换（CAS）<br>CAS（变量的内存地址V，旧的预期值A，准备设置的新值B):仅当V符合A时，处理器才会用B更新V的值，否则就不执行更新。无论是否更新V，都会返回A，整个操作是原子操作<br>Java提供compareAndSet操作，一般使用逻辑：</p>\n<pre><code class=\"java\">for(;;)\n{\n    int current=get();\n    int next=current+1;\n    if(compareAndSet(current,next))\n    {\n        return next;\n    }\n}</code></pre>\n<p>可能出现ABA问题，可以通过：提供一个带有标记的原子引用类控制变量值的版本来保证CAS的正确性</p>\n<h3 id=\"无同步方案\"><a href=\"#无同步方案\" class=\"headerlink\" title=\"无同步方案\"></a>无同步方案</h3><h4 id=\"可重入代码\"><a href=\"#可重入代码\" class=\"headerlink\" title=\"可重入代码\"></a>可重入代码</h4><p>是线程安全代码的一个子集。如果一个方法的返回结果是可以预测的，只要输入相同的数据，就能返回相同的结果，就满足可重入的要求，就是线程安全的。</p>\n<h4 id=\"线程本地存储\"><a href=\"#线程本地存储\" class=\"headerlink\" title=\"线程本地存储\"></a>线程本地存储</h4><p>如果一段代码中所需要的数据必须与其他代码共享，但是这些共享数据的代码能保证在同一个线程中执行。如Web交互模型中的“一个请求对应一个服务器线程”</p>\n<h1 id=\"锁优化\"><a href=\"#锁优化\" class=\"headerlink\" title=\"锁优化\"></a>锁优化</h1><h2 id=\"自旋锁与只适应自旋\"><a href=\"#自旋锁与只适应自旋\" class=\"headerlink\" title=\"自旋锁与只适应自旋\"></a>自旋锁与只适应自旋</h2><p>自旋锁：很多应用上，共享数据的锁定状态只会持续很短一段时间。可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环。自旋有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就会用传统的方式挂起线程。<br>只适应自旋：自旋的时间不是固定的，而是由前一个在同一个锁上的自旋时间以及锁的拥有者的状态来决定</p>\n<h2 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h2><p>即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。来源于逃逸分析技术。如果判断一段代码中所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的</p>\n<h2 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h2><p>原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，就应该把加锁同步的范围粗化到整个操作序列的外部。</p>\n<h2 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h2><p>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量造成的性能消耗</p>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><p>对象头：<br>第一部分是MarkWord用于存储对象自身的运行时数据，如HashCode，GC分代年龄等<br>另一部分存储指向方法区对象类型数据的指针。<br>如果是数组对象，还有一个额外的部分存储数组长度</p>\n<p>MarkWord根据对象的状态复用自己的存储空间。<br>轻量级锁能提升程序同步性能的依据：对于绝大部分的锁，在整个同步期间都是没有竞争的</p>\n<h3 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h3><p>在无竞争的情况下把整个同步都消除掉，这个锁会偏向于第一个获得他的线程</p>\n"},{"title":"深入理解Java虚拟机--Java内存模型与线程","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习<<深入理解Java虚拟机>>所做的笔记,此为书上第12章--Java内存模型与线程。","abbrlink":"ce3193b6","date":"2020-07-22T16:00:00.000Z","_content":"\n# 概述\n\n多任务处理原因:计算机运算能力强大了,计算机运算速度与他的存储和通信子系统的速度差异大,一个服务端要同时对多个客户端提供服务\n\n# 硬件的效率与一致性\n\n让计算机并发执行若干个计算任务与更充分地利用计算机处理器的效能之间的关系没这么简单\n\n因为绝大多数的运算任务都不可能只靠处理器的计算完成,还需要与内存的交互等。因为CPU和存储设备速度的差异，现代计算机系统加入一层或多层高速缓存作为内存和处理器的缓冲\n\n## 缓存一致性\n\n共享内存多核系统：在多路处理器系统，每个处理器都有自己的高速缓存，而他们又共享同一个主内存\n\n当多个处理器的运算任务都涉及到同一块主内存时，将可能遇到缓存不一致的情况，所以需要遵守一定的协议。\n\n## 指令重排序优化\n\n为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码的顺序是一致的\n\n因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性不能靠代码的先后顺序保证\n\n# Java内存模型\n\n## 主内存和工作内存\n\n定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储在内存和从内存中取出变量值这样的底层细节。\n\n此次变量不包括局部变量和方法参数，因为他们是线程私有的，不会被共享，没有竞争问题\n\n所有变量都存储在主内存中，每个线程还有自己的工作内存。工作内存保存了被改线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，不能直接读取主内存的数据\n\n主内存直接对应于物理硬件的内存，工作内存优先存储于寄存器和高速缓存中\n\n## 内存间交互操作\n\n主内存和工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存这一类的实现细节\n\n下面每个操作都是原子的，不可再分的\n\n1. lock 作用于主内存变量，把变量标识为线程独占\n2. unlock 作用于主内存变量，把变量从锁定状态释放\n3. read 作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中\n4. load 作用于工作内存变量，把read操作从主内存中得到到变量值放入工作内存的变量副本中\n5. use 作用于工作内存变量，把工作内存中一个变量的值传递给执行引擎\n6. assign 作用于工作内存变量，把一个从执行引擎接收的值赋给工作内存的变量\n7. store 作用于工作内存变量，把工作内存中一个变量的值传送到主内存中\n8. write 作用于主内存变量，把store操作从工作内存中得到的变量值放入主内存的变量中\n\n之后简化为read,write,lock,unlock,但只是语言描述简化，内存模型的基础设计没变\n\n之后可以采用一个等效的判断原则：先行发生原则，用来确定一个操作在并发情况下是否安全 \n\n## 对于volatile型变量的特殊规则\n\n提供的最轻量级的同步机制\n\n两大特性\n\n### 保证此量对所有线程的可见性\n\n指当一条线程修改了这个变量的值，新值对于其他线程来说是立即得知的\n\n误解：volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的\n\nvolatile变量在各个线程的工作内存中是不存在一致性问题，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的\n\n例子：一条race++ 指令，由四条字节码指令构成，当`getstatic`指令把race的值取到操作栈顶时，`volatile`关键字保证此时race的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的race值同步回主内存中\n\n由于volatile只能保证可见性，除了以下两种情况外，其余都要通过加锁解决：\n\n1. 运算结果并不依赖于变量的当前值，或者能够确保只有单一的线程修改变量的值\n2. 变量不需要于其他的状态变量共同参与不变约束\n\n### 禁止指令重排序优化\n\n普通变量只能保证结果正确，不能保证变量赋值操作的顺序与程序代码的执行顺序是一致的\n\n即线程内表现为串行的语义\n\n有volatile修饰的变量，赋值后多执行一个`lock addl $0x0,(%esp)`操作，该操作相当于一个内存屏障，指重排序时不能把后面的指令重排序到内存屏障之前的位置\n\n`lock addl $0x0,(%esp)`操作将本处理器的缓存写入到内存，会引发其他处理器无效化他们的缓存，所以可以让volatile变量的修改对其他处理器立即可见\n\n从硬件架构上，指令重排序是指处理器采用了运行将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，他必须能正确处理指令依赖情况，保证能输出正确的结果\n\n在同一个处理器中，重排序后的代码看起来仍然是有序的，`lock addl $0x0,(%esp)`把修改同步到缓存时，意味着所有之前的操作已经完成了，就形成了指令重排序无法越过内存屏障的效果\n\n只有一个处理器访问内存时，不需要内存配置，但是有多个处理器访问同一块内存，且其中一个在观测另一个，就需要内存屏障来保证一致性\n\n### 效率\nvolatile变量读操作性能消耗和普通变量差不多，写操作因为要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，会慢一些\nvolatile变量总开销比锁低，在volatile与锁之前选择的唯一依据仅仅是volatile能否满足使用场景的要求\n## 针对long和double型变量的特殊规则\nlong和double的非原子性协定：运行虚拟机将并未声明为volatile的64位数据的读取划分为两次32位的操作进行\n如果有多个线程共享一个并未声明为volatile的long和double型变量，并且同时对他们进行读取和修改操作，可能会读取到半个变量的数值\n不过非常罕见，64位Java虚拟机不会出现，32位的也通常不会出现。所以在实际开发中，除非该数据有明确可知的线程竞争，否则一般不需要刻意把long和double型变量声明为volatile\n\n## 原子性，可见性，有序性\n### 原子性\n大致可以认为，基本数据类型的访问读写都是具备原子性的\nsynchronized块之间的操作也具备原子性\n### 可见性\n当一个线程修改了共享变量的值时，其他变量能立即得知这个修改。\n三种可见性方式：\nvolatile变量：保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新\nsynchronized关键字：对一个变量执行unlock之前，必须先把此变量同步回主内存中\nfinal：被final修饰的字段在构造器一旦被初始化完成，并且构造器没有把this的引用参数传递出去，那么在其他线程中就能看到final字段的值\n### 有序性\n天然的有序性：如果在本线程内观测，所有的操作都是有序的；如果在一个线程中观测另一个线程，所有的操作都是无序的。前半句是指线程内似表现为串行的语义，后半句是指指令重排序和工作内存与主内存同步延迟现象。\nvolatile，synchronized关键字保证线程之间操作的有序性。前者本身就包含了禁止指令重排序的语义，后者由一个变量同一时刻只允许一条线程对其lock操作获得\nsynchronized关键字很万能，但是被滥用了，越万能的并发控制，通常会伴随越大的性能影响\n\n## 先行发生原则\n是判断数据是否竞争，线程是否安全的非常有用的手段\n先行发生：例如说操作A先行发生于操作B，则指发生操作B之前，操作A产生的影响能被操作B观察到\nJava语言中无须任何同步手段保障就能成立的先行发生原则如下，如果两个操作之间的关系无法从下述规则推导出来，他们就没有顺序性保证，虚拟机就能对他们随意地重排序\n1. 程序次序规则：一个线程内，按照控制流顺序前面的操作比后面的操作先执行\n2. 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作\n3. volatile变量规则：对一个 volatile变量的写操作先行发生于后面对这个变量的读操作\n4. 线程启动规则：Thread的start（）方法先行发生于该线程的每一个动作\n5. 线程终止规则：线程的所有操作先行发生于对该线程的终止检测\n6. 线程中断规则：对线程interrupt（）方法的调用优先于被中断线程的代码检测到中断事件发生\n7. 对象终结规则：一个对象的初始化方法优先于他的finalized（）方法\n8. 传递性：A先行发生于B，B先行发生于C，则A先行发生于C\n\n时间先后顺序与先行发生原则之间没有因果关系，所以衡量并发安全问题不要受时间顺序的影响，一切以先行发生原则为准\n# Java与线程\n## 线程的实现\n### 内核线程实现\n1：1实现， 内核线程就是直接由操作系统内核支持的线程，由内核来完成线程切换。一般使用内核线程的高级接口-轻量级进程\n内核线程的操作都需要进行系统调用，需要在用户态核心态切换，要消耗一定的内核资源。\n### 用户线程的实现\n用户线程为1：N的实现，完全建立在用户空间的线程库，系统内核不能感知到用户线程的存在与实现，用户线程的操作完全在用户态完成。\n比较复杂，一般不倾向使用用户线程\n### 混合实现\nN：M实现，既存在轻量级进程，又存在用户线程\n### java线程的实现\n基于操作系统原生线程模型来实现，即1：1的线程模型\n每一个Java线程都直接映射到一个操作系统原生线程来实现，线程操作由操作系统全权决定\n## Java线程调度\n### 协同式\n线程的执行时间由线程本身控制。好处是实现简单，切换操作对线程可知，没有线程同步的问题。坏处是执行时间不可控制，使用不当系统崩溃\n### 抢占式\n由系统来分配线程的执行时间，线程切换不由线程本身控制。\n可设置进程优先级，但是不是稳定的调节手段。一是某些操作系统上不同优先级，二是进程优先级可能被系统自行改变\n## 状态转换\n一共有6种线程状态：\n1. 新建：创建后尚未启动\n2. 运行：包括操作系统状态的Running和Ready，即可能正在运行，也可能等待操作系统为他分配执行时间\n3. 无限期等待：不会被分配处理器执行时间，要等待被其他线程显示唤醒\n4. 期限等待：不会被分配处理器执行时间，一定时间后会由操作系统自动唤醒\n5. 阻塞状态：在等待着获取一个排它锁。在程序等待进入同步区域时，处于该状态\n6. 结束状态：已终止线程的线程状态\n\n# Java与协程\n## 内核线程的局限\n业务量不断增长，而且为了应对业务复杂化而不断进行服务细分\n现代BS系统中一次对外部业务请求的响应，往往需要在不同机器上的大量服务共同协作来实现。增加了服务数量，缩短了留给每个服务的响应时间。要求每个服务都必须在极短的时间内完成计算，能同时处理数量更庞大的请求\nJava的1：1线程模型切换，调整成本高昂，系统能容纳的线程数量有限，对这样的情况造成严重浪费。\n## 协程的复苏\n内核线程的调度成本主要来自于用户态与内核态之间的状态转换，而这两种状态转换的开销主要来自于响应中断，保护和恢复执行现场的成本。涉及一系列数据在各种寄存器，缓存中的来回拷贝，不是一种轻量级的操作。\n有栈协程：在内存中划分一片额外空间来模拟调用栈，完整地做调用栈的保护和恢复工作\n优势是轻量，缺点是需要在应用层面上实现的内容（调用栈，调度器）特别多\n## Java的解决方案\n使用纤程，是一种典型的有栈协程。重新提供对用户线程的支持\n会有两个并发编程模型在Java虚拟机中并存，可以在程序中同时使用\n","source":"_posts/JVM笔记/第12章_Java内存模型与线程.md","raw":"---\ntitle: 深入理解Java虚拟机--Java内存模型与线程\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第12章--Java内存模型与线程。'\ncategories: JVM学习笔记\ntags:\n  - 深入理解Java虚拟机\n  - 线程\n  - 内存模型\nabbrlink: ce3193b6\ndate: 2020-07-23 00:00:00\n---\n\n# 概述\n\n多任务处理原因:计算机运算能力强大了,计算机运算速度与他的存储和通信子系统的速度差异大,一个服务端要同时对多个客户端提供服务\n\n# 硬件的效率与一致性\n\n让计算机并发执行若干个计算任务与更充分地利用计算机处理器的效能之间的关系没这么简单\n\n因为绝大多数的运算任务都不可能只靠处理器的计算完成,还需要与内存的交互等。因为CPU和存储设备速度的差异，现代计算机系统加入一层或多层高速缓存作为内存和处理器的缓冲\n\n## 缓存一致性\n\n共享内存多核系统：在多路处理器系统，每个处理器都有自己的高速缓存，而他们又共享同一个主内存\n\n当多个处理器的运算任务都涉及到同一块主内存时，将可能遇到缓存不一致的情况，所以需要遵守一定的协议。\n\n## 指令重排序优化\n\n为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码的顺序是一致的\n\n因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性不能靠代码的先后顺序保证\n\n# Java内存模型\n\n## 主内存和工作内存\n\n定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储在内存和从内存中取出变量值这样的底层细节。\n\n此次变量不包括局部变量和方法参数，因为他们是线程私有的，不会被共享，没有竞争问题\n\n所有变量都存储在主内存中，每个线程还有自己的工作内存。工作内存保存了被改线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，不能直接读取主内存的数据\n\n主内存直接对应于物理硬件的内存，工作内存优先存储于寄存器和高速缓存中\n\n## 内存间交互操作\n\n主内存和工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存这一类的实现细节\n\n下面每个操作都是原子的，不可再分的\n\n1. lock 作用于主内存变量，把变量标识为线程独占\n2. unlock 作用于主内存变量，把变量从锁定状态释放\n3. read 作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中\n4. load 作用于工作内存变量，把read操作从主内存中得到到变量值放入工作内存的变量副本中\n5. use 作用于工作内存变量，把工作内存中一个变量的值传递给执行引擎\n6. assign 作用于工作内存变量，把一个从执行引擎接收的值赋给工作内存的变量\n7. store 作用于工作内存变量，把工作内存中一个变量的值传送到主内存中\n8. write 作用于主内存变量，把store操作从工作内存中得到的变量值放入主内存的变量中\n\n之后简化为read,write,lock,unlock,但只是语言描述简化，内存模型的基础设计没变\n\n之后可以采用一个等效的判断原则：先行发生原则，用来确定一个操作在并发情况下是否安全 \n\n## 对于volatile型变量的特殊规则\n\n提供的最轻量级的同步机制\n\n两大特性\n\n### 保证此量对所有线程的可见性\n\n指当一条线程修改了这个变量的值，新值对于其他线程来说是立即得知的\n\n误解：volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的\n\nvolatile变量在各个线程的工作内存中是不存在一致性问题，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的\n\n例子：一条race++ 指令，由四条字节码指令构成，当`getstatic`指令把race的值取到操作栈顶时，`volatile`关键字保证此时race的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的race值同步回主内存中\n\n由于volatile只能保证可见性，除了以下两种情况外，其余都要通过加锁解决：\n\n1. 运算结果并不依赖于变量的当前值，或者能够确保只有单一的线程修改变量的值\n2. 变量不需要于其他的状态变量共同参与不变约束\n\n### 禁止指令重排序优化\n\n普通变量只能保证结果正确，不能保证变量赋值操作的顺序与程序代码的执行顺序是一致的\n\n即线程内表现为串行的语义\n\n有volatile修饰的变量，赋值后多执行一个`lock addl $0x0,(%esp)`操作，该操作相当于一个内存屏障，指重排序时不能把后面的指令重排序到内存屏障之前的位置\n\n`lock addl $0x0,(%esp)`操作将本处理器的缓存写入到内存，会引发其他处理器无效化他们的缓存，所以可以让volatile变量的修改对其他处理器立即可见\n\n从硬件架构上，指令重排序是指处理器采用了运行将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，他必须能正确处理指令依赖情况，保证能输出正确的结果\n\n在同一个处理器中，重排序后的代码看起来仍然是有序的，`lock addl $0x0,(%esp)`把修改同步到缓存时，意味着所有之前的操作已经完成了，就形成了指令重排序无法越过内存屏障的效果\n\n只有一个处理器访问内存时，不需要内存配置，但是有多个处理器访问同一块内存，且其中一个在观测另一个，就需要内存屏障来保证一致性\n\n### 效率\nvolatile变量读操作性能消耗和普通变量差不多，写操作因为要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，会慢一些\nvolatile变量总开销比锁低，在volatile与锁之前选择的唯一依据仅仅是volatile能否满足使用场景的要求\n## 针对long和double型变量的特殊规则\nlong和double的非原子性协定：运行虚拟机将并未声明为volatile的64位数据的读取划分为两次32位的操作进行\n如果有多个线程共享一个并未声明为volatile的long和double型变量，并且同时对他们进行读取和修改操作，可能会读取到半个变量的数值\n不过非常罕见，64位Java虚拟机不会出现，32位的也通常不会出现。所以在实际开发中，除非该数据有明确可知的线程竞争，否则一般不需要刻意把long和double型变量声明为volatile\n\n## 原子性，可见性，有序性\n### 原子性\n大致可以认为，基本数据类型的访问读写都是具备原子性的\nsynchronized块之间的操作也具备原子性\n### 可见性\n当一个线程修改了共享变量的值时，其他变量能立即得知这个修改。\n三种可见性方式：\nvolatile变量：保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新\nsynchronized关键字：对一个变量执行unlock之前，必须先把此变量同步回主内存中\nfinal：被final修饰的字段在构造器一旦被初始化完成，并且构造器没有把this的引用参数传递出去，那么在其他线程中就能看到final字段的值\n### 有序性\n天然的有序性：如果在本线程内观测，所有的操作都是有序的；如果在一个线程中观测另一个线程，所有的操作都是无序的。前半句是指线程内似表现为串行的语义，后半句是指指令重排序和工作内存与主内存同步延迟现象。\nvolatile，synchronized关键字保证线程之间操作的有序性。前者本身就包含了禁止指令重排序的语义，后者由一个变量同一时刻只允许一条线程对其lock操作获得\nsynchronized关键字很万能，但是被滥用了，越万能的并发控制，通常会伴随越大的性能影响\n\n## 先行发生原则\n是判断数据是否竞争，线程是否安全的非常有用的手段\n先行发生：例如说操作A先行发生于操作B，则指发生操作B之前，操作A产生的影响能被操作B观察到\nJava语言中无须任何同步手段保障就能成立的先行发生原则如下，如果两个操作之间的关系无法从下述规则推导出来，他们就没有顺序性保证，虚拟机就能对他们随意地重排序\n1. 程序次序规则：一个线程内，按照控制流顺序前面的操作比后面的操作先执行\n2. 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作\n3. volatile变量规则：对一个 volatile变量的写操作先行发生于后面对这个变量的读操作\n4. 线程启动规则：Thread的start（）方法先行发生于该线程的每一个动作\n5. 线程终止规则：线程的所有操作先行发生于对该线程的终止检测\n6. 线程中断规则：对线程interrupt（）方法的调用优先于被中断线程的代码检测到中断事件发生\n7. 对象终结规则：一个对象的初始化方法优先于他的finalized（）方法\n8. 传递性：A先行发生于B，B先行发生于C，则A先行发生于C\n\n时间先后顺序与先行发生原则之间没有因果关系，所以衡量并发安全问题不要受时间顺序的影响，一切以先行发生原则为准\n# Java与线程\n## 线程的实现\n### 内核线程实现\n1：1实现， 内核线程就是直接由操作系统内核支持的线程，由内核来完成线程切换。一般使用内核线程的高级接口-轻量级进程\n内核线程的操作都需要进行系统调用，需要在用户态核心态切换，要消耗一定的内核资源。\n### 用户线程的实现\n用户线程为1：N的实现，完全建立在用户空间的线程库，系统内核不能感知到用户线程的存在与实现，用户线程的操作完全在用户态完成。\n比较复杂，一般不倾向使用用户线程\n### 混合实现\nN：M实现，既存在轻量级进程，又存在用户线程\n### java线程的实现\n基于操作系统原生线程模型来实现，即1：1的线程模型\n每一个Java线程都直接映射到一个操作系统原生线程来实现，线程操作由操作系统全权决定\n## Java线程调度\n### 协同式\n线程的执行时间由线程本身控制。好处是实现简单，切换操作对线程可知，没有线程同步的问题。坏处是执行时间不可控制，使用不当系统崩溃\n### 抢占式\n由系统来分配线程的执行时间，线程切换不由线程本身控制。\n可设置进程优先级，但是不是稳定的调节手段。一是某些操作系统上不同优先级，二是进程优先级可能被系统自行改变\n## 状态转换\n一共有6种线程状态：\n1. 新建：创建后尚未启动\n2. 运行：包括操作系统状态的Running和Ready，即可能正在运行，也可能等待操作系统为他分配执行时间\n3. 无限期等待：不会被分配处理器执行时间，要等待被其他线程显示唤醒\n4. 期限等待：不会被分配处理器执行时间，一定时间后会由操作系统自动唤醒\n5. 阻塞状态：在等待着获取一个排它锁。在程序等待进入同步区域时，处于该状态\n6. 结束状态：已终止线程的线程状态\n\n# Java与协程\n## 内核线程的局限\n业务量不断增长，而且为了应对业务复杂化而不断进行服务细分\n现代BS系统中一次对外部业务请求的响应，往往需要在不同机器上的大量服务共同协作来实现。增加了服务数量，缩短了留给每个服务的响应时间。要求每个服务都必须在极短的时间内完成计算，能同时处理数量更庞大的请求\nJava的1：1线程模型切换，调整成本高昂，系统能容纳的线程数量有限，对这样的情况造成严重浪费。\n## 协程的复苏\n内核线程的调度成本主要来自于用户态与内核态之间的状态转换，而这两种状态转换的开销主要来自于响应中断，保护和恢复执行现场的成本。涉及一系列数据在各种寄存器，缓存中的来回拷贝，不是一种轻量级的操作。\n有栈协程：在内存中划分一片额外空间来模拟调用栈，完整地做调用栈的保护和恢复工作\n优势是轻量，缺点是需要在应用层面上实现的内容（调用栈，调度器）特别多\n## Java的解决方案\n使用纤程，是一种典型的有栈协程。重新提供对用户线程的支持\n会有两个并发编程模型在Java虚拟机中并存，可以在程序中同时使用\n","slug":"JVM笔记/第12章_Java内存模型与线程","published":1,"updated":"2020-11-12T11:57:29.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6vp000bjotp9n1zbd69","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>多任务处理原因:计算机运算能力强大了,计算机运算速度与他的存储和通信子系统的速度差异大,一个服务端要同时对多个客户端提供服务</p>\n<h1 id=\"硬件的效率与一致性\"><a href=\"#硬件的效率与一致性\" class=\"headerlink\" title=\"硬件的效率与一致性\"></a>硬件的效率与一致性</h1><p>让计算机并发执行若干个计算任务与更充分地利用计算机处理器的效能之间的关系没这么简单</p>\n<p>因为绝大多数的运算任务都不可能只靠处理器的计算完成,还需要与内存的交互等。因为CPU和存储设备速度的差异，现代计算机系统加入一层或多层高速缓存作为内存和处理器的缓冲</p>\n<h2 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h2><p>共享内存多核系统：在多路处理器系统，每个处理器都有自己的高速缓存，而他们又共享同一个主内存</p>\n<p>当多个处理器的运算任务都涉及到同一块主内存时，将可能遇到缓存不一致的情况，所以需要遵守一定的协议。</p>\n<h2 id=\"指令重排序优化\"><a href=\"#指令重排序优化\" class=\"headerlink\" title=\"指令重排序优化\"></a>指令重排序优化</h2><p>为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码的顺序是一致的</p>\n<p>因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性不能靠代码的先后顺序保证</p>\n<h1 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h1><h2 id=\"主内存和工作内存\"><a href=\"#主内存和工作内存\" class=\"headerlink\" title=\"主内存和工作内存\"></a>主内存和工作内存</h2><p>定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储在内存和从内存中取出变量值这样的底层细节。</p>\n<p>此次变量不包括局部变量和方法参数，因为他们是线程私有的，不会被共享，没有竞争问题</p>\n<p>所有变量都存储在主内存中，每个线程还有自己的工作内存。工作内存保存了被改线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，不能直接读取主内存的数据</p>\n<p>主内存直接对应于物理硬件的内存，工作内存优先存储于寄存器和高速缓存中</p>\n<h2 id=\"内存间交互操作\"><a href=\"#内存间交互操作\" class=\"headerlink\" title=\"内存间交互操作\"></a>内存间交互操作</h2><p>主内存和工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存这一类的实现细节</p>\n<p>下面每个操作都是原子的，不可再分的</p>\n<ol>\n<li>lock 作用于主内存变量，把变量标识为线程独占</li>\n<li>unlock 作用于主内存变量，把变量从锁定状态释放</li>\n<li>read 作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中</li>\n<li>load 作用于工作内存变量，把read操作从主内存中得到到变量值放入工作内存的变量副本中</li>\n<li>use 作用于工作内存变量，把工作内存中一个变量的值传递给执行引擎</li>\n<li>assign 作用于工作内存变量，把一个从执行引擎接收的值赋给工作内存的变量</li>\n<li>store 作用于工作内存变量，把工作内存中一个变量的值传送到主内存中</li>\n<li>write 作用于主内存变量，把store操作从工作内存中得到的变量值放入主内存的变量中</li>\n</ol>\n<p>之后简化为read,write,lock,unlock,但只是语言描述简化，内存模型的基础设计没变</p>\n<p>之后可以采用一个等效的判断原则：先行发生原则，用来确定一个操作在并发情况下是否安全 </p>\n<h2 id=\"对于volatile型变量的特殊规则\"><a href=\"#对于volatile型变量的特殊规则\" class=\"headerlink\" title=\"对于volatile型变量的特殊规则\"></a>对于volatile型变量的特殊规则</h2><p>提供的最轻量级的同步机制</p>\n<p>两大特性</p>\n<h3 id=\"保证此量对所有线程的可见性\"><a href=\"#保证此量对所有线程的可见性\" class=\"headerlink\" title=\"保证此量对所有线程的可见性\"></a>保证此量对所有线程的可见性</h3><p>指当一条线程修改了这个变量的值，新值对于其他线程来说是立即得知的</p>\n<p>误解：volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的</p>\n<p>volatile变量在各个线程的工作内存中是不存在一致性问题，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的</p>\n<p>例子：一条race++ 指令，由四条字节码指令构成，当<code>getstatic</code>指令把race的值取到操作栈顶时，<code>volatile</code>关键字保证此时race的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的race值同步回主内存中</p>\n<p>由于volatile只能保证可见性，除了以下两种情况外，其余都要通过加锁解决：</p>\n<ol>\n<li>运算结果并不依赖于变量的当前值，或者能够确保只有单一的线程修改变量的值</li>\n<li>变量不需要于其他的状态变量共同参与不变约束</li>\n</ol>\n<h3 id=\"禁止指令重排序优化\"><a href=\"#禁止指令重排序优化\" class=\"headerlink\" title=\"禁止指令重排序优化\"></a>禁止指令重排序优化</h3><p>普通变量只能保证结果正确，不能保证变量赋值操作的顺序与程序代码的执行顺序是一致的</p>\n<p>即线程内表现为串行的语义</p>\n<p>有volatile修饰的变量，赋值后多执行一个<code>lock addl $0x0,(%esp)</code>操作，该操作相当于一个内存屏障，指重排序时不能把后面的指令重排序到内存屏障之前的位置</p>\n<p><code>lock addl $0x0,(%esp)</code>操作将本处理器的缓存写入到内存，会引发其他处理器无效化他们的缓存，所以可以让volatile变量的修改对其他处理器立即可见</p>\n<p>从硬件架构上，指令重排序是指处理器采用了运行将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，他必须能正确处理指令依赖情况，保证能输出正确的结果</p>\n<p>在同一个处理器中，重排序后的代码看起来仍然是有序的，<code>lock addl $0x0,(%esp)</code>把修改同步到缓存时，意味着所有之前的操作已经完成了，就形成了指令重排序无法越过内存屏障的效果</p>\n<p>只有一个处理器访问内存时，不需要内存配置，但是有多个处理器访问同一块内存，且其中一个在观测另一个，就需要内存屏障来保证一致性</p>\n<h3 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h3><p>volatile变量读操作性能消耗和普通变量差不多，写操作因为要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，会慢一些<br>volatile变量总开销比锁低，在volatile与锁之前选择的唯一依据仅仅是volatile能否满足使用场景的要求</p>\n<h2 id=\"针对long和double型变量的特殊规则\"><a href=\"#针对long和double型变量的特殊规则\" class=\"headerlink\" title=\"针对long和double型变量的特殊规则\"></a>针对long和double型变量的特殊规则</h2><p>long和double的非原子性协定：运行虚拟机将并未声明为volatile的64位数据的读取划分为两次32位的操作进行<br>如果有多个线程共享一个并未声明为volatile的long和double型变量，并且同时对他们进行读取和修改操作，可能会读取到半个变量的数值<br>不过非常罕见，64位Java虚拟机不会出现，32位的也通常不会出现。所以在实际开发中，除非该数据有明确可知的线程竞争，否则一般不需要刻意把long和double型变量声明为volatile</p>\n<h2 id=\"原子性，可见性，有序性\"><a href=\"#原子性，可见性，有序性\" class=\"headerlink\" title=\"原子性，可见性，有序性\"></a>原子性，可见性，有序性</h2><h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>大致可以认为，基本数据类型的访问读写都是具备原子性的<br>synchronized块之间的操作也具备原子性</p>\n<h3 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h3><p>当一个线程修改了共享变量的值时，其他变量能立即得知这个修改。<br>三种可见性方式：<br>volatile变量：保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新<br>synchronized关键字：对一个变量执行unlock之前，必须先把此变量同步回主内存中<br>final：被final修饰的字段在构造器一旦被初始化完成，并且构造器没有把this的引用参数传递出去，那么在其他线程中就能看到final字段的值</p>\n<h3 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h3><p>天然的有序性：如果在本线程内观测，所有的操作都是有序的；如果在一个线程中观测另一个线程，所有的操作都是无序的。前半句是指线程内似表现为串行的语义，后半句是指指令重排序和工作内存与主内存同步延迟现象。<br>volatile，synchronized关键字保证线程之间操作的有序性。前者本身就包含了禁止指令重排序的语义，后者由一个变量同一时刻只允许一条线程对其lock操作获得<br>synchronized关键字很万能，但是被滥用了，越万能的并发控制，通常会伴随越大的性能影响</p>\n<h2 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h2><p>是判断数据是否竞争，线程是否安全的非常有用的手段<br>先行发生：例如说操作A先行发生于操作B，则指发生操作B之前，操作A产生的影响能被操作B观察到<br>Java语言中无须任何同步手段保障就能成立的先行发生原则如下，如果两个操作之间的关系无法从下述规则推导出来，他们就没有顺序性保证，虚拟机就能对他们随意地重排序</p>\n<ol>\n<li>程序次序规则：一个线程内，按照控制流顺序前面的操作比后面的操作先执行</li>\n<li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作</li>\n<li>volatile变量规则：对一个 volatile变量的写操作先行发生于后面对这个变量的读操作</li>\n<li>线程启动规则：Thread的start（）方法先行发生于该线程的每一个动作</li>\n<li>线程终止规则：线程的所有操作先行发生于对该线程的终止检测</li>\n<li>线程中断规则：对线程interrupt（）方法的调用优先于被中断线程的代码检测到中断事件发生</li>\n<li>对象终结规则：一个对象的初始化方法优先于他的finalized（）方法</li>\n<li>传递性：A先行发生于B，B先行发生于C，则A先行发生于C</li>\n</ol>\n<p>时间先后顺序与先行发生原则之间没有因果关系，所以衡量并发安全问题不要受时间顺序的影响，一切以先行发生原则为准</p>\n<h1 id=\"Java与线程\"><a href=\"#Java与线程\" class=\"headerlink\" title=\"Java与线程\"></a>Java与线程</h1><h2 id=\"线程的实现\"><a href=\"#线程的实现\" class=\"headerlink\" title=\"线程的实现\"></a>线程的实现</h2><h3 id=\"内核线程实现\"><a href=\"#内核线程实现\" class=\"headerlink\" title=\"内核线程实现\"></a>内核线程实现</h3><p>1：1实现， 内核线程就是直接由操作系统内核支持的线程，由内核来完成线程切换。一般使用内核线程的高级接口-轻量级进程<br>内核线程的操作都需要进行系统调用，需要在用户态核心态切换，要消耗一定的内核资源。</p>\n<h3 id=\"用户线程的实现\"><a href=\"#用户线程的实现\" class=\"headerlink\" title=\"用户线程的实现\"></a>用户线程的实现</h3><p>用户线程为1：N的实现，完全建立在用户空间的线程库，系统内核不能感知到用户线程的存在与实现，用户线程的操作完全在用户态完成。<br>比较复杂，一般不倾向使用用户线程</p>\n<h3 id=\"混合实现\"><a href=\"#混合实现\" class=\"headerlink\" title=\"混合实现\"></a>混合实现</h3><p>N：M实现，既存在轻量级进程，又存在用户线程</p>\n<h3 id=\"java线程的实现\"><a href=\"#java线程的实现\" class=\"headerlink\" title=\"java线程的实现\"></a>java线程的实现</h3><p>基于操作系统原生线程模型来实现，即1：1的线程模型<br>每一个Java线程都直接映射到一个操作系统原生线程来实现，线程操作由操作系统全权决定</p>\n<h2 id=\"Java线程调度\"><a href=\"#Java线程调度\" class=\"headerlink\" title=\"Java线程调度\"></a>Java线程调度</h2><h3 id=\"协同式\"><a href=\"#协同式\" class=\"headerlink\" title=\"协同式\"></a>协同式</h3><p>线程的执行时间由线程本身控制。好处是实现简单，切换操作对线程可知，没有线程同步的问题。坏处是执行时间不可控制，使用不当系统崩溃</p>\n<h3 id=\"抢占式\"><a href=\"#抢占式\" class=\"headerlink\" title=\"抢占式\"></a>抢占式</h3><p>由系统来分配线程的执行时间，线程切换不由线程本身控制。<br>可设置进程优先级，但是不是稳定的调节手段。一是某些操作系统上不同优先级，二是进程优先级可能被系统自行改变</p>\n<h2 id=\"状态转换\"><a href=\"#状态转换\" class=\"headerlink\" title=\"状态转换\"></a>状态转换</h2><p>一共有6种线程状态：</p>\n<ol>\n<li>新建：创建后尚未启动</li>\n<li>运行：包括操作系统状态的Running和Ready，即可能正在运行，也可能等待操作系统为他分配执行时间</li>\n<li>无限期等待：不会被分配处理器执行时间，要等待被其他线程显示唤醒</li>\n<li>期限等待：不会被分配处理器执行时间，一定时间后会由操作系统自动唤醒</li>\n<li>阻塞状态：在等待着获取一个排它锁。在程序等待进入同步区域时，处于该状态</li>\n<li>结束状态：已终止线程的线程状态</li>\n</ol>\n<h1 id=\"Java与协程\"><a href=\"#Java与协程\" class=\"headerlink\" title=\"Java与协程\"></a>Java与协程</h1><h2 id=\"内核线程的局限\"><a href=\"#内核线程的局限\" class=\"headerlink\" title=\"内核线程的局限\"></a>内核线程的局限</h2><p>业务量不断增长，而且为了应对业务复杂化而不断进行服务细分<br>现代BS系统中一次对外部业务请求的响应，往往需要在不同机器上的大量服务共同协作来实现。增加了服务数量，缩短了留给每个服务的响应时间。要求每个服务都必须在极短的时间内完成计算，能同时处理数量更庞大的请求<br>Java的1：1线程模型切换，调整成本高昂，系统能容纳的线程数量有限，对这样的情况造成严重浪费。</p>\n<h2 id=\"协程的复苏\"><a href=\"#协程的复苏\" class=\"headerlink\" title=\"协程的复苏\"></a>协程的复苏</h2><p>内核线程的调度成本主要来自于用户态与内核态之间的状态转换，而这两种状态转换的开销主要来自于响应中断，保护和恢复执行现场的成本。涉及一系列数据在各种寄存器，缓存中的来回拷贝，不是一种轻量级的操作。<br>有栈协程：在内存中划分一片额外空间来模拟调用栈，完整地做调用栈的保护和恢复工作<br>优势是轻量，缺点是需要在应用层面上实现的内容（调用栈，调度器）特别多</p>\n<h2 id=\"Java的解决方案\"><a href=\"#Java的解决方案\" class=\"headerlink\" title=\"Java的解决方案\"></a>Java的解决方案</h2><p>使用纤程，是一种典型的有栈协程。重新提供对用户线程的支持<br>会有两个并发编程模型在Java虚拟机中并存，可以在程序中同时使用</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>多任务处理原因:计算机运算能力强大了,计算机运算速度与他的存储和通信子系统的速度差异大,一个服务端要同时对多个客户端提供服务</p>\n<h1 id=\"硬件的效率与一致性\"><a href=\"#硬件的效率与一致性\" class=\"headerlink\" title=\"硬件的效率与一致性\"></a>硬件的效率与一致性</h1><p>让计算机并发执行若干个计算任务与更充分地利用计算机处理器的效能之间的关系没这么简单</p>\n<p>因为绝大多数的运算任务都不可能只靠处理器的计算完成,还需要与内存的交互等。因为CPU和存储设备速度的差异，现代计算机系统加入一层或多层高速缓存作为内存和处理器的缓冲</p>\n<h2 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h2><p>共享内存多核系统：在多路处理器系统，每个处理器都有自己的高速缓存，而他们又共享同一个主内存</p>\n<p>当多个处理器的运算任务都涉及到同一块主内存时，将可能遇到缓存不一致的情况，所以需要遵守一定的协议。</p>\n<h2 id=\"指令重排序优化\"><a href=\"#指令重排序优化\" class=\"headerlink\" title=\"指令重排序优化\"></a>指令重排序优化</h2><p>为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码的顺序是一致的</p>\n<p>因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性不能靠代码的先后顺序保证</p>\n<h1 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h1><h2 id=\"主内存和工作内存\"><a href=\"#主内存和工作内存\" class=\"headerlink\" title=\"主内存和工作内存\"></a>主内存和工作内存</h2><p>定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储在内存和从内存中取出变量值这样的底层细节。</p>\n<p>此次变量不包括局部变量和方法参数，因为他们是线程私有的，不会被共享，没有竞争问题</p>\n<p>所有变量都存储在主内存中，每个线程还有自己的工作内存。工作内存保存了被改线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，不能直接读取主内存的数据</p>\n<p>主内存直接对应于物理硬件的内存，工作内存优先存储于寄存器和高速缓存中</p>\n<h2 id=\"内存间交互操作\"><a href=\"#内存间交互操作\" class=\"headerlink\" title=\"内存间交互操作\"></a>内存间交互操作</h2><p>主内存和工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存这一类的实现细节</p>\n<p>下面每个操作都是原子的，不可再分的</p>\n<ol>\n<li>lock 作用于主内存变量，把变量标识为线程独占</li>\n<li>unlock 作用于主内存变量，把变量从锁定状态释放</li>\n<li>read 作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中</li>\n<li>load 作用于工作内存变量，把read操作从主内存中得到到变量值放入工作内存的变量副本中</li>\n<li>use 作用于工作内存变量，把工作内存中一个变量的值传递给执行引擎</li>\n<li>assign 作用于工作内存变量，把一个从执行引擎接收的值赋给工作内存的变量</li>\n<li>store 作用于工作内存变量，把工作内存中一个变量的值传送到主内存中</li>\n<li>write 作用于主内存变量，把store操作从工作内存中得到的变量值放入主内存的变量中</li>\n</ol>\n<p>之后简化为read,write,lock,unlock,但只是语言描述简化，内存模型的基础设计没变</p>\n<p>之后可以采用一个等效的判断原则：先行发生原则，用来确定一个操作在并发情况下是否安全 </p>\n<h2 id=\"对于volatile型变量的特殊规则\"><a href=\"#对于volatile型变量的特殊规则\" class=\"headerlink\" title=\"对于volatile型变量的特殊规则\"></a>对于volatile型变量的特殊规则</h2><p>提供的最轻量级的同步机制</p>\n<p>两大特性</p>\n<h3 id=\"保证此量对所有线程的可见性\"><a href=\"#保证此量对所有线程的可见性\" class=\"headerlink\" title=\"保证此量对所有线程的可见性\"></a>保证此量对所有线程的可见性</h3><p>指当一条线程修改了这个变量的值，新值对于其他线程来说是立即得知的</p>\n<p>误解：volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的</p>\n<p>volatile变量在各个线程的工作内存中是不存在一致性问题，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的</p>\n<p>例子：一条race++ 指令，由四条字节码指令构成，当<code>getstatic</code>指令把race的值取到操作栈顶时，<code>volatile</code>关键字保证此时race的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的race值同步回主内存中</p>\n<p>由于volatile只能保证可见性，除了以下两种情况外，其余都要通过加锁解决：</p>\n<ol>\n<li>运算结果并不依赖于变量的当前值，或者能够确保只有单一的线程修改变量的值</li>\n<li>变量不需要于其他的状态变量共同参与不变约束</li>\n</ol>\n<h3 id=\"禁止指令重排序优化\"><a href=\"#禁止指令重排序优化\" class=\"headerlink\" title=\"禁止指令重排序优化\"></a>禁止指令重排序优化</h3><p>普通变量只能保证结果正确，不能保证变量赋值操作的顺序与程序代码的执行顺序是一致的</p>\n<p>即线程内表现为串行的语义</p>\n<p>有volatile修饰的变量，赋值后多执行一个<code>lock addl $0x0,(%esp)</code>操作，该操作相当于一个内存屏障，指重排序时不能把后面的指令重排序到内存屏障之前的位置</p>\n<p><code>lock addl $0x0,(%esp)</code>操作将本处理器的缓存写入到内存，会引发其他处理器无效化他们的缓存，所以可以让volatile变量的修改对其他处理器立即可见</p>\n<p>从硬件架构上，指令重排序是指处理器采用了运行将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，他必须能正确处理指令依赖情况，保证能输出正确的结果</p>\n<p>在同一个处理器中，重排序后的代码看起来仍然是有序的，<code>lock addl $0x0,(%esp)</code>把修改同步到缓存时，意味着所有之前的操作已经完成了，就形成了指令重排序无法越过内存屏障的效果</p>\n<p>只有一个处理器访问内存时，不需要内存配置，但是有多个处理器访问同一块内存，且其中一个在观测另一个，就需要内存屏障来保证一致性</p>\n<h3 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h3><p>volatile变量读操作性能消耗和普通变量差不多，写操作因为要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，会慢一些<br>volatile变量总开销比锁低，在volatile与锁之前选择的唯一依据仅仅是volatile能否满足使用场景的要求</p>\n<h2 id=\"针对long和double型变量的特殊规则\"><a href=\"#针对long和double型变量的特殊规则\" class=\"headerlink\" title=\"针对long和double型变量的特殊规则\"></a>针对long和double型变量的特殊规则</h2><p>long和double的非原子性协定：运行虚拟机将并未声明为volatile的64位数据的读取划分为两次32位的操作进行<br>如果有多个线程共享一个并未声明为volatile的long和double型变量，并且同时对他们进行读取和修改操作，可能会读取到半个变量的数值<br>不过非常罕见，64位Java虚拟机不会出现，32位的也通常不会出现。所以在实际开发中，除非该数据有明确可知的线程竞争，否则一般不需要刻意把long和double型变量声明为volatile</p>\n<h2 id=\"原子性，可见性，有序性\"><a href=\"#原子性，可见性，有序性\" class=\"headerlink\" title=\"原子性，可见性，有序性\"></a>原子性，可见性，有序性</h2><h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>大致可以认为，基本数据类型的访问读写都是具备原子性的<br>synchronized块之间的操作也具备原子性</p>\n<h3 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h3><p>当一个线程修改了共享变量的值时，其他变量能立即得知这个修改。<br>三种可见性方式：<br>volatile变量：保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新<br>synchronized关键字：对一个变量执行unlock之前，必须先把此变量同步回主内存中<br>final：被final修饰的字段在构造器一旦被初始化完成，并且构造器没有把this的引用参数传递出去，那么在其他线程中就能看到final字段的值</p>\n<h3 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h3><p>天然的有序性：如果在本线程内观测，所有的操作都是有序的；如果在一个线程中观测另一个线程，所有的操作都是无序的。前半句是指线程内似表现为串行的语义，后半句是指指令重排序和工作内存与主内存同步延迟现象。<br>volatile，synchronized关键字保证线程之间操作的有序性。前者本身就包含了禁止指令重排序的语义，后者由一个变量同一时刻只允许一条线程对其lock操作获得<br>synchronized关键字很万能，但是被滥用了，越万能的并发控制，通常会伴随越大的性能影响</p>\n<h2 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h2><p>是判断数据是否竞争，线程是否安全的非常有用的手段<br>先行发生：例如说操作A先行发生于操作B，则指发生操作B之前，操作A产生的影响能被操作B观察到<br>Java语言中无须任何同步手段保障就能成立的先行发生原则如下，如果两个操作之间的关系无法从下述规则推导出来，他们就没有顺序性保证，虚拟机就能对他们随意地重排序</p>\n<ol>\n<li>程序次序规则：一个线程内，按照控制流顺序前面的操作比后面的操作先执行</li>\n<li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作</li>\n<li>volatile变量规则：对一个 volatile变量的写操作先行发生于后面对这个变量的读操作</li>\n<li>线程启动规则：Thread的start（）方法先行发生于该线程的每一个动作</li>\n<li>线程终止规则：线程的所有操作先行发生于对该线程的终止检测</li>\n<li>线程中断规则：对线程interrupt（）方法的调用优先于被中断线程的代码检测到中断事件发生</li>\n<li>对象终结规则：一个对象的初始化方法优先于他的finalized（）方法</li>\n<li>传递性：A先行发生于B，B先行发生于C，则A先行发生于C</li>\n</ol>\n<p>时间先后顺序与先行发生原则之间没有因果关系，所以衡量并发安全问题不要受时间顺序的影响，一切以先行发生原则为准</p>\n<h1 id=\"Java与线程\"><a href=\"#Java与线程\" class=\"headerlink\" title=\"Java与线程\"></a>Java与线程</h1><h2 id=\"线程的实现\"><a href=\"#线程的实现\" class=\"headerlink\" title=\"线程的实现\"></a>线程的实现</h2><h3 id=\"内核线程实现\"><a href=\"#内核线程实现\" class=\"headerlink\" title=\"内核线程实现\"></a>内核线程实现</h3><p>1：1实现， 内核线程就是直接由操作系统内核支持的线程，由内核来完成线程切换。一般使用内核线程的高级接口-轻量级进程<br>内核线程的操作都需要进行系统调用，需要在用户态核心态切换，要消耗一定的内核资源。</p>\n<h3 id=\"用户线程的实现\"><a href=\"#用户线程的实现\" class=\"headerlink\" title=\"用户线程的实现\"></a>用户线程的实现</h3><p>用户线程为1：N的实现，完全建立在用户空间的线程库，系统内核不能感知到用户线程的存在与实现，用户线程的操作完全在用户态完成。<br>比较复杂，一般不倾向使用用户线程</p>\n<h3 id=\"混合实现\"><a href=\"#混合实现\" class=\"headerlink\" title=\"混合实现\"></a>混合实现</h3><p>N：M实现，既存在轻量级进程，又存在用户线程</p>\n<h3 id=\"java线程的实现\"><a href=\"#java线程的实现\" class=\"headerlink\" title=\"java线程的实现\"></a>java线程的实现</h3><p>基于操作系统原生线程模型来实现，即1：1的线程模型<br>每一个Java线程都直接映射到一个操作系统原生线程来实现，线程操作由操作系统全权决定</p>\n<h2 id=\"Java线程调度\"><a href=\"#Java线程调度\" class=\"headerlink\" title=\"Java线程调度\"></a>Java线程调度</h2><h3 id=\"协同式\"><a href=\"#协同式\" class=\"headerlink\" title=\"协同式\"></a>协同式</h3><p>线程的执行时间由线程本身控制。好处是实现简单，切换操作对线程可知，没有线程同步的问题。坏处是执行时间不可控制，使用不当系统崩溃</p>\n<h3 id=\"抢占式\"><a href=\"#抢占式\" class=\"headerlink\" title=\"抢占式\"></a>抢占式</h3><p>由系统来分配线程的执行时间，线程切换不由线程本身控制。<br>可设置进程优先级，但是不是稳定的调节手段。一是某些操作系统上不同优先级，二是进程优先级可能被系统自行改变</p>\n<h2 id=\"状态转换\"><a href=\"#状态转换\" class=\"headerlink\" title=\"状态转换\"></a>状态转换</h2><p>一共有6种线程状态：</p>\n<ol>\n<li>新建：创建后尚未启动</li>\n<li>运行：包括操作系统状态的Running和Ready，即可能正在运行，也可能等待操作系统为他分配执行时间</li>\n<li>无限期等待：不会被分配处理器执行时间，要等待被其他线程显示唤醒</li>\n<li>期限等待：不会被分配处理器执行时间，一定时间后会由操作系统自动唤醒</li>\n<li>阻塞状态：在等待着获取一个排它锁。在程序等待进入同步区域时，处于该状态</li>\n<li>结束状态：已终止线程的线程状态</li>\n</ol>\n<h1 id=\"Java与协程\"><a href=\"#Java与协程\" class=\"headerlink\" title=\"Java与协程\"></a>Java与协程</h1><h2 id=\"内核线程的局限\"><a href=\"#内核线程的局限\" class=\"headerlink\" title=\"内核线程的局限\"></a>内核线程的局限</h2><p>业务量不断增长，而且为了应对业务复杂化而不断进行服务细分<br>现代BS系统中一次对外部业务请求的响应，往往需要在不同机器上的大量服务共同协作来实现。增加了服务数量，缩短了留给每个服务的响应时间。要求每个服务都必须在极短的时间内完成计算，能同时处理数量更庞大的请求<br>Java的1：1线程模型切换，调整成本高昂，系统能容纳的线程数量有限，对这样的情况造成严重浪费。</p>\n<h2 id=\"协程的复苏\"><a href=\"#协程的复苏\" class=\"headerlink\" title=\"协程的复苏\"></a>协程的复苏</h2><p>内核线程的调度成本主要来自于用户态与内核态之间的状态转换，而这两种状态转换的开销主要来自于响应中断，保护和恢复执行现场的成本。涉及一系列数据在各种寄存器，缓存中的来回拷贝，不是一种轻量级的操作。<br>有栈协程：在内存中划分一片额外空间来模拟调用栈，完整地做调用栈的保护和恢复工作<br>优势是轻量，缺点是需要在应用层面上实现的内容（调用栈，调度器）特别多</p>\n<h2 id=\"Java的解决方案\"><a href=\"#Java的解决方案\" class=\"headerlink\" title=\"Java的解决方案\"></a>Java的解决方案</h2><p>使用纤程，是一种典型的有栈协程。重新提供对用户线程的支持<br>会有两个并发编程模型在Java虚拟机中并存，可以在程序中同时使用</p>\n"},{"title":"深入理解Java虚拟机--Java内存区域与内存溢出异常","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习<<深入理解Java虚拟机>>所做的笔记,此为书上第二章--Java内存区域与内存溢出异常。","abbrlink":"6fa1fa98","date":"2020-06-30T16:00:00.000Z","_content":"\n> 学习<<深入理解Java虚拟机>>第三版时做的笔记\n\n\n# 运行时数据区\n\n## 程序计数器\n\n1. 线程私有\n2. 记录正在执行的虚拟机字节码指令的地址(如果是Native方法,则位空)\n3. 不会有OutOfMemoryError\n\n## 虚拟机栈\n\n1. 线程私有\n2. 存储的是一个个栈帧\n3. 每个方法对应一个栈帧,方法调用则入栈,执行结束则出栈\n4. 可能出现StackOverFlowError与OutOfMemoryError,前者出现是为栈分配了这么大的内存空间,但是线程请求的空间大于所分配的空间,例如不断递归。后者是允许栈动态扩展，但是扩展了还是无法申请到足够的内存，相当于把所有的内存都耗尽了\n\n### 栈帧\n#### 局部变量表\n1. 局部变量槽(slot)中long和double占用两个槽\n2. 所需的内存空间在编译器间完成分配\n#### 操作数栈\n#### 动态连接\n#### 方法出口\n\n## 本地方法栈\n与虚拟机栈类似，只是虚拟机栈是为虚拟机执行Java方法服务，本地方法栈是为虚拟机执行本地方法（Native）服务。\n\n## 堆\n1. 虚拟机管理的内存最大的一块\n2. 所有线程共享\n3. 存放几乎所有对象实例（因为逃逸技术。栈上分配，标量替换优化手段使得并不绝对）\n4. 堆中划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer TLAB），提高对象分配时的效率\n5. 物理上不连续，逻辑上连续\n6. 有可能导致OutOfMemoryError异常\n\n## 方法区\n1. 线程共享\n2. 存储类型信息，常量，静态变量，即时编译器的代码缓存等\n3. 有可能导致OutOfMemoryError异常\n4. 垃圾收集行为比较少，但是存在，主要针对常量池的回收和对类型的卸载\n### 运行时常量池\n1. 类加载后，Class文件的常量池表（编译期生成的各种字面量和符号引用）存放在运行时常量池中\n2. 具备动态性，允许期间也可以将新常量放入池中，例如String的intern（）方法\n## 直接内存\n1. 不是运行时数据区的一部分，但这部分内存经常使用，也有可能导致OutOfMemoryError异常\n2. 与NIO有相关\n3. 直接内存分配不受Java堆的限制，但是受本机总内存限制\n\n# HotSpot虚拟机中的对象\n## HotSpot虚拟机\n\n热点代码探测能力:通过执行计数器找出最具有编译价值的代码,然后通知即时编译器以方法为单位进行编译.\n\n编译器与解释器协同工作,在最优化程序响应时间与最佳执行性能中取得平衡\n## 对象的创建\n1. 遇到字节码new指令时,先检查能否在常量池中定位到一个类的符号引用\n2. 检查符号引用代表的类是否已被加载,解析,初始化,如果没有则执行类加载过程\n3. 为对象分配内存,根据是否规整,有指针碰撞法,空闲链表法\n4. 内存分配还要考虑线程安全问题,可以有两种办法解决:分配内存空间进行同步处理,如CAS配上失败重试。或者可以先分配到每个线程的TLAB中，当本地缓冲区用完后，再同步锁定\n5. 初始化为零值，所以实例字段不赋初始值也能用\n6. 设置对象头（Object Header），如锁信息，哈希码，GC分代年龄等\n7. 执行构造函数 <init>()\n\n## 对象内存布局\n对象头，实例数据，对齐填充\n### 对象头\n1. 分为两类，第一类为Mark Word，第二类是类型指针\n2. Mark Word存储对象自身的运行时数据，如HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等\n3. Mark Word有着动态定义的数据结构，根据对象的状态复用自己的存储空间，根据标志位的不同，存储内容也不同。\n4. ![IMG_20200802_153218](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200802_153218.jpg)\n5. 类型指针是指向他的类型元数据的指针，通过该指针确定对象是哪个类的实例\n6. 如果是数组，还有一块记录数组长度的数据\n### 实例数据\n对象真正存储的有效信息，包括定义的各种类型的字段内容，父类继承下来的字段等等\n### 对齐填充\n确保对象是8字节的整数倍\n## 对象访问定位\n通过栈上的reference数据来操作堆上的具体对象，访问方式有下面两种：\n\t句柄访问，直接指针访问，前者在对象改变时，reference本身不需要修改。后者节省一次指针定位的内存开销，速度更快。HotSpot虚拟机采用直接指针方式。\n\t![IMG_20200802_154351](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200802_154351.jpg)\n\t# 实战\n​\tidea配置：\n​\t`Run-Edit Configurations-Templates-Application-VM options`\n\t## 堆的OOM\n​\t-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError\n​\t解释：设置堆的最小值，最大值一样即可避免堆自动扩展。设置了堆大小为20MB，且出现内存溢出异常Dump出当前的内存堆转储快照以便进行事后分析\n![1](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1.png)\n\n分析是内存泄漏还是内存溢出.\n\n### 内存泄漏\n\n则查看泄漏对象到GC Roots的引用链,查看为什么垃圾回收器无法回收他们\n\n### 内存溢出\n\n即内存对象确实是必须存活的,则首先看看堆参数设置是否合理(-Xmx,-Xms),能否再向上调整。再从代码上检查，减少程序运行期的内存消耗。\n\n## 虚拟机栈和本地方法栈的溢出\n\n1. HotSpot虚拟机不区分这两者，栈容量只能通过-Xss来设置\n2. StackOverflowError与OutOfMemoryError异常，但是HotShot不支持栈内存动态扩展，所以除非创建线程申请内存时就因无法获取足够的内存报OOM，其他只会因为线程请求的栈的深度大于虚拟机所允许的最大深度而报StackOverflowError异常\n\n## 方法区和运行时常量池的溢出\n\nJDK7以后，运行时常量池移至堆之中，主流的框架经常在运行时生成大量动态类的应用场景，需要特别关注这些类的回收状况。但是类被回收的条件很苛刻。\n\nJDK8的元空间中，很少出现方法区的溢出异常，但是还有参数可以设置：\n\n1. -XX:MaxMetaspaceSize 设置元空间最大值，默认是-1，即不限制，只受本地内存的影响\n2. -XX:MetaspaceSize 设置初始空间的大小，达到该值则触发垃圾收集进行类型卸载\n\n## 直接内存溢出\n\n容量可以通过-XX:MaxDirectMemorySize指定，默认与堆最大值一致。\n\n间接使用直接内存的典型就是NIO","source":"_posts/JVM笔记/第2章.md","raw":"---\ntitle: 深入理解Java虚拟机--Java内存区域与内存溢出异常\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第二章--Java内存区域与内存溢出异常。'\ncategories: JVM学习笔记\ntags:\n  - 深入理解Java虚拟机\n  - JVM\n  - 运行时数据区\nabbrlink: 6fa1fa98\ndate: 2020-07-01 00:00:00\n---\n\n> 学习<<深入理解Java虚拟机>>第三版时做的笔记\n\n\n# 运行时数据区\n\n## 程序计数器\n\n1. 线程私有\n2. 记录正在执行的虚拟机字节码指令的地址(如果是Native方法,则位空)\n3. 不会有OutOfMemoryError\n\n## 虚拟机栈\n\n1. 线程私有\n2. 存储的是一个个栈帧\n3. 每个方法对应一个栈帧,方法调用则入栈,执行结束则出栈\n4. 可能出现StackOverFlowError与OutOfMemoryError,前者出现是为栈分配了这么大的内存空间,但是线程请求的空间大于所分配的空间,例如不断递归。后者是允许栈动态扩展，但是扩展了还是无法申请到足够的内存，相当于把所有的内存都耗尽了\n\n### 栈帧\n#### 局部变量表\n1. 局部变量槽(slot)中long和double占用两个槽\n2. 所需的内存空间在编译器间完成分配\n#### 操作数栈\n#### 动态连接\n#### 方法出口\n\n## 本地方法栈\n与虚拟机栈类似，只是虚拟机栈是为虚拟机执行Java方法服务，本地方法栈是为虚拟机执行本地方法（Native）服务。\n\n## 堆\n1. 虚拟机管理的内存最大的一块\n2. 所有线程共享\n3. 存放几乎所有对象实例（因为逃逸技术。栈上分配，标量替换优化手段使得并不绝对）\n4. 堆中划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer TLAB），提高对象分配时的效率\n5. 物理上不连续，逻辑上连续\n6. 有可能导致OutOfMemoryError异常\n\n## 方法区\n1. 线程共享\n2. 存储类型信息，常量，静态变量，即时编译器的代码缓存等\n3. 有可能导致OutOfMemoryError异常\n4. 垃圾收集行为比较少，但是存在，主要针对常量池的回收和对类型的卸载\n### 运行时常量池\n1. 类加载后，Class文件的常量池表（编译期生成的各种字面量和符号引用）存放在运行时常量池中\n2. 具备动态性，允许期间也可以将新常量放入池中，例如String的intern（）方法\n## 直接内存\n1. 不是运行时数据区的一部分，但这部分内存经常使用，也有可能导致OutOfMemoryError异常\n2. 与NIO有相关\n3. 直接内存分配不受Java堆的限制，但是受本机总内存限制\n\n# HotSpot虚拟机中的对象\n## HotSpot虚拟机\n\n热点代码探测能力:通过执行计数器找出最具有编译价值的代码,然后通知即时编译器以方法为单位进行编译.\n\n编译器与解释器协同工作,在最优化程序响应时间与最佳执行性能中取得平衡\n## 对象的创建\n1. 遇到字节码new指令时,先检查能否在常量池中定位到一个类的符号引用\n2. 检查符号引用代表的类是否已被加载,解析,初始化,如果没有则执行类加载过程\n3. 为对象分配内存,根据是否规整,有指针碰撞法,空闲链表法\n4. 内存分配还要考虑线程安全问题,可以有两种办法解决:分配内存空间进行同步处理,如CAS配上失败重试。或者可以先分配到每个线程的TLAB中，当本地缓冲区用完后，再同步锁定\n5. 初始化为零值，所以实例字段不赋初始值也能用\n6. 设置对象头（Object Header），如锁信息，哈希码，GC分代年龄等\n7. 执行构造函数 <init>()\n\n## 对象内存布局\n对象头，实例数据，对齐填充\n### 对象头\n1. 分为两类，第一类为Mark Word，第二类是类型指针\n2. Mark Word存储对象自身的运行时数据，如HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等\n3. Mark Word有着动态定义的数据结构，根据对象的状态复用自己的存储空间，根据标志位的不同，存储内容也不同。\n4. ![IMG_20200802_153218](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200802_153218.jpg)\n5. 类型指针是指向他的类型元数据的指针，通过该指针确定对象是哪个类的实例\n6. 如果是数组，还有一块记录数组长度的数据\n### 实例数据\n对象真正存储的有效信息，包括定义的各种类型的字段内容，父类继承下来的字段等等\n### 对齐填充\n确保对象是8字节的整数倍\n## 对象访问定位\n通过栈上的reference数据来操作堆上的具体对象，访问方式有下面两种：\n\t句柄访问，直接指针访问，前者在对象改变时，reference本身不需要修改。后者节省一次指针定位的内存开销，速度更快。HotSpot虚拟机采用直接指针方式。\n\t![IMG_20200802_154351](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200802_154351.jpg)\n\t# 实战\n​\tidea配置：\n​\t`Run-Edit Configurations-Templates-Application-VM options`\n\t## 堆的OOM\n​\t-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError\n​\t解释：设置堆的最小值，最大值一样即可避免堆自动扩展。设置了堆大小为20MB，且出现内存溢出异常Dump出当前的内存堆转储快照以便进行事后分析\n![1](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1.png)\n\n分析是内存泄漏还是内存溢出.\n\n### 内存泄漏\n\n则查看泄漏对象到GC Roots的引用链,查看为什么垃圾回收器无法回收他们\n\n### 内存溢出\n\n即内存对象确实是必须存活的,则首先看看堆参数设置是否合理(-Xmx,-Xms),能否再向上调整。再从代码上检查，减少程序运行期的内存消耗。\n\n## 虚拟机栈和本地方法栈的溢出\n\n1. HotSpot虚拟机不区分这两者，栈容量只能通过-Xss来设置\n2. StackOverflowError与OutOfMemoryError异常，但是HotShot不支持栈内存动态扩展，所以除非创建线程申请内存时就因无法获取足够的内存报OOM，其他只会因为线程请求的栈的深度大于虚拟机所允许的最大深度而报StackOverflowError异常\n\n## 方法区和运行时常量池的溢出\n\nJDK7以后，运行时常量池移至堆之中，主流的框架经常在运行时生成大量动态类的应用场景，需要特别关注这些类的回收状况。但是类被回收的条件很苛刻。\n\nJDK8的元空间中，很少出现方法区的溢出异常，但是还有参数可以设置：\n\n1. -XX:MaxMetaspaceSize 设置元空间最大值，默认是-1，即不限制，只受本地内存的影响\n2. -XX:MetaspaceSize 设置初始空间的大小，达到该值则触发垃圾收集进行类型卸载\n\n## 直接内存溢出\n\n容量可以通过-XX:MaxDirectMemorySize指定，默认与堆最大值一致。\n\n间接使用直接内存的典型就是NIO","slug":"JVM笔记/第2章","published":1,"updated":"2020-11-12T11:57:29.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6vq000cjotp8kdiejoq","content":"<blockquote>\n<p>学习&lt;&lt;深入理解Java虚拟机&gt;&gt;第三版时做的笔记</p>\n</blockquote>\n<h1 id=\"运行时数据区\"><a href=\"#运行时数据区\" class=\"headerlink\" title=\"运行时数据区\"></a>运行时数据区</h1><h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><ol>\n<li>线程私有</li>\n<li>记录正在执行的虚拟机字节码指令的地址(如果是Native方法,则位空)</li>\n<li>不会有OutOfMemoryError</li>\n</ol>\n<h2 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h2><ol>\n<li>线程私有</li>\n<li>存储的是一个个栈帧</li>\n<li>每个方法对应一个栈帧,方法调用则入栈,执行结束则出栈</li>\n<li>可能出现StackOverFlowError与OutOfMemoryError,前者出现是为栈分配了这么大的内存空间,但是线程请求的空间大于所分配的空间,例如不断递归。后者是允许栈动态扩展，但是扩展了还是无法申请到足够的内存，相当于把所有的内存都耗尽了</li>\n</ol>\n<h3 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h3><h4 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h4><ol>\n<li>局部变量槽(slot)中long和double占用两个槽</li>\n<li>所需的内存空间在编译器间完成分配<h4 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h4><h4 id=\"动态连接\"><a href=\"#动态连接\" class=\"headerlink\" title=\"动态连接\"></a>动态连接</h4><h4 id=\"方法出口\"><a href=\"#方法出口\" class=\"headerlink\" title=\"方法出口\"></a>方法出口</h4></li>\n</ol>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><p>与虚拟机栈类似，只是虚拟机栈是为虚拟机执行Java方法服务，本地方法栈是为虚拟机执行本地方法（Native）服务。</p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ol>\n<li>虚拟机管理的内存最大的一块</li>\n<li>所有线程共享</li>\n<li>存放几乎所有对象实例（因为逃逸技术。栈上分配，标量替换优化手段使得并不绝对）</li>\n<li>堆中划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer TLAB），提高对象分配时的效率</li>\n<li>物理上不连续，逻辑上连续</li>\n<li>有可能导致OutOfMemoryError异常</li>\n</ol>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><ol>\n<li>线程共享</li>\n<li>存储类型信息，常量，静态变量，即时编译器的代码缓存等</li>\n<li>有可能导致OutOfMemoryError异常</li>\n<li>垃圾收集行为比较少，但是存在，主要针对常量池的回收和对类型的卸载<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h3></li>\n<li>类加载后，Class文件的常量池表（编译期生成的各种字面量和符号引用）存放在运行时常量池中</li>\n<li>具备动态性，允许期间也可以将新常量放入池中，例如String的intern（）方法<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2></li>\n<li>不是运行时数据区的一部分，但这部分内存经常使用，也有可能导致OutOfMemoryError异常</li>\n<li>与NIO有相关</li>\n<li>直接内存分配不受Java堆的限制，但是受本机总内存限制</li>\n</ol>\n<h1 id=\"HotSpot虚拟机中的对象\"><a href=\"#HotSpot虚拟机中的对象\" class=\"headerlink\" title=\"HotSpot虚拟机中的对象\"></a>HotSpot虚拟机中的对象</h1><h2 id=\"HotSpot虚拟机\"><a href=\"#HotSpot虚拟机\" class=\"headerlink\" title=\"HotSpot虚拟机\"></a>HotSpot虚拟机</h2><p>热点代码探测能力:通过执行计数器找出最具有编译价值的代码,然后通知即时编译器以方法为单位进行编译.</p>\n<p>编译器与解释器协同工作,在最优化程序响应时间与最佳执行性能中取得平衡</p>\n<h2 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h2><ol>\n<li>遇到字节码new指令时,先检查能否在常量池中定位到一个类的符号引用</li>\n<li>检查符号引用代表的类是否已被加载,解析,初始化,如果没有则执行类加载过程</li>\n<li>为对象分配内存,根据是否规整,有指针碰撞法,空闲链表法</li>\n<li>内存分配还要考虑线程安全问题,可以有两种办法解决:分配内存空间进行同步处理,如CAS配上失败重试。或者可以先分配到每个线程的TLAB中，当本地缓冲区用完后，再同步锁定</li>\n<li>初始化为零值，所以实例字段不赋初始值也能用</li>\n<li>设置对象头（Object Header），如锁信息，哈希码，GC分代年龄等</li>\n<li>执行构造函数 <init>()</li>\n</ol>\n<h2 id=\"对象内存布局\"><a href=\"#对象内存布局\" class=\"headerlink\" title=\"对象内存布局\"></a>对象内存布局</h2><p>对象头，实例数据，对齐填充</p>\n<h3 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h3><ol>\n<li>分为两类，第一类为Mark Word，第二类是类型指针</li>\n<li>Mark Word存储对象自身的运行时数据，如HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等</li>\n<li>Mark Word有着动态定义的数据结构，根据对象的状态复用自己的存储空间，根据标志位的不同，存储内容也不同。</li>\n<li><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200802_153218.jpg\" alt=\"IMG_20200802_153218\"></li>\n<li>类型指针是指向他的类型元数据的指针，通过该指针确定对象是哪个类的实例</li>\n<li>如果是数组，还有一块记录数组长度的数据<h3 id=\"实例数据\"><a href=\"#实例数据\" class=\"headerlink\" title=\"实例数据\"></a>实例数据</h3>对象真正存储的有效信息，包括定义的各种类型的字段内容，父类继承下来的字段等等<h3 id=\"对齐填充\"><a href=\"#对齐填充\" class=\"headerlink\" title=\"对齐填充\"></a>对齐填充</h3>确保对象是8字节的整数倍<h2 id=\"对象访问定位\"><a href=\"#对象访问定位\" class=\"headerlink\" title=\"对象访问定位\"></a>对象访问定位</h2>通过栈上的reference数据来操作堆上的具体对象，访问方式有下面两种：<br> 句柄访问，直接指针访问，前者在对象改变时，reference本身不需要修改。后者节省一次指针定位的内存开销，速度更快。HotSpot虚拟机采用直接指针方式。<br> <img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200802_154351.jpg\" alt=\"IMG_20200802_154351\"><h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1>​    idea配置：<br>​    <code>Run-Edit Configurations-Templates-Application-VM options</code><h2 id=\"堆的OOM\"><a href=\"#堆的OOM\" class=\"headerlink\" title=\"堆的OOM\"></a>堆的OOM</h2>​    -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError<br>​    解释：设置堆的最小值，最大值一样即可避免堆自动扩展。设置了堆大小为20MB，且出现内存溢出异常Dump出当前的内存堆转储快照以便进行事后分析<br><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1.png\" alt=\"1\"></li>\n</ol>\n<p>分析是内存泄漏还是内存溢出.</p>\n<h3 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h3><p>则查看泄漏对象到GC Roots的引用链,查看为什么垃圾回收器无法回收他们</p>\n<h3 id=\"内存溢出\"><a href=\"#内存溢出\" class=\"headerlink\" title=\"内存溢出\"></a>内存溢出</h3><p>即内存对象确实是必须存活的,则首先看看堆参数设置是否合理(-Xmx,-Xms),能否再向上调整。再从代码上检查，减少程序运行期的内存消耗。</p>\n<h2 id=\"虚拟机栈和本地方法栈的溢出\"><a href=\"#虚拟机栈和本地方法栈的溢出\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈的溢出\"></a>虚拟机栈和本地方法栈的溢出</h2><ol>\n<li>HotSpot虚拟机不区分这两者，栈容量只能通过-Xss来设置</li>\n<li>StackOverflowError与OutOfMemoryError异常，但是HotShot不支持栈内存动态扩展，所以除非创建线程申请内存时就因无法获取足够的内存报OOM，其他只会因为线程请求的栈的深度大于虚拟机所允许的最大深度而报StackOverflowError异常</li>\n</ol>\n<h2 id=\"方法区和运行时常量池的溢出\"><a href=\"#方法区和运行时常量池的溢出\" class=\"headerlink\" title=\"方法区和运行时常量池的溢出\"></a>方法区和运行时常量池的溢出</h2><p>JDK7以后，运行时常量池移至堆之中，主流的框架经常在运行时生成大量动态类的应用场景，需要特别关注这些类的回收状况。但是类被回收的条件很苛刻。</p>\n<p>JDK8的元空间中，很少出现方法区的溢出异常，但是还有参数可以设置：</p>\n<ol>\n<li>-XX:MaxMetaspaceSize 设置元空间最大值，默认是-1，即不限制，只受本地内存的影响</li>\n<li>-XX:MetaspaceSize 设置初始空间的大小，达到该值则触发垃圾收集进行类型卸载</li>\n</ol>\n<h2 id=\"直接内存溢出\"><a href=\"#直接内存溢出\" class=\"headerlink\" title=\"直接内存溢出\"></a>直接内存溢出</h2><p>容量可以通过-XX:MaxDirectMemorySize指定，默认与堆最大值一致。</p>\n<p>间接使用直接内存的典型就是NIO</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>学习&lt;&lt;深入理解Java虚拟机&gt;&gt;第三版时做的笔记</p>\n</blockquote>\n<h1 id=\"运行时数据区\"><a href=\"#运行时数据区\" class=\"headerlink\" title=\"运行时数据区\"></a>运行时数据区</h1><h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><ol>\n<li>线程私有</li>\n<li>记录正在执行的虚拟机字节码指令的地址(如果是Native方法,则位空)</li>\n<li>不会有OutOfMemoryError</li>\n</ol>\n<h2 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h2><ol>\n<li>线程私有</li>\n<li>存储的是一个个栈帧</li>\n<li>每个方法对应一个栈帧,方法调用则入栈,执行结束则出栈</li>\n<li>可能出现StackOverFlowError与OutOfMemoryError,前者出现是为栈分配了这么大的内存空间,但是线程请求的空间大于所分配的空间,例如不断递归。后者是允许栈动态扩展，但是扩展了还是无法申请到足够的内存，相当于把所有的内存都耗尽了</li>\n</ol>\n<h3 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h3><h4 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h4><ol>\n<li>局部变量槽(slot)中long和double占用两个槽</li>\n<li>所需的内存空间在编译器间完成分配<h4 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h4><h4 id=\"动态连接\"><a href=\"#动态连接\" class=\"headerlink\" title=\"动态连接\"></a>动态连接</h4><h4 id=\"方法出口\"><a href=\"#方法出口\" class=\"headerlink\" title=\"方法出口\"></a>方法出口</h4></li>\n</ol>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><p>与虚拟机栈类似，只是虚拟机栈是为虚拟机执行Java方法服务，本地方法栈是为虚拟机执行本地方法（Native）服务。</p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ol>\n<li>虚拟机管理的内存最大的一块</li>\n<li>所有线程共享</li>\n<li>存放几乎所有对象实例（因为逃逸技术。栈上分配，标量替换优化手段使得并不绝对）</li>\n<li>堆中划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer TLAB），提高对象分配时的效率</li>\n<li>物理上不连续，逻辑上连续</li>\n<li>有可能导致OutOfMemoryError异常</li>\n</ol>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><ol>\n<li>线程共享</li>\n<li>存储类型信息，常量，静态变量，即时编译器的代码缓存等</li>\n<li>有可能导致OutOfMemoryError异常</li>\n<li>垃圾收集行为比较少，但是存在，主要针对常量池的回收和对类型的卸载<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h3></li>\n<li>类加载后，Class文件的常量池表（编译期生成的各种字面量和符号引用）存放在运行时常量池中</li>\n<li>具备动态性，允许期间也可以将新常量放入池中，例如String的intern（）方法<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2></li>\n<li>不是运行时数据区的一部分，但这部分内存经常使用，也有可能导致OutOfMemoryError异常</li>\n<li>与NIO有相关</li>\n<li>直接内存分配不受Java堆的限制，但是受本机总内存限制</li>\n</ol>\n<h1 id=\"HotSpot虚拟机中的对象\"><a href=\"#HotSpot虚拟机中的对象\" class=\"headerlink\" title=\"HotSpot虚拟机中的对象\"></a>HotSpot虚拟机中的对象</h1><h2 id=\"HotSpot虚拟机\"><a href=\"#HotSpot虚拟机\" class=\"headerlink\" title=\"HotSpot虚拟机\"></a>HotSpot虚拟机</h2><p>热点代码探测能力:通过执行计数器找出最具有编译价值的代码,然后通知即时编译器以方法为单位进行编译.</p>\n<p>编译器与解释器协同工作,在最优化程序响应时间与最佳执行性能中取得平衡</p>\n<h2 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h2><ol>\n<li>遇到字节码new指令时,先检查能否在常量池中定位到一个类的符号引用</li>\n<li>检查符号引用代表的类是否已被加载,解析,初始化,如果没有则执行类加载过程</li>\n<li>为对象分配内存,根据是否规整,有指针碰撞法,空闲链表法</li>\n<li>内存分配还要考虑线程安全问题,可以有两种办法解决:分配内存空间进行同步处理,如CAS配上失败重试。或者可以先分配到每个线程的TLAB中，当本地缓冲区用完后，再同步锁定</li>\n<li>初始化为零值，所以实例字段不赋初始值也能用</li>\n<li>设置对象头（Object Header），如锁信息，哈希码，GC分代年龄等</li>\n<li>执行构造函数 <init>()</li>\n</ol>\n<h2 id=\"对象内存布局\"><a href=\"#对象内存布局\" class=\"headerlink\" title=\"对象内存布局\"></a>对象内存布局</h2><p>对象头，实例数据，对齐填充</p>\n<h3 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h3><ol>\n<li>分为两类，第一类为Mark Word，第二类是类型指针</li>\n<li>Mark Word存储对象自身的运行时数据，如HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等</li>\n<li>Mark Word有着动态定义的数据结构，根据对象的状态复用自己的存储空间，根据标志位的不同，存储内容也不同。</li>\n<li><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200802_153218.jpg\" alt=\"IMG_20200802_153218\"></li>\n<li>类型指针是指向他的类型元数据的指针，通过该指针确定对象是哪个类的实例</li>\n<li>如果是数组，还有一块记录数组长度的数据<h3 id=\"实例数据\"><a href=\"#实例数据\" class=\"headerlink\" title=\"实例数据\"></a>实例数据</h3>对象真正存储的有效信息，包括定义的各种类型的字段内容，父类继承下来的字段等等<h3 id=\"对齐填充\"><a href=\"#对齐填充\" class=\"headerlink\" title=\"对齐填充\"></a>对齐填充</h3>确保对象是8字节的整数倍<h2 id=\"对象访问定位\"><a href=\"#对象访问定位\" class=\"headerlink\" title=\"对象访问定位\"></a>对象访问定位</h2>通过栈上的reference数据来操作堆上的具体对象，访问方式有下面两种：<br> 句柄访问，直接指针访问，前者在对象改变时，reference本身不需要修改。后者节省一次指针定位的内存开销，速度更快。HotSpot虚拟机采用直接指针方式。<br> <img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200802_154351.jpg\" alt=\"IMG_20200802_154351\"><h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1>​    idea配置：<br>​    <code>Run-Edit Configurations-Templates-Application-VM options</code><h2 id=\"堆的OOM\"><a href=\"#堆的OOM\" class=\"headerlink\" title=\"堆的OOM\"></a>堆的OOM</h2>​    -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError<br>​    解释：设置堆的最小值，最大值一样即可避免堆自动扩展。设置了堆大小为20MB，且出现内存溢出异常Dump出当前的内存堆转储快照以便进行事后分析<br><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1.png\" alt=\"1\"></li>\n</ol>\n<p>分析是内存泄漏还是内存溢出.</p>\n<h3 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h3><p>则查看泄漏对象到GC Roots的引用链,查看为什么垃圾回收器无法回收他们</p>\n<h3 id=\"内存溢出\"><a href=\"#内存溢出\" class=\"headerlink\" title=\"内存溢出\"></a>内存溢出</h3><p>即内存对象确实是必须存活的,则首先看看堆参数设置是否合理(-Xmx,-Xms),能否再向上调整。再从代码上检查，减少程序运行期的内存消耗。</p>\n<h2 id=\"虚拟机栈和本地方法栈的溢出\"><a href=\"#虚拟机栈和本地方法栈的溢出\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈的溢出\"></a>虚拟机栈和本地方法栈的溢出</h2><ol>\n<li>HotSpot虚拟机不区分这两者，栈容量只能通过-Xss来设置</li>\n<li>StackOverflowError与OutOfMemoryError异常，但是HotShot不支持栈内存动态扩展，所以除非创建线程申请内存时就因无法获取足够的内存报OOM，其他只会因为线程请求的栈的深度大于虚拟机所允许的最大深度而报StackOverflowError异常</li>\n</ol>\n<h2 id=\"方法区和运行时常量池的溢出\"><a href=\"#方法区和运行时常量池的溢出\" class=\"headerlink\" title=\"方法区和运行时常量池的溢出\"></a>方法区和运行时常量池的溢出</h2><p>JDK7以后，运行时常量池移至堆之中，主流的框架经常在运行时生成大量动态类的应用场景，需要特别关注这些类的回收状况。但是类被回收的条件很苛刻。</p>\n<p>JDK8的元空间中，很少出现方法区的溢出异常，但是还有参数可以设置：</p>\n<ol>\n<li>-XX:MaxMetaspaceSize 设置元空间最大值，默认是-1，即不限制，只受本地内存的影响</li>\n<li>-XX:MetaspaceSize 设置初始空间的大小，达到该值则触发垃圾收集进行类型卸载</li>\n</ol>\n<h2 id=\"直接内存溢出\"><a href=\"#直接内存溢出\" class=\"headerlink\" title=\"直接内存溢出\"></a>直接内存溢出</h2><p>容量可以通过-XX:MaxDirectMemorySize指定，默认与堆最大值一致。</p>\n<p>间接使用直接内存的典型就是NIO</p>\n"},{"title":"深入理解Java虚拟机--垃圾收集器与内存分配策略","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习<<深入理解Java虚拟机>>所做的笔记,此为书上第三章--垃圾收集器与内存分配策略。","abbrlink":"7dd93822","date":"2020-07-02T16:00:00.000Z","_content":"\n# 垃圾标记算法\n\n## 引用计数算法\n\n缺点在于两个对象互相引用,但是又不可被访问时,引用计数不为0,无法被回收\n\nJava虚拟机没有采用这种算法\n\n## 可达性分析算法\n\n通过GC Roots根对象作为起始节点集,引用链搜索.\n\n如果对象到GC Roots不可达,则不可能再被使用\n\n### 可作为GC Roots的对象\n\n1. 虚拟机栈中引用的对象\n2. 方法区中类静态属性引用的对象\n3. 方法区中常量引用的对象,例如字符串常量池里的引用\n4. Native方法引用的对象\n5. Java虚拟机内部的引用\n6. 被synchronized持有的对象\n\n\n\n## 引用\n\n### 强引用\n\n最传统的引用,形如:`Object obj=new Object()`\n\n只要强引用关系还存在,则永远不会回收掉被引用的对象\n\n### 软引用\n描述一些还有用,但是非必须的对象。在系统将要发生内存溢出异常前，会把这些对象列入回收范围内进行二次回收。\n### 弱引用\n也是描述一些还有用,但是非必须的对象。比软引用更弱，只能生存到下一次垃圾收集发生为止。垃圾收集器工作时，不管内存是否充足，都会回收掉弱引用关联的对象\n### 虚引用\n无法通过虚引用得到一个对象实例。设置虚引用关联的唯一目的是能在这个对象被收集器回收时收到一个系统通知\n\n## 不可达对象的回收过程\n1. 进行可达性分析后，发现没有于GC Roots相连接的引用链，进行第一次标记\n2. 随后查看是否有必要执行finalize（）方法，如果没有重写它，或者已经被调用过，则没有必要执行，则回收\n3. 如果有必要执行，则放置在F-Queue队列中\n4. finalize方法是对象最后的逃脱机会，如果它在finalize方法中重新与引用链上任何一个对象建立关联，则不会被回收。如果还没逃脱，则被回收了。\n5. 任何一个对象finalize方法只会被执行一次\n尽量避免使用finalize（）方法\n## 回收方法区\n1. 主要回收废弃的常量和不再使用的类型\n2. 回收类型很苛刻，得同时满足三个条件：该类所有实例被回收，加载该类的类加载器被回收，该类对应的Class对象没有被引用\n3. 在框架等自定义类加载器的场景中，通常需要虚拟机具有类型卸载的能力\n\n# 垃圾收集算法\n## 分代收集理论\n1. 根据弱分代假说，强分代假说。分为新生代，老年代\n2. 跨代引用假说：跨带引用相对于同代引用占比很小。所以在新生代建立全局的数据结构（记忆集），标识出老年代哪一块内存会存在跨带引用。之后的Minor GC中，只有包含在记忆集的对象才会加入GC Roots中进行扫描\n3. Minor GC/Young GC 目标只是新生代的垃圾收集\n4. Major GC/Old GC 目标只是老年代的垃圾收集，只有CMS收集器有\n5. Full GC 收集整个Java堆和方法区的垃圾收集\n## 标记清除算法\n先标记所有要回收的对象，标记完成后统一回收所有被标记对象\n缺点：\n\t1. 执行效率不稳定，随对象数量的增长而下降\n\t2. 存在内存空间碎片化的问题\n\n## 标记复制算法\n### 半区复制\n将内存容量划分成大小相等的两块，每次只使用其中一块。当其中一块用完后，把还存活的对象复制到另一块，再把已经使用的清空。\n实现简单，运行高效，但是可用内存缩小为原来的一半。\n### 优化后的半区复制\n1. 把新生代分为Eden，Survivor1，Survivor2区，空间为8：1：1\n2. 每次只使用Eden区和其中一块Survivor区\n3. 发生垃圾回收时，将Eden区和使用的Survivor区仍然存活的对象复制到另一块Survivor区，清空Eden区和之前使用的Survivor区\n4. 如果另一块Survivor区没有足够的空间存放存活对象，这些对象可以通过担保机制直接进入老年代\n\n## 标记整理算法\n\n1. 针对老年代的算法\n2. 先标记,再让所有存活的对象都向内存空间的一端移动,然后直接清理掉边界以外的内存\n3. 是移动式算法,负载较重,需要全程暂停用户应用程序,即Stop The World.但优点是不会产生碎片.总的来说提高了吞吐量.因为HotShot虚拟机关注吞吐量,所以采用了标记整理.\n\n# HotSpot虚拟机细节\n\n## 根节点枚举\n\n1. 固定可作为GC Roots的主要是:1.全局性引用(常量和类静态属性)2.执行上下文(栈帧中的本地变量表)\n2. 根节点枚举必须STW,因为它必须要再一个能保障一致性的快照上才得以进行\n3. 通过OopMap直接得到哪个地方存放着对象引用.不需要一个不漏的检查所有执行上下文和全局的引用位置\n\n## 安全点\n\n1. 只有在特定的位置才记录下OopMap信息,即安全点\n2. 用户进程必须执行到安全点才能够暂停\n3. 安全点位置选取以\"是否具有让程序长时间执行的特征\"为标准,最明显的特征就是有指令序列的复用\n4. 还需要在垃圾收集发生时让所有线程都跑到最近的安全点,然后停顿下来\n\n### 抢先式中断\n\n当垃圾收集时,把所有线程中断,再让不在安全点的继续跑到安全点\n\n没有虚拟机采用\n\n### 主动式中断\n\n简单设置标志位,每个线程执行时不断轮询它,一旦中断标志位为真,则自己在最近的安全点主动中断挂起。\n\n轮询操作精简到只有一条汇编指令--完成安全点轮询和触发线程中断\n\n## 安全区域\n\n1. 处于Sleep或Block状态的用户线程无法响应虚拟机的中断请求，不能走到安全的地方去中断挂起自己。\n2. 所以安全区域确保在某一段代码中，引用关系不会发生改变，在这个区域内进行垃圾收集是安全的。可以把安全区域看作是被扩展拉伸的安全点\n3. 用户线程到了安全区域，会标识已经进入安全区域。而要离开时，如果虚拟机已经完成了根节点枚举，则继续执行，否则要一直等待直到收到可以离开安全区的信息\n\n## 记忆集和卡表\n\n1. 记忆集是用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。\n2. 收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可\n3. 所以可以采用更粗的记录粒度来节省记忆集的开销。\n4. 目前最常采用的是卡表，卡表是记忆集的具体实现。卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨带指针。\n5. 卡表最简单是实现是字节数组，每一个元素都对应着其标识的内存区域中一块特定大小的内存块，即卡页。大小为2的9次方，512字节。\n6. 一个卡页通常不止一个对象。只要卡也中其中一个对象存在了跨代指针，就标识为1，即变脏。\n7. 垃圾收集时，就把卡表中变脏的元素对应的内存块加入GC Roots中一并扫描\n\n## 写屏障\n\n1. 有其他分代区域中对象引用了本区域对象时,对应的卡表元素应该变脏.时间点应该发生在引用类型字段赋值的那一刻。\n2. HotSpot虚拟机通过写屏障技术维护卡表状态,是在虚拟机层面上对\"引用类型字段赋值\"这个动作的AOP切面,即在引用对象赋值时会产生一个环绕通知,供程序执行额外操作。\n3. 应用写屏障后，虚拟机会为所有赋值操作生成相应的指令。每次对引用进行更新，就会产生额外的开销。\n4. 卡表在高并发场景下的“伪共享”问题：缓存系统以缓存行为单位存储，当多线程互相修改独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响而导致性能下降。\n5. 为避免伪共享问题，可以先检查卡带标记，只有当该卡表元素未被标记过时才将其标记为变脏。\n\n## 并发的可达性分析\n\n1. 可达性分析算法理论上要求全过程都STW。在根节点枚举过程中，通过OopMap技术，停顿时间已经比较短暂了。但是从GC Roots遍历图花费的时间与堆容量成正比，所以需要优化。\n2. 如果用户线程与收集器并发工作。收集器在对象图上标记颜色，同时用户线程在修改引用关系，即修改对象图的结构。会产生两种后果：1.把原本消亡的对象标记为存活，这可以容忍 2.把存活对象标记为消亡，则肯定会出错\n\n### 对象消失\n\n即原本是黑色的对象被误标记为白色，需要下述条件同时满足：\n\n1. 新增了黑色到白色对象的新引用。\n2. 删除了灰色到该白色对象的所有引用\n\n### 解决方案\n\n破坏两个条件之一即可。都是通过写屏障实现\n\n1. 增量更新。理解为当黑色对象一旦插入了指向白色对象的引用后，它就变回灰色对象。\n2. 原始快照。无论引用对象删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。\n\n# 经典垃圾收集器\n\n## 简介\n\n如果两个收集器之间存在连线，则可以搭配使用\n\n![abcd](https://tongji4m3.oss-cn-beijing.aliyuncs.com/abcd.png)\n\n## Serial收集器\n\n1. 单线程新生代收集器，必须STW\n2. 是客户端模式下默认的新生代收集器，简单而高效\n3. 对于内存资源受限，单核处理器或处理器核心数较少的环境表现良好\n\n## ParNew收集器\n\n1. 是Serial收集器的并行版本，其他与Serial大致相同\n2. JDK9后，ParNew与CMS只能互相搭配使用\n3. 在单核心处理器不会有比Serial更好的效果\n\n## Parallel Scavenge\n\n1. 同样是基于标记-复制算法，并行收集的多线程收集器。被认为是吞吐量优先收集器。\n2. 目标是达到一个可控制的吞吐量，即运行用户代码的时间/（运行用户代码的时间+运行垃圾收集时间）\n3. 停顿时间短适合用户交互，高吞吐量适用于后台运算，能最高效率的利用处理器资源，尽快完成任务。\n4. -XX:MaxGCPauseMillis控制最大垃圾收集停顿时间。设置吞吐量大小：-XX:GCTimeRatio\n5. -XX:+UseAdaptiveSizePolicy 根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量。自适应的调节策略。\n\n## Serial Old收集器\n\n单线程收集器，使用标记整理算法，供客户端模式使用的。\n\n## Parallel Old收集器\n\n支持多线程并发收集。\n\n“吞吐量优先”收集器搭配组合：Parallel Scavenge与Parallel Old\n\n## CMS收集器\n\n1. 并发收集，低停顿，以获取最短回收停顿时间为目标\n2. 基于标记-清除算法\n\n### 四个阶段\n\n1. 初始标记。需要STW，仅仅标记一下GC Roots直接关联到的对象，速度很快。\n2. 并发标记。从GC Roots直接关联到的对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程，可以并发执行。\n3. 重新标记。修改并发标记期间，因用户线程继续运行而导致的标记发生变动的那一部分对象的标记记录。参考之前的增量更新。需要STW，但是时间仍然比较短。\n4. 并发清除。删除掉标记阶段判断为已经死亡的对象，不需要移动对象，所以可以和用户线程并发执行。\n\n### 三个问题\n\n1. 对处理器资源敏感。即在并发阶段，虽然不会导致用户线程停顿，但因为占用一部分线程，而导致应用程序变慢，降低总吞吐量。\n2. 无法处理浮动垃圾。可能因失败而导致另一次完全的STW的Full GC产生。浮动垃圾即用户线程在并发执行时还会伴随着新的垃圾对象不断产生，但CMS无法在当次收集中处理他们。而且用户线程持续运行，就需要预留足够的内存空间提供给用户线程使用。如果预留的空间无法满足程序分配新对象的需要，就会出现并发失败（Concurrent Mode Failure）就会冻结用户线程的执行，临时启用Serial Old收集器重新进行老年代的垃圾收集。\n3. 有大量的空间碎片。如果无法找到足够大的连续空间来分配给当前对象，则会提前触发一次Full GC。\n\n\n\n## Garbage First收集器\n\n1. 面向局部收集，基于Region内存布局\n2. JDK8后，被称为全功能的垃圾收集器。主要面向服务端。\n3. JDK9后完全取代了Parallel Scavenge加Parallel Old组合，成为服务端模式下默认垃圾收集器。\n4. 建立了停顿时间模型。即能够支持指定的一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒。\n5. 它可以面向堆内存的任何部分来组成回收集。衡量标准不再是属于哪个分代，而是哪块内存存放的垃圾数量最多，回收收益最大。即为Mixed GC模式。\n6. 把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region可以扮演Eden，Survivor或者老年代空间。对扮演不同角色的Region采取不同的策略进行处理。\n7. 还有专门存储大对象的Humongous区域。只要大于Region容量的一半即认为是大对象。而大于一个Region的大对象就会存放在N个连续的Humongous Region区域。将Humongous Region区域作为老年代的一部分看待。\n8. 将Region作为单位回收的最小单元，每次收集的内存空间是Region大小的整数倍。\n9. 按照各个Region垃圾堆积的价值大小，即回收所获得的空间大小和回收所需时间的经验值。在后台维护优先队列，根据用户运行的收集停顿时间，优先回收价值收益最大的Region。\n\n### 细节\n\n1. 跨Region引用对象的解决。每个Region都维护自己的记忆集。记录下别的Region指向自己的指针，并且标记这些指针分别在哪些卡页的范围内。记忆集为哈希表，key为别的Region的起始地址，value是卡表索引号的集合。大致需要10%-20%的Java堆内存维持收集器工作。\n2. 并发标记阶段采用原始快照保证收集线程与用户线程互不干扰的运行。因为程序继续运行会有新对象的创建。所以每个Region都设计了两个指针，划分出一块用于并发回收过程中新对象的分配。这个地址内的对象默认是存活的，不纳入回收范围。如果内存回收速度赶不上分配速度，则也会Full GC,STW\n3. 建立可靠的停顿预测模型。根据每个Region的回收耗时等信息分析得出平均值等统计信息。衰减平均值比普通的平均值更加容易受到新数据的影响，代表“最近的”平均状态。即Region的统计状态越新，越能决定其回收价值。通过这些信息进行预测，就能在不超过期望停顿时间的约束下获得最高的收益。\n\n### 实现步骤\n\n1. 初始标记。需要STW，仅仅标记一下GC Roots直接关联到的对象，并且修改TAMS指针,让下一阶段用户线程并发执行时,能正确的在可用Region中分配新对象.需要停顿线程,但耗时很短。\n2. 并发标记。从GC Roots直接关联到的对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程，可以并发执行。扫描结束后，还要重新处理原始快照记录下在并发有引用变动的对象。\n3. 最终标记。对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍然遗留下来的最后那少量的原始快照（SATB）记录。\n4. 筛选回收。根据Region的回收价值和成本进行排序，再根据用户所期望的停顿时间来制定回收计划。把决定回收的Region存活对象复制到空的Region，再清理掉整个旧Region的全部空间。必须暂停用户线程。\n\n### 其他\n\n目标是在延迟可控的情况下获得尽可能高的吞吐量。\n\n可以由用户指定期望的停顿时间\n\n停顿时间设置100-200ms之间会比较合适，太低则导致选出来的回收集只占堆内存很小一部分。\n\n追求能应付用于的内存分配速率，而不是追求一次把整个Java堆清理干净。\n\nG1整体是基于标记整理算法的，而局部即两个Region之间，则是基于标记复制算法的。使得不会产生内存碎片。\n\n### 相对于CMS的缺点\n\n1. 内存占用率高，因为卡表\n2. 对写屏障有复杂操作，不得不实现为类似消息队列的结构，先放到队列，再异步处理。\n3. 在小内存上CMS大概率优于G1平衡点大致是6-8GB内存\n\n# 低延迟垃圾回收器\n\n## 理论\n\n衡量垃圾收集器指标：内存占用，吞吐量，延迟。最多能同时达到其中两项\n\nCMS，G1分别采用增量更新，原始快照方式实现了标记阶段的并发，但是对于标记后的处理仍未得到妥善解决。\n\nShenandoah和ZGC几乎整个工作过程都是并发的，只有在初始标记，最终标记这些阶段有短暂的停顿。\n\n## ZGC收集器\n\n基于Region内存布局的，不设分代的，使用了读屏障，染色指针和内存多映射来实现的可并发的标记整理算法，以低延迟为首要目标的一款垃圾收集器。\n\n### 内存布局\n\nRegion具有动态性，动态创建和销毁，有动态的区域容量大小\n\n1. 小型Region：容量固定2MB\n2. 中型Region：容量固定32MB\n3. 大型Region：容量不固定，但是必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region只会存放一个大对象。\n\n### 染色指针技术\n\n把标记信息直接记录在引用对象的指针上。标志信息包括引用对象的三色标记状态，是否进入重分配集（即被移动过）等。\n\n优势：\n\n1. 一旦某个Region的存活对象被移走之后，该Region立即就能被释放和重用。\n2. 大幅度减少内存屏障的使用数量，只使用了读屏障。\n3. 可扩展，之后可以把指针前18位开发使用。\n\n### 运行流程\n\n分为4个大阶段，都可以并发执行，只在两个阶段中间会存在短暂的停顿小阶段\n\n#### 并发阶段。\n\n遍历对象图做可达性分析。标记只在染色指针上进行。\n\n#### 并发预备重分配。\n\n得出本次收集过程需要清理哪些Region，将他们组成重分配集。ZGC每次都会扫描所有的Region，换取G1中记忆集的维护成本。\n\n#### 并发重分配。\n\n1. 把重分配集中存活对象复制到新的Region中。并且为重分配集的每个Region维护转发表，记录从旧对象到新对象的转向关系。\n2. 仅从引用就明确得知一个对象是否处于重分配集中。\n3. 自愈能力：在ZGC中，当读取处于重分配集的对象时，会被读屏障拦截，通过转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。只慢一次。\n\n#### 并发重映射\n\n修正整个堆中指向重分配集中旧对象的所有引用。不是迫切任务，因为可以旧引用通过自愈，最多是第一次比较慢。\n\n\n\n### 特点\n\n能承受的对象分配速率不会太高。\n\n支持“NUMA-Aware”（非统一的内存访问架构。为多处理器计算机所设计的内存架构）的内存分配。\n\n令人震惊的，革命性的ZGC  \n\n\n\n\n\n## Epsilon收集器\n\n不能够进行垃圾收集，无操作的垃圾收集器。对于微服务等，只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出，那么运行负载极小，没有任何回收行为的Epsilon是恰当的选择。\n\n# 内存分配与回收策略\n\n## 目标\n\n自动给对象分配内存\n\n自动回收分配给对象的内存\n\n## 策略\n\n1. 对象内存分配应该都是堆上分配(但也有可能栈上分配)\n2. 新生对象通常分配在新生代中,少数情况(如对象大小超过一定阈值)可能直接分配到老年代\n\n### 对象优先分配Eden区域\n\n1. 大多数情况下在Eden区分配\n2. 新生代总可用空间为Eden区+1个Survivor区的总容量\n3. 当Eden没有足够的空间时发生一次Minor GC,如果对象放不进Survivor区,则通过分配担保机制提前把这些对象转移到老年代\n\n### 大对象直接进入老年代\n\n大对象需要大量连续的内存空间，例如很长的字符串,很长的数组。\n\n容易导致提前垃圾收集，以获取足够的连续空间安置大对象\n\n大对象直接在老年代分配，以避免在Eden与Survivor区来回复制，付出高额内存复制开销\n\n### 长期存活对象进入老年代\n\n每个对象头有对象年龄计数器。如果经过一次MinorGC仍然存活，并且能被Survivor容纳，则计数器+1，当到15时，则晋身为老年代。\n\n### 动态对象年龄判断\n\n如果Survivor区中相同年龄所有对象的总和大于Survivor区的一半，那么年龄大于等于该年龄‘的对象直接进入老年代\n\n### 空间分配担保\n\n在Minor GC前，检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果成立，则这次Minor GC安全。负责要看是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的平均大小，如果小于，或者不允许担保，则Full GC。\n\n新生代中，把Survivor无法容纳的对象直接送入老年代，担保前提是老年代本身有容纳这些对象的剩余空间。\n\n在JDK7及之后。不能设置参数影响空间分配担保策略。只要老年代最大可用连续空间大于新生代的所有对象空间，或者大于历次晋升到老年代的平均大小，就进行Minor GC，负责Full GC","source":"_posts/JVM笔记/第3章.md","raw":"---\ntitle: 深入理解Java虚拟机--垃圾收集器与内存分配策略\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第三章--垃圾收集器与内存分配策略。'\ncategories: JVM学习笔记\ntags:\n  - 深入理解Java虚拟机\n  - JVM\n  - 垃圾收集器\nabbrlink: 7dd93822\ndate: 2020-07-03 00:00:00\n---\n\n# 垃圾标记算法\n\n## 引用计数算法\n\n缺点在于两个对象互相引用,但是又不可被访问时,引用计数不为0,无法被回收\n\nJava虚拟机没有采用这种算法\n\n## 可达性分析算法\n\n通过GC Roots根对象作为起始节点集,引用链搜索.\n\n如果对象到GC Roots不可达,则不可能再被使用\n\n### 可作为GC Roots的对象\n\n1. 虚拟机栈中引用的对象\n2. 方法区中类静态属性引用的对象\n3. 方法区中常量引用的对象,例如字符串常量池里的引用\n4. Native方法引用的对象\n5. Java虚拟机内部的引用\n6. 被synchronized持有的对象\n\n\n\n## 引用\n\n### 强引用\n\n最传统的引用,形如:`Object obj=new Object()`\n\n只要强引用关系还存在,则永远不会回收掉被引用的对象\n\n### 软引用\n描述一些还有用,但是非必须的对象。在系统将要发生内存溢出异常前，会把这些对象列入回收范围内进行二次回收。\n### 弱引用\n也是描述一些还有用,但是非必须的对象。比软引用更弱，只能生存到下一次垃圾收集发生为止。垃圾收集器工作时，不管内存是否充足，都会回收掉弱引用关联的对象\n### 虚引用\n无法通过虚引用得到一个对象实例。设置虚引用关联的唯一目的是能在这个对象被收集器回收时收到一个系统通知\n\n## 不可达对象的回收过程\n1. 进行可达性分析后，发现没有于GC Roots相连接的引用链，进行第一次标记\n2. 随后查看是否有必要执行finalize（）方法，如果没有重写它，或者已经被调用过，则没有必要执行，则回收\n3. 如果有必要执行，则放置在F-Queue队列中\n4. finalize方法是对象最后的逃脱机会，如果它在finalize方法中重新与引用链上任何一个对象建立关联，则不会被回收。如果还没逃脱，则被回收了。\n5. 任何一个对象finalize方法只会被执行一次\n尽量避免使用finalize（）方法\n## 回收方法区\n1. 主要回收废弃的常量和不再使用的类型\n2. 回收类型很苛刻，得同时满足三个条件：该类所有实例被回收，加载该类的类加载器被回收，该类对应的Class对象没有被引用\n3. 在框架等自定义类加载器的场景中，通常需要虚拟机具有类型卸载的能力\n\n# 垃圾收集算法\n## 分代收集理论\n1. 根据弱分代假说，强分代假说。分为新生代，老年代\n2. 跨代引用假说：跨带引用相对于同代引用占比很小。所以在新生代建立全局的数据结构（记忆集），标识出老年代哪一块内存会存在跨带引用。之后的Minor GC中，只有包含在记忆集的对象才会加入GC Roots中进行扫描\n3. Minor GC/Young GC 目标只是新生代的垃圾收集\n4. Major GC/Old GC 目标只是老年代的垃圾收集，只有CMS收集器有\n5. Full GC 收集整个Java堆和方法区的垃圾收集\n## 标记清除算法\n先标记所有要回收的对象，标记完成后统一回收所有被标记对象\n缺点：\n\t1. 执行效率不稳定，随对象数量的增长而下降\n\t2. 存在内存空间碎片化的问题\n\n## 标记复制算法\n### 半区复制\n将内存容量划分成大小相等的两块，每次只使用其中一块。当其中一块用完后，把还存活的对象复制到另一块，再把已经使用的清空。\n实现简单，运行高效，但是可用内存缩小为原来的一半。\n### 优化后的半区复制\n1. 把新生代分为Eden，Survivor1，Survivor2区，空间为8：1：1\n2. 每次只使用Eden区和其中一块Survivor区\n3. 发生垃圾回收时，将Eden区和使用的Survivor区仍然存活的对象复制到另一块Survivor区，清空Eden区和之前使用的Survivor区\n4. 如果另一块Survivor区没有足够的空间存放存活对象，这些对象可以通过担保机制直接进入老年代\n\n## 标记整理算法\n\n1. 针对老年代的算法\n2. 先标记,再让所有存活的对象都向内存空间的一端移动,然后直接清理掉边界以外的内存\n3. 是移动式算法,负载较重,需要全程暂停用户应用程序,即Stop The World.但优点是不会产生碎片.总的来说提高了吞吐量.因为HotShot虚拟机关注吞吐量,所以采用了标记整理.\n\n# HotSpot虚拟机细节\n\n## 根节点枚举\n\n1. 固定可作为GC Roots的主要是:1.全局性引用(常量和类静态属性)2.执行上下文(栈帧中的本地变量表)\n2. 根节点枚举必须STW,因为它必须要再一个能保障一致性的快照上才得以进行\n3. 通过OopMap直接得到哪个地方存放着对象引用.不需要一个不漏的检查所有执行上下文和全局的引用位置\n\n## 安全点\n\n1. 只有在特定的位置才记录下OopMap信息,即安全点\n2. 用户进程必须执行到安全点才能够暂停\n3. 安全点位置选取以\"是否具有让程序长时间执行的特征\"为标准,最明显的特征就是有指令序列的复用\n4. 还需要在垃圾收集发生时让所有线程都跑到最近的安全点,然后停顿下来\n\n### 抢先式中断\n\n当垃圾收集时,把所有线程中断,再让不在安全点的继续跑到安全点\n\n没有虚拟机采用\n\n### 主动式中断\n\n简单设置标志位,每个线程执行时不断轮询它,一旦中断标志位为真,则自己在最近的安全点主动中断挂起。\n\n轮询操作精简到只有一条汇编指令--完成安全点轮询和触发线程中断\n\n## 安全区域\n\n1. 处于Sleep或Block状态的用户线程无法响应虚拟机的中断请求，不能走到安全的地方去中断挂起自己。\n2. 所以安全区域确保在某一段代码中，引用关系不会发生改变，在这个区域内进行垃圾收集是安全的。可以把安全区域看作是被扩展拉伸的安全点\n3. 用户线程到了安全区域，会标识已经进入安全区域。而要离开时，如果虚拟机已经完成了根节点枚举，则继续执行，否则要一直等待直到收到可以离开安全区的信息\n\n## 记忆集和卡表\n\n1. 记忆集是用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。\n2. 收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可\n3. 所以可以采用更粗的记录粒度来节省记忆集的开销。\n4. 目前最常采用的是卡表，卡表是记忆集的具体实现。卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨带指针。\n5. 卡表最简单是实现是字节数组，每一个元素都对应着其标识的内存区域中一块特定大小的内存块，即卡页。大小为2的9次方，512字节。\n6. 一个卡页通常不止一个对象。只要卡也中其中一个对象存在了跨代指针，就标识为1，即变脏。\n7. 垃圾收集时，就把卡表中变脏的元素对应的内存块加入GC Roots中一并扫描\n\n## 写屏障\n\n1. 有其他分代区域中对象引用了本区域对象时,对应的卡表元素应该变脏.时间点应该发生在引用类型字段赋值的那一刻。\n2. HotSpot虚拟机通过写屏障技术维护卡表状态,是在虚拟机层面上对\"引用类型字段赋值\"这个动作的AOP切面,即在引用对象赋值时会产生一个环绕通知,供程序执行额外操作。\n3. 应用写屏障后，虚拟机会为所有赋值操作生成相应的指令。每次对引用进行更新，就会产生额外的开销。\n4. 卡表在高并发场景下的“伪共享”问题：缓存系统以缓存行为单位存储，当多线程互相修改独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响而导致性能下降。\n5. 为避免伪共享问题，可以先检查卡带标记，只有当该卡表元素未被标记过时才将其标记为变脏。\n\n## 并发的可达性分析\n\n1. 可达性分析算法理论上要求全过程都STW。在根节点枚举过程中，通过OopMap技术，停顿时间已经比较短暂了。但是从GC Roots遍历图花费的时间与堆容量成正比，所以需要优化。\n2. 如果用户线程与收集器并发工作。收集器在对象图上标记颜色，同时用户线程在修改引用关系，即修改对象图的结构。会产生两种后果：1.把原本消亡的对象标记为存活，这可以容忍 2.把存活对象标记为消亡，则肯定会出错\n\n### 对象消失\n\n即原本是黑色的对象被误标记为白色，需要下述条件同时满足：\n\n1. 新增了黑色到白色对象的新引用。\n2. 删除了灰色到该白色对象的所有引用\n\n### 解决方案\n\n破坏两个条件之一即可。都是通过写屏障实现\n\n1. 增量更新。理解为当黑色对象一旦插入了指向白色对象的引用后，它就变回灰色对象。\n2. 原始快照。无论引用对象删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。\n\n# 经典垃圾收集器\n\n## 简介\n\n如果两个收集器之间存在连线，则可以搭配使用\n\n![abcd](https://tongji4m3.oss-cn-beijing.aliyuncs.com/abcd.png)\n\n## Serial收集器\n\n1. 单线程新生代收集器，必须STW\n2. 是客户端模式下默认的新生代收集器，简单而高效\n3. 对于内存资源受限，单核处理器或处理器核心数较少的环境表现良好\n\n## ParNew收集器\n\n1. 是Serial收集器的并行版本，其他与Serial大致相同\n2. JDK9后，ParNew与CMS只能互相搭配使用\n3. 在单核心处理器不会有比Serial更好的效果\n\n## Parallel Scavenge\n\n1. 同样是基于标记-复制算法，并行收集的多线程收集器。被认为是吞吐量优先收集器。\n2. 目标是达到一个可控制的吞吐量，即运行用户代码的时间/（运行用户代码的时间+运行垃圾收集时间）\n3. 停顿时间短适合用户交互，高吞吐量适用于后台运算，能最高效率的利用处理器资源，尽快完成任务。\n4. -XX:MaxGCPauseMillis控制最大垃圾收集停顿时间。设置吞吐量大小：-XX:GCTimeRatio\n5. -XX:+UseAdaptiveSizePolicy 根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量。自适应的调节策略。\n\n## Serial Old收集器\n\n单线程收集器，使用标记整理算法，供客户端模式使用的。\n\n## Parallel Old收集器\n\n支持多线程并发收集。\n\n“吞吐量优先”收集器搭配组合：Parallel Scavenge与Parallel Old\n\n## CMS收集器\n\n1. 并发收集，低停顿，以获取最短回收停顿时间为目标\n2. 基于标记-清除算法\n\n### 四个阶段\n\n1. 初始标记。需要STW，仅仅标记一下GC Roots直接关联到的对象，速度很快。\n2. 并发标记。从GC Roots直接关联到的对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程，可以并发执行。\n3. 重新标记。修改并发标记期间，因用户线程继续运行而导致的标记发生变动的那一部分对象的标记记录。参考之前的增量更新。需要STW，但是时间仍然比较短。\n4. 并发清除。删除掉标记阶段判断为已经死亡的对象，不需要移动对象，所以可以和用户线程并发执行。\n\n### 三个问题\n\n1. 对处理器资源敏感。即在并发阶段，虽然不会导致用户线程停顿，但因为占用一部分线程，而导致应用程序变慢，降低总吞吐量。\n2. 无法处理浮动垃圾。可能因失败而导致另一次完全的STW的Full GC产生。浮动垃圾即用户线程在并发执行时还会伴随着新的垃圾对象不断产生，但CMS无法在当次收集中处理他们。而且用户线程持续运行，就需要预留足够的内存空间提供给用户线程使用。如果预留的空间无法满足程序分配新对象的需要，就会出现并发失败（Concurrent Mode Failure）就会冻结用户线程的执行，临时启用Serial Old收集器重新进行老年代的垃圾收集。\n3. 有大量的空间碎片。如果无法找到足够大的连续空间来分配给当前对象，则会提前触发一次Full GC。\n\n\n\n## Garbage First收集器\n\n1. 面向局部收集，基于Region内存布局\n2. JDK8后，被称为全功能的垃圾收集器。主要面向服务端。\n3. JDK9后完全取代了Parallel Scavenge加Parallel Old组合，成为服务端模式下默认垃圾收集器。\n4. 建立了停顿时间模型。即能够支持指定的一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒。\n5. 它可以面向堆内存的任何部分来组成回收集。衡量标准不再是属于哪个分代，而是哪块内存存放的垃圾数量最多，回收收益最大。即为Mixed GC模式。\n6. 把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region可以扮演Eden，Survivor或者老年代空间。对扮演不同角色的Region采取不同的策略进行处理。\n7. 还有专门存储大对象的Humongous区域。只要大于Region容量的一半即认为是大对象。而大于一个Region的大对象就会存放在N个连续的Humongous Region区域。将Humongous Region区域作为老年代的一部分看待。\n8. 将Region作为单位回收的最小单元，每次收集的内存空间是Region大小的整数倍。\n9. 按照各个Region垃圾堆积的价值大小，即回收所获得的空间大小和回收所需时间的经验值。在后台维护优先队列，根据用户运行的收集停顿时间，优先回收价值收益最大的Region。\n\n### 细节\n\n1. 跨Region引用对象的解决。每个Region都维护自己的记忆集。记录下别的Region指向自己的指针，并且标记这些指针分别在哪些卡页的范围内。记忆集为哈希表，key为别的Region的起始地址，value是卡表索引号的集合。大致需要10%-20%的Java堆内存维持收集器工作。\n2. 并发标记阶段采用原始快照保证收集线程与用户线程互不干扰的运行。因为程序继续运行会有新对象的创建。所以每个Region都设计了两个指针，划分出一块用于并发回收过程中新对象的分配。这个地址内的对象默认是存活的，不纳入回收范围。如果内存回收速度赶不上分配速度，则也会Full GC,STW\n3. 建立可靠的停顿预测模型。根据每个Region的回收耗时等信息分析得出平均值等统计信息。衰减平均值比普通的平均值更加容易受到新数据的影响，代表“最近的”平均状态。即Region的统计状态越新，越能决定其回收价值。通过这些信息进行预测，就能在不超过期望停顿时间的约束下获得最高的收益。\n\n### 实现步骤\n\n1. 初始标记。需要STW，仅仅标记一下GC Roots直接关联到的对象，并且修改TAMS指针,让下一阶段用户线程并发执行时,能正确的在可用Region中分配新对象.需要停顿线程,但耗时很短。\n2. 并发标记。从GC Roots直接关联到的对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程，可以并发执行。扫描结束后，还要重新处理原始快照记录下在并发有引用变动的对象。\n3. 最终标记。对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍然遗留下来的最后那少量的原始快照（SATB）记录。\n4. 筛选回收。根据Region的回收价值和成本进行排序，再根据用户所期望的停顿时间来制定回收计划。把决定回收的Region存活对象复制到空的Region，再清理掉整个旧Region的全部空间。必须暂停用户线程。\n\n### 其他\n\n目标是在延迟可控的情况下获得尽可能高的吞吐量。\n\n可以由用户指定期望的停顿时间\n\n停顿时间设置100-200ms之间会比较合适，太低则导致选出来的回收集只占堆内存很小一部分。\n\n追求能应付用于的内存分配速率，而不是追求一次把整个Java堆清理干净。\n\nG1整体是基于标记整理算法的，而局部即两个Region之间，则是基于标记复制算法的。使得不会产生内存碎片。\n\n### 相对于CMS的缺点\n\n1. 内存占用率高，因为卡表\n2. 对写屏障有复杂操作，不得不实现为类似消息队列的结构，先放到队列，再异步处理。\n3. 在小内存上CMS大概率优于G1平衡点大致是6-8GB内存\n\n# 低延迟垃圾回收器\n\n## 理论\n\n衡量垃圾收集器指标：内存占用，吞吐量，延迟。最多能同时达到其中两项\n\nCMS，G1分别采用增量更新，原始快照方式实现了标记阶段的并发，但是对于标记后的处理仍未得到妥善解决。\n\nShenandoah和ZGC几乎整个工作过程都是并发的，只有在初始标记，最终标记这些阶段有短暂的停顿。\n\n## ZGC收集器\n\n基于Region内存布局的，不设分代的，使用了读屏障，染色指针和内存多映射来实现的可并发的标记整理算法，以低延迟为首要目标的一款垃圾收集器。\n\n### 内存布局\n\nRegion具有动态性，动态创建和销毁，有动态的区域容量大小\n\n1. 小型Region：容量固定2MB\n2. 中型Region：容量固定32MB\n3. 大型Region：容量不固定，但是必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region只会存放一个大对象。\n\n### 染色指针技术\n\n把标记信息直接记录在引用对象的指针上。标志信息包括引用对象的三色标记状态，是否进入重分配集（即被移动过）等。\n\n优势：\n\n1. 一旦某个Region的存活对象被移走之后，该Region立即就能被释放和重用。\n2. 大幅度减少内存屏障的使用数量，只使用了读屏障。\n3. 可扩展，之后可以把指针前18位开发使用。\n\n### 运行流程\n\n分为4个大阶段，都可以并发执行，只在两个阶段中间会存在短暂的停顿小阶段\n\n#### 并发阶段。\n\n遍历对象图做可达性分析。标记只在染色指针上进行。\n\n#### 并发预备重分配。\n\n得出本次收集过程需要清理哪些Region，将他们组成重分配集。ZGC每次都会扫描所有的Region，换取G1中记忆集的维护成本。\n\n#### 并发重分配。\n\n1. 把重分配集中存活对象复制到新的Region中。并且为重分配集的每个Region维护转发表，记录从旧对象到新对象的转向关系。\n2. 仅从引用就明确得知一个对象是否处于重分配集中。\n3. 自愈能力：在ZGC中，当读取处于重分配集的对象时，会被读屏障拦截，通过转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。只慢一次。\n\n#### 并发重映射\n\n修正整个堆中指向重分配集中旧对象的所有引用。不是迫切任务，因为可以旧引用通过自愈，最多是第一次比较慢。\n\n\n\n### 特点\n\n能承受的对象分配速率不会太高。\n\n支持“NUMA-Aware”（非统一的内存访问架构。为多处理器计算机所设计的内存架构）的内存分配。\n\n令人震惊的，革命性的ZGC  \n\n\n\n\n\n## Epsilon收集器\n\n不能够进行垃圾收集，无操作的垃圾收集器。对于微服务等，只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出，那么运行负载极小，没有任何回收行为的Epsilon是恰当的选择。\n\n# 内存分配与回收策略\n\n## 目标\n\n自动给对象分配内存\n\n自动回收分配给对象的内存\n\n## 策略\n\n1. 对象内存分配应该都是堆上分配(但也有可能栈上分配)\n2. 新生对象通常分配在新生代中,少数情况(如对象大小超过一定阈值)可能直接分配到老年代\n\n### 对象优先分配Eden区域\n\n1. 大多数情况下在Eden区分配\n2. 新生代总可用空间为Eden区+1个Survivor区的总容量\n3. 当Eden没有足够的空间时发生一次Minor GC,如果对象放不进Survivor区,则通过分配担保机制提前把这些对象转移到老年代\n\n### 大对象直接进入老年代\n\n大对象需要大量连续的内存空间，例如很长的字符串,很长的数组。\n\n容易导致提前垃圾收集，以获取足够的连续空间安置大对象\n\n大对象直接在老年代分配，以避免在Eden与Survivor区来回复制，付出高额内存复制开销\n\n### 长期存活对象进入老年代\n\n每个对象头有对象年龄计数器。如果经过一次MinorGC仍然存活，并且能被Survivor容纳，则计数器+1，当到15时，则晋身为老年代。\n\n### 动态对象年龄判断\n\n如果Survivor区中相同年龄所有对象的总和大于Survivor区的一半，那么年龄大于等于该年龄‘的对象直接进入老年代\n\n### 空间分配担保\n\n在Minor GC前，检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果成立，则这次Minor GC安全。负责要看是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的平均大小，如果小于，或者不允许担保，则Full GC。\n\n新生代中，把Survivor无法容纳的对象直接送入老年代，担保前提是老年代本身有容纳这些对象的剩余空间。\n\n在JDK7及之后。不能设置参数影响空间分配担保策略。只要老年代最大可用连续空间大于新生代的所有对象空间，或者大于历次晋升到老年代的平均大小，就进行Minor GC，负责Full GC","slug":"JVM笔记/第3章","published":1,"updated":"2020-11-12T11:57:29.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6vt000fjotp6b6cg8v2","content":"<h1 id=\"垃圾标记算法\"><a href=\"#垃圾标记算法\" class=\"headerlink\" title=\"垃圾标记算法\"></a>垃圾标记算法</h1><h2 id=\"引用计数算法\"><a href=\"#引用计数算法\" class=\"headerlink\" title=\"引用计数算法\"></a>引用计数算法</h2><p>缺点在于两个对象互相引用,但是又不可被访问时,引用计数不为0,无法被回收</p>\n<p>Java虚拟机没有采用这种算法</p>\n<h2 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h2><p>通过GC Roots根对象作为起始节点集,引用链搜索.</p>\n<p>如果对象到GC Roots不可达,则不可能再被使用</p>\n<h3 id=\"可作为GC-Roots的对象\"><a href=\"#可作为GC-Roots的对象\" class=\"headerlink\" title=\"可作为GC Roots的对象\"></a>可作为GC Roots的对象</h3><ol>\n<li>虚拟机栈中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象,例如字符串常量池里的引用</li>\n<li>Native方法引用的对象</li>\n<li>Java虚拟机内部的引用</li>\n<li>被synchronized持有的对象</li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>最传统的引用,形如:<code>Object obj=new Object()</code></p>\n<p>只要强引用关系还存在,则永远不会回收掉被引用的对象</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>描述一些还有用,但是非必须的对象。在系统将要发生内存溢出异常前，会把这些对象列入回收范围内进行二次回收。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>也是描述一些还有用,但是非必须的对象。比软引用更弱，只能生存到下一次垃圾收集发生为止。垃圾收集器工作时，不管内存是否充足，都会回收掉弱引用关联的对象</p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>无法通过虚引用得到一个对象实例。设置虚引用关联的唯一目的是能在这个对象被收集器回收时收到一个系统通知</p>\n<h2 id=\"不可达对象的回收过程\"><a href=\"#不可达对象的回收过程\" class=\"headerlink\" title=\"不可达对象的回收过程\"></a>不可达对象的回收过程</h2><ol>\n<li>进行可达性分析后，发现没有于GC Roots相连接的引用链，进行第一次标记</li>\n<li>随后查看是否有必要执行finalize（）方法，如果没有重写它，或者已经被调用过，则没有必要执行，则回收</li>\n<li>如果有必要执行，则放置在F-Queue队列中</li>\n<li>finalize方法是对象最后的逃脱机会，如果它在finalize方法中重新与引用链上任何一个对象建立关联，则不会被回收。如果还没逃脱，则被回收了。</li>\n<li>任何一个对象finalize方法只会被执行一次<br>尽量避免使用finalize（）方法<h2 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h2></li>\n<li>主要回收废弃的常量和不再使用的类型</li>\n<li>回收类型很苛刻，得同时满足三个条件：该类所有实例被回收，加载该类的类加载器被回收，该类对应的Class对象没有被引用</li>\n<li>在框架等自定义类加载器的场景中，通常需要虚拟机具有类型卸载的能力</li>\n</ol>\n<h1 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h1><h2 id=\"分代收集理论\"><a href=\"#分代收集理论\" class=\"headerlink\" title=\"分代收集理论\"></a>分代收集理论</h2><ol>\n<li>根据弱分代假说，强分代假说。分为新生代，老年代</li>\n<li>跨代引用假说：跨带引用相对于同代引用占比很小。所以在新生代建立全局的数据结构（记忆集），标识出老年代哪一块内存会存在跨带引用。之后的Minor GC中，只有包含在记忆集的对象才会加入GC Roots中进行扫描</li>\n<li>Minor GC/Young GC 目标只是新生代的垃圾收集</li>\n<li>Major GC/Old GC 目标只是老年代的垃圾收集，只有CMS收集器有</li>\n<li>Full GC 收集整个Java堆和方法区的垃圾收集<h2 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h2>先标记所有要回收的对象，标记完成后统一回收所有被标记对象<br>缺点：<ol>\n<li>执行效率不稳定，随对象数量的增长而下降</li>\n<li>存在内存空间碎片化的问题</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"标记复制算法\"><a href=\"#标记复制算法\" class=\"headerlink\" title=\"标记复制算法\"></a>标记复制算法</h2><h3 id=\"半区复制\"><a href=\"#半区复制\" class=\"headerlink\" title=\"半区复制\"></a>半区复制</h3><p>将内存容量划分成大小相等的两块，每次只使用其中一块。当其中一块用完后，把还存活的对象复制到另一块，再把已经使用的清空。<br>实现简单，运行高效，但是可用内存缩小为原来的一半。</p>\n<h3 id=\"优化后的半区复制\"><a href=\"#优化后的半区复制\" class=\"headerlink\" title=\"优化后的半区复制\"></a>优化后的半区复制</h3><ol>\n<li>把新生代分为Eden，Survivor1，Survivor2区，空间为8：1：1</li>\n<li>每次只使用Eden区和其中一块Survivor区</li>\n<li>发生垃圾回收时，将Eden区和使用的Survivor区仍然存活的对象复制到另一块Survivor区，清空Eden区和之前使用的Survivor区</li>\n<li>如果另一块Survivor区没有足够的空间存放存活对象，这些对象可以通过担保机制直接进入老年代</li>\n</ol>\n<h2 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h2><ol>\n<li>针对老年代的算法</li>\n<li>先标记,再让所有存活的对象都向内存空间的一端移动,然后直接清理掉边界以外的内存</li>\n<li>是移动式算法,负载较重,需要全程暂停用户应用程序,即Stop The World.但优点是不会产生碎片.总的来说提高了吞吐量.因为HotShot虚拟机关注吞吐量,所以采用了标记整理.</li>\n</ol>\n<h1 id=\"HotSpot虚拟机细节\"><a href=\"#HotSpot虚拟机细节\" class=\"headerlink\" title=\"HotSpot虚拟机细节\"></a>HotSpot虚拟机细节</h1><h2 id=\"根节点枚举\"><a href=\"#根节点枚举\" class=\"headerlink\" title=\"根节点枚举\"></a>根节点枚举</h2><ol>\n<li>固定可作为GC Roots的主要是:1.全局性引用(常量和类静态属性)2.执行上下文(栈帧中的本地变量表)</li>\n<li>根节点枚举必须STW,因为它必须要再一个能保障一致性的快照上才得以进行</li>\n<li>通过OopMap直接得到哪个地方存放着对象引用.不需要一个不漏的检查所有执行上下文和全局的引用位置</li>\n</ol>\n<h2 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h2><ol>\n<li>只有在特定的位置才记录下OopMap信息,即安全点</li>\n<li>用户进程必须执行到安全点才能够暂停</li>\n<li>安全点位置选取以”是否具有让程序长时间执行的特征”为标准,最明显的特征就是有指令序列的复用</li>\n<li>还需要在垃圾收集发生时让所有线程都跑到最近的安全点,然后停顿下来</li>\n</ol>\n<h3 id=\"抢先式中断\"><a href=\"#抢先式中断\" class=\"headerlink\" title=\"抢先式中断\"></a>抢先式中断</h3><p>当垃圾收集时,把所有线程中断,再让不在安全点的继续跑到安全点</p>\n<p>没有虚拟机采用</p>\n<h3 id=\"主动式中断\"><a href=\"#主动式中断\" class=\"headerlink\" title=\"主动式中断\"></a>主动式中断</h3><p>简单设置标志位,每个线程执行时不断轮询它,一旦中断标志位为真,则自己在最近的安全点主动中断挂起。</p>\n<p>轮询操作精简到只有一条汇编指令–完成安全点轮询和触发线程中断</p>\n<h2 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h2><ol>\n<li>处于Sleep或Block状态的用户线程无法响应虚拟机的中断请求，不能走到安全的地方去中断挂起自己。</li>\n<li>所以安全区域确保在某一段代码中，引用关系不会发生改变，在这个区域内进行垃圾收集是安全的。可以把安全区域看作是被扩展拉伸的安全点</li>\n<li>用户线程到了安全区域，会标识已经进入安全区域。而要离开时，如果虚拟机已经完成了根节点枚举，则继续执行，否则要一直等待直到收到可以离开安全区的信息</li>\n</ol>\n<h2 id=\"记忆集和卡表\"><a href=\"#记忆集和卡表\" class=\"headerlink\" title=\"记忆集和卡表\"></a>记忆集和卡表</h2><ol>\n<li>记忆集是用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</li>\n<li>收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可</li>\n<li>所以可以采用更粗的记录粒度来节省记忆集的开销。</li>\n<li>目前最常采用的是卡表，卡表是记忆集的具体实现。卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨带指针。</li>\n<li>卡表最简单是实现是字节数组，每一个元素都对应着其标识的内存区域中一块特定大小的内存块，即卡页。大小为2的9次方，512字节。</li>\n<li>一个卡页通常不止一个对象。只要卡也中其中一个对象存在了跨代指针，就标识为1，即变脏。</li>\n<li>垃圾收集时，就把卡表中变脏的元素对应的内存块加入GC Roots中一并扫描</li>\n</ol>\n<h2 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h2><ol>\n<li>有其他分代区域中对象引用了本区域对象时,对应的卡表元素应该变脏.时间点应该发生在引用类型字段赋值的那一刻。</li>\n<li>HotSpot虚拟机通过写屏障技术维护卡表状态,是在虚拟机层面上对”引用类型字段赋值”这个动作的AOP切面,即在引用对象赋值时会产生一个环绕通知,供程序执行额外操作。</li>\n<li>应用写屏障后，虚拟机会为所有赋值操作生成相应的指令。每次对引用进行更新，就会产生额外的开销。</li>\n<li>卡表在高并发场景下的“伪共享”问题：缓存系统以缓存行为单位存储，当多线程互相修改独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响而导致性能下降。</li>\n<li>为避免伪共享问题，可以先检查卡带标记，只有当该卡表元素未被标记过时才将其标记为变脏。</li>\n</ol>\n<h2 id=\"并发的可达性分析\"><a href=\"#并发的可达性分析\" class=\"headerlink\" title=\"并发的可达性分析\"></a>并发的可达性分析</h2><ol>\n<li>可达性分析算法理论上要求全过程都STW。在根节点枚举过程中，通过OopMap技术，停顿时间已经比较短暂了。但是从GC Roots遍历图花费的时间与堆容量成正比，所以需要优化。</li>\n<li>如果用户线程与收集器并发工作。收集器在对象图上标记颜色，同时用户线程在修改引用关系，即修改对象图的结构。会产生两种后果：1.把原本消亡的对象标记为存活，这可以容忍 2.把存活对象标记为消亡，则肯定会出错</li>\n</ol>\n<h3 id=\"对象消失\"><a href=\"#对象消失\" class=\"headerlink\" title=\"对象消失\"></a>对象消失</h3><p>即原本是黑色的对象被误标记为白色，需要下述条件同时满足：</p>\n<ol>\n<li>新增了黑色到白色对象的新引用。</li>\n<li>删除了灰色到该白色对象的所有引用</li>\n</ol>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>破坏两个条件之一即可。都是通过写屏障实现</p>\n<ol>\n<li>增量更新。理解为当黑色对象一旦插入了指向白色对象的引用后，它就变回灰色对象。</li>\n<li>原始快照。无论引用对象删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。</li>\n</ol>\n<h1 id=\"经典垃圾收集器\"><a href=\"#经典垃圾收集器\" class=\"headerlink\" title=\"经典垃圾收集器\"></a>经典垃圾收集器</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>如果两个收集器之间存在连线，则可以搭配使用</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/abcd.png\" alt=\"abcd\"></p>\n<h2 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h2><ol>\n<li>单线程新生代收集器，必须STW</li>\n<li>是客户端模式下默认的新生代收集器，简单而高效</li>\n<li>对于内存资源受限，单核处理器或处理器核心数较少的环境表现良好</li>\n</ol>\n<h2 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h2><ol>\n<li>是Serial收集器的并行版本，其他与Serial大致相同</li>\n<li>JDK9后，ParNew与CMS只能互相搭配使用</li>\n<li>在单核心处理器不会有比Serial更好的效果</li>\n</ol>\n<h2 id=\"Parallel-Scavenge\"><a href=\"#Parallel-Scavenge\" class=\"headerlink\" title=\"Parallel Scavenge\"></a>Parallel Scavenge</h2><ol>\n<li>同样是基于标记-复制算法，并行收集的多线程收集器。被认为是吞吐量优先收集器。</li>\n<li>目标是达到一个可控制的吞吐量，即运行用户代码的时间/（运行用户代码的时间+运行垃圾收集时间）</li>\n<li>停顿时间短适合用户交互，高吞吐量适用于后台运算，能最高效率的利用处理器资源，尽快完成任务。</li>\n<li>-XX:MaxGCPauseMillis控制最大垃圾收集停顿时间。设置吞吐量大小：-XX:GCTimeRatio</li>\n<li>-XX:+UseAdaptiveSizePolicy 根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量。自适应的调节策略。</li>\n</ol>\n<h2 id=\"Serial-Old收集器\"><a href=\"#Serial-Old收集器\" class=\"headerlink\" title=\"Serial Old收集器\"></a>Serial Old收集器</h2><p>单线程收集器，使用标记整理算法，供客户端模式使用的。</p>\n<h2 id=\"Parallel-Old收集器\"><a href=\"#Parallel-Old收集器\" class=\"headerlink\" title=\"Parallel Old收集器\"></a>Parallel Old收集器</h2><p>支持多线程并发收集。</p>\n<p>“吞吐量优先”收集器搭配组合：Parallel Scavenge与Parallel Old</p>\n<h2 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h2><ol>\n<li>并发收集，低停顿，以获取最短回收停顿时间为目标</li>\n<li>基于标记-清除算法</li>\n</ol>\n<h3 id=\"四个阶段\"><a href=\"#四个阶段\" class=\"headerlink\" title=\"四个阶段\"></a>四个阶段</h3><ol>\n<li>初始标记。需要STW，仅仅标记一下GC Roots直接关联到的对象，速度很快。</li>\n<li>并发标记。从GC Roots直接关联到的对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程，可以并发执行。</li>\n<li>重新标记。修改并发标记期间，因用户线程继续运行而导致的标记发生变动的那一部分对象的标记记录。参考之前的增量更新。需要STW，但是时间仍然比较短。</li>\n<li>并发清除。删除掉标记阶段判断为已经死亡的对象，不需要移动对象，所以可以和用户线程并发执行。</li>\n</ol>\n<h3 id=\"三个问题\"><a href=\"#三个问题\" class=\"headerlink\" title=\"三个问题\"></a>三个问题</h3><ol>\n<li>对处理器资源敏感。即在并发阶段，虽然不会导致用户线程停顿，但因为占用一部分线程，而导致应用程序变慢，降低总吞吐量。</li>\n<li>无法处理浮动垃圾。可能因失败而导致另一次完全的STW的Full GC产生。浮动垃圾即用户线程在并发执行时还会伴随着新的垃圾对象不断产生，但CMS无法在当次收集中处理他们。而且用户线程持续运行，就需要预留足够的内存空间提供给用户线程使用。如果预留的空间无法满足程序分配新对象的需要，就会出现并发失败（Concurrent Mode Failure）就会冻结用户线程的执行，临时启用Serial Old收集器重新进行老年代的垃圾收集。</li>\n<li>有大量的空间碎片。如果无法找到足够大的连续空间来分配给当前对象，则会提前触发一次Full GC。</li>\n</ol>\n<h2 id=\"Garbage-First收集器\"><a href=\"#Garbage-First收集器\" class=\"headerlink\" title=\"Garbage First收集器\"></a>Garbage First收集器</h2><ol>\n<li>面向局部收集，基于Region内存布局</li>\n<li>JDK8后，被称为全功能的垃圾收集器。主要面向服务端。</li>\n<li>JDK9后完全取代了Parallel Scavenge加Parallel Old组合，成为服务端模式下默认垃圾收集器。</li>\n<li>建立了停顿时间模型。即能够支持指定的一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒。</li>\n<li>它可以面向堆内存的任何部分来组成回收集。衡量标准不再是属于哪个分代，而是哪块内存存放的垃圾数量最多，回收收益最大。即为Mixed GC模式。</li>\n<li>把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region可以扮演Eden，Survivor或者老年代空间。对扮演不同角色的Region采取不同的策略进行处理。</li>\n<li>还有专门存储大对象的Humongous区域。只要大于Region容量的一半即认为是大对象。而大于一个Region的大对象就会存放在N个连续的Humongous Region区域。将Humongous Region区域作为老年代的一部分看待。</li>\n<li>将Region作为单位回收的最小单元，每次收集的内存空间是Region大小的整数倍。</li>\n<li>按照各个Region垃圾堆积的价值大小，即回收所获得的空间大小和回收所需时间的经验值。在后台维护优先队列，根据用户运行的收集停顿时间，优先回收价值收益最大的Region。</li>\n</ol>\n<h3 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h3><ol>\n<li>跨Region引用对象的解决。每个Region都维护自己的记忆集。记录下别的Region指向自己的指针，并且标记这些指针分别在哪些卡页的范围内。记忆集为哈希表，key为别的Region的起始地址，value是卡表索引号的集合。大致需要10%-20%的Java堆内存维持收集器工作。</li>\n<li>并发标记阶段采用原始快照保证收集线程与用户线程互不干扰的运行。因为程序继续运行会有新对象的创建。所以每个Region都设计了两个指针，划分出一块用于并发回收过程中新对象的分配。这个地址内的对象默认是存活的，不纳入回收范围。如果内存回收速度赶不上分配速度，则也会Full GC,STW</li>\n<li>建立可靠的停顿预测模型。根据每个Region的回收耗时等信息分析得出平均值等统计信息。衰减平均值比普通的平均值更加容易受到新数据的影响，代表“最近的”平均状态。即Region的统计状态越新，越能决定其回收价值。通过这些信息进行预测，就能在不超过期望停顿时间的约束下获得最高的收益。</li>\n</ol>\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><ol>\n<li>初始标记。需要STW，仅仅标记一下GC Roots直接关联到的对象，并且修改TAMS指针,让下一阶段用户线程并发执行时,能正确的在可用Region中分配新对象.需要停顿线程,但耗时很短。</li>\n<li>并发标记。从GC Roots直接关联到的对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程，可以并发执行。扫描结束后，还要重新处理原始快照记录下在并发有引用变动的对象。</li>\n<li>最终标记。对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍然遗留下来的最后那少量的原始快照（SATB）记录。</li>\n<li>筛选回收。根据Region的回收价值和成本进行排序，再根据用户所期望的停顿时间来制定回收计划。把决定回收的Region存活对象复制到空的Region，再清理掉整个旧Region的全部空间。必须暂停用户线程。</li>\n</ol>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>目标是在延迟可控的情况下获得尽可能高的吞吐量。</p>\n<p>可以由用户指定期望的停顿时间</p>\n<p>停顿时间设置100-200ms之间会比较合适，太低则导致选出来的回收集只占堆内存很小一部分。</p>\n<p>追求能应付用于的内存分配速率，而不是追求一次把整个Java堆清理干净。</p>\n<p>G1整体是基于标记整理算法的，而局部即两个Region之间，则是基于标记复制算法的。使得不会产生内存碎片。</p>\n<h3 id=\"相对于CMS的缺点\"><a href=\"#相对于CMS的缺点\" class=\"headerlink\" title=\"相对于CMS的缺点\"></a>相对于CMS的缺点</h3><ol>\n<li>内存占用率高，因为卡表</li>\n<li>对写屏障有复杂操作，不得不实现为类似消息队列的结构，先放到队列，再异步处理。</li>\n<li>在小内存上CMS大概率优于G1平衡点大致是6-8GB内存</li>\n</ol>\n<h1 id=\"低延迟垃圾回收器\"><a href=\"#低延迟垃圾回收器\" class=\"headerlink\" title=\"低延迟垃圾回收器\"></a>低延迟垃圾回收器</h1><h2 id=\"理论\"><a href=\"#理论\" class=\"headerlink\" title=\"理论\"></a>理论</h2><p>衡量垃圾收集器指标：内存占用，吞吐量，延迟。最多能同时达到其中两项</p>\n<p>CMS，G1分别采用增量更新，原始快照方式实现了标记阶段的并发，但是对于标记后的处理仍未得到妥善解决。</p>\n<p>Shenandoah和ZGC几乎整个工作过程都是并发的，只有在初始标记，最终标记这些阶段有短暂的停顿。</p>\n<h2 id=\"ZGC收集器\"><a href=\"#ZGC收集器\" class=\"headerlink\" title=\"ZGC收集器\"></a>ZGC收集器</h2><p>基于Region内存布局的，不设分代的，使用了读屏障，染色指针和内存多映射来实现的可并发的标记整理算法，以低延迟为首要目标的一款垃圾收集器。</p>\n<h3 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h3><p>Region具有动态性，动态创建和销毁，有动态的区域容量大小</p>\n<ol>\n<li>小型Region：容量固定2MB</li>\n<li>中型Region：容量固定32MB</li>\n<li>大型Region：容量不固定，但是必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region只会存放一个大对象。</li>\n</ol>\n<h3 id=\"染色指针技术\"><a href=\"#染色指针技术\" class=\"headerlink\" title=\"染色指针技术\"></a>染色指针技术</h3><p>把标记信息直接记录在引用对象的指针上。标志信息包括引用对象的三色标记状态，是否进入重分配集（即被移动过）等。</p>\n<p>优势：</p>\n<ol>\n<li>一旦某个Region的存活对象被移走之后，该Region立即就能被释放和重用。</li>\n<li>大幅度减少内存屏障的使用数量，只使用了读屏障。</li>\n<li>可扩展，之后可以把指针前18位开发使用。</li>\n</ol>\n<h3 id=\"运行流程\"><a href=\"#运行流程\" class=\"headerlink\" title=\"运行流程\"></a>运行流程</h3><p>分为4个大阶段，都可以并发执行，只在两个阶段中间会存在短暂的停顿小阶段</p>\n<h4 id=\"并发阶段。\"><a href=\"#并发阶段。\" class=\"headerlink\" title=\"并发阶段。\"></a>并发阶段。</h4><p>遍历对象图做可达性分析。标记只在染色指针上进行。</p>\n<h4 id=\"并发预备重分配。\"><a href=\"#并发预备重分配。\" class=\"headerlink\" title=\"并发预备重分配。\"></a>并发预备重分配。</h4><p>得出本次收集过程需要清理哪些Region，将他们组成重分配集。ZGC每次都会扫描所有的Region，换取G1中记忆集的维护成本。</p>\n<h4 id=\"并发重分配。\"><a href=\"#并发重分配。\" class=\"headerlink\" title=\"并发重分配。\"></a>并发重分配。</h4><ol>\n<li>把重分配集中存活对象复制到新的Region中。并且为重分配集的每个Region维护转发表，记录从旧对象到新对象的转向关系。</li>\n<li>仅从引用就明确得知一个对象是否处于重分配集中。</li>\n<li>自愈能力：在ZGC中，当读取处于重分配集的对象时，会被读屏障拦截，通过转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。只慢一次。</li>\n</ol>\n<h4 id=\"并发重映射\"><a href=\"#并发重映射\" class=\"headerlink\" title=\"并发重映射\"></a>并发重映射</h4><p>修正整个堆中指向重分配集中旧对象的所有引用。不是迫切任务，因为可以旧引用通过自愈，最多是第一次比较慢。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>能承受的对象分配速率不会太高。</p>\n<p>支持“NUMA-Aware”（非统一的内存访问架构。为多处理器计算机所设计的内存架构）的内存分配。</p>\n<p>令人震惊的，革命性的ZGC  </p>\n<h2 id=\"Epsilon收集器\"><a href=\"#Epsilon收集器\" class=\"headerlink\" title=\"Epsilon收集器\"></a>Epsilon收集器</h2><p>不能够进行垃圾收集，无操作的垃圾收集器。对于微服务等，只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出，那么运行负载极小，没有任何回收行为的Epsilon是恰当的选择。</p>\n<h1 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>自动给对象分配内存</p>\n<p>自动回收分配给对象的内存</p>\n<h2 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h2><ol>\n<li>对象内存分配应该都是堆上分配(但也有可能栈上分配)</li>\n<li>新生对象通常分配在新生代中,少数情况(如对象大小超过一定阈值)可能直接分配到老年代</li>\n</ol>\n<h3 id=\"对象优先分配Eden区域\"><a href=\"#对象优先分配Eden区域\" class=\"headerlink\" title=\"对象优先分配Eden区域\"></a>对象优先分配Eden区域</h3><ol>\n<li>大多数情况下在Eden区分配</li>\n<li>新生代总可用空间为Eden区+1个Survivor区的总容量</li>\n<li>当Eden没有足够的空间时发生一次Minor GC,如果对象放不进Survivor区,则通过分配担保机制提前把这些对象转移到老年代</li>\n</ol>\n<h3 id=\"大对象直接进入老年代\"><a href=\"#大对象直接进入老年代\" class=\"headerlink\" title=\"大对象直接进入老年代\"></a>大对象直接进入老年代</h3><p>大对象需要大量连续的内存空间，例如很长的字符串,很长的数组。</p>\n<p>容易导致提前垃圾收集，以获取足够的连续空间安置大对象</p>\n<p>大对象直接在老年代分配，以避免在Eden与Survivor区来回复制，付出高额内存复制开销</p>\n<h3 id=\"长期存活对象进入老年代\"><a href=\"#长期存活对象进入老年代\" class=\"headerlink\" title=\"长期存活对象进入老年代\"></a>长期存活对象进入老年代</h3><p>每个对象头有对象年龄计数器。如果经过一次MinorGC仍然存活，并且能被Survivor容纳，则计数器+1，当到15时，则晋身为老年代。</p>\n<h3 id=\"动态对象年龄判断\"><a href=\"#动态对象年龄判断\" class=\"headerlink\" title=\"动态对象年龄判断\"></a>动态对象年龄判断</h3><p>如果Survivor区中相同年龄所有对象的总和大于Survivor区的一半，那么年龄大于等于该年龄‘的对象直接进入老年代</p>\n<h3 id=\"空间分配担保\"><a href=\"#空间分配担保\" class=\"headerlink\" title=\"空间分配担保\"></a>空间分配担保</h3><p>在Minor GC前，检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果成立，则这次Minor GC安全。负责要看是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的平均大小，如果小于，或者不允许担保，则Full GC。</p>\n<p>新生代中，把Survivor无法容纳的对象直接送入老年代，担保前提是老年代本身有容纳这些对象的剩余空间。</p>\n<p>在JDK7及之后。不能设置参数影响空间分配担保策略。只要老年代最大可用连续空间大于新生代的所有对象空间，或者大于历次晋升到老年代的平均大小，就进行Minor GC，负责Full GC</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"垃圾标记算法\"><a href=\"#垃圾标记算法\" class=\"headerlink\" title=\"垃圾标记算法\"></a>垃圾标记算法</h1><h2 id=\"引用计数算法\"><a href=\"#引用计数算法\" class=\"headerlink\" title=\"引用计数算法\"></a>引用计数算法</h2><p>缺点在于两个对象互相引用,但是又不可被访问时,引用计数不为0,无法被回收</p>\n<p>Java虚拟机没有采用这种算法</p>\n<h2 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h2><p>通过GC Roots根对象作为起始节点集,引用链搜索.</p>\n<p>如果对象到GC Roots不可达,则不可能再被使用</p>\n<h3 id=\"可作为GC-Roots的对象\"><a href=\"#可作为GC-Roots的对象\" class=\"headerlink\" title=\"可作为GC Roots的对象\"></a>可作为GC Roots的对象</h3><ol>\n<li>虚拟机栈中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象,例如字符串常量池里的引用</li>\n<li>Native方法引用的对象</li>\n<li>Java虚拟机内部的引用</li>\n<li>被synchronized持有的对象</li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>最传统的引用,形如:<code>Object obj=new Object()</code></p>\n<p>只要强引用关系还存在,则永远不会回收掉被引用的对象</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>描述一些还有用,但是非必须的对象。在系统将要发生内存溢出异常前，会把这些对象列入回收范围内进行二次回收。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>也是描述一些还有用,但是非必须的对象。比软引用更弱，只能生存到下一次垃圾收集发生为止。垃圾收集器工作时，不管内存是否充足，都会回收掉弱引用关联的对象</p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>无法通过虚引用得到一个对象实例。设置虚引用关联的唯一目的是能在这个对象被收集器回收时收到一个系统通知</p>\n<h2 id=\"不可达对象的回收过程\"><a href=\"#不可达对象的回收过程\" class=\"headerlink\" title=\"不可达对象的回收过程\"></a>不可达对象的回收过程</h2><ol>\n<li>进行可达性分析后，发现没有于GC Roots相连接的引用链，进行第一次标记</li>\n<li>随后查看是否有必要执行finalize（）方法，如果没有重写它，或者已经被调用过，则没有必要执行，则回收</li>\n<li>如果有必要执行，则放置在F-Queue队列中</li>\n<li>finalize方法是对象最后的逃脱机会，如果它在finalize方法中重新与引用链上任何一个对象建立关联，则不会被回收。如果还没逃脱，则被回收了。</li>\n<li>任何一个对象finalize方法只会被执行一次<br>尽量避免使用finalize（）方法<h2 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h2></li>\n<li>主要回收废弃的常量和不再使用的类型</li>\n<li>回收类型很苛刻，得同时满足三个条件：该类所有实例被回收，加载该类的类加载器被回收，该类对应的Class对象没有被引用</li>\n<li>在框架等自定义类加载器的场景中，通常需要虚拟机具有类型卸载的能力</li>\n</ol>\n<h1 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h1><h2 id=\"分代收集理论\"><a href=\"#分代收集理论\" class=\"headerlink\" title=\"分代收集理论\"></a>分代收集理论</h2><ol>\n<li>根据弱分代假说，强分代假说。分为新生代，老年代</li>\n<li>跨代引用假说：跨带引用相对于同代引用占比很小。所以在新生代建立全局的数据结构（记忆集），标识出老年代哪一块内存会存在跨带引用。之后的Minor GC中，只有包含在记忆集的对象才会加入GC Roots中进行扫描</li>\n<li>Minor GC/Young GC 目标只是新生代的垃圾收集</li>\n<li>Major GC/Old GC 目标只是老年代的垃圾收集，只有CMS收集器有</li>\n<li>Full GC 收集整个Java堆和方法区的垃圾收集<h2 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h2>先标记所有要回收的对象，标记完成后统一回收所有被标记对象<br>缺点：<ol>\n<li>执行效率不稳定，随对象数量的增长而下降</li>\n<li>存在内存空间碎片化的问题</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"标记复制算法\"><a href=\"#标记复制算法\" class=\"headerlink\" title=\"标记复制算法\"></a>标记复制算法</h2><h3 id=\"半区复制\"><a href=\"#半区复制\" class=\"headerlink\" title=\"半区复制\"></a>半区复制</h3><p>将内存容量划分成大小相等的两块，每次只使用其中一块。当其中一块用完后，把还存活的对象复制到另一块，再把已经使用的清空。<br>实现简单，运行高效，但是可用内存缩小为原来的一半。</p>\n<h3 id=\"优化后的半区复制\"><a href=\"#优化后的半区复制\" class=\"headerlink\" title=\"优化后的半区复制\"></a>优化后的半区复制</h3><ol>\n<li>把新生代分为Eden，Survivor1，Survivor2区，空间为8：1：1</li>\n<li>每次只使用Eden区和其中一块Survivor区</li>\n<li>发生垃圾回收时，将Eden区和使用的Survivor区仍然存活的对象复制到另一块Survivor区，清空Eden区和之前使用的Survivor区</li>\n<li>如果另一块Survivor区没有足够的空间存放存活对象，这些对象可以通过担保机制直接进入老年代</li>\n</ol>\n<h2 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h2><ol>\n<li>针对老年代的算法</li>\n<li>先标记,再让所有存活的对象都向内存空间的一端移动,然后直接清理掉边界以外的内存</li>\n<li>是移动式算法,负载较重,需要全程暂停用户应用程序,即Stop The World.但优点是不会产生碎片.总的来说提高了吞吐量.因为HotShot虚拟机关注吞吐量,所以采用了标记整理.</li>\n</ol>\n<h1 id=\"HotSpot虚拟机细节\"><a href=\"#HotSpot虚拟机细节\" class=\"headerlink\" title=\"HotSpot虚拟机细节\"></a>HotSpot虚拟机细节</h1><h2 id=\"根节点枚举\"><a href=\"#根节点枚举\" class=\"headerlink\" title=\"根节点枚举\"></a>根节点枚举</h2><ol>\n<li>固定可作为GC Roots的主要是:1.全局性引用(常量和类静态属性)2.执行上下文(栈帧中的本地变量表)</li>\n<li>根节点枚举必须STW,因为它必须要再一个能保障一致性的快照上才得以进行</li>\n<li>通过OopMap直接得到哪个地方存放着对象引用.不需要一个不漏的检查所有执行上下文和全局的引用位置</li>\n</ol>\n<h2 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h2><ol>\n<li>只有在特定的位置才记录下OopMap信息,即安全点</li>\n<li>用户进程必须执行到安全点才能够暂停</li>\n<li>安全点位置选取以”是否具有让程序长时间执行的特征”为标准,最明显的特征就是有指令序列的复用</li>\n<li>还需要在垃圾收集发生时让所有线程都跑到最近的安全点,然后停顿下来</li>\n</ol>\n<h3 id=\"抢先式中断\"><a href=\"#抢先式中断\" class=\"headerlink\" title=\"抢先式中断\"></a>抢先式中断</h3><p>当垃圾收集时,把所有线程中断,再让不在安全点的继续跑到安全点</p>\n<p>没有虚拟机采用</p>\n<h3 id=\"主动式中断\"><a href=\"#主动式中断\" class=\"headerlink\" title=\"主动式中断\"></a>主动式中断</h3><p>简单设置标志位,每个线程执行时不断轮询它,一旦中断标志位为真,则自己在最近的安全点主动中断挂起。</p>\n<p>轮询操作精简到只有一条汇编指令–完成安全点轮询和触发线程中断</p>\n<h2 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h2><ol>\n<li>处于Sleep或Block状态的用户线程无法响应虚拟机的中断请求，不能走到安全的地方去中断挂起自己。</li>\n<li>所以安全区域确保在某一段代码中，引用关系不会发生改变，在这个区域内进行垃圾收集是安全的。可以把安全区域看作是被扩展拉伸的安全点</li>\n<li>用户线程到了安全区域，会标识已经进入安全区域。而要离开时，如果虚拟机已经完成了根节点枚举，则继续执行，否则要一直等待直到收到可以离开安全区的信息</li>\n</ol>\n<h2 id=\"记忆集和卡表\"><a href=\"#记忆集和卡表\" class=\"headerlink\" title=\"记忆集和卡表\"></a>记忆集和卡表</h2><ol>\n<li>记忆集是用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</li>\n<li>收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可</li>\n<li>所以可以采用更粗的记录粒度来节省记忆集的开销。</li>\n<li>目前最常采用的是卡表，卡表是记忆集的具体实现。卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨带指针。</li>\n<li>卡表最简单是实现是字节数组，每一个元素都对应着其标识的内存区域中一块特定大小的内存块，即卡页。大小为2的9次方，512字节。</li>\n<li>一个卡页通常不止一个对象。只要卡也中其中一个对象存在了跨代指针，就标识为1，即变脏。</li>\n<li>垃圾收集时，就把卡表中变脏的元素对应的内存块加入GC Roots中一并扫描</li>\n</ol>\n<h2 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h2><ol>\n<li>有其他分代区域中对象引用了本区域对象时,对应的卡表元素应该变脏.时间点应该发生在引用类型字段赋值的那一刻。</li>\n<li>HotSpot虚拟机通过写屏障技术维护卡表状态,是在虚拟机层面上对”引用类型字段赋值”这个动作的AOP切面,即在引用对象赋值时会产生一个环绕通知,供程序执行额外操作。</li>\n<li>应用写屏障后，虚拟机会为所有赋值操作生成相应的指令。每次对引用进行更新，就会产生额外的开销。</li>\n<li>卡表在高并发场景下的“伪共享”问题：缓存系统以缓存行为单位存储，当多线程互相修改独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响而导致性能下降。</li>\n<li>为避免伪共享问题，可以先检查卡带标记，只有当该卡表元素未被标记过时才将其标记为变脏。</li>\n</ol>\n<h2 id=\"并发的可达性分析\"><a href=\"#并发的可达性分析\" class=\"headerlink\" title=\"并发的可达性分析\"></a>并发的可达性分析</h2><ol>\n<li>可达性分析算法理论上要求全过程都STW。在根节点枚举过程中，通过OopMap技术，停顿时间已经比较短暂了。但是从GC Roots遍历图花费的时间与堆容量成正比，所以需要优化。</li>\n<li>如果用户线程与收集器并发工作。收集器在对象图上标记颜色，同时用户线程在修改引用关系，即修改对象图的结构。会产生两种后果：1.把原本消亡的对象标记为存活，这可以容忍 2.把存活对象标记为消亡，则肯定会出错</li>\n</ol>\n<h3 id=\"对象消失\"><a href=\"#对象消失\" class=\"headerlink\" title=\"对象消失\"></a>对象消失</h3><p>即原本是黑色的对象被误标记为白色，需要下述条件同时满足：</p>\n<ol>\n<li>新增了黑色到白色对象的新引用。</li>\n<li>删除了灰色到该白色对象的所有引用</li>\n</ol>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>破坏两个条件之一即可。都是通过写屏障实现</p>\n<ol>\n<li>增量更新。理解为当黑色对象一旦插入了指向白色对象的引用后，它就变回灰色对象。</li>\n<li>原始快照。无论引用对象删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。</li>\n</ol>\n<h1 id=\"经典垃圾收集器\"><a href=\"#经典垃圾收集器\" class=\"headerlink\" title=\"经典垃圾收集器\"></a>经典垃圾收集器</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>如果两个收集器之间存在连线，则可以搭配使用</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/abcd.png\" alt=\"abcd\"></p>\n<h2 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h2><ol>\n<li>单线程新生代收集器，必须STW</li>\n<li>是客户端模式下默认的新生代收集器，简单而高效</li>\n<li>对于内存资源受限，单核处理器或处理器核心数较少的环境表现良好</li>\n</ol>\n<h2 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h2><ol>\n<li>是Serial收集器的并行版本，其他与Serial大致相同</li>\n<li>JDK9后，ParNew与CMS只能互相搭配使用</li>\n<li>在单核心处理器不会有比Serial更好的效果</li>\n</ol>\n<h2 id=\"Parallel-Scavenge\"><a href=\"#Parallel-Scavenge\" class=\"headerlink\" title=\"Parallel Scavenge\"></a>Parallel Scavenge</h2><ol>\n<li>同样是基于标记-复制算法，并行收集的多线程收集器。被认为是吞吐量优先收集器。</li>\n<li>目标是达到一个可控制的吞吐量，即运行用户代码的时间/（运行用户代码的时间+运行垃圾收集时间）</li>\n<li>停顿时间短适合用户交互，高吞吐量适用于后台运算，能最高效率的利用处理器资源，尽快完成任务。</li>\n<li>-XX:MaxGCPauseMillis控制最大垃圾收集停顿时间。设置吞吐量大小：-XX:GCTimeRatio</li>\n<li>-XX:+UseAdaptiveSizePolicy 根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量。自适应的调节策略。</li>\n</ol>\n<h2 id=\"Serial-Old收集器\"><a href=\"#Serial-Old收集器\" class=\"headerlink\" title=\"Serial Old收集器\"></a>Serial Old收集器</h2><p>单线程收集器，使用标记整理算法，供客户端模式使用的。</p>\n<h2 id=\"Parallel-Old收集器\"><a href=\"#Parallel-Old收集器\" class=\"headerlink\" title=\"Parallel Old收集器\"></a>Parallel Old收集器</h2><p>支持多线程并发收集。</p>\n<p>“吞吐量优先”收集器搭配组合：Parallel Scavenge与Parallel Old</p>\n<h2 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h2><ol>\n<li>并发收集，低停顿，以获取最短回收停顿时间为目标</li>\n<li>基于标记-清除算法</li>\n</ol>\n<h3 id=\"四个阶段\"><a href=\"#四个阶段\" class=\"headerlink\" title=\"四个阶段\"></a>四个阶段</h3><ol>\n<li>初始标记。需要STW，仅仅标记一下GC Roots直接关联到的对象，速度很快。</li>\n<li>并发标记。从GC Roots直接关联到的对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程，可以并发执行。</li>\n<li>重新标记。修改并发标记期间，因用户线程继续运行而导致的标记发生变动的那一部分对象的标记记录。参考之前的增量更新。需要STW，但是时间仍然比较短。</li>\n<li>并发清除。删除掉标记阶段判断为已经死亡的对象，不需要移动对象，所以可以和用户线程并发执行。</li>\n</ol>\n<h3 id=\"三个问题\"><a href=\"#三个问题\" class=\"headerlink\" title=\"三个问题\"></a>三个问题</h3><ol>\n<li>对处理器资源敏感。即在并发阶段，虽然不会导致用户线程停顿，但因为占用一部分线程，而导致应用程序变慢，降低总吞吐量。</li>\n<li>无法处理浮动垃圾。可能因失败而导致另一次完全的STW的Full GC产生。浮动垃圾即用户线程在并发执行时还会伴随着新的垃圾对象不断产生，但CMS无法在当次收集中处理他们。而且用户线程持续运行，就需要预留足够的内存空间提供给用户线程使用。如果预留的空间无法满足程序分配新对象的需要，就会出现并发失败（Concurrent Mode Failure）就会冻结用户线程的执行，临时启用Serial Old收集器重新进行老年代的垃圾收集。</li>\n<li>有大量的空间碎片。如果无法找到足够大的连续空间来分配给当前对象，则会提前触发一次Full GC。</li>\n</ol>\n<h2 id=\"Garbage-First收集器\"><a href=\"#Garbage-First收集器\" class=\"headerlink\" title=\"Garbage First收集器\"></a>Garbage First收集器</h2><ol>\n<li>面向局部收集，基于Region内存布局</li>\n<li>JDK8后，被称为全功能的垃圾收集器。主要面向服务端。</li>\n<li>JDK9后完全取代了Parallel Scavenge加Parallel Old组合，成为服务端模式下默认垃圾收集器。</li>\n<li>建立了停顿时间模型。即能够支持指定的一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒。</li>\n<li>它可以面向堆内存的任何部分来组成回收集。衡量标准不再是属于哪个分代，而是哪块内存存放的垃圾数量最多，回收收益最大。即为Mixed GC模式。</li>\n<li>把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region可以扮演Eden，Survivor或者老年代空间。对扮演不同角色的Region采取不同的策略进行处理。</li>\n<li>还有专门存储大对象的Humongous区域。只要大于Region容量的一半即认为是大对象。而大于一个Region的大对象就会存放在N个连续的Humongous Region区域。将Humongous Region区域作为老年代的一部分看待。</li>\n<li>将Region作为单位回收的最小单元，每次收集的内存空间是Region大小的整数倍。</li>\n<li>按照各个Region垃圾堆积的价值大小，即回收所获得的空间大小和回收所需时间的经验值。在后台维护优先队列，根据用户运行的收集停顿时间，优先回收价值收益最大的Region。</li>\n</ol>\n<h3 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h3><ol>\n<li>跨Region引用对象的解决。每个Region都维护自己的记忆集。记录下别的Region指向自己的指针，并且标记这些指针分别在哪些卡页的范围内。记忆集为哈希表，key为别的Region的起始地址，value是卡表索引号的集合。大致需要10%-20%的Java堆内存维持收集器工作。</li>\n<li>并发标记阶段采用原始快照保证收集线程与用户线程互不干扰的运行。因为程序继续运行会有新对象的创建。所以每个Region都设计了两个指针，划分出一块用于并发回收过程中新对象的分配。这个地址内的对象默认是存活的，不纳入回收范围。如果内存回收速度赶不上分配速度，则也会Full GC,STW</li>\n<li>建立可靠的停顿预测模型。根据每个Region的回收耗时等信息分析得出平均值等统计信息。衰减平均值比普通的平均值更加容易受到新数据的影响，代表“最近的”平均状态。即Region的统计状态越新，越能决定其回收价值。通过这些信息进行预测，就能在不超过期望停顿时间的约束下获得最高的收益。</li>\n</ol>\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><ol>\n<li>初始标记。需要STW，仅仅标记一下GC Roots直接关联到的对象，并且修改TAMS指针,让下一阶段用户线程并发执行时,能正确的在可用Region中分配新对象.需要停顿线程,但耗时很短。</li>\n<li>并发标记。从GC Roots直接关联到的对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程，可以并发执行。扫描结束后，还要重新处理原始快照记录下在并发有引用变动的对象。</li>\n<li>最终标记。对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍然遗留下来的最后那少量的原始快照（SATB）记录。</li>\n<li>筛选回收。根据Region的回收价值和成本进行排序，再根据用户所期望的停顿时间来制定回收计划。把决定回收的Region存活对象复制到空的Region，再清理掉整个旧Region的全部空间。必须暂停用户线程。</li>\n</ol>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>目标是在延迟可控的情况下获得尽可能高的吞吐量。</p>\n<p>可以由用户指定期望的停顿时间</p>\n<p>停顿时间设置100-200ms之间会比较合适，太低则导致选出来的回收集只占堆内存很小一部分。</p>\n<p>追求能应付用于的内存分配速率，而不是追求一次把整个Java堆清理干净。</p>\n<p>G1整体是基于标记整理算法的，而局部即两个Region之间，则是基于标记复制算法的。使得不会产生内存碎片。</p>\n<h3 id=\"相对于CMS的缺点\"><a href=\"#相对于CMS的缺点\" class=\"headerlink\" title=\"相对于CMS的缺点\"></a>相对于CMS的缺点</h3><ol>\n<li>内存占用率高，因为卡表</li>\n<li>对写屏障有复杂操作，不得不实现为类似消息队列的结构，先放到队列，再异步处理。</li>\n<li>在小内存上CMS大概率优于G1平衡点大致是6-8GB内存</li>\n</ol>\n<h1 id=\"低延迟垃圾回收器\"><a href=\"#低延迟垃圾回收器\" class=\"headerlink\" title=\"低延迟垃圾回收器\"></a>低延迟垃圾回收器</h1><h2 id=\"理论\"><a href=\"#理论\" class=\"headerlink\" title=\"理论\"></a>理论</h2><p>衡量垃圾收集器指标：内存占用，吞吐量，延迟。最多能同时达到其中两项</p>\n<p>CMS，G1分别采用增量更新，原始快照方式实现了标记阶段的并发，但是对于标记后的处理仍未得到妥善解决。</p>\n<p>Shenandoah和ZGC几乎整个工作过程都是并发的，只有在初始标记，最终标记这些阶段有短暂的停顿。</p>\n<h2 id=\"ZGC收集器\"><a href=\"#ZGC收集器\" class=\"headerlink\" title=\"ZGC收集器\"></a>ZGC收集器</h2><p>基于Region内存布局的，不设分代的，使用了读屏障，染色指针和内存多映射来实现的可并发的标记整理算法，以低延迟为首要目标的一款垃圾收集器。</p>\n<h3 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h3><p>Region具有动态性，动态创建和销毁，有动态的区域容量大小</p>\n<ol>\n<li>小型Region：容量固定2MB</li>\n<li>中型Region：容量固定32MB</li>\n<li>大型Region：容量不固定，但是必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region只会存放一个大对象。</li>\n</ol>\n<h3 id=\"染色指针技术\"><a href=\"#染色指针技术\" class=\"headerlink\" title=\"染色指针技术\"></a>染色指针技术</h3><p>把标记信息直接记录在引用对象的指针上。标志信息包括引用对象的三色标记状态，是否进入重分配集（即被移动过）等。</p>\n<p>优势：</p>\n<ol>\n<li>一旦某个Region的存活对象被移走之后，该Region立即就能被释放和重用。</li>\n<li>大幅度减少内存屏障的使用数量，只使用了读屏障。</li>\n<li>可扩展，之后可以把指针前18位开发使用。</li>\n</ol>\n<h3 id=\"运行流程\"><a href=\"#运行流程\" class=\"headerlink\" title=\"运行流程\"></a>运行流程</h3><p>分为4个大阶段，都可以并发执行，只在两个阶段中间会存在短暂的停顿小阶段</p>\n<h4 id=\"并发阶段。\"><a href=\"#并发阶段。\" class=\"headerlink\" title=\"并发阶段。\"></a>并发阶段。</h4><p>遍历对象图做可达性分析。标记只在染色指针上进行。</p>\n<h4 id=\"并发预备重分配。\"><a href=\"#并发预备重分配。\" class=\"headerlink\" title=\"并发预备重分配。\"></a>并发预备重分配。</h4><p>得出本次收集过程需要清理哪些Region，将他们组成重分配集。ZGC每次都会扫描所有的Region，换取G1中记忆集的维护成本。</p>\n<h4 id=\"并发重分配。\"><a href=\"#并发重分配。\" class=\"headerlink\" title=\"并发重分配。\"></a>并发重分配。</h4><ol>\n<li>把重分配集中存活对象复制到新的Region中。并且为重分配集的每个Region维护转发表，记录从旧对象到新对象的转向关系。</li>\n<li>仅从引用就明确得知一个对象是否处于重分配集中。</li>\n<li>自愈能力：在ZGC中，当读取处于重分配集的对象时，会被读屏障拦截，通过转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。只慢一次。</li>\n</ol>\n<h4 id=\"并发重映射\"><a href=\"#并发重映射\" class=\"headerlink\" title=\"并发重映射\"></a>并发重映射</h4><p>修正整个堆中指向重分配集中旧对象的所有引用。不是迫切任务，因为可以旧引用通过自愈，最多是第一次比较慢。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>能承受的对象分配速率不会太高。</p>\n<p>支持“NUMA-Aware”（非统一的内存访问架构。为多处理器计算机所设计的内存架构）的内存分配。</p>\n<p>令人震惊的，革命性的ZGC  </p>\n<h2 id=\"Epsilon收集器\"><a href=\"#Epsilon收集器\" class=\"headerlink\" title=\"Epsilon收集器\"></a>Epsilon收集器</h2><p>不能够进行垃圾收集，无操作的垃圾收集器。对于微服务等，只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出，那么运行负载极小，没有任何回收行为的Epsilon是恰当的选择。</p>\n<h1 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>自动给对象分配内存</p>\n<p>自动回收分配给对象的内存</p>\n<h2 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h2><ol>\n<li>对象内存分配应该都是堆上分配(但也有可能栈上分配)</li>\n<li>新生对象通常分配在新生代中,少数情况(如对象大小超过一定阈值)可能直接分配到老年代</li>\n</ol>\n<h3 id=\"对象优先分配Eden区域\"><a href=\"#对象优先分配Eden区域\" class=\"headerlink\" title=\"对象优先分配Eden区域\"></a>对象优先分配Eden区域</h3><ol>\n<li>大多数情况下在Eden区分配</li>\n<li>新生代总可用空间为Eden区+1个Survivor区的总容量</li>\n<li>当Eden没有足够的空间时发生一次Minor GC,如果对象放不进Survivor区,则通过分配担保机制提前把这些对象转移到老年代</li>\n</ol>\n<h3 id=\"大对象直接进入老年代\"><a href=\"#大对象直接进入老年代\" class=\"headerlink\" title=\"大对象直接进入老年代\"></a>大对象直接进入老年代</h3><p>大对象需要大量连续的内存空间，例如很长的字符串,很长的数组。</p>\n<p>容易导致提前垃圾收集，以获取足够的连续空间安置大对象</p>\n<p>大对象直接在老年代分配，以避免在Eden与Survivor区来回复制，付出高额内存复制开销</p>\n<h3 id=\"长期存活对象进入老年代\"><a href=\"#长期存活对象进入老年代\" class=\"headerlink\" title=\"长期存活对象进入老年代\"></a>长期存活对象进入老年代</h3><p>每个对象头有对象年龄计数器。如果经过一次MinorGC仍然存活，并且能被Survivor容纳，则计数器+1，当到15时，则晋身为老年代。</p>\n<h3 id=\"动态对象年龄判断\"><a href=\"#动态对象年龄判断\" class=\"headerlink\" title=\"动态对象年龄判断\"></a>动态对象年龄判断</h3><p>如果Survivor区中相同年龄所有对象的总和大于Survivor区的一半，那么年龄大于等于该年龄‘的对象直接进入老年代</p>\n<h3 id=\"空间分配担保\"><a href=\"#空间分配担保\" class=\"headerlink\" title=\"空间分配担保\"></a>空间分配担保</h3><p>在Minor GC前，检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果成立，则这次Minor GC安全。负责要看是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的平均大小，如果小于，或者不允许担保，则Full GC。</p>\n<p>新生代中，把Survivor无法容纳的对象直接送入老年代，担保前提是老年代本身有容纳这些对象的剩余空间。</p>\n<p>在JDK7及之后。不能设置参数影响空间分配担保策略。只要老年代最大可用连续空间大于新生代的所有对象空间，或者大于历次晋升到老年代的平均大小，就进行Minor GC，负责Full GC</p>\n"},{"title":"深入理解Java虚拟机--类文件结构","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习<<深入理解Java虚拟机>>所做的笔记,此为书上第六章--类文件结构。","abbrlink":"b05d8834","date":"2020-07-07T16:00:00.000Z","_content":"# Class类文件的结构\n\n1. 以八个字节为基础单位的二进制流\n2. 无符号数为基本数据类型。以u1,u2,u4,u8分别代表1字节，2字节，4字节，8字节的无符号数\n3. 表是由多个无符号数或者其他表作为数据项构成的复合数据类型。习惯以_info结尾\n\n## 魔数与Class文件的版本\n\n1. 头四个字节为魔数，标识他为Class文件。值为0xCAFEBABE\n2. 后面四个字节为版本号。前两个为次版本号（Minor Version）,后两个为主版本号（Minor Version）。次版本号基本未使用，固定为0。主版本号从45开始。\n3. 高版本JDK能向下兼容以前的Class文件但是不能运行之后版本的Class文件\n4. 例如JDK1.1能支持的版本号为:`45.0-45.65535`,JDK1.2支持`45.0-46.65535`\n\n## 常量池\n\n1. 主要存放字面量和符号引用。字面量类似常量，如文本字符串，被声明为final的常量值等等。符号引用属于编译原理相关，包括全限定类名，方法字段名称等等\n2. 符号引用不经过虚拟机运行期转换就无法得到真正的内存入口地址，就无法被虚拟机直接使用。当虚拟机做类加载时，将从常量池获取相应的符号引用，再在类创建时或运行时解析翻译到具体的内存地址中。\n\n### CONSTANT_Class_info\n\n1. 用u1存储tag，标识常量类型\n2. 用u2存储name_index,是常量池的索引值，指向一个CONSTANT_Utf8_info类型常量，代表了该类的全限定名。\n\n### CONSTANT_Utf8_info\n\n1. 用u1存储tag，标识常量类型\n2. 用u2存储length，代表字符串长度是多少字节\n3. 之后是用u1存储bytes，一共有length个字节\n\n## 访问标志\n\n常量池之后两个字节代表访问标志。例如：是类还是接口，是否是public，是否是abstract等等\n\n## 类索引，父类索引，接口索引集合\n\n1. 类索引，父类索引为u2类型的数据，接口索引集合为u2类型的数据集合。由此确定该类型的继承关系。\n2. 类索引，父类索引用u2类型的索引值表示，各自指向一个`CONSTANT_Class_info`的类描述符常量。又通过该常量的`CONSTANT_Utf8_info`找到全限定名字符串。\n3. 接口索引集合第一项的u2类型的数据为接口计数器，表示索引表的容量。\n\n## 字段表集合\n\n1. 描述变量，包括类级变量，实例级变量，但不包括方法中的局部变量。\n2. 字段包括: 修饰符`（public，private,protected,static,final,volatile,transient）`,字符数据类型（基本类型，对象，数组）,字段名称\n3. 修饰符适合用标志位表示，但字符数据类型，字段名称只能引用常量池中的常量来描述\n4. 字符修饰符用u2,access_flags表示。之后是u2的name_index,descriptor_index是对常量池的引用，代表了字段的简单名称和方法的描述符。\n5. 描述符用来描述字段的数据类型，方法的参数列表和返回值。基本数据类型类型和void用一个大写字符表示。例如C代表char。对象类型用L加对象的全限定名表示，例如Ljava/lang/Object;\n6. 数组每一维度用一个`[`表示，如定义了`java.lang.String [][]`则记录为`[[Ljava/lang/String;`\n7. 用描述符描述方法，则先参照列表，再返回值的顺序描述。例如`String test(char [] chars)`为   `([C)[Ljava/lang/String;`\n8. 字段表集合不会列出从父类或者父接口中继承来的字段。但有可能出现Java代码中不存在的字段。例如编译器为内部类自动添加指向外部类实例的字段。\n\n## 方法表集合\n\n1. 和字段表集合极其相似。没有`volatile,transient`,但多了`synchronized,native,strictfp,abstract`关键字\n2. 方法中的代码，存放再方法属性表集合中名为`Code`的属性里面\n3. 若子类没有重写父类方法，则不会出现父类方法信息\n4. 有可能出现由编译器自动添加的方法，例如类构造器`<cinit>()`,实例构造器`<init>()`方法\n\n## 属性表集合\n\nClass文件，字段表，方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。\n\n### Code属性\n\n1. 方法体中代码经过Javac编译器处理后，变成字节码指令存储在Code属性中\n2. `attribute_name_index`是指向`CONSTANT_Utf8_info`的索引，固定为\"Code\"，代表该属性名称\n3. `attribute_length`指示了属性值的长度，为u4\n4. `max_stack`代表了操作数栈深度的最大值。根据该值来分配栈帧中的操作数栈深度。\n5. `max_locals`代表了局部变量表所需的存储空间。单位是Slot（变量槽），变量槽是虚拟机为局部变量分配内存所使用的最小单位。不超过32位的一个槽，double和long占用两个槽。\n6. 方法参数（包括实例方法隐藏参数this），异常参数，方法体中的局部变量都依赖局部变量表存储\n7. 虚拟机将局部变量表中的变量槽复用。当代码执行超出了一个局部变量的作用域时，该局部变量所占的变量槽可以被其他局部变量使用。根据同时生成的最大局部变量数量和类型算出`max_locals`的大小\n8. `code_length`,`code`存储Java源程序编译后生成的字节码指令。每个指令是u1的单字节。可以对应找出该字节码代表什么指令。\n9. Code属性用于描述代码，其他项目用于描述元数据。\n10. 任何实例方法里面，都可以通过this访问到该方法所属的对象。是通过编译器编译时把对this关键字的访问转变位对一个普通方法参数的访问，虚拟机在调用实例方法时自动传入此参数。因此任何实例方法的局部变量表至少存在一个指向当前对象实例的局部变量。局部变量表也会预留出第一个变量槽位来存放实例对象的引用。\n11. 异常表，当字节码从第`start_pc`到第`end_pc`出现了类型为`catch_type`或其子类的异常，则转到第`handle_pc`行继续处理。\n\n### Exceptions属性\n\n列举出方法中可能抛出的受查异常。即方法中throws后面列举的异常。\n\n### LineNumberTable属性\n\n描述Java源码行号和字节码行号的对应关系。非必须，但如果没有，抛出异常时不会显示出错行号，调试程序也无法按照源码设置断点。\n\n### LocalVariableTable和LocalVariableTypeTable属性\n\n描述栈帧中局部变量表的变量和Java源码中定义的变量之间的关系。非必须，但没有当其他人引用方法，所有参数名称将会丢失，用arg0,arg1等替代参数名。\n### SourceFile属性\n用于记录生成这个Class文件的源码文件名称.大多数类,类名和文件名一致,但有例外。\n### ConstantValue属性\n1. 通知虚拟机自动为静态变量赋值。\n2. 对实例变量赋值再<init>()方法中。\n3. 对于类变量，若是final，static修饰，并且是基本类型或者String的话,用`ConstantValue`进行初始化。否则会选择在`<cinit()`方法初始化。\n\n### InnerClasses属性\n\n用于记录内部类和宿主类之间的关联。\n\n### Deprecated及Synthetic属性\n\nDeprecated属性用于表示某个类，字段或者方法，已经被程序作者定为不再推荐使用。可以用`@deprecated`注解进行设置。\n\nSynthetic属性标识此字段或方法不是由Java源码直接产生的，而是由编译器自行添加的。\n\n### StackMapTable属性\n\n在虚拟机类加载的字节码验证阶段被新类型检查验证器使用。\n\n### Signature属性\n\n若包含了类型变量或参数化类型，则该属性会为他记录泛型签名信息\n\n### BootStrapMethods属性\n\n保存`invokedynamic`指令引用的引导方法限定符\n\n### MethodParameters属性\n\n记录方法的各个形参名称和信息\n\n### 模块化相关属性\n\n支持Java模块化相关功能\n\n### 运行时注解相关属性\n\n记录了类,字段,方法的声明上记录运行时可见注解\n\n# 字节码指令简介\n\n由一个字节长度的操作码和零或多个的操作数构成.是面向操作数栈的,所以大多数指令不包括操作数,只有操作码.指令参数都放在操作数栈中。\n\n## 字节码与数据类型\n\n1. iload指令用于从局部变量表中加载int型的数据到操作数栈中\n2. 大多数指令没有支持byte,char,short,boolean。编译器会在编译或者运行期将他们扩展为int型数据\n\n## 加载和存储指令\n\n用于将数据在栈帧中的局部变量表和操作数栈之间来回传输\n\n## 运算指令\n\n用于对操作数栈上的两个值进行某种特定运算，并且把结果重新存入操作栈顶\n\n大致分为两种类型：对整数数据，浮点型数据\n\n不存在直接支持byte,short,char,boolean的运算，都是用操作int类型的指令代替\n\n## 类型转换指令\n\n1. 将两种不同的数据类型相互转换，实现用户代码中的显式类型转换\n2. 小范围到大范围类型为安全转换，无须显示的转换指令，如`int 转 long,float,double`,`long转folat,double`,`float转double`\n3. int转long，只会简单的将高位抛弃，所以可能导致不同的正负号\n4. 转换可能出现上限溢出，下限溢出，精度丢失等等，但永远不可能导致虚拟机抛出运行时异常\n\n## 对象创建与访问指令\n\nJava虚拟机对类实例和数组的创建使用了不同的字节码指令\n\n## 操作数栈管理指令\n\n将操作数栈顶一个或者两个元素出栈：pop,pop2\n\n将栈顶最顶端两个数值交换：swap\n\n## 控制转移指令\n\n有条件或无条件的修改PC寄存器的值，从指定位置指令的下一条指令继续执行程序\n\n各种类型的比较最终都会转化为int类型的比较操作\n\n## 方法调用和返回指令\n\n1. `invokevirtual`:用于调用对象的实例方法,根据对象的实际类型进行分派(虚方法分派)\n2. `invokeinterface`:用于调用接口方法,在运行时搜索一个实现了这个接口方法的对象,找出合适的方法调用\n3. `invokespecial`:调用一些需要特殊处理的实例方法,例如实例初始化方法,私有方法,父类方法\n4. `invokestatic`:用于调用静态方法(static)方法\n5. `invokedynamic`:用于在运行时动态解析出调用点限定符所引用的方法\n6. 方法返回指令是根据返回值的类型区分的.包括ireturn(返回类型是boolean,byte,char,short,int),lreturn,freturn,dreturn,areturn,return(返回值为void的,实例初始化的,类和接口的类初始化方法)\n\n## 异常处理指令\n\n对显示抛出异常的操作（throw语句）进行处理\n\n而处理异常（catch语句）不由字节码指令实现，是由异常表实现\n\n## 同步指令\n\nJava虚拟机可以支持方法级同步和方法内部一段指令序列的同步,使用管程实现.\n\n执行线程要求先成功持有管程,然后才能执行方法,最后当方法完成时释放管程\n\n使用synchronized语句块表示\n\n无论这个方法是正常结束还是异常退出,方法调用的每条monitorenter指令都必须有其对应的monitorexit指令\n\n\n\n# 公有设计，私有实现\n\n<<Java虚拟机规范>>描绘了Java虚拟机应有的共同程序存储格\n\n式：Class文件格式以及字节码指令集\n\n任何一款Java虚拟机都必须能读取Class文件并且精确实现其中的Java虚拟机代码的语义\n\nJava虚拟机只要外部接口与规范描述一致即可，具体实现不规定\n\n# 小结\n\nClass文件格式具备平台中立，紧凑，稳定，可扩展性的特点。是Java技术体系实现平台无关，语言无关的重要支柱\n\nClass文件是Java虚拟机执行引擎的数据入口。","source":"_posts/JVM笔记/第6章.md","raw":"---\ntitle: 深入理解Java虚拟机--类文件结构\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第六章--类文件结构。'\ncategories: JVM学习笔记\ntags:\n  - 深入理解Java虚拟机\n  - JVM\n  - Class\nabbrlink: b05d8834\ndate: 2020-07-08 00:00:00\n---\n# Class类文件的结构\n\n1. 以八个字节为基础单位的二进制流\n2. 无符号数为基本数据类型。以u1,u2,u4,u8分别代表1字节，2字节，4字节，8字节的无符号数\n3. 表是由多个无符号数或者其他表作为数据项构成的复合数据类型。习惯以_info结尾\n\n## 魔数与Class文件的版本\n\n1. 头四个字节为魔数，标识他为Class文件。值为0xCAFEBABE\n2. 后面四个字节为版本号。前两个为次版本号（Minor Version）,后两个为主版本号（Minor Version）。次版本号基本未使用，固定为0。主版本号从45开始。\n3. 高版本JDK能向下兼容以前的Class文件但是不能运行之后版本的Class文件\n4. 例如JDK1.1能支持的版本号为:`45.0-45.65535`,JDK1.2支持`45.0-46.65535`\n\n## 常量池\n\n1. 主要存放字面量和符号引用。字面量类似常量，如文本字符串，被声明为final的常量值等等。符号引用属于编译原理相关，包括全限定类名，方法字段名称等等\n2. 符号引用不经过虚拟机运行期转换就无法得到真正的内存入口地址，就无法被虚拟机直接使用。当虚拟机做类加载时，将从常量池获取相应的符号引用，再在类创建时或运行时解析翻译到具体的内存地址中。\n\n### CONSTANT_Class_info\n\n1. 用u1存储tag，标识常量类型\n2. 用u2存储name_index,是常量池的索引值，指向一个CONSTANT_Utf8_info类型常量，代表了该类的全限定名。\n\n### CONSTANT_Utf8_info\n\n1. 用u1存储tag，标识常量类型\n2. 用u2存储length，代表字符串长度是多少字节\n3. 之后是用u1存储bytes，一共有length个字节\n\n## 访问标志\n\n常量池之后两个字节代表访问标志。例如：是类还是接口，是否是public，是否是abstract等等\n\n## 类索引，父类索引，接口索引集合\n\n1. 类索引，父类索引为u2类型的数据，接口索引集合为u2类型的数据集合。由此确定该类型的继承关系。\n2. 类索引，父类索引用u2类型的索引值表示，各自指向一个`CONSTANT_Class_info`的类描述符常量。又通过该常量的`CONSTANT_Utf8_info`找到全限定名字符串。\n3. 接口索引集合第一项的u2类型的数据为接口计数器，表示索引表的容量。\n\n## 字段表集合\n\n1. 描述变量，包括类级变量，实例级变量，但不包括方法中的局部变量。\n2. 字段包括: 修饰符`（public，private,protected,static,final,volatile,transient）`,字符数据类型（基本类型，对象，数组）,字段名称\n3. 修饰符适合用标志位表示，但字符数据类型，字段名称只能引用常量池中的常量来描述\n4. 字符修饰符用u2,access_flags表示。之后是u2的name_index,descriptor_index是对常量池的引用，代表了字段的简单名称和方法的描述符。\n5. 描述符用来描述字段的数据类型，方法的参数列表和返回值。基本数据类型类型和void用一个大写字符表示。例如C代表char。对象类型用L加对象的全限定名表示，例如Ljava/lang/Object;\n6. 数组每一维度用一个`[`表示，如定义了`java.lang.String [][]`则记录为`[[Ljava/lang/String;`\n7. 用描述符描述方法，则先参照列表，再返回值的顺序描述。例如`String test(char [] chars)`为   `([C)[Ljava/lang/String;`\n8. 字段表集合不会列出从父类或者父接口中继承来的字段。但有可能出现Java代码中不存在的字段。例如编译器为内部类自动添加指向外部类实例的字段。\n\n## 方法表集合\n\n1. 和字段表集合极其相似。没有`volatile,transient`,但多了`synchronized,native,strictfp,abstract`关键字\n2. 方法中的代码，存放再方法属性表集合中名为`Code`的属性里面\n3. 若子类没有重写父类方法，则不会出现父类方法信息\n4. 有可能出现由编译器自动添加的方法，例如类构造器`<cinit>()`,实例构造器`<init>()`方法\n\n## 属性表集合\n\nClass文件，字段表，方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。\n\n### Code属性\n\n1. 方法体中代码经过Javac编译器处理后，变成字节码指令存储在Code属性中\n2. `attribute_name_index`是指向`CONSTANT_Utf8_info`的索引，固定为\"Code\"，代表该属性名称\n3. `attribute_length`指示了属性值的长度，为u4\n4. `max_stack`代表了操作数栈深度的最大值。根据该值来分配栈帧中的操作数栈深度。\n5. `max_locals`代表了局部变量表所需的存储空间。单位是Slot（变量槽），变量槽是虚拟机为局部变量分配内存所使用的最小单位。不超过32位的一个槽，double和long占用两个槽。\n6. 方法参数（包括实例方法隐藏参数this），异常参数，方法体中的局部变量都依赖局部变量表存储\n7. 虚拟机将局部变量表中的变量槽复用。当代码执行超出了一个局部变量的作用域时，该局部变量所占的变量槽可以被其他局部变量使用。根据同时生成的最大局部变量数量和类型算出`max_locals`的大小\n8. `code_length`,`code`存储Java源程序编译后生成的字节码指令。每个指令是u1的单字节。可以对应找出该字节码代表什么指令。\n9. Code属性用于描述代码，其他项目用于描述元数据。\n10. 任何实例方法里面，都可以通过this访问到该方法所属的对象。是通过编译器编译时把对this关键字的访问转变位对一个普通方法参数的访问，虚拟机在调用实例方法时自动传入此参数。因此任何实例方法的局部变量表至少存在一个指向当前对象实例的局部变量。局部变量表也会预留出第一个变量槽位来存放实例对象的引用。\n11. 异常表，当字节码从第`start_pc`到第`end_pc`出现了类型为`catch_type`或其子类的异常，则转到第`handle_pc`行继续处理。\n\n### Exceptions属性\n\n列举出方法中可能抛出的受查异常。即方法中throws后面列举的异常。\n\n### LineNumberTable属性\n\n描述Java源码行号和字节码行号的对应关系。非必须，但如果没有，抛出异常时不会显示出错行号，调试程序也无法按照源码设置断点。\n\n### LocalVariableTable和LocalVariableTypeTable属性\n\n描述栈帧中局部变量表的变量和Java源码中定义的变量之间的关系。非必须，但没有当其他人引用方法，所有参数名称将会丢失，用arg0,arg1等替代参数名。\n### SourceFile属性\n用于记录生成这个Class文件的源码文件名称.大多数类,类名和文件名一致,但有例外。\n### ConstantValue属性\n1. 通知虚拟机自动为静态变量赋值。\n2. 对实例变量赋值再<init>()方法中。\n3. 对于类变量，若是final，static修饰，并且是基本类型或者String的话,用`ConstantValue`进行初始化。否则会选择在`<cinit()`方法初始化。\n\n### InnerClasses属性\n\n用于记录内部类和宿主类之间的关联。\n\n### Deprecated及Synthetic属性\n\nDeprecated属性用于表示某个类，字段或者方法，已经被程序作者定为不再推荐使用。可以用`@deprecated`注解进行设置。\n\nSynthetic属性标识此字段或方法不是由Java源码直接产生的，而是由编译器自行添加的。\n\n### StackMapTable属性\n\n在虚拟机类加载的字节码验证阶段被新类型检查验证器使用。\n\n### Signature属性\n\n若包含了类型变量或参数化类型，则该属性会为他记录泛型签名信息\n\n### BootStrapMethods属性\n\n保存`invokedynamic`指令引用的引导方法限定符\n\n### MethodParameters属性\n\n记录方法的各个形参名称和信息\n\n### 模块化相关属性\n\n支持Java模块化相关功能\n\n### 运行时注解相关属性\n\n记录了类,字段,方法的声明上记录运行时可见注解\n\n# 字节码指令简介\n\n由一个字节长度的操作码和零或多个的操作数构成.是面向操作数栈的,所以大多数指令不包括操作数,只有操作码.指令参数都放在操作数栈中。\n\n## 字节码与数据类型\n\n1. iload指令用于从局部变量表中加载int型的数据到操作数栈中\n2. 大多数指令没有支持byte,char,short,boolean。编译器会在编译或者运行期将他们扩展为int型数据\n\n## 加载和存储指令\n\n用于将数据在栈帧中的局部变量表和操作数栈之间来回传输\n\n## 运算指令\n\n用于对操作数栈上的两个值进行某种特定运算，并且把结果重新存入操作栈顶\n\n大致分为两种类型：对整数数据，浮点型数据\n\n不存在直接支持byte,short,char,boolean的运算，都是用操作int类型的指令代替\n\n## 类型转换指令\n\n1. 将两种不同的数据类型相互转换，实现用户代码中的显式类型转换\n2. 小范围到大范围类型为安全转换，无须显示的转换指令，如`int 转 long,float,double`,`long转folat,double`,`float转double`\n3. int转long，只会简单的将高位抛弃，所以可能导致不同的正负号\n4. 转换可能出现上限溢出，下限溢出，精度丢失等等，但永远不可能导致虚拟机抛出运行时异常\n\n## 对象创建与访问指令\n\nJava虚拟机对类实例和数组的创建使用了不同的字节码指令\n\n## 操作数栈管理指令\n\n将操作数栈顶一个或者两个元素出栈：pop,pop2\n\n将栈顶最顶端两个数值交换：swap\n\n## 控制转移指令\n\n有条件或无条件的修改PC寄存器的值，从指定位置指令的下一条指令继续执行程序\n\n各种类型的比较最终都会转化为int类型的比较操作\n\n## 方法调用和返回指令\n\n1. `invokevirtual`:用于调用对象的实例方法,根据对象的实际类型进行分派(虚方法分派)\n2. `invokeinterface`:用于调用接口方法,在运行时搜索一个实现了这个接口方法的对象,找出合适的方法调用\n3. `invokespecial`:调用一些需要特殊处理的实例方法,例如实例初始化方法,私有方法,父类方法\n4. `invokestatic`:用于调用静态方法(static)方法\n5. `invokedynamic`:用于在运行时动态解析出调用点限定符所引用的方法\n6. 方法返回指令是根据返回值的类型区分的.包括ireturn(返回类型是boolean,byte,char,short,int),lreturn,freturn,dreturn,areturn,return(返回值为void的,实例初始化的,类和接口的类初始化方法)\n\n## 异常处理指令\n\n对显示抛出异常的操作（throw语句）进行处理\n\n而处理异常（catch语句）不由字节码指令实现，是由异常表实现\n\n## 同步指令\n\nJava虚拟机可以支持方法级同步和方法内部一段指令序列的同步,使用管程实现.\n\n执行线程要求先成功持有管程,然后才能执行方法,最后当方法完成时释放管程\n\n使用synchronized语句块表示\n\n无论这个方法是正常结束还是异常退出,方法调用的每条monitorenter指令都必须有其对应的monitorexit指令\n\n\n\n# 公有设计，私有实现\n\n<<Java虚拟机规范>>描绘了Java虚拟机应有的共同程序存储格\n\n式：Class文件格式以及字节码指令集\n\n任何一款Java虚拟机都必须能读取Class文件并且精确实现其中的Java虚拟机代码的语义\n\nJava虚拟机只要外部接口与规范描述一致即可，具体实现不规定\n\n# 小结\n\nClass文件格式具备平台中立，紧凑，稳定，可扩展性的特点。是Java技术体系实现平台无关，语言无关的重要支柱\n\nClass文件是Java虚拟机执行引擎的数据入口。","slug":"JVM笔记/第6章","published":1,"updated":"2020-11-12T11:57:29.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6vu000gjotp1hcbdscp","content":"<h1 id=\"Class类文件的结构\"><a href=\"#Class类文件的结构\" class=\"headerlink\" title=\"Class类文件的结构\"></a>Class类文件的结构</h1><ol>\n<li>以八个字节为基础单位的二进制流</li>\n<li>无符号数为基本数据类型。以u1,u2,u4,u8分别代表1字节，2字节，4字节，8字节的无符号数</li>\n<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型。习惯以_info结尾</li>\n</ol>\n<h2 id=\"魔数与Class文件的版本\"><a href=\"#魔数与Class文件的版本\" class=\"headerlink\" title=\"魔数与Class文件的版本\"></a>魔数与Class文件的版本</h2><ol>\n<li>头四个字节为魔数，标识他为Class文件。值为0xCAFEBABE</li>\n<li>后面四个字节为版本号。前两个为次版本号（Minor Version）,后两个为主版本号（Minor Version）。次版本号基本未使用，固定为0。主版本号从45开始。</li>\n<li>高版本JDK能向下兼容以前的Class文件但是不能运行之后版本的Class文件</li>\n<li>例如JDK1.1能支持的版本号为:<code>45.0-45.65535</code>,JDK1.2支持<code>45.0-46.65535</code></li>\n</ol>\n<h2 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h2><ol>\n<li>主要存放字面量和符号引用。字面量类似常量，如文本字符串，被声明为final的常量值等等。符号引用属于编译原理相关，包括全限定类名，方法字段名称等等</li>\n<li>符号引用不经过虚拟机运行期转换就无法得到真正的内存入口地址，就无法被虚拟机直接使用。当虚拟机做类加载时，将从常量池获取相应的符号引用，再在类创建时或运行时解析翻译到具体的内存地址中。</li>\n</ol>\n<h3 id=\"CONSTANT-Class-info\"><a href=\"#CONSTANT-Class-info\" class=\"headerlink\" title=\"CONSTANT_Class_info\"></a>CONSTANT_Class_info</h3><ol>\n<li>用u1存储tag，标识常量类型</li>\n<li>用u2存储name_index,是常量池的索引值，指向一个CONSTANT_Utf8_info类型常量，代表了该类的全限定名。</li>\n</ol>\n<h3 id=\"CONSTANT-Utf8-info\"><a href=\"#CONSTANT-Utf8-info\" class=\"headerlink\" title=\"CONSTANT_Utf8_info\"></a>CONSTANT_Utf8_info</h3><ol>\n<li>用u1存储tag，标识常量类型</li>\n<li>用u2存储length，代表字符串长度是多少字节</li>\n<li>之后是用u1存储bytes，一共有length个字节</li>\n</ol>\n<h2 id=\"访问标志\"><a href=\"#访问标志\" class=\"headerlink\" title=\"访问标志\"></a>访问标志</h2><p>常量池之后两个字节代表访问标志。例如：是类还是接口，是否是public，是否是abstract等等</p>\n<h2 id=\"类索引，父类索引，接口索引集合\"><a href=\"#类索引，父类索引，接口索引集合\" class=\"headerlink\" title=\"类索引，父类索引，接口索引集合\"></a>类索引，父类索引，接口索引集合</h2><ol>\n<li>类索引，父类索引为u2类型的数据，接口索引集合为u2类型的数据集合。由此确定该类型的继承关系。</li>\n<li>类索引，父类索引用u2类型的索引值表示，各自指向一个<code>CONSTANT_Class_info</code>的类描述符常量。又通过该常量的<code>CONSTANT_Utf8_info</code>找到全限定名字符串。</li>\n<li>接口索引集合第一项的u2类型的数据为接口计数器，表示索引表的容量。</li>\n</ol>\n<h2 id=\"字段表集合\"><a href=\"#字段表集合\" class=\"headerlink\" title=\"字段表集合\"></a>字段表集合</h2><ol>\n<li>描述变量，包括类级变量，实例级变量，但不包括方法中的局部变量。</li>\n<li>字段包括: 修饰符<code>（public，private,protected,static,final,volatile,transient）</code>,字符数据类型（基本类型，对象，数组）,字段名称</li>\n<li>修饰符适合用标志位表示，但字符数据类型，字段名称只能引用常量池中的常量来描述</li>\n<li>字符修饰符用u2,access_flags表示。之后是u2的name_index,descriptor_index是对常量池的引用，代表了字段的简单名称和方法的描述符。</li>\n<li>描述符用来描述字段的数据类型，方法的参数列表和返回值。基本数据类型类型和void用一个大写字符表示。例如C代表char。对象类型用L加对象的全限定名表示，例如Ljava/lang/Object;</li>\n<li>数组每一维度用一个<code>[</code>表示，如定义了<code>java.lang.String [][]</code>则记录为<code>[[Ljava/lang/String;</code></li>\n<li>用描述符描述方法，则先参照列表，再返回值的顺序描述。例如<code>String test(char [] chars)</code>为   <code>([C)[Ljava/lang/String;</code></li>\n<li>字段表集合不会列出从父类或者父接口中继承来的字段。但有可能出现Java代码中不存在的字段。例如编译器为内部类自动添加指向外部类实例的字段。</li>\n</ol>\n<h2 id=\"方法表集合\"><a href=\"#方法表集合\" class=\"headerlink\" title=\"方法表集合\"></a>方法表集合</h2><ol>\n<li>和字段表集合极其相似。没有<code>volatile,transient</code>,但多了<code>synchronized,native,strictfp,abstract</code>关键字</li>\n<li>方法中的代码，存放再方法属性表集合中名为<code>Code</code>的属性里面</li>\n<li>若子类没有重写父类方法，则不会出现父类方法信息</li>\n<li>有可能出现由编译器自动添加的方法，例如类构造器<code>&lt;cinit&gt;()</code>,实例构造器<code>&lt;init&gt;()</code>方法</li>\n</ol>\n<h2 id=\"属性表集合\"><a href=\"#属性表集合\" class=\"headerlink\" title=\"属性表集合\"></a>属性表集合</h2><p>Class文件，字段表，方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p>\n<h3 id=\"Code属性\"><a href=\"#Code属性\" class=\"headerlink\" title=\"Code属性\"></a>Code属性</h3><ol>\n<li>方法体中代码经过Javac编译器处理后，变成字节码指令存储在Code属性中</li>\n<li><code>attribute_name_index</code>是指向<code>CONSTANT_Utf8_info</code>的索引，固定为”Code”，代表该属性名称</li>\n<li><code>attribute_length</code>指示了属性值的长度，为u4</li>\n<li><code>max_stack</code>代表了操作数栈深度的最大值。根据该值来分配栈帧中的操作数栈深度。</li>\n<li><code>max_locals</code>代表了局部变量表所需的存储空间。单位是Slot（变量槽），变量槽是虚拟机为局部变量分配内存所使用的最小单位。不超过32位的一个槽，double和long占用两个槽。</li>\n<li>方法参数（包括实例方法隐藏参数this），异常参数，方法体中的局部变量都依赖局部变量表存储</li>\n<li>虚拟机将局部变量表中的变量槽复用。当代码执行超出了一个局部变量的作用域时，该局部变量所占的变量槽可以被其他局部变量使用。根据同时生成的最大局部变量数量和类型算出<code>max_locals</code>的大小</li>\n<li><code>code_length</code>,<code>code</code>存储Java源程序编译后生成的字节码指令。每个指令是u1的单字节。可以对应找出该字节码代表什么指令。</li>\n<li>Code属性用于描述代码，其他项目用于描述元数据。</li>\n<li>任何实例方法里面，都可以通过this访问到该方法所属的对象。是通过编译器编译时把对this关键字的访问转变位对一个普通方法参数的访问，虚拟机在调用实例方法时自动传入此参数。因此任何实例方法的局部变量表至少存在一个指向当前对象实例的局部变量。局部变量表也会预留出第一个变量槽位来存放实例对象的引用。</li>\n<li>异常表，当字节码从第<code>start_pc</code>到第<code>end_pc</code>出现了类型为<code>catch_type</code>或其子类的异常，则转到第<code>handle_pc</code>行继续处理。</li>\n</ol>\n<h3 id=\"Exceptions属性\"><a href=\"#Exceptions属性\" class=\"headerlink\" title=\"Exceptions属性\"></a>Exceptions属性</h3><p>列举出方法中可能抛出的受查异常。即方法中throws后面列举的异常。</p>\n<h3 id=\"LineNumberTable属性\"><a href=\"#LineNumberTable属性\" class=\"headerlink\" title=\"LineNumberTable属性\"></a>LineNumberTable属性</h3><p>描述Java源码行号和字节码行号的对应关系。非必须，但如果没有，抛出异常时不会显示出错行号，调试程序也无法按照源码设置断点。</p>\n<h3 id=\"LocalVariableTable和LocalVariableTypeTable属性\"><a href=\"#LocalVariableTable和LocalVariableTypeTable属性\" class=\"headerlink\" title=\"LocalVariableTable和LocalVariableTypeTable属性\"></a>LocalVariableTable和LocalVariableTypeTable属性</h3><p>描述栈帧中局部变量表的变量和Java源码中定义的变量之间的关系。非必须，但没有当其他人引用方法，所有参数名称将会丢失，用arg0,arg1等替代参数名。</p>\n<h3 id=\"SourceFile属性\"><a href=\"#SourceFile属性\" class=\"headerlink\" title=\"SourceFile属性\"></a>SourceFile属性</h3><p>用于记录生成这个Class文件的源码文件名称.大多数类,类名和文件名一致,但有例外。</p>\n<h3 id=\"ConstantValue属性\"><a href=\"#ConstantValue属性\" class=\"headerlink\" title=\"ConstantValue属性\"></a>ConstantValue属性</h3><ol>\n<li>通知虚拟机自动为静态变量赋值。</li>\n<li>对实例变量赋值再<init>()方法中。</li>\n<li>对于类变量，若是final，static修饰，并且是基本类型或者String的话,用<code>ConstantValue</code>进行初始化。否则会选择在<code>&lt;cinit()</code>方法初始化。</li>\n</ol>\n<h3 id=\"InnerClasses属性\"><a href=\"#InnerClasses属性\" class=\"headerlink\" title=\"InnerClasses属性\"></a>InnerClasses属性</h3><p>用于记录内部类和宿主类之间的关联。</p>\n<h3 id=\"Deprecated及Synthetic属性\"><a href=\"#Deprecated及Synthetic属性\" class=\"headerlink\" title=\"Deprecated及Synthetic属性\"></a>Deprecated及Synthetic属性</h3><p>Deprecated属性用于表示某个类，字段或者方法，已经被程序作者定为不再推荐使用。可以用<code>@deprecated</code>注解进行设置。</p>\n<p>Synthetic属性标识此字段或方法不是由Java源码直接产生的，而是由编译器自行添加的。</p>\n<h3 id=\"StackMapTable属性\"><a href=\"#StackMapTable属性\" class=\"headerlink\" title=\"StackMapTable属性\"></a>StackMapTable属性</h3><p>在虚拟机类加载的字节码验证阶段被新类型检查验证器使用。</p>\n<h3 id=\"Signature属性\"><a href=\"#Signature属性\" class=\"headerlink\" title=\"Signature属性\"></a>Signature属性</h3><p>若包含了类型变量或参数化类型，则该属性会为他记录泛型签名信息</p>\n<h3 id=\"BootStrapMethods属性\"><a href=\"#BootStrapMethods属性\" class=\"headerlink\" title=\"BootStrapMethods属性\"></a>BootStrapMethods属性</h3><p>保存<code>invokedynamic</code>指令引用的引导方法限定符</p>\n<h3 id=\"MethodParameters属性\"><a href=\"#MethodParameters属性\" class=\"headerlink\" title=\"MethodParameters属性\"></a>MethodParameters属性</h3><p>记录方法的各个形参名称和信息</p>\n<h3 id=\"模块化相关属性\"><a href=\"#模块化相关属性\" class=\"headerlink\" title=\"模块化相关属性\"></a>模块化相关属性</h3><p>支持Java模块化相关功能</p>\n<h3 id=\"运行时注解相关属性\"><a href=\"#运行时注解相关属性\" class=\"headerlink\" title=\"运行时注解相关属性\"></a>运行时注解相关属性</h3><p>记录了类,字段,方法的声明上记录运行时可见注解</p>\n<h1 id=\"字节码指令简介\"><a href=\"#字节码指令简介\" class=\"headerlink\" title=\"字节码指令简介\"></a>字节码指令简介</h1><p>由一个字节长度的操作码和零或多个的操作数构成.是面向操作数栈的,所以大多数指令不包括操作数,只有操作码.指令参数都放在操作数栈中。</p>\n<h2 id=\"字节码与数据类型\"><a href=\"#字节码与数据类型\" class=\"headerlink\" title=\"字节码与数据类型\"></a>字节码与数据类型</h2><ol>\n<li>iload指令用于从局部变量表中加载int型的数据到操作数栈中</li>\n<li>大多数指令没有支持byte,char,short,boolean。编译器会在编译或者运行期将他们扩展为int型数据</li>\n</ol>\n<h2 id=\"加载和存储指令\"><a href=\"#加载和存储指令\" class=\"headerlink\" title=\"加载和存储指令\"></a>加载和存储指令</h2><p>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输</p>\n<h2 id=\"运算指令\"><a href=\"#运算指令\" class=\"headerlink\" title=\"运算指令\"></a>运算指令</h2><p>用于对操作数栈上的两个值进行某种特定运算，并且把结果重新存入操作栈顶</p>\n<p>大致分为两种类型：对整数数据，浮点型数据</p>\n<p>不存在直接支持byte,short,char,boolean的运算，都是用操作int类型的指令代替</p>\n<h2 id=\"类型转换指令\"><a href=\"#类型转换指令\" class=\"headerlink\" title=\"类型转换指令\"></a>类型转换指令</h2><ol>\n<li>将两种不同的数据类型相互转换，实现用户代码中的显式类型转换</li>\n<li>小范围到大范围类型为安全转换，无须显示的转换指令，如<code>int 转 long,float,double</code>,<code>long转folat,double</code>,<code>float转double</code></li>\n<li>int转long，只会简单的将高位抛弃，所以可能导致不同的正负号</li>\n<li>转换可能出现上限溢出，下限溢出，精度丢失等等，但永远不可能导致虚拟机抛出运行时异常</li>\n</ol>\n<h2 id=\"对象创建与访问指令\"><a href=\"#对象创建与访问指令\" class=\"headerlink\" title=\"对象创建与访问指令\"></a>对象创建与访问指令</h2><p>Java虚拟机对类实例和数组的创建使用了不同的字节码指令</p>\n<h2 id=\"操作数栈管理指令\"><a href=\"#操作数栈管理指令\" class=\"headerlink\" title=\"操作数栈管理指令\"></a>操作数栈管理指令</h2><p>将操作数栈顶一个或者两个元素出栈：pop,pop2</p>\n<p>将栈顶最顶端两个数值交换：swap</p>\n<h2 id=\"控制转移指令\"><a href=\"#控制转移指令\" class=\"headerlink\" title=\"控制转移指令\"></a>控制转移指令</h2><p>有条件或无条件的修改PC寄存器的值，从指定位置指令的下一条指令继续执行程序</p>\n<p>各种类型的比较最终都会转化为int类型的比较操作</p>\n<h2 id=\"方法调用和返回指令\"><a href=\"#方法调用和返回指令\" class=\"headerlink\" title=\"方法调用和返回指令\"></a>方法调用和返回指令</h2><ol>\n<li><code>invokevirtual</code>:用于调用对象的实例方法,根据对象的实际类型进行分派(虚方法分派)</li>\n<li><code>invokeinterface</code>:用于调用接口方法,在运行时搜索一个实现了这个接口方法的对象,找出合适的方法调用</li>\n<li><code>invokespecial</code>:调用一些需要特殊处理的实例方法,例如实例初始化方法,私有方法,父类方法</li>\n<li><code>invokestatic</code>:用于调用静态方法(static)方法</li>\n<li><code>invokedynamic</code>:用于在运行时动态解析出调用点限定符所引用的方法</li>\n<li>方法返回指令是根据返回值的类型区分的.包括ireturn(返回类型是boolean,byte,char,short,int),lreturn,freturn,dreturn,areturn,return(返回值为void的,实例初始化的,类和接口的类初始化方法)</li>\n</ol>\n<h2 id=\"异常处理指令\"><a href=\"#异常处理指令\" class=\"headerlink\" title=\"异常处理指令\"></a>异常处理指令</h2><p>对显示抛出异常的操作（throw语句）进行处理</p>\n<p>而处理异常（catch语句）不由字节码指令实现，是由异常表实现</p>\n<h2 id=\"同步指令\"><a href=\"#同步指令\" class=\"headerlink\" title=\"同步指令\"></a>同步指令</h2><p>Java虚拟机可以支持方法级同步和方法内部一段指令序列的同步,使用管程实现.</p>\n<p>执行线程要求先成功持有管程,然后才能执行方法,最后当方法完成时释放管程</p>\n<p>使用synchronized语句块表示</p>\n<p>无论这个方法是正常结束还是异常退出,方法调用的每条monitorenter指令都必须有其对应的monitorexit指令</p>\n<h1 id=\"公有设计，私有实现\"><a href=\"#公有设计，私有实现\" class=\"headerlink\" title=\"公有设计，私有实现\"></a>公有设计，私有实现</h1><p>&lt;&lt;Java虚拟机规范&gt;&gt;描绘了Java虚拟机应有的共同程序存储格</p>\n<p>式：Class文件格式以及字节码指令集</p>\n<p>任何一款Java虚拟机都必须能读取Class文件并且精确实现其中的Java虚拟机代码的语义</p>\n<p>Java虚拟机只要外部接口与规范描述一致即可，具体实现不规定</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>Class文件格式具备平台中立，紧凑，稳定，可扩展性的特点。是Java技术体系实现平台无关，语言无关的重要支柱</p>\n<p>Class文件是Java虚拟机执行引擎的数据入口。</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"Class类文件的结构\"><a href=\"#Class类文件的结构\" class=\"headerlink\" title=\"Class类文件的结构\"></a>Class类文件的结构</h1><ol>\n<li>以八个字节为基础单位的二进制流</li>\n<li>无符号数为基本数据类型。以u1,u2,u4,u8分别代表1字节，2字节，4字节，8字节的无符号数</li>\n<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型。习惯以_info结尾</li>\n</ol>\n<h2 id=\"魔数与Class文件的版本\"><a href=\"#魔数与Class文件的版本\" class=\"headerlink\" title=\"魔数与Class文件的版本\"></a>魔数与Class文件的版本</h2><ol>\n<li>头四个字节为魔数，标识他为Class文件。值为0xCAFEBABE</li>\n<li>后面四个字节为版本号。前两个为次版本号（Minor Version）,后两个为主版本号（Minor Version）。次版本号基本未使用，固定为0。主版本号从45开始。</li>\n<li>高版本JDK能向下兼容以前的Class文件但是不能运行之后版本的Class文件</li>\n<li>例如JDK1.1能支持的版本号为:<code>45.0-45.65535</code>,JDK1.2支持<code>45.0-46.65535</code></li>\n</ol>\n<h2 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h2><ol>\n<li>主要存放字面量和符号引用。字面量类似常量，如文本字符串，被声明为final的常量值等等。符号引用属于编译原理相关，包括全限定类名，方法字段名称等等</li>\n<li>符号引用不经过虚拟机运行期转换就无法得到真正的内存入口地址，就无法被虚拟机直接使用。当虚拟机做类加载时，将从常量池获取相应的符号引用，再在类创建时或运行时解析翻译到具体的内存地址中。</li>\n</ol>\n<h3 id=\"CONSTANT-Class-info\"><a href=\"#CONSTANT-Class-info\" class=\"headerlink\" title=\"CONSTANT_Class_info\"></a>CONSTANT_Class_info</h3><ol>\n<li>用u1存储tag，标识常量类型</li>\n<li>用u2存储name_index,是常量池的索引值，指向一个CONSTANT_Utf8_info类型常量，代表了该类的全限定名。</li>\n</ol>\n<h3 id=\"CONSTANT-Utf8-info\"><a href=\"#CONSTANT-Utf8-info\" class=\"headerlink\" title=\"CONSTANT_Utf8_info\"></a>CONSTANT_Utf8_info</h3><ol>\n<li>用u1存储tag，标识常量类型</li>\n<li>用u2存储length，代表字符串长度是多少字节</li>\n<li>之后是用u1存储bytes，一共有length个字节</li>\n</ol>\n<h2 id=\"访问标志\"><a href=\"#访问标志\" class=\"headerlink\" title=\"访问标志\"></a>访问标志</h2><p>常量池之后两个字节代表访问标志。例如：是类还是接口，是否是public，是否是abstract等等</p>\n<h2 id=\"类索引，父类索引，接口索引集合\"><a href=\"#类索引，父类索引，接口索引集合\" class=\"headerlink\" title=\"类索引，父类索引，接口索引集合\"></a>类索引，父类索引，接口索引集合</h2><ol>\n<li>类索引，父类索引为u2类型的数据，接口索引集合为u2类型的数据集合。由此确定该类型的继承关系。</li>\n<li>类索引，父类索引用u2类型的索引值表示，各自指向一个<code>CONSTANT_Class_info</code>的类描述符常量。又通过该常量的<code>CONSTANT_Utf8_info</code>找到全限定名字符串。</li>\n<li>接口索引集合第一项的u2类型的数据为接口计数器，表示索引表的容量。</li>\n</ol>\n<h2 id=\"字段表集合\"><a href=\"#字段表集合\" class=\"headerlink\" title=\"字段表集合\"></a>字段表集合</h2><ol>\n<li>描述变量，包括类级变量，实例级变量，但不包括方法中的局部变量。</li>\n<li>字段包括: 修饰符<code>（public，private,protected,static,final,volatile,transient）</code>,字符数据类型（基本类型，对象，数组）,字段名称</li>\n<li>修饰符适合用标志位表示，但字符数据类型，字段名称只能引用常量池中的常量来描述</li>\n<li>字符修饰符用u2,access_flags表示。之后是u2的name_index,descriptor_index是对常量池的引用，代表了字段的简单名称和方法的描述符。</li>\n<li>描述符用来描述字段的数据类型，方法的参数列表和返回值。基本数据类型类型和void用一个大写字符表示。例如C代表char。对象类型用L加对象的全限定名表示，例如Ljava/lang/Object;</li>\n<li>数组每一维度用一个<code>[</code>表示，如定义了<code>java.lang.String [][]</code>则记录为<code>[[Ljava/lang/String;</code></li>\n<li>用描述符描述方法，则先参照列表，再返回值的顺序描述。例如<code>String test(char [] chars)</code>为   <code>([C)[Ljava/lang/String;</code></li>\n<li>字段表集合不会列出从父类或者父接口中继承来的字段。但有可能出现Java代码中不存在的字段。例如编译器为内部类自动添加指向外部类实例的字段。</li>\n</ol>\n<h2 id=\"方法表集合\"><a href=\"#方法表集合\" class=\"headerlink\" title=\"方法表集合\"></a>方法表集合</h2><ol>\n<li>和字段表集合极其相似。没有<code>volatile,transient</code>,但多了<code>synchronized,native,strictfp,abstract</code>关键字</li>\n<li>方法中的代码，存放再方法属性表集合中名为<code>Code</code>的属性里面</li>\n<li>若子类没有重写父类方法，则不会出现父类方法信息</li>\n<li>有可能出现由编译器自动添加的方法，例如类构造器<code>&lt;cinit&gt;()</code>,实例构造器<code>&lt;init&gt;()</code>方法</li>\n</ol>\n<h2 id=\"属性表集合\"><a href=\"#属性表集合\" class=\"headerlink\" title=\"属性表集合\"></a>属性表集合</h2><p>Class文件，字段表，方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p>\n<h3 id=\"Code属性\"><a href=\"#Code属性\" class=\"headerlink\" title=\"Code属性\"></a>Code属性</h3><ol>\n<li>方法体中代码经过Javac编译器处理后，变成字节码指令存储在Code属性中</li>\n<li><code>attribute_name_index</code>是指向<code>CONSTANT_Utf8_info</code>的索引，固定为”Code”，代表该属性名称</li>\n<li><code>attribute_length</code>指示了属性值的长度，为u4</li>\n<li><code>max_stack</code>代表了操作数栈深度的最大值。根据该值来分配栈帧中的操作数栈深度。</li>\n<li><code>max_locals</code>代表了局部变量表所需的存储空间。单位是Slot（变量槽），变量槽是虚拟机为局部变量分配内存所使用的最小单位。不超过32位的一个槽，double和long占用两个槽。</li>\n<li>方法参数（包括实例方法隐藏参数this），异常参数，方法体中的局部变量都依赖局部变量表存储</li>\n<li>虚拟机将局部变量表中的变量槽复用。当代码执行超出了一个局部变量的作用域时，该局部变量所占的变量槽可以被其他局部变量使用。根据同时生成的最大局部变量数量和类型算出<code>max_locals</code>的大小</li>\n<li><code>code_length</code>,<code>code</code>存储Java源程序编译后生成的字节码指令。每个指令是u1的单字节。可以对应找出该字节码代表什么指令。</li>\n<li>Code属性用于描述代码，其他项目用于描述元数据。</li>\n<li>任何实例方法里面，都可以通过this访问到该方法所属的对象。是通过编译器编译时把对this关键字的访问转变位对一个普通方法参数的访问，虚拟机在调用实例方法时自动传入此参数。因此任何实例方法的局部变量表至少存在一个指向当前对象实例的局部变量。局部变量表也会预留出第一个变量槽位来存放实例对象的引用。</li>\n<li>异常表，当字节码从第<code>start_pc</code>到第<code>end_pc</code>出现了类型为<code>catch_type</code>或其子类的异常，则转到第<code>handle_pc</code>行继续处理。</li>\n</ol>\n<h3 id=\"Exceptions属性\"><a href=\"#Exceptions属性\" class=\"headerlink\" title=\"Exceptions属性\"></a>Exceptions属性</h3><p>列举出方法中可能抛出的受查异常。即方法中throws后面列举的异常。</p>\n<h3 id=\"LineNumberTable属性\"><a href=\"#LineNumberTable属性\" class=\"headerlink\" title=\"LineNumberTable属性\"></a>LineNumberTable属性</h3><p>描述Java源码行号和字节码行号的对应关系。非必须，但如果没有，抛出异常时不会显示出错行号，调试程序也无法按照源码设置断点。</p>\n<h3 id=\"LocalVariableTable和LocalVariableTypeTable属性\"><a href=\"#LocalVariableTable和LocalVariableTypeTable属性\" class=\"headerlink\" title=\"LocalVariableTable和LocalVariableTypeTable属性\"></a>LocalVariableTable和LocalVariableTypeTable属性</h3><p>描述栈帧中局部变量表的变量和Java源码中定义的变量之间的关系。非必须，但没有当其他人引用方法，所有参数名称将会丢失，用arg0,arg1等替代参数名。</p>\n<h3 id=\"SourceFile属性\"><a href=\"#SourceFile属性\" class=\"headerlink\" title=\"SourceFile属性\"></a>SourceFile属性</h3><p>用于记录生成这个Class文件的源码文件名称.大多数类,类名和文件名一致,但有例外。</p>\n<h3 id=\"ConstantValue属性\"><a href=\"#ConstantValue属性\" class=\"headerlink\" title=\"ConstantValue属性\"></a>ConstantValue属性</h3><ol>\n<li>通知虚拟机自动为静态变量赋值。</li>\n<li>对实例变量赋值再<init>()方法中。</li>\n<li>对于类变量，若是final，static修饰，并且是基本类型或者String的话,用<code>ConstantValue</code>进行初始化。否则会选择在<code>&lt;cinit()</code>方法初始化。</li>\n</ol>\n<h3 id=\"InnerClasses属性\"><a href=\"#InnerClasses属性\" class=\"headerlink\" title=\"InnerClasses属性\"></a>InnerClasses属性</h3><p>用于记录内部类和宿主类之间的关联。</p>\n<h3 id=\"Deprecated及Synthetic属性\"><a href=\"#Deprecated及Synthetic属性\" class=\"headerlink\" title=\"Deprecated及Synthetic属性\"></a>Deprecated及Synthetic属性</h3><p>Deprecated属性用于表示某个类，字段或者方法，已经被程序作者定为不再推荐使用。可以用<code>@deprecated</code>注解进行设置。</p>\n<p>Synthetic属性标识此字段或方法不是由Java源码直接产生的，而是由编译器自行添加的。</p>\n<h3 id=\"StackMapTable属性\"><a href=\"#StackMapTable属性\" class=\"headerlink\" title=\"StackMapTable属性\"></a>StackMapTable属性</h3><p>在虚拟机类加载的字节码验证阶段被新类型检查验证器使用。</p>\n<h3 id=\"Signature属性\"><a href=\"#Signature属性\" class=\"headerlink\" title=\"Signature属性\"></a>Signature属性</h3><p>若包含了类型变量或参数化类型，则该属性会为他记录泛型签名信息</p>\n<h3 id=\"BootStrapMethods属性\"><a href=\"#BootStrapMethods属性\" class=\"headerlink\" title=\"BootStrapMethods属性\"></a>BootStrapMethods属性</h3><p>保存<code>invokedynamic</code>指令引用的引导方法限定符</p>\n<h3 id=\"MethodParameters属性\"><a href=\"#MethodParameters属性\" class=\"headerlink\" title=\"MethodParameters属性\"></a>MethodParameters属性</h3><p>记录方法的各个形参名称和信息</p>\n<h3 id=\"模块化相关属性\"><a href=\"#模块化相关属性\" class=\"headerlink\" title=\"模块化相关属性\"></a>模块化相关属性</h3><p>支持Java模块化相关功能</p>\n<h3 id=\"运行时注解相关属性\"><a href=\"#运行时注解相关属性\" class=\"headerlink\" title=\"运行时注解相关属性\"></a>运行时注解相关属性</h3><p>记录了类,字段,方法的声明上记录运行时可见注解</p>\n<h1 id=\"字节码指令简介\"><a href=\"#字节码指令简介\" class=\"headerlink\" title=\"字节码指令简介\"></a>字节码指令简介</h1><p>由一个字节长度的操作码和零或多个的操作数构成.是面向操作数栈的,所以大多数指令不包括操作数,只有操作码.指令参数都放在操作数栈中。</p>\n<h2 id=\"字节码与数据类型\"><a href=\"#字节码与数据类型\" class=\"headerlink\" title=\"字节码与数据类型\"></a>字节码与数据类型</h2><ol>\n<li>iload指令用于从局部变量表中加载int型的数据到操作数栈中</li>\n<li>大多数指令没有支持byte,char,short,boolean。编译器会在编译或者运行期将他们扩展为int型数据</li>\n</ol>\n<h2 id=\"加载和存储指令\"><a href=\"#加载和存储指令\" class=\"headerlink\" title=\"加载和存储指令\"></a>加载和存储指令</h2><p>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输</p>\n<h2 id=\"运算指令\"><a href=\"#运算指令\" class=\"headerlink\" title=\"运算指令\"></a>运算指令</h2><p>用于对操作数栈上的两个值进行某种特定运算，并且把结果重新存入操作栈顶</p>\n<p>大致分为两种类型：对整数数据，浮点型数据</p>\n<p>不存在直接支持byte,short,char,boolean的运算，都是用操作int类型的指令代替</p>\n<h2 id=\"类型转换指令\"><a href=\"#类型转换指令\" class=\"headerlink\" title=\"类型转换指令\"></a>类型转换指令</h2><ol>\n<li>将两种不同的数据类型相互转换，实现用户代码中的显式类型转换</li>\n<li>小范围到大范围类型为安全转换，无须显示的转换指令，如<code>int 转 long,float,double</code>,<code>long转folat,double</code>,<code>float转double</code></li>\n<li>int转long，只会简单的将高位抛弃，所以可能导致不同的正负号</li>\n<li>转换可能出现上限溢出，下限溢出，精度丢失等等，但永远不可能导致虚拟机抛出运行时异常</li>\n</ol>\n<h2 id=\"对象创建与访问指令\"><a href=\"#对象创建与访问指令\" class=\"headerlink\" title=\"对象创建与访问指令\"></a>对象创建与访问指令</h2><p>Java虚拟机对类实例和数组的创建使用了不同的字节码指令</p>\n<h2 id=\"操作数栈管理指令\"><a href=\"#操作数栈管理指令\" class=\"headerlink\" title=\"操作数栈管理指令\"></a>操作数栈管理指令</h2><p>将操作数栈顶一个或者两个元素出栈：pop,pop2</p>\n<p>将栈顶最顶端两个数值交换：swap</p>\n<h2 id=\"控制转移指令\"><a href=\"#控制转移指令\" class=\"headerlink\" title=\"控制转移指令\"></a>控制转移指令</h2><p>有条件或无条件的修改PC寄存器的值，从指定位置指令的下一条指令继续执行程序</p>\n<p>各种类型的比较最终都会转化为int类型的比较操作</p>\n<h2 id=\"方法调用和返回指令\"><a href=\"#方法调用和返回指令\" class=\"headerlink\" title=\"方法调用和返回指令\"></a>方法调用和返回指令</h2><ol>\n<li><code>invokevirtual</code>:用于调用对象的实例方法,根据对象的实际类型进行分派(虚方法分派)</li>\n<li><code>invokeinterface</code>:用于调用接口方法,在运行时搜索一个实现了这个接口方法的对象,找出合适的方法调用</li>\n<li><code>invokespecial</code>:调用一些需要特殊处理的实例方法,例如实例初始化方法,私有方法,父类方法</li>\n<li><code>invokestatic</code>:用于调用静态方法(static)方法</li>\n<li><code>invokedynamic</code>:用于在运行时动态解析出调用点限定符所引用的方法</li>\n<li>方法返回指令是根据返回值的类型区分的.包括ireturn(返回类型是boolean,byte,char,short,int),lreturn,freturn,dreturn,areturn,return(返回值为void的,实例初始化的,类和接口的类初始化方法)</li>\n</ol>\n<h2 id=\"异常处理指令\"><a href=\"#异常处理指令\" class=\"headerlink\" title=\"异常处理指令\"></a>异常处理指令</h2><p>对显示抛出异常的操作（throw语句）进行处理</p>\n<p>而处理异常（catch语句）不由字节码指令实现，是由异常表实现</p>\n<h2 id=\"同步指令\"><a href=\"#同步指令\" class=\"headerlink\" title=\"同步指令\"></a>同步指令</h2><p>Java虚拟机可以支持方法级同步和方法内部一段指令序列的同步,使用管程实现.</p>\n<p>执行线程要求先成功持有管程,然后才能执行方法,最后当方法完成时释放管程</p>\n<p>使用synchronized语句块表示</p>\n<p>无论这个方法是正常结束还是异常退出,方法调用的每条monitorenter指令都必须有其对应的monitorexit指令</p>\n<h1 id=\"公有设计，私有实现\"><a href=\"#公有设计，私有实现\" class=\"headerlink\" title=\"公有设计，私有实现\"></a>公有设计，私有实现</h1><p>&lt;&lt;Java虚拟机规范&gt;&gt;描绘了Java虚拟机应有的共同程序存储格</p>\n<p>式：Class文件格式以及字节码指令集</p>\n<p>任何一款Java虚拟机都必须能读取Class文件并且精确实现其中的Java虚拟机代码的语义</p>\n<p>Java虚拟机只要外部接口与规范描述一致即可，具体实现不规定</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>Class文件格式具备平台中立，紧凑，稳定，可扩展性的特点。是Java技术体系实现平台无关，语言无关的重要支柱</p>\n<p>Class文件是Java虚拟机执行引擎的数据入口。</p>\n"},{"title":"Java基础--JavaWeb","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"Java基础知识之JavaWeb,待完善,之后再看的时候会继续补充。","abbrlink":"582aa7a5","date":"2020-03-24T16:00:00.000Z","_content":"\n1. `BeanPropertyRowMapper<User>(User.class)`封装必须数据库和类的字段名字一样，不然会封装为null，且如果没有匹配会报错\n2. session和直接存储attribute的不同，作用域不一样。request.setAttribute()是只在此action的下一个forward需要使用的时候使用；session.setAttribute 作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。\n3. 导入的jar包直接放在web-INF的lib目录下，不要再分细的包，不然不行\n4. maven管理jar包，依赖的jar直接添加在已经给的dependences里面，不然不行\n5. 直接在右边maven里面，toncat:run就行\n6. 加scope不然包冲突\n7. 设置jdk，不然可能用不了，继续在pom插件，添加了模板jdk_use，可以直接使用了\n8. 还要设置tomcat7(设置了快捷键tomcat7)，不然跑不了，然后运行 tomcat7:run\n9. jedis操作的时候，要开启redis的server和client\n10. 自己的服务器安装了mysql之后,得再阿里云开放3306端口\n11. JDBCUtils.class.getResourceAsStream,无论如何都找到了\n12. mysql设置编码,插入中文\n13. 新建maven项目,在pom.xml里面配置jdk和tomcat7,jar包配置,试跑一下\n14. 做好大概的思维导图,大致明确逻辑,建好层级目录\n15. 先放入几个util类,新建数据库,实现User,Userdao,并测试\n16. 导入jquery,css,boostrap等\n17. 写注册页面的基本表单\n18. 正则表达式简单校验输入内容\n19. 不支持发行版本5 settings中找到java compiler 将右边改成jdk9,直接快捷键jdk9\n20. oracle不支持:mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=D:\\Oracle_10g_10.2.0.4_JDBC_ojdbc14.jar\n21. idea静态资源热部署,[https://bbs.csdn.net/topics/392365951?list=9345374](https://bbs.csdn.net/topics/392365951?list=9345374)\n\n热部署后,运行,刷新的时候按ctrl+F9就行了\n\n22. ```\n\t#mybatis版本问题,不加这个不会自动扫描包\n\tmybatis.type-aliases-package=com.tongji\n\t```\n\n23. 有时pom不主动下依赖,就maven-clean再maven-install\n\n24. 还报错就reload项目\n\n25. springboot热启动:ctrl+F9\n\n26. BeanPropertyRowMapper<User>(User.class)封装必须数据库和类的字段名字一样，不然会封装为null，且如果没有匹配会报错\n\n27. session和直接存储attribute的不同，作用域不一样。request.setAttribute()是只在此action的下一个forward需要使用的时候使用；session.setAttribute 作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。\n\n28. 导入的jar包直接放在web-INF的lib目录下，不要再分细的包，不然不行\n\n29. maven管理jar包，依赖的jar直接添加在已经给的dependences里面，不然不行\n\n30. 直接在右边maven里面，toncat:run就行\n\n31. 加scope不然包冲突\n\n32. 设置jdk，不然可能用不了，继续在pom插件，添加了模板jdk_use，可以直接使用了\n\n33. 还要设置tomcat7(设置了快捷键tomcat7)，不然跑不了，然后运行 tomcat7:run\n\n34. jedis操作的时候，要开启redis的server和client\n\n35. 自己的服务器安装了mysql之后,得再阿里云开放3306端口\n\n36. JDBCUtils.class.getResourceAsStream,无论如何都找到了\n\n37. mysql设置编码,插入中文\n\n38. 新建maven项目,在pom.xml里面配置jdk和tomcat7,jar包配置,试跑一下\n\n39. 做好大概的思维导图,大致明确逻辑,建好层级目录\n\n40. 先放入几个util类,新建数据库,实现User,Userdao,并测试\n\n41. 导入jquery,css,boostrap等\n\n42. 写注册页面的基本表单\n\n43. 正则表达式简单校验输入内容\n\n44. settings code templates other web servlet Annotated给servlet加上doPost\n\n45. mysql安装:设置用户名,密码,然后配置环境变量:\n\n\t> 环境变量-系统变量-添加 C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin\n\n46. maven镜像: C:\\Users\\12549\\.m2 下新建settings.xml文件,复制其他地方的内容进去,并且在mirrors标签下添加:\n\n\t```\n\t<mirror>\n\t      <id>nexus-aliyun</id>\n\t      <mirrorOf>central</mirrorOf>\n\t      <name>Nexus aliyun</name>\n\t      <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n\t</mirror>\n\t\n\t```\n\n\t","source":"_posts/Java笔记/Javaweb踩过的坑.md","raw":"---\ntitle: Java基础--JavaWeb\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 'Java基础知识之JavaWeb,待完善,之后再看的时候会继续补充。'\ncategories: Java基础\ntags:\n  - Java基础\n  - JavaWeb\nabbrlink: 582aa7a5\ndate: 2020-03-25 00:00:00\n---\n\n1. `BeanPropertyRowMapper<User>(User.class)`封装必须数据库和类的字段名字一样，不然会封装为null，且如果没有匹配会报错\n2. session和直接存储attribute的不同，作用域不一样。request.setAttribute()是只在此action的下一个forward需要使用的时候使用；session.setAttribute 作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。\n3. 导入的jar包直接放在web-INF的lib目录下，不要再分细的包，不然不行\n4. maven管理jar包，依赖的jar直接添加在已经给的dependences里面，不然不行\n5. 直接在右边maven里面，toncat:run就行\n6. 加scope不然包冲突\n7. 设置jdk，不然可能用不了，继续在pom插件，添加了模板jdk_use，可以直接使用了\n8. 还要设置tomcat7(设置了快捷键tomcat7)，不然跑不了，然后运行 tomcat7:run\n9. jedis操作的时候，要开启redis的server和client\n10. 自己的服务器安装了mysql之后,得再阿里云开放3306端口\n11. JDBCUtils.class.getResourceAsStream,无论如何都找到了\n12. mysql设置编码,插入中文\n13. 新建maven项目,在pom.xml里面配置jdk和tomcat7,jar包配置,试跑一下\n14. 做好大概的思维导图,大致明确逻辑,建好层级目录\n15. 先放入几个util类,新建数据库,实现User,Userdao,并测试\n16. 导入jquery,css,boostrap等\n17. 写注册页面的基本表单\n18. 正则表达式简单校验输入内容\n19. 不支持发行版本5 settings中找到java compiler 将右边改成jdk9,直接快捷键jdk9\n20. oracle不支持:mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=D:\\Oracle_10g_10.2.0.4_JDBC_ojdbc14.jar\n21. idea静态资源热部署,[https://bbs.csdn.net/topics/392365951?list=9345374](https://bbs.csdn.net/topics/392365951?list=9345374)\n\n热部署后,运行,刷新的时候按ctrl+F9就行了\n\n22. ```\n\t#mybatis版本问题,不加这个不会自动扫描包\n\tmybatis.type-aliases-package=com.tongji\n\t```\n\n23. 有时pom不主动下依赖,就maven-clean再maven-install\n\n24. 还报错就reload项目\n\n25. springboot热启动:ctrl+F9\n\n26. BeanPropertyRowMapper<User>(User.class)封装必须数据库和类的字段名字一样，不然会封装为null，且如果没有匹配会报错\n\n27. session和直接存储attribute的不同，作用域不一样。request.setAttribute()是只在此action的下一个forward需要使用的时候使用；session.setAttribute 作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。\n\n28. 导入的jar包直接放在web-INF的lib目录下，不要再分细的包，不然不行\n\n29. maven管理jar包，依赖的jar直接添加在已经给的dependences里面，不然不行\n\n30. 直接在右边maven里面，toncat:run就行\n\n31. 加scope不然包冲突\n\n32. 设置jdk，不然可能用不了，继续在pom插件，添加了模板jdk_use，可以直接使用了\n\n33. 还要设置tomcat7(设置了快捷键tomcat7)，不然跑不了，然后运行 tomcat7:run\n\n34. jedis操作的时候，要开启redis的server和client\n\n35. 自己的服务器安装了mysql之后,得再阿里云开放3306端口\n\n36. JDBCUtils.class.getResourceAsStream,无论如何都找到了\n\n37. mysql设置编码,插入中文\n\n38. 新建maven项目,在pom.xml里面配置jdk和tomcat7,jar包配置,试跑一下\n\n39. 做好大概的思维导图,大致明确逻辑,建好层级目录\n\n40. 先放入几个util类,新建数据库,实现User,Userdao,并测试\n\n41. 导入jquery,css,boostrap等\n\n42. 写注册页面的基本表单\n\n43. 正则表达式简单校验输入内容\n\n44. settings code templates other web servlet Annotated给servlet加上doPost\n\n45. mysql安装:设置用户名,密码,然后配置环境变量:\n\n\t> 环境变量-系统变量-添加 C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin\n\n46. maven镜像: C:\\Users\\12549\\.m2 下新建settings.xml文件,复制其他地方的内容进去,并且在mirrors标签下添加:\n\n\t```\n\t<mirror>\n\t      <id>nexus-aliyun</id>\n\t      <mirrorOf>central</mirrorOf>\n\t      <name>Nexus aliyun</name>\n\t      <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n\t</mirror>\n\t\n\t```\n\n\t","slug":"Java笔记/Javaweb踩过的坑","published":1,"updated":"2020-11-12T11:57:29.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6vw000kjotph3o36sj4","content":"<ol>\n<li><code>BeanPropertyRowMapper&lt;User&gt;(User.class)</code>封装必须数据库和类的字段名字一样，不然会封装为null，且如果没有匹配会报错</li>\n<li>session和直接存储attribute的不同，作用域不一样。request.setAttribute()是只在此action的下一个forward需要使用的时候使用；session.setAttribute 作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。</li>\n<li>导入的jar包直接放在web-INF的lib目录下，不要再分细的包，不然不行</li>\n<li>maven管理jar包，依赖的jar直接添加在已经给的dependences里面，不然不行</li>\n<li>直接在右边maven里面，toncat:run就行</li>\n<li>加scope不然包冲突</li>\n<li>设置jdk，不然可能用不了，继续在pom插件，添加了模板jdk_use，可以直接使用了</li>\n<li>还要设置tomcat7(设置了快捷键tomcat7)，不然跑不了，然后运行 tomcat7:run</li>\n<li>jedis操作的时候，要开启redis的server和client</li>\n<li>自己的服务器安装了mysql之后,得再阿里云开放3306端口</li>\n<li>JDBCUtils.class.getResourceAsStream,无论如何都找到了</li>\n<li>mysql设置编码,插入中文</li>\n<li>新建maven项目,在pom.xml里面配置jdk和tomcat7,jar包配置,试跑一下</li>\n<li>做好大概的思维导图,大致明确逻辑,建好层级目录</li>\n<li>先放入几个util类,新建数据库,实现User,Userdao,并测试</li>\n<li>导入jquery,css,boostrap等</li>\n<li>写注册页面的基本表单</li>\n<li>正则表达式简单校验输入内容</li>\n<li>不支持发行版本5 settings中找到java compiler 将右边改成jdk9,直接快捷键jdk9</li>\n<li>oracle不支持:mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=D:\\Oracle_10g_10.2.0.4_JDBC_ojdbc14.jar</li>\n<li>idea静态资源热部署,<a href=\"https://bbs.csdn.net/topics/392365951?list=9345374\" target=\"_blank\" rel=\"noopener\">https://bbs.csdn.net/topics/392365951?list=9345374</a></li>\n</ol>\n<p>热部署后,运行,刷新的时候按ctrl+F9就行了</p>\n<ol start=\"22\">\n<li><pre><code>#mybatis版本问题,不加这个不会自动扫描包\nmybatis.type-aliases-package=com.tongji</code></pre>\n</li>\n<li><p>有时pom不主动下依赖,就maven-clean再maven-install</p>\n</li>\n<li><p>还报错就reload项目</p>\n</li>\n<li><p>springboot热启动:ctrl+F9</p>\n</li>\n<li><p>BeanPropertyRowMapper<User>(User.class)封装必须数据库和类的字段名字一样，不然会封装为null，且如果没有匹配会报错</p>\n</li>\n<li><p>session和直接存储attribute的不同，作用域不一样。request.setAttribute()是只在此action的下一个forward需要使用的时候使用；session.setAttribute 作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。</p>\n</li>\n<li><p>导入的jar包直接放在web-INF的lib目录下，不要再分细的包，不然不行</p>\n</li>\n<li><p>maven管理jar包，依赖的jar直接添加在已经给的dependences里面，不然不行</p>\n</li>\n<li><p>直接在右边maven里面，toncat:run就行</p>\n</li>\n<li><p>加scope不然包冲突</p>\n</li>\n<li><p>设置jdk，不然可能用不了，继续在pom插件，添加了模板jdk_use，可以直接使用了</p>\n</li>\n<li><p>还要设置tomcat7(设置了快捷键tomcat7)，不然跑不了，然后运行 tomcat7:run</p>\n</li>\n<li><p>jedis操作的时候，要开启redis的server和client</p>\n</li>\n<li><p>自己的服务器安装了mysql之后,得再阿里云开放3306端口</p>\n</li>\n<li><p>JDBCUtils.class.getResourceAsStream,无论如何都找到了</p>\n</li>\n<li><p>mysql设置编码,插入中文</p>\n</li>\n<li><p>新建maven项目,在pom.xml里面配置jdk和tomcat7,jar包配置,试跑一下</p>\n</li>\n<li><p>做好大概的思维导图,大致明确逻辑,建好层级目录</p>\n</li>\n<li><p>先放入几个util类,新建数据库,实现User,Userdao,并测试</p>\n</li>\n<li><p>导入jquery,css,boostrap等</p>\n</li>\n<li><p>写注册页面的基本表单</p>\n</li>\n<li><p>正则表达式简单校验输入内容</p>\n</li>\n<li><p>settings code templates other web servlet Annotated给servlet加上doPost</p>\n</li>\n<li><p>mysql安装:设置用户名,密码,然后配置环境变量:</p>\n<blockquote>\n<p>环境变量-系统变量-添加 C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin</p>\n</blockquote>\n</li>\n<li><p>maven镜像: C:\\Users\\12549.m2 下新建settings.xml文件,复制其他地方的内容进去,并且在mirrors标签下添加:</p>\n<pre><code>&lt;mirror&gt;\n      &lt;id&gt;nexus-aliyun&lt;/id&gt;\n      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n      &lt;name&gt;Nexus aliyun&lt;/name&gt;\n      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;\n&lt;/mirror&gt;\n</code></pre>\n</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<ol>\n<li><code>BeanPropertyRowMapper&lt;User&gt;(User.class)</code>封装必须数据库和类的字段名字一样，不然会封装为null，且如果没有匹配会报错</li>\n<li>session和直接存储attribute的不同，作用域不一样。request.setAttribute()是只在此action的下一个forward需要使用的时候使用；session.setAttribute 作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。</li>\n<li>导入的jar包直接放在web-INF的lib目录下，不要再分细的包，不然不行</li>\n<li>maven管理jar包，依赖的jar直接添加在已经给的dependences里面，不然不行</li>\n<li>直接在右边maven里面，toncat:run就行</li>\n<li>加scope不然包冲突</li>\n<li>设置jdk，不然可能用不了，继续在pom插件，添加了模板jdk_use，可以直接使用了</li>\n<li>还要设置tomcat7(设置了快捷键tomcat7)，不然跑不了，然后运行 tomcat7:run</li>\n<li>jedis操作的时候，要开启redis的server和client</li>\n<li>自己的服务器安装了mysql之后,得再阿里云开放3306端口</li>\n<li>JDBCUtils.class.getResourceAsStream,无论如何都找到了</li>\n<li>mysql设置编码,插入中文</li>\n<li>新建maven项目,在pom.xml里面配置jdk和tomcat7,jar包配置,试跑一下</li>\n<li>做好大概的思维导图,大致明确逻辑,建好层级目录</li>\n<li>先放入几个util类,新建数据库,实现User,Userdao,并测试</li>\n<li>导入jquery,css,boostrap等</li>\n<li>写注册页面的基本表单</li>\n<li>正则表达式简单校验输入内容</li>\n<li>不支持发行版本5 settings中找到java compiler 将右边改成jdk9,直接快捷键jdk9</li>\n<li>oracle不支持:mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=D:\\Oracle_10g_10.2.0.4_JDBC_ojdbc14.jar</li>\n<li>idea静态资源热部署,<a href=\"https://bbs.csdn.net/topics/392365951?list=9345374\" target=\"_blank\" rel=\"noopener\">https://bbs.csdn.net/topics/392365951?list=9345374</a></li>\n</ol>\n<p>热部署后,运行,刷新的时候按ctrl+F9就行了</p>\n<ol start=\"22\">\n<li><pre><code>#mybatis版本问题,不加这个不会自动扫描包\nmybatis.type-aliases-package=com.tongji</code></pre>\n</li>\n<li><p>有时pom不主动下依赖,就maven-clean再maven-install</p>\n</li>\n<li><p>还报错就reload项目</p>\n</li>\n<li><p>springboot热启动:ctrl+F9</p>\n</li>\n<li><p>BeanPropertyRowMapper<User>(User.class)封装必须数据库和类的字段名字一样，不然会封装为null，且如果没有匹配会报错</p>\n</li>\n<li><p>session和直接存储attribute的不同，作用域不一样。request.setAttribute()是只在此action的下一个forward需要使用的时候使用；session.setAttribute 作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。</p>\n</li>\n<li><p>导入的jar包直接放在web-INF的lib目录下，不要再分细的包，不然不行</p>\n</li>\n<li><p>maven管理jar包，依赖的jar直接添加在已经给的dependences里面，不然不行</p>\n</li>\n<li><p>直接在右边maven里面，toncat:run就行</p>\n</li>\n<li><p>加scope不然包冲突</p>\n</li>\n<li><p>设置jdk，不然可能用不了，继续在pom插件，添加了模板jdk_use，可以直接使用了</p>\n</li>\n<li><p>还要设置tomcat7(设置了快捷键tomcat7)，不然跑不了，然后运行 tomcat7:run</p>\n</li>\n<li><p>jedis操作的时候，要开启redis的server和client</p>\n</li>\n<li><p>自己的服务器安装了mysql之后,得再阿里云开放3306端口</p>\n</li>\n<li><p>JDBCUtils.class.getResourceAsStream,无论如何都找到了</p>\n</li>\n<li><p>mysql设置编码,插入中文</p>\n</li>\n<li><p>新建maven项目,在pom.xml里面配置jdk和tomcat7,jar包配置,试跑一下</p>\n</li>\n<li><p>做好大概的思维导图,大致明确逻辑,建好层级目录</p>\n</li>\n<li><p>先放入几个util类,新建数据库,实现User,Userdao,并测试</p>\n</li>\n<li><p>导入jquery,css,boostrap等</p>\n</li>\n<li><p>写注册页面的基本表单</p>\n</li>\n<li><p>正则表达式简单校验输入内容</p>\n</li>\n<li><p>settings code templates other web servlet Annotated给servlet加上doPost</p>\n</li>\n<li><p>mysql安装:设置用户名,密码,然后配置环境变量:</p>\n<blockquote>\n<p>环境变量-系统变量-添加 C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin</p>\n</blockquote>\n</li>\n<li><p>maven镜像: C:\\Users\\12549.m2 下新建settings.xml文件,复制其他地方的内容进去,并且在mirrors标签下添加:</p>\n<pre><code>&lt;mirror&gt;\n      &lt;id&gt;nexus-aliyun&lt;/id&gt;\n      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n      &lt;name&gt;Nexus aliyun&lt;/name&gt;\n      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;\n&lt;/mirror&gt;\n</code></pre>\n</li>\n</ol>\n"},{"title":"深入理解Java虚拟机--虚拟机字节码执行引擎","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习<<深入理解Java虚拟机>>所做的笔记,此为书上第八章--虚拟机字节码执行引擎。","abbrlink":"988064b3","date":"2020-07-12T16:00:00.000Z","_content":"\n\n\n# 概述\n\n物理机的执行引擎是直接建立在处理器,缓存,指令集的操作系统层面上的\n\n虚拟机执行引擎由软件实现,可以不受物理条件制约地定制指令集与执行引擎的结构体系,能够执行不受硬件直接支持的指令集格式\n\n执行引擎在执行字节码时,有解释执行,编译执行两种选择。但是输入输出都是一致的：输入字节码二进制流，处理过程是字节码解析执行的等效过程，输出是执行结果\n\n# 运行时栈帧结构\n\n虚拟机以方法为最基本的执行单元，栈帧对应一个方法，是虚拟机运行时数据区的虚拟机栈的栈元素。每一个方法从调用开始到执行结束的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程\n\n栈帧存储了局部变量表，操作数栈，动态连接，方法返回地址和附加信息\n\n一个栈帧需要分配多少内存，在编译程序源码时就被计算出来并且写入到方法表的Code属性中了，并不会受到程序运行期变量数据的影响，仅仅取决于程序源码和具体的虚拟机实现的栈内存布局\n\n在Java程序的角度看，同一时刻，同一线程上，在调用堆栈的所有方法都同时处在执行状态\n\n而对于执行引擎，在活动线程中，只有位于栈顶的方法是运行的，被称为当前栈帧和当前方法\n\n## 局部变量表\n\n是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量\n\n在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量\n\n局部变量表以变量槽位最小单位，一个变量槽可以存放一个32位以内的数据类型\n\n引用至少要做到两点：\n\n\t\t1.  根据引用直接或间接地查找对象在Java堆中的数据存放的起始地址或索引\n  \t\t2.  根据引用直接或间接地查找对象所属数据类型在方法区中的存储的类型信息\n\n对于64位数据，会分配两个连续的变量槽空间（long,double），对他们读写分割位两次32位读写。由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，所以无论两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题\n\n当方法被调用，虚拟机会用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果是实例方法，则局部变量表第0位索引的变量槽默认存放用于传递方法所属对象实例的引用，即this\n\n变量槽可重用，出作用域的可以重新分配\n\n局部变量表没有准备阶段，所以如果一个局部变量定义了但是没有赋初始值，则不能使用，编译器在编译期间就能检查到并提示出这一点\n\n ## 操作数栈\n\n最大深度也在编译时就写入了Code属性的max_stacks里\n\n32位数据类型所占的栈容量位1,64所占为2,任何时候操作数栈的深度都不会超过max_stacks设置的最大值\n\n做算术运算时,通过将运算涉及的操作数压入栈顶后调用运算指令来进行的\n\n如iadd指令,运行时要求操作数栈中栈顶和次顶元素已经存了两个int型,执行该指令会将两个int出栈并相加,然后重新入栈\n\n## 动态连接\n\n为了支持方法调用过程中的动态连接,每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用\n\n## 方法返回地址\n\n两种方式退出方法:\n\n​\t正常调用完成:执行引擎遇到任意一个方法返回的字节码指令,这时可能有返回值传递给上层的方法调用者\n\n​\t异常调用完成:方法执行过程遇到异常,且该方法的异常表中没有搜索到匹配的异常处理器\n\n在方法退出之后,都必须返回到最初方法被调用时的位置。如果是正常退出，则保存了主调方法的PC计数器的值\n\n方法退出时：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令\n\n## 附加信息\n\n可增加一些规范中没有描述的信息到栈帧之中，例如与调试，性能收集相关的信息\n\n一般把动态连接，方法返回地址，附加信息归为一类，称为栈帧信息\n\n# 方法调用\n\n确定被调用方法的版本(即调用哪一个方法),暂时未涉及方法内部的具体运行过程\n\n一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(即直接引用)\n\n所以某些调用需要在类加载期间,甚至在运行期间才能确定目标方法的直接引用\n\n## 解析\n\n在类的解析阶段,会将其中的一部分符号引用转为直接引用,前提是这些方法在程序真正运行之前就有一个可确定的调用版本,且在运行期不改变\n\n符合\"编译期可知,运行期不可变\"的,主要有静态方法和私有文件两大类.前者与类型直接关联,后者在外部不可被访问\n\n### 调用字节码指令\n\n* invokestatic 用于调用静态方法\n* invokespecial 用于调用<init>()方法,私有方法,父类的方法\n* invokevirtual 用于调用所有的虚方法\n* invokeinterface 用于调用接口方法,会在运行期再确定一个实现该接口的对象\n* invokedynamic 先在运行期动态解析出调用点限定符所引用的方法,然后再执行\n\n只要能被invokestatic,invokespecial 指令调用的方法,都可以在解析阶段中确定唯一的调用版本\n\n符合这些条件的方法共有:静态方法,私有方法,实例构造器,父类方法,再加上被final修饰的方法(尽管他被invokevirtual 修饰)\n\n这五类方法再类加载时就可以把符号引用解析为该方法的直接引用，统称为非虚方法\n\n解析调用一定是静态的过程\n\n## 分派\n\n### 静态分派\n\n```Java\nstatic abstract class Human\n{\n}\nstatic class Man extends Human\n{\n}\nstatic class Woman extends Human\n{\n}\n\npublic void sayHello(Human guy)\n{\n    System.out.println(\"Human\");\n}\npublic void sayHello(Man guy)\n{\n    System.out.println(\"Man\");\n}\npublic void sayHello(Woman guy)\n{\n    System.out.println(\"Women\");\n}\n\npublic static void main(String[] args)\n{\n    Human man = new Man();\n    Human women = new Woman();\n    MainTest mainTest = new MainTest();\n    mainTest.sayHello(man);\n    mainTest.sayHello(women);\n    /*\n    result:\n        Human\n        Human\n     */\n}\n```\n\n`Human man = new Man();`中，Human称为静态类型，Man称为实际类型\n\n最终的静态类型是再编译期可知的，实际类型变化的结果在运行期才可确定\n\n虚拟机在重载时是通过参数的静态类型而不是实际类型作为判断依据的。在编译阶段，编译器根据参数的静态类型决定使用哪个重载版本\n\n所有依赖静态类型来决定方法执行的版本的分派动作，都称为静态分派，最典型的应用就是方法重载\n\n编译器虽然能确定出方法的重载版本，但是很多情况下重载版本并不唯一，往往只能确定一个相对更适合的版本\n\n### 动态分派\n\n是多态性中的重写的变现。\n\n在运行期根据变量的实际类型来分派方法执行版本\n\n字段永远不参与多态\n\n如今的Java语言是一门静态多分派，动态单分派的语言\n\n#### invokevirtual解析过程\n\n1. 找到操作数栈顶的第一个元素所指向的对象的实际类型,记为C\n2. 如果在类型C中找到与常量中的描述符和简单名称都相符的方法,则进行访问权限校验,如果通过则返回这个方法的直接引用,查找过程结束。不通过则返回IllegalAccessError异常\n3. 否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程\n4. 如果始终找不到合适的方法，则抛出AbstractMethodError\n\n### 虚拟机动态分派的实现\n\n常见的优化手段是在方法区建立一个虚方法表（vtable），使用虚方法表索引来代替元数据提高查找性能\n\n虚方法表中存放着各个方法的实际入口地址，如果某个方法没有在子类中被重写那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。\n\n如果子类重写了，则替换为指向子类实现版本的入口地址。\n\n虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕\n\n不使用final修饰的默认都是虚方法\n\n# 动态类型语言支持\n\ninvokedynamic指令，为实现动态类型语言支持而产生\n\n## 动态类型语言\n\n关键特征是：它的类型检查的主体过程是在运行期而不是编译期进行的\n\n运行时异常：只要代码不执行到这一行就不会产生异常\n\n连接时异常：即使代码放在一条根本无法被执行到的路径分支上，类加载时也照样会抛出异常\n\n动态类型语言另外一个核心特征：变量无类型，变量值有类型\n\n### 优缺点\n\n1. 静态类型语言能够在编译期确定变量类型，编译器可以提高全面严谨的类型检查，利于稳定性，让项目更容易达到更大规模\n2. 动态类型语言运行期才确定类型，为开发人员提供极大的灵活性，更清晰明了，意味着开发效率的提高\n\n## java.lang.invoke包\n\n### MethodHandle与Reflection的区别\n\n+ Reflection是在Java代码层次模拟的方法调用,MethodHandle是模拟字节码层次的方法调用\n+ Reflection是Java端的全面映像,是重量级的,MethodHandle是轻量级的\n+ Reflection难以进行优化,MethodHandle可以实现各种优化(如方法内联等)\n+ Reflection只是为Java语言服务,MethodHandle则设计为可服务于所有Java虚拟机语言\n\n# 基于栈的字节码解释执行引擎\n\n探讨如何执行方法里面的字节码指令.有解释执行,编译执行两种\n\n## 解释执行\n\n![IMG_20200825_184807](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200825_184807.jpg)\n\n在执行前,先对程序源码进行词法分析和语法分析处理，把源码转换为抽象目录树。\n\n## 基于栈的指令集和基于寄存器的指令集\n\nJavac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构。字节码指令流中大部分是零地址指令，依赖操作数栈进行工作。\n\n例如1+1:\n\n```\niconst_1\niconst_1\niadd\nistore_0\n```\n\n两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈，相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个变量槽中\n\n### 优缺点\n\n+ 基于栈的主要优点是可移植，用栈架构，用户程序不会直接使用寄存器，可以由虚拟机实现来将一些访问最频繁的数据（程序计数器，栈顶缓存等）放到寄存器中以提高性能。代码紧凑，编译器实现简单\n+ 缺点是执行速度稍慢，完成相同功能所需的指令数量要多，频繁的栈访问也就意味着频繁的内存访问","source":"_posts/JVM笔记/第8章_虚拟机字节码执行引擎.md","raw":"---\ntitle: 深入理解Java虚拟机--虚拟机字节码执行引擎\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第八章--虚拟机字节码执行引擎。'\ncategories: JVM学习笔记\ntags:\n  - JVM\n  - 栈帧\n  - 方法调用\nabbrlink: 988064b3\ndate: 2020-07-13 00:00:00\n---\n\n\n\n# 概述\n\n物理机的执行引擎是直接建立在处理器,缓存,指令集的操作系统层面上的\n\n虚拟机执行引擎由软件实现,可以不受物理条件制约地定制指令集与执行引擎的结构体系,能够执行不受硬件直接支持的指令集格式\n\n执行引擎在执行字节码时,有解释执行,编译执行两种选择。但是输入输出都是一致的：输入字节码二进制流，处理过程是字节码解析执行的等效过程，输出是执行结果\n\n# 运行时栈帧结构\n\n虚拟机以方法为最基本的执行单元，栈帧对应一个方法，是虚拟机运行时数据区的虚拟机栈的栈元素。每一个方法从调用开始到执行结束的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程\n\n栈帧存储了局部变量表，操作数栈，动态连接，方法返回地址和附加信息\n\n一个栈帧需要分配多少内存，在编译程序源码时就被计算出来并且写入到方法表的Code属性中了，并不会受到程序运行期变量数据的影响，仅仅取决于程序源码和具体的虚拟机实现的栈内存布局\n\n在Java程序的角度看，同一时刻，同一线程上，在调用堆栈的所有方法都同时处在执行状态\n\n而对于执行引擎，在活动线程中，只有位于栈顶的方法是运行的，被称为当前栈帧和当前方法\n\n## 局部变量表\n\n是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量\n\n在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量\n\n局部变量表以变量槽位最小单位，一个变量槽可以存放一个32位以内的数据类型\n\n引用至少要做到两点：\n\n\t\t1.  根据引用直接或间接地查找对象在Java堆中的数据存放的起始地址或索引\n  \t\t2.  根据引用直接或间接地查找对象所属数据类型在方法区中的存储的类型信息\n\n对于64位数据，会分配两个连续的变量槽空间（long,double），对他们读写分割位两次32位读写。由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，所以无论两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题\n\n当方法被调用，虚拟机会用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果是实例方法，则局部变量表第0位索引的变量槽默认存放用于传递方法所属对象实例的引用，即this\n\n变量槽可重用，出作用域的可以重新分配\n\n局部变量表没有准备阶段，所以如果一个局部变量定义了但是没有赋初始值，则不能使用，编译器在编译期间就能检查到并提示出这一点\n\n ## 操作数栈\n\n最大深度也在编译时就写入了Code属性的max_stacks里\n\n32位数据类型所占的栈容量位1,64所占为2,任何时候操作数栈的深度都不会超过max_stacks设置的最大值\n\n做算术运算时,通过将运算涉及的操作数压入栈顶后调用运算指令来进行的\n\n如iadd指令,运行时要求操作数栈中栈顶和次顶元素已经存了两个int型,执行该指令会将两个int出栈并相加,然后重新入栈\n\n## 动态连接\n\n为了支持方法调用过程中的动态连接,每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用\n\n## 方法返回地址\n\n两种方式退出方法:\n\n​\t正常调用完成:执行引擎遇到任意一个方法返回的字节码指令,这时可能有返回值传递给上层的方法调用者\n\n​\t异常调用完成:方法执行过程遇到异常,且该方法的异常表中没有搜索到匹配的异常处理器\n\n在方法退出之后,都必须返回到最初方法被调用时的位置。如果是正常退出，则保存了主调方法的PC计数器的值\n\n方法退出时：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令\n\n## 附加信息\n\n可增加一些规范中没有描述的信息到栈帧之中，例如与调试，性能收集相关的信息\n\n一般把动态连接，方法返回地址，附加信息归为一类，称为栈帧信息\n\n# 方法调用\n\n确定被调用方法的版本(即调用哪一个方法),暂时未涉及方法内部的具体运行过程\n\n一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(即直接引用)\n\n所以某些调用需要在类加载期间,甚至在运行期间才能确定目标方法的直接引用\n\n## 解析\n\n在类的解析阶段,会将其中的一部分符号引用转为直接引用,前提是这些方法在程序真正运行之前就有一个可确定的调用版本,且在运行期不改变\n\n符合\"编译期可知,运行期不可变\"的,主要有静态方法和私有文件两大类.前者与类型直接关联,后者在外部不可被访问\n\n### 调用字节码指令\n\n* invokestatic 用于调用静态方法\n* invokespecial 用于调用<init>()方法,私有方法,父类的方法\n* invokevirtual 用于调用所有的虚方法\n* invokeinterface 用于调用接口方法,会在运行期再确定一个实现该接口的对象\n* invokedynamic 先在运行期动态解析出调用点限定符所引用的方法,然后再执行\n\n只要能被invokestatic,invokespecial 指令调用的方法,都可以在解析阶段中确定唯一的调用版本\n\n符合这些条件的方法共有:静态方法,私有方法,实例构造器,父类方法,再加上被final修饰的方法(尽管他被invokevirtual 修饰)\n\n这五类方法再类加载时就可以把符号引用解析为该方法的直接引用，统称为非虚方法\n\n解析调用一定是静态的过程\n\n## 分派\n\n### 静态分派\n\n```Java\nstatic abstract class Human\n{\n}\nstatic class Man extends Human\n{\n}\nstatic class Woman extends Human\n{\n}\n\npublic void sayHello(Human guy)\n{\n    System.out.println(\"Human\");\n}\npublic void sayHello(Man guy)\n{\n    System.out.println(\"Man\");\n}\npublic void sayHello(Woman guy)\n{\n    System.out.println(\"Women\");\n}\n\npublic static void main(String[] args)\n{\n    Human man = new Man();\n    Human women = new Woman();\n    MainTest mainTest = new MainTest();\n    mainTest.sayHello(man);\n    mainTest.sayHello(women);\n    /*\n    result:\n        Human\n        Human\n     */\n}\n```\n\n`Human man = new Man();`中，Human称为静态类型，Man称为实际类型\n\n最终的静态类型是再编译期可知的，实际类型变化的结果在运行期才可确定\n\n虚拟机在重载时是通过参数的静态类型而不是实际类型作为判断依据的。在编译阶段，编译器根据参数的静态类型决定使用哪个重载版本\n\n所有依赖静态类型来决定方法执行的版本的分派动作，都称为静态分派，最典型的应用就是方法重载\n\n编译器虽然能确定出方法的重载版本，但是很多情况下重载版本并不唯一，往往只能确定一个相对更适合的版本\n\n### 动态分派\n\n是多态性中的重写的变现。\n\n在运行期根据变量的实际类型来分派方法执行版本\n\n字段永远不参与多态\n\n如今的Java语言是一门静态多分派，动态单分派的语言\n\n#### invokevirtual解析过程\n\n1. 找到操作数栈顶的第一个元素所指向的对象的实际类型,记为C\n2. 如果在类型C中找到与常量中的描述符和简单名称都相符的方法,则进行访问权限校验,如果通过则返回这个方法的直接引用,查找过程结束。不通过则返回IllegalAccessError异常\n3. 否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程\n4. 如果始终找不到合适的方法，则抛出AbstractMethodError\n\n### 虚拟机动态分派的实现\n\n常见的优化手段是在方法区建立一个虚方法表（vtable），使用虚方法表索引来代替元数据提高查找性能\n\n虚方法表中存放着各个方法的实际入口地址，如果某个方法没有在子类中被重写那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。\n\n如果子类重写了，则替换为指向子类实现版本的入口地址。\n\n虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕\n\n不使用final修饰的默认都是虚方法\n\n# 动态类型语言支持\n\ninvokedynamic指令，为实现动态类型语言支持而产生\n\n## 动态类型语言\n\n关键特征是：它的类型检查的主体过程是在运行期而不是编译期进行的\n\n运行时异常：只要代码不执行到这一行就不会产生异常\n\n连接时异常：即使代码放在一条根本无法被执行到的路径分支上，类加载时也照样会抛出异常\n\n动态类型语言另外一个核心特征：变量无类型，变量值有类型\n\n### 优缺点\n\n1. 静态类型语言能够在编译期确定变量类型，编译器可以提高全面严谨的类型检查，利于稳定性，让项目更容易达到更大规模\n2. 动态类型语言运行期才确定类型，为开发人员提供极大的灵活性，更清晰明了，意味着开发效率的提高\n\n## java.lang.invoke包\n\n### MethodHandle与Reflection的区别\n\n+ Reflection是在Java代码层次模拟的方法调用,MethodHandle是模拟字节码层次的方法调用\n+ Reflection是Java端的全面映像,是重量级的,MethodHandle是轻量级的\n+ Reflection难以进行优化,MethodHandle可以实现各种优化(如方法内联等)\n+ Reflection只是为Java语言服务,MethodHandle则设计为可服务于所有Java虚拟机语言\n\n# 基于栈的字节码解释执行引擎\n\n探讨如何执行方法里面的字节码指令.有解释执行,编译执行两种\n\n## 解释执行\n\n![IMG_20200825_184807](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200825_184807.jpg)\n\n在执行前,先对程序源码进行词法分析和语法分析处理，把源码转换为抽象目录树。\n\n## 基于栈的指令集和基于寄存器的指令集\n\nJavac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构。字节码指令流中大部分是零地址指令，依赖操作数栈进行工作。\n\n例如1+1:\n\n```\niconst_1\niconst_1\niadd\nistore_0\n```\n\n两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈，相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个变量槽中\n\n### 优缺点\n\n+ 基于栈的主要优点是可移植，用栈架构，用户程序不会直接使用寄存器，可以由虚拟机实现来将一些访问最频繁的数据（程序计数器，栈顶缓存等）放到寄存器中以提高性能。代码紧凑，编译器实现简单\n+ 缺点是执行速度稍慢，完成相同功能所需的指令数量要多，频繁的栈访问也就意味着频繁的内存访问","slug":"JVM笔记/第8章_虚拟机字节码执行引擎","published":1,"updated":"2020-11-12T11:57:29.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6vx000mjotp1kis0zbw","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>物理机的执行引擎是直接建立在处理器,缓存,指令集的操作系统层面上的</p>\n<p>虚拟机执行引擎由软件实现,可以不受物理条件制约地定制指令集与执行引擎的结构体系,能够执行不受硬件直接支持的指令集格式</p>\n<p>执行引擎在执行字节码时,有解释执行,编译执行两种选择。但是输入输出都是一致的：输入字节码二进制流，处理过程是字节码解析执行的等效过程，输出是执行结果</p>\n<h1 id=\"运行时栈帧结构\"><a href=\"#运行时栈帧结构\" class=\"headerlink\" title=\"运行时栈帧结构\"></a>运行时栈帧结构</h1><p>虚拟机以方法为最基本的执行单元，栈帧对应一个方法，是虚拟机运行时数据区的虚拟机栈的栈元素。每一个方法从调用开始到执行结束的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程</p>\n<p>栈帧存储了局部变量表，操作数栈，动态连接，方法返回地址和附加信息</p>\n<p>一个栈帧需要分配多少内存，在编译程序源码时就被计算出来并且写入到方法表的Code属性中了，并不会受到程序运行期变量数据的影响，仅仅取决于程序源码和具体的虚拟机实现的栈内存布局</p>\n<p>在Java程序的角度看，同一时刻，同一线程上，在调用堆栈的所有方法都同时处在执行状态</p>\n<p>而对于执行引擎，在活动线程中，只有位于栈顶的方法是运行的，被称为当前栈帧和当前方法</p>\n<h2 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h2><p>是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量</p>\n<p>在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量</p>\n<p>局部变量表以变量槽位最小单位，一个变量槽可以存放一个32位以内的数据类型</p>\n<p>引用至少要做到两点：</p>\n<pre><code>    1.  根据引用直接或间接地查找对象在Java堆中的数据存放的起始地址或索引\n      2.  根据引用直接或间接地查找对象所属数据类型在方法区中的存储的类型信息</code></pre>\n<p>对于64位数据，会分配两个连续的变量槽空间（long,double），对他们读写分割位两次32位读写。由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，所以无论两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题</p>\n<p>当方法被调用，虚拟机会用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果是实例方法，则局部变量表第0位索引的变量槽默认存放用于传递方法所属对象实例的引用，即this</p>\n<p>变量槽可重用，出作用域的可以重新分配</p>\n<p>局部变量表没有准备阶段，所以如果一个局部变量定义了但是没有赋初始值，则不能使用，编译器在编译期间就能检查到并提示出这一点</p>\n<h2 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h2><p>最大深度也在编译时就写入了Code属性的max_stacks里</p>\n<p>32位数据类型所占的栈容量位1,64所占为2,任何时候操作数栈的深度都不会超过max_stacks设置的最大值</p>\n<p>做算术运算时,通过将运算涉及的操作数压入栈顶后调用运算指令来进行的</p>\n<p>如iadd指令,运行时要求操作数栈中栈顶和次顶元素已经存了两个int型,执行该指令会将两个int出栈并相加,然后重新入栈</p>\n<h2 id=\"动态连接\"><a href=\"#动态连接\" class=\"headerlink\" title=\"动态连接\"></a>动态连接</h2><p>为了支持方法调用过程中的动态连接,每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用</p>\n<h2 id=\"方法返回地址\"><a href=\"#方法返回地址\" class=\"headerlink\" title=\"方法返回地址\"></a>方法返回地址</h2><p>两种方式退出方法:</p>\n<p>​    正常调用完成:执行引擎遇到任意一个方法返回的字节码指令,这时可能有返回值传递给上层的方法调用者</p>\n<p>​    异常调用完成:方法执行过程遇到异常,且该方法的异常表中没有搜索到匹配的异常处理器</p>\n<p>在方法退出之后,都必须返回到最初方法被调用时的位置。如果是正常退出，则保存了主调方法的PC计数器的值</p>\n<p>方法退出时：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令</p>\n<h2 id=\"附加信息\"><a href=\"#附加信息\" class=\"headerlink\" title=\"附加信息\"></a>附加信息</h2><p>可增加一些规范中没有描述的信息到栈帧之中，例如与调试，性能收集相关的信息</p>\n<p>一般把动态连接，方法返回地址，附加信息归为一类，称为栈帧信息</p>\n<h1 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h1><p>确定被调用方法的版本(即调用哪一个方法),暂时未涉及方法内部的具体运行过程</p>\n<p>一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(即直接引用)</p>\n<p>所以某些调用需要在类加载期间,甚至在运行期间才能确定目标方法的直接引用</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>在类的解析阶段,会将其中的一部分符号引用转为直接引用,前提是这些方法在程序真正运行之前就有一个可确定的调用版本,且在运行期不改变</p>\n<p>符合”编译期可知,运行期不可变”的,主要有静态方法和私有文件两大类.前者与类型直接关联,后者在外部不可被访问</p>\n<h3 id=\"调用字节码指令\"><a href=\"#调用字节码指令\" class=\"headerlink\" title=\"调用字节码指令\"></a>调用字节码指令</h3><ul>\n<li>invokestatic 用于调用静态方法</li>\n<li>invokespecial 用于调用<init>()方法,私有方法,父类的方法</li>\n<li>invokevirtual 用于调用所有的虚方法</li>\n<li>invokeinterface 用于调用接口方法,会在运行期再确定一个实现该接口的对象</li>\n<li>invokedynamic 先在运行期动态解析出调用点限定符所引用的方法,然后再执行</li>\n</ul>\n<p>只要能被invokestatic,invokespecial 指令调用的方法,都可以在解析阶段中确定唯一的调用版本</p>\n<p>符合这些条件的方法共有:静态方法,私有方法,实例构造器,父类方法,再加上被final修饰的方法(尽管他被invokevirtual 修饰)</p>\n<p>这五类方法再类加载时就可以把符号引用解析为该方法的直接引用，统称为非虚方法</p>\n<p>解析调用一定是静态的过程</p>\n<h2 id=\"分派\"><a href=\"#分派\" class=\"headerlink\" title=\"分派\"></a>分派</h2><h3 id=\"静态分派\"><a href=\"#静态分派\" class=\"headerlink\" title=\"静态分派\"></a>静态分派</h3><pre class=\" language-Java\"><code class=\"language-Java\">static abstract class Human\n{\n}\nstatic class Man extends Human\n{\n}\nstatic class Woman extends Human\n{\n}\n\npublic void sayHello(Human guy)\n{\n    System.out.println(\"Human\");\n}\npublic void sayHello(Man guy)\n{\n    System.out.println(\"Man\");\n}\npublic void sayHello(Woman guy)\n{\n    System.out.println(\"Women\");\n}\n\npublic static void main(String[] args)\n{\n    Human man = new Man();\n    Human women = new Woman();\n    MainTest mainTest = new MainTest();\n    mainTest.sayHello(man);\n    mainTest.sayHello(women);\n    /*\n    result:\n        Human\n        Human\n     */\n}</code></pre>\n<p><code>Human man = new Man();</code>中，Human称为静态类型，Man称为实际类型</p>\n<p>最终的静态类型是再编译期可知的，实际类型变化的结果在运行期才可确定</p>\n<p>虚拟机在重载时是通过参数的静态类型而不是实际类型作为判断依据的。在编译阶段，编译器根据参数的静态类型决定使用哪个重载版本</p>\n<p>所有依赖静态类型来决定方法执行的版本的分派动作，都称为静态分派，最典型的应用就是方法重载</p>\n<p>编译器虽然能确定出方法的重载版本，但是很多情况下重载版本并不唯一，往往只能确定一个相对更适合的版本</p>\n<h3 id=\"动态分派\"><a href=\"#动态分派\" class=\"headerlink\" title=\"动态分派\"></a>动态分派</h3><p>是多态性中的重写的变现。</p>\n<p>在运行期根据变量的实际类型来分派方法执行版本</p>\n<p>字段永远不参与多态</p>\n<p>如今的Java语言是一门静态多分派，动态单分派的语言</p>\n<h4 id=\"invokevirtual解析过程\"><a href=\"#invokevirtual解析过程\" class=\"headerlink\" title=\"invokevirtual解析过程\"></a>invokevirtual解析过程</h4><ol>\n<li>找到操作数栈顶的第一个元素所指向的对象的实际类型,记为C</li>\n<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法,则进行访问权限校验,如果通过则返回这个方法的直接引用,查找过程结束。不通过则返回IllegalAccessError异常</li>\n<li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程</li>\n<li>如果始终找不到合适的方法，则抛出AbstractMethodError</li>\n</ol>\n<h3 id=\"虚拟机动态分派的实现\"><a href=\"#虚拟机动态分派的实现\" class=\"headerlink\" title=\"虚拟机动态分派的实现\"></a>虚拟机动态分派的实现</h3><p>常见的优化手段是在方法区建立一个虚方法表（vtable），使用虚方法表索引来代替元数据提高查找性能</p>\n<p>虚方法表中存放着各个方法的实际入口地址，如果某个方法没有在子类中被重写那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。</p>\n<p>如果子类重写了，则替换为指向子类实现版本的入口地址。</p>\n<p>虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕</p>\n<p>不使用final修饰的默认都是虚方法</p>\n<h1 id=\"动态类型语言支持\"><a href=\"#动态类型语言支持\" class=\"headerlink\" title=\"动态类型语言支持\"></a>动态类型语言支持</h1><p>invokedynamic指令，为实现动态类型语言支持而产生</p>\n<h2 id=\"动态类型语言\"><a href=\"#动态类型语言\" class=\"headerlink\" title=\"动态类型语言\"></a>动态类型语言</h2><p>关键特征是：它的类型检查的主体过程是在运行期而不是编译期进行的</p>\n<p>运行时异常：只要代码不执行到这一行就不会产生异常</p>\n<p>连接时异常：即使代码放在一条根本无法被执行到的路径分支上，类加载时也照样会抛出异常</p>\n<p>动态类型语言另外一个核心特征：变量无类型，变量值有类型</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ol>\n<li>静态类型语言能够在编译期确定变量类型，编译器可以提高全面严谨的类型检查，利于稳定性，让项目更容易达到更大规模</li>\n<li>动态类型语言运行期才确定类型，为开发人员提供极大的灵活性，更清晰明了，意味着开发效率的提高</li>\n</ol>\n<h2 id=\"java-lang-invoke包\"><a href=\"#java-lang-invoke包\" class=\"headerlink\" title=\"java.lang.invoke包\"></a>java.lang.invoke包</h2><h3 id=\"MethodHandle与Reflection的区别\"><a href=\"#MethodHandle与Reflection的区别\" class=\"headerlink\" title=\"MethodHandle与Reflection的区别\"></a>MethodHandle与Reflection的区别</h3><ul>\n<li>Reflection是在Java代码层次模拟的方法调用,MethodHandle是模拟字节码层次的方法调用</li>\n<li>Reflection是Java端的全面映像,是重量级的,MethodHandle是轻量级的</li>\n<li>Reflection难以进行优化,MethodHandle可以实现各种优化(如方法内联等)</li>\n<li>Reflection只是为Java语言服务,MethodHandle则设计为可服务于所有Java虚拟机语言</li>\n</ul>\n<h1 id=\"基于栈的字节码解释执行引擎\"><a href=\"#基于栈的字节码解释执行引擎\" class=\"headerlink\" title=\"基于栈的字节码解释执行引擎\"></a>基于栈的字节码解释执行引擎</h1><p>探讨如何执行方法里面的字节码指令.有解释执行,编译执行两种</p>\n<h2 id=\"解释执行\"><a href=\"#解释执行\" class=\"headerlink\" title=\"解释执行\"></a>解释执行</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200825_184807.jpg\" alt=\"IMG_20200825_184807\"></p>\n<p>在执行前,先对程序源码进行词法分析和语法分析处理，把源码转换为抽象目录树。</p>\n<h2 id=\"基于栈的指令集和基于寄存器的指令集\"><a href=\"#基于栈的指令集和基于寄存器的指令集\" class=\"headerlink\" title=\"基于栈的指令集和基于寄存器的指令集\"></a>基于栈的指令集和基于寄存器的指令集</h2><p>Javac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构。字节码指令流中大部分是零地址指令，依赖操作数栈进行工作。</p>\n<p>例如1+1:</p>\n<pre><code>iconst_1\niconst_1\niadd\nistore_0</code></pre>\n<p>两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈，相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个变量槽中</p>\n<h3 id=\"优缺点-1\"><a href=\"#优缺点-1\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ul>\n<li>基于栈的主要优点是可移植，用栈架构，用户程序不会直接使用寄存器，可以由虚拟机实现来将一些访问最频繁的数据（程序计数器，栈顶缓存等）放到寄存器中以提高性能。代码紧凑，编译器实现简单</li>\n<li>缺点是执行速度稍慢，完成相同功能所需的指令数量要多，频繁的栈访问也就意味着频繁的内存访问</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>物理机的执行引擎是直接建立在处理器,缓存,指令集的操作系统层面上的</p>\n<p>虚拟机执行引擎由软件实现,可以不受物理条件制约地定制指令集与执行引擎的结构体系,能够执行不受硬件直接支持的指令集格式</p>\n<p>执行引擎在执行字节码时,有解释执行,编译执行两种选择。但是输入输出都是一致的：输入字节码二进制流，处理过程是字节码解析执行的等效过程，输出是执行结果</p>\n<h1 id=\"运行时栈帧结构\"><a href=\"#运行时栈帧结构\" class=\"headerlink\" title=\"运行时栈帧结构\"></a>运行时栈帧结构</h1><p>虚拟机以方法为最基本的执行单元，栈帧对应一个方法，是虚拟机运行时数据区的虚拟机栈的栈元素。每一个方法从调用开始到执行结束的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程</p>\n<p>栈帧存储了局部变量表，操作数栈，动态连接，方法返回地址和附加信息</p>\n<p>一个栈帧需要分配多少内存，在编译程序源码时就被计算出来并且写入到方法表的Code属性中了，并不会受到程序运行期变量数据的影响，仅仅取决于程序源码和具体的虚拟机实现的栈内存布局</p>\n<p>在Java程序的角度看，同一时刻，同一线程上，在调用堆栈的所有方法都同时处在执行状态</p>\n<p>而对于执行引擎，在活动线程中，只有位于栈顶的方法是运行的，被称为当前栈帧和当前方法</p>\n<h2 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h2><p>是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量</p>\n<p>在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量</p>\n<p>局部变量表以变量槽位最小单位，一个变量槽可以存放一个32位以内的数据类型</p>\n<p>引用至少要做到两点：</p>\n<pre><code>    1.  根据引用直接或间接地查找对象在Java堆中的数据存放的起始地址或索引\n      2.  根据引用直接或间接地查找对象所属数据类型在方法区中的存储的类型信息</code></pre>\n<p>对于64位数据，会分配两个连续的变量槽空间（long,double），对他们读写分割位两次32位读写。由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，所以无论两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题</p>\n<p>当方法被调用，虚拟机会用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果是实例方法，则局部变量表第0位索引的变量槽默认存放用于传递方法所属对象实例的引用，即this</p>\n<p>变量槽可重用，出作用域的可以重新分配</p>\n<p>局部变量表没有准备阶段，所以如果一个局部变量定义了但是没有赋初始值，则不能使用，编译器在编译期间就能检查到并提示出这一点</p>\n<h2 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h2><p>最大深度也在编译时就写入了Code属性的max_stacks里</p>\n<p>32位数据类型所占的栈容量位1,64所占为2,任何时候操作数栈的深度都不会超过max_stacks设置的最大值</p>\n<p>做算术运算时,通过将运算涉及的操作数压入栈顶后调用运算指令来进行的</p>\n<p>如iadd指令,运行时要求操作数栈中栈顶和次顶元素已经存了两个int型,执行该指令会将两个int出栈并相加,然后重新入栈</p>\n<h2 id=\"动态连接\"><a href=\"#动态连接\" class=\"headerlink\" title=\"动态连接\"></a>动态连接</h2><p>为了支持方法调用过程中的动态连接,每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用</p>\n<h2 id=\"方法返回地址\"><a href=\"#方法返回地址\" class=\"headerlink\" title=\"方法返回地址\"></a>方法返回地址</h2><p>两种方式退出方法:</p>\n<p>​    正常调用完成:执行引擎遇到任意一个方法返回的字节码指令,这时可能有返回值传递给上层的方法调用者</p>\n<p>​    异常调用完成:方法执行过程遇到异常,且该方法的异常表中没有搜索到匹配的异常处理器</p>\n<p>在方法退出之后,都必须返回到最初方法被调用时的位置。如果是正常退出，则保存了主调方法的PC计数器的值</p>\n<p>方法退出时：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令</p>\n<h2 id=\"附加信息\"><a href=\"#附加信息\" class=\"headerlink\" title=\"附加信息\"></a>附加信息</h2><p>可增加一些规范中没有描述的信息到栈帧之中，例如与调试，性能收集相关的信息</p>\n<p>一般把动态连接，方法返回地址，附加信息归为一类，称为栈帧信息</p>\n<h1 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h1><p>确定被调用方法的版本(即调用哪一个方法),暂时未涉及方法内部的具体运行过程</p>\n<p>一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(即直接引用)</p>\n<p>所以某些调用需要在类加载期间,甚至在运行期间才能确定目标方法的直接引用</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>在类的解析阶段,会将其中的一部分符号引用转为直接引用,前提是这些方法在程序真正运行之前就有一个可确定的调用版本,且在运行期不改变</p>\n<p>符合”编译期可知,运行期不可变”的,主要有静态方法和私有文件两大类.前者与类型直接关联,后者在外部不可被访问</p>\n<h3 id=\"调用字节码指令\"><a href=\"#调用字节码指令\" class=\"headerlink\" title=\"调用字节码指令\"></a>调用字节码指令</h3><ul>\n<li>invokestatic 用于调用静态方法</li>\n<li>invokespecial 用于调用<init>()方法,私有方法,父类的方法</li>\n<li>invokevirtual 用于调用所有的虚方法</li>\n<li>invokeinterface 用于调用接口方法,会在运行期再确定一个实现该接口的对象</li>\n<li>invokedynamic 先在运行期动态解析出调用点限定符所引用的方法,然后再执行</li>\n</ul>\n<p>只要能被invokestatic,invokespecial 指令调用的方法,都可以在解析阶段中确定唯一的调用版本</p>\n<p>符合这些条件的方法共有:静态方法,私有方法,实例构造器,父类方法,再加上被final修饰的方法(尽管他被invokevirtual 修饰)</p>\n<p>这五类方法再类加载时就可以把符号引用解析为该方法的直接引用，统称为非虚方法</p>\n<p>解析调用一定是静态的过程</p>\n<h2 id=\"分派\"><a href=\"#分派\" class=\"headerlink\" title=\"分派\"></a>分派</h2><h3 id=\"静态分派\"><a href=\"#静态分派\" class=\"headerlink\" title=\"静态分派\"></a>静态分派</h3><pre><code class=\"Java\">static abstract class Human\n{\n}\nstatic class Man extends Human\n{\n}\nstatic class Woman extends Human\n{\n}\n\npublic void sayHello(Human guy)\n{\n    System.out.println(&quot;Human&quot;);\n}\npublic void sayHello(Man guy)\n{\n    System.out.println(&quot;Man&quot;);\n}\npublic void sayHello(Woman guy)\n{\n    System.out.println(&quot;Women&quot;);\n}\n\npublic static void main(String[] args)\n{\n    Human man = new Man();\n    Human women = new Woman();\n    MainTest mainTest = new MainTest();\n    mainTest.sayHello(man);\n    mainTest.sayHello(women);\n    /*\n    result:\n        Human\n        Human\n     */\n}</code></pre>\n<p><code>Human man = new Man();</code>中，Human称为静态类型，Man称为实际类型</p>\n<p>最终的静态类型是再编译期可知的，实际类型变化的结果在运行期才可确定</p>\n<p>虚拟机在重载时是通过参数的静态类型而不是实际类型作为判断依据的。在编译阶段，编译器根据参数的静态类型决定使用哪个重载版本</p>\n<p>所有依赖静态类型来决定方法执行的版本的分派动作，都称为静态分派，最典型的应用就是方法重载</p>\n<p>编译器虽然能确定出方法的重载版本，但是很多情况下重载版本并不唯一，往往只能确定一个相对更适合的版本</p>\n<h3 id=\"动态分派\"><a href=\"#动态分派\" class=\"headerlink\" title=\"动态分派\"></a>动态分派</h3><p>是多态性中的重写的变现。</p>\n<p>在运行期根据变量的实际类型来分派方法执行版本</p>\n<p>字段永远不参与多态</p>\n<p>如今的Java语言是一门静态多分派，动态单分派的语言</p>\n<h4 id=\"invokevirtual解析过程\"><a href=\"#invokevirtual解析过程\" class=\"headerlink\" title=\"invokevirtual解析过程\"></a>invokevirtual解析过程</h4><ol>\n<li>找到操作数栈顶的第一个元素所指向的对象的实际类型,记为C</li>\n<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法,则进行访问权限校验,如果通过则返回这个方法的直接引用,查找过程结束。不通过则返回IllegalAccessError异常</li>\n<li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程</li>\n<li>如果始终找不到合适的方法，则抛出AbstractMethodError</li>\n</ol>\n<h3 id=\"虚拟机动态分派的实现\"><a href=\"#虚拟机动态分派的实现\" class=\"headerlink\" title=\"虚拟机动态分派的实现\"></a>虚拟机动态分派的实现</h3><p>常见的优化手段是在方法区建立一个虚方法表（vtable），使用虚方法表索引来代替元数据提高查找性能</p>\n<p>虚方法表中存放着各个方法的实际入口地址，如果某个方法没有在子类中被重写那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。</p>\n<p>如果子类重写了，则替换为指向子类实现版本的入口地址。</p>\n<p>虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕</p>\n<p>不使用final修饰的默认都是虚方法</p>\n<h1 id=\"动态类型语言支持\"><a href=\"#动态类型语言支持\" class=\"headerlink\" title=\"动态类型语言支持\"></a>动态类型语言支持</h1><p>invokedynamic指令，为实现动态类型语言支持而产生</p>\n<h2 id=\"动态类型语言\"><a href=\"#动态类型语言\" class=\"headerlink\" title=\"动态类型语言\"></a>动态类型语言</h2><p>关键特征是：它的类型检查的主体过程是在运行期而不是编译期进行的</p>\n<p>运行时异常：只要代码不执行到这一行就不会产生异常</p>\n<p>连接时异常：即使代码放在一条根本无法被执行到的路径分支上，类加载时也照样会抛出异常</p>\n<p>动态类型语言另外一个核心特征：变量无类型，变量值有类型</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ol>\n<li>静态类型语言能够在编译期确定变量类型，编译器可以提高全面严谨的类型检查，利于稳定性，让项目更容易达到更大规模</li>\n<li>动态类型语言运行期才确定类型，为开发人员提供极大的灵活性，更清晰明了，意味着开发效率的提高</li>\n</ol>\n<h2 id=\"java-lang-invoke包\"><a href=\"#java-lang-invoke包\" class=\"headerlink\" title=\"java.lang.invoke包\"></a>java.lang.invoke包</h2><h3 id=\"MethodHandle与Reflection的区别\"><a href=\"#MethodHandle与Reflection的区别\" class=\"headerlink\" title=\"MethodHandle与Reflection的区别\"></a>MethodHandle与Reflection的区别</h3><ul>\n<li>Reflection是在Java代码层次模拟的方法调用,MethodHandle是模拟字节码层次的方法调用</li>\n<li>Reflection是Java端的全面映像,是重量级的,MethodHandle是轻量级的</li>\n<li>Reflection难以进行优化,MethodHandle可以实现各种优化(如方法内联等)</li>\n<li>Reflection只是为Java语言服务,MethodHandle则设计为可服务于所有Java虚拟机语言</li>\n</ul>\n<h1 id=\"基于栈的字节码解释执行引擎\"><a href=\"#基于栈的字节码解释执行引擎\" class=\"headerlink\" title=\"基于栈的字节码解释执行引擎\"></a>基于栈的字节码解释执行引擎</h1><p>探讨如何执行方法里面的字节码指令.有解释执行,编译执行两种</p>\n<h2 id=\"解释执行\"><a href=\"#解释执行\" class=\"headerlink\" title=\"解释执行\"></a>解释执行</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200825_184807.jpg\" alt=\"IMG_20200825_184807\"></p>\n<p>在执行前,先对程序源码进行词法分析和语法分析处理，把源码转换为抽象目录树。</p>\n<h2 id=\"基于栈的指令集和基于寄存器的指令集\"><a href=\"#基于栈的指令集和基于寄存器的指令集\" class=\"headerlink\" title=\"基于栈的指令集和基于寄存器的指令集\"></a>基于栈的指令集和基于寄存器的指令集</h2><p>Javac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构。字节码指令流中大部分是零地址指令，依赖操作数栈进行工作。</p>\n<p>例如1+1:</p>\n<pre><code>iconst_1\niconst_1\niadd\nistore_0</code></pre>\n<p>两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈，相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个变量槽中</p>\n<h3 id=\"优缺点-1\"><a href=\"#优缺点-1\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ul>\n<li>基于栈的主要优点是可移植，用栈架构，用户程序不会直接使用寄存器，可以由虚拟机实现来将一些访问最频繁的数据（程序计数器，栈顶缓存等）放到寄存器中以提高性能。代码紧凑，编译器实现简单</li>\n<li>缺点是执行速度稍慢，完成相同功能所需的指令数量要多，频繁的栈访问也就意味着频繁的内存访问</li>\n</ul>\n"},{"title":"Java基础--IO","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"Java基础知识之IO,待完善,之后再看的时候会继续补充。","abbrlink":"48185b72","date":"2020-03-01T16:00:00.000Z","_content":"\n## IO\n1. 用完流要调用close()关闭\n2. 最终输出前,调用flush(),清空管道\n3. 以Stream结尾都是字节流,以Reader/Writer结尾都是字符流\n\n```java\npublic static void main(String[] args)\n{\n    FileInputStream fileInputStream = null;\n    FileOutputStream fileOutputStream = null;\n    try\n    {\n        fileInputStream = new FileInputStream(\"src/test.txt\");\n        fileOutputStream = new FileOutputStream(\"src/test1.txt\");\n\n        byte[] bytes = new byte[1024*1024];//一次读取1024*1024个字节\n        int count;//读到的字节数量,读取不到返回-1\n        while((count=fileInputStream.read(bytes))!=-1)\n        {\n            //把读到的byte数组再写出去\n            fileOutputStream.write(bytes,0,count);\n        }\n\n        fileOutputStream.flush();\n    }\n    catch (FileNotFoundException e)\n    {\n        e.printStackTrace();\n    }\n    catch (IOException e)\n    {\n        e.printStackTrace();\n    }\n    finally\n    {\n        if(fileInputStream!=null)\n        {\n            try\n            {\n                fileInputStream.close();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        if(fileOutputStream!=null)\n        {\n            try\n            {\n                fileOutputStream.close();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n```java\n//自带缓冲\n//包装类模式\nBufferedReader bufferedReader = new BufferedReader(new FileReader(\"src/test.txt\"));\n\nString line;//不读换行符\nwhile((line=bufferedReader.readLine())!=null)\n    System.out.println(line);\n\n//只需要关闭最外层的流\nbufferedReader.close();\n```\n\n![image-20200808071748335](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200808071748335.png)\n\n\n```java\n//转换流\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/test.txt\")));\n```\n\n## 序列化\n1. 要实现标志接口 `Serializable`,会自动生成序列化版本号\n2. transient:不参与序列化\n3. 通过类名,序列号区分一个类\n4. 建议将序列号手动写出来,这样类改动也还能用之前序列化后的\n\n\n\n```java\nPerson person = new Person(\"zhangsan\",23);\n\nObjectOutputStream objectOutputStream = \n    new ObjectOutputStream(new FileOutputStream(\"person\"));\n\nobjectOutputStream.writeObject(person);\n\nobjectOutputStream.flush();\nobjectOutputStream.close();\n```\n```java\nObjectInputStream objectInputStream = \n    new ObjectInputStream(new FileInputStream(\"person\"));\nObject object = objectInputStream.readObject();\nSystem.out.println(object);\nobjectInputStream.close();\n```","source":"_posts/Java笔记/IO.md","raw":"---\ntitle: Java基础--IO\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 'Java基础知识之IO,待完善,之后再看的时候会继续补充。'\ncategories: Java基础\ntags:\n  - Java基础\n  - IO\nabbrlink: 48185b72\ndate: 2020-03-02 00:00:00\n---\n\n## IO\n1. 用完流要调用close()关闭\n2. 最终输出前,调用flush(),清空管道\n3. 以Stream结尾都是字节流,以Reader/Writer结尾都是字符流\n\n```java\npublic static void main(String[] args)\n{\n    FileInputStream fileInputStream = null;\n    FileOutputStream fileOutputStream = null;\n    try\n    {\n        fileInputStream = new FileInputStream(\"src/test.txt\");\n        fileOutputStream = new FileOutputStream(\"src/test1.txt\");\n\n        byte[] bytes = new byte[1024*1024];//一次读取1024*1024个字节\n        int count;//读到的字节数量,读取不到返回-1\n        while((count=fileInputStream.read(bytes))!=-1)\n        {\n            //把读到的byte数组再写出去\n            fileOutputStream.write(bytes,0,count);\n        }\n\n        fileOutputStream.flush();\n    }\n    catch (FileNotFoundException e)\n    {\n        e.printStackTrace();\n    }\n    catch (IOException e)\n    {\n        e.printStackTrace();\n    }\n    finally\n    {\n        if(fileInputStream!=null)\n        {\n            try\n            {\n                fileInputStream.close();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        if(fileOutputStream!=null)\n        {\n            try\n            {\n                fileOutputStream.close();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n```java\n//自带缓冲\n//包装类模式\nBufferedReader bufferedReader = new BufferedReader(new FileReader(\"src/test.txt\"));\n\nString line;//不读换行符\nwhile((line=bufferedReader.readLine())!=null)\n    System.out.println(line);\n\n//只需要关闭最外层的流\nbufferedReader.close();\n```\n\n![image-20200808071748335](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200808071748335.png)\n\n\n```java\n//转换流\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/test.txt\")));\n```\n\n## 序列化\n1. 要实现标志接口 `Serializable`,会自动生成序列化版本号\n2. transient:不参与序列化\n3. 通过类名,序列号区分一个类\n4. 建议将序列号手动写出来,这样类改动也还能用之前序列化后的\n\n\n\n```java\nPerson person = new Person(\"zhangsan\",23);\n\nObjectOutputStream objectOutputStream = \n    new ObjectOutputStream(new FileOutputStream(\"person\"));\n\nobjectOutputStream.writeObject(person);\n\nobjectOutputStream.flush();\nobjectOutputStream.close();\n```\n```java\nObjectInputStream objectInputStream = \n    new ObjectInputStream(new FileInputStream(\"person\"));\nObject object = objectInputStream.readObject();\nSystem.out.println(object);\nobjectInputStream.close();\n```","slug":"Java笔记/IO","published":1,"updated":"2020-11-12T11:57:29.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6vy000qjotp96qtfbo1","content":"<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><ol>\n<li>用完流要调用close()关闭</li>\n<li>最终输出前,调用flush(),清空管道</li>\n<li>以Stream结尾都是字节流,以Reader/Writer结尾都是字符流</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    FileInputStream fileInputStream <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    FileOutputStream fileOutputStream <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span>\n    <span class=\"token punctuation\">{</span>\n        fileInputStream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"src/test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        fileOutputStream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"src/test1.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token operator\">*</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//一次读取1024*1024个字节</span>\n        <span class=\"token keyword\">int</span> count<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//读到的字节数量,读取不到返回-1</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>count<span class=\"token operator\">=</span>fileInputStream<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//把读到的byte数组再写出去</span>\n            fileOutputStream<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        fileOutputStream<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FileNotFoundException</span> e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">finally</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fileInputStream<span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span>\n            <span class=\"token punctuation\">{</span>\n                fileInputStream<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fileOutputStream<span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span>\n            <span class=\"token punctuation\">{</span>\n                fileOutputStream<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//自带缓冲</span>\n<span class=\"token comment\" spellcheck=\"true\">//包装类模式</span>\nBufferedReader bufferedReader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileReader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"src/test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nString line<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//不读换行符</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>line<span class=\"token operator\">=</span>bufferedReader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//只需要关闭最外层的流</span>\nbufferedReader<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200808071748335.png\" alt=\"image-20200808071748335\"></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//转换流</span>\nBufferedReader bufferedReader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"src/test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h2><ol>\n<li>要实现标志接口 <code>Serializable</code>,会自动生成序列化版本号</li>\n<li>transient:不参与序列化</li>\n<li>通过类名,序列号区分一个类</li>\n<li>建议将序列号手动写出来,这样类改动也还能用之前序列化后的</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\">Person person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zhangsan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">23</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nObjectOutputStream objectOutputStream <span class=\"token operator\">=</span> \n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nobjectOutputStream<span class=\"token punctuation\">.</span><span class=\"token function\">writeObject</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nobjectOutputStream<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobjectOutputStream<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">ObjectInputStream objectInputStream <span class=\"token operator\">=</span> \n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectInputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nObject object <span class=\"token operator\">=</span> objectInputStream<span class=\"token punctuation\">.</span><span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobjectInputStream<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><ol>\n<li>用完流要调用close()关闭</li>\n<li>最终输出前,调用flush(),清空管道</li>\n<li>以Stream结尾都是字节流,以Reader/Writer结尾都是字符流</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args)\n{\n    FileInputStream fileInputStream = null;\n    FileOutputStream fileOutputStream = null;\n    try\n    {\n        fileInputStream = new FileInputStream(&quot;src/test.txt&quot;);\n        fileOutputStream = new FileOutputStream(&quot;src/test1.txt&quot;);\n\n        byte[] bytes = new byte[1024*1024];//一次读取1024*1024个字节\n        int count;//读到的字节数量,读取不到返回-1\n        while((count=fileInputStream.read(bytes))!=-1)\n        {\n            //把读到的byte数组再写出去\n            fileOutputStream.write(bytes,0,count);\n        }\n\n        fileOutputStream.flush();\n    }\n    catch (FileNotFoundException e)\n    {\n        e.printStackTrace();\n    }\n    catch (IOException e)\n    {\n        e.printStackTrace();\n    }\n    finally\n    {\n        if(fileInputStream!=null)\n        {\n            try\n            {\n                fileInputStream.close();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        if(fileOutputStream!=null)\n        {\n            try\n            {\n                fileOutputStream.close();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre>\n<pre><code class=\"java\">//自带缓冲\n//包装类模式\nBufferedReader bufferedReader = new BufferedReader(new FileReader(&quot;src/test.txt&quot;));\n\nString line;//不读换行符\nwhile((line=bufferedReader.readLine())!=null)\n    System.out.println(line);\n\n//只需要关闭最外层的流\nbufferedReader.close();</code></pre>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200808071748335.png\" alt=\"image-20200808071748335\"></p>\n<pre><code class=\"java\">//转换流\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;src/test.txt&quot;)));</code></pre>\n<h2 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h2><ol>\n<li>要实现标志接口 <code>Serializable</code>,会自动生成序列化版本号</li>\n<li>transient:不参与序列化</li>\n<li>通过类名,序列号区分一个类</li>\n<li>建议将序列号手动写出来,这样类改动也还能用之前序列化后的</li>\n</ol>\n<pre><code class=\"java\">Person person = new Person(&quot;zhangsan&quot;,23);\n\nObjectOutputStream objectOutputStream = \n    new ObjectOutputStream(new FileOutputStream(&quot;person&quot;));\n\nobjectOutputStream.writeObject(person);\n\nobjectOutputStream.flush();\nobjectOutputStream.close();</code></pre>\n<pre><code class=\"java\">ObjectInputStream objectInputStream = \n    new ObjectInputStream(new FileInputStream(&quot;person&quot;));\nObject object = objectInputStream.readObject();\nSystem.out.println(object);\nobjectInputStream.close();</code></pre>\n"},{"title":"深入理解Java虚拟机--虚拟机类加载机制","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习<<深入理解Java虚拟机>>所做的笔记,此为书上第七章--虚拟机类加载机制。","abbrlink":"92288fa0","date":"2020-07-10T16:00:00.000Z","_content":"\n# 概述\n\nJava虚拟机把描述类的数据从Class文件加载到内存,并进行加载,连接,初始化.这些都是在程序运行期间完成的。\n\nJava天生可以动态扩展的语言特性，就是依赖于运行期动态加载和动态连接实现的\n\nClass文件，指的是一串二进制字节流，并非特指某个存在于具体磁盘中的文件\n\n# 类加载的时机\n\n1. 整个生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载\n2. 加载，验证，准备，初始化，卸载顺序是确定的，必须按照这种顺序按部就班地开始，但不是按部就班地进行或完成。他们通常相互交叉地混合进行，会在一个阶段的执行过程中调用激活另一个阶段\n3. 解析阶段有可能在初始化阶段之后开始，因为要支持运行时绑定（动态绑定）\n\n## 立即对类进行初始化的六种情况：\n\n有且仅有这六种.这些行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用\n\n1. 遇到new,getstatic,putstatic,invokestatic这四种字节码指令，如果没有进行过初始化，则需要先触发其初始化阶段,典型情况：\n\t1. 使用new关键字实例化对象\n\t2. 读取或设置一个类型的静态字段\n\t3. 调用一个类的静态方法\n\t\n2. 使用java.lang.reflect包的方法对类进行反射调用。如果类没有初始化，则需要触发\n\n3. 初始化类，其父类还没有初始化\n\n4. 虚拟机启动时，需要指定执行主类（main())，先初始化这个主类\n\n5. 使用JDK7新加入的动态语言支持，方法句柄对应的类没有进行过初始化\n\n6. 一个接口定义了JDK8新加入的默认方法（被default修饰），如果这个接口的实现类发生了初始化，则该接口要在其之前进行初始化\n### 被动引用例子\n1. 通过其子类来引用父类中定义的静态字段,只会触发父类的不会触发之类的初始化。\n2. 创建类的数组，也只会自动生成一个继承于Object的数组类型，不会触发子类的初始化\n3. 引用类中定义的常量，因为编译期间通过常量优化，常量的值直接存储在使用的类的常量池中\n\n# 类加载的过程\n\n## 加载\n\n### 任务\n\n1. 通过一个类的全限定名获取定义该类的二进制字节流\n2. 将该字节流所代表的静态存储结构转换为方法区的运行时数据结构\n3. 在内存中生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口\n\n### 二进制字节流获取方式\n\n1. 从zip获取，如JAR\n2. 从网络中获取，如Web Applet\n3. 运行时计算生成，如动态代理技术\n4. 由其他文件生成，如JSP\n5. 从数据库中获取\n6. 从加密文件中获取，防Class文件被反编译的保护措施\n\n### 数组类的加载\n1. 如果数组的组件类型是引用类型，则会递归采用之前所说的加载过程去加载该组件类型，数组类将被标识在加载该组件类型的类加载器的类名称空间上\n2. 如果数组的组件类型不是引用类型，数组类将与引导类加载器关联\n3. 数组类的可访问性与它的组件类型一致， 如果数组的组件类型不是引用类型，则默认为是public\n### 加载结束\n加载阶段结束后，二进制字节流就按照格式存储在方法区之中了，然后会在Java堆内存中实例化一个Class对象，作为程序访问方法区中的类型数据的外部接口\n\n## 验证\n\n为了确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害到虚拟机自身的安全\n\n### 文件格式验证\n\n验证字节流是否符合Class文件格式的规范，并且被当前版本的虚拟机处理（例如是否以魔数开头，常量池中常量是否有不被支持的常量类型，CONSTANT_Utf8_info型的常量是否有不符合Utf8编码的数据）\n\n目的是保证输入的字节流能正确地解析并且存储在方法区之内，即格式上符合描述一个Java类型的要求\n\n### 元数据验证\n\n对字节码描述的信息进行语义分析，包括：\n\n1. 该类是否有父类\n2. 该类的父类是否继承了不允许继承的类（final修饰的类）\n3. 如果不是抽象类，是否实现了其父类或者接口要求实现的所有方法\n4. 类中字段，方法是否与父类产生矛盾（例如覆盖了父类的final方法，出现不符合规范的重载等等）\n### 字节码验证\n对类的方法体(Class文件中的Code属性)进行校验分析,保证被校验类的方法在运行时不会做出危害虚拟机安全的行为,例如:\n1. 保证任意时刻操作数栈的数据类型与指令的代码序列都能配合工作。不会出现类似于在操作数栈放置了一个int型的数据，使用却按long类型来加载入本地变量表中\n2. 保证任何跳转指令都不会跳转到方法体之外的字节码指令中\n3. 保证方法体中的类型转换都是有效的\n\n但不可能完全确保程序是安全的，因为停机问题理论：不能通过程序准确地检查出程序是否能在有效的时间之内结束运行\n### 符号引用验证\n发生在虚拟机将符号引用转化为直接引用的时候，发生在解析阶段。验证该类是否缺少或者被禁止访问它依赖的某些外部类，方法，字段等资源，通常检验：\n1. 符号引用中通过字符串描述的全限定名是否能找到对应的类\n2. 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段\n3. 符号引用中的类，字段，方法的可访问性\n\n## 准备\n正式为类中定义的静态变量分配内存并设置类变量初始值的阶段\n在JDK8中，类变量会随着Class对象一起放Java堆中\n不包括实例变量，实例变量会在对象实例化时随着对象一起分配在堆中\n通常情况下初始值是数据类型的零值，直到在类的初始化阶段通过类构造器的<clinit>()方法赋值\n但如果是final修饰，即存在ConstantValue属性，那在准备阶段就会被初始化为ConstantValue属性所指定的初始值\n\n## 解析\n1. 将常量池内的符号引用替换为直接引用的过程\n\n2. 符合引用：以一组符合来描述所引用的目标，可以是任何形式的字面量，与虚拟机实现的内存布局无关\n\n3. 直接引用：可以直接指向目标的指针，相对偏移量，或者是一个能间接定位到目标的句柄，与虚拟机实现的内存布局直接相关。如果有了直接引用，那引用目标必定已经在虚拟机的内存中存在\n\n4. 在执行操作符号引用的字节码指令之前，必须先堆它所使用的符号引用进行解析。可以自行判断在加载时就解析还是在使用前才解析\n\n### 类和接口的解析\n假设当前代码所处的类为D,要把从未解析过的符号引用N解析为一个类或接口C\n1. 如果C不是一个数组类型,虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C\n2. 如果C是一个数组类型,并且数组的元素类型为对象,会先按上面的方法加载数组元素类型,再由虚拟机生成一个代表该数组维度和元素的数组对象\n3. 在解析完成之前,要进行符号引用验证,确认D是否具备对C的访问权限\n\n### 字段解析\n1. 会先对字段所属的类或接口的符号引用进行解析\n2. 如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该字段的直接引用\n3. 否则,则按照继承关系从下往上递归搜索各个接口和它的父接口\n4. 否则,则按照继承关系从下往上递归搜索父类\n5. 找不到,则抛出NoSuchFieldError\n6. 查找成功并返回引用后,将对这个字段进行权限验证,如果没有访问权限,则抛出IllegalAccessError\n\n### 方法解析\n1. 会先对方法所属的类或接口的符号引用进行解析\n2. 发现C是接口,抛异常\n3. 如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该方法的直接引用\n4. 父类中递归查找\n5. 实现的接口列表和父接口中递归查找\n6. 权限认证\n\n### 接口方法解析\n1. 会先对方法所属的类或接口的符号引用进行解析\n2. 发现C是类,不是接口,抛异常\n3. 如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该方法的直接引用\n4. 父接口中递归查找\n5. 因为允许接口的多继承,所以如果在不同的父接口中找到多个,则从多个方法中返回其中一个\n6. 因为接口所有方法默认public,所以JDK9之前没有模块化访问约束,不存在访问权限问题\n\n## 初始化\n1. 初始化阶段就是执行类构造器`<clinit>()`方法的过程,它是Javac编译器的自动生成物,是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并而成的。收集的顺序由在源文件出现的顺序决定\n2. 静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，只能赋值，不能访问\n3. 父类的`<clinit>()`先执行，所以父类中定义的静态语句块优先于之类的变量赋值操作\n4. `<clinit>()`方法不是必须的，如果没有类变量的赋值动作和静态语句块，则不为该类生成`<clinit>()`方法\n5. 执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法，只有父接口的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的`<clinit>()`方法\n6. 虚拟机保证一个类的`<clinit>()`方法在多线程环境被正确的加锁同步 \n\t\n\n# 类加载器\n\n类加载器:通过一个类的全限定类名来获取描述该类的二进制字节流 在Java虚拟机外实现\n\n## 类与类加载器\n\n每个类加载器都拥有一个独立的类名称空间\n\n一个类由他的类加载器和这个类本身一同确定其唯一性\n\n即使两个类来源于同一个类加载器,被同一个Java虚拟机加载,只要加载他们的类加载器不同,则着两个类必定不相等\n\n相等,包括了equals()方法,instanceof关键字等等\n\n## 双亲委派机制\n\n### 虚拟机角度\n\n启动类加载器(Bootstrap ClassLoader) 使用C++实现,是虚拟机自身的一部分\n\n其他所有类加载器:由Java实现,独立于虚拟机外部,全都继承自抽象类java.lang.ClassLoader\n\n### 开发人员角度\n\n保持着三层类加载器,双亲委派机制的类加载结构\n\n#### 启动类加载器(Bootstrap ClassLoader)\n\n负责加载存放在<JAVA_HOME>\\lib目录下,而且是虚拟机能够识别的类库加载到虚拟机内存中\n\n启动类加载器无法被Java程序直接引用,如果需要把加载请求委派给启动类加载器处理,则用null代替\n\n#### 扩展类加载器(Extension ClassLoader)\n\n负责加载<JAVA_HOME>\\lib\\ext目录下类库\n\n是一种Java系统类库的扩展机制\n\n允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能\n\n#### 应用程序类加载器(Application ClassLoader)\n\n也称为系统类加载器。\n\n负责加载用户类路径（ClassPath)上所有的类库。如果没有定义自己的类加载器，则它就是程序默认的类加载器\n\n### 双亲委派模型\n\n除了顶层的启动类加载器，其余的类加载器都应有自己的父类加载器，通常使用组合关系来复用父加载器的代码\n\n#### 工作过程\n\n如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载\n\n#### 优势\n\n类随着他的类加载器一起具备了一种带有优先级的层次关系\n\n例如Object类，无论哪个类加载器去加载他，都会委派到启动类加载器进行执行，因此Object类在不同的类加载器环境下都能保证是同一个类\n\n## 破坏双亲委派机制\n\n1. 第一次被“破坏”：兼容双亲委派机制出现之前已经存在的用户自定义类加载器的代码。按照loadClass（）方法的逻辑，如果父类加载失败，会调用自己的findClass（）方法来完成加载。这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派加载的\n2. 第二次被“破坏”：由于模型自身的缺陷导致的，如有基础类型又要调回用户的代码。但是显然启动类加载器不可能认识，加载这些代码。使用线程上下文类加载器，用父加载器去请求子类加载器去完成类加载的行为违背了双亲委派机制的一般性原则\n3. 由于用户对程序动态性的追求导致的。如代码热替换，模块热部署等等。此时的类加载器不再是双亲委派机制推荐的树状结构，而是更加复杂的网状结构","source":"_posts/JVM笔记/第7章_虚拟机类加载机制.md","raw":"---\ntitle: 深入理解Java虚拟机--虚拟机类加载机制\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第七章--虚拟机类加载机制。'\ncategories: JVM学习笔记\ntags:\n  - 深入理解Java虚拟机\n  - JVM\n  - 类加载器\nabbrlink: 92288fa0\ndate: 2020-07-11 00:00:00\n---\n\n# 概述\n\nJava虚拟机把描述类的数据从Class文件加载到内存,并进行加载,连接,初始化.这些都是在程序运行期间完成的。\n\nJava天生可以动态扩展的语言特性，就是依赖于运行期动态加载和动态连接实现的\n\nClass文件，指的是一串二进制字节流，并非特指某个存在于具体磁盘中的文件\n\n# 类加载的时机\n\n1. 整个生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载\n2. 加载，验证，准备，初始化，卸载顺序是确定的，必须按照这种顺序按部就班地开始，但不是按部就班地进行或完成。他们通常相互交叉地混合进行，会在一个阶段的执行过程中调用激活另一个阶段\n3. 解析阶段有可能在初始化阶段之后开始，因为要支持运行时绑定（动态绑定）\n\n## 立即对类进行初始化的六种情况：\n\n有且仅有这六种.这些行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用\n\n1. 遇到new,getstatic,putstatic,invokestatic这四种字节码指令，如果没有进行过初始化，则需要先触发其初始化阶段,典型情况：\n\t1. 使用new关键字实例化对象\n\t2. 读取或设置一个类型的静态字段\n\t3. 调用一个类的静态方法\n\t\n2. 使用java.lang.reflect包的方法对类进行反射调用。如果类没有初始化，则需要触发\n\n3. 初始化类，其父类还没有初始化\n\n4. 虚拟机启动时，需要指定执行主类（main())，先初始化这个主类\n\n5. 使用JDK7新加入的动态语言支持，方法句柄对应的类没有进行过初始化\n\n6. 一个接口定义了JDK8新加入的默认方法（被default修饰），如果这个接口的实现类发生了初始化，则该接口要在其之前进行初始化\n### 被动引用例子\n1. 通过其子类来引用父类中定义的静态字段,只会触发父类的不会触发之类的初始化。\n2. 创建类的数组，也只会自动生成一个继承于Object的数组类型，不会触发子类的初始化\n3. 引用类中定义的常量，因为编译期间通过常量优化，常量的值直接存储在使用的类的常量池中\n\n# 类加载的过程\n\n## 加载\n\n### 任务\n\n1. 通过一个类的全限定名获取定义该类的二进制字节流\n2. 将该字节流所代表的静态存储结构转换为方法区的运行时数据结构\n3. 在内存中生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口\n\n### 二进制字节流获取方式\n\n1. 从zip获取，如JAR\n2. 从网络中获取，如Web Applet\n3. 运行时计算生成，如动态代理技术\n4. 由其他文件生成，如JSP\n5. 从数据库中获取\n6. 从加密文件中获取，防Class文件被反编译的保护措施\n\n### 数组类的加载\n1. 如果数组的组件类型是引用类型，则会递归采用之前所说的加载过程去加载该组件类型，数组类将被标识在加载该组件类型的类加载器的类名称空间上\n2. 如果数组的组件类型不是引用类型，数组类将与引导类加载器关联\n3. 数组类的可访问性与它的组件类型一致， 如果数组的组件类型不是引用类型，则默认为是public\n### 加载结束\n加载阶段结束后，二进制字节流就按照格式存储在方法区之中了，然后会在Java堆内存中实例化一个Class对象，作为程序访问方法区中的类型数据的外部接口\n\n## 验证\n\n为了确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害到虚拟机自身的安全\n\n### 文件格式验证\n\n验证字节流是否符合Class文件格式的规范，并且被当前版本的虚拟机处理（例如是否以魔数开头，常量池中常量是否有不被支持的常量类型，CONSTANT_Utf8_info型的常量是否有不符合Utf8编码的数据）\n\n目的是保证输入的字节流能正确地解析并且存储在方法区之内，即格式上符合描述一个Java类型的要求\n\n### 元数据验证\n\n对字节码描述的信息进行语义分析，包括：\n\n1. 该类是否有父类\n2. 该类的父类是否继承了不允许继承的类（final修饰的类）\n3. 如果不是抽象类，是否实现了其父类或者接口要求实现的所有方法\n4. 类中字段，方法是否与父类产生矛盾（例如覆盖了父类的final方法，出现不符合规范的重载等等）\n### 字节码验证\n对类的方法体(Class文件中的Code属性)进行校验分析,保证被校验类的方法在运行时不会做出危害虚拟机安全的行为,例如:\n1. 保证任意时刻操作数栈的数据类型与指令的代码序列都能配合工作。不会出现类似于在操作数栈放置了一个int型的数据，使用却按long类型来加载入本地变量表中\n2. 保证任何跳转指令都不会跳转到方法体之外的字节码指令中\n3. 保证方法体中的类型转换都是有效的\n\n但不可能完全确保程序是安全的，因为停机问题理论：不能通过程序准确地检查出程序是否能在有效的时间之内结束运行\n### 符号引用验证\n发生在虚拟机将符号引用转化为直接引用的时候，发生在解析阶段。验证该类是否缺少或者被禁止访问它依赖的某些外部类，方法，字段等资源，通常检验：\n1. 符号引用中通过字符串描述的全限定名是否能找到对应的类\n2. 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段\n3. 符号引用中的类，字段，方法的可访问性\n\n## 准备\n正式为类中定义的静态变量分配内存并设置类变量初始值的阶段\n在JDK8中，类变量会随着Class对象一起放Java堆中\n不包括实例变量，实例变量会在对象实例化时随着对象一起分配在堆中\n通常情况下初始值是数据类型的零值，直到在类的初始化阶段通过类构造器的<clinit>()方法赋值\n但如果是final修饰，即存在ConstantValue属性，那在准备阶段就会被初始化为ConstantValue属性所指定的初始值\n\n## 解析\n1. 将常量池内的符号引用替换为直接引用的过程\n\n2. 符合引用：以一组符合来描述所引用的目标，可以是任何形式的字面量，与虚拟机实现的内存布局无关\n\n3. 直接引用：可以直接指向目标的指针，相对偏移量，或者是一个能间接定位到目标的句柄，与虚拟机实现的内存布局直接相关。如果有了直接引用，那引用目标必定已经在虚拟机的内存中存在\n\n4. 在执行操作符号引用的字节码指令之前，必须先堆它所使用的符号引用进行解析。可以自行判断在加载时就解析还是在使用前才解析\n\n### 类和接口的解析\n假设当前代码所处的类为D,要把从未解析过的符号引用N解析为一个类或接口C\n1. 如果C不是一个数组类型,虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C\n2. 如果C是一个数组类型,并且数组的元素类型为对象,会先按上面的方法加载数组元素类型,再由虚拟机生成一个代表该数组维度和元素的数组对象\n3. 在解析完成之前,要进行符号引用验证,确认D是否具备对C的访问权限\n\n### 字段解析\n1. 会先对字段所属的类或接口的符号引用进行解析\n2. 如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该字段的直接引用\n3. 否则,则按照继承关系从下往上递归搜索各个接口和它的父接口\n4. 否则,则按照继承关系从下往上递归搜索父类\n5. 找不到,则抛出NoSuchFieldError\n6. 查找成功并返回引用后,将对这个字段进行权限验证,如果没有访问权限,则抛出IllegalAccessError\n\n### 方法解析\n1. 会先对方法所属的类或接口的符号引用进行解析\n2. 发现C是接口,抛异常\n3. 如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该方法的直接引用\n4. 父类中递归查找\n5. 实现的接口列表和父接口中递归查找\n6. 权限认证\n\n### 接口方法解析\n1. 会先对方法所属的类或接口的符号引用进行解析\n2. 发现C是类,不是接口,抛异常\n3. 如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该方法的直接引用\n4. 父接口中递归查找\n5. 因为允许接口的多继承,所以如果在不同的父接口中找到多个,则从多个方法中返回其中一个\n6. 因为接口所有方法默认public,所以JDK9之前没有模块化访问约束,不存在访问权限问题\n\n## 初始化\n1. 初始化阶段就是执行类构造器`<clinit>()`方法的过程,它是Javac编译器的自动生成物,是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并而成的。收集的顺序由在源文件出现的顺序决定\n2. 静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，只能赋值，不能访问\n3. 父类的`<clinit>()`先执行，所以父类中定义的静态语句块优先于之类的变量赋值操作\n4. `<clinit>()`方法不是必须的，如果没有类变量的赋值动作和静态语句块，则不为该类生成`<clinit>()`方法\n5. 执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法，只有父接口的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的`<clinit>()`方法\n6. 虚拟机保证一个类的`<clinit>()`方法在多线程环境被正确的加锁同步 \n\t\n\n# 类加载器\n\n类加载器:通过一个类的全限定类名来获取描述该类的二进制字节流 在Java虚拟机外实现\n\n## 类与类加载器\n\n每个类加载器都拥有一个独立的类名称空间\n\n一个类由他的类加载器和这个类本身一同确定其唯一性\n\n即使两个类来源于同一个类加载器,被同一个Java虚拟机加载,只要加载他们的类加载器不同,则着两个类必定不相等\n\n相等,包括了equals()方法,instanceof关键字等等\n\n## 双亲委派机制\n\n### 虚拟机角度\n\n启动类加载器(Bootstrap ClassLoader) 使用C++实现,是虚拟机自身的一部分\n\n其他所有类加载器:由Java实现,独立于虚拟机外部,全都继承自抽象类java.lang.ClassLoader\n\n### 开发人员角度\n\n保持着三层类加载器,双亲委派机制的类加载结构\n\n#### 启动类加载器(Bootstrap ClassLoader)\n\n负责加载存放在<JAVA_HOME>\\lib目录下,而且是虚拟机能够识别的类库加载到虚拟机内存中\n\n启动类加载器无法被Java程序直接引用,如果需要把加载请求委派给启动类加载器处理,则用null代替\n\n#### 扩展类加载器(Extension ClassLoader)\n\n负责加载<JAVA_HOME>\\lib\\ext目录下类库\n\n是一种Java系统类库的扩展机制\n\n允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能\n\n#### 应用程序类加载器(Application ClassLoader)\n\n也称为系统类加载器。\n\n负责加载用户类路径（ClassPath)上所有的类库。如果没有定义自己的类加载器，则它就是程序默认的类加载器\n\n### 双亲委派模型\n\n除了顶层的启动类加载器，其余的类加载器都应有自己的父类加载器，通常使用组合关系来复用父加载器的代码\n\n#### 工作过程\n\n如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载\n\n#### 优势\n\n类随着他的类加载器一起具备了一种带有优先级的层次关系\n\n例如Object类，无论哪个类加载器去加载他，都会委派到启动类加载器进行执行，因此Object类在不同的类加载器环境下都能保证是同一个类\n\n## 破坏双亲委派机制\n\n1. 第一次被“破坏”：兼容双亲委派机制出现之前已经存在的用户自定义类加载器的代码。按照loadClass（）方法的逻辑，如果父类加载失败，会调用自己的findClass（）方法来完成加载。这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派加载的\n2. 第二次被“破坏”：由于模型自身的缺陷导致的，如有基础类型又要调回用户的代码。但是显然启动类加载器不可能认识，加载这些代码。使用线程上下文类加载器，用父加载器去请求子类加载器去完成类加载的行为违背了双亲委派机制的一般性原则\n3. 由于用户对程序动态性的追求导致的。如代码热替换，模块热部署等等。此时的类加载器不再是双亲委派机制推荐的树状结构，而是更加复杂的网状结构","slug":"JVM笔记/第7章_虚拟机类加载机制","published":1,"updated":"2020-11-12T11:57:29.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6vz000tjotpa3fverm9","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存,并进行加载,连接,初始化.这些都是在程序运行期间完成的。</p>\n<p>Java天生可以动态扩展的语言特性，就是依赖于运行期动态加载和动态连接实现的</p>\n<p>Class文件，指的是一串二进制字节流，并非特指某个存在于具体磁盘中的文件</p>\n<h1 id=\"类加载的时机\"><a href=\"#类加载的时机\" class=\"headerlink\" title=\"类加载的时机\"></a>类加载的时机</h1><ol>\n<li>整个生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载</li>\n<li>加载，验证，准备，初始化，卸载顺序是确定的，必须按照这种顺序按部就班地开始，但不是按部就班地进行或完成。他们通常相互交叉地混合进行，会在一个阶段的执行过程中调用激活另一个阶段</li>\n<li>解析阶段有可能在初始化阶段之后开始，因为要支持运行时绑定（动态绑定）</li>\n</ol>\n<h2 id=\"立即对类进行初始化的六种情况：\"><a href=\"#立即对类进行初始化的六种情况：\" class=\"headerlink\" title=\"立即对类进行初始化的六种情况：\"></a>立即对类进行初始化的六种情况：</h2><p>有且仅有这六种.这些行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用</p>\n<ol>\n<li><p>遇到new,getstatic,putstatic,invokestatic这四种字节码指令，如果没有进行过初始化，则需要先触发其初始化阶段,典型情况：</p>\n<ol>\n<li>使用new关键字实例化对象</li>\n<li>读取或设置一个类型的静态字段</li>\n<li>调用一个类的静态方法</li>\n</ol>\n</li>\n<li><p>使用java.lang.reflect包的方法对类进行反射调用。如果类没有初始化，则需要触发</p>\n</li>\n<li><p>初始化类，其父类还没有初始化</p>\n</li>\n<li><p>虚拟机启动时，需要指定执行主类（main())，先初始化这个主类</p>\n</li>\n<li><p>使用JDK7新加入的动态语言支持，方法句柄对应的类没有进行过初始化</p>\n</li>\n<li><p>一个接口定义了JDK8新加入的默认方法（被default修饰），如果这个接口的实现类发生了初始化，则该接口要在其之前进行初始化</p>\n<h3 id=\"被动引用例子\"><a href=\"#被动引用例子\" class=\"headerlink\" title=\"被动引用例子\"></a>被动引用例子</h3></li>\n<li><p>通过其子类来引用父类中定义的静态字段,只会触发父类的不会触发之类的初始化。</p>\n</li>\n<li><p>创建类的数组，也只会自动生成一个继承于Object的数组类型，不会触发子类的初始化</p>\n</li>\n<li><p>引用类中定义的常量，因为编译期间通过常量优化，常量的值直接存储在使用的类的常量池中</p>\n</li>\n</ol>\n<h1 id=\"类加载的过程\"><a href=\"#类加载的过程\" class=\"headerlink\" title=\"类加载的过程\"></a>类加载的过程</h1><h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><h3 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h3><ol>\n<li>通过一个类的全限定名获取定义该类的二进制字节流</li>\n<li>将该字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口</li>\n</ol>\n<h3 id=\"二进制字节流获取方式\"><a href=\"#二进制字节流获取方式\" class=\"headerlink\" title=\"二进制字节流获取方式\"></a>二进制字节流获取方式</h3><ol>\n<li>从zip获取，如JAR</li>\n<li>从网络中获取，如Web Applet</li>\n<li>运行时计算生成，如动态代理技术</li>\n<li>由其他文件生成，如JSP</li>\n<li>从数据库中获取</li>\n<li>从加密文件中获取，防Class文件被反编译的保护措施</li>\n</ol>\n<h3 id=\"数组类的加载\"><a href=\"#数组类的加载\" class=\"headerlink\" title=\"数组类的加载\"></a>数组类的加载</h3><ol>\n<li>如果数组的组件类型是引用类型，则会递归采用之前所说的加载过程去加载该组件类型，数组类将被标识在加载该组件类型的类加载器的类名称空间上</li>\n<li>如果数组的组件类型不是引用类型，数组类将与引导类加载器关联</li>\n<li>数组类的可访问性与它的组件类型一致， 如果数组的组件类型不是引用类型，则默认为是public<h3 id=\"加载结束\"><a href=\"#加载结束\" class=\"headerlink\" title=\"加载结束\"></a>加载结束</h3>加载阶段结束后，二进制字节流就按照格式存储在方法区之中了，然后会在Java堆内存中实例化一个Class对象，作为程序访问方法区中的类型数据的外部接口</li>\n</ol>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>为了确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害到虚拟机自身的安全</p>\n<h3 id=\"文件格式验证\"><a href=\"#文件格式验证\" class=\"headerlink\" title=\"文件格式验证\"></a>文件格式验证</h3><p>验证字节流是否符合Class文件格式的规范，并且被当前版本的虚拟机处理（例如是否以魔数开头，常量池中常量是否有不被支持的常量类型，CONSTANT_Utf8_info型的常量是否有不符合Utf8编码的数据）</p>\n<p>目的是保证输入的字节流能正确地解析并且存储在方法区之内，即格式上符合描述一个Java类型的要求</p>\n<h3 id=\"元数据验证\"><a href=\"#元数据验证\" class=\"headerlink\" title=\"元数据验证\"></a>元数据验证</h3><p>对字节码描述的信息进行语义分析，包括：</p>\n<ol>\n<li>该类是否有父类</li>\n<li>该类的父类是否继承了不允许继承的类（final修饰的类）</li>\n<li>如果不是抽象类，是否实现了其父类或者接口要求实现的所有方法</li>\n<li>类中字段，方法是否与父类产生矛盾（例如覆盖了父类的final方法，出现不符合规范的重载等等）<h3 id=\"字节码验证\"><a href=\"#字节码验证\" class=\"headerlink\" title=\"字节码验证\"></a>字节码验证</h3>对类的方法体(Class文件中的Code属性)进行校验分析,保证被校验类的方法在运行时不会做出危害虚拟机安全的行为,例如:</li>\n<li>保证任意时刻操作数栈的数据类型与指令的代码序列都能配合工作。不会出现类似于在操作数栈放置了一个int型的数据，使用却按long类型来加载入本地变量表中</li>\n<li>保证任何跳转指令都不会跳转到方法体之外的字节码指令中</li>\n<li>保证方法体中的类型转换都是有效的</li>\n</ol>\n<p>但不可能完全确保程序是安全的，因为停机问题理论：不能通过程序准确地检查出程序是否能在有效的时间之内结束运行</p>\n<h3 id=\"符号引用验证\"><a href=\"#符号引用验证\" class=\"headerlink\" title=\"符号引用验证\"></a>符号引用验证</h3><p>发生在虚拟机将符号引用转化为直接引用的时候，发生在解析阶段。验证该类是否缺少或者被禁止访问它依赖的某些外部类，方法，字段等资源，通常检验：</p>\n<ol>\n<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>\n<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>\n<li>符号引用中的类，字段，方法的可访问性</li>\n</ol>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>正式为类中定义的静态变量分配内存并设置类变量初始值的阶段<br>在JDK8中，类变量会随着Class对象一起放Java堆中<br>不包括实例变量，实例变量会在对象实例化时随着对象一起分配在堆中<br>通常情况下初始值是数据类型的零值，直到在类的初始化阶段通过类构造器的<clinit>()方法赋值<br>但如果是final修饰，即存在ConstantValue属性，那在准备阶段就会被初始化为ConstantValue属性所指定的初始值</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><ol>\n<li><p>将常量池内的符号引用替换为直接引用的过程</p>\n</li>\n<li><p>符合引用：以一组符合来描述所引用的目标，可以是任何形式的字面量，与虚拟机实现的内存布局无关</p>\n</li>\n<li><p>直接引用：可以直接指向目标的指针，相对偏移量，或者是一个能间接定位到目标的句柄，与虚拟机实现的内存布局直接相关。如果有了直接引用，那引用目标必定已经在虚拟机的内存中存在</p>\n</li>\n<li><p>在执行操作符号引用的字节码指令之前，必须先堆它所使用的符号引用进行解析。可以自行判断在加载时就解析还是在使用前才解析</p>\n</li>\n</ol>\n<h3 id=\"类和接口的解析\"><a href=\"#类和接口的解析\" class=\"headerlink\" title=\"类和接口的解析\"></a>类和接口的解析</h3><p>假设当前代码所处的类为D,要把从未解析过的符号引用N解析为一个类或接口C</p>\n<ol>\n<li>如果C不是一个数组类型,虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C</li>\n<li>如果C是一个数组类型,并且数组的元素类型为对象,会先按上面的方法加载数组元素类型,再由虚拟机生成一个代表该数组维度和元素的数组对象</li>\n<li>在解析完成之前,要进行符号引用验证,确认D是否具备对C的访问权限</li>\n</ol>\n<h3 id=\"字段解析\"><a href=\"#字段解析\" class=\"headerlink\" title=\"字段解析\"></a>字段解析</h3><ol>\n<li>会先对字段所属的类或接口的符号引用进行解析</li>\n<li>如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该字段的直接引用</li>\n<li>否则,则按照继承关系从下往上递归搜索各个接口和它的父接口</li>\n<li>否则,则按照继承关系从下往上递归搜索父类</li>\n<li>找不到,则抛出NoSuchFieldError</li>\n<li>查找成功并返回引用后,将对这个字段进行权限验证,如果没有访问权限,则抛出IllegalAccessError</li>\n</ol>\n<h3 id=\"方法解析\"><a href=\"#方法解析\" class=\"headerlink\" title=\"方法解析\"></a>方法解析</h3><ol>\n<li>会先对方法所属的类或接口的符号引用进行解析</li>\n<li>发现C是接口,抛异常</li>\n<li>如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该方法的直接引用</li>\n<li>父类中递归查找</li>\n<li>实现的接口列表和父接口中递归查找</li>\n<li>权限认证</li>\n</ol>\n<h3 id=\"接口方法解析\"><a href=\"#接口方法解析\" class=\"headerlink\" title=\"接口方法解析\"></a>接口方法解析</h3><ol>\n<li>会先对方法所属的类或接口的符号引用进行解析</li>\n<li>发现C是类,不是接口,抛异常</li>\n<li>如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该方法的直接引用</li>\n<li>父接口中递归查找</li>\n<li>因为允许接口的多继承,所以如果在不同的父接口中找到多个,则从多个方法中返回其中一个</li>\n<li>因为接口所有方法默认public,所以JDK9之前没有模块化访问约束,不存在访问权限问题</li>\n</ol>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><ol>\n<li>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程,它是Javac编译器的自动生成物,是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并而成的。收集的顺序由在源文件出现的顺序决定</li>\n<li>静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，只能赋值，不能访问</li>\n<li>父类的<code>&lt;clinit&gt;()</code>先执行，所以父类中定义的静态语句块优先于之类的变量赋值操作</li>\n<li><code>&lt;clinit&gt;()</code>方法不是必须的，如果没有类变量的赋值动作和静态语句块，则不为该类生成<code>&lt;clinit&gt;()</code>方法</li>\n<li>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，只有父接口的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法</li>\n<li>虚拟机保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境被正确的加锁同步 </li>\n</ol>\n<h1 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h1><p>类加载器:通过一个类的全限定类名来获取描述该类的二进制字节流 在Java虚拟机外实现</p>\n<h2 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h2><p>每个类加载器都拥有一个独立的类名称空间</p>\n<p>一个类由他的类加载器和这个类本身一同确定其唯一性</p>\n<p>即使两个类来源于同一个类加载器,被同一个Java虚拟机加载,只要加载他们的类加载器不同,则着两个类必定不相等</p>\n<p>相等,包括了equals()方法,instanceof关键字等等</p>\n<h2 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h2><h3 id=\"虚拟机角度\"><a href=\"#虚拟机角度\" class=\"headerlink\" title=\"虚拟机角度\"></a>虚拟机角度</h3><p>启动类加载器(Bootstrap ClassLoader) 使用C++实现,是虚拟机自身的一部分</p>\n<p>其他所有类加载器:由Java实现,独立于虚拟机外部,全都继承自抽象类java.lang.ClassLoader</p>\n<h3 id=\"开发人员角度\"><a href=\"#开发人员角度\" class=\"headerlink\" title=\"开发人员角度\"></a>开发人员角度</h3><p>保持着三层类加载器,双亲委派机制的类加载结构</p>\n<h4 id=\"启动类加载器-Bootstrap-ClassLoader\"><a href=\"#启动类加载器-Bootstrap-ClassLoader\" class=\"headerlink\" title=\"启动类加载器(Bootstrap ClassLoader)\"></a>启动类加载器(Bootstrap ClassLoader)</h4><p>负责加载存放在<JAVA_HOME>\\lib目录下,而且是虚拟机能够识别的类库加载到虚拟机内存中</p>\n<p>启动类加载器无法被Java程序直接引用,如果需要把加载请求委派给启动类加载器处理,则用null代替</p>\n<h4 id=\"扩展类加载器-Extension-ClassLoader\"><a href=\"#扩展类加载器-Extension-ClassLoader\" class=\"headerlink\" title=\"扩展类加载器(Extension ClassLoader)\"></a>扩展类加载器(Extension ClassLoader)</h4><p>负责加载<JAVA_HOME>\\lib\\ext目录下类库</p>\n<p>是一种Java系统类库的扩展机制</p>\n<p>允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能</p>\n<h4 id=\"应用程序类加载器-Application-ClassLoader\"><a href=\"#应用程序类加载器-Application-ClassLoader\" class=\"headerlink\" title=\"应用程序类加载器(Application ClassLoader)\"></a>应用程序类加载器(Application ClassLoader)</h4><p>也称为系统类加载器。</p>\n<p>负责加载用户类路径（ClassPath)上所有的类库。如果没有定义自己的类加载器，则它就是程序默认的类加载器</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>除了顶层的启动类加载器，其余的类加载器都应有自己的父类加载器，通常使用组合关系来复用父加载器的代码</p>\n<h4 id=\"工作过程\"><a href=\"#工作过程\" class=\"headerlink\" title=\"工作过程\"></a>工作过程</h4><p>如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p>类随着他的类加载器一起具备了一种带有优先级的层次关系</p>\n<p>例如Object类，无论哪个类加载器去加载他，都会委派到启动类加载器进行执行，因此Object类在不同的类加载器环境下都能保证是同一个类</p>\n<h2 id=\"破坏双亲委派机制\"><a href=\"#破坏双亲委派机制\" class=\"headerlink\" title=\"破坏双亲委派机制\"></a>破坏双亲委派机制</h2><ol>\n<li>第一次被“破坏”：兼容双亲委派机制出现之前已经存在的用户自定义类加载器的代码。按照loadClass（）方法的逻辑，如果父类加载失败，会调用自己的findClass（）方法来完成加载。这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派加载的</li>\n<li>第二次被“破坏”：由于模型自身的缺陷导致的，如有基础类型又要调回用户的代码。但是显然启动类加载器不可能认识，加载这些代码。使用线程上下文类加载器，用父加载器去请求子类加载器去完成类加载的行为违背了双亲委派机制的一般性原则</li>\n<li>由于用户对程序动态性的追求导致的。如代码热替换，模块热部署等等。此时的类加载器不再是双亲委派机制推荐的树状结构，而是更加复杂的网状结构</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存,并进行加载,连接,初始化.这些都是在程序运行期间完成的。</p>\n<p>Java天生可以动态扩展的语言特性，就是依赖于运行期动态加载和动态连接实现的</p>\n<p>Class文件，指的是一串二进制字节流，并非特指某个存在于具体磁盘中的文件</p>\n<h1 id=\"类加载的时机\"><a href=\"#类加载的时机\" class=\"headerlink\" title=\"类加载的时机\"></a>类加载的时机</h1><ol>\n<li>整个生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载</li>\n<li>加载，验证，准备，初始化，卸载顺序是确定的，必须按照这种顺序按部就班地开始，但不是按部就班地进行或完成。他们通常相互交叉地混合进行，会在一个阶段的执行过程中调用激活另一个阶段</li>\n<li>解析阶段有可能在初始化阶段之后开始，因为要支持运行时绑定（动态绑定）</li>\n</ol>\n<h2 id=\"立即对类进行初始化的六种情况：\"><a href=\"#立即对类进行初始化的六种情况：\" class=\"headerlink\" title=\"立即对类进行初始化的六种情况：\"></a>立即对类进行初始化的六种情况：</h2><p>有且仅有这六种.这些行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用</p>\n<ol>\n<li><p>遇到new,getstatic,putstatic,invokestatic这四种字节码指令，如果没有进行过初始化，则需要先触发其初始化阶段,典型情况：</p>\n<ol>\n<li>使用new关键字实例化对象</li>\n<li>读取或设置一个类型的静态字段</li>\n<li>调用一个类的静态方法</li>\n</ol>\n</li>\n<li><p>使用java.lang.reflect包的方法对类进行反射调用。如果类没有初始化，则需要触发</p>\n</li>\n<li><p>初始化类，其父类还没有初始化</p>\n</li>\n<li><p>虚拟机启动时，需要指定执行主类（main())，先初始化这个主类</p>\n</li>\n<li><p>使用JDK7新加入的动态语言支持，方法句柄对应的类没有进行过初始化</p>\n</li>\n<li><p>一个接口定义了JDK8新加入的默认方法（被default修饰），如果这个接口的实现类发生了初始化，则该接口要在其之前进行初始化</p>\n<h3 id=\"被动引用例子\"><a href=\"#被动引用例子\" class=\"headerlink\" title=\"被动引用例子\"></a>被动引用例子</h3></li>\n<li><p>通过其子类来引用父类中定义的静态字段,只会触发父类的不会触发之类的初始化。</p>\n</li>\n<li><p>创建类的数组，也只会自动生成一个继承于Object的数组类型，不会触发子类的初始化</p>\n</li>\n<li><p>引用类中定义的常量，因为编译期间通过常量优化，常量的值直接存储在使用的类的常量池中</p>\n</li>\n</ol>\n<h1 id=\"类加载的过程\"><a href=\"#类加载的过程\" class=\"headerlink\" title=\"类加载的过程\"></a>类加载的过程</h1><h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><h3 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h3><ol>\n<li>通过一个类的全限定名获取定义该类的二进制字节流</li>\n<li>将该字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口</li>\n</ol>\n<h3 id=\"二进制字节流获取方式\"><a href=\"#二进制字节流获取方式\" class=\"headerlink\" title=\"二进制字节流获取方式\"></a>二进制字节流获取方式</h3><ol>\n<li>从zip获取，如JAR</li>\n<li>从网络中获取，如Web Applet</li>\n<li>运行时计算生成，如动态代理技术</li>\n<li>由其他文件生成，如JSP</li>\n<li>从数据库中获取</li>\n<li>从加密文件中获取，防Class文件被反编译的保护措施</li>\n</ol>\n<h3 id=\"数组类的加载\"><a href=\"#数组类的加载\" class=\"headerlink\" title=\"数组类的加载\"></a>数组类的加载</h3><ol>\n<li>如果数组的组件类型是引用类型，则会递归采用之前所说的加载过程去加载该组件类型，数组类将被标识在加载该组件类型的类加载器的类名称空间上</li>\n<li>如果数组的组件类型不是引用类型，数组类将与引导类加载器关联</li>\n<li>数组类的可访问性与它的组件类型一致， 如果数组的组件类型不是引用类型，则默认为是public<h3 id=\"加载结束\"><a href=\"#加载结束\" class=\"headerlink\" title=\"加载结束\"></a>加载结束</h3>加载阶段结束后，二进制字节流就按照格式存储在方法区之中了，然后会在Java堆内存中实例化一个Class对象，作为程序访问方法区中的类型数据的外部接口</li>\n</ol>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>为了确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害到虚拟机自身的安全</p>\n<h3 id=\"文件格式验证\"><a href=\"#文件格式验证\" class=\"headerlink\" title=\"文件格式验证\"></a>文件格式验证</h3><p>验证字节流是否符合Class文件格式的规范，并且被当前版本的虚拟机处理（例如是否以魔数开头，常量池中常量是否有不被支持的常量类型，CONSTANT_Utf8_info型的常量是否有不符合Utf8编码的数据）</p>\n<p>目的是保证输入的字节流能正确地解析并且存储在方法区之内，即格式上符合描述一个Java类型的要求</p>\n<h3 id=\"元数据验证\"><a href=\"#元数据验证\" class=\"headerlink\" title=\"元数据验证\"></a>元数据验证</h3><p>对字节码描述的信息进行语义分析，包括：</p>\n<ol>\n<li>该类是否有父类</li>\n<li>该类的父类是否继承了不允许继承的类（final修饰的类）</li>\n<li>如果不是抽象类，是否实现了其父类或者接口要求实现的所有方法</li>\n<li>类中字段，方法是否与父类产生矛盾（例如覆盖了父类的final方法，出现不符合规范的重载等等）<h3 id=\"字节码验证\"><a href=\"#字节码验证\" class=\"headerlink\" title=\"字节码验证\"></a>字节码验证</h3>对类的方法体(Class文件中的Code属性)进行校验分析,保证被校验类的方法在运行时不会做出危害虚拟机安全的行为,例如:</li>\n<li>保证任意时刻操作数栈的数据类型与指令的代码序列都能配合工作。不会出现类似于在操作数栈放置了一个int型的数据，使用却按long类型来加载入本地变量表中</li>\n<li>保证任何跳转指令都不会跳转到方法体之外的字节码指令中</li>\n<li>保证方法体中的类型转换都是有效的</li>\n</ol>\n<p>但不可能完全确保程序是安全的，因为停机问题理论：不能通过程序准确地检查出程序是否能在有效的时间之内结束运行</p>\n<h3 id=\"符号引用验证\"><a href=\"#符号引用验证\" class=\"headerlink\" title=\"符号引用验证\"></a>符号引用验证</h3><p>发生在虚拟机将符号引用转化为直接引用的时候，发生在解析阶段。验证该类是否缺少或者被禁止访问它依赖的某些外部类，方法，字段等资源，通常检验：</p>\n<ol>\n<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>\n<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>\n<li>符号引用中的类，字段，方法的可访问性</li>\n</ol>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>正式为类中定义的静态变量分配内存并设置类变量初始值的阶段<br>在JDK8中，类变量会随着Class对象一起放Java堆中<br>不包括实例变量，实例变量会在对象实例化时随着对象一起分配在堆中<br>通常情况下初始值是数据类型的零值，直到在类的初始化阶段通过类构造器的<clinit>()方法赋值<br>但如果是final修饰，即存在ConstantValue属性，那在准备阶段就会被初始化为ConstantValue属性所指定的初始值</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><ol>\n<li><p>将常量池内的符号引用替换为直接引用的过程</p>\n</li>\n<li><p>符合引用：以一组符合来描述所引用的目标，可以是任何形式的字面量，与虚拟机实现的内存布局无关</p>\n</li>\n<li><p>直接引用：可以直接指向目标的指针，相对偏移量，或者是一个能间接定位到目标的句柄，与虚拟机实现的内存布局直接相关。如果有了直接引用，那引用目标必定已经在虚拟机的内存中存在</p>\n</li>\n<li><p>在执行操作符号引用的字节码指令之前，必须先堆它所使用的符号引用进行解析。可以自行判断在加载时就解析还是在使用前才解析</p>\n</li>\n</ol>\n<h3 id=\"类和接口的解析\"><a href=\"#类和接口的解析\" class=\"headerlink\" title=\"类和接口的解析\"></a>类和接口的解析</h3><p>假设当前代码所处的类为D,要把从未解析过的符号引用N解析为一个类或接口C</p>\n<ol>\n<li>如果C不是一个数组类型,虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C</li>\n<li>如果C是一个数组类型,并且数组的元素类型为对象,会先按上面的方法加载数组元素类型,再由虚拟机生成一个代表该数组维度和元素的数组对象</li>\n<li>在解析完成之前,要进行符号引用验证,确认D是否具备对C的访问权限</li>\n</ol>\n<h3 id=\"字段解析\"><a href=\"#字段解析\" class=\"headerlink\" title=\"字段解析\"></a>字段解析</h3><ol>\n<li>会先对字段所属的类或接口的符号引用进行解析</li>\n<li>如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该字段的直接引用</li>\n<li>否则,则按照继承关系从下往上递归搜索各个接口和它的父接口</li>\n<li>否则,则按照继承关系从下往上递归搜索父类</li>\n<li>找不到,则抛出NoSuchFieldError</li>\n<li>查找成功并返回引用后,将对这个字段进行权限验证,如果没有访问权限,则抛出IllegalAccessError</li>\n</ol>\n<h3 id=\"方法解析\"><a href=\"#方法解析\" class=\"headerlink\" title=\"方法解析\"></a>方法解析</h3><ol>\n<li>会先对方法所属的类或接口的符号引用进行解析</li>\n<li>发现C是接口,抛异常</li>\n<li>如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该方法的直接引用</li>\n<li>父类中递归查找</li>\n<li>实现的接口列表和父接口中递归查找</li>\n<li>权限认证</li>\n</ol>\n<h3 id=\"接口方法解析\"><a href=\"#接口方法解析\" class=\"headerlink\" title=\"接口方法解析\"></a>接口方法解析</h3><ol>\n<li>会先对方法所属的类或接口的符号引用进行解析</li>\n<li>发现C是类,不是接口,抛异常</li>\n<li>如果C本身包含了简单名称和字段描述符都与目标相匹配的字段,则返回该方法的直接引用</li>\n<li>父接口中递归查找</li>\n<li>因为允许接口的多继承,所以如果在不同的父接口中找到多个,则从多个方法中返回其中一个</li>\n<li>因为接口所有方法默认public,所以JDK9之前没有模块化访问约束,不存在访问权限问题</li>\n</ol>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><ol>\n<li>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程,它是Javac编译器的自动生成物,是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并而成的。收集的顺序由在源文件出现的顺序决定</li>\n<li>静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，只能赋值，不能访问</li>\n<li>父类的<code>&lt;clinit&gt;()</code>先执行，所以父类中定义的静态语句块优先于之类的变量赋值操作</li>\n<li><code>&lt;clinit&gt;()</code>方法不是必须的，如果没有类变量的赋值动作和静态语句块，则不为该类生成<code>&lt;clinit&gt;()</code>方法</li>\n<li>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，只有父接口的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法</li>\n<li>虚拟机保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境被正确的加锁同步 </li>\n</ol>\n<h1 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h1><p>类加载器:通过一个类的全限定类名来获取描述该类的二进制字节流 在Java虚拟机外实现</p>\n<h2 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h2><p>每个类加载器都拥有一个独立的类名称空间</p>\n<p>一个类由他的类加载器和这个类本身一同确定其唯一性</p>\n<p>即使两个类来源于同一个类加载器,被同一个Java虚拟机加载,只要加载他们的类加载器不同,则着两个类必定不相等</p>\n<p>相等,包括了equals()方法,instanceof关键字等等</p>\n<h2 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h2><h3 id=\"虚拟机角度\"><a href=\"#虚拟机角度\" class=\"headerlink\" title=\"虚拟机角度\"></a>虚拟机角度</h3><p>启动类加载器(Bootstrap ClassLoader) 使用C++实现,是虚拟机自身的一部分</p>\n<p>其他所有类加载器:由Java实现,独立于虚拟机外部,全都继承自抽象类java.lang.ClassLoader</p>\n<h3 id=\"开发人员角度\"><a href=\"#开发人员角度\" class=\"headerlink\" title=\"开发人员角度\"></a>开发人员角度</h3><p>保持着三层类加载器,双亲委派机制的类加载结构</p>\n<h4 id=\"启动类加载器-Bootstrap-ClassLoader\"><a href=\"#启动类加载器-Bootstrap-ClassLoader\" class=\"headerlink\" title=\"启动类加载器(Bootstrap ClassLoader)\"></a>启动类加载器(Bootstrap ClassLoader)</h4><p>负责加载存放在<JAVA_HOME>\\lib目录下,而且是虚拟机能够识别的类库加载到虚拟机内存中</p>\n<p>启动类加载器无法被Java程序直接引用,如果需要把加载请求委派给启动类加载器处理,则用null代替</p>\n<h4 id=\"扩展类加载器-Extension-ClassLoader\"><a href=\"#扩展类加载器-Extension-ClassLoader\" class=\"headerlink\" title=\"扩展类加载器(Extension ClassLoader)\"></a>扩展类加载器(Extension ClassLoader)</h4><p>负责加载<JAVA_HOME>\\lib\\ext目录下类库</p>\n<p>是一种Java系统类库的扩展机制</p>\n<p>允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能</p>\n<h4 id=\"应用程序类加载器-Application-ClassLoader\"><a href=\"#应用程序类加载器-Application-ClassLoader\" class=\"headerlink\" title=\"应用程序类加载器(Application ClassLoader)\"></a>应用程序类加载器(Application ClassLoader)</h4><p>也称为系统类加载器。</p>\n<p>负责加载用户类路径（ClassPath)上所有的类库。如果没有定义自己的类加载器，则它就是程序默认的类加载器</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>除了顶层的启动类加载器，其余的类加载器都应有自己的父类加载器，通常使用组合关系来复用父加载器的代码</p>\n<h4 id=\"工作过程\"><a href=\"#工作过程\" class=\"headerlink\" title=\"工作过程\"></a>工作过程</h4><p>如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p>类随着他的类加载器一起具备了一种带有优先级的层次关系</p>\n<p>例如Object类，无论哪个类加载器去加载他，都会委派到启动类加载器进行执行，因此Object类在不同的类加载器环境下都能保证是同一个类</p>\n<h2 id=\"破坏双亲委派机制\"><a href=\"#破坏双亲委派机制\" class=\"headerlink\" title=\"破坏双亲委派机制\"></a>破坏双亲委派机制</h2><ol>\n<li>第一次被“破坏”：兼容双亲委派机制出现之前已经存在的用户自定义类加载器的代码。按照loadClass（）方法的逻辑，如果父类加载失败，会调用自己的findClass（）方法来完成加载。这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派加载的</li>\n<li>第二次被“破坏”：由于模型自身的缺陷导致的，如有基础类型又要调回用户的代码。但是显然启动类加载器不可能认识，加载这些代码。使用线程上下文类加载器，用父加载器去请求子类加载器去完成类加载的行为违背了双亲委派机制的一般性原则</li>\n<li>由于用户对程序动态性的追求导致的。如代码热替换，模块热部署等等。此时的类加载器不再是双亲委派机制推荐的树状结构，而是更加复杂的网状结构</li>\n</ol>\n"},{"title":"Java基础--常见基础","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"Java基础知识,待完善,之后再看的时候会继续补充。","abbrlink":"e7b0c3c0","date":"2020-02-29T16:00:00.000Z","_content":"1. > int 4字节 (-2的31次方)~(2的31次方-1) \n   >\n   > short 2字节\n   >\n   > long 8字节\n   >\n   > byte 1字节 (-128~127)\n   >\n   > float 四字节\n   >\n   > double 8字节\n   >\n   > byte 2字节     因为Java采用16位的Unicode字符集\n   >\n   > boolean 只有两个值,但是大小没精确定义\n\n2. > 0x开头代表十六进制,如:0xCAFE \n   >\n   > 0b开头代表二进制数,如:0b1001\n\n3. > ```java\n   > System.out.printf(\"%8.2f\",x);\n   > //s为字符串，f为浮点数，d为十进制数\n   > //用8字符的宽度和小数点后两位的精度打印x\n   > ```\n\n4. > Java总是按值调用\n\t>\n\t> 如果是基本数据类型,那么值不变\n\t>\n\t> 引用数据类型:引用被拷贝,指向的是原对象,所以仍能改变对象值\n\n5. > Object类equals()方法:\n\t>\n\t> 底层调用==来实现,判断两个对象是否具有相同的引用\n\t>\n\t> 若是比较状态是否相等\n\t>\n\t> ```java\n\t> public boolean equals(Object obj)\n\t> {\n\t>     if(this==obj) return true;\n\t>     if(obj==null) return false;\n\t>     if(getClass()!=obj.getClass()) return false;\n\t> \n\t>     Person person = (Person) obj;\n\t>     return Objects.equals(name, person.name) &&\n\t>         Objects.equals(age, person.age);\n\t> }\n\t> \n\t> /*\n\t> Objects.equals():\n\t> public static boolean equals(Object a, Object b) \n\t> {\n\t>     return (a == b) || (a != null && a.equals(b));\n\t> }\n\t> */\n\t> ```\n6. >  Object类hashCode()方法\n\t>\n\t>  如果重新定义equals方法,则需要重新定义hashCode()方法\n\t>\n\t>  ```java\n\t>  @Override\n\t>  public int hashCode()\n\t>  {\n\t>      return Objects.hash(name, age);\n\t>  }\n\t>  ```\n\n7. > 自动装箱,自动拆箱,在-128,127之间会被包装到固定的对象,会导致\n\t>\n\t> ```java\n\t> Integer a=10;\n\t> Integer b=10;\n\t> if(a==b)//结果为true\n\t> ```\n\n8. > 异常\n\t>\n\t> ```java \n\t> Throwable \n\t>  \tError 非受查异常\n\t>  \tException\n\t>  \t\tIOException等 受查异常\n\t>  \t\tRuntimeException 非受查异常\n\t> ```\n\t>   一个方法必须声明所有可能抛出的受查异常.非受查异常要么不可控制,要么应该避免发生.\n    >     \t\n\n​\t\n\n\n\n1. 多态,父类引用指向子类对象.编译看左边,运行看右边.\n\n2. ```java\n   SimpleDateFormat dateFormat =\n     new SimpleDateFormat(\"yyyy年MM月dd日\");\n   Date date = new Date();\n   System.out.println(dateFormat.format(date));\n   ```\n\n3. ```java\n   StringBuilder builder = new StringBuilder(\"A\");\n   builder.append(\"BC\");\n   String s = builder.toString();\n   ```\n\n4. ```java\n   Integer.parseInt(string);\n   ```\n\n5. ```java\n   <? extend E>泛型中必须是本身或者子类\n   ```\n\n6. ```java\n   Collections.shuffle(poker);\n   Collections.sort(poker);\n   Collections.addAll(poker, \"A\", \"B\");\n   ```\n\n\n\n1. ```java\n   //运行期异常可以不进行异常处理(RuntimeException).抛出异常\n   if(s==null)\n   {\n     throw new NullPointerException(\"传递对象为空\");\n   }\n\n   //编译期异常必须进行异常处理\n    public static void main(String[] args) \n      throws FileNotFoundException\n    {\n      throw new FileNotFoundException(\"aa\");\n    }\n\n   try{}\n   catch (RuntimeException e)\n   {\n     e.printStackTrace();\n   }\n   finally{}\n   ```\n\n2. ```java\n    new Thread()\n    {\n      @Override\n      public void run()\n      {\n        for (int i = 0; i < 20; i++)\n        \tSystem.out.println(i);     \n      }\n    }.start();\n   Thread.sleep(1000);\n   ```\n\n3. ```java\n   //同步方法 线程安全 锁对象是this\n   public synchronized void payTicket(){}\n\n   //等待唤醒机制,实现线程通信\n   Object obj = new Object();\n   new Thread()\n   {\n     @Override\n     public void run()\n     {\n       synchronized (obj)\n       {\n         obj.wait();\n       }\n     }\n   }.start();\n\n   new Thread()\n   {\n     @Override\n     public void run()\n     {\n       Thread.sleep(5000);\n       synchronized (obj)\n       {\n         obj.notify();\n       }\n     }\n   }.start();\n   ```\n\n4. ```java\n   //用线程池管理线程\n   ExecutorService es = Executors.newFixedThreadPool(2);\n   es.submit(\n     new Runnable()\n     {\n       @Override\n       public void run()\n       {\n         System.out.println(\"AA\");\n       }\n     });\n   ```\n\n5. ```java\n   /*函数式编程 只要获取结果就行,不注重谁去做\n   适合只想传递一段代码的情况\n   Lambda表达式\n   */\n   public interface Cook\n   {\n       void invokeCooke();\n   }\n   public class CookImpl\n   {\n       public static void main(String[] args)\n       {\n           test(()->\n           {\n               System.out.println(\"吃饭了\");\n           });\n       }\n\n       public static void test(Cook cook)\n       {\n           cook.invokeCooke();\n       }\n   }\n\n   /*******************带参数的省略写法************************/\n   public interface Cook\n   {\n       int invokeCooke(int a,int b);\n   }\n   public class CookImpl\n   {\n       public static void main(String[] args)\n       {\n           test(12,13,(a,b)-> a+b);\n       }\n\n       public static void test(int a,int b,Cook cook)\n       {\n           int result=cook.invokeCooke(a,b);\n           System.out.println(result);\n       }\n   }\n   ```\n\n6. ```java\n   //相对路径 相当于当前项目的根目录 //C:\\code_home\\idea_home\\JAVA\\DouDiZhu\n   File file = new File(\"DouDiZhu\");\n   System.out.println(file.getAbsolutePath());\n   ```\n\n7. ```java\n   //字符流处理中文问题\n    FileReader fileReader = new FileReader(\"D:\\\\test.txt\");\n   char[] chars = new char[1024];//读取到chars中\n   int len = 0;//len记录每次读取的字符个数\n   while((len=fileReader.read(chars))!=-1)\n   {\n     System.out.println(new String(chars,0,len));\n   }\n   ```\n\n8. ```java\n   //流对象自动关闭,无需手动close\n   public static void main(String[] args) \n     throws FileNotFoundException\n   {\n     try(FileInputStream fileInputStream = \n         new FileInputStream(\"D:\\\\00001.jpg\");\n         FileOutputStream fileOutputStream = \n         new FileOutputStream(\"D:\\\\copy.jpg\");)\n     {\n       byte[] bytes = new byte[1024];\n       int length;\n       while((length=fileInputStream.read(bytes))!=-1)\n       {\n         fileOutputStream.write(bytes,0,length);\n       }\n     }\n     catch (IOException e)\n     {\n       e.printStackTrace();\n     }\n     //fileOutputStream.close();\n     //fileInputStream.close();\n   }\n   ```\n\n9. ```java\n   //配置文件加载与存储\n   Properties properties = new Properties();\n   properties.setProperty(\"李\", \"168\");\n   properties.setProperty(\"BA\", \"1688\");\n   properties.setProperty(\"CA\", \"168888\");\n   properties.store(new FileWriter(\"D:\\\\test.txt\"),\"save data\");//存储硬盘中\n\n   Properties properties = new Properties();//加载硬盘中\n   properties.load(new FileReader(\"D:\\\\test.txt\"));\n   Set<String> strings = properties.stringPropertyNames();\n   for (String string : strings)\n   {\n     System.out.println(string+\" \"+properties.getProperty(string));\n   }\n   //配置文件基本表示类型\n   /*\n   #save data\n   #Wed Feb 05 11:12:12 CST 2020\n   李=168\n   CA=168888\n   BA=1688\n   */\n   ```\n\n10. ```java\n    HashMap<String, String> hashMap = new HashMap<>();\n    BufferedReader bufferedReader = \n      new BufferedReader(new FileReader(\"D:\\\\test.txt\"));\n    String line;\n    while((line=bufferedReader.readLine())!=null)\n    {\n      String[] strings = line.split(\"\\\\.\");\n      hashMap.put(strings[0], strings[1]);\n    }\n    //如果放在上面就会没了\n    BufferedWriter bufferedWriter = \n      new BufferedWriter(new FileWriter(\"D:\\\\test.txt\"));\n    for(String key:hashMap.keySet())\n    {\n      String value = hashMap.get(key);\n      line = key + \".\" + value;\n      bufferedWriter.write(line);\n      bufferedWriter.newLine();\n    }\n    bufferedReader.close();\n    bufferedWriter.close();\n    }\n    ```\n\n11. ```java\n    idea默认编码UTF-8,win10默认编码GBK\n    ```\n\n12. ipconfig  127.0.0.1 localhost 代表自己  \n\n13. 端口号 0-65535  1024之前的端口不能使用\n\n14. 网络端口:80     MySQL:3306      tomcat服务器:8080\n\n15. ```java\n    //网络编程\n    //客户端\n    Socket socket = new Socket(\"127.0.0.1\", 8888);\n    OutputStream outputStream = socket.getOutputStream();\n    outputStream.write(\"你好,服务器\".getBytes());\n\n    InputStream inputStream = socket.getInputStream();\n    byte[] bytes = new byte[1024];\n    int len = inputStream.read(bytes);\n    System.out.println(new String(bytes,0,len));\n    /*******************服务器端*******************/\n    ServerSocket serverSocket = new ServerSocket(8888);\n    Socket socket = serverSocket.accept();\n    InputStream inputStream = socket.getInputStream();\n    byte[] bytes = new byte[1024];\n    int len = inputStream.read(bytes);\n    System.out.println(new String(bytes,0,len));\n    socket.getOutputStream().write(\"收到谢谢\".getBytes());\n\n    ```\n\n16. ```java\n    //检测是否是函数式接口 有且仅有一个抽象方法\n    @FunctionalInterface\n    public interface Test\n    {\n        void test1();\n    }\n    public class Demo\n    {\n        public static void main(String[] args)\n        {\n            show(() -> System.out.println(\"AA\"));\n        }\n\n        public static void show(Test myTest)\n        {\n            myTest.test1();\n        }\n    }\n\n    ```\n\n17. ```java\n    //stream流式模型 相当于对一个list或者数组进行一系列处理,然后对剩下的集合打印或者其他操作\n    public static void main(String[] args)\n    {\n      List<String> list = new ArrayList<>();\n      list.add(\"AAA\");\n      list.add(\"AAB\");\n      list.stream().\n        filter(name->name.startsWith(\"A\")).\n        filter(name->name.length()==3).\n        forEach(name->System.out.println(name));\n    }\n    ```\n\n\n    //一种数据类型转换为另外一种\n    Stream<String> stream = Stream.of(\"12\", \"23\", \"45\");\n    Stream<Integer> stream1=stream.map((String name) ->\n     {\n           return Integer.parseInt(name);\n     });\n    stream1.forEach(i->System.out.println(i));\n    \n    Stream<String> stream = Stream.of(\"12\", \"23\", \"45\",\"78\");\n    System.out.println(stream.limit(3).count());\n    ```\n\n18. ```java\n    //junit\n    //@Before使得所有测试方法先执行该方法\n    @Before\n    public void init()\n    {\n      System.out.println(\"init..\");\n    }\n\n    @After\n    public void close()\n    {\n      System.out.println(\"close..\");\n    }\n\n    @Test\n    public void testIt()\n    {\n      Demo demo = new Demo();\n      demo.test(2,3);\n    }\n    ```\n\n19. ```java\n    //三种反射获得方式\n    //全类名\n    Class.forName(\"com.tongji.Student\");\n    Class clazz = Student.class;\n    Student student = new Student();\n    student.getClass();\n\n    //一个案例\n    Properties properties = new Properties();\n    InputStream inputStream = ReflectTest.class.getClassLoader().\n      getResourceAsStream(\"com/tongji/test/pro.properties\");\n    properties.load(inputStream);\n\n    String className = properties.getProperty(\"className\");\n    String methodName = properties.getProperty(\"methodName\");\n    Class cls = Class.forName(className);\n    Object object = cls.newInstance();\n    Method method = cls.getMethod(methodName);\n    method.invoke(object);\n    ```\n\n20. ```java\n    @Deprecated  代表方法已经过时\n    @SuppressWarnings(\"all\")  抑制警告\n    @Override 重写方法\n    ```\n\n    \n\n\n\n\n\n\n\n","source":"_posts/Java笔记/JAVASE.md","raw":"---\ntitle: Java基础--常见基础\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 'Java基础知识,待完善,之后再看的时候会继续补充。'\ncategories: Java基础\ntags:\n  - Java基础\nabbrlink: e7b0c3c0\ndate: 2020-03-01 00:00:00\n---\n1. > int 4字节 (-2的31次方)~(2的31次方-1) \n   >\n   > short 2字节\n   >\n   > long 8字节\n   >\n   > byte 1字节 (-128~127)\n   >\n   > float 四字节\n   >\n   > double 8字节\n   >\n   > byte 2字节     因为Java采用16位的Unicode字符集\n   >\n   > boolean 只有两个值,但是大小没精确定义\n\n2. > 0x开头代表十六进制,如:0xCAFE \n   >\n   > 0b开头代表二进制数,如:0b1001\n\n3. > ```java\n   > System.out.printf(\"%8.2f\",x);\n   > //s为字符串，f为浮点数，d为十进制数\n   > //用8字符的宽度和小数点后两位的精度打印x\n   > ```\n\n4. > Java总是按值调用\n\t>\n\t> 如果是基本数据类型,那么值不变\n\t>\n\t> 引用数据类型:引用被拷贝,指向的是原对象,所以仍能改变对象值\n\n5. > Object类equals()方法:\n\t>\n\t> 底层调用==来实现,判断两个对象是否具有相同的引用\n\t>\n\t> 若是比较状态是否相等\n\t>\n\t> ```java\n\t> public boolean equals(Object obj)\n\t> {\n\t>     if(this==obj) return true;\n\t>     if(obj==null) return false;\n\t>     if(getClass()!=obj.getClass()) return false;\n\t> \n\t>     Person person = (Person) obj;\n\t>     return Objects.equals(name, person.name) &&\n\t>         Objects.equals(age, person.age);\n\t> }\n\t> \n\t> /*\n\t> Objects.equals():\n\t> public static boolean equals(Object a, Object b) \n\t> {\n\t>     return (a == b) || (a != null && a.equals(b));\n\t> }\n\t> */\n\t> ```\n6. >  Object类hashCode()方法\n\t>\n\t>  如果重新定义equals方法,则需要重新定义hashCode()方法\n\t>\n\t>  ```java\n\t>  @Override\n\t>  public int hashCode()\n\t>  {\n\t>      return Objects.hash(name, age);\n\t>  }\n\t>  ```\n\n7. > 自动装箱,自动拆箱,在-128,127之间会被包装到固定的对象,会导致\n\t>\n\t> ```java\n\t> Integer a=10;\n\t> Integer b=10;\n\t> if(a==b)//结果为true\n\t> ```\n\n8. > 异常\n\t>\n\t> ```java \n\t> Throwable \n\t>  \tError 非受查异常\n\t>  \tException\n\t>  \t\tIOException等 受查异常\n\t>  \t\tRuntimeException 非受查异常\n\t> ```\n\t>   一个方法必须声明所有可能抛出的受查异常.非受查异常要么不可控制,要么应该避免发生.\n    >     \t\n\n​\t\n\n\n\n1. 多态,父类引用指向子类对象.编译看左边,运行看右边.\n\n2. ```java\n   SimpleDateFormat dateFormat =\n     new SimpleDateFormat(\"yyyy年MM月dd日\");\n   Date date = new Date();\n   System.out.println(dateFormat.format(date));\n   ```\n\n3. ```java\n   StringBuilder builder = new StringBuilder(\"A\");\n   builder.append(\"BC\");\n   String s = builder.toString();\n   ```\n\n4. ```java\n   Integer.parseInt(string);\n   ```\n\n5. ```java\n   <? extend E>泛型中必须是本身或者子类\n   ```\n\n6. ```java\n   Collections.shuffle(poker);\n   Collections.sort(poker);\n   Collections.addAll(poker, \"A\", \"B\");\n   ```\n\n\n\n1. ```java\n   //运行期异常可以不进行异常处理(RuntimeException).抛出异常\n   if(s==null)\n   {\n     throw new NullPointerException(\"传递对象为空\");\n   }\n\n   //编译期异常必须进行异常处理\n    public static void main(String[] args) \n      throws FileNotFoundException\n    {\n      throw new FileNotFoundException(\"aa\");\n    }\n\n   try{}\n   catch (RuntimeException e)\n   {\n     e.printStackTrace();\n   }\n   finally{}\n   ```\n\n2. ```java\n    new Thread()\n    {\n      @Override\n      public void run()\n      {\n        for (int i = 0; i < 20; i++)\n        \tSystem.out.println(i);     \n      }\n    }.start();\n   Thread.sleep(1000);\n   ```\n\n3. ```java\n   //同步方法 线程安全 锁对象是this\n   public synchronized void payTicket(){}\n\n   //等待唤醒机制,实现线程通信\n   Object obj = new Object();\n   new Thread()\n   {\n     @Override\n     public void run()\n     {\n       synchronized (obj)\n       {\n         obj.wait();\n       }\n     }\n   }.start();\n\n   new Thread()\n   {\n     @Override\n     public void run()\n     {\n       Thread.sleep(5000);\n       synchronized (obj)\n       {\n         obj.notify();\n       }\n     }\n   }.start();\n   ```\n\n4. ```java\n   //用线程池管理线程\n   ExecutorService es = Executors.newFixedThreadPool(2);\n   es.submit(\n     new Runnable()\n     {\n       @Override\n       public void run()\n       {\n         System.out.println(\"AA\");\n       }\n     });\n   ```\n\n5. ```java\n   /*函数式编程 只要获取结果就行,不注重谁去做\n   适合只想传递一段代码的情况\n   Lambda表达式\n   */\n   public interface Cook\n   {\n       void invokeCooke();\n   }\n   public class CookImpl\n   {\n       public static void main(String[] args)\n       {\n           test(()->\n           {\n               System.out.println(\"吃饭了\");\n           });\n       }\n\n       public static void test(Cook cook)\n       {\n           cook.invokeCooke();\n       }\n   }\n\n   /*******************带参数的省略写法************************/\n   public interface Cook\n   {\n       int invokeCooke(int a,int b);\n   }\n   public class CookImpl\n   {\n       public static void main(String[] args)\n       {\n           test(12,13,(a,b)-> a+b);\n       }\n\n       public static void test(int a,int b,Cook cook)\n       {\n           int result=cook.invokeCooke(a,b);\n           System.out.println(result);\n       }\n   }\n   ```\n\n6. ```java\n   //相对路径 相当于当前项目的根目录 //C:\\code_home\\idea_home\\JAVA\\DouDiZhu\n   File file = new File(\"DouDiZhu\");\n   System.out.println(file.getAbsolutePath());\n   ```\n\n7. ```java\n   //字符流处理中文问题\n    FileReader fileReader = new FileReader(\"D:\\\\test.txt\");\n   char[] chars = new char[1024];//读取到chars中\n   int len = 0;//len记录每次读取的字符个数\n   while((len=fileReader.read(chars))!=-1)\n   {\n     System.out.println(new String(chars,0,len));\n   }\n   ```\n\n8. ```java\n   //流对象自动关闭,无需手动close\n   public static void main(String[] args) \n     throws FileNotFoundException\n   {\n     try(FileInputStream fileInputStream = \n         new FileInputStream(\"D:\\\\00001.jpg\");\n         FileOutputStream fileOutputStream = \n         new FileOutputStream(\"D:\\\\copy.jpg\");)\n     {\n       byte[] bytes = new byte[1024];\n       int length;\n       while((length=fileInputStream.read(bytes))!=-1)\n       {\n         fileOutputStream.write(bytes,0,length);\n       }\n     }\n     catch (IOException e)\n     {\n       e.printStackTrace();\n     }\n     //fileOutputStream.close();\n     //fileInputStream.close();\n   }\n   ```\n\n9. ```java\n   //配置文件加载与存储\n   Properties properties = new Properties();\n   properties.setProperty(\"李\", \"168\");\n   properties.setProperty(\"BA\", \"1688\");\n   properties.setProperty(\"CA\", \"168888\");\n   properties.store(new FileWriter(\"D:\\\\test.txt\"),\"save data\");//存储硬盘中\n\n   Properties properties = new Properties();//加载硬盘中\n   properties.load(new FileReader(\"D:\\\\test.txt\"));\n   Set<String> strings = properties.stringPropertyNames();\n   for (String string : strings)\n   {\n     System.out.println(string+\" \"+properties.getProperty(string));\n   }\n   //配置文件基本表示类型\n   /*\n   #save data\n   #Wed Feb 05 11:12:12 CST 2020\n   李=168\n   CA=168888\n   BA=1688\n   */\n   ```\n\n10. ```java\n    HashMap<String, String> hashMap = new HashMap<>();\n    BufferedReader bufferedReader = \n      new BufferedReader(new FileReader(\"D:\\\\test.txt\"));\n    String line;\n    while((line=bufferedReader.readLine())!=null)\n    {\n      String[] strings = line.split(\"\\\\.\");\n      hashMap.put(strings[0], strings[1]);\n    }\n    //如果放在上面就会没了\n    BufferedWriter bufferedWriter = \n      new BufferedWriter(new FileWriter(\"D:\\\\test.txt\"));\n    for(String key:hashMap.keySet())\n    {\n      String value = hashMap.get(key);\n      line = key + \".\" + value;\n      bufferedWriter.write(line);\n      bufferedWriter.newLine();\n    }\n    bufferedReader.close();\n    bufferedWriter.close();\n    }\n    ```\n\n11. ```java\n    idea默认编码UTF-8,win10默认编码GBK\n    ```\n\n12. ipconfig  127.0.0.1 localhost 代表自己  \n\n13. 端口号 0-65535  1024之前的端口不能使用\n\n14. 网络端口:80     MySQL:3306      tomcat服务器:8080\n\n15. ```java\n    //网络编程\n    //客户端\n    Socket socket = new Socket(\"127.0.0.1\", 8888);\n    OutputStream outputStream = socket.getOutputStream();\n    outputStream.write(\"你好,服务器\".getBytes());\n\n    InputStream inputStream = socket.getInputStream();\n    byte[] bytes = new byte[1024];\n    int len = inputStream.read(bytes);\n    System.out.println(new String(bytes,0,len));\n    /*******************服务器端*******************/\n    ServerSocket serverSocket = new ServerSocket(8888);\n    Socket socket = serverSocket.accept();\n    InputStream inputStream = socket.getInputStream();\n    byte[] bytes = new byte[1024];\n    int len = inputStream.read(bytes);\n    System.out.println(new String(bytes,0,len));\n    socket.getOutputStream().write(\"收到谢谢\".getBytes());\n\n    ```\n\n16. ```java\n    //检测是否是函数式接口 有且仅有一个抽象方法\n    @FunctionalInterface\n    public interface Test\n    {\n        void test1();\n    }\n    public class Demo\n    {\n        public static void main(String[] args)\n        {\n            show(() -> System.out.println(\"AA\"));\n        }\n\n        public static void show(Test myTest)\n        {\n            myTest.test1();\n        }\n    }\n\n    ```\n\n17. ```java\n    //stream流式模型 相当于对一个list或者数组进行一系列处理,然后对剩下的集合打印或者其他操作\n    public static void main(String[] args)\n    {\n      List<String> list = new ArrayList<>();\n      list.add(\"AAA\");\n      list.add(\"AAB\");\n      list.stream().\n        filter(name->name.startsWith(\"A\")).\n        filter(name->name.length()==3).\n        forEach(name->System.out.println(name));\n    }\n    ```\n\n\n    //一种数据类型转换为另外一种\n    Stream<String> stream = Stream.of(\"12\", \"23\", \"45\");\n    Stream<Integer> stream1=stream.map((String name) ->\n     {\n           return Integer.parseInt(name);\n     });\n    stream1.forEach(i->System.out.println(i));\n    \n    Stream<String> stream = Stream.of(\"12\", \"23\", \"45\",\"78\");\n    System.out.println(stream.limit(3).count());\n    ```\n\n18. ```java\n    //junit\n    //@Before使得所有测试方法先执行该方法\n    @Before\n    public void init()\n    {\n      System.out.println(\"init..\");\n    }\n\n    @After\n    public void close()\n    {\n      System.out.println(\"close..\");\n    }\n\n    @Test\n    public void testIt()\n    {\n      Demo demo = new Demo();\n      demo.test(2,3);\n    }\n    ```\n\n19. ```java\n    //三种反射获得方式\n    //全类名\n    Class.forName(\"com.tongji.Student\");\n    Class clazz = Student.class;\n    Student student = new Student();\n    student.getClass();\n\n    //一个案例\n    Properties properties = new Properties();\n    InputStream inputStream = ReflectTest.class.getClassLoader().\n      getResourceAsStream(\"com/tongji/test/pro.properties\");\n    properties.load(inputStream);\n\n    String className = properties.getProperty(\"className\");\n    String methodName = properties.getProperty(\"methodName\");\n    Class cls = Class.forName(className);\n    Object object = cls.newInstance();\n    Method method = cls.getMethod(methodName);\n    method.invoke(object);\n    ```\n\n20. ```java\n    @Deprecated  代表方法已经过时\n    @SuppressWarnings(\"all\")  抑制警告\n    @Override 重写方法\n    ```\n\n    \n\n\n\n\n\n\n\n","slug":"Java笔记/JAVASE","published":1,"updated":"2020-11-12T11:57:29.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6w2000xjotpgcirgk67","content":"<ol>\n<li><blockquote>\n<p>int 4字节 (-2的31次方)~(2的31次方-1) </p>\n<p>short 2字节</p>\n<p>long 8字节</p>\n<p>byte 1字节 (-128~127)</p>\n<p>float 四字节</p>\n<p>double 8字节</p>\n<p>byte 2字节     因为Java采用16位的Unicode字符集</p>\n<p>boolean 只有两个值,但是大小没精确定义</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>0x开头代表十六进制,如:0xCAFE </p>\n<p>0b开头代表二进制数,如:0b1001</p>\n</blockquote>\n</li>\n<li><blockquote>\n<pre class=\" language-java\"><code class=\"language-java\">System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%8.2f\"</span><span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//s为字符串，f为浮点数，d为十进制数</span>\n<span class=\"token comment\" spellcheck=\"true\">//用8字符的宽度和小数点后两位的精度打印x</span></code></pre>\n</blockquote>\n</li>\n<li><blockquote>\n<p>Java总是按值调用</p>\n<p>如果是基本数据类型,那么值不变</p>\n<p>引用数据类型:引用被拷贝,指向的是原对象,所以仍能改变对象值</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>Object类equals()方法:</p>\n<p>底层调用==来实现,判断两个对象是否具有相同的引用</p>\n<p>若是比较状态是否相等</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>Object obj<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token operator\">==</span>obj<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>obj<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!=</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n    Person person <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Person<span class=\"token punctuation\">)</span> obj<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Objects<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n        Objects<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">,</span> person<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/*\nObjects.equals():\npublic static boolean equals(Object a, Object b) \n{\n    return (a == b) || (a != null &amp;&amp; a.equals(b));\n}\n*/</span></code></pre>\n</blockquote>\n</li>\n<li><blockquote>\n<p> Object类hashCode()方法</p>\n<p> 如果重新定义equals方法,则需要重新定义hashCode()方法</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Objects<span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</blockquote>\n</li>\n<li><blockquote>\n<p>自动装箱,自动拆箱,在-128,127之间会被包装到固定的对象,会导致</p>\n<pre class=\" language-java\"><code class=\"language-java\">Integer a<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\nInteger b<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">==</span>b<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//结果为true</span></code></pre>\n</blockquote>\n</li>\n<li><blockquote>\n<p>异常</p>\n<pre class=\" language-java\"><code class=\"language-java\">Throwable \n     Error 非受查异常\n     Exception\n         IOException等 受查异常\n         RuntimeException 非受查异常</code></pre>\n<p>  一个方法必须声明所有可能抛出的受查异常.非受查异常要么不可控制,要么应该避免发生.</p>\n</blockquote>\n</li>\n</ol>\n<p>​    </p>\n<ol>\n<li><p>多态,父类引用指向子类对象.编译看左边,运行看右边.</p>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\">SimpleDateFormat dateFormat <span class=\"token operator\">=</span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"yyyy年MM月dd日\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nDate date <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>dateFormat<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\">StringBuilder builder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nbuilder<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"BC\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nString s <span class=\"token operator\">=</span> builder<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\">Integer<span class=\"token punctuation\">.</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> extend E<span class=\"token operator\">></span>泛型中必须是本身或者子类</code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\">Collections<span class=\"token punctuation\">.</span><span class=\"token function\">shuffle</span><span class=\"token punctuation\">(</span>poker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nCollections<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>poker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nCollections<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>poker<span class=\"token punctuation\">,</span> <span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ol>\n<ol>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//运行期异常可以不进行异常处理(RuntimeException).抛出异常</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"传递对象为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//编译期异常必须进行异常处理</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> \n   <span class=\"token keyword\">throws</span> FileNotFoundException\n <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileNotFoundException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">RuntimeException</span> e<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">finally</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{</span>\n   <span class=\"token annotation punctuation\">@Override</span>\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n         System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     \n   <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nThread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//同步方法 线程安全 锁对象是this</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">payTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//等待唤醒机制,实现线程通信</span>\nObject obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n      obj<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{</span>\n    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n      obj<span class=\"token punctuation\">.</span><span class=\"token function\">notify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//用线程池管理线程</span>\nExecutorService es <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nes<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"AA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/*函数式编程 只要获取结果就行,不注重谁去做\n适合只想传递一段代码的情况\nLambda表达式\n*/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Cook</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">invokeCooke</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CookImpl</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"吃饭了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>Cook cook<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cook<span class=\"token punctuation\">.</span><span class=\"token function\">invokeCooke</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/*******************带参数的省略写法************************/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Cook</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">invokeCooke</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CookImpl</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span><span class=\"token number\">13</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span> a<span class=\"token operator\">+</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> b<span class=\"token punctuation\">,</span>Cook cook<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> result<span class=\"token operator\">=</span>cook<span class=\"token punctuation\">.</span><span class=\"token function\">invokeCooke</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//相对路径 相当于当前项目的根目录 //C:\\code_home\\idea_home\\JAVA\\DouDiZhu</span>\nFile file <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"DouDiZhu\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">getAbsolutePath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//字符流处理中文问题</span>\n FileReader fileReader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileReader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> chars <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">char</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//读取到chars中</span>\n<span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//len记录每次读取的字符个数</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>len<span class=\"token operator\">=</span>fileReader<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>chars<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>chars<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//流对象自动关闭,无需手动close</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> \n  <span class=\"token keyword\">throws</span> FileNotFoundException\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span><span class=\"token punctuation\">(</span>FileInputStream fileInputStream <span class=\"token operator\">=</span> \n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\00001.jpg\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      FileOutputStream fileOutputStream <span class=\"token operator\">=</span> \n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\copy.jpg\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>length<span class=\"token operator\">=</span>fileInputStream<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n      fileOutputStream<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{</span>\n    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">//fileOutputStream.close();</span>\n  <span class=\"token comment\" spellcheck=\"true\">//fileInputStream.close();</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//配置文件加载与存储</span>\nProperties properties <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Properties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nproperties<span class=\"token punctuation\">.</span><span class=\"token function\">setProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"李\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"168\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nproperties<span class=\"token punctuation\">.</span><span class=\"token function\">setProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"BA\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1688\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nproperties<span class=\"token punctuation\">.</span><span class=\"token function\">setProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"CA\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"168888\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nproperties<span class=\"token punctuation\">.</span><span class=\"token function\">store</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileWriter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"save data\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//存储硬盘中</span>\n\nProperties properties <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Properties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//加载硬盘中</span>\nproperties<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileReader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSet<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> strings <span class=\"token operator\">=</span> properties<span class=\"token punctuation\">.</span><span class=\"token function\">stringPropertyNames</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>String string <span class=\"token operator\">:</span> strings<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>string<span class=\"token operator\">+</span><span class=\"token string\">\" \"</span><span class=\"token operator\">+</span>properties<span class=\"token punctuation\">.</span><span class=\"token function\">getProperty</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//配置文件基本表示类型</span>\n<span class=\"token comment\" spellcheck=\"true\">/*\n#save data\n#Wed Feb 05 11:12:12 CST 2020\n李=168\nCA=168888\nBA=1688\n*/</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\">HashMap<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> hashMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nBufferedReader bufferedReader <span class=\"token operator\">=</span> \n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileReader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nString line<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>line<span class=\"token operator\">=</span>bufferedReader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> strings <span class=\"token operator\">=</span> line<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\\\.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  hashMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>strings<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> strings<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//如果放在上面就会没了</span>\nBufferedWriter bufferedWriter <span class=\"token operator\">=</span> \n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedWriter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileWriter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>String key<span class=\"token operator\">:</span>hashMap<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  String value <span class=\"token operator\">=</span> hashMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  line <span class=\"token operator\">=</span> key <span class=\"token operator\">+</span> <span class=\"token string\">\".\"</span> <span class=\"token operator\">+</span> value<span class=\"token punctuation\">;</span>\n  bufferedWriter<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  bufferedWriter<span class=\"token punctuation\">.</span><span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nbufferedReader<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nbufferedWriter<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\">idea默认编码UTF<span class=\"token operator\">-</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span>win10默认编码GBK</code></pre>\n</li>\n<li><p>ipconfig  127.0.0.1 localhost 代表自己  </p>\n</li>\n<li><p>端口号 0-65535  1024之前的端口不能使用</p>\n</li>\n<li><p>网络端口:80     MySQL:3306      tomcat服务器:8080</p>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//网络编程</span>\n<span class=\"token comment\" spellcheck=\"true\">//客户端</span>\nSocket socket <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Socket</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8888</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nOutputStream outputStream <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">.</span><span class=\"token function\">getOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\noutputStream<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"你好,服务器\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nInputStream inputStream <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">.</span><span class=\"token function\">getInputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> inputStream<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">/*******************服务器端*******************/</span>\nServerSocket serverSocket <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServerSocket</span><span class=\"token punctuation\">(</span><span class=\"token number\">8888</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSocket socket <span class=\"token operator\">=</span> serverSocket<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nInputStream inputStream <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">.</span><span class=\"token function\">getInputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> inputStream<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsocket<span class=\"token punctuation\">.</span><span class=\"token function\">getOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"收到谢谢\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//检测是否是函数式接口 有且仅有一个抽象方法</span>\n<span class=\"token annotation punctuation\">@FunctionalInterface</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Test</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"AA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">show</span><span class=\"token punctuation\">(</span>Test myTest<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        myTest<span class=\"token punctuation\">.</span><span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//stream流式模型 相当于对一个list或者数组进行一系列处理,然后对剩下的集合打印或者其他操作</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"AAA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"AAB\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  list<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n    <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">-</span><span class=\"token operator\">></span>name<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n    <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">-</span><span class=\"token operator\">></span>name<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n    <span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">-</span><span class=\"token operator\">></span>System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ol>\n<pre><code>//一种数据类型转换为另外一种\nStream&lt;String&gt; stream = Stream.of(&quot;12&quot;, &quot;23&quot;, &quot;45&quot;);\nStream&lt;Integer&gt; stream1=stream.map((String name) -&gt;\n {\n       return Integer.parseInt(name);\n });\nstream1.forEach(i-&gt;System.out.println(i));\n\nStream&lt;String&gt; stream = Stream.of(&quot;12&quot;, &quot;23&quot;, &quot;45&quot;,&quot;78&quot;);\nSystem.out.println(stream.limit(3).count());\n```</code></pre>\n<ol start=\"18\">\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//junit</span>\n<span class=\"token comment\" spellcheck=\"true\">//@Before使得所有测试方法先执行该方法</span>\n<span class=\"token annotation punctuation\">@Before</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"init..\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@After</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"close..\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testIt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  Demo demo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  demo<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//三种反射获得方式</span>\n<span class=\"token comment\" spellcheck=\"true\">//全类名</span>\nClass<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.tongji.Student\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nClass <span class=\"token class-name\">clazz</span> <span class=\"token operator\">=</span> Student<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\nStudent student <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstudent<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//一个案例</span>\nProperties properties <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Properties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nInputStream inputStream <span class=\"token operator\">=</span> ReflectTest<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n  <span class=\"token function\">getResourceAsStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com/tongji/test/pro.properties\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nproperties<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span>inputStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nString className <span class=\"token operator\">=</span> properties<span class=\"token punctuation\">.</span><span class=\"token function\">getProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"className\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nString methodName <span class=\"token operator\">=</span> properties<span class=\"token punctuation\">.</span><span class=\"token function\">getProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"methodName\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nClass <span class=\"token class-name\">cls</span> <span class=\"token operator\">=</span> Class<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>className<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nObject object <span class=\"token operator\">=</span> cls<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nMethod method <span class=\"token operator\">=</span> cls<span class=\"token punctuation\">.</span><span class=\"token function\">getMethod</span><span class=\"token punctuation\">(</span>methodName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmethod<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Deprecated</span>  代表方法已经过时\n<span class=\"token annotation punctuation\">@SuppressWarnings</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"all\"</span><span class=\"token punctuation\">)</span>  抑制警告\n<span class=\"token annotation punctuation\">@Override</span> 重写方法</code></pre>\n</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<ol>\n<li><blockquote>\n<p>int 4字节 (-2的31次方)~(2的31次方-1) </p>\n<p>short 2字节</p>\n<p>long 8字节</p>\n<p>byte 1字节 (-128~127)</p>\n<p>float 四字节</p>\n<p>double 8字节</p>\n<p>byte 2字节     因为Java采用16位的Unicode字符集</p>\n<p>boolean 只有两个值,但是大小没精确定义</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>0x开头代表十六进制,如:0xCAFE </p>\n<p>0b开头代表二进制数,如:0b1001</p>\n</blockquote>\n</li>\n<li><blockquote>\n<pre><code class=\"java\">System.out.printf(&quot;%8.2f&quot;,x);\n//s为字符串，f为浮点数，d为十进制数\n//用8字符的宽度和小数点后两位的精度打印x</code></pre>\n</blockquote>\n</li>\n<li><blockquote>\n<p>Java总是按值调用</p>\n<p>如果是基本数据类型,那么值不变</p>\n<p>引用数据类型:引用被拷贝,指向的是原对象,所以仍能改变对象值</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>Object类equals()方法:</p>\n<p>底层调用==来实现,判断两个对象是否具有相同的引用</p>\n<p>若是比较状态是否相等</p>\n<pre><code class=\"java\">public boolean equals(Object obj)\n{\n    if(this==obj) return true;\n    if(obj==null) return false;\n    if(getClass()!=obj.getClass()) return false;\n\n    Person person = (Person) obj;\n    return Objects.equals(name, person.name) &amp;&amp;\n        Objects.equals(age, person.age);\n}\n\n/*\nObjects.equals():\npublic static boolean equals(Object a, Object b) \n{\n    return (a == b) || (a != null &amp;&amp; a.equals(b));\n}\n*/</code></pre>\n</blockquote>\n</li>\n<li><blockquote>\n<p> Object类hashCode()方法</p>\n<p> 如果重新定义equals方法,则需要重新定义hashCode()方法</p>\n<pre><code class=\"java\">@Override\npublic int hashCode()\n{\n    return Objects.hash(name, age);\n}</code></pre>\n</blockquote>\n</li>\n<li><blockquote>\n<p>自动装箱,自动拆箱,在-128,127之间会被包装到固定的对象,会导致</p>\n<pre><code class=\"java\">Integer a=10;\nInteger b=10;\nif(a==b)//结果为true</code></pre>\n</blockquote>\n</li>\n<li><blockquote>\n<p>异常</p>\n<pre><code class=\"java\">Throwable \n     Error 非受查异常\n     Exception\n         IOException等 受查异常\n         RuntimeException 非受查异常</code></pre>\n<p>  一个方法必须声明所有可能抛出的受查异常.非受查异常要么不可控制,要么应该避免发生.</p>\n</blockquote>\n</li>\n</ol>\n<p>​    </p>\n<ol>\n<li><p>多态,父类引用指向子类对象.编译看左边,运行看右边.</p>\n</li>\n<li><pre><code class=\"java\">SimpleDateFormat dateFormat =\n  new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);\nDate date = new Date();\nSystem.out.println(dateFormat.format(date));</code></pre>\n</li>\n<li><pre><code class=\"java\">StringBuilder builder = new StringBuilder(&quot;A&quot;);\nbuilder.append(&quot;BC&quot;);\nString s = builder.toString();</code></pre>\n</li>\n<li><pre><code class=\"java\">Integer.parseInt(string);</code></pre>\n</li>\n<li><pre><code class=\"java\">&lt;? extend E&gt;泛型中必须是本身或者子类</code></pre>\n</li>\n<li><pre><code class=\"java\">Collections.shuffle(poker);\nCollections.sort(poker);\nCollections.addAll(poker, &quot;A&quot;, &quot;B&quot;);</code></pre>\n</li>\n</ol>\n<ol>\n<li><pre><code class=\"java\">//运行期异常可以不进行异常处理(RuntimeException).抛出异常\nif(s==null)\n{\n  throw new NullPointerException(&quot;传递对象为空&quot;);\n}\n\n//编译期异常必须进行异常处理\n public static void main(String[] args) \n   throws FileNotFoundException\n {\n   throw new FileNotFoundException(&quot;aa&quot;);\n }\n\ntry{}\ncatch (RuntimeException e)\n{\n  e.printStackTrace();\n}\nfinally{}</code></pre>\n</li>\n<li><pre><code class=\"java\"> new Thread()\n {\n   @Override\n   public void run()\n   {\n     for (int i = 0; i &lt; 20; i++)\n         System.out.println(i);     \n   }\n }.start();\nThread.sleep(1000);</code></pre>\n</li>\n<li><pre><code class=\"java\">//同步方法 线程安全 锁对象是this\npublic synchronized void payTicket(){}\n\n//等待唤醒机制,实现线程通信\nObject obj = new Object();\nnew Thread()\n{\n  @Override\n  public void run()\n  {\n    synchronized (obj)\n    {\n      obj.wait();\n    }\n  }\n}.start();\n\nnew Thread()\n{\n  @Override\n  public void run()\n  {\n    Thread.sleep(5000);\n    synchronized (obj)\n    {\n      obj.notify();\n    }\n  }\n}.start();</code></pre>\n</li>\n<li><pre><code class=\"java\">//用线程池管理线程\nExecutorService es = Executors.newFixedThreadPool(2);\nes.submit(\n  new Runnable()\n  {\n    @Override\n    public void run()\n    {\n      System.out.println(&quot;AA&quot;);\n    }\n  });</code></pre>\n</li>\n<li><pre><code class=\"java\">/*函数式编程 只要获取结果就行,不注重谁去做\n适合只想传递一段代码的情况\nLambda表达式\n*/\npublic interface Cook\n{\n    void invokeCooke();\n}\npublic class CookImpl\n{\n    public static void main(String[] args)\n    {\n        test(()-&gt;\n        {\n            System.out.println(&quot;吃饭了&quot;);\n        });\n    }\n\n    public static void test(Cook cook)\n    {\n        cook.invokeCooke();\n    }\n}\n\n/*******************带参数的省略写法************************/\npublic interface Cook\n{\n    int invokeCooke(int a,int b);\n}\npublic class CookImpl\n{\n    public static void main(String[] args)\n    {\n        test(12,13,(a,b)-&gt; a+b);\n    }\n\n    public static void test(int a,int b,Cook cook)\n    {\n        int result=cook.invokeCooke(a,b);\n        System.out.println(result);\n    }\n}</code></pre>\n</li>\n<li><pre><code class=\"java\">//相对路径 相当于当前项目的根目录 //C:\\code_home\\idea_home\\JAVA\\DouDiZhu\nFile file = new File(&quot;DouDiZhu&quot;);\nSystem.out.println(file.getAbsolutePath());</code></pre>\n</li>\n<li><pre><code class=\"java\">//字符流处理中文问题\n FileReader fileReader = new FileReader(&quot;D:\\\\test.txt&quot;);\nchar[] chars = new char[1024];//读取到chars中\nint len = 0;//len记录每次读取的字符个数\nwhile((len=fileReader.read(chars))!=-1)\n{\n  System.out.println(new String(chars,0,len));\n}</code></pre>\n</li>\n<li><pre><code class=\"java\">//流对象自动关闭,无需手动close\npublic static void main(String[] args) \n  throws FileNotFoundException\n{\n  try(FileInputStream fileInputStream = \n      new FileInputStream(&quot;D:\\\\00001.jpg&quot;);\n      FileOutputStream fileOutputStream = \n      new FileOutputStream(&quot;D:\\\\copy.jpg&quot;);)\n  {\n    byte[] bytes = new byte[1024];\n    int length;\n    while((length=fileInputStream.read(bytes))!=-1)\n    {\n      fileOutputStream.write(bytes,0,length);\n    }\n  }\n  catch (IOException e)\n  {\n    e.printStackTrace();\n  }\n  //fileOutputStream.close();\n  //fileInputStream.close();\n}</code></pre>\n</li>\n<li><pre><code class=\"java\">//配置文件加载与存储\nProperties properties = new Properties();\nproperties.setProperty(&quot;李&quot;, &quot;168&quot;);\nproperties.setProperty(&quot;BA&quot;, &quot;1688&quot;);\nproperties.setProperty(&quot;CA&quot;, &quot;168888&quot;);\nproperties.store(new FileWriter(&quot;D:\\\\test.txt&quot;),&quot;save data&quot;);//存储硬盘中\n\nProperties properties = new Properties();//加载硬盘中\nproperties.load(new FileReader(&quot;D:\\\\test.txt&quot;));\nSet&lt;String&gt; strings = properties.stringPropertyNames();\nfor (String string : strings)\n{\n  System.out.println(string+&quot; &quot;+properties.getProperty(string));\n}\n//配置文件基本表示类型\n/*\n#save data\n#Wed Feb 05 11:12:12 CST 2020\n李=168\nCA=168888\nBA=1688\n*/</code></pre>\n</li>\n<li><pre><code class=\"java\">HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();\nBufferedReader bufferedReader = \n  new BufferedReader(new FileReader(&quot;D:\\\\test.txt&quot;));\nString line;\nwhile((line=bufferedReader.readLine())!=null)\n{\n  String[] strings = line.split(&quot;\\\\.&quot;);\n  hashMap.put(strings[0], strings[1]);\n}\n//如果放在上面就会没了\nBufferedWriter bufferedWriter = \n  new BufferedWriter(new FileWriter(&quot;D:\\\\test.txt&quot;));\nfor(String key:hashMap.keySet())\n{\n  String value = hashMap.get(key);\n  line = key + &quot;.&quot; + value;\n  bufferedWriter.write(line);\n  bufferedWriter.newLine();\n}\nbufferedReader.close();\nbufferedWriter.close();\n}</code></pre>\n</li>\n<li><pre><code class=\"java\">idea默认编码UTF-8,win10默认编码GBK</code></pre>\n</li>\n<li><p>ipconfig  127.0.0.1 localhost 代表自己  </p>\n</li>\n<li><p>端口号 0-65535  1024之前的端口不能使用</p>\n</li>\n<li><p>网络端口:80     MySQL:3306      tomcat服务器:8080</p>\n</li>\n<li><pre><code class=\"java\">//网络编程\n//客户端\nSocket socket = new Socket(&quot;127.0.0.1&quot;, 8888);\nOutputStream outputStream = socket.getOutputStream();\noutputStream.write(&quot;你好,服务器&quot;.getBytes());\n\nInputStream inputStream = socket.getInputStream();\nbyte[] bytes = new byte[1024];\nint len = inputStream.read(bytes);\nSystem.out.println(new String(bytes,0,len));\n/*******************服务器端*******************/\nServerSocket serverSocket = new ServerSocket(8888);\nSocket socket = serverSocket.accept();\nInputStream inputStream = socket.getInputStream();\nbyte[] bytes = new byte[1024];\nint len = inputStream.read(bytes);\nSystem.out.println(new String(bytes,0,len));\nsocket.getOutputStream().write(&quot;收到谢谢&quot;.getBytes());\n</code></pre>\n</li>\n<li><pre><code class=\"java\">//检测是否是函数式接口 有且仅有一个抽象方法\n@FunctionalInterface\npublic interface Test\n{\n    void test1();\n}\npublic class Demo\n{\n    public static void main(String[] args)\n    {\n        show(() -&gt; System.out.println(&quot;AA&quot;));\n    }\n\n    public static void show(Test myTest)\n    {\n        myTest.test1();\n    }\n}\n</code></pre>\n</li>\n<li><pre><code class=\"java\">//stream流式模型 相当于对一个list或者数组进行一系列处理,然后对剩下的集合打印或者其他操作\npublic static void main(String[] args)\n{\n  List&lt;String&gt; list = new ArrayList&lt;&gt;();\n  list.add(&quot;AAA&quot;);\n  list.add(&quot;AAB&quot;);\n  list.stream().\n    filter(name-&gt;name.startsWith(&quot;A&quot;)).\n    filter(name-&gt;name.length()==3).\n    forEach(name-&gt;System.out.println(name));\n}</code></pre>\n</li>\n</ol>\n<pre><code>//一种数据类型转换为另外一种\nStream&lt;String&gt; stream = Stream.of(&quot;12&quot;, &quot;23&quot;, &quot;45&quot;);\nStream&lt;Integer&gt; stream1=stream.map((String name) -&gt;\n {\n       return Integer.parseInt(name);\n });\nstream1.forEach(i-&gt;System.out.println(i));\n\nStream&lt;String&gt; stream = Stream.of(&quot;12&quot;, &quot;23&quot;, &quot;45&quot;,&quot;78&quot;);\nSystem.out.println(stream.limit(3).count());\n```</code></pre>\n<ol start=\"18\">\n<li><pre><code class=\"java\">//junit\n//@Before使得所有测试方法先执行该方法\n@Before\npublic void init()\n{\n  System.out.println(&quot;init..&quot;);\n}\n\n@After\npublic void close()\n{\n  System.out.println(&quot;close..&quot;);\n}\n\n@Test\npublic void testIt()\n{\n  Demo demo = new Demo();\n  demo.test(2,3);\n}</code></pre>\n</li>\n<li><pre><code class=\"java\">//三种反射获得方式\n//全类名\nClass.forName(&quot;com.tongji.Student&quot;);\nClass clazz = Student.class;\nStudent student = new Student();\nstudent.getClass();\n\n//一个案例\nProperties properties = new Properties();\nInputStream inputStream = ReflectTest.class.getClassLoader().\n  getResourceAsStream(&quot;com/tongji/test/pro.properties&quot;);\nproperties.load(inputStream);\n\nString className = properties.getProperty(&quot;className&quot;);\nString methodName = properties.getProperty(&quot;methodName&quot;);\nClass cls = Class.forName(className);\nObject object = cls.newInstance();\nMethod method = cls.getMethod(methodName);\nmethod.invoke(object);</code></pre>\n</li>\n<li><pre><code class=\"java\">@Deprecated  代表方法已经过时\n@SuppressWarnings(&quot;all&quot;)  抑制警告\n@Override 重写方法</code></pre>\n</li>\n</ol>\n"},{"title":"Java基础--常用对象","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"Java基础知识之常用对象,待完善,之后再看的时候会继续补充。","abbrlink":"d70d769a","date":"2020-03-10T16:00:00.000Z","_content":"# Object\n## toString()\n\n```\npublic String toString() \n{\n\treturn getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n```\n\n\n\n返回对象的字符串表示形式,建议所有子类重写此方法.\n\n## equals()\n\n```\npublic boolean equals(Object obj)\n{\n    return (this == obj);\n}\n```\n\n如果是对象引用,那么equals()底层调用==,比较的是对象内存地址是否相等\n\n一般重写它以比较两个对象的内容\n\n无论何时覆盖该方法，通常需要覆盖`hashCode`方法，以便维护`hashCode`方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。\n\n所以基本数据类型用==判断相等,引用数据类型都用equals()进行判断(String也是引用类型)\n\n```java\n//idea生成\n@Override\npublic boolean equals(Object o)\n{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Person person = (Person) o;\n    return age == person.age &&\n        username.equals(person.username);\n}\n\n@Override\npublic int hashCode()\n{\n    return Objects.hash(username, age);\n}\n```\n\n## clone\n\n- - - 创建并返回此对象的副本。“复制”的精确含义可能取决于对象的类。一般的意图是，对于任何对象`x` ，表达式：\n\n\t\t\t> ` x.clone() != x`\n\n\t\t\t将是真实的，而且表达：\n\n\t\t\t> ` x.clone().getClass() == x.getClass()`\n\n\t\t\t将是`true`  ，但这些都不是绝对的要求。通常情况是：\n\n\t\t\t> ` x.clone().equals(x)`\n\n\t\t\t将是`true`  ，这不是一个绝对的要求。\n\n- - - 按照惯例，返回的对象应该通过调用`super.clone`获得。  如果一个类和它的所有超类（除了`Object` ）遵守这个惯例，那将是`x.clone().getClass()  == x.getClass()`的情况。 \n\n\t\t\t按照惯例，此方法返回的对象应该与此对象（正被克隆）无关。  为了实现这一独立性，可能需要修改`super.clone`返回的对象的一个或多个字段。  通常，这意味着复制构成被克隆的对象的内部“深层结构”的任何可变对象，并通过引用该副本替换对这些对象的引用。  如果一个类仅包含原始字段或对不可变对象的引用，则通常情况下，  `super.clone`返回的对象中的字段通常不需要修改。 \n\n- - - `clone`的方法`Object`执行特定的克隆操作。  首先，如果此对象的类不实现接口`Cloneable`  ，则抛出`CloneNotSupportedException` 。  请注意，所有数组都被认为是实现接口`Cloneable`  ，并且数组类型`T[]`的`clone`方法的返回类型是`T[]`  ，其中T是任何引用或原始类型。  否则，该方法将创建该对象的类的新实例，并将其所有字段初始化为完全符合该对象的相应字段的内容，就像通过赋值一样。  这些字段的内容本身不被克隆。 因此，该方法执行该对象的“浅拷贝”，而不是“深度拷贝”操作。 \n\n\t\t\t`Object`类本身并不实现接口`Cloneable`  ，因此在类别为`Object`的对象上调用`clone`方法将导致运行时抛出异常。 \n\t\t\t\n# 八种包装类型\n\n1. Byte,Short,Integer,Long,Float,Double父类都是Number\n2. Boolean,Character父类是Object\n\n## Number\n\n提供了六种转换方法\n```java\npublic abstract int intValue();\npublic abstract long longValue();\n```\n\n## 拆箱装箱机制\n`Integer i=100` 其实还是相当于`Integer i= new Integer(100)`i还是指向内存地址。只是自动装箱了,只有运算才会自动拆装箱\n```\n//==永远判断内存地址是否相同\nInteger i= new Integer(100);\nInteger j= new Integer(100);\nif(i==j) //结果为false\n```\n\nInteger类加载时会初始化整数型常量池：256个对象\n在[-128,127]之间会被包装到固定的对象,放在整数型常量池里\n此区间的数据直接从内存中取出，内存地址相同\n```java\nInteger a=10;\nInteger b=10;\nif(a==b)//结果为true\n```\n\n\n# 常用类\n## 日期\n\n```java\n//Date转为String\nSimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\nDate date = new Date();\nSystem.out.println(dateFormat.format(date));\n   \n//String转为Date\nSimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\nString s = \"2020年08月07日 08:28:23\";\nDate date = dateFormat.parse(s);\n\n//从1970.1.1至今的总毫秒数\nSystem.currentTimeMillis();\n   \n```\n## BigDecimal\n```java\n//高精度,如财务处理软件等\nBigDecimal bigDecimal1 = new BigDecimal(4);\nBigDecimal bigDecimal2 = new BigDecimal(3.5);\nBigDecimal add = bigDecimal1.add(bigDecimal2);\nSystem.out.println(add);\n//7.5999999999999996447286321199499070644378662109375\nBigDecimal divide = bigDecimal1.divide(bigDecimal2);\nSystem.out.println(divide);\n//java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.\n```\n## Random\n```java\n//构造参数可传入随机种子,每次程序的随机数都一样\nRandom random = new Random(4);\nint i = random.nextInt();//产生int范围内的随机数\nint j = random.nextInt(100);//产生[0,100)范围内的随机数\n```\n# 其他\n## 测试\n\n```java\n    //junit\n    //@Before使得所有测试方法先执行该方法\n    @Before\n    public void init()\n    {\n      System.out.println(\"init..\");\n    }\n\n    @After\n    public void close()\n    {\n      System.out.println(\"close..\");\n    }\n\n    @Test\n    public void testIt()\n    {\n      Demo demo = new Demo();\n      demo.test(2,3);\n    }\n```\n\n## stream流\n\n```java\n//stream流式模型 相当于对一个list或者数组进行一系列处理,然后对剩下的集合打印或者其他操作\n    public static void main(String[] args)\n    {\n      List<String> list = new ArrayList<>();\n      list.add(\"AAA\");\n      list.add(\"AAB\");\n      list.stream().\n        filter(name->name.startsWith(\"A\")).\n        filter(name->name.length()==3).\n        forEach(name->System.out.println(name));\n    }\n```\n\n\n    //一种数据类型转换为另外一种\n    Stream<String> stream = Stream.of(\"12\", \"23\", \"45\");\n    Stream<Integer> stream1=stream.map((String name) ->\n     {\n           return Integer.parseInt(name);\n     });\n    stream1.forEach(i->System.out.println(i));\n    \n    Stream<String> stream = Stream.of(\"12\", \"23\", \"45\",\"78\");\n    System.out.println(stream.limit(3).count());\n    ```\n\n\n## 测试\n\n    @Deprecated  代表方法已经过时\n    @SuppressWarnings(\"all\")  抑制警告\n    @Override 重写方法\n\n端口号 0-65535  1024之前的端口不能使用\n\nidea默认编码UTF-8，win10默认GBK","source":"_posts/Java笔记/常用对象.md","raw":"---\ntitle: Java基础--常用对象\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 'Java基础知识之常用对象,待完善,之后再看的时候会继续补充。'\ncategories: Java基础\ntags:\n  - Java基础\n  - 对象\nabbrlink: d70d769a\ndate: 2020-03-11 00:00:00\n---\n# Object\n## toString()\n\n```\npublic String toString() \n{\n\treturn getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n```\n\n\n\n返回对象的字符串表示形式,建议所有子类重写此方法.\n\n## equals()\n\n```\npublic boolean equals(Object obj)\n{\n    return (this == obj);\n}\n```\n\n如果是对象引用,那么equals()底层调用==,比较的是对象内存地址是否相等\n\n一般重写它以比较两个对象的内容\n\n无论何时覆盖该方法，通常需要覆盖`hashCode`方法，以便维护`hashCode`方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。\n\n所以基本数据类型用==判断相等,引用数据类型都用equals()进行判断(String也是引用类型)\n\n```java\n//idea生成\n@Override\npublic boolean equals(Object o)\n{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Person person = (Person) o;\n    return age == person.age &&\n        username.equals(person.username);\n}\n\n@Override\npublic int hashCode()\n{\n    return Objects.hash(username, age);\n}\n```\n\n## clone\n\n- - - 创建并返回此对象的副本。“复制”的精确含义可能取决于对象的类。一般的意图是，对于任何对象`x` ，表达式：\n\n\t\t\t> ` x.clone() != x`\n\n\t\t\t将是真实的，而且表达：\n\n\t\t\t> ` x.clone().getClass() == x.getClass()`\n\n\t\t\t将是`true`  ，但这些都不是绝对的要求。通常情况是：\n\n\t\t\t> ` x.clone().equals(x)`\n\n\t\t\t将是`true`  ，这不是一个绝对的要求。\n\n- - - 按照惯例，返回的对象应该通过调用`super.clone`获得。  如果一个类和它的所有超类（除了`Object` ）遵守这个惯例，那将是`x.clone().getClass()  == x.getClass()`的情况。 \n\n\t\t\t按照惯例，此方法返回的对象应该与此对象（正被克隆）无关。  为了实现这一独立性，可能需要修改`super.clone`返回的对象的一个或多个字段。  通常，这意味着复制构成被克隆的对象的内部“深层结构”的任何可变对象，并通过引用该副本替换对这些对象的引用。  如果一个类仅包含原始字段或对不可变对象的引用，则通常情况下，  `super.clone`返回的对象中的字段通常不需要修改。 \n\n- - - `clone`的方法`Object`执行特定的克隆操作。  首先，如果此对象的类不实现接口`Cloneable`  ，则抛出`CloneNotSupportedException` 。  请注意，所有数组都被认为是实现接口`Cloneable`  ，并且数组类型`T[]`的`clone`方法的返回类型是`T[]`  ，其中T是任何引用或原始类型。  否则，该方法将创建该对象的类的新实例，并将其所有字段初始化为完全符合该对象的相应字段的内容，就像通过赋值一样。  这些字段的内容本身不被克隆。 因此，该方法执行该对象的“浅拷贝”，而不是“深度拷贝”操作。 \n\n\t\t\t`Object`类本身并不实现接口`Cloneable`  ，因此在类别为`Object`的对象上调用`clone`方法将导致运行时抛出异常。 \n\t\t\t\n# 八种包装类型\n\n1. Byte,Short,Integer,Long,Float,Double父类都是Number\n2. Boolean,Character父类是Object\n\n## Number\n\n提供了六种转换方法\n```java\npublic abstract int intValue();\npublic abstract long longValue();\n```\n\n## 拆箱装箱机制\n`Integer i=100` 其实还是相当于`Integer i= new Integer(100)`i还是指向内存地址。只是自动装箱了,只有运算才会自动拆装箱\n```\n//==永远判断内存地址是否相同\nInteger i= new Integer(100);\nInteger j= new Integer(100);\nif(i==j) //结果为false\n```\n\nInteger类加载时会初始化整数型常量池：256个对象\n在[-128,127]之间会被包装到固定的对象,放在整数型常量池里\n此区间的数据直接从内存中取出，内存地址相同\n```java\nInteger a=10;\nInteger b=10;\nif(a==b)//结果为true\n```\n\n\n# 常用类\n## 日期\n\n```java\n//Date转为String\nSimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\nDate date = new Date();\nSystem.out.println(dateFormat.format(date));\n   \n//String转为Date\nSimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\nString s = \"2020年08月07日 08:28:23\";\nDate date = dateFormat.parse(s);\n\n//从1970.1.1至今的总毫秒数\nSystem.currentTimeMillis();\n   \n```\n## BigDecimal\n```java\n//高精度,如财务处理软件等\nBigDecimal bigDecimal1 = new BigDecimal(4);\nBigDecimal bigDecimal2 = new BigDecimal(3.5);\nBigDecimal add = bigDecimal1.add(bigDecimal2);\nSystem.out.println(add);\n//7.5999999999999996447286321199499070644378662109375\nBigDecimal divide = bigDecimal1.divide(bigDecimal2);\nSystem.out.println(divide);\n//java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.\n```\n## Random\n```java\n//构造参数可传入随机种子,每次程序的随机数都一样\nRandom random = new Random(4);\nint i = random.nextInt();//产生int范围内的随机数\nint j = random.nextInt(100);//产生[0,100)范围内的随机数\n```\n# 其他\n## 测试\n\n```java\n    //junit\n    //@Before使得所有测试方法先执行该方法\n    @Before\n    public void init()\n    {\n      System.out.println(\"init..\");\n    }\n\n    @After\n    public void close()\n    {\n      System.out.println(\"close..\");\n    }\n\n    @Test\n    public void testIt()\n    {\n      Demo demo = new Demo();\n      demo.test(2,3);\n    }\n```\n\n## stream流\n\n```java\n//stream流式模型 相当于对一个list或者数组进行一系列处理,然后对剩下的集合打印或者其他操作\n    public static void main(String[] args)\n    {\n      List<String> list = new ArrayList<>();\n      list.add(\"AAA\");\n      list.add(\"AAB\");\n      list.stream().\n        filter(name->name.startsWith(\"A\")).\n        filter(name->name.length()==3).\n        forEach(name->System.out.println(name));\n    }\n```\n\n\n    //一种数据类型转换为另外一种\n    Stream<String> stream = Stream.of(\"12\", \"23\", \"45\");\n    Stream<Integer> stream1=stream.map((String name) ->\n     {\n           return Integer.parseInt(name);\n     });\n    stream1.forEach(i->System.out.println(i));\n    \n    Stream<String> stream = Stream.of(\"12\", \"23\", \"45\",\"78\");\n    System.out.println(stream.limit(3).count());\n    ```\n\n\n## 测试\n\n    @Deprecated  代表方法已经过时\n    @SuppressWarnings(\"all\")  抑制警告\n    @Override 重写方法\n\n端口号 0-65535  1024之前的端口不能使用\n\nidea默认编码UTF-8，win10默认GBK","slug":"Java笔记/常用对象","published":1,"updated":"2020-11-12T11:57:29.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6w40011jotpbxa9efsv","content":"<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h2><pre><code>public String toString() \n{\n    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());\n}</code></pre>\n<p>返回对象的字符串表示形式,建议所有子类重写此方法.</p>\n<h2 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals()\"></a>equals()</h2><pre><code>public boolean equals(Object obj)\n{\n    return (this == obj);\n}</code></pre>\n<p>如果是对象引用,那么equals()底层调用==,比较的是对象内存地址是否相等</p>\n<p>一般重写它以比较两个对象的内容</p>\n<p>无论何时覆盖该方法，通常需要覆盖<code>hashCode</code>方法，以便维护<code>hashCode</code>方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。</p>\n<p>所以基本数据类型用==判断相等,引用数据类型都用equals()进行判断(String也是引用类型)</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//idea生成</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>Object o<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> o<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> <span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> o<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    Person person <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Person<span class=\"token punctuation\">)</span> o<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> age <span class=\"token operator\">==</span> person<span class=\"token punctuation\">.</span>age <span class=\"token operator\">&amp;&amp;</span>\n        username<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>username<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Objects<span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone\"></a>clone</h2><ul>\n<li><ul>\n<li><ul>\n<li><p>创建并返回此对象的副本。“复制”的精确含义可能取决于对象的类。一般的意图是，对于任何对象<code>x</code> ，表达式：</p>\n<pre><code>  &gt; ` x.clone() != x`\n\n  将是真实的，而且表达：\n\n  &gt; ` x.clone().getClass() == x.getClass()`\n\n  将是`true`  ，但这些都不是绝对的要求。通常情况是：\n\n  &gt; ` x.clone().equals(x)`\n\n  将是`true`  ，这不是一个绝对的要求。</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><p>按照惯例，返回的对象应该通过调用<code>super.clone</code>获得。  如果一个类和它的所有超类（除了<code>Object</code> ）遵守这个惯例，那将是<code>x.clone().getClass()  == x.getClass()</code>的情况。 </p>\n<pre><code>  按照惯例，此方法返回的对象应该与此对象（正被克隆）无关。  为了实现这一独立性，可能需要修改`super.clone`返回的对象的一个或多个字段。  通常，这意味着复制构成被克隆的对象的内部“深层结构”的任何可变对象，并通过引用该副本替换对这些对象的引用。  如果一个类仅包含原始字段或对不可变对象的引用，则通常情况下，  `super.clone`返回的对象中的字段通常不需要修改。 </code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><p><code>clone</code>的方法<code>Object</code>执行特定的克隆操作。  首先，如果此对象的类不实现接口<code>Cloneable</code>  ，则抛出<code>CloneNotSupportedException</code> 。  请注意，所有数组都被认为是实现接口<code>Cloneable</code>  ，并且数组类型<code>T[]</code>的<code>clone</code>方法的返回类型是<code>T[]</code>  ，其中T是任何引用或原始类型。  否则，该方法将创建该对象的类的新实例，并将其所有字段初始化为完全符合该对象的相应字段的内容，就像通过赋值一样。  这些字段的内容本身不被克隆。 因此，该方法执行该对象的“浅拷贝”，而不是“深度拷贝”操作。 </p>\n<pre><code>  `Object`类本身并不实现接口`Cloneable`  ，因此在类别为`Object`的对象上调用`clone`方法将导致运行时抛出异常。 </code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"八种包装类型\"><a href=\"#八种包装类型\" class=\"headerlink\" title=\"八种包装类型\"></a>八种包装类型</h1><ol>\n<li>Byte,Short,Integer,Long,Float,Double父类都是Number</li>\n<li>Boolean,Character父类是Object</li>\n</ol>\n<h2 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h2><p>提供了六种转换方法</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">int</span> <span class=\"token function\">intValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">long</span> <span class=\"token function\">longValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"拆箱装箱机制\"><a href=\"#拆箱装箱机制\" class=\"headerlink\" title=\"拆箱装箱机制\"></a>拆箱装箱机制</h2><p><code>Integer i=100</code> 其实还是相当于<code>Integer i= new Integer(100)</code>i还是指向内存地址。只是自动装箱了,只有运算才会自动拆装箱</p>\n<pre><code>//==永远判断内存地址是否相同\nInteger i= new Integer(100);\nInteger j= new Integer(100);\nif(i==j) //结果为false</code></pre>\n<p>Integer类加载时会初始化整数型常量池：256个对象<br>在[-128,127]之间会被包装到固定的对象,放在整数型常量池里<br>此区间的数据直接从内存中取出，内存地址相同</p>\n<pre class=\" language-java\"><code class=\"language-java\">Integer a<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\nInteger b<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">==</span>b<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//结果为true</span></code></pre>\n<h1 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h1><h2 id=\"日期\"><a href=\"#日期\" class=\"headerlink\" title=\"日期\"></a>日期</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//Date转为String</span>\nSimpleDateFormat dateFormat <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"yyyy年MM月dd日 HH:mm:ss\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nDate date <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>dateFormat<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//String转为Date</span>\nSimpleDateFormat dateFormat <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"yyyy年MM月dd日 HH:mm:ss\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nString s <span class=\"token operator\">=</span> <span class=\"token string\">\"2020年08月07日 08:28:23\"</span><span class=\"token punctuation\">;</span>\nDate date <span class=\"token operator\">=</span> dateFormat<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//从1970.1.1至今的总毫秒数</span>\nSystem<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2 id=\"BigDecimal\"><a href=\"#BigDecimal\" class=\"headerlink\" title=\"BigDecimal\"></a>BigDecimal</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//高精度,如财务处理软件等</span>\nBigDecimal bigDecimal1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nBigDecimal bigDecimal2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">3.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nBigDecimal add <span class=\"token operator\">=</span> bigDecimal1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>bigDecimal2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>add<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//7.5999999999999996447286321199499070644378662109375</span>\nBigDecimal divide <span class=\"token operator\">=</span> bigDecimal1<span class=\"token punctuation\">.</span><span class=\"token function\">divide</span><span class=\"token punctuation\">(</span>bigDecimal2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>divide<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</span></code></pre>\n<h2 id=\"Random\"><a href=\"#Random\" class=\"headerlink\" title=\"Random\"></a>Random</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//构造参数可传入随机种子,每次程序的随机数都一样</span>\nRandom random <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> random<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//产生int范围内的随机数</span>\n<span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> random<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//产生[0,100)范围内的随机数</span></code></pre>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token comment\" spellcheck=\"true\">//junit</span>\n    <span class=\"token comment\" spellcheck=\"true\">//@Before使得所有测试方法先执行该方法</span>\n    <span class=\"token annotation punctuation\">@Before</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"init..\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@After</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"close..\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Test</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testIt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n      Demo demo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      demo<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"stream流\"><a href=\"#stream流\" class=\"headerlink\" title=\"stream流\"></a>stream流</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//stream流式模型 相当于对一个list或者数组进行一系列处理,然后对剩下的集合打印或者其他操作</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n      List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"AAA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"AAB\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      list<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n        <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">-</span><span class=\"token operator\">></span>name<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n        <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">-</span><span class=\"token operator\">></span>name<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n        <span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">-</span><span class=\"token operator\">></span>System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<pre><code>//一种数据类型转换为另外一种\nStream&lt;String&gt; stream = Stream.of(&quot;12&quot;, &quot;23&quot;, &quot;45&quot;);\nStream&lt;Integer&gt; stream1=stream.map((String name) -&gt;\n {\n       return Integer.parseInt(name);\n });\nstream1.forEach(i-&gt;System.out.println(i));\n\nStream&lt;String&gt; stream = Stream.of(&quot;12&quot;, &quot;23&quot;, &quot;45&quot;,&quot;78&quot;);\nSystem.out.println(stream.limit(3).count());\n```</code></pre>\n<h2 id=\"测试-1\"><a href=\"#测试-1\" class=\"headerlink\" title=\"测试\"></a>测试</h2><pre><code>@Deprecated  代表方法已经过时\n@SuppressWarnings(&quot;all&quot;)  抑制警告\n@Override 重写方法</code></pre>\n<p>端口号 0-65535  1024之前的端口不能使用</p>\n<p>idea默认编码UTF-8，win10默认GBK</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h2><pre><code>public String toString() \n{\n    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());\n}</code></pre>\n<p>返回对象的字符串表示形式,建议所有子类重写此方法.</p>\n<h2 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals()\"></a>equals()</h2><pre><code>public boolean equals(Object obj)\n{\n    return (this == obj);\n}</code></pre>\n<p>如果是对象引用,那么equals()底层调用==,比较的是对象内存地址是否相等</p>\n<p>一般重写它以比较两个对象的内容</p>\n<p>无论何时覆盖该方法，通常需要覆盖<code>hashCode</code>方法，以便维护<code>hashCode</code>方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。</p>\n<p>所以基本数据类型用==判断相等,引用数据类型都用equals()进行判断(String也是引用类型)</p>\n<pre><code class=\"java\">//idea生成\n@Override\npublic boolean equals(Object o)\n{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Person person = (Person) o;\n    return age == person.age &amp;&amp;\n        username.equals(person.username);\n}\n\n@Override\npublic int hashCode()\n{\n    return Objects.hash(username, age);\n}</code></pre>\n<h2 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone\"></a>clone</h2><ul>\n<li><ul>\n<li><ul>\n<li><p>创建并返回此对象的副本。“复制”的精确含义可能取决于对象的类。一般的意图是，对于任何对象<code>x</code> ，表达式：</p>\n<pre><code>  &gt; ` x.clone() != x`\n\n  将是真实的，而且表达：\n\n  &gt; ` x.clone().getClass() == x.getClass()`\n\n  将是`true`  ，但这些都不是绝对的要求。通常情况是：\n\n  &gt; ` x.clone().equals(x)`\n\n  将是`true`  ，这不是一个绝对的要求。</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><p>按照惯例，返回的对象应该通过调用<code>super.clone</code>获得。  如果一个类和它的所有超类（除了<code>Object</code> ）遵守这个惯例，那将是<code>x.clone().getClass()  == x.getClass()</code>的情况。 </p>\n<pre><code>  按照惯例，此方法返回的对象应该与此对象（正被克隆）无关。  为了实现这一独立性，可能需要修改`super.clone`返回的对象的一个或多个字段。  通常，这意味着复制构成被克隆的对象的内部“深层结构”的任何可变对象，并通过引用该副本替换对这些对象的引用。  如果一个类仅包含原始字段或对不可变对象的引用，则通常情况下，  `super.clone`返回的对象中的字段通常不需要修改。 </code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><p><code>clone</code>的方法<code>Object</code>执行特定的克隆操作。  首先，如果此对象的类不实现接口<code>Cloneable</code>  ，则抛出<code>CloneNotSupportedException</code> 。  请注意，所有数组都被认为是实现接口<code>Cloneable</code>  ，并且数组类型<code>T[]</code>的<code>clone</code>方法的返回类型是<code>T[]</code>  ，其中T是任何引用或原始类型。  否则，该方法将创建该对象的类的新实例，并将其所有字段初始化为完全符合该对象的相应字段的内容，就像通过赋值一样。  这些字段的内容本身不被克隆。 因此，该方法执行该对象的“浅拷贝”，而不是“深度拷贝”操作。 </p>\n<pre><code>  `Object`类本身并不实现接口`Cloneable`  ，因此在类别为`Object`的对象上调用`clone`方法将导致运行时抛出异常。 </code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"八种包装类型\"><a href=\"#八种包装类型\" class=\"headerlink\" title=\"八种包装类型\"></a>八种包装类型</h1><ol>\n<li>Byte,Short,Integer,Long,Float,Double父类都是Number</li>\n<li>Boolean,Character父类是Object</li>\n</ol>\n<h2 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h2><p>提供了六种转换方法</p>\n<pre><code class=\"java\">public abstract int intValue();\npublic abstract long longValue();</code></pre>\n<h2 id=\"拆箱装箱机制\"><a href=\"#拆箱装箱机制\" class=\"headerlink\" title=\"拆箱装箱机制\"></a>拆箱装箱机制</h2><p><code>Integer i=100</code> 其实还是相当于<code>Integer i= new Integer(100)</code>i还是指向内存地址。只是自动装箱了,只有运算才会自动拆装箱</p>\n<pre><code>//==永远判断内存地址是否相同\nInteger i= new Integer(100);\nInteger j= new Integer(100);\nif(i==j) //结果为false</code></pre>\n<p>Integer类加载时会初始化整数型常量池：256个对象<br>在[-128,127]之间会被包装到固定的对象,放在整数型常量池里<br>此区间的数据直接从内存中取出，内存地址相同</p>\n<pre><code class=\"java\">Integer a=10;\nInteger b=10;\nif(a==b)//结果为true</code></pre>\n<h1 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h1><h2 id=\"日期\"><a href=\"#日期\" class=\"headerlink\" title=\"日期\"></a>日期</h2><pre><code class=\"java\">//Date转为String\nSimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);\nDate date = new Date();\nSystem.out.println(dateFormat.format(date));\n\n//String转为Date\nSimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);\nString s = &quot;2020年08月07日 08:28:23&quot;;\nDate date = dateFormat.parse(s);\n\n//从1970.1.1至今的总毫秒数\nSystem.currentTimeMillis();\n</code></pre>\n<h2 id=\"BigDecimal\"><a href=\"#BigDecimal\" class=\"headerlink\" title=\"BigDecimal\"></a>BigDecimal</h2><pre><code class=\"java\">//高精度,如财务处理软件等\nBigDecimal bigDecimal1 = new BigDecimal(4);\nBigDecimal bigDecimal2 = new BigDecimal(3.5);\nBigDecimal add = bigDecimal1.add(bigDecimal2);\nSystem.out.println(add);\n//7.5999999999999996447286321199499070644378662109375\nBigDecimal divide = bigDecimal1.divide(bigDecimal2);\nSystem.out.println(divide);\n//java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</code></pre>\n<h2 id=\"Random\"><a href=\"#Random\" class=\"headerlink\" title=\"Random\"></a>Random</h2><pre><code class=\"java\">//构造参数可传入随机种子,每次程序的随机数都一样\nRandom random = new Random(4);\nint i = random.nextInt();//产生int范围内的随机数\nint j = random.nextInt(100);//产生[0,100)范围内的随机数</code></pre>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><pre><code class=\"java\">    //junit\n    //@Before使得所有测试方法先执行该方法\n    @Before\n    public void init()\n    {\n      System.out.println(&quot;init..&quot;);\n    }\n\n    @After\n    public void close()\n    {\n      System.out.println(&quot;close..&quot;);\n    }\n\n    @Test\n    public void testIt()\n    {\n      Demo demo = new Demo();\n      demo.test(2,3);\n    }</code></pre>\n<h2 id=\"stream流\"><a href=\"#stream流\" class=\"headerlink\" title=\"stream流\"></a>stream流</h2><pre><code class=\"java\">//stream流式模型 相当于对一个list或者数组进行一系列处理,然后对剩下的集合打印或者其他操作\n    public static void main(String[] args)\n    {\n      List&lt;String&gt; list = new ArrayList&lt;&gt;();\n      list.add(&quot;AAA&quot;);\n      list.add(&quot;AAB&quot;);\n      list.stream().\n        filter(name-&gt;name.startsWith(&quot;A&quot;)).\n        filter(name-&gt;name.length()==3).\n        forEach(name-&gt;System.out.println(name));\n    }</code></pre>\n<pre><code>//一种数据类型转换为另外一种\nStream&lt;String&gt; stream = Stream.of(&quot;12&quot;, &quot;23&quot;, &quot;45&quot;);\nStream&lt;Integer&gt; stream1=stream.map((String name) -&gt;\n {\n       return Integer.parseInt(name);\n });\nstream1.forEach(i-&gt;System.out.println(i));\n\nStream&lt;String&gt; stream = Stream.of(&quot;12&quot;, &quot;23&quot;, &quot;45&quot;,&quot;78&quot;);\nSystem.out.println(stream.limit(3).count());\n```</code></pre>\n<h2 id=\"测试-1\"><a href=\"#测试-1\" class=\"headerlink\" title=\"测试\"></a>测试</h2><pre><code>@Deprecated  代表方法已经过时\n@SuppressWarnings(&quot;all&quot;)  抑制警告\n@Override 重写方法</code></pre>\n<p>端口号 0-65535  1024之前的端口不能使用</p>\n<p>idea默认编码UTF-8，win10默认GBK</p>\n"},{"title":"Java基础--异常","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"Java基础知识之异常,待完善,之后再看的时候会继续补充。","abbrlink":"1a12af4c","date":"2020-03-12T16:00:00.000Z","_content":"\n\n# 异常简介\n![image-20200807095737682](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200807095737682.png)\n\n1. 所有的RuntimeException及其子类都属于运行时异常。在编写处理程序阶段可用处理，也可用选择不处理\n2. Exception中除了RuntimeException的其他子类，都是编译时异常，又叫受检异常。即编写程序时必须预先对异常进行处理，否则编译器报错。编译时异常发生概率高。所以未雨绸缪。\n3. 编译时异常例子：大雨天，出门不带伞，很大可能会生病（很大可能发生的一种异常）。那就提前带一把伞（对概率较高的异常进行预处理）\n4. 运行时异常例子：被飞机砸中，发生概率比较低。如果提前预处理，就很麻烦\n5. 编译期，运行期异常都发生在运行阶段。编译阶段异常不会发生。\n\n# 异常处理\n\n编译时异常在编写程序时就要预先处理，可以继续向上抛出，或者自行处理。\n\n## 抛出异常\n1. 如果异常一直上抛，main再上抛则上抛到了JVM，则会终止程序\n2. `throws ClassNotFoundException`交给调用该方法的调用者处理\n3. \n\n## 处理异常\n\n异常堆栈信息从上往下看。先看抛出的异常名。再看自己代码中最顶端报错的代码位置。\n\n```java\ntry\n{\n    throw new ClassNotFoundException(\"my_exception\");\n}\ncatch (ClassNotFoundException e)\n{\n    System.out.println(e.getMessage());//my_exception\n    e.printStackTrace();//打印异常栈堆信息\n}\n```\n\n## finally\n\n1. 无论try里执行了return语句、break语句、还是continue语句，finally语句块还会继续执行。\n2. 当try或者catch的代码在运行的时候，JVM退出了。那么finally语句块就不会执行。同样，如果线程在运行try或者catch的代码时被中断了或者被杀死了(killed)，那么finally语句可能也不会执行了，即使整个运用还会继续执行。\n3. 如果在try语句里有return语句，finally语句还是会执行。它会在把控制权转移到该方法的调用者或者构造器前执行finally语句。也就是说，使用return语句把控制权转移给其他的方法前会执行finally语句。\n\n```java\npublic static void main(String[] args)\n    {\n        System.out.println(f());//100\n    }\n    public static int f()\n    {\n        int i = 100;\n        try\n        {\n            return i;\n        }\n        finally\n        {\n            i++;\n        }\n    }\n\n//反编译\nint i=100;\nint j=i;\ni++;\nreturn;\n```\n\n## 自定义异常\n\n```java\n//要定义编译时异常就Exception,运行时异常就RuntimeException\npublic class MyException extends Exception\n{\n    public MyException()\n    {\n    }\n\n    public MyException(String msg)\n    {\n        super(msg);\n    }\n}\n\npublic static void main(String[] args)\n{\n    try\n    {\n        throw new MyException(\"myExceptionInfo\");\n    }\n    catch (MyException e)\n    {\n        e.printStackTrace();\n    }\n    //test.MyException: myExceptionInfo\n    //\tat demo1.MainTest.main(MainTest.java:21)\n}\n```\n\n","source":"_posts/Java笔记/异常.md","raw":"---\ntitle: Java基础--异常\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 'Java基础知识之异常,待完善,之后再看的时候会继续补充。'\ncategories: Java基础\ntags:\n  - Java基础\n  - 异常\nabbrlink: 1a12af4c\ndate: 2020-03-13 00:00:00\n---\n\n\n# 异常简介\n![image-20200807095737682](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200807095737682.png)\n\n1. 所有的RuntimeException及其子类都属于运行时异常。在编写处理程序阶段可用处理，也可用选择不处理\n2. Exception中除了RuntimeException的其他子类，都是编译时异常，又叫受检异常。即编写程序时必须预先对异常进行处理，否则编译器报错。编译时异常发生概率高。所以未雨绸缪。\n3. 编译时异常例子：大雨天，出门不带伞，很大可能会生病（很大可能发生的一种异常）。那就提前带一把伞（对概率较高的异常进行预处理）\n4. 运行时异常例子：被飞机砸中，发生概率比较低。如果提前预处理，就很麻烦\n5. 编译期，运行期异常都发生在运行阶段。编译阶段异常不会发生。\n\n# 异常处理\n\n编译时异常在编写程序时就要预先处理，可以继续向上抛出，或者自行处理。\n\n## 抛出异常\n1. 如果异常一直上抛，main再上抛则上抛到了JVM，则会终止程序\n2. `throws ClassNotFoundException`交给调用该方法的调用者处理\n3. \n\n## 处理异常\n\n异常堆栈信息从上往下看。先看抛出的异常名。再看自己代码中最顶端报错的代码位置。\n\n```java\ntry\n{\n    throw new ClassNotFoundException(\"my_exception\");\n}\ncatch (ClassNotFoundException e)\n{\n    System.out.println(e.getMessage());//my_exception\n    e.printStackTrace();//打印异常栈堆信息\n}\n```\n\n## finally\n\n1. 无论try里执行了return语句、break语句、还是continue语句，finally语句块还会继续执行。\n2. 当try或者catch的代码在运行的时候，JVM退出了。那么finally语句块就不会执行。同样，如果线程在运行try或者catch的代码时被中断了或者被杀死了(killed)，那么finally语句可能也不会执行了，即使整个运用还会继续执行。\n3. 如果在try语句里有return语句，finally语句还是会执行。它会在把控制权转移到该方法的调用者或者构造器前执行finally语句。也就是说，使用return语句把控制权转移给其他的方法前会执行finally语句。\n\n```java\npublic static void main(String[] args)\n    {\n        System.out.println(f());//100\n    }\n    public static int f()\n    {\n        int i = 100;\n        try\n        {\n            return i;\n        }\n        finally\n        {\n            i++;\n        }\n    }\n\n//反编译\nint i=100;\nint j=i;\ni++;\nreturn;\n```\n\n## 自定义异常\n\n```java\n//要定义编译时异常就Exception,运行时异常就RuntimeException\npublic class MyException extends Exception\n{\n    public MyException()\n    {\n    }\n\n    public MyException(String msg)\n    {\n        super(msg);\n    }\n}\n\npublic static void main(String[] args)\n{\n    try\n    {\n        throw new MyException(\"myExceptionInfo\");\n    }\n    catch (MyException e)\n    {\n        e.printStackTrace();\n    }\n    //test.MyException: myExceptionInfo\n    //\tat demo1.MainTest.main(MainTest.java:21)\n}\n```\n\n","slug":"Java笔记/异常","published":1,"updated":"2020-11-12T11:57:29.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6w60014jotpa40h6quc","content":"<h1 id=\"异常简介\"><a href=\"#异常简介\" class=\"headerlink\" title=\"异常简介\"></a>异常简介</h1><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200807095737682.png\" alt=\"image-20200807095737682\"></p>\n<ol>\n<li>所有的RuntimeException及其子类都属于运行时异常。在编写处理程序阶段可用处理，也可用选择不处理</li>\n<li>Exception中除了RuntimeException的其他子类，都是编译时异常，又叫受检异常。即编写程序时必须预先对异常进行处理，否则编译器报错。编译时异常发生概率高。所以未雨绸缪。</li>\n<li>编译时异常例子：大雨天，出门不带伞，很大可能会生病（很大可能发生的一种异常）。那就提前带一把伞（对概率较高的异常进行预处理）</li>\n<li>运行时异常例子：被飞机砸中，发生概率比较低。如果提前预处理，就很麻烦</li>\n<li>编译期，运行期异常都发生在运行阶段。编译阶段异常不会发生。</li>\n</ol>\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><p>编译时异常在编写程序时就要预先处理，可以继续向上抛出，或者自行处理。</p>\n<h2 id=\"抛出异常\"><a href=\"#抛出异常\" class=\"headerlink\" title=\"抛出异常\"></a>抛出异常</h2><ol>\n<li>如果异常一直上抛，main再上抛则上抛到了JVM，则会终止程序</li>\n<li><code>throws ClassNotFoundException</code>交给调用该方法的调用者处理</li>\n<li></li>\n</ol>\n<h2 id=\"处理异常\"><a href=\"#处理异常\" class=\"headerlink\" title=\"处理异常\"></a>处理异常</h2><p>异常堆栈信息从上往下看。先看抛出的异常名。再看自己代码中最顶端报错的代码位置。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">try</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassNotFoundException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"my_exception\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//my_exception</span>\n    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//打印异常栈堆信息</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally\"></a>finally</h2><ol>\n<li>无论try里执行了return语句、break语句、还是continue语句，finally语句块还会继续执行。</li>\n<li>当try或者catch的代码在运行的时候，JVM退出了。那么finally语句块就不会执行。同样，如果线程在运行try或者catch的代码时被中断了或者被杀死了(killed)，那么finally语句可能也不会执行了，即使整个运用还会继续执行。</li>\n<li>如果在try语句里有return语句，finally语句还是会执行。它会在把控制权转移到该方法的调用者或者构造器前执行finally语句。也就是说，使用return语句把控制权转移给其他的方法前会执行finally语句。</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//100</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">finally</span>\n        <span class=\"token punctuation\">{</span>\n            i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//反编译</span>\n<span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span>i<span class=\"token punctuation\">;</span>\ni<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//要定义编译时异常就Exception,运行时异常就RuntimeException</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyException</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Exception</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">MyException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">MyException</span><span class=\"token punctuation\">(</span>String msg<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myExceptionInfo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">MyException</span> e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//test.MyException: myExceptionInfo</span>\n    <span class=\"token comment\" spellcheck=\"true\">//    at demo1.MainTest.main(MainTest.java:21)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"异常简介\"><a href=\"#异常简介\" class=\"headerlink\" title=\"异常简介\"></a>异常简介</h1><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200807095737682.png\" alt=\"image-20200807095737682\"></p>\n<ol>\n<li>所有的RuntimeException及其子类都属于运行时异常。在编写处理程序阶段可用处理，也可用选择不处理</li>\n<li>Exception中除了RuntimeException的其他子类，都是编译时异常，又叫受检异常。即编写程序时必须预先对异常进行处理，否则编译器报错。编译时异常发生概率高。所以未雨绸缪。</li>\n<li>编译时异常例子：大雨天，出门不带伞，很大可能会生病（很大可能发生的一种异常）。那就提前带一把伞（对概率较高的异常进行预处理）</li>\n<li>运行时异常例子：被飞机砸中，发生概率比较低。如果提前预处理，就很麻烦</li>\n<li>编译期，运行期异常都发生在运行阶段。编译阶段异常不会发生。</li>\n</ol>\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><p>编译时异常在编写程序时就要预先处理，可以继续向上抛出，或者自行处理。</p>\n<h2 id=\"抛出异常\"><a href=\"#抛出异常\" class=\"headerlink\" title=\"抛出异常\"></a>抛出异常</h2><ol>\n<li>如果异常一直上抛，main再上抛则上抛到了JVM，则会终止程序</li>\n<li><code>throws ClassNotFoundException</code>交给调用该方法的调用者处理</li>\n<li></li>\n</ol>\n<h2 id=\"处理异常\"><a href=\"#处理异常\" class=\"headerlink\" title=\"处理异常\"></a>处理异常</h2><p>异常堆栈信息从上往下看。先看抛出的异常名。再看自己代码中最顶端报错的代码位置。</p>\n<pre><code class=\"java\">try\n{\n    throw new ClassNotFoundException(&quot;my_exception&quot;);\n}\ncatch (ClassNotFoundException e)\n{\n    System.out.println(e.getMessage());//my_exception\n    e.printStackTrace();//打印异常栈堆信息\n}</code></pre>\n<h2 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally\"></a>finally</h2><ol>\n<li>无论try里执行了return语句、break语句、还是continue语句，finally语句块还会继续执行。</li>\n<li>当try或者catch的代码在运行的时候，JVM退出了。那么finally语句块就不会执行。同样，如果线程在运行try或者catch的代码时被中断了或者被杀死了(killed)，那么finally语句可能也不会执行了，即使整个运用还会继续执行。</li>\n<li>如果在try语句里有return语句，finally语句还是会执行。它会在把控制权转移到该方法的调用者或者构造器前执行finally语句。也就是说，使用return语句把控制权转移给其他的方法前会执行finally语句。</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args)\n    {\n        System.out.println(f());//100\n    }\n    public static int f()\n    {\n        int i = 100;\n        try\n        {\n            return i;\n        }\n        finally\n        {\n            i++;\n        }\n    }\n\n//反编译\nint i=100;\nint j=i;\ni++;\nreturn;</code></pre>\n<h2 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h2><pre><code class=\"java\">//要定义编译时异常就Exception,运行时异常就RuntimeException\npublic class MyException extends Exception\n{\n    public MyException()\n    {\n    }\n\n    public MyException(String msg)\n    {\n        super(msg);\n    }\n}\n\npublic static void main(String[] args)\n{\n    try\n    {\n        throw new MyException(&quot;myExceptionInfo&quot;);\n    }\n    catch (MyException e)\n    {\n        e.printStackTrace();\n    }\n    //test.MyException: myExceptionInfo\n    //    at demo1.MainTest.main(MainTest.java:21)\n}</code></pre>\n"},{"title":"Java基础--String","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"Java基础知识之String,待完善,之后再看的时候会继续补充。","abbrlink":"a0a3a5a1","date":"2020-03-09T16:00:00.000Z","_content":"# String\n\n```\nprivate final char value[];\n```\n\n数组长度不可变,而且加了final,所以只能指向那个对象,所以不可变\n\n# println\n\n输出任何数据都转换成字符串再输出\n\n## pringf\n\n```java\nSystem.out.printf(\"%8.2f\",x);\n//s为字符串，f为浮点数，d为十进制数\n//用8字符的宽度和小数点后两位的精度打印x\n//.2如果用在String则表示打印String时输出字符的最大数量\n//%-10 则为左对齐\n```\n\n\n\n## System.out.println(new Object());\n\n```java\npublic void println(Object x) \n{\n    String s = String.valueOf(x);\n    synchronized (this) \n    {\n        print(s);\n        newLine();\n    }\n}\n\npublic static String valueOf(Object obj) \n{\n    return (obj == null) ? \"null\" : obj.toString();\n}\n```\n\n## System.out.println(1);\n\n```java\npublic void println(int x) \n{\n    synchronized (this) \n    {\n        print(x);\n        newLine();\n    }\n}\npublic void print(int i) \n{\n    write(String.valueOf(i));\n}\n```\n\n","source":"_posts/Java笔记/String.md","raw":"---\ntitle: Java基础--String\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 'Java基础知识之String,待完善,之后再看的时候会继续补充。'\ncategories: Java基础\ntags:\n  - Java基础\n  - String\nabbrlink: a0a3a5a1\ndate: 2020-03-10 00:00:00\n---\n# String\n\n```\nprivate final char value[];\n```\n\n数组长度不可变,而且加了final,所以只能指向那个对象,所以不可变\n\n# println\n\n输出任何数据都转换成字符串再输出\n\n## pringf\n\n```java\nSystem.out.printf(\"%8.2f\",x);\n//s为字符串，f为浮点数，d为十进制数\n//用8字符的宽度和小数点后两位的精度打印x\n//.2如果用在String则表示打印String时输出字符的最大数量\n//%-10 则为左对齐\n```\n\n\n\n## System.out.println(new Object());\n\n```java\npublic void println(Object x) \n{\n    String s = String.valueOf(x);\n    synchronized (this) \n    {\n        print(s);\n        newLine();\n    }\n}\n\npublic static String valueOf(Object obj) \n{\n    return (obj == null) ? \"null\" : obj.toString();\n}\n```\n\n## System.out.println(1);\n\n```java\npublic void println(int x) \n{\n    synchronized (this) \n    {\n        print(x);\n        newLine();\n    }\n}\npublic void print(int i) \n{\n    write(String.valueOf(i));\n}\n```\n\n","slug":"Java笔记/String","published":1,"updated":"2020-11-12T11:57:29.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6w80016jotpbmey3xaw","content":"<h1 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h1><pre><code>private final char value[];</code></pre>\n<p>数组长度不可变,而且加了final,所以只能指向那个对象,所以不可变</p>\n<h1 id=\"println\"><a href=\"#println\" class=\"headerlink\" title=\"println\"></a>println</h1><p>输出任何数据都转换成字符串再输出</p>\n<h2 id=\"pringf\"><a href=\"#pringf\" class=\"headerlink\" title=\"pringf\"></a>pringf</h2><pre class=\" language-java\"><code class=\"language-java\">System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%8.2f\"</span><span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//s为字符串，f为浮点数，d为十进制数</span>\n<span class=\"token comment\" spellcheck=\"true\">//用8字符的宽度和小数点后两位的精度打印x</span>\n<span class=\"token comment\" spellcheck=\"true\">//.2如果用在String则表示打印String时输出字符的最大数量</span>\n<span class=\"token comment\" spellcheck=\"true\">//%-10 则为左对齐</span></code></pre>\n<h2 id=\"System-out-println-new-Object\"><a href=\"#System-out-println-new-Object\" class=\"headerlink\" title=\"System.out.println(new Object());\"></a>System.out.println(new Object());</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Object x<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n    String s <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>Object obj<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>obj <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token string\">\"null\"</span> <span class=\"token operator\">:</span> obj<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"System-out-println-1\"><a href=\"#System-out-println-1\" class=\"headerlink\" title=\"System.out.println(1);\"></a>System.out.println(1);</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">newLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">write</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h1><pre><code>private final char value[];</code></pre>\n<p>数组长度不可变,而且加了final,所以只能指向那个对象,所以不可变</p>\n<h1 id=\"println\"><a href=\"#println\" class=\"headerlink\" title=\"println\"></a>println</h1><p>输出任何数据都转换成字符串再输出</p>\n<h2 id=\"pringf\"><a href=\"#pringf\" class=\"headerlink\" title=\"pringf\"></a>pringf</h2><pre><code class=\"java\">System.out.printf(&quot;%8.2f&quot;,x);\n//s为字符串，f为浮点数，d为十进制数\n//用8字符的宽度和小数点后两位的精度打印x\n//.2如果用在String则表示打印String时输出字符的最大数量\n//%-10 则为左对齐</code></pre>\n<h2 id=\"System-out-println-new-Object\"><a href=\"#System-out-println-new-Object\" class=\"headerlink\" title=\"System.out.println(new Object());\"></a>System.out.println(new Object());</h2><pre><code class=\"java\">public void println(Object x) \n{\n    String s = String.valueOf(x);\n    synchronized (this) \n    {\n        print(s);\n        newLine();\n    }\n}\n\npublic static String valueOf(Object obj) \n{\n    return (obj == null) ? &quot;null&quot; : obj.toString();\n}</code></pre>\n<h2 id=\"System-out-println-1\"><a href=\"#System-out-println-1\" class=\"headerlink\" title=\"System.out.println(1);\"></a>System.out.println(1);</h2><pre><code class=\"java\">public void println(int x) \n{\n    synchronized (this) \n    {\n        print(x);\n        newLine();\n    }\n}\npublic void print(int i) \n{\n    write(String.valueOf(i));\n}</code></pre>\n"},{"title":"Java基础--Java简介","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"Java基础知识之Java简介,待完善,之后再看的时候会继续补充。","abbrlink":"31c6b392","date":"2020-02-26T16:00:00.000Z","_content":"# java简介\n## 主要特性\n\n1. 简单性(不能直接操作指针)\n2. 面向对象性\n3. 健壮性(GC机制)\n4. 多线程并发\n5. 可移植性/跨平台性 write once,run everywhere\n\n\n## JDK,JRE,JVM\n1. JDK包括JRE,JRE包括JVM\n2. JDK:开发工具包\n3. JRE:java运行环境\n4. 安装JDK自带JRE,因为开发还需要测试\n\n## javac,java\n1. javac在编译期,将.java文件形成.class文件 `javac MainTest.java`\n\t相对路径写法，即MainTest.java必须在当前路径下\n2. java在运行期,运行.class文件   `java MainTest`\n\t如果指定了classpath则不必，否则MainTest.class也必须在当前路径下\n\n# JAVA配置环境变量解析\n## 环境变量简介\n环境变量包括了 系统变量,用户变量\n系统变量的范围比较大,会让所有计算机用户都生效\n用户变量只会作用与当前用户\n\n## path环境变量\npath环境变量告诉windows可以去哪里找到命令.这样就不用写程序的绝对路径了,如\n`C:\\Program Files\\Java\\jdk1.8.0_261\\bin\\javac.exe`或者\n`%JAVA_HOME%\\bin\\java`\n可以直接在任何路径下的命令行敲javac\n\n## classpath\n1. 默认情况下classpath只加载当前路径下的class文件\n2. classpath给类加载器指定路径,让类加载器去指定路径下加载字节码\n3. 为了程序能找到相应的\".class\"文件\n3. classpath不区分大小写,如CLASSPATH\n4. CLASSPATH配置:`.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar`\n## JAVA_HOME\n1. 方便引用。`C:\\Program Files\\Java\\jdk1.8.0_261`,设置JAVA_HOME为该目录路径, 那么以后你要使用这个路径的时候, 只需输入%JAVA_HOME%即可,避免每次引用都输入很长的路径串;\n2. 归一原则。即只需改一处\n3. 有些第三方软件例如Tomcat约定要用JAVA_HOME\n\n# 基础\n## class文件\n1. 一个java源文件可以定义多个class\n2. 源文件中只要有一个class定义，就会产生一个class文件\n3. public类可以没有，但有则必须与源文件名保持一致，且只能有一个\n4. 每个类都能有自己的main方法\n\n\n\n## 字符编码\n\n1. ASCII码用byte进行编码。计算机先编码，再解码，如果用的不是同一个编码方法，则乱码。 ‘a' : 97，'A' : 65， space : 32\n2. GBK支持中文\n3. Unicode支持全世界语言文字。具体实现有UTF-8\n4. char可以存储一个汉字，采用Unicode编码，用单引号\n5. 计算机只存储二进制的补码\n\n## 转义字符\n1. \\为转义字符，在输出或者字符串中使用，\\加特殊符号则转为普通符号，例如`\\\"`等等\n2. \\u 后面跟16进制为输出对应的unicode码。例如`\\u 4e2d`可以转为汉字\"中\"，（注意没有空格，只是因为typora也会转义)\n\n## 类型转换\n1. int型中，0x开头代表16进制,如:0xCAFE ，0b开头为二进制，例如int a=0b110,输出结果为6\n2. 一个字面量，默认当作int类型处理，后面加L则默认为long类型\n3. 自动类型转换： long b=200; 200字面量首先默认当作int型，但是自动转换为long。而long b=300L,300字面量默认当作long，赋值给b不存在类型转换。\n4. long a=200_0000_0000会报错，因为后者默认先为int时，已经超出int，就报错了\n5. 大容量转小容量需要强制类型转换，有可能损失精度\n6. byte中，当整数型不超过[-128,127]时，该字面量可以直接赋值给byte，不需要类型转换。`byte x=127; byte a = (byte)128;`short，char也是可以的。只有字面量可以这样转换，例如 `short s=a+x`则会报错：不兼容的类型：从int转换到short可能会有损失。\n7. `char ch=97`一个整数赋值给char类型变量能自动类型转换\n8. byte，short，char混合运算，都会先转换为int再运算\n9. 多种数据类型混合运算，最终结果为“最大容量”类型\n10. boolean类型不能转换\n11. 如果整数型字面量没有超过byte，short,char的取值范围，可以直接将其赋值给他们相应类型的变量\n12. 容量比较：byte<short(char)<int<long<float<double  char比short代表更大的正整数\n13. \n## 浮点型\n1. float容量>long容量 `3.4028235E38`与`9223372036854775807`\n2. 所有浮点型默认当作double类型处理，要当作Float，后面加F\n\n## 运算符\n1. ```java\n    byte x=100\n    x+=1\n    //+=不会改变运算结果类型 \n    //x+=1   ====== x=(byte)(x+1)\n    ```\n2. +两边只要有一边是字符串类型，拼接完就还是字符串。遵循从左到右的原则，例如`System.out.println(100+200+\"300\");//300300`\n## 方法\n\n1. 方法重载：同一个类中，方法名相同，参数列表不同。只有返回值不同不能算方法重载\n2. 尽量不使用递归，消耗内存大\n3. 方法参数传递只有传值,引用对象也是.不过引用对象传递了地址值过去,所以修改能成功.引用被拷贝,指向的是原对象,所以仍能改变对象值\n\n## 对象相关\n\n1. 在类加载时执行且只执行一次\n2. 一个类中可以写多个,代码块有先后顺序,自上而下执行\n3. 静态代码块与静态变量有先后顺序\n4. 此时其他非静态的还未创建\n5. 在构造方法执行之前,执行实例语句块\n6. this为指向自己的引用.实例对象只有有引用才能访问.所以类中访问成员变量,方法时,省略了this。即age其实是this.age。即当前对象的成员变量age\n7. this不能用于静态方法，因为静态方法调用不需要this\n\n\n## 数组\n\n数组是引用数据类型,数组父类是Object,存储在堆中\n\n数组元素首地址作为整个数组对象的地址\n\n初始化数组有默认值,如:\n\n`String [] names=new String[6]`每个元素初始化为null\n\n# 继承多态\n\n## 继承\n\n### 基础\n\n1. 只允许单继承\n2. 子类继承父类的所有除了构造方法，但是父类私有的属性无法在子类直接访问\n3. 都继承了Object\n4. this是指向自己的引用\n5. super不是引用，也不保存内存地址，也不指向一块对象，只是代表当前对象内部的那一块父类型的特征\n6. this（），super（）都只能出现在构造方法第一行。为u的是创建子类对象时，先初始化父类的特征\n\n### 方法覆盖\n\n1. 私有方法无法覆盖\n\n2. 构造方法不能被继承，所以也不能被覆盖\n\n3. 静态方法覆盖没有意义\n\n4. 方法名相同，参数相同，一般来说返回类型也相同。子类的返回值与父类相同或者是父类返回类型的子类型。\n\n5. 子类方法可以具有相同的访问权限或者子类的访问权限大于父类\n\n6. 子类方法不能比父类方法抛出更多的编译时异常（不是运行时异常），即子类方法抛出的编译时异常或者和父类相同或者是父类异常的子类。\n\n\t\n\n## 多态\n\n### 基础\n\n多态：编辑阶段是一种状态，运行阶段又是另外一种状态。父类引用指向子类对象\n\n向上转型：子类转为父类。\n\t\t向下转型：父类转为子类，需要加强制类型转换符。\n\n编译阶段属于静态绑定\n\t\t运行阶段属于动态绑定\n\n### 子类特有方法\n\n1. ` Animal animal=new Cat();`\n2. 编译阶段绑定父类的方法，运行阶段绑定子类对象的方法\n3. 只有编译通过的代码才能运行，所以直接使用子类的方法编译期间就通不过\n4. 编译期间只知道引用是父类型的变量\n5. 当一定需要使用子类特有的方法，则要向下转型\n6. 为避免ClassCastException异常，使用instanceof语法，可以在运行阶段动态判断引用指向的对象的类型。（引用 instanceof 类型） 结果为true/false\n\n## final\n\n1. final修饰的变量只能赋一次值\n2. 引用也是变量,存内存地址.所以final修饰的引用只要指向了一个对象就永远指向那个变量\n3. 局部变量没有初始值,只能手动赋值\n4. 虽然实例变量如果没有手动赋值,系统会赋默认值。但是final修饰实例变量,内部实现让他必须要手动赋值。手动赋值可以在变量后面直接赋值，或者在构造器中赋值\n5. 实例对象用final修饰，说明该实例变量值不会随着对象的变化而变化，所以一般加static修饰变成常量\n6. 常量，静态变量存储在方法区中，在类加载时初始化\n\n","source":"_posts/Java笔记/Java基础.md","raw":"---\ntitle: Java基础--Java简介\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 'Java基础知识之Java简介,待完善,之后再看的时候会继续补充。'\ncategories: Java基础\ntags:\n  - Java基础\nabbrlink: 31c6b392\ndate: 2020-02-27 00:00:00\n---\n# java简介\n## 主要特性\n\n1. 简单性(不能直接操作指针)\n2. 面向对象性\n3. 健壮性(GC机制)\n4. 多线程并发\n5. 可移植性/跨平台性 write once,run everywhere\n\n\n## JDK,JRE,JVM\n1. JDK包括JRE,JRE包括JVM\n2. JDK:开发工具包\n3. JRE:java运行环境\n4. 安装JDK自带JRE,因为开发还需要测试\n\n## javac,java\n1. javac在编译期,将.java文件形成.class文件 `javac MainTest.java`\n\t相对路径写法，即MainTest.java必须在当前路径下\n2. java在运行期,运行.class文件   `java MainTest`\n\t如果指定了classpath则不必，否则MainTest.class也必须在当前路径下\n\n# JAVA配置环境变量解析\n## 环境变量简介\n环境变量包括了 系统变量,用户变量\n系统变量的范围比较大,会让所有计算机用户都生效\n用户变量只会作用与当前用户\n\n## path环境变量\npath环境变量告诉windows可以去哪里找到命令.这样就不用写程序的绝对路径了,如\n`C:\\Program Files\\Java\\jdk1.8.0_261\\bin\\javac.exe`或者\n`%JAVA_HOME%\\bin\\java`\n可以直接在任何路径下的命令行敲javac\n\n## classpath\n1. 默认情况下classpath只加载当前路径下的class文件\n2. classpath给类加载器指定路径,让类加载器去指定路径下加载字节码\n3. 为了程序能找到相应的\".class\"文件\n3. classpath不区分大小写,如CLASSPATH\n4. CLASSPATH配置:`.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar`\n## JAVA_HOME\n1. 方便引用。`C:\\Program Files\\Java\\jdk1.8.0_261`,设置JAVA_HOME为该目录路径, 那么以后你要使用这个路径的时候, 只需输入%JAVA_HOME%即可,避免每次引用都输入很长的路径串;\n2. 归一原则。即只需改一处\n3. 有些第三方软件例如Tomcat约定要用JAVA_HOME\n\n# 基础\n## class文件\n1. 一个java源文件可以定义多个class\n2. 源文件中只要有一个class定义，就会产生一个class文件\n3. public类可以没有，但有则必须与源文件名保持一致，且只能有一个\n4. 每个类都能有自己的main方法\n\n\n\n## 字符编码\n\n1. ASCII码用byte进行编码。计算机先编码，再解码，如果用的不是同一个编码方法，则乱码。 ‘a' : 97，'A' : 65， space : 32\n2. GBK支持中文\n3. Unicode支持全世界语言文字。具体实现有UTF-8\n4. char可以存储一个汉字，采用Unicode编码，用单引号\n5. 计算机只存储二进制的补码\n\n## 转义字符\n1. \\为转义字符，在输出或者字符串中使用，\\加特殊符号则转为普通符号，例如`\\\"`等等\n2. \\u 后面跟16进制为输出对应的unicode码。例如`\\u 4e2d`可以转为汉字\"中\"，（注意没有空格，只是因为typora也会转义)\n\n## 类型转换\n1. int型中，0x开头代表16进制,如:0xCAFE ，0b开头为二进制，例如int a=0b110,输出结果为6\n2. 一个字面量，默认当作int类型处理，后面加L则默认为long类型\n3. 自动类型转换： long b=200; 200字面量首先默认当作int型，但是自动转换为long。而long b=300L,300字面量默认当作long，赋值给b不存在类型转换。\n4. long a=200_0000_0000会报错，因为后者默认先为int时，已经超出int，就报错了\n5. 大容量转小容量需要强制类型转换，有可能损失精度\n6. byte中，当整数型不超过[-128,127]时，该字面量可以直接赋值给byte，不需要类型转换。`byte x=127; byte a = (byte)128;`short，char也是可以的。只有字面量可以这样转换，例如 `short s=a+x`则会报错：不兼容的类型：从int转换到short可能会有损失。\n7. `char ch=97`一个整数赋值给char类型变量能自动类型转换\n8. byte，short，char混合运算，都会先转换为int再运算\n9. 多种数据类型混合运算，最终结果为“最大容量”类型\n10. boolean类型不能转换\n11. 如果整数型字面量没有超过byte，short,char的取值范围，可以直接将其赋值给他们相应类型的变量\n12. 容量比较：byte<short(char)<int<long<float<double  char比short代表更大的正整数\n13. \n## 浮点型\n1. float容量>long容量 `3.4028235E38`与`9223372036854775807`\n2. 所有浮点型默认当作double类型处理，要当作Float，后面加F\n\n## 运算符\n1. ```java\n    byte x=100\n    x+=1\n    //+=不会改变运算结果类型 \n    //x+=1   ====== x=(byte)(x+1)\n    ```\n2. +两边只要有一边是字符串类型，拼接完就还是字符串。遵循从左到右的原则，例如`System.out.println(100+200+\"300\");//300300`\n## 方法\n\n1. 方法重载：同一个类中，方法名相同，参数列表不同。只有返回值不同不能算方法重载\n2. 尽量不使用递归，消耗内存大\n3. 方法参数传递只有传值,引用对象也是.不过引用对象传递了地址值过去,所以修改能成功.引用被拷贝,指向的是原对象,所以仍能改变对象值\n\n## 对象相关\n\n1. 在类加载时执行且只执行一次\n2. 一个类中可以写多个,代码块有先后顺序,自上而下执行\n3. 静态代码块与静态变量有先后顺序\n4. 此时其他非静态的还未创建\n5. 在构造方法执行之前,执行实例语句块\n6. this为指向自己的引用.实例对象只有有引用才能访问.所以类中访问成员变量,方法时,省略了this。即age其实是this.age。即当前对象的成员变量age\n7. this不能用于静态方法，因为静态方法调用不需要this\n\n\n## 数组\n\n数组是引用数据类型,数组父类是Object,存储在堆中\n\n数组元素首地址作为整个数组对象的地址\n\n初始化数组有默认值,如:\n\n`String [] names=new String[6]`每个元素初始化为null\n\n# 继承多态\n\n## 继承\n\n### 基础\n\n1. 只允许单继承\n2. 子类继承父类的所有除了构造方法，但是父类私有的属性无法在子类直接访问\n3. 都继承了Object\n4. this是指向自己的引用\n5. super不是引用，也不保存内存地址，也不指向一块对象，只是代表当前对象内部的那一块父类型的特征\n6. this（），super（）都只能出现在构造方法第一行。为u的是创建子类对象时，先初始化父类的特征\n\n### 方法覆盖\n\n1. 私有方法无法覆盖\n\n2. 构造方法不能被继承，所以也不能被覆盖\n\n3. 静态方法覆盖没有意义\n\n4. 方法名相同，参数相同，一般来说返回类型也相同。子类的返回值与父类相同或者是父类返回类型的子类型。\n\n5. 子类方法可以具有相同的访问权限或者子类的访问权限大于父类\n\n6. 子类方法不能比父类方法抛出更多的编译时异常（不是运行时异常），即子类方法抛出的编译时异常或者和父类相同或者是父类异常的子类。\n\n\t\n\n## 多态\n\n### 基础\n\n多态：编辑阶段是一种状态，运行阶段又是另外一种状态。父类引用指向子类对象\n\n向上转型：子类转为父类。\n\t\t向下转型：父类转为子类，需要加强制类型转换符。\n\n编译阶段属于静态绑定\n\t\t运行阶段属于动态绑定\n\n### 子类特有方法\n\n1. ` Animal animal=new Cat();`\n2. 编译阶段绑定父类的方法，运行阶段绑定子类对象的方法\n3. 只有编译通过的代码才能运行，所以直接使用子类的方法编译期间就通不过\n4. 编译期间只知道引用是父类型的变量\n5. 当一定需要使用子类特有的方法，则要向下转型\n6. 为避免ClassCastException异常，使用instanceof语法，可以在运行阶段动态判断引用指向的对象的类型。（引用 instanceof 类型） 结果为true/false\n\n## final\n\n1. final修饰的变量只能赋一次值\n2. 引用也是变量,存内存地址.所以final修饰的引用只要指向了一个对象就永远指向那个变量\n3. 局部变量没有初始值,只能手动赋值\n4. 虽然实例变量如果没有手动赋值,系统会赋默认值。但是final修饰实例变量,内部实现让他必须要手动赋值。手动赋值可以在变量后面直接赋值，或者在构造器中赋值\n5. 实例对象用final修饰，说明该实例变量值不会随着对象的变化而变化，所以一般加static修饰变成常量\n6. 常量，静态变量存储在方法区中，在类加载时初始化\n\n","slug":"Java笔记/Java基础","published":1,"updated":"2020-11-12T11:57:29.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6w90019jotphjlw4f2b","content":"<h1 id=\"java简介\"><a href=\"#java简介\" class=\"headerlink\" title=\"java简介\"></a>java简介</h1><h2 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h2><ol>\n<li>简单性(不能直接操作指针)</li>\n<li>面向对象性</li>\n<li>健壮性(GC机制)</li>\n<li>多线程并发</li>\n<li>可移植性/跨平台性 write once,run everywhere</li>\n</ol>\n<h2 id=\"JDK-JRE-JVM\"><a href=\"#JDK-JRE-JVM\" class=\"headerlink\" title=\"JDK,JRE,JVM\"></a>JDK,JRE,JVM</h2><ol>\n<li>JDK包括JRE,JRE包括JVM</li>\n<li>JDK:开发工具包</li>\n<li>JRE:java运行环境</li>\n<li>安装JDK自带JRE,因为开发还需要测试</li>\n</ol>\n<h2 id=\"javac-java\"><a href=\"#javac-java\" class=\"headerlink\" title=\"javac,java\"></a>javac,java</h2><ol>\n<li>javac在编译期,将.java文件形成.class文件 <code>javac MainTest.java</code><br> 相对路径写法，即MainTest.java必须在当前路径下</li>\n<li>java在运行期,运行.class文件   <code>java MainTest</code><br> 如果指定了classpath则不必，否则MainTest.class也必须在当前路径下</li>\n</ol>\n<h1 id=\"JAVA配置环境变量解析\"><a href=\"#JAVA配置环境变量解析\" class=\"headerlink\" title=\"JAVA配置环境变量解析\"></a>JAVA配置环境变量解析</h1><h2 id=\"环境变量简介\"><a href=\"#环境变量简介\" class=\"headerlink\" title=\"环境变量简介\"></a>环境变量简介</h2><p>环境变量包括了 系统变量,用户变量<br>系统变量的范围比较大,会让所有计算机用户都生效<br>用户变量只会作用与当前用户</p>\n<h2 id=\"path环境变量\"><a href=\"#path环境变量\" class=\"headerlink\" title=\"path环境变量\"></a>path环境变量</h2><p>path环境变量告诉windows可以去哪里找到命令.这样就不用写程序的绝对路径了,如<br><code>C:\\Program Files\\Java\\jdk1.8.0_261\\bin\\javac.exe</code>或者<br><code>%JAVA_HOME%\\bin\\java</code><br>可以直接在任何路径下的命令行敲javac</p>\n<h2 id=\"classpath\"><a href=\"#classpath\" class=\"headerlink\" title=\"classpath\"></a>classpath</h2><ol>\n<li>默认情况下classpath只加载当前路径下的class文件</li>\n<li>classpath给类加载器指定路径,让类加载器去指定路径下加载字节码</li>\n<li>为了程序能找到相应的”.class”文件</li>\n<li>classpath不区分大小写,如CLASSPATH</li>\n<li>CLASSPATH配置:<code>.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar</code><h2 id=\"JAVA-HOME\"><a href=\"#JAVA-HOME\" class=\"headerlink\" title=\"JAVA_HOME\"></a>JAVA_HOME</h2></li>\n<li>方便引用。<code>C:\\Program Files\\Java\\jdk1.8.0_261</code>,设置JAVA_HOME为该目录路径, 那么以后你要使用这个路径的时候, 只需输入%JAVA_HOME%即可,避免每次引用都输入很长的路径串;</li>\n<li>归一原则。即只需改一处</li>\n<li>有些第三方软件例如Tomcat约定要用JAVA_HOME</li>\n</ol>\n<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"class文件\"><a href=\"#class文件\" class=\"headerlink\" title=\"class文件\"></a>class文件</h2><ol>\n<li>一个java源文件可以定义多个class</li>\n<li>源文件中只要有一个class定义，就会产生一个class文件</li>\n<li>public类可以没有，但有则必须与源文件名保持一致，且只能有一个</li>\n<li>每个类都能有自己的main方法</li>\n</ol>\n<h2 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h2><ol>\n<li>ASCII码用byte进行编码。计算机先编码，再解码，如果用的不是同一个编码方法，则乱码。 ‘a’ : 97，’A’ : 65， space : 32</li>\n<li>GBK支持中文</li>\n<li>Unicode支持全世界语言文字。具体实现有UTF-8</li>\n<li>char可以存储一个汉字，采用Unicode编码，用单引号</li>\n<li>计算机只存储二进制的补码</li>\n</ol>\n<h2 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h2><ol>\n<li>\\为转义字符，在输出或者字符串中使用，\\加特殊符号则转为普通符号，例如<code>\\&quot;</code>等等</li>\n<li>\\u 后面跟16进制为输出对应的unicode码。例如<code>\\u 4e2d</code>可以转为汉字”中”，（注意没有空格，只是因为typora也会转义)</li>\n</ol>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ol>\n<li>int型中，0x开头代表16进制,如:0xCAFE ，0b开头为二进制，例如int a=0b110,输出结果为6</li>\n<li>一个字面量，默认当作int类型处理，后面加L则默认为long类型</li>\n<li>自动类型转换： long b=200; 200字面量首先默认当作int型，但是自动转换为long。而long b=300L,300字面量默认当作long，赋值给b不存在类型转换。</li>\n<li>long a=200_0000_0000会报错，因为后者默认先为int时，已经超出int，就报错了</li>\n<li>大容量转小容量需要强制类型转换，有可能损失精度</li>\n<li>byte中，当整数型不超过[-128,127]时，该字面量可以直接赋值给byte，不需要类型转换。<code>byte x=127; byte a = (byte)128;</code>short，char也是可以的。只有字面量可以这样转换，例如 <code>short s=a+x</code>则会报错：不兼容的类型：从int转换到short可能会有损失。</li>\n<li><code>char ch=97</code>一个整数赋值给char类型变量能自动类型转换</li>\n<li>byte，short，char混合运算，都会先转换为int再运算</li>\n<li>多种数据类型混合运算，最终结果为“最大容量”类型</li>\n<li>boolean类型不能转换</li>\n<li>如果整数型字面量没有超过byte，short,char的取值范围，可以直接将其赋值给他们相应类型的变量</li>\n<li>容量比较：byte&lt;short(char)&lt;int&lt;long&lt;float&lt;double  char比short代表更大的正整数</li>\n<li><h2 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h2></li>\n<li>float容量&gt;long容量 <code>3.4028235E38</code>与<code>9223372036854775807</code></li>\n<li>所有浮点型默认当作double类型处理，要当作Float，后面加F</li>\n</ol>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><ol>\n<li><pre class=\" language-java\"><code class=\"language-java\"> <span class=\"token keyword\">byte</span> x<span class=\"token operator\">=</span><span class=\"token number\">100</span>\n x<span class=\"token operator\">+=</span><span class=\"token number\">1</span>\n <span class=\"token comment\" spellcheck=\"true\">//+=不会改变运算结果类型 </span>\n <span class=\"token comment\" spellcheck=\"true\">//x+=1   ====== x=(byte)(x+1)</span></code></pre>\n</li>\n<li><p>+两边只要有一边是字符串类型，拼接完就还是字符串。遵循从左到右的原则，例如<code>System.out.println(100+200+&quot;300&quot;);//300300</code></p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2></li>\n<li><p>方法重载：同一个类中，方法名相同，参数列表不同。只有返回值不同不能算方法重载</p>\n</li>\n<li><p>尽量不使用递归，消耗内存大</p>\n</li>\n<li><p>方法参数传递只有传值,引用对象也是.不过引用对象传递了地址值过去,所以修改能成功.引用被拷贝,指向的是原对象,所以仍能改变对象值</p>\n</li>\n</ol>\n<h2 id=\"对象相关\"><a href=\"#对象相关\" class=\"headerlink\" title=\"对象相关\"></a>对象相关</h2><ol>\n<li>在类加载时执行且只执行一次</li>\n<li>一个类中可以写多个,代码块有先后顺序,自上而下执行</li>\n<li>静态代码块与静态变量有先后顺序</li>\n<li>此时其他非静态的还未创建</li>\n<li>在构造方法执行之前,执行实例语句块</li>\n<li>this为指向自己的引用.实例对象只有有引用才能访问.所以类中访问成员变量,方法时,省略了this。即age其实是this.age。即当前对象的成员变量age</li>\n<li>this不能用于静态方法，因为静态方法调用不需要this</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>数组是引用数据类型,数组父类是Object,存储在堆中</p>\n<p>数组元素首地址作为整个数组对象的地址</p>\n<p>初始化数组有默认值,如:</p>\n<p><code>String [] names=new String[6]</code>每个元素初始化为null</p>\n<h1 id=\"继承多态\"><a href=\"#继承多态\" class=\"headerlink\" title=\"继承多态\"></a>继承多态</h1><h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><h3 id=\"基础-1\"><a href=\"#基础-1\" class=\"headerlink\" title=\"基础\"></a>基础</h3><ol>\n<li>只允许单继承</li>\n<li>子类继承父类的所有除了构造方法，但是父类私有的属性无法在子类直接访问</li>\n<li>都继承了Object</li>\n<li>this是指向自己的引用</li>\n<li>super不是引用，也不保存内存地址，也不指向一块对象，只是代表当前对象内部的那一块父类型的特征</li>\n<li>this（），super（）都只能出现在构造方法第一行。为u的是创建子类对象时，先初始化父类的特征</li>\n</ol>\n<h3 id=\"方法覆盖\"><a href=\"#方法覆盖\" class=\"headerlink\" title=\"方法覆盖\"></a>方法覆盖</h3><ol>\n<li><p>私有方法无法覆盖</p>\n</li>\n<li><p>构造方法不能被继承，所以也不能被覆盖</p>\n</li>\n<li><p>静态方法覆盖没有意义</p>\n</li>\n<li><p>方法名相同，参数相同，一般来说返回类型也相同。子类的返回值与父类相同或者是父类返回类型的子类型。</p>\n</li>\n<li><p>子类方法可以具有相同的访问权限或者子类的访问权限大于父类</p>\n</li>\n<li><p>子类方法不能比父类方法抛出更多的编译时异常（不是运行时异常），即子类方法抛出的编译时异常或者和父类相同或者是父类异常的子类。</p>\n</li>\n</ol>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><h3 id=\"基础-2\"><a href=\"#基础-2\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>多态：编辑阶段是一种状态，运行阶段又是另外一种状态。父类引用指向子类对象</p>\n<p>向上转型：子类转为父类。<br>        向下转型：父类转为子类，需要加强制类型转换符。</p>\n<p>编译阶段属于静态绑定<br>        运行阶段属于动态绑定</p>\n<h3 id=\"子类特有方法\"><a href=\"#子类特有方法\" class=\"headerlink\" title=\"子类特有方法\"></a>子类特有方法</h3><ol>\n<li><code> Animal animal=new Cat();</code></li>\n<li>编译阶段绑定父类的方法，运行阶段绑定子类对象的方法</li>\n<li>只有编译通过的代码才能运行，所以直接使用子类的方法编译期间就通不过</li>\n<li>编译期间只知道引用是父类型的变量</li>\n<li>当一定需要使用子类特有的方法，则要向下转型</li>\n<li>为避免ClassCastException异常，使用instanceof语法，可以在运行阶段动态判断引用指向的对象的类型。（引用 instanceof 类型） 结果为true/false</li>\n</ol>\n<h2 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h2><ol>\n<li>final修饰的变量只能赋一次值</li>\n<li>引用也是变量,存内存地址.所以final修饰的引用只要指向了一个对象就永远指向那个变量</li>\n<li>局部变量没有初始值,只能手动赋值</li>\n<li>虽然实例变量如果没有手动赋值,系统会赋默认值。但是final修饰实例变量,内部实现让他必须要手动赋值。手动赋值可以在变量后面直接赋值，或者在构造器中赋值</li>\n<li>实例对象用final修饰，说明该实例变量值不会随着对象的变化而变化，所以一般加static修饰变成常量</li>\n<li>常量，静态变量存储在方法区中，在类加载时初始化</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"java简介\"><a href=\"#java简介\" class=\"headerlink\" title=\"java简介\"></a>java简介</h1><h2 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h2><ol>\n<li>简单性(不能直接操作指针)</li>\n<li>面向对象性</li>\n<li>健壮性(GC机制)</li>\n<li>多线程并发</li>\n<li>可移植性/跨平台性 write once,run everywhere</li>\n</ol>\n<h2 id=\"JDK-JRE-JVM\"><a href=\"#JDK-JRE-JVM\" class=\"headerlink\" title=\"JDK,JRE,JVM\"></a>JDK,JRE,JVM</h2><ol>\n<li>JDK包括JRE,JRE包括JVM</li>\n<li>JDK:开发工具包</li>\n<li>JRE:java运行环境</li>\n<li>安装JDK自带JRE,因为开发还需要测试</li>\n</ol>\n<h2 id=\"javac-java\"><a href=\"#javac-java\" class=\"headerlink\" title=\"javac,java\"></a>javac,java</h2><ol>\n<li>javac在编译期,将.java文件形成.class文件 <code>javac MainTest.java</code><br> 相对路径写法，即MainTest.java必须在当前路径下</li>\n<li>java在运行期,运行.class文件   <code>java MainTest</code><br> 如果指定了classpath则不必，否则MainTest.class也必须在当前路径下</li>\n</ol>\n<h1 id=\"JAVA配置环境变量解析\"><a href=\"#JAVA配置环境变量解析\" class=\"headerlink\" title=\"JAVA配置环境变量解析\"></a>JAVA配置环境变量解析</h1><h2 id=\"环境变量简介\"><a href=\"#环境变量简介\" class=\"headerlink\" title=\"环境变量简介\"></a>环境变量简介</h2><p>环境变量包括了 系统变量,用户变量<br>系统变量的范围比较大,会让所有计算机用户都生效<br>用户变量只会作用与当前用户</p>\n<h2 id=\"path环境变量\"><a href=\"#path环境变量\" class=\"headerlink\" title=\"path环境变量\"></a>path环境变量</h2><p>path环境变量告诉windows可以去哪里找到命令.这样就不用写程序的绝对路径了,如<br><code>C:\\Program Files\\Java\\jdk1.8.0_261\\bin\\javac.exe</code>或者<br><code>%JAVA_HOME%\\bin\\java</code><br>可以直接在任何路径下的命令行敲javac</p>\n<h2 id=\"classpath\"><a href=\"#classpath\" class=\"headerlink\" title=\"classpath\"></a>classpath</h2><ol>\n<li>默认情况下classpath只加载当前路径下的class文件</li>\n<li>classpath给类加载器指定路径,让类加载器去指定路径下加载字节码</li>\n<li>为了程序能找到相应的”.class”文件</li>\n<li>classpath不区分大小写,如CLASSPATH</li>\n<li>CLASSPATH配置:<code>.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar</code><h2 id=\"JAVA-HOME\"><a href=\"#JAVA-HOME\" class=\"headerlink\" title=\"JAVA_HOME\"></a>JAVA_HOME</h2></li>\n<li>方便引用。<code>C:\\Program Files\\Java\\jdk1.8.0_261</code>,设置JAVA_HOME为该目录路径, 那么以后你要使用这个路径的时候, 只需输入%JAVA_HOME%即可,避免每次引用都输入很长的路径串;</li>\n<li>归一原则。即只需改一处</li>\n<li>有些第三方软件例如Tomcat约定要用JAVA_HOME</li>\n</ol>\n<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"class文件\"><a href=\"#class文件\" class=\"headerlink\" title=\"class文件\"></a>class文件</h2><ol>\n<li>一个java源文件可以定义多个class</li>\n<li>源文件中只要有一个class定义，就会产生一个class文件</li>\n<li>public类可以没有，但有则必须与源文件名保持一致，且只能有一个</li>\n<li>每个类都能有自己的main方法</li>\n</ol>\n<h2 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h2><ol>\n<li>ASCII码用byte进行编码。计算机先编码，再解码，如果用的不是同一个编码方法，则乱码。 ‘a’ : 97，’A’ : 65， space : 32</li>\n<li>GBK支持中文</li>\n<li>Unicode支持全世界语言文字。具体实现有UTF-8</li>\n<li>char可以存储一个汉字，采用Unicode编码，用单引号</li>\n<li>计算机只存储二进制的补码</li>\n</ol>\n<h2 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h2><ol>\n<li>\\为转义字符，在输出或者字符串中使用，\\加特殊符号则转为普通符号，例如<code>\\&quot;</code>等等</li>\n<li>\\u 后面跟16进制为输出对应的unicode码。例如<code>\\u 4e2d</code>可以转为汉字”中”，（注意没有空格，只是因为typora也会转义)</li>\n</ol>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ol>\n<li>int型中，0x开头代表16进制,如:0xCAFE ，0b开头为二进制，例如int a=0b110,输出结果为6</li>\n<li>一个字面量，默认当作int类型处理，后面加L则默认为long类型</li>\n<li>自动类型转换： long b=200; 200字面量首先默认当作int型，但是自动转换为long。而long b=300L,300字面量默认当作long，赋值给b不存在类型转换。</li>\n<li>long a=200_0000_0000会报错，因为后者默认先为int时，已经超出int，就报错了</li>\n<li>大容量转小容量需要强制类型转换，有可能损失精度</li>\n<li>byte中，当整数型不超过[-128,127]时，该字面量可以直接赋值给byte，不需要类型转换。<code>byte x=127; byte a = (byte)128;</code>short，char也是可以的。只有字面量可以这样转换，例如 <code>short s=a+x</code>则会报错：不兼容的类型：从int转换到short可能会有损失。</li>\n<li><code>char ch=97</code>一个整数赋值给char类型变量能自动类型转换</li>\n<li>byte，short，char混合运算，都会先转换为int再运算</li>\n<li>多种数据类型混合运算，最终结果为“最大容量”类型</li>\n<li>boolean类型不能转换</li>\n<li>如果整数型字面量没有超过byte，short,char的取值范围，可以直接将其赋值给他们相应类型的变量</li>\n<li>容量比较：byte&lt;short(char)&lt;int&lt;long&lt;float&lt;double  char比short代表更大的正整数</li>\n<li><h2 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h2></li>\n<li>float容量&gt;long容量 <code>3.4028235E38</code>与<code>9223372036854775807</code></li>\n<li>所有浮点型默认当作double类型处理，要当作Float，后面加F</li>\n</ol>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><ol>\n<li><pre><code class=\"java\"> byte x=100\n x+=1\n //+=不会改变运算结果类型 \n //x+=1   ====== x=(byte)(x+1)</code></pre>\n</li>\n<li><p>+两边只要有一边是字符串类型，拼接完就还是字符串。遵循从左到右的原则，例如<code>System.out.println(100+200+&quot;300&quot;);//300300</code></p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2></li>\n<li><p>方法重载：同一个类中，方法名相同，参数列表不同。只有返回值不同不能算方法重载</p>\n</li>\n<li><p>尽量不使用递归，消耗内存大</p>\n</li>\n<li><p>方法参数传递只有传值,引用对象也是.不过引用对象传递了地址值过去,所以修改能成功.引用被拷贝,指向的是原对象,所以仍能改变对象值</p>\n</li>\n</ol>\n<h2 id=\"对象相关\"><a href=\"#对象相关\" class=\"headerlink\" title=\"对象相关\"></a>对象相关</h2><ol>\n<li>在类加载时执行且只执行一次</li>\n<li>一个类中可以写多个,代码块有先后顺序,自上而下执行</li>\n<li>静态代码块与静态变量有先后顺序</li>\n<li>此时其他非静态的还未创建</li>\n<li>在构造方法执行之前,执行实例语句块</li>\n<li>this为指向自己的引用.实例对象只有有引用才能访问.所以类中访问成员变量,方法时,省略了this。即age其实是this.age。即当前对象的成员变量age</li>\n<li>this不能用于静态方法，因为静态方法调用不需要this</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>数组是引用数据类型,数组父类是Object,存储在堆中</p>\n<p>数组元素首地址作为整个数组对象的地址</p>\n<p>初始化数组有默认值,如:</p>\n<p><code>String [] names=new String[6]</code>每个元素初始化为null</p>\n<h1 id=\"继承多态\"><a href=\"#继承多态\" class=\"headerlink\" title=\"继承多态\"></a>继承多态</h1><h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><h3 id=\"基础-1\"><a href=\"#基础-1\" class=\"headerlink\" title=\"基础\"></a>基础</h3><ol>\n<li>只允许单继承</li>\n<li>子类继承父类的所有除了构造方法，但是父类私有的属性无法在子类直接访问</li>\n<li>都继承了Object</li>\n<li>this是指向自己的引用</li>\n<li>super不是引用，也不保存内存地址，也不指向一块对象，只是代表当前对象内部的那一块父类型的特征</li>\n<li>this（），super（）都只能出现在构造方法第一行。为u的是创建子类对象时，先初始化父类的特征</li>\n</ol>\n<h3 id=\"方法覆盖\"><a href=\"#方法覆盖\" class=\"headerlink\" title=\"方法覆盖\"></a>方法覆盖</h3><ol>\n<li><p>私有方法无法覆盖</p>\n</li>\n<li><p>构造方法不能被继承，所以也不能被覆盖</p>\n</li>\n<li><p>静态方法覆盖没有意义</p>\n</li>\n<li><p>方法名相同，参数相同，一般来说返回类型也相同。子类的返回值与父类相同或者是父类返回类型的子类型。</p>\n</li>\n<li><p>子类方法可以具有相同的访问权限或者子类的访问权限大于父类</p>\n</li>\n<li><p>子类方法不能比父类方法抛出更多的编译时异常（不是运行时异常），即子类方法抛出的编译时异常或者和父类相同或者是父类异常的子类。</p>\n</li>\n</ol>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><h3 id=\"基础-2\"><a href=\"#基础-2\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>多态：编辑阶段是一种状态，运行阶段又是另外一种状态。父类引用指向子类对象</p>\n<p>向上转型：子类转为父类。<br>        向下转型：父类转为子类，需要加强制类型转换符。</p>\n<p>编译阶段属于静态绑定<br>        运行阶段属于动态绑定</p>\n<h3 id=\"子类特有方法\"><a href=\"#子类特有方法\" class=\"headerlink\" title=\"子类特有方法\"></a>子类特有方法</h3><ol>\n<li><code> Animal animal=new Cat();</code></li>\n<li>编译阶段绑定父类的方法，运行阶段绑定子类对象的方法</li>\n<li>只有编译通过的代码才能运行，所以直接使用子类的方法编译期间就通不过</li>\n<li>编译期间只知道引用是父类型的变量</li>\n<li>当一定需要使用子类特有的方法，则要向下转型</li>\n<li>为避免ClassCastException异常，使用instanceof语法，可以在运行阶段动态判断引用指向的对象的类型。（引用 instanceof 类型） 结果为true/false</li>\n</ol>\n<h2 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h2><ol>\n<li>final修饰的变量只能赋一次值</li>\n<li>引用也是变量,存内存地址.所以final修饰的引用只要指向了一个对象就永远指向那个变量</li>\n<li>局部变量没有初始值,只能手动赋值</li>\n<li>虽然实例变量如果没有手动赋值,系统会赋默认值。但是final修饰实例变量,内部实现让他必须要手动赋值。手动赋值可以在变量后面直接赋值，或者在构造器中赋值</li>\n<li>实例对象用final修饰，说明该实例变量值不会随着对象的变化而变化，所以一般加static修饰变成常量</li>\n<li>常量，静态变量存储在方法区中，在类加载时初始化</li>\n</ol>\n"},{"title":"《Redis设计与实现》-------RDB持久化","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第十章--RDB持久化。","abbrlink":"267cb657","date":"2020-09-16T16:00:00.000Z","_content":"\n# RDB文件的创建与载入\n\n`SAVE指令`会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间,服务器不能处理任何命令请求\n\n`BGSAVE命令`会派生出一个子进程,由它负责创建RDB文件,服务器进程(父进程)继续处理命令请求。\n\n```c\ndef SAVE():\n\t#创建RDB文件\n\trdbSave（）\n\t\ndef BGSAVE():\n\t# 创建子进程\n\tpid=fork()\n\t\n\tif pid == 0:\n\t\t# 子进程负责创建RDB文件\n\t\trdbSave（）\n\t\t# 完成之后向父进程发送信号\n\t\tsignal_parent()\n\telif pid>0:\n\t\t# 父进程继续处理命令请求，并通过轮询等待子进程的信号\n\t\thandle_request_and_wait_signal()\n\telse:\n\t\t# 处理出错情况\n\t\thandle_fork_error()\n```\n\n# 自动间隔性保存\n\n服务器每隔一段时间自动执行一次`BGSAVE`命令，可以设置多个保存条件，只要任意一个条件被满足，服务器就会执行`BGSAVE`指令\n\n```c\nsave 900 1\nsave 300 10\nsave 60 10000\n\n服务器在900秒内进行了至少1次修改\n服务器在300秒内进行了至少10次修改\n服务器在60秒内进行了至少10000次修改\n```\n\n## 设置保存条件\n\n```c\nstruct redisServer\n{\n\tstruct saveparam * saveparams;\n\tlong long dirty; //距离上一次成功执行BGSAVE之后,进行修改的次数\n\ttime_t lastsave; //上一次成功执行BGSAVE的时间\n};\n\nstruct saveparam\n{\n\ttime_t seconds;\n\tint changes;\n}\n```\n\n## 检查保存条件是否满足\n\n默认每隔100ms执行一次`serverCron()`\n\n```c\ndef serverCron():\n\t# 遍历所有保存条件\n\tfor saveparam in server.saveparams:\n\t\tsave_interval=unixtime_now()-server.lastsave\n\t\t\n\t\t#如果数据库状态的修改次数超过条件所设置的次数\n\t\t#并且距离上次保存的时间超过条件所设置的时间\n\t\t#那么执行保存操作\n\t\tif server.dirty >= saveparam.changes and save_interval>saveparam.seconds:\n\t\t\tBGSAVE()\n```\n\n# RDB文件结构\n\n## 概览\n\n1. REDIS,通过这五个字符,程序可以在载入文件时,快速检查所载入的文件是否是RDB文件\n2. db_version,记录了版本号\n3. databases,包含任意个数据库以及他们的键值对数据。\n4. EOF，标志着RDB文件正文内容的结束\n5. check_sum,校验和，检查RDB文件是否有出错或损坏的情况\n\n## databases\n\n每个非空数据库保存三部分：\n\n1. SELECTDB 常量，说明接下来会读取一个数据库号码\n2. db_number，读入后，调用SELECT指令，进行数据库切换，使得之后读入的键值对可以载入到正确的数据库之中\n3. key_value_pairs，保存了数据库中的所有键值对数据。包含过期时间。\n\n## key_value_pairs\n\n1. TYPE记录了value的类型，代表了一种对象类型或底层编码。\n2. key总是一个字符串对象\n3. value根据TYPE的指令保存相应类型的内容\n4. EXPIRETIME_MS常量，代表之后会读取一个以毫秒为单位的过期时间\n5. ms，保存键值对的过期时间\n\n","source":"_posts/Redis笔记/10.RDB持久化.md","raw":"---\ntitle: 《Redis设计与实现》-------RDB持久化\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第十章--RDB持久化。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - RDB\n  - 数据库\nabbrlink: 267cb657\ndate: 2020-09-17 00:00:00\n---\n\n# RDB文件的创建与载入\n\n`SAVE指令`会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间,服务器不能处理任何命令请求\n\n`BGSAVE命令`会派生出一个子进程,由它负责创建RDB文件,服务器进程(父进程)继续处理命令请求。\n\n```c\ndef SAVE():\n\t#创建RDB文件\n\trdbSave（）\n\t\ndef BGSAVE():\n\t# 创建子进程\n\tpid=fork()\n\t\n\tif pid == 0:\n\t\t# 子进程负责创建RDB文件\n\t\trdbSave（）\n\t\t# 完成之后向父进程发送信号\n\t\tsignal_parent()\n\telif pid>0:\n\t\t# 父进程继续处理命令请求，并通过轮询等待子进程的信号\n\t\thandle_request_and_wait_signal()\n\telse:\n\t\t# 处理出错情况\n\t\thandle_fork_error()\n```\n\n# 自动间隔性保存\n\n服务器每隔一段时间自动执行一次`BGSAVE`命令，可以设置多个保存条件，只要任意一个条件被满足，服务器就会执行`BGSAVE`指令\n\n```c\nsave 900 1\nsave 300 10\nsave 60 10000\n\n服务器在900秒内进行了至少1次修改\n服务器在300秒内进行了至少10次修改\n服务器在60秒内进行了至少10000次修改\n```\n\n## 设置保存条件\n\n```c\nstruct redisServer\n{\n\tstruct saveparam * saveparams;\n\tlong long dirty; //距离上一次成功执行BGSAVE之后,进行修改的次数\n\ttime_t lastsave; //上一次成功执行BGSAVE的时间\n};\n\nstruct saveparam\n{\n\ttime_t seconds;\n\tint changes;\n}\n```\n\n## 检查保存条件是否满足\n\n默认每隔100ms执行一次`serverCron()`\n\n```c\ndef serverCron():\n\t# 遍历所有保存条件\n\tfor saveparam in server.saveparams:\n\t\tsave_interval=unixtime_now()-server.lastsave\n\t\t\n\t\t#如果数据库状态的修改次数超过条件所设置的次数\n\t\t#并且距离上次保存的时间超过条件所设置的时间\n\t\t#那么执行保存操作\n\t\tif server.dirty >= saveparam.changes and save_interval>saveparam.seconds:\n\t\t\tBGSAVE()\n```\n\n# RDB文件结构\n\n## 概览\n\n1. REDIS,通过这五个字符,程序可以在载入文件时,快速检查所载入的文件是否是RDB文件\n2. db_version,记录了版本号\n3. databases,包含任意个数据库以及他们的键值对数据。\n4. EOF，标志着RDB文件正文内容的结束\n5. check_sum,校验和，检查RDB文件是否有出错或损坏的情况\n\n## databases\n\n每个非空数据库保存三部分：\n\n1. SELECTDB 常量，说明接下来会读取一个数据库号码\n2. db_number，读入后，调用SELECT指令，进行数据库切换，使得之后读入的键值对可以载入到正确的数据库之中\n3. key_value_pairs，保存了数据库中的所有键值对数据。包含过期时间。\n\n## key_value_pairs\n\n1. TYPE记录了value的类型，代表了一种对象类型或底层编码。\n2. key总是一个字符串对象\n3. value根据TYPE的指令保存相应类型的内容\n4. EXPIRETIME_MS常量，代表之后会读取一个以毫秒为单位的过期时间\n5. ms，保存键值对的过期时间\n\n","slug":"Redis笔记/10.RDB持久化","published":1,"updated":"2020-11-12T11:57:29.823Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wa001bjotpgva3c3vx","content":"<h1 id=\"RDB文件的创建与载入\"><a href=\"#RDB文件的创建与载入\" class=\"headerlink\" title=\"RDB文件的创建与载入\"></a>RDB文件的创建与载入</h1><p><code>SAVE指令</code>会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间,服务器不能处理任何命令请求</p>\n<p><code>BGSAVE命令</code>会派生出一个子进程,由它负责创建RDB文件,服务器进程(父进程)继续处理命令请求。</p>\n<pre class=\" language-c\"><code class=\"language-c\">def <span class=\"token function\">SAVE</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    #创建RDB文件\n    rdbSave（）\n\ndef <span class=\"token function\">BGSAVE</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    # 创建子进程\n    pid<span class=\"token operator\">=</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> pid <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        # 子进程负责创建RDB文件\n        rdbSave（）\n        # 完成之后向父进程发送信号\n        <span class=\"token function\">signal_parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    elif pid<span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        # 父进程继续处理命令请求，并通过轮询等待子进程的信号\n        <span class=\"token function\">handle_request_and_wait_signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        # 处理出错情况\n        <span class=\"token function\">handle_fork_error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<h1 id=\"自动间隔性保存\"><a href=\"#自动间隔性保存\" class=\"headerlink\" title=\"自动间隔性保存\"></a>自动间隔性保存</h1><p>服务器每隔一段时间自动执行一次<code>BGSAVE</code>命令，可以设置多个保存条件，只要任意一个条件被满足，服务器就会执行<code>BGSAVE</code>指令</p>\n<pre class=\" language-c\"><code class=\"language-c\">save <span class=\"token number\">900</span> <span class=\"token number\">1</span>\nsave <span class=\"token number\">300</span> <span class=\"token number\">10</span>\nsave <span class=\"token number\">60</span> <span class=\"token number\">10000</span>\n\n服务器在<span class=\"token number\">900</span>秒内进行了至少<span class=\"token number\">1</span>次修改\n服务器在<span class=\"token number\">300</span>秒内进行了至少<span class=\"token number\">10</span>次修改\n服务器在<span class=\"token number\">60</span>秒内进行了至少<span class=\"token number\">10000</span>次修改</code></pre>\n<h2 id=\"设置保存条件\"><a href=\"#设置保存条件\" class=\"headerlink\" title=\"设置保存条件\"></a>设置保存条件</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> redisServer\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> saveparam <span class=\"token operator\">*</span> saveparams<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> dirty<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//距离上一次成功执行BGSAVE之后,进行修改的次数</span>\n    time_t lastsave<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//上一次成功执行BGSAVE的时间</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> saveparam\n<span class=\"token punctuation\">{</span>\n    time_t seconds<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> changes<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"检查保存条件是否满足\"><a href=\"#检查保存条件是否满足\" class=\"headerlink\" title=\"检查保存条件是否满足\"></a>检查保存条件是否满足</h2><p>默认每隔100ms执行一次<code>serverCron()</code></p>\n<pre class=\" language-c\"><code class=\"language-c\">def <span class=\"token function\">serverCron</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    # 遍历所有保存条件\n    <span class=\"token keyword\">for</span> saveparam in server<span class=\"token punctuation\">.</span>saveparams<span class=\"token punctuation\">:</span>\n        save_interval<span class=\"token operator\">=</span><span class=\"token function\">unixtime_now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span>server<span class=\"token punctuation\">.</span>lastsave\n\n        #如果数据库状态的修改次数超过条件所设置的次数\n        #并且距离上次保存的时间超过条件所设置的时间\n        #那么执行保存操作\n        <span class=\"token keyword\">if</span> server<span class=\"token punctuation\">.</span>dirty <span class=\"token operator\">>=</span> saveparam<span class=\"token punctuation\">.</span>changes and save_interval<span class=\"token operator\">></span>saveparam<span class=\"token punctuation\">.</span>seconds<span class=\"token punctuation\">:</span>\n            <span class=\"token function\">BGSAVE</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<h1 id=\"RDB文件结构\"><a href=\"#RDB文件结构\" class=\"headerlink\" title=\"RDB文件结构\"></a>RDB文件结构</h1><h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><ol>\n<li>REDIS,通过这五个字符,程序可以在载入文件时,快速检查所载入的文件是否是RDB文件</li>\n<li>db_version,记录了版本号</li>\n<li>databases,包含任意个数据库以及他们的键值对数据。</li>\n<li>EOF，标志着RDB文件正文内容的结束</li>\n<li>check_sum,校验和，检查RDB文件是否有出错或损坏的情况</li>\n</ol>\n<h2 id=\"databases\"><a href=\"#databases\" class=\"headerlink\" title=\"databases\"></a>databases</h2><p>每个非空数据库保存三部分：</p>\n<ol>\n<li>SELECTDB 常量，说明接下来会读取一个数据库号码</li>\n<li>db_number，读入后，调用SELECT指令，进行数据库切换，使得之后读入的键值对可以载入到正确的数据库之中</li>\n<li>key_value_pairs，保存了数据库中的所有键值对数据。包含过期时间。</li>\n</ol>\n<h2 id=\"key-value-pairs\"><a href=\"#key-value-pairs\" class=\"headerlink\" title=\"key_value_pairs\"></a>key_value_pairs</h2><ol>\n<li>TYPE记录了value的类型，代表了一种对象类型或底层编码。</li>\n<li>key总是一个字符串对象</li>\n<li>value根据TYPE的指令保存相应类型的内容</li>\n<li>EXPIRETIME_MS常量，代表之后会读取一个以毫秒为单位的过期时间</li>\n<li>ms，保存键值对的过期时间</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"RDB文件的创建与载入\"><a href=\"#RDB文件的创建与载入\" class=\"headerlink\" title=\"RDB文件的创建与载入\"></a>RDB文件的创建与载入</h1><p><code>SAVE指令</code>会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间,服务器不能处理任何命令请求</p>\n<p><code>BGSAVE命令</code>会派生出一个子进程,由它负责创建RDB文件,服务器进程(父进程)继续处理命令请求。</p>\n<pre><code class=\"c\">def SAVE():\n    #创建RDB文件\n    rdbSave（）\n\ndef BGSAVE():\n    # 创建子进程\n    pid=fork()\n\n    if pid == 0:\n        # 子进程负责创建RDB文件\n        rdbSave（）\n        # 完成之后向父进程发送信号\n        signal_parent()\n    elif pid&gt;0:\n        # 父进程继续处理命令请求，并通过轮询等待子进程的信号\n        handle_request_and_wait_signal()\n    else:\n        # 处理出错情况\n        handle_fork_error()</code></pre>\n<h1 id=\"自动间隔性保存\"><a href=\"#自动间隔性保存\" class=\"headerlink\" title=\"自动间隔性保存\"></a>自动间隔性保存</h1><p>服务器每隔一段时间自动执行一次<code>BGSAVE</code>命令，可以设置多个保存条件，只要任意一个条件被满足，服务器就会执行<code>BGSAVE</code>指令</p>\n<pre><code class=\"c\">save 900 1\nsave 300 10\nsave 60 10000\n\n服务器在900秒内进行了至少1次修改\n服务器在300秒内进行了至少10次修改\n服务器在60秒内进行了至少10000次修改</code></pre>\n<h2 id=\"设置保存条件\"><a href=\"#设置保存条件\" class=\"headerlink\" title=\"设置保存条件\"></a>设置保存条件</h2><pre><code class=\"c\">struct redisServer\n{\n    struct saveparam * saveparams;\n    long long dirty; //距离上一次成功执行BGSAVE之后,进行修改的次数\n    time_t lastsave; //上一次成功执行BGSAVE的时间\n};\n\nstruct saveparam\n{\n    time_t seconds;\n    int changes;\n}</code></pre>\n<h2 id=\"检查保存条件是否满足\"><a href=\"#检查保存条件是否满足\" class=\"headerlink\" title=\"检查保存条件是否满足\"></a>检查保存条件是否满足</h2><p>默认每隔100ms执行一次<code>serverCron()</code></p>\n<pre><code class=\"c\">def serverCron():\n    # 遍历所有保存条件\n    for saveparam in server.saveparams:\n        save_interval=unixtime_now()-server.lastsave\n\n        #如果数据库状态的修改次数超过条件所设置的次数\n        #并且距离上次保存的时间超过条件所设置的时间\n        #那么执行保存操作\n        if server.dirty &gt;= saveparam.changes and save_interval&gt;saveparam.seconds:\n            BGSAVE()</code></pre>\n<h1 id=\"RDB文件结构\"><a href=\"#RDB文件结构\" class=\"headerlink\" title=\"RDB文件结构\"></a>RDB文件结构</h1><h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><ol>\n<li>REDIS,通过这五个字符,程序可以在载入文件时,快速检查所载入的文件是否是RDB文件</li>\n<li>db_version,记录了版本号</li>\n<li>databases,包含任意个数据库以及他们的键值对数据。</li>\n<li>EOF，标志着RDB文件正文内容的结束</li>\n<li>check_sum,校验和，检查RDB文件是否有出错或损坏的情况</li>\n</ol>\n<h2 id=\"databases\"><a href=\"#databases\" class=\"headerlink\" title=\"databases\"></a>databases</h2><p>每个非空数据库保存三部分：</p>\n<ol>\n<li>SELECTDB 常量，说明接下来会读取一个数据库号码</li>\n<li>db_number，读入后，调用SELECT指令，进行数据库切换，使得之后读入的键值对可以载入到正确的数据库之中</li>\n<li>key_value_pairs，保存了数据库中的所有键值对数据。包含过期时间。</li>\n</ol>\n<h2 id=\"key-value-pairs\"><a href=\"#key-value-pairs\" class=\"headerlink\" title=\"key_value_pairs\"></a>key_value_pairs</h2><ol>\n<li>TYPE记录了value的类型，代表了一种对象类型或底层编码。</li>\n<li>key总是一个字符串对象</li>\n<li>value根据TYPE的指令保存相应类型的内容</li>\n<li>EXPIRETIME_MS常量，代表之后会读取一个以毫秒为单位的过期时间</li>\n<li>ms，保存键值对的过期时间</li>\n</ol>\n"},{"title":"《Redis设计与实现》-------AOF持久化","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第十一章--AOF持久化。","abbrlink":"7730ae65","date":"2020-09-21T16:00:00.000Z","_content":"\n# 简介\n\n通过保存`Redis`服务器所执行的写命令来记录数据库状态的\n\n服务器启动时,可以通过载入和执行`AOF文件`中保存的命令来还原服务器关闭之前的数据库状态\n\n# AOF持久化的实现\n\n## 命令追加\n\n服务器在执行完一个写命令后,会将被执行的写命令追加到服务器状态的`aof_buf`缓冲区的末尾:\n\n```c\nstruct redisServer\n{\n\t// AOF缓冲区\n\tsds aof_buf;\n}\n```\n\n## AOF文件的写入与同步\n\n服务器进程是一个事件循环,循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复.时间事件负责执行像serverCron函数这样需要定时运行的函数\n\n```python\ndef eventLoop()\n{\n\twhile True:\n\t\t#处理文件事件,接收命令请求以及发送命令回复\n\t\t#处理命令请求时可能会有新内容加入到aof_buf缓冲区中\n\t\tprocessFileEvents()\n\t\t\n\t\t#处理时间事件\n\t\tprocessTimeEvents()\n\t\t\n\t\t#考虑是否要将aof_buf缓冲区中的内容写入和保存到AOF文件里面\n\t\tflushAppendOnlyFile()\n}\n```\n\n# AOF文件的载入与数据还原\n\n只要读入并重新执行一遍`AOF文件`里面保存的写命令,就可以还原服务器关闭之前的数据库状态\n\n1. 创建一个不带网络连接的伪客户端\n2. 从AOF文件中分析并读取出一条写命令\n3. 使用伪客户端执行被读出的写命令\n4. 一直执行2,3直到AOF文件中的所有写命令都被处理完毕\n\n# AOF重写\n\n服务器创建一个新的AOF文件来**替代**现有的AOF文件,新旧两个AOF文件所保存的数据库状态相同,但是新的AOF文件不会包含任何浪费空间的冗余命令\n\n## AOF文件重写的实现\n\n不需要对现有的AOF文件进行操作,是通过读取服务器当前的数据库状态来实现的\n\n```python\ndef aof_rewrite(new_aof_file_name):\n\t#创建新的aof文件\n\tf=create_file(new_aof_file_name)\n\t#遍历数据库\n\tfor db in redisServer.db:\n\t\t#忽略空数据库\n\t\tif db.is_empty():continue\n\t\t\n\t\t#写入SELECT命令,指定数据库号码\n\t\tf.write_command(\"SELECT\"+db.id)\n\t\t\n\t\t#遍历数据库中所有键\n\t\tfor key in db:\n\t\t\t#忽略过期的键\n\t\t\tif key.is_expired():continue\n\t\t\t\n\t\t\t#根据键的类型对键进行重写\n\t\t\tif key.type == String:\n\t\t\t\trewrite_string(key)\n\t\t\telif key.type == List:\n\t\t\t\trewrite_list(key)\n\t\t\telif key.type == Hash:\n\t\t\t\trewrite_hash(key)\n            elif key.type == Set:\n\t\t\t\trewrite_set(key)\n            elif key.type == SortedSet:\n\t\t\t\trewrite_sortedSet(key)\n\t\t\t\t\n\t\t\t# 如果键带有过期时间,过期时间也要重写\n\t\t\tif key.have_expired_time():\n\t\t\t\trewrite_expired_time(key)\n\t#写入完毕,关闭文件\t\t\t\n\tf.close()\n\t\ndef rewrite_string(key):\n\t#使用GET命令获取字符串的值\n\tvalue=GET(key)\n\t#使用SET命令重写字符串键\n\tf.write_command(SET,key,value)\n\t\ndef rewrite_expired_time(key):\n\t#获取毫秒精度的键过期时间戳\n\ttimestamp=get_expired_time_in_unixstamp(key)\n\t#使用PEXPIREAT命令重写键的过期时间\n\tf.write_command(PEXPIREAT,key,timestamp)\n```\n\n\n\n## AOF后台重写\n\nRedis服务器使用单个线程来处理命令请求,决定将AOF重写程序放到子进程中执行\n\n+ 子进程在进行AOF重写期间,服务器进程可以进行处理命令请求\n+ 子进程带有服务器进程的数据副本,使用子进程而不是线程,可以在避免使用锁的情况下,保证数据的安全性\n\n但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库状态不一致\n\n\n\n在子进程执行AOF重写期间,服务器进程执行:\n\n1. 执行客户端发来的指令\n2. 将执行后的写命令追加到AOF缓冲区\n3. 将执行后的写命令追加到AOF重写缓冲区\n\n\n\n当子进程完成AOF重写工作后,他会向父进程发送一个信号,父进程将执行:\n\n1. 将AOF重写缓冲区中所有内容写入到新的AOF文件中,这时新的AOF文件所保存的内容就与当前的数据库状态一致\n2. 对新的AOF文件进行改名,原子地覆盖现有的AOF文件,完成新旧AOF文件的替换","source":"_posts/Redis笔记/11.AOF持久化.md","raw":"---\ntitle: 《Redis设计与实现》-------AOF持久化\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第十一章--AOF持久化。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - AOF\n  - 数据库\nabbrlink: 7730ae65\ndate: 2020-09-22 00:00:00\n---\n\n# 简介\n\n通过保存`Redis`服务器所执行的写命令来记录数据库状态的\n\n服务器启动时,可以通过载入和执行`AOF文件`中保存的命令来还原服务器关闭之前的数据库状态\n\n# AOF持久化的实现\n\n## 命令追加\n\n服务器在执行完一个写命令后,会将被执行的写命令追加到服务器状态的`aof_buf`缓冲区的末尾:\n\n```c\nstruct redisServer\n{\n\t// AOF缓冲区\n\tsds aof_buf;\n}\n```\n\n## AOF文件的写入与同步\n\n服务器进程是一个事件循环,循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复.时间事件负责执行像serverCron函数这样需要定时运行的函数\n\n```python\ndef eventLoop()\n{\n\twhile True:\n\t\t#处理文件事件,接收命令请求以及发送命令回复\n\t\t#处理命令请求时可能会有新内容加入到aof_buf缓冲区中\n\t\tprocessFileEvents()\n\t\t\n\t\t#处理时间事件\n\t\tprocessTimeEvents()\n\t\t\n\t\t#考虑是否要将aof_buf缓冲区中的内容写入和保存到AOF文件里面\n\t\tflushAppendOnlyFile()\n}\n```\n\n# AOF文件的载入与数据还原\n\n只要读入并重新执行一遍`AOF文件`里面保存的写命令,就可以还原服务器关闭之前的数据库状态\n\n1. 创建一个不带网络连接的伪客户端\n2. 从AOF文件中分析并读取出一条写命令\n3. 使用伪客户端执行被读出的写命令\n4. 一直执行2,3直到AOF文件中的所有写命令都被处理完毕\n\n# AOF重写\n\n服务器创建一个新的AOF文件来**替代**现有的AOF文件,新旧两个AOF文件所保存的数据库状态相同,但是新的AOF文件不会包含任何浪费空间的冗余命令\n\n## AOF文件重写的实现\n\n不需要对现有的AOF文件进行操作,是通过读取服务器当前的数据库状态来实现的\n\n```python\ndef aof_rewrite(new_aof_file_name):\n\t#创建新的aof文件\n\tf=create_file(new_aof_file_name)\n\t#遍历数据库\n\tfor db in redisServer.db:\n\t\t#忽略空数据库\n\t\tif db.is_empty():continue\n\t\t\n\t\t#写入SELECT命令,指定数据库号码\n\t\tf.write_command(\"SELECT\"+db.id)\n\t\t\n\t\t#遍历数据库中所有键\n\t\tfor key in db:\n\t\t\t#忽略过期的键\n\t\t\tif key.is_expired():continue\n\t\t\t\n\t\t\t#根据键的类型对键进行重写\n\t\t\tif key.type == String:\n\t\t\t\trewrite_string(key)\n\t\t\telif key.type == List:\n\t\t\t\trewrite_list(key)\n\t\t\telif key.type == Hash:\n\t\t\t\trewrite_hash(key)\n            elif key.type == Set:\n\t\t\t\trewrite_set(key)\n            elif key.type == SortedSet:\n\t\t\t\trewrite_sortedSet(key)\n\t\t\t\t\n\t\t\t# 如果键带有过期时间,过期时间也要重写\n\t\t\tif key.have_expired_time():\n\t\t\t\trewrite_expired_time(key)\n\t#写入完毕,关闭文件\t\t\t\n\tf.close()\n\t\ndef rewrite_string(key):\n\t#使用GET命令获取字符串的值\n\tvalue=GET(key)\n\t#使用SET命令重写字符串键\n\tf.write_command(SET,key,value)\n\t\ndef rewrite_expired_time(key):\n\t#获取毫秒精度的键过期时间戳\n\ttimestamp=get_expired_time_in_unixstamp(key)\n\t#使用PEXPIREAT命令重写键的过期时间\n\tf.write_command(PEXPIREAT,key,timestamp)\n```\n\n\n\n## AOF后台重写\n\nRedis服务器使用单个线程来处理命令请求,决定将AOF重写程序放到子进程中执行\n\n+ 子进程在进行AOF重写期间,服务器进程可以进行处理命令请求\n+ 子进程带有服务器进程的数据副本,使用子进程而不是线程,可以在避免使用锁的情况下,保证数据的安全性\n\n但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库状态不一致\n\n\n\n在子进程执行AOF重写期间,服务器进程执行:\n\n1. 执行客户端发来的指令\n2. 将执行后的写命令追加到AOF缓冲区\n3. 将执行后的写命令追加到AOF重写缓冲区\n\n\n\n当子进程完成AOF重写工作后,他会向父进程发送一个信号,父进程将执行:\n\n1. 将AOF重写缓冲区中所有内容写入到新的AOF文件中,这时新的AOF文件所保存的内容就与当前的数据库状态一致\n2. 对新的AOF文件进行改名,原子地覆盖现有的AOF文件,完成新旧AOF文件的替换","slug":"Redis笔记/11.AOF持久化","published":1,"updated":"2020-11-12T11:57:29.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wb001djotp782v0pu9","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>通过保存<code>Redis</code>服务器所执行的写命令来记录数据库状态的</p>\n<p>服务器启动时,可以通过载入和执行<code>AOF文件</code>中保存的命令来还原服务器关闭之前的数据库状态</p>\n<h1 id=\"AOF持久化的实现\"><a href=\"#AOF持久化的实现\" class=\"headerlink\" title=\"AOF持久化的实现\"></a>AOF持久化的实现</h1><h2 id=\"命令追加\"><a href=\"#命令追加\" class=\"headerlink\" title=\"命令追加\"></a>命令追加</h2><p>服务器在执行完一个写命令后,会将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾:</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> redisServer\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// AOF缓冲区</span>\n    sds aof_buf<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"AOF文件的写入与同步\"><a href=\"#AOF文件的写入与同步\" class=\"headerlink\" title=\"AOF文件的写入与同步\"></a>AOF文件的写入与同步</h2><p>服务器进程是一个事件循环,循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复.时间事件负责执行像serverCron函数这样需要定时运行的函数</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">eventLoop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">#处理文件事件,接收命令请求以及发送命令回复</span>\n        <span class=\"token comment\" spellcheck=\"true\">#处理命令请求时可能会有新内容加入到aof_buf缓冲区中</span>\n        processFileEvents<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#处理时间事件</span>\n        processTimeEvents<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#考虑是否要将aof_buf缓冲区中的内容写入和保存到AOF文件里面</span>\n        flushAppendOnlyFile<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"AOF文件的载入与数据还原\"><a href=\"#AOF文件的载入与数据还原\" class=\"headerlink\" title=\"AOF文件的载入与数据还原\"></a>AOF文件的载入与数据还原</h1><p>只要读入并重新执行一遍<code>AOF文件</code>里面保存的写命令,就可以还原服务器关闭之前的数据库状态</p>\n<ol>\n<li>创建一个不带网络连接的伪客户端</li>\n<li>从AOF文件中分析并读取出一条写命令</li>\n<li>使用伪客户端执行被读出的写命令</li>\n<li>一直执行2,3直到AOF文件中的所有写命令都被处理完毕</li>\n</ol>\n<h1 id=\"AOF重写\"><a href=\"#AOF重写\" class=\"headerlink\" title=\"AOF重写\"></a>AOF重写</h1><p>服务器创建一个新的AOF文件来<strong>替代</strong>现有的AOF文件,新旧两个AOF文件所保存的数据库状态相同,但是新的AOF文件不会包含任何浪费空间的冗余命令</p>\n<h2 id=\"AOF文件重写的实现\"><a href=\"#AOF文件重写的实现\" class=\"headerlink\" title=\"AOF文件重写的实现\"></a>AOF文件重写的实现</h2><p>不需要对现有的AOF文件进行操作,是通过读取服务器当前的数据库状态来实现的</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">aof_rewrite</span><span class=\"token punctuation\">(</span>new_aof_file_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#创建新的aof文件</span>\n    f<span class=\"token operator\">=</span>create_file<span class=\"token punctuation\">(</span>new_aof_file_name<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">#遍历数据库</span>\n    <span class=\"token keyword\">for</span> db <span class=\"token keyword\">in</span> redisServer<span class=\"token punctuation\">.</span>db<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">#忽略空数据库</span>\n        <span class=\"token keyword\">if</span> db<span class=\"token punctuation\">.</span>is_empty<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">continue</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#写入SELECT命令,指定数据库号码</span>\n        f<span class=\"token punctuation\">.</span>write_command<span class=\"token punctuation\">(</span><span class=\"token string\">\"SELECT\"</span><span class=\"token operator\">+</span>db<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#遍历数据库中所有键</span>\n        <span class=\"token keyword\">for</span> key <span class=\"token keyword\">in</span> db<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\" spellcheck=\"true\">#忽略过期的键</span>\n            <span class=\"token keyword\">if</span> key<span class=\"token punctuation\">.</span>is_expired<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">continue</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">#根据键的类型对键进行重写</span>\n            <span class=\"token keyword\">if</span> key<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> String<span class=\"token punctuation\">:</span>\n                rewrite_string<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">elif</span> key<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> List<span class=\"token punctuation\">:</span>\n                rewrite_list<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">elif</span> key<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> Hash<span class=\"token punctuation\">:</span>\n                rewrite_hash<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">elif</span> key<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> Set<span class=\"token punctuation\">:</span>\n                rewrite_set<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">elif</span> key<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> SortedSet<span class=\"token punctuation\">:</span>\n                rewrite_sortedSet<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n\n            <span class=\"token comment\" spellcheck=\"true\"># 如果键带有过期时间,过期时间也要重写</span>\n            <span class=\"token keyword\">if</span> key<span class=\"token punctuation\">.</span>have_expired_time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                rewrite_expired_time<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">#写入完毕,关闭文件            </span>\n    f<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">rewrite_string</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#使用GET命令获取字符串的值</span>\n    value<span class=\"token operator\">=</span>GET<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">#使用SET命令重写字符串键</span>\n    f<span class=\"token punctuation\">.</span>write_command<span class=\"token punctuation\">(</span>SET<span class=\"token punctuation\">,</span>key<span class=\"token punctuation\">,</span>value<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">rewrite_expired_time</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#获取毫秒精度的键过期时间戳</span>\n    timestamp<span class=\"token operator\">=</span>get_expired_time_in_unixstamp<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">#使用PEXPIREAT命令重写键的过期时间</span>\n    f<span class=\"token punctuation\">.</span>write_command<span class=\"token punctuation\">(</span>PEXPIREAT<span class=\"token punctuation\">,</span>key<span class=\"token punctuation\">,</span>timestamp<span class=\"token punctuation\">)</span></code></pre>\n<h2 id=\"AOF后台重写\"><a href=\"#AOF后台重写\" class=\"headerlink\" title=\"AOF后台重写\"></a>AOF后台重写</h2><p>Redis服务器使用单个线程来处理命令请求,决定将AOF重写程序放到子进程中执行</p>\n<ul>\n<li>子进程在进行AOF重写期间,服务器进程可以进行处理命令请求</li>\n<li>子进程带有服务器进程的数据副本,使用子进程而不是线程,可以在避免使用锁的情况下,保证数据的安全性</li>\n</ul>\n<p>但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库状态不一致</p>\n<p>在子进程执行AOF重写期间,服务器进程执行:</p>\n<ol>\n<li>执行客户端发来的指令</li>\n<li>将执行后的写命令追加到AOF缓冲区</li>\n<li>将执行后的写命令追加到AOF重写缓冲区</li>\n</ol>\n<p>当子进程完成AOF重写工作后,他会向父进程发送一个信号,父进程将执行:</p>\n<ol>\n<li>将AOF重写缓冲区中所有内容写入到新的AOF文件中,这时新的AOF文件所保存的内容就与当前的数据库状态一致</li>\n<li>对新的AOF文件进行改名,原子地覆盖现有的AOF文件,完成新旧AOF文件的替换</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>通过保存<code>Redis</code>服务器所执行的写命令来记录数据库状态的</p>\n<p>服务器启动时,可以通过载入和执行<code>AOF文件</code>中保存的命令来还原服务器关闭之前的数据库状态</p>\n<h1 id=\"AOF持久化的实现\"><a href=\"#AOF持久化的实现\" class=\"headerlink\" title=\"AOF持久化的实现\"></a>AOF持久化的实现</h1><h2 id=\"命令追加\"><a href=\"#命令追加\" class=\"headerlink\" title=\"命令追加\"></a>命令追加</h2><p>服务器在执行完一个写命令后,会将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾:</p>\n<pre><code class=\"c\">struct redisServer\n{\n    // AOF缓冲区\n    sds aof_buf;\n}</code></pre>\n<h2 id=\"AOF文件的写入与同步\"><a href=\"#AOF文件的写入与同步\" class=\"headerlink\" title=\"AOF文件的写入与同步\"></a>AOF文件的写入与同步</h2><p>服务器进程是一个事件循环,循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复.时间事件负责执行像serverCron函数这样需要定时运行的函数</p>\n<pre><code class=\"python\">def eventLoop()\n{\n    while True:\n        #处理文件事件,接收命令请求以及发送命令回复\n        #处理命令请求时可能会有新内容加入到aof_buf缓冲区中\n        processFileEvents()\n\n        #处理时间事件\n        processTimeEvents()\n\n        #考虑是否要将aof_buf缓冲区中的内容写入和保存到AOF文件里面\n        flushAppendOnlyFile()\n}</code></pre>\n<h1 id=\"AOF文件的载入与数据还原\"><a href=\"#AOF文件的载入与数据还原\" class=\"headerlink\" title=\"AOF文件的载入与数据还原\"></a>AOF文件的载入与数据还原</h1><p>只要读入并重新执行一遍<code>AOF文件</code>里面保存的写命令,就可以还原服务器关闭之前的数据库状态</p>\n<ol>\n<li>创建一个不带网络连接的伪客户端</li>\n<li>从AOF文件中分析并读取出一条写命令</li>\n<li>使用伪客户端执行被读出的写命令</li>\n<li>一直执行2,3直到AOF文件中的所有写命令都被处理完毕</li>\n</ol>\n<h1 id=\"AOF重写\"><a href=\"#AOF重写\" class=\"headerlink\" title=\"AOF重写\"></a>AOF重写</h1><p>服务器创建一个新的AOF文件来<strong>替代</strong>现有的AOF文件,新旧两个AOF文件所保存的数据库状态相同,但是新的AOF文件不会包含任何浪费空间的冗余命令</p>\n<h2 id=\"AOF文件重写的实现\"><a href=\"#AOF文件重写的实现\" class=\"headerlink\" title=\"AOF文件重写的实现\"></a>AOF文件重写的实现</h2><p>不需要对现有的AOF文件进行操作,是通过读取服务器当前的数据库状态来实现的</p>\n<pre><code class=\"python\">def aof_rewrite(new_aof_file_name):\n    #创建新的aof文件\n    f=create_file(new_aof_file_name)\n    #遍历数据库\n    for db in redisServer.db:\n        #忽略空数据库\n        if db.is_empty():continue\n\n        #写入SELECT命令,指定数据库号码\n        f.write_command(&quot;SELECT&quot;+db.id)\n\n        #遍历数据库中所有键\n        for key in db:\n            #忽略过期的键\n            if key.is_expired():continue\n\n            #根据键的类型对键进行重写\n            if key.type == String:\n                rewrite_string(key)\n            elif key.type == List:\n                rewrite_list(key)\n            elif key.type == Hash:\n                rewrite_hash(key)\n            elif key.type == Set:\n                rewrite_set(key)\n            elif key.type == SortedSet:\n                rewrite_sortedSet(key)\n\n            # 如果键带有过期时间,过期时间也要重写\n            if key.have_expired_time():\n                rewrite_expired_time(key)\n    #写入完毕,关闭文件            \n    f.close()\n\ndef rewrite_string(key):\n    #使用GET命令获取字符串的值\n    value=GET(key)\n    #使用SET命令重写字符串键\n    f.write_command(SET,key,value)\n\ndef rewrite_expired_time(key):\n    #获取毫秒精度的键过期时间戳\n    timestamp=get_expired_time_in_unixstamp(key)\n    #使用PEXPIREAT命令重写键的过期时间\n    f.write_command(PEXPIREAT,key,timestamp)</code></pre>\n<h2 id=\"AOF后台重写\"><a href=\"#AOF后台重写\" class=\"headerlink\" title=\"AOF后台重写\"></a>AOF后台重写</h2><p>Redis服务器使用单个线程来处理命令请求,决定将AOF重写程序放到子进程中执行</p>\n<ul>\n<li>子进程在进行AOF重写期间,服务器进程可以进行处理命令请求</li>\n<li>子进程带有服务器进程的数据副本,使用子进程而不是线程,可以在避免使用锁的情况下,保证数据的安全性</li>\n</ul>\n<p>但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库状态不一致</p>\n<p>在子进程执行AOF重写期间,服务器进程执行:</p>\n<ol>\n<li>执行客户端发来的指令</li>\n<li>将执行后的写命令追加到AOF缓冲区</li>\n<li>将执行后的写命令追加到AOF重写缓冲区</li>\n</ol>\n<p>当子进程完成AOF重写工作后,他会向父进程发送一个信号,父进程将执行:</p>\n<ol>\n<li>将AOF重写缓冲区中所有内容写入到新的AOF文件中,这时新的AOF文件所保存的内容就与当前的数据库状态一致</li>\n<li>对新的AOF文件进行改名,原子地覆盖现有的AOF文件,完成新旧AOF文件的替换</li>\n</ol>\n"},{"title":"《Redis设计与实现》-------复制","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第十五章--复制。","abbrlink":"2e019a64","date":"2020-09-25T16:00:00.000Z","_content":"\n# 简介\n\n被复制的服务器称为主服务器,对主服务器进行复制的服务器称为从服务器\n\n进行复制中的主从服务器双方的数据库将保存相同的数据\n\n# 旧版复制功能的实现\n\n## 同步\n\n用于将从服务器的数据库状态更新至当前所处的数据库状态\n\n## 命令传播\n\n用于在主服务器的数据库状态被修改,导致主从服务器的数据库状态出现不一致时,让主从服务器的数据库重新回到一致状态\n\n## 缺陷\n\n旧版复制功能在处理断线重复制情况时低效\n\n# 新版复制功能的实现\n\n1. 完整重同步:用于处理初次复制的情况,通过让主服务器创建并发送`RDB文件`,以及向从服务器发送保存在缓冲区里面的写命令进行同步\n2. 部分重同步:用于处理**断线后重复制**情况,当从服务器在断线后重新连接主服务器时,如果条件允许,主服务器可以将主从服务器断开期间执行的写命令发送给从服务器,从服务器只要接收并执行这些写命令,就可以将数据库更新至主服务器当前所处的状态\n\n# 部分重同步的实现\n\n1. 复制偏移量\n2. 复制积压缓冲区\n3. 服务器运行ID\n\n# 复制的实现\n\n## 步骤1:设置主服务器的地址和端口\n\n执行:`SLAVEOF 127.0.0.1 6379`\n\n```c\nstruct redisServer\n{\n\tchar * masterhost;//主服务器的地址\n\tint masterport;//主服务器的端口号\n};\n```\n\n## 步骤2:建立套接字连接\n\n如果从服务器创建的套接字能成功连接到主服务器,从服务器是主服务器的客户端,以从服务器向主服务器发送命令请求的形式来进行.\n\n## 步骤3:发送PING命令\n\n1. 检查套接字的读写状态是否正常\n2. 检查主服务器能否正常处理命令请求\n\n## 步骤4:身份验证\n\n## 步骤5:发送端口信息\n\n## 步骤6:同步\n\n从服务器将向主服务器发送`PSYNC命令`,执行同步操作,并将自己的数据库更新至主服务器数据库当前所处的状态\n\n## 步骤7:命令传播\n\n主服务器只要一直将自己执行的写命令发送给从服务器,而从服务器只要一直接收并执行主服务器发来的写命令,就可以保证主从服务器保持一致了\n\n\n\n# 心跳检测\n\n在命令传播阶段,从服务器默认以每秒一次的频率,向主服务器发送从服务器当前的复制偏移量,有三个作用:\n\n## 检测主从服务器的网络连接状态\n\n## 辅助实现min-slaves配置选项\n\n防止主服务器在不安全的情况下执行写命令\n\n## 检测命令丢失\n\n如果命令丢失,主服务器会发觉从服务器当前的复制偏移量少于自己的**复制偏移量**,然后主服务器就会通过从服务器提交的复制偏移量,在复制积压缓冲区里找到从服务器缺少的数据,并将这些数据重新发送给从服务器.","source":"_posts/Redis笔记/15.复制.md","raw":"---\ntitle: 《Redis设计与实现》-------复制\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第十五章--复制。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - 复制\n  - 数据库\nabbrlink: 2e019a64\ndate: 2020-09-26 00:00:00\n---\n\n# 简介\n\n被复制的服务器称为主服务器,对主服务器进行复制的服务器称为从服务器\n\n进行复制中的主从服务器双方的数据库将保存相同的数据\n\n# 旧版复制功能的实现\n\n## 同步\n\n用于将从服务器的数据库状态更新至当前所处的数据库状态\n\n## 命令传播\n\n用于在主服务器的数据库状态被修改,导致主从服务器的数据库状态出现不一致时,让主从服务器的数据库重新回到一致状态\n\n## 缺陷\n\n旧版复制功能在处理断线重复制情况时低效\n\n# 新版复制功能的实现\n\n1. 完整重同步:用于处理初次复制的情况,通过让主服务器创建并发送`RDB文件`,以及向从服务器发送保存在缓冲区里面的写命令进行同步\n2. 部分重同步:用于处理**断线后重复制**情况,当从服务器在断线后重新连接主服务器时,如果条件允许,主服务器可以将主从服务器断开期间执行的写命令发送给从服务器,从服务器只要接收并执行这些写命令,就可以将数据库更新至主服务器当前所处的状态\n\n# 部分重同步的实现\n\n1. 复制偏移量\n2. 复制积压缓冲区\n3. 服务器运行ID\n\n# 复制的实现\n\n## 步骤1:设置主服务器的地址和端口\n\n执行:`SLAVEOF 127.0.0.1 6379`\n\n```c\nstruct redisServer\n{\n\tchar * masterhost;//主服务器的地址\n\tint masterport;//主服务器的端口号\n};\n```\n\n## 步骤2:建立套接字连接\n\n如果从服务器创建的套接字能成功连接到主服务器,从服务器是主服务器的客户端,以从服务器向主服务器发送命令请求的形式来进行.\n\n## 步骤3:发送PING命令\n\n1. 检查套接字的读写状态是否正常\n2. 检查主服务器能否正常处理命令请求\n\n## 步骤4:身份验证\n\n## 步骤5:发送端口信息\n\n## 步骤6:同步\n\n从服务器将向主服务器发送`PSYNC命令`,执行同步操作,并将自己的数据库更新至主服务器数据库当前所处的状态\n\n## 步骤7:命令传播\n\n主服务器只要一直将自己执行的写命令发送给从服务器,而从服务器只要一直接收并执行主服务器发来的写命令,就可以保证主从服务器保持一致了\n\n\n\n# 心跳检测\n\n在命令传播阶段,从服务器默认以每秒一次的频率,向主服务器发送从服务器当前的复制偏移量,有三个作用:\n\n## 检测主从服务器的网络连接状态\n\n## 辅助实现min-slaves配置选项\n\n防止主服务器在不安全的情况下执行写命令\n\n## 检测命令丢失\n\n如果命令丢失,主服务器会发觉从服务器当前的复制偏移量少于自己的**复制偏移量**,然后主服务器就会通过从服务器提交的复制偏移量,在复制积压缓冲区里找到从服务器缺少的数据,并将这些数据重新发送给从服务器.","slug":"Redis笔记/15.复制","published":1,"updated":"2020-11-12T11:57:29.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wc001ijotpdjsugbnk","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>被复制的服务器称为主服务器,对主服务器进行复制的服务器称为从服务器</p>\n<p>进行复制中的主从服务器双方的数据库将保存相同的数据</p>\n<h1 id=\"旧版复制功能的实现\"><a href=\"#旧版复制功能的实现\" class=\"headerlink\" title=\"旧版复制功能的实现\"></a>旧版复制功能的实现</h1><h2 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h2><p>用于将从服务器的数据库状态更新至当前所处的数据库状态</p>\n<h2 id=\"命令传播\"><a href=\"#命令传播\" class=\"headerlink\" title=\"命令传播\"></a>命令传播</h2><p>用于在主服务器的数据库状态被修改,导致主从服务器的数据库状态出现不一致时,让主从服务器的数据库重新回到一致状态</p>\n<h2 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h2><p>旧版复制功能在处理断线重复制情况时低效</p>\n<h1 id=\"新版复制功能的实现\"><a href=\"#新版复制功能的实现\" class=\"headerlink\" title=\"新版复制功能的实现\"></a>新版复制功能的实现</h1><ol>\n<li>完整重同步:用于处理初次复制的情况,通过让主服务器创建并发送<code>RDB文件</code>,以及向从服务器发送保存在缓冲区里面的写命令进行同步</li>\n<li>部分重同步:用于处理<strong>断线后重复制</strong>情况,当从服务器在断线后重新连接主服务器时,如果条件允许,主服务器可以将主从服务器断开期间执行的写命令发送给从服务器,从服务器只要接收并执行这些写命令,就可以将数据库更新至主服务器当前所处的状态</li>\n</ol>\n<h1 id=\"部分重同步的实现\"><a href=\"#部分重同步的实现\" class=\"headerlink\" title=\"部分重同步的实现\"></a>部分重同步的实现</h1><ol>\n<li>复制偏移量</li>\n<li>复制积压缓冲区</li>\n<li>服务器运行ID</li>\n</ol>\n<h1 id=\"复制的实现\"><a href=\"#复制的实现\" class=\"headerlink\" title=\"复制的实现\"></a>复制的实现</h1><h2 id=\"步骤1-设置主服务器的地址和端口\"><a href=\"#步骤1-设置主服务器的地址和端口\" class=\"headerlink\" title=\"步骤1:设置主服务器的地址和端口\"></a>步骤1:设置主服务器的地址和端口</h2><p>执行:<code>SLAVEOF 127.0.0.1 6379</code></p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> redisServer\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> masterhost<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//主服务器的地址</span>\n    <span class=\"token keyword\">int</span> masterport<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//主服务器的端口号</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"步骤2-建立套接字连接\"><a href=\"#步骤2-建立套接字连接\" class=\"headerlink\" title=\"步骤2:建立套接字连接\"></a>步骤2:建立套接字连接</h2><p>如果从服务器创建的套接字能成功连接到主服务器,从服务器是主服务器的客户端,以从服务器向主服务器发送命令请求的形式来进行.</p>\n<h2 id=\"步骤3-发送PING命令\"><a href=\"#步骤3-发送PING命令\" class=\"headerlink\" title=\"步骤3:发送PING命令\"></a>步骤3:发送PING命令</h2><ol>\n<li>检查套接字的读写状态是否正常</li>\n<li>检查主服务器能否正常处理命令请求</li>\n</ol>\n<h2 id=\"步骤4-身份验证\"><a href=\"#步骤4-身份验证\" class=\"headerlink\" title=\"步骤4:身份验证\"></a>步骤4:身份验证</h2><h2 id=\"步骤5-发送端口信息\"><a href=\"#步骤5-发送端口信息\" class=\"headerlink\" title=\"步骤5:发送端口信息\"></a>步骤5:发送端口信息</h2><h2 id=\"步骤6-同步\"><a href=\"#步骤6-同步\" class=\"headerlink\" title=\"步骤6:同步\"></a>步骤6:同步</h2><p>从服务器将向主服务器发送<code>PSYNC命令</code>,执行同步操作,并将自己的数据库更新至主服务器数据库当前所处的状态</p>\n<h2 id=\"步骤7-命令传播\"><a href=\"#步骤7-命令传播\" class=\"headerlink\" title=\"步骤7:命令传播\"></a>步骤7:命令传播</h2><p>主服务器只要一直将自己执行的写命令发送给从服务器,而从服务器只要一直接收并执行主服务器发来的写命令,就可以保证主从服务器保持一致了</p>\n<h1 id=\"心跳检测\"><a href=\"#心跳检测\" class=\"headerlink\" title=\"心跳检测\"></a>心跳检测</h1><p>在命令传播阶段,从服务器默认以每秒一次的频率,向主服务器发送从服务器当前的复制偏移量,有三个作用:</p>\n<h2 id=\"检测主从服务器的网络连接状态\"><a href=\"#检测主从服务器的网络连接状态\" class=\"headerlink\" title=\"检测主从服务器的网络连接状态\"></a>检测主从服务器的网络连接状态</h2><h2 id=\"辅助实现min-slaves配置选项\"><a href=\"#辅助实现min-slaves配置选项\" class=\"headerlink\" title=\"辅助实现min-slaves配置选项\"></a>辅助实现min-slaves配置选项</h2><p>防止主服务器在不安全的情况下执行写命令</p>\n<h2 id=\"检测命令丢失\"><a href=\"#检测命令丢失\" class=\"headerlink\" title=\"检测命令丢失\"></a>检测命令丢失</h2><p>如果命令丢失,主服务器会发觉从服务器当前的复制偏移量少于自己的<strong>复制偏移量</strong>,然后主服务器就会通过从服务器提交的复制偏移量,在复制积压缓冲区里找到从服务器缺少的数据,并将这些数据重新发送给从服务器.</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>被复制的服务器称为主服务器,对主服务器进行复制的服务器称为从服务器</p>\n<p>进行复制中的主从服务器双方的数据库将保存相同的数据</p>\n<h1 id=\"旧版复制功能的实现\"><a href=\"#旧版复制功能的实现\" class=\"headerlink\" title=\"旧版复制功能的实现\"></a>旧版复制功能的实现</h1><h2 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h2><p>用于将从服务器的数据库状态更新至当前所处的数据库状态</p>\n<h2 id=\"命令传播\"><a href=\"#命令传播\" class=\"headerlink\" title=\"命令传播\"></a>命令传播</h2><p>用于在主服务器的数据库状态被修改,导致主从服务器的数据库状态出现不一致时,让主从服务器的数据库重新回到一致状态</p>\n<h2 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h2><p>旧版复制功能在处理断线重复制情况时低效</p>\n<h1 id=\"新版复制功能的实现\"><a href=\"#新版复制功能的实现\" class=\"headerlink\" title=\"新版复制功能的实现\"></a>新版复制功能的实现</h1><ol>\n<li>完整重同步:用于处理初次复制的情况,通过让主服务器创建并发送<code>RDB文件</code>,以及向从服务器发送保存在缓冲区里面的写命令进行同步</li>\n<li>部分重同步:用于处理<strong>断线后重复制</strong>情况,当从服务器在断线后重新连接主服务器时,如果条件允许,主服务器可以将主从服务器断开期间执行的写命令发送给从服务器,从服务器只要接收并执行这些写命令,就可以将数据库更新至主服务器当前所处的状态</li>\n</ol>\n<h1 id=\"部分重同步的实现\"><a href=\"#部分重同步的实现\" class=\"headerlink\" title=\"部分重同步的实现\"></a>部分重同步的实现</h1><ol>\n<li>复制偏移量</li>\n<li>复制积压缓冲区</li>\n<li>服务器运行ID</li>\n</ol>\n<h1 id=\"复制的实现\"><a href=\"#复制的实现\" class=\"headerlink\" title=\"复制的实现\"></a>复制的实现</h1><h2 id=\"步骤1-设置主服务器的地址和端口\"><a href=\"#步骤1-设置主服务器的地址和端口\" class=\"headerlink\" title=\"步骤1:设置主服务器的地址和端口\"></a>步骤1:设置主服务器的地址和端口</h2><p>执行:<code>SLAVEOF 127.0.0.1 6379</code></p>\n<pre><code class=\"c\">struct redisServer\n{\n    char * masterhost;//主服务器的地址\n    int masterport;//主服务器的端口号\n};</code></pre>\n<h2 id=\"步骤2-建立套接字连接\"><a href=\"#步骤2-建立套接字连接\" class=\"headerlink\" title=\"步骤2:建立套接字连接\"></a>步骤2:建立套接字连接</h2><p>如果从服务器创建的套接字能成功连接到主服务器,从服务器是主服务器的客户端,以从服务器向主服务器发送命令请求的形式来进行.</p>\n<h2 id=\"步骤3-发送PING命令\"><a href=\"#步骤3-发送PING命令\" class=\"headerlink\" title=\"步骤3:发送PING命令\"></a>步骤3:发送PING命令</h2><ol>\n<li>检查套接字的读写状态是否正常</li>\n<li>检查主服务器能否正常处理命令请求</li>\n</ol>\n<h2 id=\"步骤4-身份验证\"><a href=\"#步骤4-身份验证\" class=\"headerlink\" title=\"步骤4:身份验证\"></a>步骤4:身份验证</h2><h2 id=\"步骤5-发送端口信息\"><a href=\"#步骤5-发送端口信息\" class=\"headerlink\" title=\"步骤5:发送端口信息\"></a>步骤5:发送端口信息</h2><h2 id=\"步骤6-同步\"><a href=\"#步骤6-同步\" class=\"headerlink\" title=\"步骤6:同步\"></a>步骤6:同步</h2><p>从服务器将向主服务器发送<code>PSYNC命令</code>,执行同步操作,并将自己的数据库更新至主服务器数据库当前所处的状态</p>\n<h2 id=\"步骤7-命令传播\"><a href=\"#步骤7-命令传播\" class=\"headerlink\" title=\"步骤7:命令传播\"></a>步骤7:命令传播</h2><p>主服务器只要一直将自己执行的写命令发送给从服务器,而从服务器只要一直接收并执行主服务器发来的写命令,就可以保证主从服务器保持一致了</p>\n<h1 id=\"心跳检测\"><a href=\"#心跳检测\" class=\"headerlink\" title=\"心跳检测\"></a>心跳检测</h1><p>在命令传播阶段,从服务器默认以每秒一次的频率,向主服务器发送从服务器当前的复制偏移量,有三个作用:</p>\n<h2 id=\"检测主从服务器的网络连接状态\"><a href=\"#检测主从服务器的网络连接状态\" class=\"headerlink\" title=\"检测主从服务器的网络连接状态\"></a>检测主从服务器的网络连接状态</h2><h2 id=\"辅助实现min-slaves配置选项\"><a href=\"#辅助实现min-slaves配置选项\" class=\"headerlink\" title=\"辅助实现min-slaves配置选项\"></a>辅助实现min-slaves配置选项</h2><p>防止主服务器在不安全的情况下执行写命令</p>\n<h2 id=\"检测命令丢失\"><a href=\"#检测命令丢失\" class=\"headerlink\" title=\"检测命令丢失\"></a>检测命令丢失</h2><p>如果命令丢失,主服务器会发觉从服务器当前的复制偏移量少于自己的<strong>复制偏移量</strong>,然后主服务器就会通过从服务器提交的复制偏移量,在复制积压缓冲区里找到从服务器缺少的数据,并将这些数据重新发送给从服务器.</p>\n"},{"title":"《Redis设计与实现》-------简单字符串","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第二章--简单字符串。","abbrlink":"303ff37b","date":"2020-08-15T16:00:00.000Z","_content":"\n\n\n\n# SDS简介\n\n+ 使用**简单动态字符串**(simple dynamic string SDS)作为默认字符串\n+ c字符串只作为字符串字面量,用在无需对字符串值进行修改的地方\n+ 包含字符串值的键值对在底层都是用`SDS`实现的\n\n# SDS的定义\n\n```c\nstruct sdshdr\n{\n\tint len;//记录buf数组中已使用字节的数量 为字符串长度\n\tint free;//未使用的数量\n\tchar buf[];//字节数组,用来保存字符串\n}\n```\n\n1. `buf数组`以空字符结尾,且最后的空字符不算在len里面\n2. 该空字符由`SDS`函数自动完成,对`SDS`用户透明\n\n# SDS与C字符串的区别\n\n## 1.获取字符串长度所需复杂度从O(N)降低到​O(1)​\n\n## 2.杜绝了缓冲区溢出\n例如c进行字符串拼接,需要假设已经为字符串分配了足够的内存以容纳要拼接的字符串,否则就会溢出。\n**SDS空间分配策略**完全杜绝了发生缓冲区溢出的可能性.当要对SDS进行修改时,会先检查空间是否满足修改所需的要求,如果不满足,则会自动将**SDS的空间扩展**,然后再执行实际的修改操作\n\n## 减少修改字符串时带来的内存重分配次数\n\nC字符串底层实现总是一个`N+1`个字符长的数组,每次对该数组进行增加或缩短,总要进行一次**内存重分配**操作。如果是增长,则要内存重分配扩展底层数组的空间大小。如果是缩短，则执行操作后，需要内存重分配来释放空间，避免内存泄漏.\n\nRedis通过**未使用空间**解除了字符串长度和底层数组长度之间的关联\n\n### 空间预分配\n\n用于优化`SDS`的字符串增长操作，在扩展SDS空间之前，会先检查未使用的空间是否足够，如果足够，则直接使用未使用空间，无需进行内存重分配。\n\n在对一个SDS进行修改，并且需要对SDS进行空间扩展时，不仅为SDS分配修改所需要的空间，还会分配额外的未使用空间。\n\n如果修改后 `SDS.len < 1MB`,程序会分配给和len一样的长度给free\n\n如果修改后 `SDS.len >= 1MB`,程序会分配1MB给free\n\n### 惰性空间释放\n\n用于优化`SDS字符串`缩短操作：不立即回收缩短后多出来的字节，而是用`free`记录。避免了缩短字符串时所需的内存重分配操作，并且为将来可能的增长提供了优化\n\nAPI也让我们在需要时，真正释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费\n\n## 二进制安全\n\n1. C字符串并且符合特定的编码，并且除字符串的末尾外，不能包含空字符，使得他只能保存文本数据\n2. Redis以处理二进制的方式处理SDS存放在`buf数组`的数据，使用`len`而不是空字符判断字符串是否结束。所以他可以保存**任意格式**的二进制数据。\n\n## 兼容部分C字符串函数\n\nSDS保存数据的末尾总是为空字符，所以让那些保存文本数据的SDS可以重用一部分`<string.h>库`定义的函数\n\n\n\n","source":"_posts/Redis笔记/2.简单字符串.md","raw":"---\ntitle: 《Redis设计与实现》-------简单字符串\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第二章--简单字符串。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - 数据结构\n  - 字符串\nabbrlink: 303ff37b\ndate: 2020-08-16 00:00:00\n---\n\n\n\n\n# SDS简介\n\n+ 使用**简单动态字符串**(simple dynamic string SDS)作为默认字符串\n+ c字符串只作为字符串字面量,用在无需对字符串值进行修改的地方\n+ 包含字符串值的键值对在底层都是用`SDS`实现的\n\n# SDS的定义\n\n```c\nstruct sdshdr\n{\n\tint len;//记录buf数组中已使用字节的数量 为字符串长度\n\tint free;//未使用的数量\n\tchar buf[];//字节数组,用来保存字符串\n}\n```\n\n1. `buf数组`以空字符结尾,且最后的空字符不算在len里面\n2. 该空字符由`SDS`函数自动完成,对`SDS`用户透明\n\n# SDS与C字符串的区别\n\n## 1.获取字符串长度所需复杂度从O(N)降低到​O(1)​\n\n## 2.杜绝了缓冲区溢出\n例如c进行字符串拼接,需要假设已经为字符串分配了足够的内存以容纳要拼接的字符串,否则就会溢出。\n**SDS空间分配策略**完全杜绝了发生缓冲区溢出的可能性.当要对SDS进行修改时,会先检查空间是否满足修改所需的要求,如果不满足,则会自动将**SDS的空间扩展**,然后再执行实际的修改操作\n\n## 减少修改字符串时带来的内存重分配次数\n\nC字符串底层实现总是一个`N+1`个字符长的数组,每次对该数组进行增加或缩短,总要进行一次**内存重分配**操作。如果是增长,则要内存重分配扩展底层数组的空间大小。如果是缩短，则执行操作后，需要内存重分配来释放空间，避免内存泄漏.\n\nRedis通过**未使用空间**解除了字符串长度和底层数组长度之间的关联\n\n### 空间预分配\n\n用于优化`SDS`的字符串增长操作，在扩展SDS空间之前，会先检查未使用的空间是否足够，如果足够，则直接使用未使用空间，无需进行内存重分配。\n\n在对一个SDS进行修改，并且需要对SDS进行空间扩展时，不仅为SDS分配修改所需要的空间，还会分配额外的未使用空间。\n\n如果修改后 `SDS.len < 1MB`,程序会分配给和len一样的长度给free\n\n如果修改后 `SDS.len >= 1MB`,程序会分配1MB给free\n\n### 惰性空间释放\n\n用于优化`SDS字符串`缩短操作：不立即回收缩短后多出来的字节，而是用`free`记录。避免了缩短字符串时所需的内存重分配操作，并且为将来可能的增长提供了优化\n\nAPI也让我们在需要时，真正释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费\n\n## 二进制安全\n\n1. C字符串并且符合特定的编码，并且除字符串的末尾外，不能包含空字符，使得他只能保存文本数据\n2. Redis以处理二进制的方式处理SDS存放在`buf数组`的数据，使用`len`而不是空字符判断字符串是否结束。所以他可以保存**任意格式**的二进制数据。\n\n## 兼容部分C字符串函数\n\nSDS保存数据的末尾总是为空字符，所以让那些保存文本数据的SDS可以重用一部分`<string.h>库`定义的函数\n\n\n\n","slug":"Redis笔记/2.简单字符串","published":1,"updated":"2020-11-12T11:57:29.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wd001ljotpfu098kwl","content":"<h1 id=\"SDS简介\"><a href=\"#SDS简介\" class=\"headerlink\" title=\"SDS简介\"></a>SDS简介</h1><ul>\n<li>使用<strong>简单动态字符串</strong>(simple dynamic string SDS)作为默认字符串</li>\n<li>c字符串只作为字符串字面量,用在无需对字符串值进行修改的地方</li>\n<li>包含字符串值的键值对在底层都是用<code>SDS</code>实现的</li>\n</ul>\n<h1 id=\"SDS的定义\"><a href=\"#SDS的定义\" class=\"headerlink\" title=\"SDS的定义\"></a>SDS的定义</h1><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> sdshdr\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//记录buf数组中已使用字节的数量 为字符串长度</span>\n    <span class=\"token keyword\">int</span> free<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//未使用的数量</span>\n    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//字节数组,用来保存字符串</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ol>\n<li><code>buf数组</code>以空字符结尾,且最后的空字符不算在len里面</li>\n<li>该空字符由<code>SDS</code>函数自动完成,对<code>SDS</code>用户透明</li>\n</ol>\n<h1 id=\"SDS与C字符串的区别\"><a href=\"#SDS与C字符串的区别\" class=\"headerlink\" title=\"SDS与C字符串的区别\"></a>SDS与C字符串的区别</h1><h2 id=\"1-获取字符串长度所需复杂度从O-N-降低到​O-1-​\"><a href=\"#1-获取字符串长度所需复杂度从O-N-降低到​O-1-​\" class=\"headerlink\" title=\"1.获取字符串长度所需复杂度从O(N)降低到​O(1)​\"></a>1.获取字符串长度所需复杂度从O(N)降低到​O(1)​</h2><h2 id=\"2-杜绝了缓冲区溢出\"><a href=\"#2-杜绝了缓冲区溢出\" class=\"headerlink\" title=\"2.杜绝了缓冲区溢出\"></a>2.杜绝了缓冲区溢出</h2><p>例如c进行字符串拼接,需要假设已经为字符串分配了足够的内存以容纳要拼接的字符串,否则就会溢出。<br><strong>SDS空间分配策略</strong>完全杜绝了发生缓冲区溢出的可能性.当要对SDS进行修改时,会先检查空间是否满足修改所需的要求,如果不满足,则会自动将<strong>SDS的空间扩展</strong>,然后再执行实际的修改操作</p>\n<h2 id=\"减少修改字符串时带来的内存重分配次数\"><a href=\"#减少修改字符串时带来的内存重分配次数\" class=\"headerlink\" title=\"减少修改字符串时带来的内存重分配次数\"></a>减少修改字符串时带来的内存重分配次数</h2><p>C字符串底层实现总是一个<code>N+1</code>个字符长的数组,每次对该数组进行增加或缩短,总要进行一次<strong>内存重分配</strong>操作。如果是增长,则要内存重分配扩展底层数组的空间大小。如果是缩短，则执行操作后，需要内存重分配来释放空间，避免内存泄漏.</p>\n<p>Redis通过<strong>未使用空间</strong>解除了字符串长度和底层数组长度之间的关联</p>\n<h3 id=\"空间预分配\"><a href=\"#空间预分配\" class=\"headerlink\" title=\"空间预分配\"></a>空间预分配</h3><p>用于优化<code>SDS</code>的字符串增长操作，在扩展SDS空间之前，会先检查未使用的空间是否足够，如果足够，则直接使用未使用空间，无需进行内存重分配。</p>\n<p>在对一个SDS进行修改，并且需要对SDS进行空间扩展时，不仅为SDS分配修改所需要的空间，还会分配额外的未使用空间。</p>\n<p>如果修改后 <code>SDS.len &lt; 1MB</code>,程序会分配给和len一样的长度给free</p>\n<p>如果修改后 <code>SDS.len &gt;= 1MB</code>,程序会分配1MB给free</p>\n<h3 id=\"惰性空间释放\"><a href=\"#惰性空间释放\" class=\"headerlink\" title=\"惰性空间释放\"></a>惰性空间释放</h3><p>用于优化<code>SDS字符串</code>缩短操作：不立即回收缩短后多出来的字节，而是用<code>free</code>记录。避免了缩短字符串时所需的内存重分配操作，并且为将来可能的增长提供了优化</p>\n<p>API也让我们在需要时，真正释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费</p>\n<h2 id=\"二进制安全\"><a href=\"#二进制安全\" class=\"headerlink\" title=\"二进制安全\"></a>二进制安全</h2><ol>\n<li>C字符串并且符合特定的编码，并且除字符串的末尾外，不能包含空字符，使得他只能保存文本数据</li>\n<li>Redis以处理二进制的方式处理SDS存放在<code>buf数组</code>的数据，使用<code>len</code>而不是空字符判断字符串是否结束。所以他可以保存<strong>任意格式</strong>的二进制数据。</li>\n</ol>\n<h2 id=\"兼容部分C字符串函数\"><a href=\"#兼容部分C字符串函数\" class=\"headerlink\" title=\"兼容部分C字符串函数\"></a>兼容部分C字符串函数</h2><p>SDS保存数据的末尾总是为空字符，所以让那些保存文本数据的SDS可以重用一部分<code>&lt;string.h&gt;库</code>定义的函数</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"SDS简介\"><a href=\"#SDS简介\" class=\"headerlink\" title=\"SDS简介\"></a>SDS简介</h1><ul>\n<li>使用<strong>简单动态字符串</strong>(simple dynamic string SDS)作为默认字符串</li>\n<li>c字符串只作为字符串字面量,用在无需对字符串值进行修改的地方</li>\n<li>包含字符串值的键值对在底层都是用<code>SDS</code>实现的</li>\n</ul>\n<h1 id=\"SDS的定义\"><a href=\"#SDS的定义\" class=\"headerlink\" title=\"SDS的定义\"></a>SDS的定义</h1><pre><code class=\"c\">struct sdshdr\n{\n    int len;//记录buf数组中已使用字节的数量 为字符串长度\n    int free;//未使用的数量\n    char buf[];//字节数组,用来保存字符串\n}</code></pre>\n<ol>\n<li><code>buf数组</code>以空字符结尾,且最后的空字符不算在len里面</li>\n<li>该空字符由<code>SDS</code>函数自动完成,对<code>SDS</code>用户透明</li>\n</ol>\n<h1 id=\"SDS与C字符串的区别\"><a href=\"#SDS与C字符串的区别\" class=\"headerlink\" title=\"SDS与C字符串的区别\"></a>SDS与C字符串的区别</h1><h2 id=\"1-获取字符串长度所需复杂度从O-N-降低到​O-1-​\"><a href=\"#1-获取字符串长度所需复杂度从O-N-降低到​O-1-​\" class=\"headerlink\" title=\"1.获取字符串长度所需复杂度从O(N)降低到​O(1)​\"></a>1.获取字符串长度所需复杂度从O(N)降低到​O(1)​</h2><h2 id=\"2-杜绝了缓冲区溢出\"><a href=\"#2-杜绝了缓冲区溢出\" class=\"headerlink\" title=\"2.杜绝了缓冲区溢出\"></a>2.杜绝了缓冲区溢出</h2><p>例如c进行字符串拼接,需要假设已经为字符串分配了足够的内存以容纳要拼接的字符串,否则就会溢出。<br><strong>SDS空间分配策略</strong>完全杜绝了发生缓冲区溢出的可能性.当要对SDS进行修改时,会先检查空间是否满足修改所需的要求,如果不满足,则会自动将<strong>SDS的空间扩展</strong>,然后再执行实际的修改操作</p>\n<h2 id=\"减少修改字符串时带来的内存重分配次数\"><a href=\"#减少修改字符串时带来的内存重分配次数\" class=\"headerlink\" title=\"减少修改字符串时带来的内存重分配次数\"></a>减少修改字符串时带来的内存重分配次数</h2><p>C字符串底层实现总是一个<code>N+1</code>个字符长的数组,每次对该数组进行增加或缩短,总要进行一次<strong>内存重分配</strong>操作。如果是增长,则要内存重分配扩展底层数组的空间大小。如果是缩短，则执行操作后，需要内存重分配来释放空间，避免内存泄漏.</p>\n<p>Redis通过<strong>未使用空间</strong>解除了字符串长度和底层数组长度之间的关联</p>\n<h3 id=\"空间预分配\"><a href=\"#空间预分配\" class=\"headerlink\" title=\"空间预分配\"></a>空间预分配</h3><p>用于优化<code>SDS</code>的字符串增长操作，在扩展SDS空间之前，会先检查未使用的空间是否足够，如果足够，则直接使用未使用空间，无需进行内存重分配。</p>\n<p>在对一个SDS进行修改，并且需要对SDS进行空间扩展时，不仅为SDS分配修改所需要的空间，还会分配额外的未使用空间。</p>\n<p>如果修改后 <code>SDS.len &lt; 1MB</code>,程序会分配给和len一样的长度给free</p>\n<p>如果修改后 <code>SDS.len &gt;= 1MB</code>,程序会分配1MB给free</p>\n<h3 id=\"惰性空间释放\"><a href=\"#惰性空间释放\" class=\"headerlink\" title=\"惰性空间释放\"></a>惰性空间释放</h3><p>用于优化<code>SDS字符串</code>缩短操作：不立即回收缩短后多出来的字节，而是用<code>free</code>记录。避免了缩短字符串时所需的内存重分配操作，并且为将来可能的增长提供了优化</p>\n<p>API也让我们在需要时，真正释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费</p>\n<h2 id=\"二进制安全\"><a href=\"#二进制安全\" class=\"headerlink\" title=\"二进制安全\"></a>二进制安全</h2><ol>\n<li>C字符串并且符合特定的编码，并且除字符串的末尾外，不能包含空字符，使得他只能保存文本数据</li>\n<li>Redis以处理二进制的方式处理SDS存放在<code>buf数组</code>的数据，使用<code>len</code>而不是空字符判断字符串是否结束。所以他可以保存<strong>任意格式</strong>的二进制数据。</li>\n</ol>\n<h2 id=\"兼容部分C字符串函数\"><a href=\"#兼容部分C字符串函数\" class=\"headerlink\" title=\"兼容部分C字符串函数\"></a>兼容部分C字符串函数</h2><p>SDS保存数据的末尾总是为空字符，所以让那些保存文本数据的SDS可以重用一部分<code>&lt;string.h&gt;库</code>定义的函数</p>\n"},{"title":"《Redis设计与实现》-------字典","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第四章--字典。","abbrlink":"4ea31ca4","date":"2020-08-17T16:00:00.000Z","_content":"\n# 简介\n\n`Redis`的数据库底层就是用字典实现的\n\n字典也是**哈希键**的底层实现之一\n\n# 字典的实现\n\n字典采用哈希表作为底层实现,一个哈希表可以有多个哈希表节点,每个节点保存了一个键值对\n\n每个字典带有**两个哈希表**,一个平时使用,一个仅仅在rehash时使用\n\n## 哈希表\n\n```c\ntypedef struct dictht\n{\n\tdictEntry ** table;//哈希表数组\n\tunsigned long size;\n\tunsigned long sizemask;//哈希表大小掩码,用于计算索引值 总=size-1\n\tunsigned long used;\n}dictht;\n```\n\n`sizemask`和哈希值一起决定一个键应该放到table数组里面的哪个索引上\n\n## 哈希表节点\n\n```c\ntypedef struct dictEntry\n{\n\tvoid *key;\n\tunion\n\t{\n\t\tvoid *val;\n\t\tuint64_t u64;\n\t\tint64_t s64;\n\t} v;\n\tstruct dictEntry * next; \n}dictEntry;\n```\n\n值可以是应该指针,或者是应该uint64_t类型的整数,或是一个int64_t整数\n\nnext属性指向另一个哈希表节点的指针,可以将多个哈希值相同的键值对连接在一起,以解决键冲突\n\n## 字典\n\n```c\ntypedef struct dict\n{\n\tdicType * type;//类型特定函数\n\tvoid * privdata;//私有数据\n\tditcht ht[2];//哈希表\n\t\n\tint rehashidx;//rehash索引,当rehash不再进行时,值为-1\n}dict;\n```\n\n1. `type`,`privdata`属性是针对不同类型的键值对,为创建多态字典而设置的\n2. 每个`dicType`结构保存了一簇用于操作特定类型键值对的函数\n3. `privdata`属性保存了需要传给那些类型特定函数的可选参数\n4. ht数组中,每个项都是**ditcht哈希表**,一般只使用`ht[0]`,ht[1]只会在ht[0]进行rehash时使用\n5. `rehashidx`记录rehash目前的进度\n\n# 哈希算法\n\n程序先通过键计算哈希值hash,在计算索引值(`index=hash & sizemask`),再根据索引将包含新键值对的哈希表节点放到哈希表数组的指定索引上\n\n# 解决键冲突\n\n用链地址法,多个分配到同一个索引的节点用单向链表连接起来。且用头插法，将新节点添加到链表的表头位置 \n\n# rehash\n\n## 时机\n\n1. 若没有在执行`BGSAVE`或`BGREWRITEAOF`命令,则哈希表负载因子>=1时rehash\n2. 若在执行BGSAVE或BGREWRITEAOF命令,则哈希表负载因子>=5时rehash\n3. `load_factor=ht[0].used / ht[0].size`\n4. 以上的不同是因为,执行那两个命令时,Redis需要创建当前服务器进程的**子进程**,在子进程存在期间,服务器会提高执行扩展操作所需的负载因子,从而京可能避免在子进程存在期间进行哈希表的扩展操作,可以避免不必要的内存写入操作,最大限度地节约内存\n5. 当负载因子<0.1,则自动进行收缩操作\n\n## 步骤\n\n1. 为字典的ht[1]哈希表分配空间:如果是扩展,则ht[1]大小为第一个>= `ht[0].used*2` 的2^n​。如果是收缩，则是第一个>= `ht[0].used` 的2^n​。\n2. 将保存在ht[0]的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后放到ht[1]的指定位置上\n3. 当ht[0]所有的键值对都迁移到了ht[1]，则将ht[1]设置为ht[0]，并且在ht[1]新建一个空哈希表\n\n# 渐进式rehash\n\n1. rehash时，服务器不是一次就将ht[0]里面的所有键值对全部rehash到ht[1]。而是分多次，**渐进式**地将ht[0]里面的键值对慢慢地`rehash`到ht[1]\n2. 在执行操作之外，顺带将键值对rehash到ht[1]中，把rehash键值对所需的计算工作均摊到每次对字典的增删改查操作之中\n3. 在进行渐进式rehash时，字典**同时**使用ht[0]，ht[1]。所以操作同时在两个哈希表中进行，即如果要查找一个键，会先在ht[0]找，没找到就继续到ht[1]中找\n4. 新添加的键值对直接保存到ht[1]中","source":"_posts/Redis笔记/4.字典.md","raw":"---\ntitle: 《Redis设计与实现》-------字典\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第四章--字典。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - 数据结构\n  - 字典\nabbrlink: 4ea31ca4\ndate: 2020-08-18 00:00:00\n---\n\n# 简介\n\n`Redis`的数据库底层就是用字典实现的\n\n字典也是**哈希键**的底层实现之一\n\n# 字典的实现\n\n字典采用哈希表作为底层实现,一个哈希表可以有多个哈希表节点,每个节点保存了一个键值对\n\n每个字典带有**两个哈希表**,一个平时使用,一个仅仅在rehash时使用\n\n## 哈希表\n\n```c\ntypedef struct dictht\n{\n\tdictEntry ** table;//哈希表数组\n\tunsigned long size;\n\tunsigned long sizemask;//哈希表大小掩码,用于计算索引值 总=size-1\n\tunsigned long used;\n}dictht;\n```\n\n`sizemask`和哈希值一起决定一个键应该放到table数组里面的哪个索引上\n\n## 哈希表节点\n\n```c\ntypedef struct dictEntry\n{\n\tvoid *key;\n\tunion\n\t{\n\t\tvoid *val;\n\t\tuint64_t u64;\n\t\tint64_t s64;\n\t} v;\n\tstruct dictEntry * next; \n}dictEntry;\n```\n\n值可以是应该指针,或者是应该uint64_t类型的整数,或是一个int64_t整数\n\nnext属性指向另一个哈希表节点的指针,可以将多个哈希值相同的键值对连接在一起,以解决键冲突\n\n## 字典\n\n```c\ntypedef struct dict\n{\n\tdicType * type;//类型特定函数\n\tvoid * privdata;//私有数据\n\tditcht ht[2];//哈希表\n\t\n\tint rehashidx;//rehash索引,当rehash不再进行时,值为-1\n}dict;\n```\n\n1. `type`,`privdata`属性是针对不同类型的键值对,为创建多态字典而设置的\n2. 每个`dicType`结构保存了一簇用于操作特定类型键值对的函数\n3. `privdata`属性保存了需要传给那些类型特定函数的可选参数\n4. ht数组中,每个项都是**ditcht哈希表**,一般只使用`ht[0]`,ht[1]只会在ht[0]进行rehash时使用\n5. `rehashidx`记录rehash目前的进度\n\n# 哈希算法\n\n程序先通过键计算哈希值hash,在计算索引值(`index=hash & sizemask`),再根据索引将包含新键值对的哈希表节点放到哈希表数组的指定索引上\n\n# 解决键冲突\n\n用链地址法,多个分配到同一个索引的节点用单向链表连接起来。且用头插法，将新节点添加到链表的表头位置 \n\n# rehash\n\n## 时机\n\n1. 若没有在执行`BGSAVE`或`BGREWRITEAOF`命令,则哈希表负载因子>=1时rehash\n2. 若在执行BGSAVE或BGREWRITEAOF命令,则哈希表负载因子>=5时rehash\n3. `load_factor=ht[0].used / ht[0].size`\n4. 以上的不同是因为,执行那两个命令时,Redis需要创建当前服务器进程的**子进程**,在子进程存在期间,服务器会提高执行扩展操作所需的负载因子,从而京可能避免在子进程存在期间进行哈希表的扩展操作,可以避免不必要的内存写入操作,最大限度地节约内存\n5. 当负载因子<0.1,则自动进行收缩操作\n\n## 步骤\n\n1. 为字典的ht[1]哈希表分配空间:如果是扩展,则ht[1]大小为第一个>= `ht[0].used*2` 的2^n​。如果是收缩，则是第一个>= `ht[0].used` 的2^n​。\n2. 将保存在ht[0]的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后放到ht[1]的指定位置上\n3. 当ht[0]所有的键值对都迁移到了ht[1]，则将ht[1]设置为ht[0]，并且在ht[1]新建一个空哈希表\n\n# 渐进式rehash\n\n1. rehash时，服务器不是一次就将ht[0]里面的所有键值对全部rehash到ht[1]。而是分多次，**渐进式**地将ht[0]里面的键值对慢慢地`rehash`到ht[1]\n2. 在执行操作之外，顺带将键值对rehash到ht[1]中，把rehash键值对所需的计算工作均摊到每次对字典的增删改查操作之中\n3. 在进行渐进式rehash时，字典**同时**使用ht[0]，ht[1]。所以操作同时在两个哈希表中进行，即如果要查找一个键，会先在ht[0]找，没找到就继续到ht[1]中找\n4. 新添加的键值对直接保存到ht[1]中","slug":"Redis笔记/4.字典","published":1,"updated":"2020-11-12T11:57:29.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wg001pjotp6tv8auya","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><code>Redis</code>的数据库底层就是用字典实现的</p>\n<p>字典也是<strong>哈希键</strong>的底层实现之一</p>\n<h1 id=\"字典的实现\"><a href=\"#字典的实现\" class=\"headerlink\" title=\"字典的实现\"></a>字典的实现</h1><p>字典采用哈希表作为底层实现,一个哈希表可以有多个哈希表节点,每个节点保存了一个键值对</p>\n<p>每个字典带有<strong>两个哈希表</strong>,一个平时使用,一个仅仅在rehash时使用</p>\n<h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> dictht\n<span class=\"token punctuation\">{</span>\n    dictEntry <span class=\"token operator\">*</span><span class=\"token operator\">*</span> table<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//哈希表数组</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> size<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> sizemask<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//哈希表大小掩码,用于计算索引值 总=size-1</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> used<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>dictht<span class=\"token punctuation\">;</span></code></pre>\n<p><code>sizemask</code>和哈希值一起决定一个键应该放到table数组里面的哪个索引上</p>\n<h2 id=\"哈希表节点\"><a href=\"#哈希表节点\" class=\"headerlink\" title=\"哈希表节点\"></a>哈希表节点</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> dictEntry\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>key<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">union</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>val<span class=\"token punctuation\">;</span>\n        uint64_t u64<span class=\"token punctuation\">;</span>\n        int64_t s64<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> v<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> dictEntry <span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>dictEntry<span class=\"token punctuation\">;</span></code></pre>\n<p>值可以是应该指针,或者是应该uint64_t类型的整数,或是一个int64_t整数</p>\n<p>next属性指向另一个哈希表节点的指针,可以将多个哈希值相同的键值对连接在一起,以解决键冲突</p>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> dict\n<span class=\"token punctuation\">{</span>\n    dicType <span class=\"token operator\">*</span> type<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//类型特定函数</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> privdata<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//私有数据</span>\n    ditcht ht<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//哈希表</span>\n\n    <span class=\"token keyword\">int</span> rehashidx<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//rehash索引,当rehash不再进行时,值为-1</span>\n<span class=\"token punctuation\">}</span>dict<span class=\"token punctuation\">;</span></code></pre>\n<ol>\n<li><code>type</code>,<code>privdata</code>属性是针对不同类型的键值对,为创建多态字典而设置的</li>\n<li>每个<code>dicType</code>结构保存了一簇用于操作特定类型键值对的函数</li>\n<li><code>privdata</code>属性保存了需要传给那些类型特定函数的可选参数</li>\n<li>ht数组中,每个项都是<strong>ditcht哈希表</strong>,一般只使用<code>ht[0]</code>,ht[1]只会在ht[0]进行rehash时使用</li>\n<li><code>rehashidx</code>记录rehash目前的进度</li>\n</ol>\n<h1 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h1><p>程序先通过键计算哈希值hash,在计算索引值(<code>index=hash &amp; sizemask</code>),再根据索引将包含新键值对的哈希表节点放到哈希表数组的指定索引上</p>\n<h1 id=\"解决键冲突\"><a href=\"#解决键冲突\" class=\"headerlink\" title=\"解决键冲突\"></a>解决键冲突</h1><p>用链地址法,多个分配到同一个索引的节点用单向链表连接起来。且用头插法，将新节点添加到链表的表头位置 </p>\n<h1 id=\"rehash\"><a href=\"#rehash\" class=\"headerlink\" title=\"rehash\"></a>rehash</h1><h2 id=\"时机\"><a href=\"#时机\" class=\"headerlink\" title=\"时机\"></a>时机</h2><ol>\n<li>若没有在执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>命令,则哈希表负载因子&gt;=1时rehash</li>\n<li>若在执行BGSAVE或BGREWRITEAOF命令,则哈希表负载因子&gt;=5时rehash</li>\n<li><code>load_factor=ht[0].used / ht[0].size</code></li>\n<li>以上的不同是因为,执行那两个命令时,Redis需要创建当前服务器进程的<strong>子进程</strong>,在子进程存在期间,服务器会提高执行扩展操作所需的负载因子,从而京可能避免在子进程存在期间进行哈希表的扩展操作,可以避免不必要的内存写入操作,最大限度地节约内存</li>\n<li>当负载因子&lt;0.1,则自动进行收缩操作</li>\n</ol>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li>为字典的ht[1]哈希表分配空间:如果是扩展,则ht[1]大小为第一个&gt;= <code>ht[0].used*2</code> 的2^n​。如果是收缩，则是第一个&gt;= <code>ht[0].used</code> 的2^n​。</li>\n<li>将保存在ht[0]的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后放到ht[1]的指定位置上</li>\n<li>当ht[0]所有的键值对都迁移到了ht[1]，则将ht[1]设置为ht[0]，并且在ht[1]新建一个空哈希表</li>\n</ol>\n<h1 id=\"渐进式rehash\"><a href=\"#渐进式rehash\" class=\"headerlink\" title=\"渐进式rehash\"></a>渐进式rehash</h1><ol>\n<li>rehash时，服务器不是一次就将ht[0]里面的所有键值对全部rehash到ht[1]。而是分多次，<strong>渐进式</strong>地将ht[0]里面的键值对慢慢地<code>rehash</code>到ht[1]</li>\n<li>在执行操作之外，顺带将键值对rehash到ht[1]中，把rehash键值对所需的计算工作均摊到每次对字典的增删改查操作之中</li>\n<li>在进行渐进式rehash时，字典<strong>同时</strong>使用ht[0]，ht[1]。所以操作同时在两个哈希表中进行，即如果要查找一个键，会先在ht[0]找，没找到就继续到ht[1]中找</li>\n<li>新添加的键值对直接保存到ht[1]中</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><code>Redis</code>的数据库底层就是用字典实现的</p>\n<p>字典也是<strong>哈希键</strong>的底层实现之一</p>\n<h1 id=\"字典的实现\"><a href=\"#字典的实现\" class=\"headerlink\" title=\"字典的实现\"></a>字典的实现</h1><p>字典采用哈希表作为底层实现,一个哈希表可以有多个哈希表节点,每个节点保存了一个键值对</p>\n<p>每个字典带有<strong>两个哈希表</strong>,一个平时使用,一个仅仅在rehash时使用</p>\n<h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><pre><code class=\"c\">typedef struct dictht\n{\n    dictEntry ** table;//哈希表数组\n    unsigned long size;\n    unsigned long sizemask;//哈希表大小掩码,用于计算索引值 总=size-1\n    unsigned long used;\n}dictht;</code></pre>\n<p><code>sizemask</code>和哈希值一起决定一个键应该放到table数组里面的哪个索引上</p>\n<h2 id=\"哈希表节点\"><a href=\"#哈希表节点\" class=\"headerlink\" title=\"哈希表节点\"></a>哈希表节点</h2><pre><code class=\"c\">typedef struct dictEntry\n{\n    void *key;\n    union\n    {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n    struct dictEntry * next; \n}dictEntry;</code></pre>\n<p>值可以是应该指针,或者是应该uint64_t类型的整数,或是一个int64_t整数</p>\n<p>next属性指向另一个哈希表节点的指针,可以将多个哈希值相同的键值对连接在一起,以解决键冲突</p>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><pre><code class=\"c\">typedef struct dict\n{\n    dicType * type;//类型特定函数\n    void * privdata;//私有数据\n    ditcht ht[2];//哈希表\n\n    int rehashidx;//rehash索引,当rehash不再进行时,值为-1\n}dict;</code></pre>\n<ol>\n<li><code>type</code>,<code>privdata</code>属性是针对不同类型的键值对,为创建多态字典而设置的</li>\n<li>每个<code>dicType</code>结构保存了一簇用于操作特定类型键值对的函数</li>\n<li><code>privdata</code>属性保存了需要传给那些类型特定函数的可选参数</li>\n<li>ht数组中,每个项都是<strong>ditcht哈希表</strong>,一般只使用<code>ht[0]</code>,ht[1]只会在ht[0]进行rehash时使用</li>\n<li><code>rehashidx</code>记录rehash目前的进度</li>\n</ol>\n<h1 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h1><p>程序先通过键计算哈希值hash,在计算索引值(<code>index=hash &amp; sizemask</code>),再根据索引将包含新键值对的哈希表节点放到哈希表数组的指定索引上</p>\n<h1 id=\"解决键冲突\"><a href=\"#解决键冲突\" class=\"headerlink\" title=\"解决键冲突\"></a>解决键冲突</h1><p>用链地址法,多个分配到同一个索引的节点用单向链表连接起来。且用头插法，将新节点添加到链表的表头位置 </p>\n<h1 id=\"rehash\"><a href=\"#rehash\" class=\"headerlink\" title=\"rehash\"></a>rehash</h1><h2 id=\"时机\"><a href=\"#时机\" class=\"headerlink\" title=\"时机\"></a>时机</h2><ol>\n<li>若没有在执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>命令,则哈希表负载因子&gt;=1时rehash</li>\n<li>若在执行BGSAVE或BGREWRITEAOF命令,则哈希表负载因子&gt;=5时rehash</li>\n<li><code>load_factor=ht[0].used / ht[0].size</code></li>\n<li>以上的不同是因为,执行那两个命令时,Redis需要创建当前服务器进程的<strong>子进程</strong>,在子进程存在期间,服务器会提高执行扩展操作所需的负载因子,从而京可能避免在子进程存在期间进行哈希表的扩展操作,可以避免不必要的内存写入操作,最大限度地节约内存</li>\n<li>当负载因子&lt;0.1,则自动进行收缩操作</li>\n</ol>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li>为字典的ht[1]哈希表分配空间:如果是扩展,则ht[1]大小为第一个&gt;= <code>ht[0].used*2</code> 的2^n​。如果是收缩，则是第一个&gt;= <code>ht[0].used</code> 的2^n​。</li>\n<li>将保存在ht[0]的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后放到ht[1]的指定位置上</li>\n<li>当ht[0]所有的键值对都迁移到了ht[1]，则将ht[1]设置为ht[0]，并且在ht[1]新建一个空哈希表</li>\n</ol>\n<h1 id=\"渐进式rehash\"><a href=\"#渐进式rehash\" class=\"headerlink\" title=\"渐进式rehash\"></a>渐进式rehash</h1><ol>\n<li>rehash时，服务器不是一次就将ht[0]里面的所有键值对全部rehash到ht[1]。而是分多次，<strong>渐进式</strong>地将ht[0]里面的键值对慢慢地<code>rehash</code>到ht[1]</li>\n<li>在执行操作之外，顺带将键值对rehash到ht[1]中，把rehash键值对所需的计算工作均摊到每次对字典的增删改查操作之中</li>\n<li>在进行渐进式rehash时，字典<strong>同时</strong>使用ht[0]，ht[1]。所以操作同时在两个哈希表中进行，即如果要查找一个键，会先在ht[0]找，没找到就继续到ht[1]中找</li>\n<li>新添加的键值对直接保存到ht[1]中</li>\n</ol>\n"},{"title":"《Redis设计与实现》------Sentinel","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":"flase","mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第十六章--Sentinel。","abbrlink":"b89933c6","date":"2020-09-27T16:00:00.000Z","_content":"\n# Sentinel简介\n\n`Sentinel`(哨兵)是Redis的高可用性解决方案:由一个或多个`Sentinel`实例组成的Sentinel系统可以监视任意多个主服务器,以及这些主服务器属下的所有从服务器,并在被监视的主服务器进入下线状态时,自动将下线主服务器属下的某个从服务器升级为新的主服务器,然后由新的主服务器代替已下线的主服务器继续处理命令请求。\n\n# 启动并初始化Sentinel\n\n启动`Sentinel`会执行以下操作：\n\n1. 初始化服务器\n2. 将普通Redis服务器使用的代码替换成`Sentinel`专用代码\n3. 初始化`Sentinel`状态\n4. 根据给定的配置文件,初始化`Sentinel`的监视主服务器列表\n5. 创建连向主服务器的网络连接\n\n## 初始化Sentinel状态的masters属性\n\n`dict * masters;`保存了所有被这个Sentinel监视的主服务器\n\n`masters`字典键是监视主服务器的名字,值是被监视主服务器对应的`sentinelRedisInstance`结构\n\n每个`sentinelRedisInstance`结构代表了一个被sentinel监视的Redis服务器实例,这个实例可以是主服务器,从服务器或者另外一个`Sentinel`\n\n```c\ntypedef struct sentinelRedisInstance\n{\n\tint flags;//标识值,记录了实例的类型,以及该实例的当前状态\n\t\n\t//实例的名字\n\t//主服务器的名字由用户在配置文件中设置\n\t//从服务器以及Sentinel的名字由Sentinel自动设置\n\t//格式为ip:port,例如\"127.0.0.1:26379\"\n\tchar * name;\n\t\n\t//实例的运行ID\n\tchar * runid;\n\t\n\t//配置纪元,用于实现故障转移\n\tuint64_t config_epoch;\n\t\n\tsentinelAddr * addr; //实例的地址\n\t\n\tmstime_t down_after_period;//实例无响应多少毫秒后才会被认为是主观下线\n\tint quorum;//判断这个实例为客观下线所需的支持投票数量\n\tint parallel_syncs;//在执行故障转移操作时,可以同时对新的主服务器进行同步的从服务器数量\n\tmstime_t failover_timeout;//刷新故障迁移状态的最大时限\n}\n```\n\n```c\nstruct sentinelAddr\n{\n\tchar * ip;\n\tint port;\n}\n```\n\n## 获取主服务器的信息\n\n`Sentinel`默认会以每10秒一次的频率,通过命令连接向被监视的主服务器发送INFO命令\n\n对于主服务器返回的从服务器信息,会被用于更新主服务器实例结构的`slavers`字典,该字典记录了主服务器属下从服务器的名单\n\n# 获取从服务器信息\n\n当`Sentinel`发现主服务器有新的从服务器出现时,除了会为这个新的从服务器创建相应的实例结构外,还会创建连接到从服务器的命令连接和订阅连接\n\n# 检测主观下线状态\n\n默认情况下,`Sentinel`会以每秒一次的频率向所有与它创建了命令连接的实例(包括主服务器,从服务器,其他`Sentinel`在内)发送PING命令,并通过实例返回的`PING`命令来判断实例是否在线\n\n## 检测客观下线状态\n\n当`Sentinel`将一个主服务器判断为主观下线后,它会向同样监视这一主服务器的其他`Sentinel`进行询问,如果接收到了足够数量的已下线判断之后,`Sentinel`就会将主服务器判断为客观下线,并对主服务器执行故障转移操作","source":"_posts/Redis笔记/16.Sentinel.md","raw":"---\ntitle: 《Redis设计与实现》------Sentinel\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: flase\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第十六章--Sentinel。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - Sentinel\n  - 数据库\nabbrlink: b89933c6\ndate: 2020-09-28 00:00:00\n---\n\n# Sentinel简介\n\n`Sentinel`(哨兵)是Redis的高可用性解决方案:由一个或多个`Sentinel`实例组成的Sentinel系统可以监视任意多个主服务器,以及这些主服务器属下的所有从服务器,并在被监视的主服务器进入下线状态时,自动将下线主服务器属下的某个从服务器升级为新的主服务器,然后由新的主服务器代替已下线的主服务器继续处理命令请求。\n\n# 启动并初始化Sentinel\n\n启动`Sentinel`会执行以下操作：\n\n1. 初始化服务器\n2. 将普通Redis服务器使用的代码替换成`Sentinel`专用代码\n3. 初始化`Sentinel`状态\n4. 根据给定的配置文件,初始化`Sentinel`的监视主服务器列表\n5. 创建连向主服务器的网络连接\n\n## 初始化Sentinel状态的masters属性\n\n`dict * masters;`保存了所有被这个Sentinel监视的主服务器\n\n`masters`字典键是监视主服务器的名字,值是被监视主服务器对应的`sentinelRedisInstance`结构\n\n每个`sentinelRedisInstance`结构代表了一个被sentinel监视的Redis服务器实例,这个实例可以是主服务器,从服务器或者另外一个`Sentinel`\n\n```c\ntypedef struct sentinelRedisInstance\n{\n\tint flags;//标识值,记录了实例的类型,以及该实例的当前状态\n\t\n\t//实例的名字\n\t//主服务器的名字由用户在配置文件中设置\n\t//从服务器以及Sentinel的名字由Sentinel自动设置\n\t//格式为ip:port,例如\"127.0.0.1:26379\"\n\tchar * name;\n\t\n\t//实例的运行ID\n\tchar * runid;\n\t\n\t//配置纪元,用于实现故障转移\n\tuint64_t config_epoch;\n\t\n\tsentinelAddr * addr; //实例的地址\n\t\n\tmstime_t down_after_period;//实例无响应多少毫秒后才会被认为是主观下线\n\tint quorum;//判断这个实例为客观下线所需的支持投票数量\n\tint parallel_syncs;//在执行故障转移操作时,可以同时对新的主服务器进行同步的从服务器数量\n\tmstime_t failover_timeout;//刷新故障迁移状态的最大时限\n}\n```\n\n```c\nstruct sentinelAddr\n{\n\tchar * ip;\n\tint port;\n}\n```\n\n## 获取主服务器的信息\n\n`Sentinel`默认会以每10秒一次的频率,通过命令连接向被监视的主服务器发送INFO命令\n\n对于主服务器返回的从服务器信息,会被用于更新主服务器实例结构的`slavers`字典,该字典记录了主服务器属下从服务器的名单\n\n# 获取从服务器信息\n\n当`Sentinel`发现主服务器有新的从服务器出现时,除了会为这个新的从服务器创建相应的实例结构外,还会创建连接到从服务器的命令连接和订阅连接\n\n# 检测主观下线状态\n\n默认情况下,`Sentinel`会以每秒一次的频率向所有与它创建了命令连接的实例(包括主服务器,从服务器,其他`Sentinel`在内)发送PING命令,并通过实例返回的`PING`命令来判断实例是否在线\n\n## 检测客观下线状态\n\n当`Sentinel`将一个主服务器判断为主观下线后,它会向同样监视这一主服务器的其他`Sentinel`进行询问,如果接收到了足够数量的已下线判断之后,`Sentinel`就会将主服务器判断为客观下线,并对主服务器执行故障转移操作","slug":"Redis笔记/16.Sentinel","published":1,"updated":"2021-02-04T00:36:00.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wi001tjotp07fk5vl9","content":"<h1 id=\"Sentinel简介\"><a href=\"#Sentinel简介\" class=\"headerlink\" title=\"Sentinel简介\"></a>Sentinel简介</h1><p><code>Sentinel</code>(哨兵)是Redis的高可用性解决方案:由一个或多个<code>Sentinel</code>实例组成的Sentinel系统可以监视任意多个主服务器,以及这些主服务器属下的所有从服务器,并在被监视的主服务器进入下线状态时,自动将下线主服务器属下的某个从服务器升级为新的主服务器,然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>\n<h1 id=\"启动并初始化Sentinel\"><a href=\"#启动并初始化Sentinel\" class=\"headerlink\" title=\"启动并初始化Sentinel\"></a>启动并初始化Sentinel</h1><p>启动<code>Sentinel</code>会执行以下操作：</p>\n<ol>\n<li>初始化服务器</li>\n<li>将普通Redis服务器使用的代码替换成<code>Sentinel</code>专用代码</li>\n<li>初始化<code>Sentinel</code>状态</li>\n<li>根据给定的配置文件,初始化<code>Sentinel</code>的监视主服务器列表</li>\n<li>创建连向主服务器的网络连接</li>\n</ol>\n<h2 id=\"初始化Sentinel状态的masters属性\"><a href=\"#初始化Sentinel状态的masters属性\" class=\"headerlink\" title=\"初始化Sentinel状态的masters属性\"></a>初始化Sentinel状态的masters属性</h2><p><code>dict * masters;</code>保存了所有被这个Sentinel监视的主服务器</p>\n<p><code>masters</code>字典键是监视主服务器的名字,值是被监视主服务器对应的<code>sentinelRedisInstance</code>结构</p>\n<p>每个<code>sentinelRedisInstance</code>结构代表了一个被sentinel监视的Redis服务器实例,这个实例可以是主服务器,从服务器或者另外一个<code>Sentinel</code></p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> sentinelRedisInstance\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> flags<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//标识值,记录了实例的类型,以及该实例的当前状态</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//实例的名字</span>\n    <span class=\"token comment\" spellcheck=\"true\">//主服务器的名字由用户在配置文件中设置</span>\n    <span class=\"token comment\" spellcheck=\"true\">//从服务器以及Sentinel的名字由Sentinel自动设置</span>\n    <span class=\"token comment\" spellcheck=\"true\">//格式为ip:port,例如\"127.0.0.1:26379\"</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> name<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//实例的运行ID</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> runid<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//配置纪元,用于实现故障转移</span>\n    uint64_t config_epoch<span class=\"token punctuation\">;</span>\n\n    sentinelAddr <span class=\"token operator\">*</span> addr<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//实例的地址</span>\n\n    mstime_t down_after_period<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//实例无响应多少毫秒后才会被认为是主观下线</span>\n    <span class=\"token keyword\">int</span> quorum<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//判断这个实例为客观下线所需的支持投票数量</span>\n    <span class=\"token keyword\">int</span> parallel_syncs<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//在执行故障转移操作时,可以同时对新的主服务器进行同步的从服务器数量</span>\n    mstime_t failover_timeout<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//刷新故障迁移状态的最大时限</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> sentinelAddr\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> ip<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> port<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"获取主服务器的信息\"><a href=\"#获取主服务器的信息\" class=\"headerlink\" title=\"获取主服务器的信息\"></a>获取主服务器的信息</h2><p><code>Sentinel</code>默认会以每10秒一次的频率,通过命令连接向被监视的主服务器发送INFO命令</p>\n<p>对于主服务器返回的从服务器信息,会被用于更新主服务器实例结构的<code>slavers</code>字典,该字典记录了主服务器属下从服务器的名单</p>\n<h1 id=\"获取从服务器信息\"><a href=\"#获取从服务器信息\" class=\"headerlink\" title=\"获取从服务器信息\"></a>获取从服务器信息</h1><p>当<code>Sentinel</code>发现主服务器有新的从服务器出现时,除了会为这个新的从服务器创建相应的实例结构外,还会创建连接到从服务器的命令连接和订阅连接</p>\n<h1 id=\"检测主观下线状态\"><a href=\"#检测主观下线状态\" class=\"headerlink\" title=\"检测主观下线状态\"></a>检测主观下线状态</h1><p>默认情况下,<code>Sentinel</code>会以每秒一次的频率向所有与它创建了命令连接的实例(包括主服务器,从服务器,其他<code>Sentinel</code>在内)发送PING命令,并通过实例返回的<code>PING</code>命令来判断实例是否在线</p>\n<h2 id=\"检测客观下线状态\"><a href=\"#检测客观下线状态\" class=\"headerlink\" title=\"检测客观下线状态\"></a>检测客观下线状态</h2><p>当<code>Sentinel</code>将一个主服务器判断为主观下线后,它会向同样监视这一主服务器的其他<code>Sentinel</code>进行询问,如果接收到了足够数量的已下线判断之后,<code>Sentinel</code>就会将主服务器判断为客观下线,并对主服务器执行故障转移操作</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"Sentinel简介\"><a href=\"#Sentinel简介\" class=\"headerlink\" title=\"Sentinel简介\"></a>Sentinel简介</h1><p><code>Sentinel</code>(哨兵)是Redis的高可用性解决方案:由一个或多个<code>Sentinel</code>实例组成的Sentinel系统可以监视任意多个主服务器,以及这些主服务器属下的所有从服务器,并在被监视的主服务器进入下线状态时,自动将下线主服务器属下的某个从服务器升级为新的主服务器,然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>\n<h1 id=\"启动并初始化Sentinel\"><a href=\"#启动并初始化Sentinel\" class=\"headerlink\" title=\"启动并初始化Sentinel\"></a>启动并初始化Sentinel</h1><p>启动<code>Sentinel</code>会执行以下操作：</p>\n<ol>\n<li>初始化服务器</li>\n<li>将普通Redis服务器使用的代码替换成<code>Sentinel</code>专用代码</li>\n<li>初始化<code>Sentinel</code>状态</li>\n<li>根据给定的配置文件,初始化<code>Sentinel</code>的监视主服务器列表</li>\n<li>创建连向主服务器的网络连接</li>\n</ol>\n<h2 id=\"初始化Sentinel状态的masters属性\"><a href=\"#初始化Sentinel状态的masters属性\" class=\"headerlink\" title=\"初始化Sentinel状态的masters属性\"></a>初始化Sentinel状态的masters属性</h2><p><code>dict * masters;</code>保存了所有被这个Sentinel监视的主服务器</p>\n<p><code>masters</code>字典键是监视主服务器的名字,值是被监视主服务器对应的<code>sentinelRedisInstance</code>结构</p>\n<p>每个<code>sentinelRedisInstance</code>结构代表了一个被sentinel监视的Redis服务器实例,这个实例可以是主服务器,从服务器或者另外一个<code>Sentinel</code></p>\n<pre><code class=\"c\">typedef struct sentinelRedisInstance\n{\n    int flags;//标识值,记录了实例的类型,以及该实例的当前状态\n\n    //实例的名字\n    //主服务器的名字由用户在配置文件中设置\n    //从服务器以及Sentinel的名字由Sentinel自动设置\n    //格式为ip:port,例如&quot;127.0.0.1:26379&quot;\n    char * name;\n\n    //实例的运行ID\n    char * runid;\n\n    //配置纪元,用于实现故障转移\n    uint64_t config_epoch;\n\n    sentinelAddr * addr; //实例的地址\n\n    mstime_t down_after_period;//实例无响应多少毫秒后才会被认为是主观下线\n    int quorum;//判断这个实例为客观下线所需的支持投票数量\n    int parallel_syncs;//在执行故障转移操作时,可以同时对新的主服务器进行同步的从服务器数量\n    mstime_t failover_timeout;//刷新故障迁移状态的最大时限\n}</code></pre>\n<pre><code class=\"c\">struct sentinelAddr\n{\n    char * ip;\n    int port;\n}</code></pre>\n<h2 id=\"获取主服务器的信息\"><a href=\"#获取主服务器的信息\" class=\"headerlink\" title=\"获取主服务器的信息\"></a>获取主服务器的信息</h2><p><code>Sentinel</code>默认会以每10秒一次的频率,通过命令连接向被监视的主服务器发送INFO命令</p>\n<p>对于主服务器返回的从服务器信息,会被用于更新主服务器实例结构的<code>slavers</code>字典,该字典记录了主服务器属下从服务器的名单</p>\n<h1 id=\"获取从服务器信息\"><a href=\"#获取从服务器信息\" class=\"headerlink\" title=\"获取从服务器信息\"></a>获取从服务器信息</h1><p>当<code>Sentinel</code>发现主服务器有新的从服务器出现时,除了会为这个新的从服务器创建相应的实例结构外,还会创建连接到从服务器的命令连接和订阅连接</p>\n<h1 id=\"检测主观下线状态\"><a href=\"#检测主观下线状态\" class=\"headerlink\" title=\"检测主观下线状态\"></a>检测主观下线状态</h1><p>默认情况下,<code>Sentinel</code>会以每秒一次的频率向所有与它创建了命令连接的实例(包括主服务器,从服务器,其他<code>Sentinel</code>在内)发送PING命令,并通过实例返回的<code>PING</code>命令来判断实例是否在线</p>\n<h2 id=\"检测客观下线状态\"><a href=\"#检测客观下线状态\" class=\"headerlink\" title=\"检测客观下线状态\"></a>检测客观下线状态</h2><p>当<code>Sentinel</code>将一个主服务器判断为主观下线后,它会向同样监视这一主服务器的其他<code>Sentinel</code>进行询问,如果接收到了足够数量的已下线判断之后,<code>Sentinel</code>就会将主服务器判断为客观下线,并对主服务器执行故障转移操作</p>\n"},{"title":"《Redis设计与实现》-------整数集合","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第六章--整数集合。","abbrlink":"e6a53be5","date":"2020-08-26T16:00:00.000Z","_content":"\n# 整数集合的实现\n\n当一个集合只包含整数值元素,并且数量不多时,`redis`就会采用整数集合作为集合键的底层实现\n\n```c\ntypedef strcut intset\n{\n\tuint32_t encoding; //编码方式\n\tuint32_t length; //元素数量\n\tint8_t contents[]; //保存元素的数组\n}\n```\n\n可以保存类型为 int16_t,int32_t,int64_t的非重复整数值,且元素在`contents数组`中有序排列\n\n# 升级\n\n每当添加一个新元素到整数集合里面,并且新元素的类型比**现有所有元素类型**都长,需要先对整数集合进行升级,再加入该元素\n\n1. 根据新元素类型,扩展整数集合底层数组的空间大小,并为新元素分配空间\n2. 将底层数组现有的所有元素转换成与新元素相同的类型,并且放置到正确位置上,仍需**保证有序性**\n3. 将新元素添加到底层数组里\n\n每次添加新元素都有可能引起升级,而每次升级都需要对底层数组所有元素进行类型转换,所以添加新元素时间复杂度为`O(N)`\n\n新元素要么小于现有所有元素,则放在底层数组的索引0的位置;要么大于所有元素,放在底层数组索引 `length-1`的位置\n\n# 升级的好处\n\n## 提升灵活性\n\n整数集合可以通过自动升级底层数组来适应新元素,所以可以将 int16_t,int32_t,`int64_t`随意地添加到集合中,不必担心类型错误\n\n## 节约内存\n\n既可以让集合能**同时保存三种不同类型**的值,又可以确保升级只在必要时进行\n\n\n\n# 降级\n\n**不支持**降级操作,即使把之前因为他而升级的元素删除,底层数组还仍然是加入那个元素后的类型","source":"_posts/Redis笔记/6.整数集合.md","raw":"---\ntitle: 《Redis设计与实现》-------整数集合\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第六章--整数集合。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - 数据结构\n  - 整数集合\nabbrlink: e6a53be5\ndate: 2020-08-27 00:00:00\n---\n\n# 整数集合的实现\n\n当一个集合只包含整数值元素,并且数量不多时,`redis`就会采用整数集合作为集合键的底层实现\n\n```c\ntypedef strcut intset\n{\n\tuint32_t encoding; //编码方式\n\tuint32_t length; //元素数量\n\tint8_t contents[]; //保存元素的数组\n}\n```\n\n可以保存类型为 int16_t,int32_t,int64_t的非重复整数值,且元素在`contents数组`中有序排列\n\n# 升级\n\n每当添加一个新元素到整数集合里面,并且新元素的类型比**现有所有元素类型**都长,需要先对整数集合进行升级,再加入该元素\n\n1. 根据新元素类型,扩展整数集合底层数组的空间大小,并为新元素分配空间\n2. 将底层数组现有的所有元素转换成与新元素相同的类型,并且放置到正确位置上,仍需**保证有序性**\n3. 将新元素添加到底层数组里\n\n每次添加新元素都有可能引起升级,而每次升级都需要对底层数组所有元素进行类型转换,所以添加新元素时间复杂度为`O(N)`\n\n新元素要么小于现有所有元素,则放在底层数组的索引0的位置;要么大于所有元素,放在底层数组索引 `length-1`的位置\n\n# 升级的好处\n\n## 提升灵活性\n\n整数集合可以通过自动升级底层数组来适应新元素,所以可以将 int16_t,int32_t,`int64_t`随意地添加到集合中,不必担心类型错误\n\n## 节约内存\n\n既可以让集合能**同时保存三种不同类型**的值,又可以确保升级只在必要时进行\n\n\n\n# 降级\n\n**不支持**降级操作,即使把之前因为他而升级的元素删除,底层数组还仍然是加入那个元素后的类型","slug":"Redis笔记/6.整数集合","published":1,"updated":"2020-11-12T11:57:29.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wj001wjotp3o2n7vgi","content":"<h1 id=\"整数集合的实现\"><a href=\"#整数集合的实现\" class=\"headerlink\" title=\"整数集合的实现\"></a>整数集合的实现</h1><p>当一个集合只包含整数值元素,并且数量不多时,<code>redis</code>就会采用整数集合作为集合键的底层实现</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> strcut intset\n<span class=\"token punctuation\">{</span>\n    uint32_t encoding<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//编码方式</span>\n    uint32_t length<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//元素数量</span>\n    int8_t contents<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//保存元素的数组</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>可以保存类型为 int16_t,int32_t,int64_t的非重复整数值,且元素在<code>contents数组</code>中有序排列</p>\n<h1 id=\"升级\"><a href=\"#升级\" class=\"headerlink\" title=\"升级\"></a>升级</h1><p>每当添加一个新元素到整数集合里面,并且新元素的类型比<strong>现有所有元素类型</strong>都长,需要先对整数集合进行升级,再加入该元素</p>\n<ol>\n<li>根据新元素类型,扩展整数集合底层数组的空间大小,并为新元素分配空间</li>\n<li>将底层数组现有的所有元素转换成与新元素相同的类型,并且放置到正确位置上,仍需<strong>保证有序性</strong></li>\n<li>将新元素添加到底层数组里</li>\n</ol>\n<p>每次添加新元素都有可能引起升级,而每次升级都需要对底层数组所有元素进行类型转换,所以添加新元素时间复杂度为<code>O(N)</code></p>\n<p>新元素要么小于现有所有元素,则放在底层数组的索引0的位置;要么大于所有元素,放在底层数组索引 <code>length-1</code>的位置</p>\n<h1 id=\"升级的好处\"><a href=\"#升级的好处\" class=\"headerlink\" title=\"升级的好处\"></a>升级的好处</h1><h2 id=\"提升灵活性\"><a href=\"#提升灵活性\" class=\"headerlink\" title=\"提升灵活性\"></a>提升灵活性</h2><p>整数集合可以通过自动升级底层数组来适应新元素,所以可以将 int16_t,int32_t,<code>int64_t</code>随意地添加到集合中,不必担心类型错误</p>\n<h2 id=\"节约内存\"><a href=\"#节约内存\" class=\"headerlink\" title=\"节约内存\"></a>节约内存</h2><p>既可以让集合能<strong>同时保存三种不同类型</strong>的值,又可以确保升级只在必要时进行</p>\n<h1 id=\"降级\"><a href=\"#降级\" class=\"headerlink\" title=\"降级\"></a>降级</h1><p><strong>不支持</strong>降级操作,即使把之前因为他而升级的元素删除,底层数组还仍然是加入那个元素后的类型</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"整数集合的实现\"><a href=\"#整数集合的实现\" class=\"headerlink\" title=\"整数集合的实现\"></a>整数集合的实现</h1><p>当一个集合只包含整数值元素,并且数量不多时,<code>redis</code>就会采用整数集合作为集合键的底层实现</p>\n<pre><code class=\"c\">typedef strcut intset\n{\n    uint32_t encoding; //编码方式\n    uint32_t length; //元素数量\n    int8_t contents[]; //保存元素的数组\n}</code></pre>\n<p>可以保存类型为 int16_t,int32_t,int64_t的非重复整数值,且元素在<code>contents数组</code>中有序排列</p>\n<h1 id=\"升级\"><a href=\"#升级\" class=\"headerlink\" title=\"升级\"></a>升级</h1><p>每当添加一个新元素到整数集合里面,并且新元素的类型比<strong>现有所有元素类型</strong>都长,需要先对整数集合进行升级,再加入该元素</p>\n<ol>\n<li>根据新元素类型,扩展整数集合底层数组的空间大小,并为新元素分配空间</li>\n<li>将底层数组现有的所有元素转换成与新元素相同的类型,并且放置到正确位置上,仍需<strong>保证有序性</strong></li>\n<li>将新元素添加到底层数组里</li>\n</ol>\n<p>每次添加新元素都有可能引起升级,而每次升级都需要对底层数组所有元素进行类型转换,所以添加新元素时间复杂度为<code>O(N)</code></p>\n<p>新元素要么小于现有所有元素,则放在底层数组的索引0的位置;要么大于所有元素,放在底层数组索引 <code>length-1</code>的位置</p>\n<h1 id=\"升级的好处\"><a href=\"#升级的好处\" class=\"headerlink\" title=\"升级的好处\"></a>升级的好处</h1><h2 id=\"提升灵活性\"><a href=\"#提升灵活性\" class=\"headerlink\" title=\"提升灵活性\"></a>提升灵活性</h2><p>整数集合可以通过自动升级底层数组来适应新元素,所以可以将 int16_t,int32_t,<code>int64_t</code>随意地添加到集合中,不必担心类型错误</p>\n<h2 id=\"节约内存\"><a href=\"#节约内存\" class=\"headerlink\" title=\"节约内存\"></a>节约内存</h2><p>既可以让集合能<strong>同时保存三种不同类型</strong>的值,又可以确保升级只在必要时进行</p>\n<h1 id=\"降级\"><a href=\"#降级\" class=\"headerlink\" title=\"降级\"></a>降级</h1><p><strong>不支持</strong>降级操作,即使把之前因为他而升级的元素删除,底层数组还仍然是加入那个元素后的类型</p>\n"},{"title":"《Redis设计与实现》-------跳跃表","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第五章--跳跃表。","abbrlink":"27ebf426","date":"2020-08-20T16:00:00.000Z","_content":"\n# 介绍\n\n+ 通过在每个节点中维持多个指向其他节点的指针,从而快速访问节点\n+ 查找速度:平均`O(log N)`,最坏`O(N)`\n+ 支持顺序性操作\n+ 使用跳跃表作为有序集合键的底层实现之一\n\n## 性质\n\n1. 每一层都是一个有序的链表,最底层(L1)的链表包含**所有元素**\n2. 如果一个元素出现在第 n 层的链表中，则它也出现在第` n+1 `层\n3. 搜索先从上层搜索,当前面的元素比`target`大时,则向下一级搜索(即向着更密集的数据找)\n4. 总体来看从左上往右下寻找\n\n\n\n# 实现\n\n![IMG_20200818_102630](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200818_102630.jpg)\n\nlevel:表中层数最大的节点的层数\n\nlength:节点数量\n\n## 跳跃表节点\n\n```c\ntypedef struct zskiplistNode\n{\n\tstruct zskiplistNode * backward;//后退指针\n\tdouble score;//分值\n\trobj * obj;//成员对象\n\t\n\tstruct zskiplistLevel //层\n\t{\n\t\tstruct zskiplistNode * forward; //前进指针\n\t\tunsigned int span;//跨度\n\t}\n}\n```\n\n### 层\n\n`level数组`可以包含多个元素,每个元素都包含一个指向其他节点的指针,来加快访问其他节点的速度\n\n感觉幂次规律,随机生成一个`[1,32]`的值作为level数组的大小,即层的高度\n\n### 前进指针\n\n每个层都有一个指向表尾方向的前进指针(`level[i].forward`)\n\n### 跨度\n\n记录两个节点之间的距离\n\n指向NULL的所有前进指针的跨度都为0\n\n跨度实际是用来计算排位的:在查找某个节点过程中,将沿途访问的所有层的跨度累积起来,得到的结果就是目标节点在跳跃表中的排位(即该节点是第几个节点)\n\n### 后退指针\n\n可以先通过跳跃表的tail指针访问表尾节点,然后通过后退指针访问倒数第二个节点...,直到遇到指向NULL的后退指针\n\n### 分值和成员\n\n1. 分值:跳跃表中所有节点都按分值从小到大排序\n2. 成员对象:指向**SDS字符串**对象的指针\n3. 跳跃表中成员对象必须唯一,但是分值可以相同\n4. 分值相同的节点按照成员变量的字典序排序\n\n## 跳跃表\n\n```c\ntypedef struct zskiplist\n{\n\tstruct zskiplistNode * header,*tial;\n\tunsigned long length;//表中节点的数量\n\tint level;//表中层数最大的节点的层数\n} zskiplist;\n```\n\n使得能`O(1)`访问表头表尾节点,访问跳跃表长度,获取表中层数最大的节点的层数\n\n","source":"_posts/Redis笔记/5.跳跃表.md","raw":"---\ntitle: 《Redis设计与实现》-------跳跃表\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第五章--跳跃表。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - 数据结构\n  - 跳跃表\nabbrlink: 27ebf426\ndate: 2020-08-21 00:00:00\n---\n\n# 介绍\n\n+ 通过在每个节点中维持多个指向其他节点的指针,从而快速访问节点\n+ 查找速度:平均`O(log N)`,最坏`O(N)`\n+ 支持顺序性操作\n+ 使用跳跃表作为有序集合键的底层实现之一\n\n## 性质\n\n1. 每一层都是一个有序的链表,最底层(L1)的链表包含**所有元素**\n2. 如果一个元素出现在第 n 层的链表中，则它也出现在第` n+1 `层\n3. 搜索先从上层搜索,当前面的元素比`target`大时,则向下一级搜索(即向着更密集的数据找)\n4. 总体来看从左上往右下寻找\n\n\n\n# 实现\n\n![IMG_20200818_102630](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200818_102630.jpg)\n\nlevel:表中层数最大的节点的层数\n\nlength:节点数量\n\n## 跳跃表节点\n\n```c\ntypedef struct zskiplistNode\n{\n\tstruct zskiplistNode * backward;//后退指针\n\tdouble score;//分值\n\trobj * obj;//成员对象\n\t\n\tstruct zskiplistLevel //层\n\t{\n\t\tstruct zskiplistNode * forward; //前进指针\n\t\tunsigned int span;//跨度\n\t}\n}\n```\n\n### 层\n\n`level数组`可以包含多个元素,每个元素都包含一个指向其他节点的指针,来加快访问其他节点的速度\n\n感觉幂次规律,随机生成一个`[1,32]`的值作为level数组的大小,即层的高度\n\n### 前进指针\n\n每个层都有一个指向表尾方向的前进指针(`level[i].forward`)\n\n### 跨度\n\n记录两个节点之间的距离\n\n指向NULL的所有前进指针的跨度都为0\n\n跨度实际是用来计算排位的:在查找某个节点过程中,将沿途访问的所有层的跨度累积起来,得到的结果就是目标节点在跳跃表中的排位(即该节点是第几个节点)\n\n### 后退指针\n\n可以先通过跳跃表的tail指针访问表尾节点,然后通过后退指针访问倒数第二个节点...,直到遇到指向NULL的后退指针\n\n### 分值和成员\n\n1. 分值:跳跃表中所有节点都按分值从小到大排序\n2. 成员对象:指向**SDS字符串**对象的指针\n3. 跳跃表中成员对象必须唯一,但是分值可以相同\n4. 分值相同的节点按照成员变量的字典序排序\n\n## 跳跃表\n\n```c\ntypedef struct zskiplist\n{\n\tstruct zskiplistNode * header,*tial;\n\tunsigned long length;//表中节点的数量\n\tint level;//表中层数最大的节点的层数\n} zskiplist;\n```\n\n使得能`O(1)`访问表头表尾节点,访问跳跃表长度,获取表中层数最大的节点的层数\n\n","slug":"Redis笔记/5.跳跃表","published":1,"updated":"2020-11-12T11:57:29.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wl001zjotp3bdzdbjb","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><ul>\n<li>通过在每个节点中维持多个指向其他节点的指针,从而快速访问节点</li>\n<li>查找速度:平均<code>O(log N)</code>,最坏<code>O(N)</code></li>\n<li>支持顺序性操作</li>\n<li>使用跳跃表作为有序集合键的底层实现之一</li>\n</ul>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><ol>\n<li>每一层都是一个有序的链表,最底层(L1)的链表包含<strong>所有元素</strong></li>\n<li>如果一个元素出现在第 n 层的链表中，则它也出现在第<code>n+1</code>层</li>\n<li>搜索先从上层搜索,当前面的元素比<code>target</code>大时,则向下一级搜索(即向着更密集的数据找)</li>\n<li>总体来看从左上往右下寻找</li>\n</ol>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200818_102630.jpg\" alt=\"IMG_20200818_102630\"></p>\n<p>level:表中层数最大的节点的层数</p>\n<p>length:节点数量</p>\n<h2 id=\"跳跃表节点\"><a href=\"#跳跃表节点\" class=\"headerlink\" title=\"跳跃表节点\"></a>跳跃表节点</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> zskiplistNode\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> zskiplistNode <span class=\"token operator\">*</span> backward<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//后退指针</span>\n    <span class=\"token keyword\">double</span> score<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//分值</span>\n    robj <span class=\"token operator\">*</span> obj<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//成员对象</span>\n\n    <span class=\"token keyword\">struct</span> zskiplistLevel <span class=\"token comment\" spellcheck=\"true\">//层</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">struct</span> zskiplistNode <span class=\"token operator\">*</span> forward<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//前进指针</span>\n        <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> span<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//跨度</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"层\"><a href=\"#层\" class=\"headerlink\" title=\"层\"></a>层</h3><p><code>level数组</code>可以包含多个元素,每个元素都包含一个指向其他节点的指针,来加快访问其他节点的速度</p>\n<p>感觉幂次规律,随机生成一个<code>[1,32]</code>的值作为level数组的大小,即层的高度</p>\n<h3 id=\"前进指针\"><a href=\"#前进指针\" class=\"headerlink\" title=\"前进指针\"></a>前进指针</h3><p>每个层都有一个指向表尾方向的前进指针(<code>level[i].forward</code>)</p>\n<h3 id=\"跨度\"><a href=\"#跨度\" class=\"headerlink\" title=\"跨度\"></a>跨度</h3><p>记录两个节点之间的距离</p>\n<p>指向NULL的所有前进指针的跨度都为0</p>\n<p>跨度实际是用来计算排位的:在查找某个节点过程中,将沿途访问的所有层的跨度累积起来,得到的结果就是目标节点在跳跃表中的排位(即该节点是第几个节点)</p>\n<h3 id=\"后退指针\"><a href=\"#后退指针\" class=\"headerlink\" title=\"后退指针\"></a>后退指针</h3><p>可以先通过跳跃表的tail指针访问表尾节点,然后通过后退指针访问倒数第二个节点…,直到遇到指向NULL的后退指针</p>\n<h3 id=\"分值和成员\"><a href=\"#分值和成员\" class=\"headerlink\" title=\"分值和成员\"></a>分值和成员</h3><ol>\n<li>分值:跳跃表中所有节点都按分值从小到大排序</li>\n<li>成员对象:指向<strong>SDS字符串</strong>对象的指针</li>\n<li>跳跃表中成员对象必须唯一,但是分值可以相同</li>\n<li>分值相同的节点按照成员变量的字典序排序</li>\n</ol>\n<h2 id=\"跳跃表\"><a href=\"#跳跃表\" class=\"headerlink\" title=\"跳跃表\"></a>跳跃表</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> zskiplist\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> zskiplistNode <span class=\"token operator\">*</span> header<span class=\"token punctuation\">,</span><span class=\"token operator\">*</span>tial<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> length<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//表中节点的数量</span>\n    <span class=\"token keyword\">int</span> level<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//表中层数最大的节点的层数</span>\n<span class=\"token punctuation\">}</span> zskiplist<span class=\"token punctuation\">;</span></code></pre>\n<p>使得能<code>O(1)</code>访问表头表尾节点,访问跳跃表长度,获取表中层数最大的节点的层数</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><ul>\n<li>通过在每个节点中维持多个指向其他节点的指针,从而快速访问节点</li>\n<li>查找速度:平均<code>O(log N)</code>,最坏<code>O(N)</code></li>\n<li>支持顺序性操作</li>\n<li>使用跳跃表作为有序集合键的底层实现之一</li>\n</ul>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><ol>\n<li>每一层都是一个有序的链表,最底层(L1)的链表包含<strong>所有元素</strong></li>\n<li>如果一个元素出现在第 n 层的链表中，则它也出现在第<code>n+1</code>层</li>\n<li>搜索先从上层搜索,当前面的元素比<code>target</code>大时,则向下一级搜索(即向着更密集的数据找)</li>\n<li>总体来看从左上往右下寻找</li>\n</ol>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200818_102630.jpg\" alt=\"IMG_20200818_102630\"></p>\n<p>level:表中层数最大的节点的层数</p>\n<p>length:节点数量</p>\n<h2 id=\"跳跃表节点\"><a href=\"#跳跃表节点\" class=\"headerlink\" title=\"跳跃表节点\"></a>跳跃表节点</h2><pre><code class=\"c\">typedef struct zskiplistNode\n{\n    struct zskiplistNode * backward;//后退指针\n    double score;//分值\n    robj * obj;//成员对象\n\n    struct zskiplistLevel //层\n    {\n        struct zskiplistNode * forward; //前进指针\n        unsigned int span;//跨度\n    }\n}</code></pre>\n<h3 id=\"层\"><a href=\"#层\" class=\"headerlink\" title=\"层\"></a>层</h3><p><code>level数组</code>可以包含多个元素,每个元素都包含一个指向其他节点的指针,来加快访问其他节点的速度</p>\n<p>感觉幂次规律,随机生成一个<code>[1,32]</code>的值作为level数组的大小,即层的高度</p>\n<h3 id=\"前进指针\"><a href=\"#前进指针\" class=\"headerlink\" title=\"前进指针\"></a>前进指针</h3><p>每个层都有一个指向表尾方向的前进指针(<code>level[i].forward</code>)</p>\n<h3 id=\"跨度\"><a href=\"#跨度\" class=\"headerlink\" title=\"跨度\"></a>跨度</h3><p>记录两个节点之间的距离</p>\n<p>指向NULL的所有前进指针的跨度都为0</p>\n<p>跨度实际是用来计算排位的:在查找某个节点过程中,将沿途访问的所有层的跨度累积起来,得到的结果就是目标节点在跳跃表中的排位(即该节点是第几个节点)</p>\n<h3 id=\"后退指针\"><a href=\"#后退指针\" class=\"headerlink\" title=\"后退指针\"></a>后退指针</h3><p>可以先通过跳跃表的tail指针访问表尾节点,然后通过后退指针访问倒数第二个节点…,直到遇到指向NULL的后退指针</p>\n<h3 id=\"分值和成员\"><a href=\"#分值和成员\" class=\"headerlink\" title=\"分值和成员\"></a>分值和成员</h3><ol>\n<li>分值:跳跃表中所有节点都按分值从小到大排序</li>\n<li>成员对象:指向<strong>SDS字符串</strong>对象的指针</li>\n<li>跳跃表中成员对象必须唯一,但是分值可以相同</li>\n<li>分值相同的节点按照成员变量的字典序排序</li>\n</ol>\n<h2 id=\"跳跃表\"><a href=\"#跳跃表\" class=\"headerlink\" title=\"跳跃表\"></a>跳跃表</h2><pre><code class=\"c\">typedef struct zskiplist\n{\n    struct zskiplistNode * header,*tial;\n    unsigned long length;//表中节点的数量\n    int level;//表中层数最大的节点的层数\n} zskiplist;</code></pre>\n<p>使得能<code>O(1)</code>访问表头表尾节点,访问跳跃表长度,获取表中层数最大的节点的层数</p>\n"},{"title":"《Redis设计与实现》-------链表","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第三章--链表。","abbrlink":"1ecd581d","date":"2020-08-16T16:00:00.000Z","_content":"\n## 简介\n\n被广泛用于实现`Redis`的各种功能,如列表键,发布与订阅,慢查询,监视器等等\n## 链表和链表节点的实现\n\n```c\ntypedef struct listNode\n{\n\tstruct listNode * prev;\n\tstruct listNode * next;\n\tvoid * value;\n}listNode;\n```\n\n```c\ntypedef struct list\n{\n\tlistNode *head;\n\tlistNode *tail;\n\tunsigned long len;\n\t\n\tvoid *(*dup)(void *ptr);//节点值的复制函数\n\tvoid (*free)(void * ptr);//节点值的释放函数\n\tint (*match)(void * ptr,void * key);//节点值的对比函数\n}\n```\n\n## 特性总结\n\n+ 双端,无环,带表头和表尾指针,带链表长度计数器\n+ 多态:可以保存各种不同类型的值","source":"_posts/Redis笔记/3.链表.md","raw":"---\ntitle: 《Redis设计与实现》-------链表\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第三章--链表。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - 数据结构\n  - 链表\n  - 指针\nabbrlink: 1ecd581d\ndate: 2020-08-17 00:00:00\n---\n\n## 简介\n\n被广泛用于实现`Redis`的各种功能,如列表键,发布与订阅,慢查询,监视器等等\n## 链表和链表节点的实现\n\n```c\ntypedef struct listNode\n{\n\tstruct listNode * prev;\n\tstruct listNode * next;\n\tvoid * value;\n}listNode;\n```\n\n```c\ntypedef struct list\n{\n\tlistNode *head;\n\tlistNode *tail;\n\tunsigned long len;\n\t\n\tvoid *(*dup)(void *ptr);//节点值的复制函数\n\tvoid (*free)(void * ptr);//节点值的释放函数\n\tint (*match)(void * ptr,void * key);//节点值的对比函数\n}\n```\n\n## 特性总结\n\n+ 双端,无环,带表头和表尾指针,带链表长度计数器\n+ 多态:可以保存各种不同类型的值","slug":"Redis笔记/3.链表","published":1,"updated":"2020-11-12T11:57:29.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wn0022jotp0rdh32je","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>被广泛用于实现<code>Redis</code>的各种功能,如列表键,发布与订阅,慢查询,监视器等等</p>\n<h2 id=\"链表和链表节点的实现\"><a href=\"#链表和链表节点的实现\" class=\"headerlink\" title=\"链表和链表节点的实现\"></a>链表和链表节点的实现</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> listNode\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> listNode <span class=\"token operator\">*</span> prev<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> listNode <span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>listNode<span class=\"token punctuation\">;</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> list\n<span class=\"token punctuation\">{</span>\n    listNode <span class=\"token operator\">*</span>head<span class=\"token punctuation\">;</span>\n    listNode <span class=\"token operator\">*</span>tail<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> len<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>dup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//节点值的复制函数</span>\n    <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>free<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//节点值的释放函数</span>\n    <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>match<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> ptr<span class=\"token punctuation\">,</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//节点值的对比函数</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"特性总结\"><a href=\"#特性总结\" class=\"headerlink\" title=\"特性总结\"></a>特性总结</h2><ul>\n<li>双端,无环,带表头和表尾指针,带链表长度计数器</li>\n<li>多态:可以保存各种不同类型的值</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>被广泛用于实现<code>Redis</code>的各种功能,如列表键,发布与订阅,慢查询,监视器等等</p>\n<h2 id=\"链表和链表节点的实现\"><a href=\"#链表和链表节点的实现\" class=\"headerlink\" title=\"链表和链表节点的实现\"></a>链表和链表节点的实现</h2><pre><code class=\"c\">typedef struct listNode\n{\n    struct listNode * prev;\n    struct listNode * next;\n    void * value;\n}listNode;</code></pre>\n<pre><code class=\"c\">typedef struct list\n{\n    listNode *head;\n    listNode *tail;\n    unsigned long len;\n\n    void *(*dup)(void *ptr);//节点值的复制函数\n    void (*free)(void * ptr);//节点值的释放函数\n    int (*match)(void * ptr,void * key);//节点值的对比函数\n}</code></pre>\n<h2 id=\"特性总结\"><a href=\"#特性总结\" class=\"headerlink\" title=\"特性总结\"></a>特性总结</h2><ul>\n<li>双端,无环,带表头和表尾指针,带链表长度计数器</li>\n<li>多态:可以保存各种不同类型的值</li>\n</ul>\n"},{"title":"《Redis设计与实现》-------压缩列表","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第七章--压缩列表。","abbrlink":"cbdc6ef6","date":"2020-08-28T16:00:00.000Z","_content":"\n# 压缩列表的构成\n\n压缩列表是列表键和哈希键的底层实现之一,当一个列表键只包含少量列表项,并且每个列表项都是**小整数或较短字符串**，则用压缩列表作为底层实现\n\n压缩列表是为了**节约内存**而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构\n\n+ `zlbytes`:记录整个压缩列表所占用的内存字节数，在内存重分配或zlend位置时使用\n+ `zltail`：记录压缩列表表尾节点距压缩列表的起始地址有多少字节，通过该偏移量，可无须遍历整个压缩列表就可以确定表尾节点的地址\n+ `zllen`：记录了压缩列表包含的节点数量\n+ `entryX`：压缩列表包含的各个节点，节点长度由节点包含的内容决定\n+ `zlend`：特殊值oxFF,用于标记压缩列表的末端\n\n# 压缩列表节点的构成\n\n## previous_entry_length\n\n以字节为单位，记录压缩列表**前一个节点**的长度。所以可以通过指针运算，根据当前节点的起始地址得到前一个节点的起始地址，用于从表尾到表头的遍历\n\n指向表尾节点的指针 可以通过压缩列表的起始地址的指针加上`zltail`\n\n## encoding\n\n记录节点的`content`属性所保存数据的类型及长度\n\n## content\n\n负责保存节点的值，值的类型和属性由`encoding`决定\n\n\n\n# 连锁更新\n\n如果在压缩列表中，有多个介于250-153字节的节点e1-eN,记录这些节点的长度只需要1字节长的**previous_entry_length**，所以e1-eN所有节点的**previous_entry_length**都是1字节长\n\n但如果将一个大于254字节的新节点new加入压缩列表的头节点，则new成为e1的前置节点。而这样e1的**previous_entry_length**属性不足以保存new的长度，所以进行空间重分配，变成5字节大小\n\n这样e1的长度大于254字节了，e2的**previous_entry_length**也不足以保存e1的长度，也扩展成5字节大小。这样就进行连续多次空间扩展，即连锁更新\n\n删除节点也会引发连锁更新\n\n连锁更新在最坏情况下需要对压缩列表进行N次空间重分配操作，每次操作最坏`O(N)`,所以连锁更新最坏时间复杂度为`O(N^2)​`.\n\n但是发生的机率比较低：1. 恰好有多个连续的，长度介于250-153字节的节点的情况并不多见 2. 即使出现连锁更新，只要被更新的节点数量不多，就不会对性能有影响所以平均复杂度为O(N)\n\n\n\n","source":"_posts/Redis笔记/7.压缩列表.md","raw":"---\ntitle: 《Redis设计与实现》-------压缩列表\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第七章--压缩列表。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - 数据结构\n  - 压缩列表\nabbrlink: cbdc6ef6\ndate: 2020-08-29 00:00:00\n---\n\n# 压缩列表的构成\n\n压缩列表是列表键和哈希键的底层实现之一,当一个列表键只包含少量列表项,并且每个列表项都是**小整数或较短字符串**，则用压缩列表作为底层实现\n\n压缩列表是为了**节约内存**而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构\n\n+ `zlbytes`:记录整个压缩列表所占用的内存字节数，在内存重分配或zlend位置时使用\n+ `zltail`：记录压缩列表表尾节点距压缩列表的起始地址有多少字节，通过该偏移量，可无须遍历整个压缩列表就可以确定表尾节点的地址\n+ `zllen`：记录了压缩列表包含的节点数量\n+ `entryX`：压缩列表包含的各个节点，节点长度由节点包含的内容决定\n+ `zlend`：特殊值oxFF,用于标记压缩列表的末端\n\n# 压缩列表节点的构成\n\n## previous_entry_length\n\n以字节为单位，记录压缩列表**前一个节点**的长度。所以可以通过指针运算，根据当前节点的起始地址得到前一个节点的起始地址，用于从表尾到表头的遍历\n\n指向表尾节点的指针 可以通过压缩列表的起始地址的指针加上`zltail`\n\n## encoding\n\n记录节点的`content`属性所保存数据的类型及长度\n\n## content\n\n负责保存节点的值，值的类型和属性由`encoding`决定\n\n\n\n# 连锁更新\n\n如果在压缩列表中，有多个介于250-153字节的节点e1-eN,记录这些节点的长度只需要1字节长的**previous_entry_length**，所以e1-eN所有节点的**previous_entry_length**都是1字节长\n\n但如果将一个大于254字节的新节点new加入压缩列表的头节点，则new成为e1的前置节点。而这样e1的**previous_entry_length**属性不足以保存new的长度，所以进行空间重分配，变成5字节大小\n\n这样e1的长度大于254字节了，e2的**previous_entry_length**也不足以保存e1的长度，也扩展成5字节大小。这样就进行连续多次空间扩展，即连锁更新\n\n删除节点也会引发连锁更新\n\n连锁更新在最坏情况下需要对压缩列表进行N次空间重分配操作，每次操作最坏`O(N)`,所以连锁更新最坏时间复杂度为`O(N^2)​`.\n\n但是发生的机率比较低：1. 恰好有多个连续的，长度介于250-153字节的节点的情况并不多见 2. 即使出现连锁更新，只要被更新的节点数量不多，就不会对性能有影响所以平均复杂度为O(N)\n\n\n\n","slug":"Redis笔记/7.压缩列表","published":1,"updated":"2020-11-12T11:57:29.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wo0025jotp9ze701zz","content":"<h1 id=\"压缩列表的构成\"><a href=\"#压缩列表的构成\" class=\"headerlink\" title=\"压缩列表的构成\"></a>压缩列表的构成</h1><p>压缩列表是列表键和哈希键的底层实现之一,当一个列表键只包含少量列表项,并且每个列表项都是<strong>小整数或较短字符串</strong>，则用压缩列表作为底层实现</p>\n<p>压缩列表是为了<strong>节约内存</strong>而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构</p>\n<ul>\n<li><code>zlbytes</code>:记录整个压缩列表所占用的内存字节数，在内存重分配或zlend位置时使用</li>\n<li><code>zltail</code>：记录压缩列表表尾节点距压缩列表的起始地址有多少字节，通过该偏移量，可无须遍历整个压缩列表就可以确定表尾节点的地址</li>\n<li><code>zllen</code>：记录了压缩列表包含的节点数量</li>\n<li><code>entryX</code>：压缩列表包含的各个节点，节点长度由节点包含的内容决定</li>\n<li><code>zlend</code>：特殊值oxFF,用于标记压缩列表的末端</li>\n</ul>\n<h1 id=\"压缩列表节点的构成\"><a href=\"#压缩列表节点的构成\" class=\"headerlink\" title=\"压缩列表节点的构成\"></a>压缩列表节点的构成</h1><h2 id=\"previous-entry-length\"><a href=\"#previous-entry-length\" class=\"headerlink\" title=\"previous_entry_length\"></a>previous_entry_length</h2><p>以字节为单位，记录压缩列表<strong>前一个节点</strong>的长度。所以可以通过指针运算，根据当前节点的起始地址得到前一个节点的起始地址，用于从表尾到表头的遍历</p>\n<p>指向表尾节点的指针 可以通过压缩列表的起始地址的指针加上<code>zltail</code></p>\n<h2 id=\"encoding\"><a href=\"#encoding\" class=\"headerlink\" title=\"encoding\"></a>encoding</h2><p>记录节点的<code>content</code>属性所保存数据的类型及长度</p>\n<h2 id=\"content\"><a href=\"#content\" class=\"headerlink\" title=\"content\"></a>content</h2><p>负责保存节点的值，值的类型和属性由<code>encoding</code>决定</p>\n<h1 id=\"连锁更新\"><a href=\"#连锁更新\" class=\"headerlink\" title=\"连锁更新\"></a>连锁更新</h1><p>如果在压缩列表中，有多个介于250-153字节的节点e1-eN,记录这些节点的长度只需要1字节长的<strong>previous_entry_length</strong>，所以e1-eN所有节点的<strong>previous_entry_length</strong>都是1字节长</p>\n<p>但如果将一个大于254字节的新节点new加入压缩列表的头节点，则new成为e1的前置节点。而这样e1的<strong>previous_entry_length</strong>属性不足以保存new的长度，所以进行空间重分配，变成5字节大小</p>\n<p>这样e1的长度大于254字节了，e2的<strong>previous_entry_length</strong>也不足以保存e1的长度，也扩展成5字节大小。这样就进行连续多次空间扩展，即连锁更新</p>\n<p>删除节点也会引发连锁更新</p>\n<p>连锁更新在最坏情况下需要对压缩列表进行N次空间重分配操作，每次操作最坏<code>O(N)</code>,所以连锁更新最坏时间复杂度为<code>O(N^2)​</code>.</p>\n<p>但是发生的机率比较低：1. 恰好有多个连续的，长度介于250-153字节的节点的情况并不多见 2. 即使出现连锁更新，只要被更新的节点数量不多，就不会对性能有影响所以平均复杂度为O(N)</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"压缩列表的构成\"><a href=\"#压缩列表的构成\" class=\"headerlink\" title=\"压缩列表的构成\"></a>压缩列表的构成</h1><p>压缩列表是列表键和哈希键的底层实现之一,当一个列表键只包含少量列表项,并且每个列表项都是<strong>小整数或较短字符串</strong>，则用压缩列表作为底层实现</p>\n<p>压缩列表是为了<strong>节约内存</strong>而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构</p>\n<ul>\n<li><code>zlbytes</code>:记录整个压缩列表所占用的内存字节数，在内存重分配或zlend位置时使用</li>\n<li><code>zltail</code>：记录压缩列表表尾节点距压缩列表的起始地址有多少字节，通过该偏移量，可无须遍历整个压缩列表就可以确定表尾节点的地址</li>\n<li><code>zllen</code>：记录了压缩列表包含的节点数量</li>\n<li><code>entryX</code>：压缩列表包含的各个节点，节点长度由节点包含的内容决定</li>\n<li><code>zlend</code>：特殊值oxFF,用于标记压缩列表的末端</li>\n</ul>\n<h1 id=\"压缩列表节点的构成\"><a href=\"#压缩列表节点的构成\" class=\"headerlink\" title=\"压缩列表节点的构成\"></a>压缩列表节点的构成</h1><h2 id=\"previous-entry-length\"><a href=\"#previous-entry-length\" class=\"headerlink\" title=\"previous_entry_length\"></a>previous_entry_length</h2><p>以字节为单位，记录压缩列表<strong>前一个节点</strong>的长度。所以可以通过指针运算，根据当前节点的起始地址得到前一个节点的起始地址，用于从表尾到表头的遍历</p>\n<p>指向表尾节点的指针 可以通过压缩列表的起始地址的指针加上<code>zltail</code></p>\n<h2 id=\"encoding\"><a href=\"#encoding\" class=\"headerlink\" title=\"encoding\"></a>encoding</h2><p>记录节点的<code>content</code>属性所保存数据的类型及长度</p>\n<h2 id=\"content\"><a href=\"#content\" class=\"headerlink\" title=\"content\"></a>content</h2><p>负责保存节点的值，值的类型和属性由<code>encoding</code>决定</p>\n<h1 id=\"连锁更新\"><a href=\"#连锁更新\" class=\"headerlink\" title=\"连锁更新\"></a>连锁更新</h1><p>如果在压缩列表中，有多个介于250-153字节的节点e1-eN,记录这些节点的长度只需要1字节长的<strong>previous_entry_length</strong>，所以e1-eN所有节点的<strong>previous_entry_length</strong>都是1字节长</p>\n<p>但如果将一个大于254字节的新节点new加入压缩列表的头节点，则new成为e1的前置节点。而这样e1的<strong>previous_entry_length</strong>属性不足以保存new的长度，所以进行空间重分配，变成5字节大小</p>\n<p>这样e1的长度大于254字节了，e2的<strong>previous_entry_length</strong>也不足以保存e1的长度，也扩展成5字节大小。这样就进行连续多次空间扩展，即连锁更新</p>\n<p>删除节点也会引发连锁更新</p>\n<p>连锁更新在最坏情况下需要对压缩列表进行N次空间重分配操作，每次操作最坏<code>O(N)</code>,所以连锁更新最坏时间复杂度为<code>O(N^2)​</code>.</p>\n<p>但是发生的机率比较低：1. 恰好有多个连续的，长度介于250-153字节的节点的情况并不多见 2. 即使出现连锁更新，只要被更新的节点数量不多，就不会对性能有影响所以平均复杂度为O(N)</p>\n"},{"title":"《Redis设计与实现》-------数据库","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第九章--数据库。","abbrlink":"f6b4575b","date":"2020-09-11T16:00:00.000Z","_content":"\n# 服务器中的数据库\n\n```c\nstruct redisServer\n{\n\tint dbnum;//服务器的数据库数量\n\tredisDb *db; //一个数组,保存着服务器中的所有数据库 默认16\n}\n```\n\n# 切换数据库\n\n每个Redis客户端都有个目标数据库,每当客户端执行数据库读写命令时,目标数据库就成为这些命令的操作对象.默认目标数据库为0号数据库\n\n```c\ntypedef struct redisClient\n{\n\tredisDb * db;//记录客户端当前使用的数据库\n}redisClient;\n```\n\n# 数据库键空间\n\n```c\ntypedef struct redisDb\n{\n\tdict *dict;//数据库键空间,保存着数据库中的所有键值对\n} redisDb;\n```\n\n键空间的键是一个字符串对象,值可以是字符串对象,列表对象,哈希表对象,集合对象,有序集合对象\n\n所有针对数据库的操作,都是通过对键空间字典进行操作实现的\n\n## 添加新键\n\n就是将新键值对添加到键空间字典里面\n\n## 读写键空间时的维护操作\n\n+ 在读取一个键后(读写操作都要对键进行读取),服务器会根据键是否存在来更新服务器的键空间命中次数\n+ 在读取一个键后,会更新LRU时间,可以计算键的闲置时间\n+ 在读取一个键若发现该键已过期,则会先删除过期键\n+ 在对被监视的键进行修改后,会标记为脏,让事务程序注意该键已经被修改\n\n# 设置键的生存时间或过期时间\n\n## 设置过期时间\n\n1. EXPIRE 设置过期时间,单位为秒\n2. PEXPIRE 设置过期时间,单位为毫秒\n3. EXPIREAT 设置过期时间为秒数时间戳\n4. PEXPIREAT 设置过期时间为毫秒数时间戳\n\n最后都是转换为PEXPIREAT来执行的\n\n## 保存过期时间\n\n```c\ntypedef struct redisDb\n{\n\tdict *dict;//数据库键空间,保存着数据库中的所有键值对\n\tdict *expires;//保存了数据库中所有键的过期时间,过期字典\n\t//指向的键就是键空间某个键\n\t//指向的值为long long类型的过期时间,一个毫秒精度的UNIX时间戳\n} redisDb;\n```\n\n键空间的键和过期字典的键都指向同一个键对象,不会出现任何重复对象,也不会浪费任何空间\n\n```python\ndef PEXPIREAT(key,expire_time_in_ms)\n{\n \t#如果给定的键不存在键空间,那么不能设置过期时间\n    if key not in redisDb.dict:\n    \treturn 0\n    #在过期字典中关联键和过期时间\n    redisDb.expires[key]=expire_time_in_ms\n    # 过期时间设置成功\n    return 1\n}\n```\n\n## 移除过期时间\n\n```python\ndef PERSIST(key):\n    #如果给定的键不存在或没设置过期时间,那么直接返回\n     if key not in redisDb.expires:\n    \treturn 0\n    #移除过期字典中给定键的键值对关联\n    redisDb.expires.remove(key)\n    #移除成功\n    return 1\n```\n\n## 计算并返回剩余生存时间\n\n```python\ndef PTTL(key):\n    #如果给定的键不存在数据库\n    if key not in redisDb.dict:\n    \treturn -2\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n    \n    if expire_time_in_ms is None:\n        return -1\n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n    return (expire_time_in_ms - now_ms)\n```\n\n```python\ndef TTL(key):\n    ttl_in_ms = PTTL(key)\n    if ttl_in_ms<0:\n        //处理为-2,-1的异常情况\n        return ttl_in_ms\n    else:\n        #将毫秒转为秒\n        return ms_to_sec(ttl_in_ms)\n    \n```\n\n## 过期键的判断\n\n```python\ndef is_expired(key):\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n    \n    if expire_time_in_ms is None:\n        return False\n    \n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n    \n    if  now_ms>expire_time_in_ms:\n        return True # 已过期\n    else:\n        return False\n```\n\n# 过期键删除策略\n\n## 定时删除\n\n在设置键的过期时间的同时,创建一个定时器,让定时器在键的过期时间来临时,立即执行对键的删除操作\n\n可以保证过期键会尽可能快地被删除,并释放过期键所占用的内存\n\n对CPU时间最不友好\n\n不太现实\n\n## 惰性删除\n\n每次取出键都会检查是否过期,过期则删除\n\n只有在取出键时才会对键进行过期检查,对CPU时间最友好\n\n对内存最不友好,会导致内存泄漏:无用的垃圾数据占用了大量内存\n\n如日志,当不再使用时,会大量积压在数据库,用户以为自动删除了,其实还存在\n\n## 定期删除\n\n每隔一段时间进行检查,删除里面的过期键\n\n是前两种的整合与折中\n\n必须合理地设置删除操作的执行时间和执行效率\n\n# Redis过期键删除策略\n\n配合使用惰性删除和定期删除两种\n\n## 惰性删除策略的实现\n\n采用expireIfNeeded函数,如果过期则将键删除。就像过滤器，在命令真正执行前，过滤掉过期的输入键，避免命令接触到过期键\n\n所以每个命令的实现函数必须能同时处理键存在和不存在两种情况\n\n## 定期删除策略实现\n\n```python\n# coding=utf-8\n# 默认每次检查的数据库数量\nDEFAULT_DB_NUMBERS = 16\n\n# 默认每个数据库检查的键数量\nDEFAULT_KEY_NUMBERS = 20\n\n# 全局变量,记录检查进度\ncurrent_db = 0\n\n\ndef activeExpireCycle():\n    # 初始化要检查的数据库数量\n    # 以服务器的数据库数量为主\n    if serer.dbnum < DEFAULT_DB_NUMBERS:\n        db_numbers = serer.dbnum\n    else:\n        db_numbers = DEFAULT_DB_NUMBERS\n\n    #遍历每个数据库\n    for i in range(db_numbers):\n        #如果current_db=服务器的数据库数量\n        #则表示已经遍历了服务器的所有数据库一次\n        #将current_db=重置为0,开始新一轮\n        if current_db==server.dbnum:\n            current_db=0\n        \n        #获取当前要处理的数据库\n        redisDb=server.db[current_db]\n        \n        #指向下一个要处理的数据库\n        current_db+=1\n        \n        #检查数据库的键\n        for j in range(DEFAULT_KEY_NUMBERS):\n            #如果数据库中没有一个键带有过期时间,则跳过该数据库\n            if redisDb.expires.size()==0:\n                break\n            \n            #随机获取一个带过期时间的键\n            key_with_ttl=redisDb.expires.get_random_key()\n            \n            if is_expired(key_with_ttl):\n                delete_key(key_with_ttl)\n                \n            # 已到达时间上限,停止处理\n            if reach_time_limit():\n                return \n```\n\n","source":"_posts/Redis笔记/9.数据库.md","raw":"---\ntitle: 《Redis设计与实现》-------数据库\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第九章--数据库。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - 数据库\nabbrlink: f6b4575b\ndate: 2020-09-12 00:00:00\n---\n\n# 服务器中的数据库\n\n```c\nstruct redisServer\n{\n\tint dbnum;//服务器的数据库数量\n\tredisDb *db; //一个数组,保存着服务器中的所有数据库 默认16\n}\n```\n\n# 切换数据库\n\n每个Redis客户端都有个目标数据库,每当客户端执行数据库读写命令时,目标数据库就成为这些命令的操作对象.默认目标数据库为0号数据库\n\n```c\ntypedef struct redisClient\n{\n\tredisDb * db;//记录客户端当前使用的数据库\n}redisClient;\n```\n\n# 数据库键空间\n\n```c\ntypedef struct redisDb\n{\n\tdict *dict;//数据库键空间,保存着数据库中的所有键值对\n} redisDb;\n```\n\n键空间的键是一个字符串对象,值可以是字符串对象,列表对象,哈希表对象,集合对象,有序集合对象\n\n所有针对数据库的操作,都是通过对键空间字典进行操作实现的\n\n## 添加新键\n\n就是将新键值对添加到键空间字典里面\n\n## 读写键空间时的维护操作\n\n+ 在读取一个键后(读写操作都要对键进行读取),服务器会根据键是否存在来更新服务器的键空间命中次数\n+ 在读取一个键后,会更新LRU时间,可以计算键的闲置时间\n+ 在读取一个键若发现该键已过期,则会先删除过期键\n+ 在对被监视的键进行修改后,会标记为脏,让事务程序注意该键已经被修改\n\n# 设置键的生存时间或过期时间\n\n## 设置过期时间\n\n1. EXPIRE 设置过期时间,单位为秒\n2. PEXPIRE 设置过期时间,单位为毫秒\n3. EXPIREAT 设置过期时间为秒数时间戳\n4. PEXPIREAT 设置过期时间为毫秒数时间戳\n\n最后都是转换为PEXPIREAT来执行的\n\n## 保存过期时间\n\n```c\ntypedef struct redisDb\n{\n\tdict *dict;//数据库键空间,保存着数据库中的所有键值对\n\tdict *expires;//保存了数据库中所有键的过期时间,过期字典\n\t//指向的键就是键空间某个键\n\t//指向的值为long long类型的过期时间,一个毫秒精度的UNIX时间戳\n} redisDb;\n```\n\n键空间的键和过期字典的键都指向同一个键对象,不会出现任何重复对象,也不会浪费任何空间\n\n```python\ndef PEXPIREAT(key,expire_time_in_ms)\n{\n \t#如果给定的键不存在键空间,那么不能设置过期时间\n    if key not in redisDb.dict:\n    \treturn 0\n    #在过期字典中关联键和过期时间\n    redisDb.expires[key]=expire_time_in_ms\n    # 过期时间设置成功\n    return 1\n}\n```\n\n## 移除过期时间\n\n```python\ndef PERSIST(key):\n    #如果给定的键不存在或没设置过期时间,那么直接返回\n     if key not in redisDb.expires:\n    \treturn 0\n    #移除过期字典中给定键的键值对关联\n    redisDb.expires.remove(key)\n    #移除成功\n    return 1\n```\n\n## 计算并返回剩余生存时间\n\n```python\ndef PTTL(key):\n    #如果给定的键不存在数据库\n    if key not in redisDb.dict:\n    \treturn -2\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n    \n    if expire_time_in_ms is None:\n        return -1\n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n    return (expire_time_in_ms - now_ms)\n```\n\n```python\ndef TTL(key):\n    ttl_in_ms = PTTL(key)\n    if ttl_in_ms<0:\n        //处理为-2,-1的异常情况\n        return ttl_in_ms\n    else:\n        #将毫秒转为秒\n        return ms_to_sec(ttl_in_ms)\n    \n```\n\n## 过期键的判断\n\n```python\ndef is_expired(key):\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n    \n    if expire_time_in_ms is None:\n        return False\n    \n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n    \n    if  now_ms>expire_time_in_ms:\n        return True # 已过期\n    else:\n        return False\n```\n\n# 过期键删除策略\n\n## 定时删除\n\n在设置键的过期时间的同时,创建一个定时器,让定时器在键的过期时间来临时,立即执行对键的删除操作\n\n可以保证过期键会尽可能快地被删除,并释放过期键所占用的内存\n\n对CPU时间最不友好\n\n不太现实\n\n## 惰性删除\n\n每次取出键都会检查是否过期,过期则删除\n\n只有在取出键时才会对键进行过期检查,对CPU时间最友好\n\n对内存最不友好,会导致内存泄漏:无用的垃圾数据占用了大量内存\n\n如日志,当不再使用时,会大量积压在数据库,用户以为自动删除了,其实还存在\n\n## 定期删除\n\n每隔一段时间进行检查,删除里面的过期键\n\n是前两种的整合与折中\n\n必须合理地设置删除操作的执行时间和执行效率\n\n# Redis过期键删除策略\n\n配合使用惰性删除和定期删除两种\n\n## 惰性删除策略的实现\n\n采用expireIfNeeded函数,如果过期则将键删除。就像过滤器，在命令真正执行前，过滤掉过期的输入键，避免命令接触到过期键\n\n所以每个命令的实现函数必须能同时处理键存在和不存在两种情况\n\n## 定期删除策略实现\n\n```python\n# coding=utf-8\n# 默认每次检查的数据库数量\nDEFAULT_DB_NUMBERS = 16\n\n# 默认每个数据库检查的键数量\nDEFAULT_KEY_NUMBERS = 20\n\n# 全局变量,记录检查进度\ncurrent_db = 0\n\n\ndef activeExpireCycle():\n    # 初始化要检查的数据库数量\n    # 以服务器的数据库数量为主\n    if serer.dbnum < DEFAULT_DB_NUMBERS:\n        db_numbers = serer.dbnum\n    else:\n        db_numbers = DEFAULT_DB_NUMBERS\n\n    #遍历每个数据库\n    for i in range(db_numbers):\n        #如果current_db=服务器的数据库数量\n        #则表示已经遍历了服务器的所有数据库一次\n        #将current_db=重置为0,开始新一轮\n        if current_db==server.dbnum:\n            current_db=0\n        \n        #获取当前要处理的数据库\n        redisDb=server.db[current_db]\n        \n        #指向下一个要处理的数据库\n        current_db+=1\n        \n        #检查数据库的键\n        for j in range(DEFAULT_KEY_NUMBERS):\n            #如果数据库中没有一个键带有过期时间,则跳过该数据库\n            if redisDb.expires.size()==0:\n                break\n            \n            #随机获取一个带过期时间的键\n            key_with_ttl=redisDb.expires.get_random_key()\n            \n            if is_expired(key_with_ttl):\n                delete_key(key_with_ttl)\n                \n            # 已到达时间上限,停止处理\n            if reach_time_limit():\n                return \n```\n\n","slug":"Redis笔记/9.数据库","published":1,"updated":"2020-11-12T11:57:29.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6ws0029jotp9upycyf5","content":"<h1 id=\"服务器中的数据库\"><a href=\"#服务器中的数据库\" class=\"headerlink\" title=\"服务器中的数据库\"></a>服务器中的数据库</h1><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> redisServer\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> dbnum<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//服务器的数据库数量</span>\n    redisDb <span class=\"token operator\">*</span>db<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//一个数组,保存着服务器中的所有数据库 默认16</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"切换数据库\"><a href=\"#切换数据库\" class=\"headerlink\" title=\"切换数据库\"></a>切换数据库</h1><p>每个Redis客户端都有个目标数据库,每当客户端执行数据库读写命令时,目标数据库就成为这些命令的操作对象.默认目标数据库为0号数据库</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> redisClient\n<span class=\"token punctuation\">{</span>\n    redisDb <span class=\"token operator\">*</span> db<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//记录客户端当前使用的数据库</span>\n<span class=\"token punctuation\">}</span>redisClient<span class=\"token punctuation\">;</span></code></pre>\n<h1 id=\"数据库键空间\"><a href=\"#数据库键空间\" class=\"headerlink\" title=\"数据库键空间\"></a>数据库键空间</h1><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> redisDb\n<span class=\"token punctuation\">{</span>\n    dict <span class=\"token operator\">*</span>dict<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//数据库键空间,保存着数据库中的所有键值对</span>\n<span class=\"token punctuation\">}</span> redisDb<span class=\"token punctuation\">;</span></code></pre>\n<p>键空间的键是一个字符串对象,值可以是字符串对象,列表对象,哈希表对象,集合对象,有序集合对象</p>\n<p>所有针对数据库的操作,都是通过对键空间字典进行操作实现的</p>\n<h2 id=\"添加新键\"><a href=\"#添加新键\" class=\"headerlink\" title=\"添加新键\"></a>添加新键</h2><p>就是将新键值对添加到键空间字典里面</p>\n<h2 id=\"读写键空间时的维护操作\"><a href=\"#读写键空间时的维护操作\" class=\"headerlink\" title=\"读写键空间时的维护操作\"></a>读写键空间时的维护操作</h2><ul>\n<li>在读取一个键后(读写操作都要对键进行读取),服务器会根据键是否存在来更新服务器的键空间命中次数</li>\n<li>在读取一个键后,会更新LRU时间,可以计算键的闲置时间</li>\n<li>在读取一个键若发现该键已过期,则会先删除过期键</li>\n<li>在对被监视的键进行修改后,会标记为脏,让事务程序注意该键已经被修改</li>\n</ul>\n<h1 id=\"设置键的生存时间或过期时间\"><a href=\"#设置键的生存时间或过期时间\" class=\"headerlink\" title=\"设置键的生存时间或过期时间\"></a>设置键的生存时间或过期时间</h1><h2 id=\"设置过期时间\"><a href=\"#设置过期时间\" class=\"headerlink\" title=\"设置过期时间\"></a>设置过期时间</h2><ol>\n<li>EXPIRE 设置过期时间,单位为秒</li>\n<li>PEXPIRE 设置过期时间,单位为毫秒</li>\n<li>EXPIREAT 设置过期时间为秒数时间戳</li>\n<li>PEXPIREAT 设置过期时间为毫秒数时间戳</li>\n</ol>\n<p>最后都是转换为PEXPIREAT来执行的</p>\n<h2 id=\"保存过期时间\"><a href=\"#保存过期时间\" class=\"headerlink\" title=\"保存过期时间\"></a>保存过期时间</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> redisDb\n<span class=\"token punctuation\">{</span>\n    dict <span class=\"token operator\">*</span>dict<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//数据库键空间,保存着数据库中的所有键值对</span>\n    dict <span class=\"token operator\">*</span>expires<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//保存了数据库中所有键的过期时间,过期字典</span>\n    <span class=\"token comment\" spellcheck=\"true\">//指向的键就是键空间某个键</span>\n    <span class=\"token comment\" spellcheck=\"true\">//指向的值为long long类型的过期时间,一个毫秒精度的UNIX时间戳</span>\n<span class=\"token punctuation\">}</span> redisDb<span class=\"token punctuation\">;</span></code></pre>\n<p>键空间的键和过期字典的键都指向同一个键对象,不会出现任何重复对象,也不会浪费任何空间</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">PEXPIREAT</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span>expire_time_in_ms<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n     <span class=\"token comment\" spellcheck=\"true\">#如果给定的键不存在键空间,那么不能设置过期时间</span>\n    <span class=\"token keyword\">if</span> key <span class=\"token operator\">not</span> <span class=\"token keyword\">in</span> redisDb<span class=\"token punctuation\">.</span>dict<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n    <span class=\"token comment\" spellcheck=\"true\">#在过期字典中关联键和过期时间</span>\n    redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>expire_time_in_ms\n    <span class=\"token comment\" spellcheck=\"true\"># 过期时间设置成功</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"移除过期时间\"><a href=\"#移除过期时间\" class=\"headerlink\" title=\"移除过期时间\"></a>移除过期时间</h2><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">PERSIST</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#如果给定的键不存在或没设置过期时间,那么直接返回</span>\n     <span class=\"token keyword\">if</span> key <span class=\"token operator\">not</span> <span class=\"token keyword\">in</span> redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n    <span class=\"token comment\" spellcheck=\"true\">#移除过期字典中给定键的键值对关联</span>\n    redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">#移除成功</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span></code></pre>\n<h2 id=\"计算并返回剩余生存时间\"><a href=\"#计算并返回剩余生存时间\" class=\"headerlink\" title=\"计算并返回剩余生存时间\"></a>计算并返回剩余生存时间</h2><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">PTTL</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#如果给定的键不存在数据库</span>\n    <span class=\"token keyword\">if</span> key <span class=\"token operator\">not</span> <span class=\"token keyword\">in</span> redisDb<span class=\"token punctuation\">.</span>dict<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">2</span>\n    <span class=\"token comment\" spellcheck=\"true\">#尝试获取过期时间</span>\n    <span class=\"token comment\" spellcheck=\"true\">#没有则为None</span>\n    expire_time_in_ms<span class=\"token operator\">=</span>redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> expire_time_in_ms <span class=\"token keyword\">is</span> None<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 获取当前时间时间戳</span>\n    now_ms<span class=\"token operator\">=</span>get_current_unix_timestamp_in_ms<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>expire_time_in_ms <span class=\"token operator\">-</span> now_ms<span class=\"token punctuation\">)</span></code></pre>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">TTL</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    ttl_in_ms <span class=\"token operator\">=</span> PTTL<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> ttl_in_ms<span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token operator\">//</span>处理为<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1</span>的异常情况\n        <span class=\"token keyword\">return</span> ttl_in_ms\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">#将毫秒转为秒</span>\n        <span class=\"token keyword\">return</span> ms_to_sec<span class=\"token punctuation\">(</span>ttl_in_ms<span class=\"token punctuation\">)</span>\n</code></pre>\n<h2 id=\"过期键的判断\"><a href=\"#过期键的判断\" class=\"headerlink\" title=\"过期键的判断\"></a>过期键的判断</h2><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">is_expired</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#尝试获取过期时间</span>\n    <span class=\"token comment\" spellcheck=\"true\">#没有则为None</span>\n    expire_time_in_ms<span class=\"token operator\">=</span>redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> expire_time_in_ms <span class=\"token keyword\">is</span> None<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># 获取当前时间时间戳</span>\n    now_ms<span class=\"token operator\">=</span>get_current_unix_timestamp_in_ms<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span>  now_ms<span class=\"token operator\">></span>expire_time_in_ms<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span> <span class=\"token comment\" spellcheck=\"true\"># 已过期</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span></code></pre>\n<h1 id=\"过期键删除策略\"><a href=\"#过期键删除策略\" class=\"headerlink\" title=\"过期键删除策略\"></a>过期键删除策略</h1><h2 id=\"定时删除\"><a href=\"#定时删除\" class=\"headerlink\" title=\"定时删除\"></a>定时删除</h2><p>在设置键的过期时间的同时,创建一个定时器,让定时器在键的过期时间来临时,立即执行对键的删除操作</p>\n<p>可以保证过期键会尽可能快地被删除,并释放过期键所占用的内存</p>\n<p>对CPU时间最不友好</p>\n<p>不太现实</p>\n<h2 id=\"惰性删除\"><a href=\"#惰性删除\" class=\"headerlink\" title=\"惰性删除\"></a>惰性删除</h2><p>每次取出键都会检查是否过期,过期则删除</p>\n<p>只有在取出键时才会对键进行过期检查,对CPU时间最友好</p>\n<p>对内存最不友好,会导致内存泄漏:无用的垃圾数据占用了大量内存</p>\n<p>如日志,当不再使用时,会大量积压在数据库,用户以为自动删除了,其实还存在</p>\n<h2 id=\"定期删除\"><a href=\"#定期删除\" class=\"headerlink\" title=\"定期删除\"></a>定期删除</h2><p>每隔一段时间进行检查,删除里面的过期键</p>\n<p>是前两种的整合与折中</p>\n<p>必须合理地设置删除操作的执行时间和执行效率</p>\n<h1 id=\"Redis过期键删除策略\"><a href=\"#Redis过期键删除策略\" class=\"headerlink\" title=\"Redis过期键删除策略\"></a>Redis过期键删除策略</h1><p>配合使用惰性删除和定期删除两种</p>\n<h2 id=\"惰性删除策略的实现\"><a href=\"#惰性删除策略的实现\" class=\"headerlink\" title=\"惰性删除策略的实现\"></a>惰性删除策略的实现</h2><p>采用expireIfNeeded函数,如果过期则将键删除。就像过滤器，在命令真正执行前，过滤掉过期的输入键，避免命令接触到过期键</p>\n<p>所以每个命令的实现函数必须能同时处理键存在和不存在两种情况</p>\n<h2 id=\"定期删除策略实现\"><a href=\"#定期删除策略实现\" class=\"headerlink\" title=\"定期删除策略实现\"></a>定期删除策略实现</h2><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># coding=utf-8</span>\n<span class=\"token comment\" spellcheck=\"true\"># 默认每次检查的数据库数量</span>\nDEFAULT_DB_NUMBERS <span class=\"token operator\">=</span> <span class=\"token number\">16</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 默认每个数据库检查的键数量</span>\nDEFAULT_KEY_NUMBERS <span class=\"token operator\">=</span> <span class=\"token number\">20</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 全局变量,记录检查进度</span>\ncurrent_db <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">activeExpireCycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 初始化要检查的数据库数量</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 以服务器的数据库数量为主</span>\n    <span class=\"token keyword\">if</span> serer<span class=\"token punctuation\">.</span>dbnum <span class=\"token operator\">&lt;</span> DEFAULT_DB_NUMBERS<span class=\"token punctuation\">:</span>\n        db_numbers <span class=\"token operator\">=</span> serer<span class=\"token punctuation\">.</span>dbnum\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        db_numbers <span class=\"token operator\">=</span> DEFAULT_DB_NUMBERS\n\n    <span class=\"token comment\" spellcheck=\"true\">#遍历每个数据库</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span>db_numbers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">#如果current_db=服务器的数据库数量</span>\n        <span class=\"token comment\" spellcheck=\"true\">#则表示已经遍历了服务器的所有数据库一次</span>\n        <span class=\"token comment\" spellcheck=\"true\">#将current_db=重置为0,开始新一轮</span>\n        <span class=\"token keyword\">if</span> current_db<span class=\"token operator\">==</span>server<span class=\"token punctuation\">.</span>dbnum<span class=\"token punctuation\">:</span>\n            current_db<span class=\"token operator\">=</span><span class=\"token number\">0</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#获取当前要处理的数据库</span>\n        redisDb<span class=\"token operator\">=</span>server<span class=\"token punctuation\">.</span>db<span class=\"token punctuation\">[</span>current_db<span class=\"token punctuation\">]</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#指向下一个要处理的数据库</span>\n        current_db<span class=\"token operator\">+=</span><span class=\"token number\">1</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#检查数据库的键</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span>DEFAULT_KEY_NUMBERS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\" spellcheck=\"true\">#如果数据库中没有一个键带有过期时间,则跳过该数据库</span>\n            <span class=\"token keyword\">if</span> redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">break</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">#随机获取一个带过期时间的键</span>\n            key_with_ttl<span class=\"token operator\">=</span>redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">.</span>get_random_key<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n            <span class=\"token keyword\">if</span> is_expired<span class=\"token punctuation\">(</span>key_with_ttl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                delete_key<span class=\"token punctuation\">(</span>key_with_ttl<span class=\"token punctuation\">)</span>\n\n            <span class=\"token comment\" spellcheck=\"true\"># 已到达时间上限,停止处理</span>\n            <span class=\"token keyword\">if</span> reach_time_limit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> </code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"服务器中的数据库\"><a href=\"#服务器中的数据库\" class=\"headerlink\" title=\"服务器中的数据库\"></a>服务器中的数据库</h1><pre><code class=\"c\">struct redisServer\n{\n    int dbnum;//服务器的数据库数量\n    redisDb *db; //一个数组,保存着服务器中的所有数据库 默认16\n}</code></pre>\n<h1 id=\"切换数据库\"><a href=\"#切换数据库\" class=\"headerlink\" title=\"切换数据库\"></a>切换数据库</h1><p>每个Redis客户端都有个目标数据库,每当客户端执行数据库读写命令时,目标数据库就成为这些命令的操作对象.默认目标数据库为0号数据库</p>\n<pre><code class=\"c\">typedef struct redisClient\n{\n    redisDb * db;//记录客户端当前使用的数据库\n}redisClient;</code></pre>\n<h1 id=\"数据库键空间\"><a href=\"#数据库键空间\" class=\"headerlink\" title=\"数据库键空间\"></a>数据库键空间</h1><pre><code class=\"c\">typedef struct redisDb\n{\n    dict *dict;//数据库键空间,保存着数据库中的所有键值对\n} redisDb;</code></pre>\n<p>键空间的键是一个字符串对象,值可以是字符串对象,列表对象,哈希表对象,集合对象,有序集合对象</p>\n<p>所有针对数据库的操作,都是通过对键空间字典进行操作实现的</p>\n<h2 id=\"添加新键\"><a href=\"#添加新键\" class=\"headerlink\" title=\"添加新键\"></a>添加新键</h2><p>就是将新键值对添加到键空间字典里面</p>\n<h2 id=\"读写键空间时的维护操作\"><a href=\"#读写键空间时的维护操作\" class=\"headerlink\" title=\"读写键空间时的维护操作\"></a>读写键空间时的维护操作</h2><ul>\n<li>在读取一个键后(读写操作都要对键进行读取),服务器会根据键是否存在来更新服务器的键空间命中次数</li>\n<li>在读取一个键后,会更新LRU时间,可以计算键的闲置时间</li>\n<li>在读取一个键若发现该键已过期,则会先删除过期键</li>\n<li>在对被监视的键进行修改后,会标记为脏,让事务程序注意该键已经被修改</li>\n</ul>\n<h1 id=\"设置键的生存时间或过期时间\"><a href=\"#设置键的生存时间或过期时间\" class=\"headerlink\" title=\"设置键的生存时间或过期时间\"></a>设置键的生存时间或过期时间</h1><h2 id=\"设置过期时间\"><a href=\"#设置过期时间\" class=\"headerlink\" title=\"设置过期时间\"></a>设置过期时间</h2><ol>\n<li>EXPIRE 设置过期时间,单位为秒</li>\n<li>PEXPIRE 设置过期时间,单位为毫秒</li>\n<li>EXPIREAT 设置过期时间为秒数时间戳</li>\n<li>PEXPIREAT 设置过期时间为毫秒数时间戳</li>\n</ol>\n<p>最后都是转换为PEXPIREAT来执行的</p>\n<h2 id=\"保存过期时间\"><a href=\"#保存过期时间\" class=\"headerlink\" title=\"保存过期时间\"></a>保存过期时间</h2><pre><code class=\"c\">typedef struct redisDb\n{\n    dict *dict;//数据库键空间,保存着数据库中的所有键值对\n    dict *expires;//保存了数据库中所有键的过期时间,过期字典\n    //指向的键就是键空间某个键\n    //指向的值为long long类型的过期时间,一个毫秒精度的UNIX时间戳\n} redisDb;</code></pre>\n<p>键空间的键和过期字典的键都指向同一个键对象,不会出现任何重复对象,也不会浪费任何空间</p>\n<pre><code class=\"python\">def PEXPIREAT(key,expire_time_in_ms)\n{\n     #如果给定的键不存在键空间,那么不能设置过期时间\n    if key not in redisDb.dict:\n        return 0\n    #在过期字典中关联键和过期时间\n    redisDb.expires[key]=expire_time_in_ms\n    # 过期时间设置成功\n    return 1\n}</code></pre>\n<h2 id=\"移除过期时间\"><a href=\"#移除过期时间\" class=\"headerlink\" title=\"移除过期时间\"></a>移除过期时间</h2><pre><code class=\"python\">def PERSIST(key):\n    #如果给定的键不存在或没设置过期时间,那么直接返回\n     if key not in redisDb.expires:\n        return 0\n    #移除过期字典中给定键的键值对关联\n    redisDb.expires.remove(key)\n    #移除成功\n    return 1</code></pre>\n<h2 id=\"计算并返回剩余生存时间\"><a href=\"#计算并返回剩余生存时间\" class=\"headerlink\" title=\"计算并返回剩余生存时间\"></a>计算并返回剩余生存时间</h2><pre><code class=\"python\">def PTTL(key):\n    #如果给定的键不存在数据库\n    if key not in redisDb.dict:\n        return -2\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n\n    if expire_time_in_ms is None:\n        return -1\n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n    return (expire_time_in_ms - now_ms)</code></pre>\n<pre><code class=\"python\">def TTL(key):\n    ttl_in_ms = PTTL(key)\n    if ttl_in_ms&lt;0:\n        //处理为-2,-1的异常情况\n        return ttl_in_ms\n    else:\n        #将毫秒转为秒\n        return ms_to_sec(ttl_in_ms)\n</code></pre>\n<h2 id=\"过期键的判断\"><a href=\"#过期键的判断\" class=\"headerlink\" title=\"过期键的判断\"></a>过期键的判断</h2><pre><code class=\"python\">def is_expired(key):\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n\n    if expire_time_in_ms is None:\n        return False\n\n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n\n    if  now_ms&gt;expire_time_in_ms:\n        return True # 已过期\n    else:\n        return False</code></pre>\n<h1 id=\"过期键删除策略\"><a href=\"#过期键删除策略\" class=\"headerlink\" title=\"过期键删除策略\"></a>过期键删除策略</h1><h2 id=\"定时删除\"><a href=\"#定时删除\" class=\"headerlink\" title=\"定时删除\"></a>定时删除</h2><p>在设置键的过期时间的同时,创建一个定时器,让定时器在键的过期时间来临时,立即执行对键的删除操作</p>\n<p>可以保证过期键会尽可能快地被删除,并释放过期键所占用的内存</p>\n<p>对CPU时间最不友好</p>\n<p>不太现实</p>\n<h2 id=\"惰性删除\"><a href=\"#惰性删除\" class=\"headerlink\" title=\"惰性删除\"></a>惰性删除</h2><p>每次取出键都会检查是否过期,过期则删除</p>\n<p>只有在取出键时才会对键进行过期检查,对CPU时间最友好</p>\n<p>对内存最不友好,会导致内存泄漏:无用的垃圾数据占用了大量内存</p>\n<p>如日志,当不再使用时,会大量积压在数据库,用户以为自动删除了,其实还存在</p>\n<h2 id=\"定期删除\"><a href=\"#定期删除\" class=\"headerlink\" title=\"定期删除\"></a>定期删除</h2><p>每隔一段时间进行检查,删除里面的过期键</p>\n<p>是前两种的整合与折中</p>\n<p>必须合理地设置删除操作的执行时间和执行效率</p>\n<h1 id=\"Redis过期键删除策略\"><a href=\"#Redis过期键删除策略\" class=\"headerlink\" title=\"Redis过期键删除策略\"></a>Redis过期键删除策略</h1><p>配合使用惰性删除和定期删除两种</p>\n<h2 id=\"惰性删除策略的实现\"><a href=\"#惰性删除策略的实现\" class=\"headerlink\" title=\"惰性删除策略的实现\"></a>惰性删除策略的实现</h2><p>采用expireIfNeeded函数,如果过期则将键删除。就像过滤器，在命令真正执行前，过滤掉过期的输入键，避免命令接触到过期键</p>\n<p>所以每个命令的实现函数必须能同时处理键存在和不存在两种情况</p>\n<h2 id=\"定期删除策略实现\"><a href=\"#定期删除策略实现\" class=\"headerlink\" title=\"定期删除策略实现\"></a>定期删除策略实现</h2><pre><code class=\"python\"># coding=utf-8\n# 默认每次检查的数据库数量\nDEFAULT_DB_NUMBERS = 16\n\n# 默认每个数据库检查的键数量\nDEFAULT_KEY_NUMBERS = 20\n\n# 全局变量,记录检查进度\ncurrent_db = 0\n\n\ndef activeExpireCycle():\n    # 初始化要检查的数据库数量\n    # 以服务器的数据库数量为主\n    if serer.dbnum &lt; DEFAULT_DB_NUMBERS:\n        db_numbers = serer.dbnum\n    else:\n        db_numbers = DEFAULT_DB_NUMBERS\n\n    #遍历每个数据库\n    for i in range(db_numbers):\n        #如果current_db=服务器的数据库数量\n        #则表示已经遍历了服务器的所有数据库一次\n        #将current_db=重置为0,开始新一轮\n        if current_db==server.dbnum:\n            current_db=0\n\n        #获取当前要处理的数据库\n        redisDb=server.db[current_db]\n\n        #指向下一个要处理的数据库\n        current_db+=1\n\n        #检查数据库的键\n        for j in range(DEFAULT_KEY_NUMBERS):\n            #如果数据库中没有一个键带有过期时间,则跳过该数据库\n            if redisDb.expires.size()==0:\n                break\n\n            #随机获取一个带过期时间的键\n            key_with_ttl=redisDb.expires.get_random_key()\n\n            if is_expired(key_with_ttl):\n                delete_key(key_with_ttl)\n\n            # 已到达时间上限,停止处理\n            if reach_time_limit():\n                return </code></pre>\n"},{"title":"Hadoop搭建及使用文档","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"Hadoop搭建及使用文档,并配置运行WordCount程序","abbrlink":"80a83e6","date":"2020-09-12T16:00:00.000Z","_content":"\n\n\n# 配置流程\n\n1.  Windows10安装Vmware,并在VMware配置Centos7 linux系统,分配4核CPU,10G内存\n2. 在Centos7中下载docker,配置SSH连接,网络连接\n3. 下载Hadoop镜像（使用的是Github开源的Hadoop镜像**kiwenlau/hadoop-cluster-docker** \n4.  对Hadoop镜像进行配置,启动3个容器，1个master+2个slave,搭建小型分布式集群\n5.  通过SSH连接在idea操纵虚拟机命令行,Xftp操作虚拟机文件系统\n6.  修改start-container.sh,配置docker容器启动方式。通过docker的目录映射,将虚拟机的文件与docker的Hadoop镜像中的文件相互关联,可以方便的在虚拟机中操纵Hadoop的文件。如下图所示，在windows上通过Xftp操作虚拟机的文件，又因为docker的目录映射，可以直接操作Hadoop内的容器。如**run-wordcount.sh**则是配置启动选项的Shell脚本，**input,output**文件夹存放输入输出的相关数据。jar包内存放**WordCount**程序代码\n ![image-20201106143611228](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201106143611228.png)\n8.  寻找网上demo，在本地windows环境用idea写好测试用例，打成jar包放入虚拟机中\n9.  下载的hadoop镜像基于JDK7的，所以进行相应更改\n10.  在run-wordcount.sh中修改输入输出文件位置，需要运行的jar包位置\n11.  对WordCount示例代码进行精读，并进行相关的代码注释\n11.  先对文本进行一些预处理，以及在windows本地测试处理效果\n12.  加入本次数据存储练习需要的词频计算程序逻辑代码\n13.  在Hadoop集群中运行得到根据单词词频降序排列的文件\n14.  对文本结果进行进一步分析与相应处理优化\n\n\n\n\n\n# 实现流程\n\n1. 对给的文本通过**StandardProcessing**程序进行预处理:设置好分隔符,即通过非字符进行分隔,然后取字符串长度大于1,且不包含数字的即可认为是单词,用空格分隔,重新写入一个文件standard_review中\n2. 对文本进行简单的词性还原，同样以空格分割，放入文件中\n3. 通过运行Hadoop集群实现词频统计，输出得到文件output.txt\n4. 对得到的output.txt再次使用Hadoop集群进行处理,得到按频率降序排序的结果，输出到文件result.txt中\n5. 对结果进行进一步处理,如去掉count为1的（对应大文本来说，只出现一次一般就是某些id）、去掉一些不合法的html元素（例如br等标签）。\n\n\n\n# 词性还原判断规则\n\n> 即要求中的（请考虑什么是不同的单词，例如单复数等均为同一个单词，不同时态也为同一个单词）\n\n\n\n# 启动流程\n\n1. 开启虚拟机,用ip addr得到动态ip地址\n2. 用idea ssh连接centos7命令行,xftp连接centos7文件系统\n3. 通过idea的maven插件将WordCount程序打成jar包\n4. 放入容器内的jar文件夹内\n5. `cd hadoop-cluster-docker`\n6. `./start-container.sh`\n7. `./start-hadoop.sh`\n8. `./run-wordcount.sh`\n\n\n\n# 常用命令\n\n```\nvmware查看动态路由:\n\tip addr\n\nhadoop查看内部的输入输出文件:\n    hdfs dfs -cat output/part-r-00000\n    hdfs dfs -ls input\n\nhadoop将输出文件拷贝到docker容器卷:\n\thdfs dfs -cat output/part-r-00000 > output/output.txt\n\t\nhadoop控制执行对应的jar:\n\thadoop far +jar包名称 +mainClass + 输入路径 + 输出路径\n\nhadoop内部日志位置:\n\tcd /usr/local/hadoop/logs\n\t\n查看日志：\n\tconfig/mapred-site.xml下配置程序日志输出位置\n```\n\n\n\n\n\n\n\n# 遇到的问题\n\n## 云服务器运行Demo失败\n\n```\nCaused by: org.apache.spark.SparkException: Job aborted due to stage failure: Task 2 in stage 3.0 failed 4 times, most recent failure: Lost task 2.3 in stage 3.0 (TID 23, ip-xxx-xxx-xx-xxx.compute.internal, executor 4): ExecutorLostFailure (executor 4 exited caused by one of the running tasks) Reason: Container marked as failed: container_1516900607498_6585_01_000008 on host: ip-xxx-xxx-xx-xxx.compute.internal. Exit status: 137. Diagnostics: Container killed on request. Exit code is 137\n```\n\n在阿里云轻量级应用服务器上，跑集群的小demo异常退出，后来发现是内存不够的原因（云服务器只有2g的内存），于是换到windows的虚拟机上\n\n## Hadoop集群连接失败\n\n```\njava.net.ConnectException: Call From xxx to localhost:8020 failed on connection exception: java.net.ConnectException: Connection refused\n```\n\n关闭Centos7防火墙\n\n## 内存溢出\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n```\n\n在执行NLP进行单词词性还原时,遇到堆空间溢出的情况。我们通过减少训练量（每次只训练500个单词），增大给虚拟机内存（最后是11.3GB）的方式解决\n\n\n\n## Jar包运行失败\n\n使用NLP进行单词词性还原的代码打成jar包后放入Hadoop集群中跑不了，查阅后知道打的jar包必须用含有依赖的。于是把含有依赖的继续放入，报错`java.util.zip.ZipException:invalid distance distance too far back`，需要检查jar包下载相关jar包时未下载完全，导致服务器进行加载解压时出错。\n\n## NLP处理问题\n\nNLP处理单词词性还原效果很好，但是运行速度极慢，一晚上只能跑出34MB的结果。于是我们弃用了NLP，通过英语本身的规则进行了粗略的词性还原，速度很快，但是效果一般。\n\n所以我们将跑出来的部分NLP结果也列出来，进行一个对比。\n\n\n","source":"_posts/Tools笔记/Hadoop搭建及使用文档.md","raw":"---\ntitle: Hadoop搭建及使用文档\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 'Hadoop搭建及使用文档,并配置运行WordCount程序'\ncategories: 常用工具\ntags:\n  - 工具\n  - Hadoop\n  - NLP\nabbrlink: 80a83e6\ndate: 2020-09-13 00:00:00\n---\n\n\n\n# 配置流程\n\n1.  Windows10安装Vmware,并在VMware配置Centos7 linux系统,分配4核CPU,10G内存\n2. 在Centos7中下载docker,配置SSH连接,网络连接\n3. 下载Hadoop镜像（使用的是Github开源的Hadoop镜像**kiwenlau/hadoop-cluster-docker** \n4.  对Hadoop镜像进行配置,启动3个容器，1个master+2个slave,搭建小型分布式集群\n5.  通过SSH连接在idea操纵虚拟机命令行,Xftp操作虚拟机文件系统\n6.  修改start-container.sh,配置docker容器启动方式。通过docker的目录映射,将虚拟机的文件与docker的Hadoop镜像中的文件相互关联,可以方便的在虚拟机中操纵Hadoop的文件。如下图所示，在windows上通过Xftp操作虚拟机的文件，又因为docker的目录映射，可以直接操作Hadoop内的容器。如**run-wordcount.sh**则是配置启动选项的Shell脚本，**input,output**文件夹存放输入输出的相关数据。jar包内存放**WordCount**程序代码\n ![image-20201106143611228](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201106143611228.png)\n8.  寻找网上demo，在本地windows环境用idea写好测试用例，打成jar包放入虚拟机中\n9.  下载的hadoop镜像基于JDK7的，所以进行相应更改\n10.  在run-wordcount.sh中修改输入输出文件位置，需要运行的jar包位置\n11.  对WordCount示例代码进行精读，并进行相关的代码注释\n11.  先对文本进行一些预处理，以及在windows本地测试处理效果\n12.  加入本次数据存储练习需要的词频计算程序逻辑代码\n13.  在Hadoop集群中运行得到根据单词词频降序排列的文件\n14.  对文本结果进行进一步分析与相应处理优化\n\n\n\n\n\n# 实现流程\n\n1. 对给的文本通过**StandardProcessing**程序进行预处理:设置好分隔符,即通过非字符进行分隔,然后取字符串长度大于1,且不包含数字的即可认为是单词,用空格分隔,重新写入一个文件standard_review中\n2. 对文本进行简单的词性还原，同样以空格分割，放入文件中\n3. 通过运行Hadoop集群实现词频统计，输出得到文件output.txt\n4. 对得到的output.txt再次使用Hadoop集群进行处理,得到按频率降序排序的结果，输出到文件result.txt中\n5. 对结果进行进一步处理,如去掉count为1的（对应大文本来说，只出现一次一般就是某些id）、去掉一些不合法的html元素（例如br等标签）。\n\n\n\n# 词性还原判断规则\n\n> 即要求中的（请考虑什么是不同的单词，例如单复数等均为同一个单词，不同时态也为同一个单词）\n\n\n\n# 启动流程\n\n1. 开启虚拟机,用ip addr得到动态ip地址\n2. 用idea ssh连接centos7命令行,xftp连接centos7文件系统\n3. 通过idea的maven插件将WordCount程序打成jar包\n4. 放入容器内的jar文件夹内\n5. `cd hadoop-cluster-docker`\n6. `./start-container.sh`\n7. `./start-hadoop.sh`\n8. `./run-wordcount.sh`\n\n\n\n# 常用命令\n\n```\nvmware查看动态路由:\n\tip addr\n\nhadoop查看内部的输入输出文件:\n    hdfs dfs -cat output/part-r-00000\n    hdfs dfs -ls input\n\nhadoop将输出文件拷贝到docker容器卷:\n\thdfs dfs -cat output/part-r-00000 > output/output.txt\n\t\nhadoop控制执行对应的jar:\n\thadoop far +jar包名称 +mainClass + 输入路径 + 输出路径\n\nhadoop内部日志位置:\n\tcd /usr/local/hadoop/logs\n\t\n查看日志：\n\tconfig/mapred-site.xml下配置程序日志输出位置\n```\n\n\n\n\n\n\n\n# 遇到的问题\n\n## 云服务器运行Demo失败\n\n```\nCaused by: org.apache.spark.SparkException: Job aborted due to stage failure: Task 2 in stage 3.0 failed 4 times, most recent failure: Lost task 2.3 in stage 3.0 (TID 23, ip-xxx-xxx-xx-xxx.compute.internal, executor 4): ExecutorLostFailure (executor 4 exited caused by one of the running tasks) Reason: Container marked as failed: container_1516900607498_6585_01_000008 on host: ip-xxx-xxx-xx-xxx.compute.internal. Exit status: 137. Diagnostics: Container killed on request. Exit code is 137\n```\n\n在阿里云轻量级应用服务器上，跑集群的小demo异常退出，后来发现是内存不够的原因（云服务器只有2g的内存），于是换到windows的虚拟机上\n\n## Hadoop集群连接失败\n\n```\njava.net.ConnectException: Call From xxx to localhost:8020 failed on connection exception: java.net.ConnectException: Connection refused\n```\n\n关闭Centos7防火墙\n\n## 内存溢出\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n```\n\n在执行NLP进行单词词性还原时,遇到堆空间溢出的情况。我们通过减少训练量（每次只训练500个单词），增大给虚拟机内存（最后是11.3GB）的方式解决\n\n\n\n## Jar包运行失败\n\n使用NLP进行单词词性还原的代码打成jar包后放入Hadoop集群中跑不了，查阅后知道打的jar包必须用含有依赖的。于是把含有依赖的继续放入，报错`java.util.zip.ZipException:invalid distance distance too far back`，需要检查jar包下载相关jar包时未下载完全，导致服务器进行加载解压时出错。\n\n## NLP处理问题\n\nNLP处理单词词性还原效果很好，但是运行速度极慢，一晚上只能跑出34MB的结果。于是我们弃用了NLP，通过英语本身的规则进行了粗略的词性还原，速度很快，但是效果一般。\n\n所以我们将跑出来的部分NLP结果也列出来，进行一个对比。\n\n\n","slug":"Tools笔记/Hadoop搭建及使用文档","published":1,"updated":"2020-11-12T11:57:29.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6ws002cjotpf37sefzg","content":"<h1 id=\"配置流程\"><a href=\"#配置流程\" class=\"headerlink\" title=\"配置流程\"></a>配置流程</h1><ol>\n<li>Windows10安装Vmware,并在VMware配置Centos7 linux系统,分配4核CPU,10G内存</li>\n<li>在Centos7中下载docker,配置SSH连接,网络连接</li>\n<li>下载Hadoop镜像（使用的是Github开源的Hadoop镜像<strong>kiwenlau/hadoop-cluster-docker</strong> </li>\n<li>对Hadoop镜像进行配置,启动3个容器，1个master+2个slave,搭建小型分布式集群</li>\n<li>通过SSH连接在idea操纵虚拟机命令行,Xftp操作虚拟机文件系统</li>\n<li>修改start-container.sh,配置docker容器启动方式。通过docker的目录映射,将虚拟机的文件与docker的Hadoop镜像中的文件相互关联,可以方便的在虚拟机中操纵Hadoop的文件。如下图所示，在windows上通过Xftp操作虚拟机的文件，又因为docker的目录映射，可以直接操作Hadoop内的容器。如<strong>run-wordcount.sh</strong>则是配置启动选项的Shell脚本，<strong>input,output</strong>文件夹存放输入输出的相关数据。jar包内存放<strong>WordCount</strong>程序代码<br><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201106143611228.png\" alt=\"image-20201106143611228\"></li>\n<li>寻找网上demo，在本地windows环境用idea写好测试用例，打成jar包放入虚拟机中</li>\n<li>下载的hadoop镜像基于JDK7的，所以进行相应更改</li>\n<li>在run-wordcount.sh中修改输入输出文件位置，需要运行的jar包位置</li>\n<li>对WordCount示例代码进行精读，并进行相关的代码注释</li>\n<li>先对文本进行一些预处理，以及在windows本地测试处理效果</li>\n<li>加入本次数据存储练习需要的词频计算程序逻辑代码</li>\n<li>在Hadoop集群中运行得到根据单词词频降序排列的文件</li>\n<li>对文本结果进行进一步分析与相应处理优化</li>\n</ol>\n<h1 id=\"实现流程\"><a href=\"#实现流程\" class=\"headerlink\" title=\"实现流程\"></a>实现流程</h1><ol>\n<li>对给的文本通过<strong>StandardProcessing</strong>程序进行预处理:设置好分隔符,即通过非字符进行分隔,然后取字符串长度大于1,且不包含数字的即可认为是单词,用空格分隔,重新写入一个文件standard_review中</li>\n<li>对文本进行简单的词性还原，同样以空格分割，放入文件中</li>\n<li>通过运行Hadoop集群实现词频统计，输出得到文件output.txt</li>\n<li>对得到的output.txt再次使用Hadoop集群进行处理,得到按频率降序排序的结果，输出到文件result.txt中</li>\n<li>对结果进行进一步处理,如去掉count为1的（对应大文本来说，只出现一次一般就是某些id）、去掉一些不合法的html元素（例如br等标签）。</li>\n</ol>\n<h1 id=\"词性还原判断规则\"><a href=\"#词性还原判断规则\" class=\"headerlink\" title=\"词性还原判断规则\"></a>词性还原判断规则</h1><blockquote>\n<p>即要求中的（请考虑什么是不同的单词，例如单复数等均为同一个单词，不同时态也为同一个单词）</p>\n</blockquote>\n<h1 id=\"启动流程\"><a href=\"#启动流程\" class=\"headerlink\" title=\"启动流程\"></a>启动流程</h1><ol>\n<li>开启虚拟机,用ip addr得到动态ip地址</li>\n<li>用idea ssh连接centos7命令行,xftp连接centos7文件系统</li>\n<li>通过idea的maven插件将WordCount程序打成jar包</li>\n<li>放入容器内的jar文件夹内</li>\n<li><code>cd hadoop-cluster-docker</code></li>\n<li><code>./start-container.sh</code></li>\n<li><code>./start-hadoop.sh</code></li>\n<li><code>./run-wordcount.sh</code></li>\n</ol>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><pre><code>vmware查看动态路由:\n    ip addr\n\nhadoop查看内部的输入输出文件:\n    hdfs dfs -cat output/part-r-00000\n    hdfs dfs -ls input\n\nhadoop将输出文件拷贝到docker容器卷:\n    hdfs dfs -cat output/part-r-00000 &gt; output/output.txt\n\nhadoop控制执行对应的jar:\n    hadoop far +jar包名称 +mainClass + 输入路径 + 输出路径\n\nhadoop内部日志位置:\n    cd /usr/local/hadoop/logs\n\n查看日志：\n    config/mapred-site.xml下配置程序日志输出位置</code></pre>\n<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><h2 id=\"云服务器运行Demo失败\"><a href=\"#云服务器运行Demo失败\" class=\"headerlink\" title=\"云服务器运行Demo失败\"></a>云服务器运行Demo失败</h2><pre><code>Caused by: org.apache.spark.SparkException: Job aborted due to stage failure: Task 2 in stage 3.0 failed 4 times, most recent failure: Lost task 2.3 in stage 3.0 (TID 23, ip-xxx-xxx-xx-xxx.compute.internal, executor 4): ExecutorLostFailure (executor 4 exited caused by one of the running tasks) Reason: Container marked as failed: container_1516900607498_6585_01_000008 on host: ip-xxx-xxx-xx-xxx.compute.internal. Exit status: 137. Diagnostics: Container killed on request. Exit code is 137</code></pre>\n<p>在阿里云轻量级应用服务器上，跑集群的小demo异常退出，后来发现是内存不够的原因（云服务器只有2g的内存），于是换到windows的虚拟机上</p>\n<h2 id=\"Hadoop集群连接失败\"><a href=\"#Hadoop集群连接失败\" class=\"headerlink\" title=\"Hadoop集群连接失败\"></a>Hadoop集群连接失败</h2><pre><code>java.net.ConnectException: Call From xxx to localhost:8020 failed on connection exception: java.net.ConnectException: Connection refused</code></pre>\n<p>关闭Centos7防火墙</p>\n<h2 id=\"内存溢出\"><a href=\"#内存溢出\" class=\"headerlink\" title=\"内存溢出\"></a>内存溢出</h2><pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</code></pre>\n<p>在执行NLP进行单词词性还原时,遇到堆空间溢出的情况。我们通过减少训练量（每次只训练500个单词），增大给虚拟机内存（最后是11.3GB）的方式解决</p>\n<h2 id=\"Jar包运行失败\"><a href=\"#Jar包运行失败\" class=\"headerlink\" title=\"Jar包运行失败\"></a>Jar包运行失败</h2><p>使用NLP进行单词词性还原的代码打成jar包后放入Hadoop集群中跑不了，查阅后知道打的jar包必须用含有依赖的。于是把含有依赖的继续放入，报错<code>java.util.zip.ZipException:invalid distance distance too far back</code>，需要检查jar包下载相关jar包时未下载完全，导致服务器进行加载解压时出错。</p>\n<h2 id=\"NLP处理问题\"><a href=\"#NLP处理问题\" class=\"headerlink\" title=\"NLP处理问题\"></a>NLP处理问题</h2><p>NLP处理单词词性还原效果很好，但是运行速度极慢，一晚上只能跑出34MB的结果。于是我们弃用了NLP，通过英语本身的规则进行了粗略的词性还原，速度很快，但是效果一般。</p>\n<p>所以我们将跑出来的部分NLP结果也列出来，进行一个对比。</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"配置流程\"><a href=\"#配置流程\" class=\"headerlink\" title=\"配置流程\"></a>配置流程</h1><ol>\n<li>Windows10安装Vmware,并在VMware配置Centos7 linux系统,分配4核CPU,10G内存</li>\n<li>在Centos7中下载docker,配置SSH连接,网络连接</li>\n<li>下载Hadoop镜像（使用的是Github开源的Hadoop镜像<strong>kiwenlau/hadoop-cluster-docker</strong> </li>\n<li>对Hadoop镜像进行配置,启动3个容器，1个master+2个slave,搭建小型分布式集群</li>\n<li>通过SSH连接在idea操纵虚拟机命令行,Xftp操作虚拟机文件系统</li>\n<li>修改start-container.sh,配置docker容器启动方式。通过docker的目录映射,将虚拟机的文件与docker的Hadoop镜像中的文件相互关联,可以方便的在虚拟机中操纵Hadoop的文件。如下图所示，在windows上通过Xftp操作虚拟机的文件，又因为docker的目录映射，可以直接操作Hadoop内的容器。如<strong>run-wordcount.sh</strong>则是配置启动选项的Shell脚本，<strong>input,output</strong>文件夹存放输入输出的相关数据。jar包内存放<strong>WordCount</strong>程序代码<br><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201106143611228.png\" alt=\"image-20201106143611228\"></li>\n<li>寻找网上demo，在本地windows环境用idea写好测试用例，打成jar包放入虚拟机中</li>\n<li>下载的hadoop镜像基于JDK7的，所以进行相应更改</li>\n<li>在run-wordcount.sh中修改输入输出文件位置，需要运行的jar包位置</li>\n<li>对WordCount示例代码进行精读，并进行相关的代码注释</li>\n<li>先对文本进行一些预处理，以及在windows本地测试处理效果</li>\n<li>加入本次数据存储练习需要的词频计算程序逻辑代码</li>\n<li>在Hadoop集群中运行得到根据单词词频降序排列的文件</li>\n<li>对文本结果进行进一步分析与相应处理优化</li>\n</ol>\n<h1 id=\"实现流程\"><a href=\"#实现流程\" class=\"headerlink\" title=\"实现流程\"></a>实现流程</h1><ol>\n<li>对给的文本通过<strong>StandardProcessing</strong>程序进行预处理:设置好分隔符,即通过非字符进行分隔,然后取字符串长度大于1,且不包含数字的即可认为是单词,用空格分隔,重新写入一个文件standard_review中</li>\n<li>对文本进行简单的词性还原，同样以空格分割，放入文件中</li>\n<li>通过运行Hadoop集群实现词频统计，输出得到文件output.txt</li>\n<li>对得到的output.txt再次使用Hadoop集群进行处理,得到按频率降序排序的结果，输出到文件result.txt中</li>\n<li>对结果进行进一步处理,如去掉count为1的（对应大文本来说，只出现一次一般就是某些id）、去掉一些不合法的html元素（例如br等标签）。</li>\n</ol>\n<h1 id=\"词性还原判断规则\"><a href=\"#词性还原判断规则\" class=\"headerlink\" title=\"词性还原判断规则\"></a>词性还原判断规则</h1><blockquote>\n<p>即要求中的（请考虑什么是不同的单词，例如单复数等均为同一个单词，不同时态也为同一个单词）</p>\n</blockquote>\n<h1 id=\"启动流程\"><a href=\"#启动流程\" class=\"headerlink\" title=\"启动流程\"></a>启动流程</h1><ol>\n<li>开启虚拟机,用ip addr得到动态ip地址</li>\n<li>用idea ssh连接centos7命令行,xftp连接centos7文件系统</li>\n<li>通过idea的maven插件将WordCount程序打成jar包</li>\n<li>放入容器内的jar文件夹内</li>\n<li><code>cd hadoop-cluster-docker</code></li>\n<li><code>./start-container.sh</code></li>\n<li><code>./start-hadoop.sh</code></li>\n<li><code>./run-wordcount.sh</code></li>\n</ol>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><pre><code>vmware查看动态路由:\n    ip addr\n\nhadoop查看内部的输入输出文件:\n    hdfs dfs -cat output/part-r-00000\n    hdfs dfs -ls input\n\nhadoop将输出文件拷贝到docker容器卷:\n    hdfs dfs -cat output/part-r-00000 &gt; output/output.txt\n\nhadoop控制执行对应的jar:\n    hadoop far +jar包名称 +mainClass + 输入路径 + 输出路径\n\nhadoop内部日志位置:\n    cd /usr/local/hadoop/logs\n\n查看日志：\n    config/mapred-site.xml下配置程序日志输出位置</code></pre>\n<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><h2 id=\"云服务器运行Demo失败\"><a href=\"#云服务器运行Demo失败\" class=\"headerlink\" title=\"云服务器运行Demo失败\"></a>云服务器运行Demo失败</h2><pre><code>Caused by: org.apache.spark.SparkException: Job aborted due to stage failure: Task 2 in stage 3.0 failed 4 times, most recent failure: Lost task 2.3 in stage 3.0 (TID 23, ip-xxx-xxx-xx-xxx.compute.internal, executor 4): ExecutorLostFailure (executor 4 exited caused by one of the running tasks) Reason: Container marked as failed: container_1516900607498_6585_01_000008 on host: ip-xxx-xxx-xx-xxx.compute.internal. Exit status: 137. Diagnostics: Container killed on request. Exit code is 137</code></pre>\n<p>在阿里云轻量级应用服务器上，跑集群的小demo异常退出，后来发现是内存不够的原因（云服务器只有2g的内存），于是换到windows的虚拟机上</p>\n<h2 id=\"Hadoop集群连接失败\"><a href=\"#Hadoop集群连接失败\" class=\"headerlink\" title=\"Hadoop集群连接失败\"></a>Hadoop集群连接失败</h2><pre><code>java.net.ConnectException: Call From xxx to localhost:8020 failed on connection exception: java.net.ConnectException: Connection refused</code></pre>\n<p>关闭Centos7防火墙</p>\n<h2 id=\"内存溢出\"><a href=\"#内存溢出\" class=\"headerlink\" title=\"内存溢出\"></a>内存溢出</h2><pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</code></pre>\n<p>在执行NLP进行单词词性还原时,遇到堆空间溢出的情况。我们通过减少训练量（每次只训练500个单词），增大给虚拟机内存（最后是11.3GB）的方式解决</p>\n<h2 id=\"Jar包运行失败\"><a href=\"#Jar包运行失败\" class=\"headerlink\" title=\"Jar包运行失败\"></a>Jar包运行失败</h2><p>使用NLP进行单词词性还原的代码打成jar包后放入Hadoop集群中跑不了，查阅后知道打的jar包必须用含有依赖的。于是把含有依赖的继续放入，报错<code>java.util.zip.ZipException:invalid distance distance too far back</code>，需要检查jar包下载相关jar包时未下载完全，导致服务器进行加载解压时出错。</p>\n<h2 id=\"NLP处理问题\"><a href=\"#NLP处理问题\" class=\"headerlink\" title=\"NLP处理问题\"></a>NLP处理问题</h2><p>NLP处理单词词性还原效果很好，但是运行速度极慢，一晚上只能跑出34MB的结果。于是我们弃用了NLP，通过英语本身的规则进行了粗略的词性还原，速度很快，但是效果一般。</p>\n<p>所以我们将跑出来的部分NLP结果也列出来，进行一个对比。</p>\n"},{"title":"《Redis设计与实现》-------对象","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Redis设计与实现》所做的笔记,此为书上第八章--对象。","abbrlink":"a3175fad","date":"2020-08-31T16:00:00.000Z","_content":"\n\n\n\n\n# 简介\n\n2. 基于之前的数据结构创建一个对象系统。包括字符串对象，列表对象，哈希对象，集合对象，有序集合对象五种\n\n2. 可以在执行命令之前，根据对象类型判断一个对象能否执行给定的命令\n3. 可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率\n4. 实现基于引用计数的内存回收机制，实现内存共享机制，让多个数据库键共享同一个对象节约内存\n5. 对象带有访问时间记录信息，记录数据库键的空转时间\n\n# 对象的类型和编码\n使用对象来表示数据库的键和值，新创建一个键值对时，会创建两个对象分别代表键和值\n\n```c\ntypedef struct redisObject\n{\n\tunsigned type:4;//类型\n\tunsigned encoding:4;//编码\n\tvoid * ptr;//指向底层实现数据结构的指针\n}\n```\n## 类型\n`type`属性记录了对象的类型，即五种对象类型之一\n对于一个键值对，键总是字符串对象，值可以是五种对象类型之一\n\n## 编码和底层实现\n1. 对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，即之前学习的几种数据结构\n2. 每种类型的对象都至少使用了两种不同的编码\n3. 通过`encoding`属性来设定使用的编码，极大地提升了灵活性和效率，可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率\n\n# 字符串对象\n1. 字符串对象的编码可以是int，raw，embstr\n2. 如果字符串对象保存整数值，且可以用long表示，则会将整数值保存在ptr中，enconding设为int\n3. 如果保存字符串值，并且长度大于39字节，就用`SDS`保存，并且设为raw\n4. 如果保存字符串值，并且长度小于39字节，就用`embstr`编码保存，并且设为embstr\n\n## embstr\n专门用来保存短字符串的一种优化编码方式，和SDS差不多\n不同的是，只调用一次内存分配函数来分配一块连续的空间，空间依次包含redisObject，sdshdr两个结构\n优点：内存分配与释放次数由两次变为一次；字符串所有的数据保存在一块连续的内存中，更好利用缓存\n## 编码的转换\n1. int编码的字符串对象如果操作后保存的不再是整数值，而是字符串值，则编码变为raw\n2. embstr编码的字符串对象只是可读的，对它执行任何修改命令，都会编程raw\n\n# 列表对象\n\n编码可以是`ziplist`,`linkedlist`。ziplist使用压缩列表作为底层实现，linkedlist采用双端链表作为底层实现。每个双端链表节点都保持一个字符串对象\n\n字符串对象是Redis 5种类型的对象中唯一一种会被其他四种对象嵌套的对象\n\n## 编码转换\n\n使用ziplist编码的情况：\n\n1. 列表对象保存的所有字符串元素都小于64字节\n2. 列表保存的元素数量小于512\n\n# 哈希对象\n\n编码可以是ziplist,hashtable。\n\n用ziplist则将键值对压入列表表尾，键值对紧挨一起，键在前，值在后。类似队列\n\nhashtable编码用字典作为底层实现，字典的每个键与值都是一个字符串对象\n\n## 编码转换\n\n使用ziplist编码的情况：\n\n1. 列表对象保存的所有字符串元素都小于64字节\n2. 列表保存的元素数量小于512\n\n# 集合对象\n\n编码可以是intset,hashtable。\n\n用intset编码的集合使用整数集合作为底层实现\n\n用hashtable编码的集合使用字典作为底层实现，每个键是一个字符串对象，而值设为NULL\n\n## 编码转换\n\n使用intset编码的情况：\n\n1. 列表对象保存的都是整数值\n2. 列表保存的元素数量小于512\n\n# 有序集合对象\n\n有序集合的编码可以是ziplist或者skiplist\n\n用ziplist编码则每个集合元素使用两个紧挨的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值\n\n## 用skiplist编码实现\n\n```c\ntypedef struct zset\n{\n\tzskiplist *zsl;\n\tdict * dict;\n} zset;\n```\n\nzset中的zsl跳跃表按分值从小到大保存了所有集合元素\n\n每个跳跃表节点中：object属性保存元素的成员，score属性保存元素的分值\n\n此外，dict中，字典的键保存元素的成员，值保存元素的分值，这样，通过字典可以用O(1)的复杂度查找给定成员的分值\n\n这两种数据结构都会通过指针来共享相同元素的成员和分值，所以使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，不会浪费额外内存\n\n## 编码转换\n\n使用ziplist编码的情况：\n\n1. 有序集合保存的所有元素长度都小于64字节\n2. 有序集合保存的元素数量小于128个\n\n# 类型检查和命令多态\n\n在执行一个类型的特定命令之前，服务器会检查输入数据库键的值对象是否为执行命令所需的指令，如果是，服务器就会对键执行指定的命令。否则将拒绝执行命令，并向客户端返回一个类型错误。\n\n类型检查是通过`redisObject`结构的type属性来实现的 \n\n## 多态命令的实现\n\nRedis除了会根据值对象的类型来判断键是否能够执行指定指令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令\n\n例如，`LLEN命令`是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行\n\nDEL，TYPE等命令也是多态命令，无论输入的键是什么类型，这些命令都可以正常执行。区别在于，DEL，TYPE等命令是基于类型的多态，一个命令可以处理多种不同的类型的键，LLen命令是基于编码的多态，一个命令可以同时用于处理多种不同编码\n\n# 内存回收\n\n基于引用计数法实现内存回收机制，通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收\n\n1. 创建对象，引用计数值为1\n2. 对象被新程序使用，引用计数值+1\n3. 对象不被一个程序使用，引用计数值-1\n4. 引用计数值为0时，释放对象占用的内存\n\n# 对象共享\n\n## 步骤\n\n让多个键共享同一个值对象步骤：\n\n1. 将数据库键的值指向一个现有的值对象\n2. 将被共享的值对象引用计数值+1\n\n## 内置整数\n\nRedis在初始化服务器时，会创建一万个字符串对象，存储[0,9999]的整数值。如果需要用到这些字符串对象，服务器则会使用这些共享对象，而不会新创建对象。\n\n这些共享对象不仅仅只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象\n\n## 为什么不共享包含字符串的对象\n\n只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象\n\n一个共享对象保存的值越复杂，则验证共享对象和目标对象是否相同所需的复杂度越高：\n\n1. 共享对象是整数值的字符串对象，验证操作为`O(1)`\n2. 共享对象是保存字符串值的字符串对象，验证操作为`O(N)`\n3. 共享对象是包含多个值的对象（如列表），验证操作为`O(N^2)`\n\n# 对象的空转时间\n\n`redisObject`结构包含属性lru,记录了对象最后一次被命令程序访问的时间。可用当前时间-键的值对象的lru时间求得空转时间\n\n可通过设置，使得当服务器占用的内存数超过了，`maxmemory`的上限时，空转时间较高的那部分键会优先被服务器释放，从而回收内存","source":"_posts/Redis笔记/8.对象.md","raw":"---\ntitle: 《Redis设计与实现》-------对象\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Redis设计与实现》所做的笔记,此为书上第八章--对象。'\ncategories: Redis学习笔记\ntags:\n  - Redis\n  - 数据结构\nabbrlink: a3175fad\ndate: 2020-09-01 00:00:00\n---\n\n\n\n\n\n# 简介\n\n2. 基于之前的数据结构创建一个对象系统。包括字符串对象，列表对象，哈希对象，集合对象，有序集合对象五种\n\n2. 可以在执行命令之前，根据对象类型判断一个对象能否执行给定的命令\n3. 可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率\n4. 实现基于引用计数的内存回收机制，实现内存共享机制，让多个数据库键共享同一个对象节约内存\n5. 对象带有访问时间记录信息，记录数据库键的空转时间\n\n# 对象的类型和编码\n使用对象来表示数据库的键和值，新创建一个键值对时，会创建两个对象分别代表键和值\n\n```c\ntypedef struct redisObject\n{\n\tunsigned type:4;//类型\n\tunsigned encoding:4;//编码\n\tvoid * ptr;//指向底层实现数据结构的指针\n}\n```\n## 类型\n`type`属性记录了对象的类型，即五种对象类型之一\n对于一个键值对，键总是字符串对象，值可以是五种对象类型之一\n\n## 编码和底层实现\n1. 对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，即之前学习的几种数据结构\n2. 每种类型的对象都至少使用了两种不同的编码\n3. 通过`encoding`属性来设定使用的编码，极大地提升了灵活性和效率，可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率\n\n# 字符串对象\n1. 字符串对象的编码可以是int，raw，embstr\n2. 如果字符串对象保存整数值，且可以用long表示，则会将整数值保存在ptr中，enconding设为int\n3. 如果保存字符串值，并且长度大于39字节，就用`SDS`保存，并且设为raw\n4. 如果保存字符串值，并且长度小于39字节，就用`embstr`编码保存，并且设为embstr\n\n## embstr\n专门用来保存短字符串的一种优化编码方式，和SDS差不多\n不同的是，只调用一次内存分配函数来分配一块连续的空间，空间依次包含redisObject，sdshdr两个结构\n优点：内存分配与释放次数由两次变为一次；字符串所有的数据保存在一块连续的内存中，更好利用缓存\n## 编码的转换\n1. int编码的字符串对象如果操作后保存的不再是整数值，而是字符串值，则编码变为raw\n2. embstr编码的字符串对象只是可读的，对它执行任何修改命令，都会编程raw\n\n# 列表对象\n\n编码可以是`ziplist`,`linkedlist`。ziplist使用压缩列表作为底层实现，linkedlist采用双端链表作为底层实现。每个双端链表节点都保持一个字符串对象\n\n字符串对象是Redis 5种类型的对象中唯一一种会被其他四种对象嵌套的对象\n\n## 编码转换\n\n使用ziplist编码的情况：\n\n1. 列表对象保存的所有字符串元素都小于64字节\n2. 列表保存的元素数量小于512\n\n# 哈希对象\n\n编码可以是ziplist,hashtable。\n\n用ziplist则将键值对压入列表表尾，键值对紧挨一起，键在前，值在后。类似队列\n\nhashtable编码用字典作为底层实现，字典的每个键与值都是一个字符串对象\n\n## 编码转换\n\n使用ziplist编码的情况：\n\n1. 列表对象保存的所有字符串元素都小于64字节\n2. 列表保存的元素数量小于512\n\n# 集合对象\n\n编码可以是intset,hashtable。\n\n用intset编码的集合使用整数集合作为底层实现\n\n用hashtable编码的集合使用字典作为底层实现，每个键是一个字符串对象，而值设为NULL\n\n## 编码转换\n\n使用intset编码的情况：\n\n1. 列表对象保存的都是整数值\n2. 列表保存的元素数量小于512\n\n# 有序集合对象\n\n有序集合的编码可以是ziplist或者skiplist\n\n用ziplist编码则每个集合元素使用两个紧挨的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值\n\n## 用skiplist编码实现\n\n```c\ntypedef struct zset\n{\n\tzskiplist *zsl;\n\tdict * dict;\n} zset;\n```\n\nzset中的zsl跳跃表按分值从小到大保存了所有集合元素\n\n每个跳跃表节点中：object属性保存元素的成员，score属性保存元素的分值\n\n此外，dict中，字典的键保存元素的成员，值保存元素的分值，这样，通过字典可以用O(1)的复杂度查找给定成员的分值\n\n这两种数据结构都会通过指针来共享相同元素的成员和分值，所以使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，不会浪费额外内存\n\n## 编码转换\n\n使用ziplist编码的情况：\n\n1. 有序集合保存的所有元素长度都小于64字节\n2. 有序集合保存的元素数量小于128个\n\n# 类型检查和命令多态\n\n在执行一个类型的特定命令之前，服务器会检查输入数据库键的值对象是否为执行命令所需的指令，如果是，服务器就会对键执行指定的命令。否则将拒绝执行命令，并向客户端返回一个类型错误。\n\n类型检查是通过`redisObject`结构的type属性来实现的 \n\n## 多态命令的实现\n\nRedis除了会根据值对象的类型来判断键是否能够执行指定指令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令\n\n例如，`LLEN命令`是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行\n\nDEL，TYPE等命令也是多态命令，无论输入的键是什么类型，这些命令都可以正常执行。区别在于，DEL，TYPE等命令是基于类型的多态，一个命令可以处理多种不同的类型的键，LLen命令是基于编码的多态，一个命令可以同时用于处理多种不同编码\n\n# 内存回收\n\n基于引用计数法实现内存回收机制，通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收\n\n1. 创建对象，引用计数值为1\n2. 对象被新程序使用，引用计数值+1\n3. 对象不被一个程序使用，引用计数值-1\n4. 引用计数值为0时，释放对象占用的内存\n\n# 对象共享\n\n## 步骤\n\n让多个键共享同一个值对象步骤：\n\n1. 将数据库键的值指向一个现有的值对象\n2. 将被共享的值对象引用计数值+1\n\n## 内置整数\n\nRedis在初始化服务器时，会创建一万个字符串对象，存储[0,9999]的整数值。如果需要用到这些字符串对象，服务器则会使用这些共享对象，而不会新创建对象。\n\n这些共享对象不仅仅只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象\n\n## 为什么不共享包含字符串的对象\n\n只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象\n\n一个共享对象保存的值越复杂，则验证共享对象和目标对象是否相同所需的复杂度越高：\n\n1. 共享对象是整数值的字符串对象，验证操作为`O(1)`\n2. 共享对象是保存字符串值的字符串对象，验证操作为`O(N)`\n3. 共享对象是包含多个值的对象（如列表），验证操作为`O(N^2)`\n\n# 对象的空转时间\n\n`redisObject`结构包含属性lru,记录了对象最后一次被命令程序访问的时间。可用当前时间-键的值对象的lru时间求得空转时间\n\n可通过设置，使得当服务器占用的内存数超过了，`maxmemory`的上限时，空转时间较高的那部分键会优先被服务器释放，从而回收内存","slug":"Redis笔记/8.对象","published":1,"updated":"2020-11-12T11:57:29.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wt002fjotpghcs4y0o","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><ol start=\"2\">\n<li><p>基于之前的数据结构创建一个对象系统。包括字符串对象，列表对象，哈希对象，集合对象，有序集合对象五种</p>\n</li>\n<li><p>可以在执行命令之前，根据对象类型判断一个对象能否执行给定的命令</p>\n</li>\n<li><p>可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率</p>\n</li>\n<li><p>实现基于引用计数的内存回收机制，实现内存共享机制，让多个数据库键共享同一个对象节约内存</p>\n</li>\n<li><p>对象带有访问时间记录信息，记录数据库键的空转时间</p>\n</li>\n</ol>\n<h1 id=\"对象的类型和编码\"><a href=\"#对象的类型和编码\" class=\"headerlink\" title=\"对象的类型和编码\"></a>对象的类型和编码</h1><p>使用对象来表示数据库的键和值，新创建一个键值对时，会创建两个对象分别代表键和值</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> redisObject\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">unsigned</span> type<span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//类型</span>\n    <span class=\"token keyword\">unsigned</span> encoding<span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//编码</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> ptr<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//指向底层实现数据结构的指针</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p><code>type</code>属性记录了对象的类型，即五种对象类型之一<br>对于一个键值对，键总是字符串对象，值可以是五种对象类型之一</p>\n<h2 id=\"编码和底层实现\"><a href=\"#编码和底层实现\" class=\"headerlink\" title=\"编码和底层实现\"></a>编码和底层实现</h2><ol>\n<li>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，即之前学习的几种数据结构</li>\n<li>每种类型的对象都至少使用了两种不同的编码</li>\n<li>通过<code>encoding</code>属性来设定使用的编码，极大地提升了灵活性和效率，可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率</li>\n</ol>\n<h1 id=\"字符串对象\"><a href=\"#字符串对象\" class=\"headerlink\" title=\"字符串对象\"></a>字符串对象</h1><ol>\n<li>字符串对象的编码可以是int，raw，embstr</li>\n<li>如果字符串对象保存整数值，且可以用long表示，则会将整数值保存在ptr中，enconding设为int</li>\n<li>如果保存字符串值，并且长度大于39字节，就用<code>SDS</code>保存，并且设为raw</li>\n<li>如果保存字符串值，并且长度小于39字节，就用<code>embstr</code>编码保存，并且设为embstr</li>\n</ol>\n<h2 id=\"embstr\"><a href=\"#embstr\" class=\"headerlink\" title=\"embstr\"></a>embstr</h2><p>专门用来保存短字符串的一种优化编码方式，和SDS差不多<br>不同的是，只调用一次内存分配函数来分配一块连续的空间，空间依次包含redisObject，sdshdr两个结构<br>优点：内存分配与释放次数由两次变为一次；字符串所有的数据保存在一块连续的内存中，更好利用缓存</p>\n<h2 id=\"编码的转换\"><a href=\"#编码的转换\" class=\"headerlink\" title=\"编码的转换\"></a>编码的转换</h2><ol>\n<li>int编码的字符串对象如果操作后保存的不再是整数值，而是字符串值，则编码变为raw</li>\n<li>embstr编码的字符串对象只是可读的，对它执行任何修改命令，都会编程raw</li>\n</ol>\n<h1 id=\"列表对象\"><a href=\"#列表对象\" class=\"headerlink\" title=\"列表对象\"></a>列表对象</h1><p>编码可以是<code>ziplist</code>,<code>linkedlist</code>。ziplist使用压缩列表作为底层实现，linkedlist采用双端链表作为底层实现。每个双端链表节点都保持一个字符串对象</p>\n<p>字符串对象是Redis 5种类型的对象中唯一一种会被其他四种对象嵌套的对象</p>\n<h2 id=\"编码转换\"><a href=\"#编码转换\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h2><p>使用ziplist编码的情况：</p>\n<ol>\n<li>列表对象保存的所有字符串元素都小于64字节</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<h1 id=\"哈希对象\"><a href=\"#哈希对象\" class=\"headerlink\" title=\"哈希对象\"></a>哈希对象</h1><p>编码可以是ziplist,hashtable。</p>\n<p>用ziplist则将键值对压入列表表尾，键值对紧挨一起，键在前，值在后。类似队列</p>\n<p>hashtable编码用字典作为底层实现，字典的每个键与值都是一个字符串对象</p>\n<h2 id=\"编码转换-1\"><a href=\"#编码转换-1\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h2><p>使用ziplist编码的情况：</p>\n<ol>\n<li>列表对象保存的所有字符串元素都小于64字节</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<h1 id=\"集合对象\"><a href=\"#集合对象\" class=\"headerlink\" title=\"集合对象\"></a>集合对象</h1><p>编码可以是intset,hashtable。</p>\n<p>用intset编码的集合使用整数集合作为底层实现</p>\n<p>用hashtable编码的集合使用字典作为底层实现，每个键是一个字符串对象，而值设为NULL</p>\n<h2 id=\"编码转换-2\"><a href=\"#编码转换-2\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h2><p>使用intset编码的情况：</p>\n<ol>\n<li>列表对象保存的都是整数值</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<h1 id=\"有序集合对象\"><a href=\"#有序集合对象\" class=\"headerlink\" title=\"有序集合对象\"></a>有序集合对象</h1><p>有序集合的编码可以是ziplist或者skiplist</p>\n<p>用ziplist编码则每个集合元素使用两个紧挨的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值</p>\n<h2 id=\"用skiplist编码实现\"><a href=\"#用skiplist编码实现\" class=\"headerlink\" title=\"用skiplist编码实现\"></a>用skiplist编码实现</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> zset\n<span class=\"token punctuation\">{</span>\n    zskiplist <span class=\"token operator\">*</span>zsl<span class=\"token punctuation\">;</span>\n    dict <span class=\"token operator\">*</span> dict<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> zset<span class=\"token punctuation\">;</span></code></pre>\n<p>zset中的zsl跳跃表按分值从小到大保存了所有集合元素</p>\n<p>每个跳跃表节点中：object属性保存元素的成员，score属性保存元素的分值</p>\n<p>此外，dict中，字典的键保存元素的成员，值保存元素的分值，这样，通过字典可以用O(1)的复杂度查找给定成员的分值</p>\n<p>这两种数据结构都会通过指针来共享相同元素的成员和分值，所以使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，不会浪费额外内存</p>\n<h2 id=\"编码转换-3\"><a href=\"#编码转换-3\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h2><p>使用ziplist编码的情况：</p>\n<ol>\n<li>有序集合保存的所有元素长度都小于64字节</li>\n<li>有序集合保存的元素数量小于128个</li>\n</ol>\n<h1 id=\"类型检查和命令多态\"><a href=\"#类型检查和命令多态\" class=\"headerlink\" title=\"类型检查和命令多态\"></a>类型检查和命令多态</h1><p>在执行一个类型的特定命令之前，服务器会检查输入数据库键的值对象是否为执行命令所需的指令，如果是，服务器就会对键执行指定的命令。否则将拒绝执行命令，并向客户端返回一个类型错误。</p>\n<p>类型检查是通过<code>redisObject</code>结构的type属性来实现的 </p>\n<h2 id=\"多态命令的实现\"><a href=\"#多态命令的实现\" class=\"headerlink\" title=\"多态命令的实现\"></a>多态命令的实现</h2><p>Redis除了会根据值对象的类型来判断键是否能够执行指定指令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令</p>\n<p>例如，<code>LLEN命令</code>是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行</p>\n<p>DEL，TYPE等命令也是多态命令，无论输入的键是什么类型，这些命令都可以正常执行。区别在于，DEL，TYPE等命令是基于类型的多态，一个命令可以处理多种不同的类型的键，LLen命令是基于编码的多态，一个命令可以同时用于处理多种不同编码</p>\n<h1 id=\"内存回收\"><a href=\"#内存回收\" class=\"headerlink\" title=\"内存回收\"></a>内存回收</h1><p>基于引用计数法实现内存回收机制，通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p>\n<ol>\n<li>创建对象，引用计数值为1</li>\n<li>对象被新程序使用，引用计数值+1</li>\n<li>对象不被一个程序使用，引用计数值-1</li>\n<li>引用计数值为0时，释放对象占用的内存</li>\n</ol>\n<h1 id=\"对象共享\"><a href=\"#对象共享\" class=\"headerlink\" title=\"对象共享\"></a>对象共享</h1><h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><p>让多个键共享同一个值对象步骤：</p>\n<ol>\n<li>将数据库键的值指向一个现有的值对象</li>\n<li>将被共享的值对象引用计数值+1</li>\n</ol>\n<h2 id=\"内置整数\"><a href=\"#内置整数\" class=\"headerlink\" title=\"内置整数\"></a>内置整数</h2><p>Redis在初始化服务器时，会创建一万个字符串对象，存储[0,9999]的整数值。如果需要用到这些字符串对象，服务器则会使用这些共享对象，而不会新创建对象。</p>\n<p>这些共享对象不仅仅只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象</p>\n<h2 id=\"为什么不共享包含字符串的对象\"><a href=\"#为什么不共享包含字符串的对象\" class=\"headerlink\" title=\"为什么不共享包含字符串的对象\"></a>为什么不共享包含字符串的对象</h2><p>只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象</p>\n<p>一个共享对象保存的值越复杂，则验证共享对象和目标对象是否相同所需的复杂度越高：</p>\n<ol>\n<li>共享对象是整数值的字符串对象，验证操作为<code>O(1)</code></li>\n<li>共享对象是保存字符串值的字符串对象，验证操作为<code>O(N)</code></li>\n<li>共享对象是包含多个值的对象（如列表），验证操作为<code>O(N^2)</code></li>\n</ol>\n<h1 id=\"对象的空转时间\"><a href=\"#对象的空转时间\" class=\"headerlink\" title=\"对象的空转时间\"></a>对象的空转时间</h1><p><code>redisObject</code>结构包含属性lru,记录了对象最后一次被命令程序访问的时间。可用当前时间-键的值对象的lru时间求得空转时间</p>\n<p>可通过设置，使得当服务器占用的内存数超过了，<code>maxmemory</code>的上限时，空转时间较高的那部分键会优先被服务器释放，从而回收内存</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><ol start=\"2\">\n<li><p>基于之前的数据结构创建一个对象系统。包括字符串对象，列表对象，哈希对象，集合对象，有序集合对象五种</p>\n</li>\n<li><p>可以在执行命令之前，根据对象类型判断一个对象能否执行给定的命令</p>\n</li>\n<li><p>可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率</p>\n</li>\n<li><p>实现基于引用计数的内存回收机制，实现内存共享机制，让多个数据库键共享同一个对象节约内存</p>\n</li>\n<li><p>对象带有访问时间记录信息，记录数据库键的空转时间</p>\n</li>\n</ol>\n<h1 id=\"对象的类型和编码\"><a href=\"#对象的类型和编码\" class=\"headerlink\" title=\"对象的类型和编码\"></a>对象的类型和编码</h1><p>使用对象来表示数据库的键和值，新创建一个键值对时，会创建两个对象分别代表键和值</p>\n<pre><code class=\"c\">typedef struct redisObject\n{\n    unsigned type:4;//类型\n    unsigned encoding:4;//编码\n    void * ptr;//指向底层实现数据结构的指针\n}</code></pre>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p><code>type</code>属性记录了对象的类型，即五种对象类型之一<br>对于一个键值对，键总是字符串对象，值可以是五种对象类型之一</p>\n<h2 id=\"编码和底层实现\"><a href=\"#编码和底层实现\" class=\"headerlink\" title=\"编码和底层实现\"></a>编码和底层实现</h2><ol>\n<li>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，即之前学习的几种数据结构</li>\n<li>每种类型的对象都至少使用了两种不同的编码</li>\n<li>通过<code>encoding</code>属性来设定使用的编码，极大地提升了灵活性和效率，可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率</li>\n</ol>\n<h1 id=\"字符串对象\"><a href=\"#字符串对象\" class=\"headerlink\" title=\"字符串对象\"></a>字符串对象</h1><ol>\n<li>字符串对象的编码可以是int，raw，embstr</li>\n<li>如果字符串对象保存整数值，且可以用long表示，则会将整数值保存在ptr中，enconding设为int</li>\n<li>如果保存字符串值，并且长度大于39字节，就用<code>SDS</code>保存，并且设为raw</li>\n<li>如果保存字符串值，并且长度小于39字节，就用<code>embstr</code>编码保存，并且设为embstr</li>\n</ol>\n<h2 id=\"embstr\"><a href=\"#embstr\" class=\"headerlink\" title=\"embstr\"></a>embstr</h2><p>专门用来保存短字符串的一种优化编码方式，和SDS差不多<br>不同的是，只调用一次内存分配函数来分配一块连续的空间，空间依次包含redisObject，sdshdr两个结构<br>优点：内存分配与释放次数由两次变为一次；字符串所有的数据保存在一块连续的内存中，更好利用缓存</p>\n<h2 id=\"编码的转换\"><a href=\"#编码的转换\" class=\"headerlink\" title=\"编码的转换\"></a>编码的转换</h2><ol>\n<li>int编码的字符串对象如果操作后保存的不再是整数值，而是字符串值，则编码变为raw</li>\n<li>embstr编码的字符串对象只是可读的，对它执行任何修改命令，都会编程raw</li>\n</ol>\n<h1 id=\"列表对象\"><a href=\"#列表对象\" class=\"headerlink\" title=\"列表对象\"></a>列表对象</h1><p>编码可以是<code>ziplist</code>,<code>linkedlist</code>。ziplist使用压缩列表作为底层实现，linkedlist采用双端链表作为底层实现。每个双端链表节点都保持一个字符串对象</p>\n<p>字符串对象是Redis 5种类型的对象中唯一一种会被其他四种对象嵌套的对象</p>\n<h2 id=\"编码转换\"><a href=\"#编码转换\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h2><p>使用ziplist编码的情况：</p>\n<ol>\n<li>列表对象保存的所有字符串元素都小于64字节</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<h1 id=\"哈希对象\"><a href=\"#哈希对象\" class=\"headerlink\" title=\"哈希对象\"></a>哈希对象</h1><p>编码可以是ziplist,hashtable。</p>\n<p>用ziplist则将键值对压入列表表尾，键值对紧挨一起，键在前，值在后。类似队列</p>\n<p>hashtable编码用字典作为底层实现，字典的每个键与值都是一个字符串对象</p>\n<h2 id=\"编码转换-1\"><a href=\"#编码转换-1\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h2><p>使用ziplist编码的情况：</p>\n<ol>\n<li>列表对象保存的所有字符串元素都小于64字节</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<h1 id=\"集合对象\"><a href=\"#集合对象\" class=\"headerlink\" title=\"集合对象\"></a>集合对象</h1><p>编码可以是intset,hashtable。</p>\n<p>用intset编码的集合使用整数集合作为底层实现</p>\n<p>用hashtable编码的集合使用字典作为底层实现，每个键是一个字符串对象，而值设为NULL</p>\n<h2 id=\"编码转换-2\"><a href=\"#编码转换-2\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h2><p>使用intset编码的情况：</p>\n<ol>\n<li>列表对象保存的都是整数值</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<h1 id=\"有序集合对象\"><a href=\"#有序集合对象\" class=\"headerlink\" title=\"有序集合对象\"></a>有序集合对象</h1><p>有序集合的编码可以是ziplist或者skiplist</p>\n<p>用ziplist编码则每个集合元素使用两个紧挨的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值</p>\n<h2 id=\"用skiplist编码实现\"><a href=\"#用skiplist编码实现\" class=\"headerlink\" title=\"用skiplist编码实现\"></a>用skiplist编码实现</h2><pre><code class=\"c\">typedef struct zset\n{\n    zskiplist *zsl;\n    dict * dict;\n} zset;</code></pre>\n<p>zset中的zsl跳跃表按分值从小到大保存了所有集合元素</p>\n<p>每个跳跃表节点中：object属性保存元素的成员，score属性保存元素的分值</p>\n<p>此外，dict中，字典的键保存元素的成员，值保存元素的分值，这样，通过字典可以用O(1)的复杂度查找给定成员的分值</p>\n<p>这两种数据结构都会通过指针来共享相同元素的成员和分值，所以使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，不会浪费额外内存</p>\n<h2 id=\"编码转换-3\"><a href=\"#编码转换-3\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h2><p>使用ziplist编码的情况：</p>\n<ol>\n<li>有序集合保存的所有元素长度都小于64字节</li>\n<li>有序集合保存的元素数量小于128个</li>\n</ol>\n<h1 id=\"类型检查和命令多态\"><a href=\"#类型检查和命令多态\" class=\"headerlink\" title=\"类型检查和命令多态\"></a>类型检查和命令多态</h1><p>在执行一个类型的特定命令之前，服务器会检查输入数据库键的值对象是否为执行命令所需的指令，如果是，服务器就会对键执行指定的命令。否则将拒绝执行命令，并向客户端返回一个类型错误。</p>\n<p>类型检查是通过<code>redisObject</code>结构的type属性来实现的 </p>\n<h2 id=\"多态命令的实现\"><a href=\"#多态命令的实现\" class=\"headerlink\" title=\"多态命令的实现\"></a>多态命令的实现</h2><p>Redis除了会根据值对象的类型来判断键是否能够执行指定指令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令</p>\n<p>例如，<code>LLEN命令</code>是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行</p>\n<p>DEL，TYPE等命令也是多态命令，无论输入的键是什么类型，这些命令都可以正常执行。区别在于，DEL，TYPE等命令是基于类型的多态，一个命令可以处理多种不同的类型的键，LLen命令是基于编码的多态，一个命令可以同时用于处理多种不同编码</p>\n<h1 id=\"内存回收\"><a href=\"#内存回收\" class=\"headerlink\" title=\"内存回收\"></a>内存回收</h1><p>基于引用计数法实现内存回收机制，通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p>\n<ol>\n<li>创建对象，引用计数值为1</li>\n<li>对象被新程序使用，引用计数值+1</li>\n<li>对象不被一个程序使用，引用计数值-1</li>\n<li>引用计数值为0时，释放对象占用的内存</li>\n</ol>\n<h1 id=\"对象共享\"><a href=\"#对象共享\" class=\"headerlink\" title=\"对象共享\"></a>对象共享</h1><h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><p>让多个键共享同一个值对象步骤：</p>\n<ol>\n<li>将数据库键的值指向一个现有的值对象</li>\n<li>将被共享的值对象引用计数值+1</li>\n</ol>\n<h2 id=\"内置整数\"><a href=\"#内置整数\" class=\"headerlink\" title=\"内置整数\"></a>内置整数</h2><p>Redis在初始化服务器时，会创建一万个字符串对象，存储[0,9999]的整数值。如果需要用到这些字符串对象，服务器则会使用这些共享对象，而不会新创建对象。</p>\n<p>这些共享对象不仅仅只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象</p>\n<h2 id=\"为什么不共享包含字符串的对象\"><a href=\"#为什么不共享包含字符串的对象\" class=\"headerlink\" title=\"为什么不共享包含字符串的对象\"></a>为什么不共享包含字符串的对象</h2><p>只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象</p>\n<p>一个共享对象保存的值越复杂，则验证共享对象和目标对象是否相同所需的复杂度越高：</p>\n<ol>\n<li>共享对象是整数值的字符串对象，验证操作为<code>O(1)</code></li>\n<li>共享对象是保存字符串值的字符串对象，验证操作为<code>O(N)</code></li>\n<li>共享对象是包含多个值的对象（如列表），验证操作为<code>O(N^2)</code></li>\n</ol>\n<h1 id=\"对象的空转时间\"><a href=\"#对象的空转时间\" class=\"headerlink\" title=\"对象的空转时间\"></a>对象的空转时间</h1><p><code>redisObject</code>结构包含属性lru,记录了对象最后一次被命令程序访问的时间。可用当前时间-键的值对象的lru时间求得空转时间</p>\n<p>可通过设置，使得当服务器占用的内存数超过了，<code>maxmemory</code>的上限时，空转时间较高的那部分键会优先被服务器释放，从而回收内存</p>\n"},{"title":"VMware常用命令与使用","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,主要写了VMware常用命令与使用","abbrlink":"d398cc0d","date":"2020-05-24T16:00:00.000Z","_content":"\n\n# 配置Ubuntu\n\n## [教程](https://blog.csdn.net/stpeace/article/details/78598333)\n## 设置root密码\n`ctrl+alt+F3`切换命令行,设置root: `sudo passwd root`,设置密码,确认密码\n\n## ssh连接\n### [教程](https://blog.csdn.net/weixin_42739326/article/details/82260588?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param)\n### ssh连接允许root登录\n修改`/etc/ssh/sshd_config`下的`PermitRootLogin yes`\n\t\t重新启动服务`/etc/init.d/ssh restart`\n### 用idea管理ssh连接\n[教程](https://blog.csdn.net/weixin_42249196/article/details/107464658)\n或者可以用idea连接进行命令行操作,用Xftp进行文件上传操作\n\n## 快照\n为便于出错后的恢复,最好在具体操作之前做好快照\n`对虚拟机项目右键-快照-拍摄快照`\n\n## 配置镜像源\n\n[教程](https://blog.csdn.net/u013541411/article/details/81410964)\n\n\n# 配置centos7\n## [教程](https://blog.csdn.net/qq_39135287/article/details/83993574?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param)\n\nyum不可用,更换源:[教程](https://blog.csdn.net/qq_41684957/article/details/83345154?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)\n\n## [ssh连接](https://blog.csdn.net/mengzuchao/article/details/80261836)\n","source":"_posts/Tools笔记/VMware.md","raw":"---\ntitle: VMware常用命令与使用\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,主要写了VMware常用命令与使用'\ncategories: 常用工具\ntags:\n  - 工具\n  - VMware\nabbrlink: d398cc0d\ndate: 2020-05-25 00:00:00\n---\n\n\n# 配置Ubuntu\n\n## [教程](https://blog.csdn.net/stpeace/article/details/78598333)\n## 设置root密码\n`ctrl+alt+F3`切换命令行,设置root: `sudo passwd root`,设置密码,确认密码\n\n## ssh连接\n### [教程](https://blog.csdn.net/weixin_42739326/article/details/82260588?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param)\n### ssh连接允许root登录\n修改`/etc/ssh/sshd_config`下的`PermitRootLogin yes`\n\t\t重新启动服务`/etc/init.d/ssh restart`\n### 用idea管理ssh连接\n[教程](https://blog.csdn.net/weixin_42249196/article/details/107464658)\n或者可以用idea连接进行命令行操作,用Xftp进行文件上传操作\n\n## 快照\n为便于出错后的恢复,最好在具体操作之前做好快照\n`对虚拟机项目右键-快照-拍摄快照`\n\n## 配置镜像源\n\n[教程](https://blog.csdn.net/u013541411/article/details/81410964)\n\n\n# 配置centos7\n## [教程](https://blog.csdn.net/qq_39135287/article/details/83993574?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param)\n\nyum不可用,更换源:[教程](https://blog.csdn.net/qq_41684957/article/details/83345154?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)\n\n## [ssh连接](https://blog.csdn.net/mengzuchao/article/details/80261836)\n","slug":"Tools笔记/VMware","published":1,"updated":"2020-11-12T11:57:29.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wu002jjotp9cg9fnun","content":"<h1 id=\"配置Ubuntu\"><a href=\"#配置Ubuntu\" class=\"headerlink\" title=\"配置Ubuntu\"></a>配置Ubuntu</h1><h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a><a href=\"https://blog.csdn.net/stpeace/article/details/78598333\" target=\"_blank\" rel=\"noopener\">教程</a></h2><h2 id=\"设置root密码\"><a href=\"#设置root密码\" class=\"headerlink\" title=\"设置root密码\"></a>设置root密码</h2><p><code>ctrl+alt+F3</code>切换命令行,设置root: <code>sudo passwd root</code>,设置密码,确认密码</p>\n<h2 id=\"ssh连接\"><a href=\"#ssh连接\" class=\"headerlink\" title=\"ssh连接\"></a>ssh连接</h2><h3 id=\"教程-1\"><a href=\"#教程-1\" class=\"headerlink\" title=\"教程\"></a><a href=\"https://blog.csdn.net/weixin_42739326/article/details/82260588?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param\" target=\"_blank\" rel=\"noopener\">教程</a></h3><h3 id=\"ssh连接允许root登录\"><a href=\"#ssh连接允许root登录\" class=\"headerlink\" title=\"ssh连接允许root登录\"></a>ssh连接允许root登录</h3><p>修改<code>/etc/ssh/sshd_config</code>下的<code>PermitRootLogin yes</code><br>        重新启动服务<code>/etc/init.d/ssh restart</code></p>\n<h3 id=\"用idea管理ssh连接\"><a href=\"#用idea管理ssh连接\" class=\"headerlink\" title=\"用idea管理ssh连接\"></a>用idea管理ssh连接</h3><p><a href=\"https://blog.csdn.net/weixin_42249196/article/details/107464658\" target=\"_blank\" rel=\"noopener\">教程</a><br>或者可以用idea连接进行命令行操作,用Xftp进行文件上传操作</p>\n<h2 id=\"快照\"><a href=\"#快照\" class=\"headerlink\" title=\"快照\"></a>快照</h2><p>为便于出错后的恢复,最好在具体操作之前做好快照<br><code>对虚拟机项目右键-快照-拍摄快照</code></p>\n<h2 id=\"配置镜像源\"><a href=\"#配置镜像源\" class=\"headerlink\" title=\"配置镜像源\"></a>配置镜像源</h2><p><a href=\"https://blog.csdn.net/u013541411/article/details/81410964\" target=\"_blank\" rel=\"noopener\">教程</a></p>\n<h1 id=\"配置centos7\"><a href=\"#配置centos7\" class=\"headerlink\" title=\"配置centos7\"></a>配置centos7</h1><h2 id=\"教程-2\"><a href=\"#教程-2\" class=\"headerlink\" title=\"教程\"></a><a href=\"https://blog.csdn.net/qq_39135287/article/details/83993574?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param\" target=\"_blank\" rel=\"noopener\">教程</a></h2><p>yum不可用,更换源:<a href=\"https://blog.csdn.net/qq_41684957/article/details/83345154?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param\" target=\"_blank\" rel=\"noopener\">教程</a></p>\n<h2 id=\"ssh连接-1\"><a href=\"#ssh连接-1\" class=\"headerlink\" title=\"ssh连接\"></a><a href=\"https://blog.csdn.net/mengzuchao/article/details/80261836\" target=\"_blank\" rel=\"noopener\">ssh连接</a></h2>","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"配置Ubuntu\"><a href=\"#配置Ubuntu\" class=\"headerlink\" title=\"配置Ubuntu\"></a>配置Ubuntu</h1><h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a><a href=\"https://blog.csdn.net/stpeace/article/details/78598333\" target=\"_blank\" rel=\"noopener\">教程</a></h2><h2 id=\"设置root密码\"><a href=\"#设置root密码\" class=\"headerlink\" title=\"设置root密码\"></a>设置root密码</h2><p><code>ctrl+alt+F3</code>切换命令行,设置root: <code>sudo passwd root</code>,设置密码,确认密码</p>\n<h2 id=\"ssh连接\"><a href=\"#ssh连接\" class=\"headerlink\" title=\"ssh连接\"></a>ssh连接</h2><h3 id=\"教程-1\"><a href=\"#教程-1\" class=\"headerlink\" title=\"教程\"></a><a href=\"https://blog.csdn.net/weixin_42739326/article/details/82260588?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param\" target=\"_blank\" rel=\"noopener\">教程</a></h3><h3 id=\"ssh连接允许root登录\"><a href=\"#ssh连接允许root登录\" class=\"headerlink\" title=\"ssh连接允许root登录\"></a>ssh连接允许root登录</h3><p>修改<code>/etc/ssh/sshd_config</code>下的<code>PermitRootLogin yes</code><br>        重新启动服务<code>/etc/init.d/ssh restart</code></p>\n<h3 id=\"用idea管理ssh连接\"><a href=\"#用idea管理ssh连接\" class=\"headerlink\" title=\"用idea管理ssh连接\"></a>用idea管理ssh连接</h3><p><a href=\"https://blog.csdn.net/weixin_42249196/article/details/107464658\" target=\"_blank\" rel=\"noopener\">教程</a><br>或者可以用idea连接进行命令行操作,用Xftp进行文件上传操作</p>\n<h2 id=\"快照\"><a href=\"#快照\" class=\"headerlink\" title=\"快照\"></a>快照</h2><p>为便于出错后的恢复,最好在具体操作之前做好快照<br><code>对虚拟机项目右键-快照-拍摄快照</code></p>\n<h2 id=\"配置镜像源\"><a href=\"#配置镜像源\" class=\"headerlink\" title=\"配置镜像源\"></a>配置镜像源</h2><p><a href=\"https://blog.csdn.net/u013541411/article/details/81410964\" target=\"_blank\" rel=\"noopener\">教程</a></p>\n<h1 id=\"配置centos7\"><a href=\"#配置centos7\" class=\"headerlink\" title=\"配置centos7\"></a>配置centos7</h1><h2 id=\"教程-2\"><a href=\"#教程-2\" class=\"headerlink\" title=\"教程\"></a><a href=\"https://blog.csdn.net/qq_39135287/article/details/83993574?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param\" target=\"_blank\" rel=\"noopener\">教程</a></h2><p>yum不可用,更换源:<a href=\"https://blog.csdn.net/qq_41684957/article/details/83345154?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param\" target=\"_blank\" rel=\"noopener\">教程</a></p>\n<h2 id=\"ssh连接-1\"><a href=\"#ssh连接-1\" class=\"headerlink\" title=\"ssh连接\"></a><a href=\"https://blog.csdn.net/mengzuchao/article/details/80261836\" target=\"_blank\" rel=\"noopener\">ssh连接</a></h2>"},{"title":"Vue常用命令与使用","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,主要写了Vue常用命令与使用","abbrlink":"2d8f53b2","date":"2020-03-14T16:00:00.000Z","_content":"\n> 官网下载安装node.js\n>\n>  安装cnpm:npm install -g cnpm --registry=https://registry.npm.taobao.org \n>\n> npm install -g @vue/cli\n>\n> vue --version 查看是否成功\n>\n> 安装vue全局扩展:npm install -g @vue/cli-service-global\n>\n> vue create 项目名\n>\n> 用IDEA打开项目,可以在Terminal运行npm run serve\n\n\n\n\n\n\n\n\n\n","source":"_posts/Tools笔记/Vue.md","raw":"---\ntitle: Vue常用命令与使用\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,主要写了Vue常用命令与使用'\ncategories: 常用工具\ntags:\n  - 工具\n  - Vue\nabbrlink: 2d8f53b2\ndate: 2020-03-15 00:00:00\n---\n\n> 官网下载安装node.js\n>\n>  安装cnpm:npm install -g cnpm --registry=https://registry.npm.taobao.org \n>\n> npm install -g @vue/cli\n>\n> vue --version 查看是否成功\n>\n> 安装vue全局扩展:npm install -g @vue/cli-service-global\n>\n> vue create 项目名\n>\n> 用IDEA打开项目,可以在Terminal运行npm run serve\n\n\n\n\n\n\n\n\n\n","slug":"Tools笔记/Vue","published":1,"updated":"2020-11-12T11:57:29.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wv002njotp2eiphiu0","content":"<blockquote>\n<p>官网下载安装node.js</p>\n<p> 安装cnpm:npm install -g cnpm –registry=<a href=\"https://registry.npm.taobao.org/\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a> </p>\n<p>npm install -g @vue/cli</p>\n<p>vue –version 查看是否成功</p>\n<p>安装vue全局扩展:npm install -g @vue/cli-service-global</p>\n<p>vue create 项目名</p>\n<p>用IDEA打开项目,可以在Terminal运行npm run serve</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>官网下载安装node.js</p>\n<p> 安装cnpm:npm install -g cnpm –registry=<a href=\"https://registry.npm.taobao.org/\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a> </p>\n<p>npm install -g @vue/cli</p>\n<p>vue –version 查看是否成功</p>\n<p>安装vue全局扩展:npm install -g @vue/cli-service-global</p>\n<p>vue create 项目名</p>\n<p>用IDEA打开项目,可以在Terminal运行npm run serve</p>\n</blockquote>\n"},{"title":"快速新建md文件","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,介绍在windows下如何快速新建md文件","abbrlink":"b379f77c","date":"2020-08-01T16:00:00.000Z","_content":"\n﻿# 快捷键新建文档\n\n1. win+r,输入regedit点击运行打开注册表\n2. ctrl+F搜索 文本文档\n3. 双击此键值，在\"文本文档\"后加上\" (&T)\"(不要忘记前面有一个空格)\n4. 此时可以用右键+w+t新建文档\n5. 再修改文件名和后缀为md文件\n# 右键新建md文件\n1. 新建文本文件\n```\nWindows Registry Editor Version 5.00\n\n[HKEY_CLASSES_ROOT\\.md]\n@=\"Typora.md\"\n\"Content Type\"=\"text/markdown\"\n\"PerceivedType\"=\"text\"\n\n[HKEY_CLASSES_ROOT\\.md\\ShellNew]\n\"NullFile\"=\"\"\n```\n2. 修改后缀为reg,双击运行即可\n\n# win+R输入typora运行\n","source":"_posts/Tools笔记/Windows新建一个md文件的几种方法.md","raw":"---\ntitle: 快速新建md文件\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,介绍在windows下如何快速新建md文件'\ncategories: 常用工具\ntags:\n  - 工具\n  - markdown\nabbrlink: b379f77c\ndate: 2020-08-02 00:00:00\n---\n\n﻿# 快捷键新建文档\n\n1. win+r,输入regedit点击运行打开注册表\n2. ctrl+F搜索 文本文档\n3. 双击此键值，在\"文本文档\"后加上\" (&T)\"(不要忘记前面有一个空格)\n4. 此时可以用右键+w+t新建文档\n5. 再修改文件名和后缀为md文件\n# 右键新建md文件\n1. 新建文本文件\n```\nWindows Registry Editor Version 5.00\n\n[HKEY_CLASSES_ROOT\\.md]\n@=\"Typora.md\"\n\"Content Type\"=\"text/markdown\"\n\"PerceivedType\"=\"text\"\n\n[HKEY_CLASSES_ROOT\\.md\\ShellNew]\n\"NullFile\"=\"\"\n```\n2. 修改后缀为reg,双击运行即可\n\n# win+R输入typora运行\n","slug":"Tools笔记/Windows新建一个md文件的几种方法","published":1,"updated":"2020-11-12T11:57:29.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6wy002qjotp7xhahzk9","content":"<p>﻿# 快捷键新建文档</p>\n<ol>\n<li>win+r,输入regedit点击运行打开注册表</li>\n<li>ctrl+F搜索 文本文档</li>\n<li>双击此键值，在”文本文档”后加上” (&amp;T)”(不要忘记前面有一个空格)</li>\n<li>此时可以用右键+w+t新建文档</li>\n<li>再修改文件名和后缀为md文件<h1 id=\"右键新建md文件\"><a href=\"#右键新建md文件\" class=\"headerlink\" title=\"右键新建md文件\"></a>右键新建md文件</h1></li>\n<li>新建文本文件<pre><code>Windows Registry Editor Version 5.00\n</code></pre>\n</li>\n</ol>\n<p>[HKEY_CLASSES_ROOT.md]<br>@=”Typora.md”<br>“Content Type”=”text/markdown”<br>“PerceivedType”=”text”</p>\n<p>[HKEY_CLASSES_ROOT.md\\ShellNew]<br>“NullFile”=””</p>\n<pre><code>2. 修改后缀为reg,双击运行即可\n\n# win+R输入typora运行</code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<p>﻿# 快捷键新建文档</p>\n<ol>\n<li>win+r,输入regedit点击运行打开注册表</li>\n<li>ctrl+F搜索 文本文档</li>\n<li>双击此键值，在”文本文档”后加上” (&amp;T)”(不要忘记前面有一个空格)</li>\n<li>此时可以用右键+w+t新建文档</li>\n<li>再修改文件名和后缀为md文件<h1 id=\"右键新建md文件\"><a href=\"#右键新建md文件\" class=\"headerlink\" title=\"右键新建md文件\"></a>右键新建md文件</h1></li>\n<li>新建文本文件<pre><code>Windows Registry Editor Version 5.00\n</code></pre>\n</li>\n</ol>\n<p>[HKEY_CLASSES_ROOT.md]<br>@=”Typora.md”<br>“Content Type”=”text/markdown”<br>“PerceivedType”=”text”</p>\n<p>[HKEY_CLASSES_ROOT.md\\ShellNew]<br>“NullFile”=””</p>\n<pre><code>2. 修改后缀为reg,双击运行即可\n\n# win+R输入typora运行</code></pre>\n"},{"title":"docker常用命令与使用","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,主要写了docker常用命令与使用","abbrlink":"65fb0b69","date":"2020-07-18T16:00:00.000Z","_content":"\n\n\n\n\n# Docker理解\n\n1. docker对进程进行隔离,将软件所需的所有资源打包到一个隔离的容器中.\n\n2. 容器是相互隔离的,每个容器内部都有一个属于自己的文件系统\n\n3. 镜像与容器。容器是用镜像创建的运行实例。容器可以看作简易版的Linux环境\n\n4. 仓库包含多个镜像，每个镜像都有不同的标签（tag），即版本\n\n5. 联合文件系统:一些已经下的基础包就不会继续下了\n\n6. 帮助命令:`docker --help`\n\n7. > Docker容器卷\n  >\n  > 容器之间共享数据\n  >\n  > docker run -it -v 宿主机目录:容器内目录 镜像名 \n\n# 镜像命令 \n> \n\t> docker images                查看镜像\n\t>\n\t> docker search  镜像名\n\t>\n\t> docker pull 镜像名[:TAG]          不写TAG则默认下最新版本\n\t>\n\t> docker rmi -f 镜像名[:TAG]            删除镜像\n\t>\n\t> docker rmi -f $(docker images -qa)  删除全部镜像\n\n​\t\n# 容器命令                              \n\n> docker run -it  --name centos1  镜像ID/镜像名 \n>\n> docker ps              参数-a,列出历史上所有运行过的\n>\n> docker stop 容器ID \n>\n> docker start 容器ID    \n>\n> docker rm 容器ID    删除已停止的容器 参数-f 强制删除正在运行的容器\n>\n> docker run -d    镜像ID 以守护式启动,后台运行  如果该进程没有前台进程,会自动退出\n>\n> exit 直接退出docker容器\n>\n> docker exec -it centos1 /bin/bash 重新进入当前运行的 容器\n>\n> docker run -it  -p 8888:8080 tomcat 带端口的启动\n>\n> docker run  -it --name centos7 centos:7   /bin/bash \n>\n> docker logs -f -t  --tail 10  centos7  **-f :** 跟踪日志输出  **-t :** 显示时间戳\n>\n> docker top centos7 查看容器内进程信息\n>\n> docker inspect centos7 查看容器内具体信息\n>\n> docker cp centos7:/usr/tongji4m3.txt . 拷贝容器内文件到主机\n>\n> \n>\n> --name=\"名称\" 容器名\n>\n> -d 后台运行\n>\n> -it 以交互方式运行,进入容器\n>\n> -p 8888:8080  指定端口映射\n\n# DockerFile创建容器\n首先新建个文件`vim DockerFile`\n\n```c\n\tFROM centos\n\n    ENV mypath /usr/local\n\tWORKDIR $mypath\n    \n    RUN yum -y install vim\n    \n    EXPOSE 80\n\tCMD /bin/bash\n```\n\n创建  `docker build -f /root/myDocker/DockerFile -t mycentos:1.0 .`\n\n之后就可以正常使用：`docker run -it mycentos:1.0`\n\n\n\n# 常用软件安装\n\n## redis\n\n### 安装\n\n```docker run -d --name redis -p 6379:6379 redis --requirepass \"redis\"```\n\n### 以客户端启动\n\n```docker exec -it redis redis-cli -a redis ```\n\n# 一些例子\n\n```javascript\nFROM centos\n#拷贝宿主机的文件到容器的文件\nCOPY temp.txt /usr/local/container.txt\n#把Java，tomcat添加到容器中\nADD jdk-8u221-linux-x64.tar.gz /usr/local/\nADD apache-tomcat-9.0.8.tar.gz /usr/local/\n#安装vim编辑器\nRUN yum -y install vim\n#设置登录落脚点\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n#配置Java，tomcat环境变量\nENV JAVA_HOME /usr/local/jdk1.8.0.221\nENV CLASSPATH $JAVA_HOME/lib/dt.jar\n#配置java与tomcat环境变量\nENV JAVA HOME /usr/1ocal/jdk1.8.0_ 171\nENV CLASSPATH $JAVA_HOME/1ib/dt.jar: $JAVA_HOME/lib/tools.jar\nENV CATALINA_HOME /usr/local/apache-tomcat-9.0.8\nENV CATALINA_BASE /usr/local/apache-tomcat-9.0.8\nENV PATH $PATH: $JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin\n#监听窗口\nEXPOSE 8080\n#启动时运行tomcat\nCMD /usr/local/apache-tomcat-9.0.8/bin/startup.sh\n\n    \n```\n\n\n\n`docker pull mysql:5.7`\n\n> mysql安装\n>\n> docker run -p 3306:3306 --name mysql -v /root/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7\n\n启动:\n\n`docker exec -it mysql bash`\n\n`mysql -uroot -proot`","source":"_posts/Tools笔记/docker.md","raw":"---\ntitle: docker常用命令与使用\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,主要写了docker常用命令与使用'\ncategories: 常用工具\ntags:\n  - 工具\n  - Docker\nabbrlink: 65fb0b69\ndate: 2020-07-19 00:00:00\n---\n\n\n\n\n\n# Docker理解\n\n1. docker对进程进行隔离,将软件所需的所有资源打包到一个隔离的容器中.\n\n2. 容器是相互隔离的,每个容器内部都有一个属于自己的文件系统\n\n3. 镜像与容器。容器是用镜像创建的运行实例。容器可以看作简易版的Linux环境\n\n4. 仓库包含多个镜像，每个镜像都有不同的标签（tag），即版本\n\n5. 联合文件系统:一些已经下的基础包就不会继续下了\n\n6. 帮助命令:`docker --help`\n\n7. > Docker容器卷\n  >\n  > 容器之间共享数据\n  >\n  > docker run -it -v 宿主机目录:容器内目录 镜像名 \n\n# 镜像命令 \n> \n\t> docker images                查看镜像\n\t>\n\t> docker search  镜像名\n\t>\n\t> docker pull 镜像名[:TAG]          不写TAG则默认下最新版本\n\t>\n\t> docker rmi -f 镜像名[:TAG]            删除镜像\n\t>\n\t> docker rmi -f $(docker images -qa)  删除全部镜像\n\n​\t\n# 容器命令                              \n\n> docker run -it  --name centos1  镜像ID/镜像名 \n>\n> docker ps              参数-a,列出历史上所有运行过的\n>\n> docker stop 容器ID \n>\n> docker start 容器ID    \n>\n> docker rm 容器ID    删除已停止的容器 参数-f 强制删除正在运行的容器\n>\n> docker run -d    镜像ID 以守护式启动,后台运行  如果该进程没有前台进程,会自动退出\n>\n> exit 直接退出docker容器\n>\n> docker exec -it centos1 /bin/bash 重新进入当前运行的 容器\n>\n> docker run -it  -p 8888:8080 tomcat 带端口的启动\n>\n> docker run  -it --name centos7 centos:7   /bin/bash \n>\n> docker logs -f -t  --tail 10  centos7  **-f :** 跟踪日志输出  **-t :** 显示时间戳\n>\n> docker top centos7 查看容器内进程信息\n>\n> docker inspect centos7 查看容器内具体信息\n>\n> docker cp centos7:/usr/tongji4m3.txt . 拷贝容器内文件到主机\n>\n> \n>\n> --name=\"名称\" 容器名\n>\n> -d 后台运行\n>\n> -it 以交互方式运行,进入容器\n>\n> -p 8888:8080  指定端口映射\n\n# DockerFile创建容器\n首先新建个文件`vim DockerFile`\n\n```c\n\tFROM centos\n\n    ENV mypath /usr/local\n\tWORKDIR $mypath\n    \n    RUN yum -y install vim\n    \n    EXPOSE 80\n\tCMD /bin/bash\n```\n\n创建  `docker build -f /root/myDocker/DockerFile -t mycentos:1.0 .`\n\n之后就可以正常使用：`docker run -it mycentos:1.0`\n\n\n\n# 常用软件安装\n\n## redis\n\n### 安装\n\n```docker run -d --name redis -p 6379:6379 redis --requirepass \"redis\"```\n\n### 以客户端启动\n\n```docker exec -it redis redis-cli -a redis ```\n\n# 一些例子\n\n```javascript\nFROM centos\n#拷贝宿主机的文件到容器的文件\nCOPY temp.txt /usr/local/container.txt\n#把Java，tomcat添加到容器中\nADD jdk-8u221-linux-x64.tar.gz /usr/local/\nADD apache-tomcat-9.0.8.tar.gz /usr/local/\n#安装vim编辑器\nRUN yum -y install vim\n#设置登录落脚点\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n#配置Java，tomcat环境变量\nENV JAVA_HOME /usr/local/jdk1.8.0.221\nENV CLASSPATH $JAVA_HOME/lib/dt.jar\n#配置java与tomcat环境变量\nENV JAVA HOME /usr/1ocal/jdk1.8.0_ 171\nENV CLASSPATH $JAVA_HOME/1ib/dt.jar: $JAVA_HOME/lib/tools.jar\nENV CATALINA_HOME /usr/local/apache-tomcat-9.0.8\nENV CATALINA_BASE /usr/local/apache-tomcat-9.0.8\nENV PATH $PATH: $JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin\n#监听窗口\nEXPOSE 8080\n#启动时运行tomcat\nCMD /usr/local/apache-tomcat-9.0.8/bin/startup.sh\n\n    \n```\n\n\n\n`docker pull mysql:5.7`\n\n> mysql安装\n>\n> docker run -p 3306:3306 --name mysql -v /root/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7\n\n启动:\n\n`docker exec -it mysql bash`\n\n`mysql -uroot -proot`","slug":"Tools笔记/docker","published":1,"updated":"2020-11-12T11:57:29.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6x0002tjotp1wolglp8","content":"<h1 id=\"Docker理解\"><a href=\"#Docker理解\" class=\"headerlink\" title=\"Docker理解\"></a>Docker理解</h1><ol>\n<li><p>docker对进程进行隔离,将软件所需的所有资源打包到一个隔离的容器中.</p>\n</li>\n<li><p>容器是相互隔离的,每个容器内部都有一个属于自己的文件系统</p>\n</li>\n<li><p>镜像与容器。容器是用镜像创建的运行实例。容器可以看作简易版的Linux环境</p>\n</li>\n<li><p>仓库包含多个镜像，每个镜像都有不同的标签（tag），即版本</p>\n</li>\n<li><p>联合文件系统:一些已经下的基础包就不会继续下了</p>\n</li>\n<li><p>帮助命令:<code>docker --help</code></p>\n</li>\n<li><blockquote>\n<p>Docker容器卷</p>\n<p>容器之间共享数据</p>\n<p>docker run -it -v 宿主机目录:容器内目录 镜像名 </p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"镜像命令\"><a href=\"#镜像命令\" class=\"headerlink\" title=\"镜像命令\"></a>镜像命令</h1><blockquote>\n</blockquote>\n<pre><code>&gt; docker images                查看镜像\n&gt;\n&gt; docker search  镜像名\n&gt;\n&gt; docker pull 镜像名[:TAG]          不写TAG则默认下最新版本\n&gt;\n&gt; docker rmi -f 镜像名[:TAG]            删除镜像\n&gt;\n&gt; docker rmi -f $(docker images -qa)  删除全部镜像</code></pre>\n<p>​    </p>\n<h1 id=\"容器命令\"><a href=\"#容器命令\" class=\"headerlink\" title=\"容器命令\"></a>容器命令</h1><blockquote>\n<p>docker run -it  –name centos1  镜像ID/镜像名 </p>\n<p>docker ps              参数-a,列出历史上所有运行过的</p>\n<p>docker stop 容器ID </p>\n<p>docker start 容器ID    </p>\n<p>docker rm 容器ID    删除已停止的容器 参数-f 强制删除正在运行的容器</p>\n<p>docker run -d    镜像ID 以守护式启动,后台运行  如果该进程没有前台进程,会自动退出</p>\n<p>exit 直接退出docker容器</p>\n<p>docker exec -it centos1 /bin/bash 重新进入当前运行的 容器</p>\n<p>docker run -it  -p 8888:8080 tomcat 带端口的启动</p>\n<p>docker run  -it –name centos7 centos:7   /bin/bash </p>\n<p>docker logs -f -t  –tail 10  centos7  <strong>-f :</strong> 跟踪日志输出  <strong>-t :</strong> 显示时间戳</p>\n<p>docker top centos7 查看容器内进程信息</p>\n<p>docker inspect centos7 查看容器内具体信息</p>\n<p>docker cp centos7:/usr/tongji4m3.txt . 拷贝容器内文件到主机</p>\n<p>–name=”名称” 容器名</p>\n<p>-d 后台运行</p>\n<p>-it 以交互方式运行,进入容器</p>\n<p>-p 8888:8080  指定端口映射</p>\n</blockquote>\n<h1 id=\"DockerFile创建容器\"><a href=\"#DockerFile创建容器\" class=\"headerlink\" title=\"DockerFile创建容器\"></a>DockerFile创建容器</h1><p>首先新建个文件<code>vim DockerFile</code></p>\n<pre class=\" language-c\"><code class=\"language-c\">    FROM centos\n\n    ENV mypath <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local\n    WORKDIR $mypath\n\n    RUN yum <span class=\"token operator\">-</span>y install vim\n\n    EXPOSE <span class=\"token number\">80</span>\n    CMD <span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>bash</code></pre>\n<p>创建  <code>docker build -f /root/myDocker/DockerFile -t mycentos:1.0 .</code></p>\n<p>之后就可以正常使用：<code>docker run -it mycentos:1.0</code></p>\n<h1 id=\"常用软件安装\"><a href=\"#常用软件安装\" class=\"headerlink\" title=\"常用软件安装\"></a>常用软件安装</h1><h2 id=\"redis\"><a href=\"#redis\" class=\"headerlink\" title=\"redis\"></a>redis</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>docker run -d --name redis -p 6379:6379 redis --requirepass &quot;redis&quot;</code></p>\n<h3 id=\"以客户端启动\"><a href=\"#以客户端启动\" class=\"headerlink\" title=\"以客户端启动\"></a>以客户端启动</h3><p><code>docker exec -it redis redis-cli -a redis </code></p>\n<h1 id=\"一些例子\"><a href=\"#一些例子\" class=\"headerlink\" title=\"一些例子\"></a>一些例子</h1><pre class=\" language-javascript\"><code class=\"language-javascript\">FROM centos\n#拷贝宿主机的文件到容器的文件\nCOPY temp<span class=\"token punctuation\">.</span>txt <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local<span class=\"token operator\">/</span>container<span class=\"token punctuation\">.</span>txt\n#把Java，tomcat添加到容器中\nADD jdk<span class=\"token operator\">-</span>8u221<span class=\"token operator\">-</span>linux<span class=\"token operator\">-</span>x64<span class=\"token punctuation\">.</span>tar<span class=\"token punctuation\">.</span>gz <span class=\"token operator\">/</span>usr<span class=\"token regex\">/local/</span>\nADD apache<span class=\"token operator\">-</span>tomcat<span class=\"token number\">-9.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">8</span><span class=\"token punctuation\">.</span>tar<span class=\"token punctuation\">.</span>gz <span class=\"token operator\">/</span>usr<span class=\"token regex\">/local/</span>\n#安装vim编辑器\nRUN yum <span class=\"token operator\">-</span>y install vim\n#设置登录落脚点\nENV MYPATH <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local\nWORKDIR $MYPATH\n#配置Java，tomcat环境变量\nENV JAVA_HOME <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local<span class=\"token operator\">/</span>jdk1<span class=\"token number\">.8</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.221</span>\nENV CLASSPATH $JAVA_HOME<span class=\"token operator\">/</span>lib<span class=\"token operator\">/</span>dt<span class=\"token punctuation\">.</span>jar\n#配置java与tomcat环境变量\nENV JAVA HOME <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>1ocal<span class=\"token operator\">/</span>jdk1<span class=\"token number\">.8</span><span class=\"token punctuation\">.</span>0_ <span class=\"token number\">171</span>\nENV CLASSPATH $JAVA_HOME<span class=\"token operator\">/</span>1ib<span class=\"token operator\">/</span>dt<span class=\"token punctuation\">.</span>jar<span class=\"token punctuation\">:</span> $JAVA_HOME<span class=\"token operator\">/</span>lib<span class=\"token operator\">/</span>tools<span class=\"token punctuation\">.</span>jar\nENV CATALINA_HOME <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local<span class=\"token operator\">/</span>apache<span class=\"token operator\">-</span>tomcat<span class=\"token number\">-9.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">8</span>\nENV CATALINA_BASE <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local<span class=\"token operator\">/</span>apache<span class=\"token operator\">-</span>tomcat<span class=\"token number\">-9.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">8</span>\nENV PATH $PATH<span class=\"token punctuation\">:</span> $JAVA_HOME<span class=\"token operator\">/</span>bin<span class=\"token punctuation\">:</span>$CATALINA_HOME<span class=\"token operator\">/</span>lib<span class=\"token punctuation\">:</span>$CATALINA_HOME<span class=\"token operator\">/</span>bin\n#监听窗口\nEXPOSE <span class=\"token number\">8080</span>\n#启动时运行tomcat\nCMD <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local<span class=\"token operator\">/</span>apache<span class=\"token operator\">-</span>tomcat<span class=\"token number\">-9.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">8</span><span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>startup<span class=\"token punctuation\">.</span>sh\n\n</code></pre>\n<p><code>docker pull mysql:5.7</code></p>\n<blockquote>\n<p>mysql安装</p>\n<p>docker run -p 3306:3306 –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7</p>\n</blockquote>\n<p>启动:</p>\n<p><code>docker exec -it mysql bash</code></p>\n<p><code>mysql -uroot -proot</code></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"Docker理解\"><a href=\"#Docker理解\" class=\"headerlink\" title=\"Docker理解\"></a>Docker理解</h1><ol>\n<li><p>docker对进程进行隔离,将软件所需的所有资源打包到一个隔离的容器中.</p>\n</li>\n<li><p>容器是相互隔离的,每个容器内部都有一个属于自己的文件系统</p>\n</li>\n<li><p>镜像与容器。容器是用镜像创建的运行实例。容器可以看作简易版的Linux环境</p>\n</li>\n<li><p>仓库包含多个镜像，每个镜像都有不同的标签（tag），即版本</p>\n</li>\n<li><p>联合文件系统:一些已经下的基础包就不会继续下了</p>\n</li>\n<li><p>帮助命令:<code>docker --help</code></p>\n</li>\n<li><blockquote>\n<p>Docker容器卷</p>\n<p>容器之间共享数据</p>\n<p>docker run -it -v 宿主机目录:容器内目录 镜像名 </p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"镜像命令\"><a href=\"#镜像命令\" class=\"headerlink\" title=\"镜像命令\"></a>镜像命令</h1><blockquote>\n</blockquote>\n<pre><code>&gt; docker images                查看镜像\n&gt;\n&gt; docker search  镜像名\n&gt;\n&gt; docker pull 镜像名[:TAG]          不写TAG则默认下最新版本\n&gt;\n&gt; docker rmi -f 镜像名[:TAG]            删除镜像\n&gt;\n&gt; docker rmi -f $(docker images -qa)  删除全部镜像</code></pre>\n<p>​    </p>\n<h1 id=\"容器命令\"><a href=\"#容器命令\" class=\"headerlink\" title=\"容器命令\"></a>容器命令</h1><blockquote>\n<p>docker run -it  –name centos1  镜像ID/镜像名 </p>\n<p>docker ps              参数-a,列出历史上所有运行过的</p>\n<p>docker stop 容器ID </p>\n<p>docker start 容器ID    </p>\n<p>docker rm 容器ID    删除已停止的容器 参数-f 强制删除正在运行的容器</p>\n<p>docker run -d    镜像ID 以守护式启动,后台运行  如果该进程没有前台进程,会自动退出</p>\n<p>exit 直接退出docker容器</p>\n<p>docker exec -it centos1 /bin/bash 重新进入当前运行的 容器</p>\n<p>docker run -it  -p 8888:8080 tomcat 带端口的启动</p>\n<p>docker run  -it –name centos7 centos:7   /bin/bash </p>\n<p>docker logs -f -t  –tail 10  centos7  <strong>-f :</strong> 跟踪日志输出  <strong>-t :</strong> 显示时间戳</p>\n<p>docker top centos7 查看容器内进程信息</p>\n<p>docker inspect centos7 查看容器内具体信息</p>\n<p>docker cp centos7:/usr/tongji4m3.txt . 拷贝容器内文件到主机</p>\n<p>–name=”名称” 容器名</p>\n<p>-d 后台运行</p>\n<p>-it 以交互方式运行,进入容器</p>\n<p>-p 8888:8080  指定端口映射</p>\n</blockquote>\n<h1 id=\"DockerFile创建容器\"><a href=\"#DockerFile创建容器\" class=\"headerlink\" title=\"DockerFile创建容器\"></a>DockerFile创建容器</h1><p>首先新建个文件<code>vim DockerFile</code></p>\n<pre><code class=\"c\">    FROM centos\n\n    ENV mypath /usr/local\n    WORKDIR $mypath\n\n    RUN yum -y install vim\n\n    EXPOSE 80\n    CMD /bin/bash</code></pre>\n<p>创建  <code>docker build -f /root/myDocker/DockerFile -t mycentos:1.0 .</code></p>\n<p>之后就可以正常使用：<code>docker run -it mycentos:1.0</code></p>\n<h1 id=\"常用软件安装\"><a href=\"#常用软件安装\" class=\"headerlink\" title=\"常用软件安装\"></a>常用软件安装</h1><h2 id=\"redis\"><a href=\"#redis\" class=\"headerlink\" title=\"redis\"></a>redis</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>docker run -d --name redis -p 6379:6379 redis --requirepass &quot;redis&quot;</code></p>\n<h3 id=\"以客户端启动\"><a href=\"#以客户端启动\" class=\"headerlink\" title=\"以客户端启动\"></a>以客户端启动</h3><p><code>docker exec -it redis redis-cli -a redis </code></p>\n<h1 id=\"一些例子\"><a href=\"#一些例子\" class=\"headerlink\" title=\"一些例子\"></a>一些例子</h1><pre><code class=\"javascript\">FROM centos\n#拷贝宿主机的文件到容器的文件\nCOPY temp.txt /usr/local/container.txt\n#把Java，tomcat添加到容器中\nADD jdk-8u221-linux-x64.tar.gz /usr/local/\nADD apache-tomcat-9.0.8.tar.gz /usr/local/\n#安装vim编辑器\nRUN yum -y install vim\n#设置登录落脚点\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n#配置Java，tomcat环境变量\nENV JAVA_HOME /usr/local/jdk1.8.0.221\nENV CLASSPATH $JAVA_HOME/lib/dt.jar\n#配置java与tomcat环境变量\nENV JAVA HOME /usr/1ocal/jdk1.8.0_ 171\nENV CLASSPATH $JAVA_HOME/1ib/dt.jar: $JAVA_HOME/lib/tools.jar\nENV CATALINA_HOME /usr/local/apache-tomcat-9.0.8\nENV CATALINA_BASE /usr/local/apache-tomcat-9.0.8\nENV PATH $PATH: $JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin\n#监听窗口\nEXPOSE 8080\n#启动时运行tomcat\nCMD /usr/local/apache-tomcat-9.0.8/bin/startup.sh\n\n</code></pre>\n<p><code>docker pull mysql:5.7</code></p>\n<blockquote>\n<p>mysql安装</p>\n<p>docker run -p 3306:3306 –name mysql -v /root/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7</p>\n</blockquote>\n<p>启动:</p>\n<p><code>docker exec -it mysql bash</code></p>\n<p><code>mysql -uroot -proot</code></p>\n"},{"title":"hexo常用命令与使用","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,主要写了hexo常用命令与使用","abbrlink":"95af1e01","date":"2020-07-13T16:00:00.000Z","_content":"\n## 一.安装hexo\n\n搭建可以参考视频:[CodeSheep搭建博客教程](https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=17889294783077443284),如果出现问题可以看弹幕解决\n\n**连接Github时注意**\n\n>git config --global user.name \"Github名字\"\n>\n>git config --global user.email \"Github绑定的邮箱\"\n\n**中文乱码**\n\n> echo $LANG查看字符集\n>\n> 在 /etc/profile配置文件添加export LANG=\"zh_CN.UTF-8\"\n>\n>  . /etc/profile 重新载入\n\n**idea ssh连接中文乱码**\n\n> File>Settings>Tools>SSH Terminal> Default encoding设为utf-8\n\n## 二.hexo主题与美化\n\n主题可以用[next主题](https://github.com/iissnan/hexo-theme-next)上的，在next主题上进行美化:[next美化教程](https://blog.csdn.net/nightmare_dimple/article/details/86661502)\n\n另一个教程:[hexo美化设置](https://blog.csdn.net/qincidong/article/details/82415256)\n\n目前正在使用的,**强烈推荐**:[Matery主题](https://github.com/blinkfox/hexo-theme-matery)\n\n> hexo相关的设置在blog/_config.yml文件修改_\n>\n> 主题相关的设置在themes/next/_config.yml文件修改\n\n## 三.hexo相关命令\n\n> hexo d 部署到Github上\n>\n> hexo clean清空缓存\n\n\n\n","source":"_posts/Tools笔记/hexo.md","raw":"---\ntitle: hexo常用命令与使用\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,主要写了hexo常用命令与使用'\ncategories: 常用工具\ntags:\n  - 工具\n  - hexo\nabbrlink: 95af1e01\ndate: 2020-07-14 00:00:00\n---\n\n## 一.安装hexo\n\n搭建可以参考视频:[CodeSheep搭建博客教程](https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=17889294783077443284),如果出现问题可以看弹幕解决\n\n**连接Github时注意**\n\n>git config --global user.name \"Github名字\"\n>\n>git config --global user.email \"Github绑定的邮箱\"\n\n**中文乱码**\n\n> echo $LANG查看字符集\n>\n> 在 /etc/profile配置文件添加export LANG=\"zh_CN.UTF-8\"\n>\n>  . /etc/profile 重新载入\n\n**idea ssh连接中文乱码**\n\n> File>Settings>Tools>SSH Terminal> Default encoding设为utf-8\n\n## 二.hexo主题与美化\n\n主题可以用[next主题](https://github.com/iissnan/hexo-theme-next)上的，在next主题上进行美化:[next美化教程](https://blog.csdn.net/nightmare_dimple/article/details/86661502)\n\n另一个教程:[hexo美化设置](https://blog.csdn.net/qincidong/article/details/82415256)\n\n目前正在使用的,**强烈推荐**:[Matery主题](https://github.com/blinkfox/hexo-theme-matery)\n\n> hexo相关的设置在blog/_config.yml文件修改_\n>\n> 主题相关的设置在themes/next/_config.yml文件修改\n\n## 三.hexo相关命令\n\n> hexo d 部署到Github上\n>\n> hexo clean清空缓存\n\n\n\n","slug":"Tools笔记/hexo","published":1,"updated":"2020-11-12T11:57:29.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6x2002xjotpg0i9c1c7","content":"<h2 id=\"一-安装hexo\"><a href=\"#一-安装hexo\" class=\"headerlink\" title=\"一.安装hexo\"></a>一.安装hexo</h2><p>搭建可以参考视频:<a href=\"https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=17889294783077443284\" target=\"_blank\" rel=\"noopener\">CodeSheep搭建博客教程</a>,如果出现问题可以看弹幕解决</p>\n<p><strong>连接Github时注意</strong></p>\n<blockquote>\n<p>git config –global user.name “Github名字”</p>\n<p>git config –global user.email “Github绑定的邮箱”</p>\n</blockquote>\n<p><strong>中文乱码</strong></p>\n<blockquote>\n<p>echo $LANG查看字符集</p>\n<p>在 /etc/profile配置文件添加export LANG=”zh_CN.UTF-8”</p>\n<p> . /etc/profile 重新载入</p>\n</blockquote>\n<p><strong>idea ssh连接中文乱码</strong></p>\n<blockquote>\n<p>File&gt;Settings&gt;Tools&gt;SSH Terminal&gt; Default encoding设为utf-8</p>\n</blockquote>\n<h2 id=\"二-hexo主题与美化\"><a href=\"#二-hexo主题与美化\" class=\"headerlink\" title=\"二.hexo主题与美化\"></a>二.hexo主题与美化</h2><p>主题可以用<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">next主题</a>上的，在next主题上进行美化:<a href=\"https://blog.csdn.net/nightmare_dimple/article/details/86661502\" target=\"_blank\" rel=\"noopener\">next美化教程</a></p>\n<p>另一个教程:<a href=\"https://blog.csdn.net/qincidong/article/details/82415256\" target=\"_blank\" rel=\"noopener\">hexo美化设置</a></p>\n<p>目前正在使用的,<strong>强烈推荐</strong>:<a href=\"https://github.com/blinkfox/hexo-theme-matery\" target=\"_blank\" rel=\"noopener\">Matery主题</a></p>\n<blockquote>\n<p>hexo相关的设置在blog/<em>config.yml文件修改</em></p>\n<p>主题相关的设置在themes/next/_config.yml文件修改</p>\n</blockquote>\n<h2 id=\"三-hexo相关命令\"><a href=\"#三-hexo相关命令\" class=\"headerlink\" title=\"三.hexo相关命令\"></a>三.hexo相关命令</h2><blockquote>\n<p>hexo d 部署到Github上</p>\n<p>hexo clean清空缓存</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"一-安装hexo\"><a href=\"#一-安装hexo\" class=\"headerlink\" title=\"一.安装hexo\"></a>一.安装hexo</h2><p>搭建可以参考视频:<a href=\"https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=17889294783077443284\" target=\"_blank\" rel=\"noopener\">CodeSheep搭建博客教程</a>,如果出现问题可以看弹幕解决</p>\n<p><strong>连接Github时注意</strong></p>\n<blockquote>\n<p>git config –global user.name “Github名字”</p>\n<p>git config –global user.email “Github绑定的邮箱”</p>\n</blockquote>\n<p><strong>中文乱码</strong></p>\n<blockquote>\n<p>echo $LANG查看字符集</p>\n<p>在 /etc/profile配置文件添加export LANG=”zh_CN.UTF-8”</p>\n<p> . /etc/profile 重新载入</p>\n</blockquote>\n<p><strong>idea ssh连接中文乱码</strong></p>\n<blockquote>\n<p>File&gt;Settings&gt;Tools&gt;SSH Terminal&gt; Default encoding设为utf-8</p>\n</blockquote>\n<h2 id=\"二-hexo主题与美化\"><a href=\"#二-hexo主题与美化\" class=\"headerlink\" title=\"二.hexo主题与美化\"></a>二.hexo主题与美化</h2><p>主题可以用<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">next主题</a>上的，在next主题上进行美化:<a href=\"https://blog.csdn.net/nightmare_dimple/article/details/86661502\" target=\"_blank\" rel=\"noopener\">next美化教程</a></p>\n<p>另一个教程:<a href=\"https://blog.csdn.net/qincidong/article/details/82415256\" target=\"_blank\" rel=\"noopener\">hexo美化设置</a></p>\n<p>目前正在使用的,<strong>强烈推荐</strong>:<a href=\"https://github.com/blinkfox/hexo-theme-matery\" target=\"_blank\" rel=\"noopener\">Matery主题</a></p>\n<blockquote>\n<p>hexo相关的设置在blog/<em>config.yml文件修改</em></p>\n<p>主题相关的设置在themes/next/_config.yml文件修改</p>\n</blockquote>\n<h2 id=\"三-hexo相关命令\"><a href=\"#三-hexo相关命令\" class=\"headerlink\" title=\"三.hexo相关命令\"></a>三.hexo相关命令</h2><blockquote>\n<p>hexo d 部署到Github上</p>\n<p>hexo clean清空缓存</p>\n</blockquote>\n"},{"title":"idea常用命令与使用","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,主要写了idea常用命令与使用","abbrlink":"e0571985","date":"2020-04-13T16:00:00.000Z","_content":"\n# 设置\n\n---\n\n1. File Export Settings先导出一份自己熟悉使用的设置，导出为 settings.jar.新电脑就直接file import Settings\n\n2. 下载ultimate版本的,注册可以用去官网学生认证\n\n3. 全屏，view，appearance，full screen；如果顶部菜单栏不见了，改ui.inf.xml的<option name=\"SHOW_MAIN_MENU\" value=\"false\" />这个选项为false，将其修改为true\n\n4. 大小写不敏感：setting->Editor->General->Code Completion取消Match case\n\n5. 花括号File->Setting->Editor->Code Style->Java->Wrapping and Braces\n\n6. > 自定义模板\n   >\n   > File –> Setting中, 搜索live…要设置下面的change，选java\n   >\n   > fori不用配置\n   >\n   > 集合.for增强for循环快捷键  \n   >\n   > sys:System.out.print($END$);\n\n7. ctrl+F8设置断点,改成ctrl+shift+B,记得去除之前的一个\n\n8. 格式化 ctrl+shift+F,在右边搜索栏输入：reformat code \n\n9. Args传入参数：Run下的Edit Configurations，配置Configuration分页中的Program arguments选项\n\n10. Ctrl+鼠标滑轮控制字体大小，在File -> Setting -> Editor -> General下进行设置。选中Change font size (Zoom) with Ctrl+Mouse wheel \n\n11. 设置idea背景,File | Settings | Appearance & Behavior | Appearance|background Image\n\n   \n\n---\n\n# 快捷键(常用)\n\n1. Alt+enter内容辅助，可以这样比较方便的新建一个类,或者是修改建议\n\n1. Ctrl +Y 删除代码\n2. 代码的上下移动，ctrl+shift+上下箭头\n3. shift+F6 重命名\n4. 格式化 ctrl+shift+F\n5. Ctrl+D 复制当前行到下一行\n6. ctrl+/；ctrl+shift+/  注释\n7. Alt+ins，快速生成get，set等等\n8. Alt+1打开层次体系\n9. 行末加分号，ctrl+shift+enter\n10. 用F2移动到有错误的代码\n11. Ctrl+alt+ins快速新建类\n12. ctrl+shift+加减,代码折叠 \n13. 选中类名 Ctrl+鼠标点击  查看源码\n14. shift+enter 快速下一行\n15. Ctrl+删除，删除这个单词\n16. .Ctrl+F搜索\n17. ctrl+左右，快速跳过一个单词;Shift+上下,选中某行；\n\n\n\n---\n\n# 快捷键(常忘记的)\n\n1. 运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。Ctrl+F8 设置断点 。F7/F8/F9分别对应Step into，Step over，Continue，shift+F8退出方法\n2. 抽取方法快捷键:ctrl+alt+m\n3. Ctrl+H打开类继承体系，ctrl+F12查看类所有方法\n4. Ctrl+Alt+V则是抽取变量\n5. Ctrl+W快速选中一行\n6. Ctrl+Tab切换类\n7. Shift+shift快速搜索，可以查找类\n8. Ctrl+alt+s 打开设置\n9. ctrl alt+t 用try catch等包裹代码\n10. shift+end或者home,快速选择一行\n11. ctrl+p方法参数提示\n\n\n\n# 整合github\n\n在IDEA中设置GitHub，File-->Setting->Version Control-->GibHub\n\n创建本地仓库，VCS-->Import into Version Control-->Create Git Repository\n\nVCS-->Import into Version Control-->Share Project on GitHub\n\n# UML\n\n1. 右键一个类--Diagram--show Diagrams\n2. 对一个类,右键,可用`show Parents`,`show implementations`\n3. 也可以新添加类,对一个类按空格\n\n","source":"_posts/Tools笔记/idea.md","raw":"---\ntitle: idea常用命令与使用\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,主要写了idea常用命令与使用'\ncategories: 常用工具\ntags:\n  - 工具\n  - idea\nabbrlink: e0571985\ndate: 2020-04-14 00:00:00\n---\n\n# 设置\n\n---\n\n1. File Export Settings先导出一份自己熟悉使用的设置，导出为 settings.jar.新电脑就直接file import Settings\n\n2. 下载ultimate版本的,注册可以用去官网学生认证\n\n3. 全屏，view，appearance，full screen；如果顶部菜单栏不见了，改ui.inf.xml的<option name=\"SHOW_MAIN_MENU\" value=\"false\" />这个选项为false，将其修改为true\n\n4. 大小写不敏感：setting->Editor->General->Code Completion取消Match case\n\n5. 花括号File->Setting->Editor->Code Style->Java->Wrapping and Braces\n\n6. > 自定义模板\n   >\n   > File –> Setting中, 搜索live…要设置下面的change，选java\n   >\n   > fori不用配置\n   >\n   > 集合.for增强for循环快捷键  \n   >\n   > sys:System.out.print($END$);\n\n7. ctrl+F8设置断点,改成ctrl+shift+B,记得去除之前的一个\n\n8. 格式化 ctrl+shift+F,在右边搜索栏输入：reformat code \n\n9. Args传入参数：Run下的Edit Configurations，配置Configuration分页中的Program arguments选项\n\n10. Ctrl+鼠标滑轮控制字体大小，在File -> Setting -> Editor -> General下进行设置。选中Change font size (Zoom) with Ctrl+Mouse wheel \n\n11. 设置idea背景,File | Settings | Appearance & Behavior | Appearance|background Image\n\n   \n\n---\n\n# 快捷键(常用)\n\n1. Alt+enter内容辅助，可以这样比较方便的新建一个类,或者是修改建议\n\n1. Ctrl +Y 删除代码\n2. 代码的上下移动，ctrl+shift+上下箭头\n3. shift+F6 重命名\n4. 格式化 ctrl+shift+F\n5. Ctrl+D 复制当前行到下一行\n6. ctrl+/；ctrl+shift+/  注释\n7. Alt+ins，快速生成get，set等等\n8. Alt+1打开层次体系\n9. 行末加分号，ctrl+shift+enter\n10. 用F2移动到有错误的代码\n11. Ctrl+alt+ins快速新建类\n12. ctrl+shift+加减,代码折叠 \n13. 选中类名 Ctrl+鼠标点击  查看源码\n14. shift+enter 快速下一行\n15. Ctrl+删除，删除这个单词\n16. .Ctrl+F搜索\n17. ctrl+左右，快速跳过一个单词;Shift+上下,选中某行；\n\n\n\n---\n\n# 快捷键(常忘记的)\n\n1. 运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。Ctrl+F8 设置断点 。F7/F8/F9分别对应Step into，Step over，Continue，shift+F8退出方法\n2. 抽取方法快捷键:ctrl+alt+m\n3. Ctrl+H打开类继承体系，ctrl+F12查看类所有方法\n4. Ctrl+Alt+V则是抽取变量\n5. Ctrl+W快速选中一行\n6. Ctrl+Tab切换类\n7. Shift+shift快速搜索，可以查找类\n8. Ctrl+alt+s 打开设置\n9. ctrl alt+t 用try catch等包裹代码\n10. shift+end或者home,快速选择一行\n11. ctrl+p方法参数提示\n\n\n\n# 整合github\n\n在IDEA中设置GitHub，File-->Setting->Version Control-->GibHub\n\n创建本地仓库，VCS-->Import into Version Control-->Create Git Repository\n\nVCS-->Import into Version Control-->Share Project on GitHub\n\n# UML\n\n1. 右键一个类--Diagram--show Diagrams\n2. 对一个类,右键,可用`show Parents`,`show implementations`\n3. 也可以新添加类,对一个类按空格\n\n","slug":"Tools笔记/idea","published":1,"updated":"2020-11-12T11:57:29.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6x30030jotphi8yh7ug","content":"<h1 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h1><hr>\n<ol>\n<li><p>File Export Settings先导出一份自己熟悉使用的设置，导出为 settings.jar.新电脑就直接file import Settings</p>\n</li>\n<li><p>下载ultimate版本的,注册可以用去官网学生认证</p>\n</li>\n<li><p>全屏，view，appearance，full screen；如果顶部菜单栏不见了，改ui.inf.xml的<option name=\"SHOW_MAIN_MENU\" value=\"false\" />这个选项为false，将其修改为true</p>\n</li>\n<li><p>大小写不敏感：setting-&gt;Editor-&gt;General-&gt;Code Completion取消Match case</p>\n</li>\n<li><p>花括号File-&gt;Setting-&gt;Editor-&gt;Code Style-&gt;Java-&gt;Wrapping and Braces</p>\n</li>\n<li><blockquote>\n<p>自定义模板</p>\n<p>File –&gt; Setting中, 搜索live…要设置下面的change，选java</p>\n<p>fori不用配置</p>\n<p>集合.for增强for循环快捷键  </p>\n<p>sys:System.out.print($END$);</p>\n</blockquote>\n</li>\n<li><p>ctrl+F8设置断点,改成ctrl+shift+B,记得去除之前的一个</p>\n</li>\n<li><p>格式化 ctrl+shift+F,在右边搜索栏输入：reformat code </p>\n</li>\n<li><p>Args传入参数：Run下的Edit Configurations，配置Configuration分页中的Program arguments选项</p>\n</li>\n<li><p>Ctrl+鼠标滑轮控制字体大小，在File -&gt; Setting -&gt; Editor -&gt; General下进行设置。选中Change font size (Zoom) with Ctrl+Mouse wheel </p>\n</li>\n<li><p>设置idea背景,File | Settings | Appearance &amp; Behavior | Appearance|background Image</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"快捷键-常用\"><a href=\"#快捷键-常用\" class=\"headerlink\" title=\"快捷键(常用)\"></a>快捷键(常用)</h1><ol>\n<li><p>Alt+enter内容辅助，可以这样比较方便的新建一个类,或者是修改建议</p>\n</li>\n<li><p>Ctrl +Y 删除代码</p>\n</li>\n<li><p>代码的上下移动，ctrl+shift+上下箭头</p>\n</li>\n<li><p>shift+F6 重命名</p>\n</li>\n<li><p>格式化 ctrl+shift+F</p>\n</li>\n<li><p>Ctrl+D 复制当前行到下一行</p>\n</li>\n<li><p>ctrl+/；ctrl+shift+/  注释</p>\n</li>\n<li><p>Alt+ins，快速生成get，set等等</p>\n</li>\n<li><p>Alt+1打开层次体系</p>\n</li>\n<li><p>行末加分号，ctrl+shift+enter</p>\n</li>\n<li><p>用F2移动到有错误的代码</p>\n</li>\n<li><p>Ctrl+alt+ins快速新建类</p>\n</li>\n<li><p>ctrl+shift+加减,代码折叠 </p>\n</li>\n<li><p>选中类名 Ctrl+鼠标点击  查看源码</p>\n</li>\n<li><p>shift+enter 快速下一行</p>\n</li>\n<li><p>Ctrl+删除，删除这个单词</p>\n</li>\n<li><p>.Ctrl+F搜索</p>\n</li>\n<li><p>ctrl+左右，快速跳过一个单词;Shift+上下,选中某行；</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"快捷键-常忘记的\"><a href=\"#快捷键-常忘记的\" class=\"headerlink\" title=\"快捷键(常忘记的)\"></a>快捷键(常忘记的)</h1><ol>\n<li>运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。Ctrl+F8 设置断点 。F7/F8/F9分别对应Step into，Step over，Continue，shift+F8退出方法</li>\n<li>抽取方法快捷键:ctrl+alt+m</li>\n<li>Ctrl+H打开类继承体系，ctrl+F12查看类所有方法</li>\n<li>Ctrl+Alt+V则是抽取变量</li>\n<li>Ctrl+W快速选中一行</li>\n<li>Ctrl+Tab切换类</li>\n<li>Shift+shift快速搜索，可以查找类</li>\n<li>Ctrl+alt+s 打开设置</li>\n<li>ctrl alt+t 用try catch等包裹代码</li>\n<li>shift+end或者home,快速选择一行</li>\n<li>ctrl+p方法参数提示</li>\n</ol>\n<h1 id=\"整合github\"><a href=\"#整合github\" class=\"headerlink\" title=\"整合github\"></a>整合github</h1><p>在IDEA中设置GitHub，File–&gt;Setting-&gt;Version Control–&gt;GibHub</p>\n<p>创建本地仓库，VCS–&gt;Import into Version Control–&gt;Create Git Repository</p>\n<p>VCS–&gt;Import into Version Control–&gt;Share Project on GitHub</p>\n<h1 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h1><ol>\n<li>右键一个类–Diagram–show Diagrams</li>\n<li>对一个类,右键,可用<code>show Parents</code>,<code>show implementations</code></li>\n<li>也可以新添加类,对一个类按空格</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h1><hr>\n<ol>\n<li><p>File Export Settings先导出一份自己熟悉使用的设置，导出为 settings.jar.新电脑就直接file import Settings</p>\n</li>\n<li><p>下载ultimate版本的,注册可以用去官网学生认证</p>\n</li>\n<li><p>全屏，view，appearance，full screen；如果顶部菜单栏不见了，改ui.inf.xml的<option name=\"SHOW_MAIN_MENU\" value=\"false\" />这个选项为false，将其修改为true</p>\n</li>\n<li><p>大小写不敏感：setting-&gt;Editor-&gt;General-&gt;Code Completion取消Match case</p>\n</li>\n<li><p>花括号File-&gt;Setting-&gt;Editor-&gt;Code Style-&gt;Java-&gt;Wrapping and Braces</p>\n</li>\n<li><blockquote>\n<p>自定义模板</p>\n<p>File –&gt; Setting中, 搜索live…要设置下面的change，选java</p>\n<p>fori不用配置</p>\n<p>集合.for增强for循环快捷键  </p>\n<p>sys:System.out.print($END$);</p>\n</blockquote>\n</li>\n<li><p>ctrl+F8设置断点,改成ctrl+shift+B,记得去除之前的一个</p>\n</li>\n<li><p>格式化 ctrl+shift+F,在右边搜索栏输入：reformat code </p>\n</li>\n<li><p>Args传入参数：Run下的Edit Configurations，配置Configuration分页中的Program arguments选项</p>\n</li>\n<li><p>Ctrl+鼠标滑轮控制字体大小，在File -&gt; Setting -&gt; Editor -&gt; General下进行设置。选中Change font size (Zoom) with Ctrl+Mouse wheel </p>\n</li>\n<li><p>设置idea背景,File | Settings | Appearance &amp; Behavior | Appearance|background Image</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"快捷键-常用\"><a href=\"#快捷键-常用\" class=\"headerlink\" title=\"快捷键(常用)\"></a>快捷键(常用)</h1><ol>\n<li><p>Alt+enter内容辅助，可以这样比较方便的新建一个类,或者是修改建议</p>\n</li>\n<li><p>Ctrl +Y 删除代码</p>\n</li>\n<li><p>代码的上下移动，ctrl+shift+上下箭头</p>\n</li>\n<li><p>shift+F6 重命名</p>\n</li>\n<li><p>格式化 ctrl+shift+F</p>\n</li>\n<li><p>Ctrl+D 复制当前行到下一行</p>\n</li>\n<li><p>ctrl+/；ctrl+shift+/  注释</p>\n</li>\n<li><p>Alt+ins，快速生成get，set等等</p>\n</li>\n<li><p>Alt+1打开层次体系</p>\n</li>\n<li><p>行末加分号，ctrl+shift+enter</p>\n</li>\n<li><p>用F2移动到有错误的代码</p>\n</li>\n<li><p>Ctrl+alt+ins快速新建类</p>\n</li>\n<li><p>ctrl+shift+加减,代码折叠 </p>\n</li>\n<li><p>选中类名 Ctrl+鼠标点击  查看源码</p>\n</li>\n<li><p>shift+enter 快速下一行</p>\n</li>\n<li><p>Ctrl+删除，删除这个单词</p>\n</li>\n<li><p>.Ctrl+F搜索</p>\n</li>\n<li><p>ctrl+左右，快速跳过一个单词;Shift+上下,选中某行；</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"快捷键-常忘记的\"><a href=\"#快捷键-常忘记的\" class=\"headerlink\" title=\"快捷键(常忘记的)\"></a>快捷键(常忘记的)</h1><ol>\n<li>运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。Ctrl+F8 设置断点 。F7/F8/F9分别对应Step into，Step over，Continue，shift+F8退出方法</li>\n<li>抽取方法快捷键:ctrl+alt+m</li>\n<li>Ctrl+H打开类继承体系，ctrl+F12查看类所有方法</li>\n<li>Ctrl+Alt+V则是抽取变量</li>\n<li>Ctrl+W快速选中一行</li>\n<li>Ctrl+Tab切换类</li>\n<li>Shift+shift快速搜索，可以查找类</li>\n<li>Ctrl+alt+s 打开设置</li>\n<li>ctrl alt+t 用try catch等包裹代码</li>\n<li>shift+end或者home,快速选择一行</li>\n<li>ctrl+p方法参数提示</li>\n</ol>\n<h1 id=\"整合github\"><a href=\"#整合github\" class=\"headerlink\" title=\"整合github\"></a>整合github</h1><p>在IDEA中设置GitHub，File–&gt;Setting-&gt;Version Control–&gt;GibHub</p>\n<p>创建本地仓库，VCS–&gt;Import into Version Control–&gt;Create Git Repository</p>\n<p>VCS–&gt;Import into Version Control–&gt;Share Project on GitHub</p>\n<h1 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h1><ol>\n<li>右键一个类–Diagram–show Diagrams</li>\n<li>对一个类,右键,可用<code>show Parents</code>,<code>show implementations</code></li>\n<li>也可以新添加类,对一个类按空格</li>\n</ol>\n"},{"title":"linux常用命令与使用","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,主要写了linux常用命令与使用","abbrlink":"9f1ebbb4","date":"2020-07-29T16:00:00.000Z","_content":"\n# 基础知识\n\n1. root的家目录为/root,所以~代表了/root。其余的则在/home/用户名\n2. /usr/local:系统管理员在本机安装自己下载的软件建议安装的目录\n\n\n\n\n\n# 常用操作\n\n1. \\为转义字符，可以后跟回车，使命令连续到下一行\n\n2. tab tab，命令补全\n\n3. man 命令，查看用法\n\n4. ctrl+C终止命令\n\n5. ctrl+D退出终端\n\n6. > 目录操作\n  >\n  > cd \n  >\n  > pwd \n  >\n  > mkdir         -p可以递归创建\n  >\n  > rmdir          -r可以删除有文件的目录\n\n7. >  文件操作\n  >\n  > cp 源文件 目标位置  -r可以复制目录\n  >\n  > rm  -rf  文件/目录   递归删除,且不会出现提示信息\n  >\n  > mv test test1 可以实现更名操作\n\n8. > 查找文件\n  >\n  > find /usr -name \"jdk*\" -type d   查找在/usr下查找目录包含jdk的文件\n\n9. > 解压缩\n  >\n  > tar -zxv -f filename.tar.gz  -C 解压缩的目录\n\n# vim\n\n1. >三种模式:一般模式,编辑模式,命令行模式\n\t>\n\t>一般模式按i进入编辑模式,输入/进入命令行模式.其他两个模式按ESC退出到一般模式\n\n2. > 退出:\n\t>\n\t> :wq 保存退出\n\t>\n\t> :q! 强制退出不保存\n\n3. > 一般模式\n\t>\n\t> Page UP,Page DOWN翻页\n\t>\n\t> HOME,END移动到该行首/尾\n\t>\n\t> G移动到末尾,数字G移动到某行,1G则可以移动到开头\n\n4. > 查找\n\t>\n\t> /word向下继续查找\n\t>\n\t>  n为重复前一个查找操作,所以可以配合着向下找.N则向上找\n\n5. > 删除一整行 dd\n\t>\n\t> 复制一整行 yy\n\t>\n\t> 将复制数据粘贴 p\n\t>\n\t> 撤销前一个操作 u\n\n\t\n\n# 进程管理\n\n1. ps aux 查看所有进程\n2. top 动态查看进程 默认以CPU占用率排序 查看即时活跃的进程，类似Windows的任务管理器\n3. 查看端口是否占用: netstat -tunlp |grep 8000\n4.  ps -ef | grep -i java\n5.  kill -s 9 xxx\n\n\n\n\n\n\n\n","source":"_posts/Tools笔记/linux.md","raw":"---\ntitle: linux常用命令与使用\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,主要写了linux常用命令与使用'\ncategories: 常用工具\ntags:\n  - 工具\n  - linux\nabbrlink: 9f1ebbb4\ndate: 2020-07-30 00:00:00\n---\n\n# 基础知识\n\n1. root的家目录为/root,所以~代表了/root。其余的则在/home/用户名\n2. /usr/local:系统管理员在本机安装自己下载的软件建议安装的目录\n\n\n\n\n\n# 常用操作\n\n1. \\为转义字符，可以后跟回车，使命令连续到下一行\n\n2. tab tab，命令补全\n\n3. man 命令，查看用法\n\n4. ctrl+C终止命令\n\n5. ctrl+D退出终端\n\n6. > 目录操作\n  >\n  > cd \n  >\n  > pwd \n  >\n  > mkdir         -p可以递归创建\n  >\n  > rmdir          -r可以删除有文件的目录\n\n7. >  文件操作\n  >\n  > cp 源文件 目标位置  -r可以复制目录\n  >\n  > rm  -rf  文件/目录   递归删除,且不会出现提示信息\n  >\n  > mv test test1 可以实现更名操作\n\n8. > 查找文件\n  >\n  > find /usr -name \"jdk*\" -type d   查找在/usr下查找目录包含jdk的文件\n\n9. > 解压缩\n  >\n  > tar -zxv -f filename.tar.gz  -C 解压缩的目录\n\n# vim\n\n1. >三种模式:一般模式,编辑模式,命令行模式\n\t>\n\t>一般模式按i进入编辑模式,输入/进入命令行模式.其他两个模式按ESC退出到一般模式\n\n2. > 退出:\n\t>\n\t> :wq 保存退出\n\t>\n\t> :q! 强制退出不保存\n\n3. > 一般模式\n\t>\n\t> Page UP,Page DOWN翻页\n\t>\n\t> HOME,END移动到该行首/尾\n\t>\n\t> G移动到末尾,数字G移动到某行,1G则可以移动到开头\n\n4. > 查找\n\t>\n\t> /word向下继续查找\n\t>\n\t>  n为重复前一个查找操作,所以可以配合着向下找.N则向上找\n\n5. > 删除一整行 dd\n\t>\n\t> 复制一整行 yy\n\t>\n\t> 将复制数据粘贴 p\n\t>\n\t> 撤销前一个操作 u\n\n\t\n\n# 进程管理\n\n1. ps aux 查看所有进程\n2. top 动态查看进程 默认以CPU占用率排序 查看即时活跃的进程，类似Windows的任务管理器\n3. 查看端口是否占用: netstat -tunlp |grep 8000\n4.  ps -ef | grep -i java\n5.  kill -s 9 xxx\n\n\n\n\n\n\n\n","slug":"Tools笔记/linux","published":1,"updated":"2020-11-12T11:57:29.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6x50034jotpazyg1vox","content":"<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><ol>\n<li>root的家目录为/root,所以~代表了/root。其余的则在/home/用户名</li>\n<li>/usr/local:系统管理员在本机安装自己下载的软件建议安装的目录</li>\n</ol>\n<h1 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h1><ol>\n<li><p>\\为转义字符，可以后跟回车，使命令连续到下一行</p>\n</li>\n<li><p>tab tab，命令补全</p>\n</li>\n<li><p>man 命令，查看用法</p>\n</li>\n<li><p>ctrl+C终止命令</p>\n</li>\n<li><p>ctrl+D退出终端</p>\n</li>\n<li><blockquote>\n<p>目录操作</p>\n<p>cd </p>\n<p>pwd </p>\n<p>mkdir         -p可以递归创建</p>\n<p>rmdir          -r可以删除有文件的目录</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p> 文件操作</p>\n<p>cp 源文件 目标位置  -r可以复制目录</p>\n<p>rm  -rf  文件/目录   递归删除,且不会出现提示信息</p>\n<p>mv test test1 可以实现更名操作</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>查找文件</p>\n<p>find /usr -name “jdk*” -type d   查找在/usr下查找目录包含jdk的文件</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>解压缩</p>\n<p>tar -zxv -f filename.tar.gz  -C 解压缩的目录</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h1><ol>\n<li><blockquote>\n<p>三种模式:一般模式,编辑模式,命令行模式</p>\n<p>一般模式按i进入编辑模式,输入/进入命令行模式.其他两个模式按ESC退出到一般模式</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>退出:</p>\n<p>:wq 保存退出</p>\n<p>:q! 强制退出不保存</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>一般模式</p>\n<p>Page UP,Page DOWN翻页</p>\n<p>HOME,END移动到该行首/尾</p>\n<p>G移动到末尾,数字G移动到某行,1G则可以移动到开头</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>查找</p>\n<p>/word向下继续查找</p>\n<p> n为重复前一个查找操作,所以可以配合着向下找.N则向上找</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>删除一整行 dd</p>\n<p>复制一整行 yy</p>\n<p>将复制数据粘贴 p</p>\n<p>撤销前一个操作 u</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h1><ol>\n<li>ps aux 查看所有进程</li>\n<li>top 动态查看进程 默认以CPU占用率排序 查看即时活跃的进程，类似Windows的任务管理器</li>\n<li>查看端口是否占用: netstat -tunlp |grep 8000</li>\n<li>ps -ef | grep -i java</li>\n<li>kill -s 9 xxx</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><ol>\n<li>root的家目录为/root,所以~代表了/root。其余的则在/home/用户名</li>\n<li>/usr/local:系统管理员在本机安装自己下载的软件建议安装的目录</li>\n</ol>\n<h1 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h1><ol>\n<li><p>\\为转义字符，可以后跟回车，使命令连续到下一行</p>\n</li>\n<li><p>tab tab，命令补全</p>\n</li>\n<li><p>man 命令，查看用法</p>\n</li>\n<li><p>ctrl+C终止命令</p>\n</li>\n<li><p>ctrl+D退出终端</p>\n</li>\n<li><blockquote>\n<p>目录操作</p>\n<p>cd </p>\n<p>pwd </p>\n<p>mkdir         -p可以递归创建</p>\n<p>rmdir          -r可以删除有文件的目录</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p> 文件操作</p>\n<p>cp 源文件 目标位置  -r可以复制目录</p>\n<p>rm  -rf  文件/目录   递归删除,且不会出现提示信息</p>\n<p>mv test test1 可以实现更名操作</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>查找文件</p>\n<p>find /usr -name “jdk*” -type d   查找在/usr下查找目录包含jdk的文件</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>解压缩</p>\n<p>tar -zxv -f filename.tar.gz  -C 解压缩的目录</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h1><ol>\n<li><blockquote>\n<p>三种模式:一般模式,编辑模式,命令行模式</p>\n<p>一般模式按i进入编辑模式,输入/进入命令行模式.其他两个模式按ESC退出到一般模式</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>退出:</p>\n<p>:wq 保存退出</p>\n<p>:q! 强制退出不保存</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>一般模式</p>\n<p>Page UP,Page DOWN翻页</p>\n<p>HOME,END移动到该行首/尾</p>\n<p>G移动到末尾,数字G移动到某行,1G则可以移动到开头</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>查找</p>\n<p>/word向下继续查找</p>\n<p> n为重复前一个查找操作,所以可以配合着向下找.N则向上找</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>删除一整行 dd</p>\n<p>复制一整行 yy</p>\n<p>将复制数据粘贴 p</p>\n<p>撤销前一个操作 u</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h1><ol>\n<li>ps aux 查看所有进程</li>\n<li>top 动态查看进程 默认以CPU占用率排序 查看即时活跃的进程，类似Windows的任务管理器</li>\n<li>查看端口是否占用: netstat -tunlp |grep 8000</li>\n<li>ps -ef | grep -i java</li>\n<li>kill -s 9 xxx</li>\n</ol>\n"},{"title":"SSH常用命令与使用","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,主要写了SSH常用命令与使用","abbrlink":"50d6952b","date":"2020-06-21T16:00:00.000Z","_content":"\n### 连接\n\n```java\nTools——Deployment——Configuration \n\n点击加号  选择SFTP\n\nSSH configuration需要额外配置\n\n配置Mappings ,即本地资源路径和远程路径的映射\n\nLocal path是本地资源路径，Deployment path on server 是远程服务器对应的文件路径 \n```\n\n\n\n### 中文乱码问题\n\n```java\necho $LANG查看字符集\n\n在 /etc/profile配置文件添加export LANG=\"zh_CN.UTF-8\"\n\n. /etc/profile 重新载入\n```\n\n idea SSH连接中文乱码\n\n> File>Settings>Tools>SSH Terminal> Default encoding设为utf-8\n>\n> 重新启动idea\n\n\n\n### 上传文件\n\n>Tools---Deployment---- Remote Host \n>\n>一定要选择映射的那个文件夹----右键---Upload here","source":"_posts/Tools笔记/ssh.md","raw":"---\ntitle: SSH常用命令与使用\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,主要写了SSH常用命令与使用'\ncategories: 常用工具\ntags:\n  - 工具\n  - SSH\nabbrlink: 50d6952b\ndate: 2020-06-22 00:00:00\n---\n\n### 连接\n\n```java\nTools——Deployment——Configuration \n\n点击加号  选择SFTP\n\nSSH configuration需要额外配置\n\n配置Mappings ,即本地资源路径和远程路径的映射\n\nLocal path是本地资源路径，Deployment path on server 是远程服务器对应的文件路径 \n```\n\n\n\n### 中文乱码问题\n\n```java\necho $LANG查看字符集\n\n在 /etc/profile配置文件添加export LANG=\"zh_CN.UTF-8\"\n\n. /etc/profile 重新载入\n```\n\n idea SSH连接中文乱码\n\n> File>Settings>Tools>SSH Terminal> Default encoding设为utf-8\n>\n> 重新启动idea\n\n\n\n### 上传文件\n\n>Tools---Deployment---- Remote Host \n>\n>一定要选择映射的那个文件夹----右键---Upload here","slug":"Tools笔记/ssh","published":1,"updated":"2020-11-12T11:57:29.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6x60037jotp2u6g74e5","content":"<h3 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h3><pre class=\" language-java\"><code class=\"language-java\">Tools——Deployment——Configuration \n\n点击加号  选择SFTP\n\nSSH configuration需要额外配置\n\n配置Mappings <span class=\"token punctuation\">,</span>即本地资源路径和远程路径的映射\n\nLocal path是本地资源路径，Deployment path on server 是远程服务器对应的文件路径 </code></pre>\n<h3 id=\"中文乱码问题\"><a href=\"#中文乱码问题\" class=\"headerlink\" title=\"中文乱码问题\"></a>中文乱码问题</h3><pre class=\" language-java\"><code class=\"language-java\">echo $LANG查看字符集\n\n在 <span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>profile配置文件添加export LANG<span class=\"token operator\">=</span><span class=\"token string\">\"zh_CN.UTF-8\"</span>\n\n<span class=\"token punctuation\">.</span> <span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>profile 重新载入</code></pre>\n<p> idea SSH连接中文乱码</p>\n<blockquote>\n<p>File&gt;Settings&gt;Tools&gt;SSH Terminal&gt; Default encoding设为utf-8</p>\n<p>重新启动idea</p>\n</blockquote>\n<h3 id=\"上传文件\"><a href=\"#上传文件\" class=\"headerlink\" title=\"上传文件\"></a>上传文件</h3><blockquote>\n<p>Tools—Deployment—- Remote Host </p>\n<p>一定要选择映射的那个文件夹—-右键—Upload here</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h3><pre><code class=\"java\">Tools——Deployment——Configuration \n\n点击加号  选择SFTP\n\nSSH configuration需要额外配置\n\n配置Mappings ,即本地资源路径和远程路径的映射\n\nLocal path是本地资源路径，Deployment path on server 是远程服务器对应的文件路径 </code></pre>\n<h3 id=\"中文乱码问题\"><a href=\"#中文乱码问题\" class=\"headerlink\" title=\"中文乱码问题\"></a>中文乱码问题</h3><pre><code class=\"java\">echo $LANG查看字符集\n\n在 /etc/profile配置文件添加export LANG=&quot;zh_CN.UTF-8&quot;\n\n. /etc/profile 重新载入</code></pre>\n<p> idea SSH连接中文乱码</p>\n<blockquote>\n<p>File&gt;Settings&gt;Tools&gt;SSH Terminal&gt; Default encoding设为utf-8</p>\n<p>重新启动idea</p>\n</blockquote>\n<h3 id=\"上传文件\"><a href=\"#上传文件\" class=\"headerlink\" title=\"上传文件\"></a>上传文件</h3><blockquote>\n<p>Tools—Deployment—- Remote Host </p>\n<p>一定要选择映射的那个文件夹—-右键—Upload here</p>\n</blockquote>\n"},{"title":"markdown常用命令与使用","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,主要写了markdown常用命令与使用","abbrlink":"db5a7195","date":"2020-07-19T16:00:00.000Z","_content":"\n# markdown常用语法\n\n1. \\# 内容为标题，多个#为多级标题,注意要空格\n2. 一个\\*包围为倾斜，两个\\**包围为加粗，三个\\*为斜体加粗\n3. \\>引用,可以多级引用\n4. \\---为分割线\n5. \\[链接名字](链接地址)  图片链接\n6. \\+ 内容,无序列表,一定要有空格\n7. 1\\.  内容，有序列表\n8. \\`\\`\\`java  \\`\\`\\`为代码块\n9. 一个\\`包围的为一行代码\n\n# Typora的快捷键\n1. 切换到源代码编辑模式:ctrl+/\n2. [toc]快速生成目录","source":"_posts/Tools笔记/markdown.md","raw":"---\ntitle: markdown常用命令与使用\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,主要写了markdown常用命令与使用'\ncategories: 常用工具\ntags:\n  - 工具\n  - markdown\nabbrlink: db5a7195\ndate: 2020-07-20 00:00:00\n---\n\n# markdown常用语法\n\n1. \\# 内容为标题，多个#为多级标题,注意要空格\n2. 一个\\*包围为倾斜，两个\\**包围为加粗，三个\\*为斜体加粗\n3. \\>引用,可以多级引用\n4. \\---为分割线\n5. \\[链接名字](链接地址)  图片链接\n6. \\+ 内容,无序列表,一定要有空格\n7. 1\\.  内容，有序列表\n8. \\`\\`\\`java  \\`\\`\\`为代码块\n9. 一个\\`包围的为一行代码\n\n# Typora的快捷键\n1. 切换到源代码编辑模式:ctrl+/\n2. [toc]快速生成目录","slug":"Tools笔记/markdown","published":1,"updated":"2020-11-12T11:57:29.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6x7003bjotpaj9d9en8","content":"<h1 id=\"markdown常用语法\"><a href=\"#markdown常用语法\" class=\"headerlink\" title=\"markdown常用语法\"></a>markdown常用语法</h1><ol>\n<li># 内容为标题，多个#为多级标题,注意要空格</li>\n<li>一个*包围为倾斜，两个*<em>包围为加粗，三个\\</em>为斜体加粗</li>\n<li>&gt;引用,可以多级引用</li>\n<li>-–为分割线</li>\n<li>[链接名字](链接地址)  图片链接</li>\n<li>+ 内容,无序列表,一定要有空格</li>\n<li>1.  内容，有序列表</li>\n<li>```java  ```为代码块</li>\n<li>一个`包围的为一行代码</li>\n</ol>\n<h1 id=\"Typora的快捷键\"><a href=\"#Typora的快捷键\" class=\"headerlink\" title=\"Typora的快捷键\"></a>Typora的快捷键</h1><ol>\n<li>切换到源代码编辑模式:ctrl+/</li>\n<li>[toc]快速生成目录</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"markdown常用语法\"><a href=\"#markdown常用语法\" class=\"headerlink\" title=\"markdown常用语法\"></a>markdown常用语法</h1><ol>\n<li># 内容为标题，多个#为多级标题,注意要空格</li>\n<li>一个*包围为倾斜，两个*<em>包围为加粗，三个\\</em>为斜体加粗</li>\n<li>&gt;引用,可以多级引用</li>\n<li>-–为分割线</li>\n<li>[链接名字](链接地址)  图片链接</li>\n<li>+ 内容,无序列表,一定要有空格</li>\n<li>1.  内容，有序列表</li>\n<li>```java  ```为代码块</li>\n<li>一个`包围的为一行代码</li>\n</ol>\n<h1 id=\"Typora的快捷键\"><a href=\"#Typora的快捷键\" class=\"headerlink\" title=\"Typora的快捷键\"></a>Typora的快捷键</h1><ol>\n<li>切换到源代码编辑模式:ctrl+/</li>\n<li>[toc]快速生成目录</li>\n</ol>\n"},{"title":"markdown的一些操作与图床","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,主要介绍了markdown的一些操作与图床","abbrlink":"96c9e0d0","date":"2019-12-24T16:00:00.000Z","_content":"\n\n\n# word文件快速转md文件并且上传至CSDN\n\n> 学校的项目基本都要写项目说明文档,并且要求提交word版本的\n>\n> 写好后我想上传到CSDN上,但是又不想手动改为md文件\n\n> 而且之前的图片内嵌在word里面,直接上传CSDN会有个防盗链,手动太麻烦\n>\n> 折腾了一上午,终于搜索到了解决办法,记录下来,之后不用再重新找资料\n>\n> 主要解决两个问题,一个是转为md文件,一个是图床相关问题\n\n\n\n\n\n## 1.图床解决方案\n\n> 阿里云+typora+picGo图床配置\n>\n> [参考博客](https://blog.csdn.net/qq_39132095/article/details/106317768)\n>\n> 坑:\n>\n> PicGo选择`仅为我安装`，否则在Typora`验证图片上传选项`时会出现错误\n>\n> 如果Typora`验证图片上传选项`出现Failed to fetch错误,则在`PicGo设置->设置Server`中端口改为36677并重新关开\n>\n\n## 2.word转md上传到CSDN,并且保存图片\n\n> 下载并安装`Writage`插件\n>\n> 另存为时保存为md文件\n>\n> 在`文件-偏好设置-图像`中,设置为这样:\n>\n> ![LE45L1$ZJ$EINKQAZK}58QN](https://tongji4m3.oss-cn-beijing.aliyuncs.com/LE45L1$ZJ$EINKQAZK}58QN.png)\n>\n> 然后选择`格式-图像-上传所有本地图片`\n>\n> 最后,在CSDN写博客页面中,导入该md文件即可!\n\n","source":"_posts/Tools笔记/图床.md","raw":"---\ntitle: markdown的一些操作与图床\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,主要介绍了markdown的一些操作与图床'\ncategories: 常用工具\ntags:\n  - 工具\n  - 图床\n  - markdown\nabbrlink: 96c9e0d0\ndate: 2019-12-25 00:00:00\n---\n\n\n\n# word文件快速转md文件并且上传至CSDN\n\n> 学校的项目基本都要写项目说明文档,并且要求提交word版本的\n>\n> 写好后我想上传到CSDN上,但是又不想手动改为md文件\n\n> 而且之前的图片内嵌在word里面,直接上传CSDN会有个防盗链,手动太麻烦\n>\n> 折腾了一上午,终于搜索到了解决办法,记录下来,之后不用再重新找资料\n>\n> 主要解决两个问题,一个是转为md文件,一个是图床相关问题\n\n\n\n\n\n## 1.图床解决方案\n\n> 阿里云+typora+picGo图床配置\n>\n> [参考博客](https://blog.csdn.net/qq_39132095/article/details/106317768)\n>\n> 坑:\n>\n> PicGo选择`仅为我安装`，否则在Typora`验证图片上传选项`时会出现错误\n>\n> 如果Typora`验证图片上传选项`出现Failed to fetch错误,则在`PicGo设置->设置Server`中端口改为36677并重新关开\n>\n\n## 2.word转md上传到CSDN,并且保存图片\n\n> 下载并安装`Writage`插件\n>\n> 另存为时保存为md文件\n>\n> 在`文件-偏好设置-图像`中,设置为这样:\n>\n> ![LE45L1$ZJ$EINKQAZK}58QN](https://tongji4m3.oss-cn-beijing.aliyuncs.com/LE45L1$ZJ$EINKQAZK}58QN.png)\n>\n> 然后选择`格式-图像-上传所有本地图片`\n>\n> 最后,在CSDN写博客页面中,导入该md文件即可!\n\n","slug":"Tools笔记/图床","published":1,"updated":"2020-11-12T11:57:29.987Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6x8003ejotp5uoufkih","content":"<h1 id=\"word文件快速转md文件并且上传至CSDN\"><a href=\"#word文件快速转md文件并且上传至CSDN\" class=\"headerlink\" title=\"word文件快速转md文件并且上传至CSDN\"></a>word文件快速转md文件并且上传至CSDN</h1><blockquote>\n<p>学校的项目基本都要写项目说明文档,并且要求提交word版本的</p>\n<p>写好后我想上传到CSDN上,但是又不想手动改为md文件</p>\n</blockquote>\n<blockquote>\n<p>而且之前的图片内嵌在word里面,直接上传CSDN会有个防盗链,手动太麻烦</p>\n<p>折腾了一上午,终于搜索到了解决办法,记录下来,之后不用再重新找资料</p>\n<p>主要解决两个问题,一个是转为md文件,一个是图床相关问题</p>\n</blockquote>\n<h2 id=\"1-图床解决方案\"><a href=\"#1-图床解决方案\" class=\"headerlink\" title=\"1.图床解决方案\"></a>1.图床解决方案</h2><blockquote>\n<p>阿里云+typora+picGo图床配置</p>\n<p><a href=\"https://blog.csdn.net/qq_39132095/article/details/106317768\" target=\"_blank\" rel=\"noopener\">参考博客</a></p>\n<p>坑:</p>\n<p>PicGo选择<code>仅为我安装</code>，否则在Typora<code>验证图片上传选项</code>时会出现错误</p>\n<p>如果Typora<code>验证图片上传选项</code>出现Failed to fetch错误,则在<code>PicGo设置-&gt;设置Server</code>中端口改为36677并重新关开</p>\n</blockquote>\n<h2 id=\"2-word转md上传到CSDN-并且保存图片\"><a href=\"#2-word转md上传到CSDN-并且保存图片\" class=\"headerlink\" title=\"2.word转md上传到CSDN,并且保存图片\"></a>2.word转md上传到CSDN,并且保存图片</h2><blockquote>\n<p>下载并安装<code>Writage</code>插件</p>\n<p>另存为时保存为md文件</p>\n<p>在<code>文件-偏好设置-图像</code>中,设置为这样:</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/LE45L1$ZJ$EINKQAZK%7D58QN.png\" alt=\"LE45L1$ZJ$EINKQAZK}58QN\"></p>\n<p>然后选择<code>格式-图像-上传所有本地图片</code></p>\n<p>最后,在CSDN写博客页面中,导入该md文件即可!</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"word文件快速转md文件并且上传至CSDN\"><a href=\"#word文件快速转md文件并且上传至CSDN\" class=\"headerlink\" title=\"word文件快速转md文件并且上传至CSDN\"></a>word文件快速转md文件并且上传至CSDN</h1><blockquote>\n<p>学校的项目基本都要写项目说明文档,并且要求提交word版本的</p>\n<p>写好后我想上传到CSDN上,但是又不想手动改为md文件</p>\n</blockquote>\n<blockquote>\n<p>而且之前的图片内嵌在word里面,直接上传CSDN会有个防盗链,手动太麻烦</p>\n<p>折腾了一上午,终于搜索到了解决办法,记录下来,之后不用再重新找资料</p>\n<p>主要解决两个问题,一个是转为md文件,一个是图床相关问题</p>\n</blockquote>\n<h2 id=\"1-图床解决方案\"><a href=\"#1-图床解决方案\" class=\"headerlink\" title=\"1.图床解决方案\"></a>1.图床解决方案</h2><blockquote>\n<p>阿里云+typora+picGo图床配置</p>\n<p><a href=\"https://blog.csdn.net/qq_39132095/article/details/106317768\" target=\"_blank\" rel=\"noopener\">参考博客</a></p>\n<p>坑:</p>\n<p>PicGo选择<code>仅为我安装</code>，否则在Typora<code>验证图片上传选项</code>时会出现错误</p>\n<p>如果Typora<code>验证图片上传选项</code>出现Failed to fetch错误,则在<code>PicGo设置-&gt;设置Server</code>中端口改为36677并重新关开</p>\n</blockquote>\n<h2 id=\"2-word转md上传到CSDN-并且保存图片\"><a href=\"#2-word转md上传到CSDN-并且保存图片\" class=\"headerlink\" title=\"2.word转md上传到CSDN,并且保存图片\"></a>2.word转md上传到CSDN,并且保存图片</h2><blockquote>\n<p>下载并安装<code>Writage</code>插件</p>\n<p>另存为时保存为md文件</p>\n<p>在<code>文件-偏好设置-图像</code>中,设置为这样:</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/LE45L1$ZJ$EINKQAZK%7D58QN.png\" alt=\"LE45L1$ZJ$EINKQAZK}58QN\"></p>\n<p>然后选择<code>格式-图像-上传所有本地图片</code></p>\n<p>最后,在CSDN写博客页面中,导入该md文件即可!</p>\n</blockquote>\n"},{"title":"重装系统与windows常用配置","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,主要介绍重装系统与windows常用配置","abbrlink":"12863071","date":"2019-11-30T16:00:00.000Z","_content":"\n> 隔几个月就重装系统,记录下来之后好安装 \n\n1. 下载地址[win10](https://www.microsoft.com/zh-cn/software-download/windows10)\n2. 运行下载的软件,下载进U盘.(会初始化U盘,并且挺久的)\n3. 进入BIOS,以U盘启动(神州是F2进入BIOS,选boot manager 直接点击U盘)\n4. 自定义安装，不要选升级\n5. 将固态硬盘所有分区删除，剩下一块未分配空间。选新建，应用。选主分区，下一步\n\n### 一些设置\n\n1. 关闭触摸板:在设置里面关闭触摸板\n2. 设置IE下载路径，方便统一管理\n3. 下载软件注意自定义安装设置\n4. 删除桌面图标:右键单击桌面，“个性化”“主题”“桌面图标设置”\n5. win+e显示C盘D盘等:window+e “查看”，点击右边“选项”，设置为此电脑\n6. 关闭windows安全中心,下载弹窗提醒的时候,选择关闭\n7. 驱动安装（安装04_NVIDIA下的） [神州驱动官网下载](http://www.hasee.com/Chinese/download/computer.aspx?cid=105001003001001)\n8. 驱动设置(神州).（先在桌面空白处，点击鼠标右键——选择“NVIDIA”控制面板进入——选择“管理3D设置”——将显卡设置为全局“高性能NVIDIA显卡“运行，——点击应用）设置physx配置-勾选独显-点击应用             \n\n### 安装完成了，进行软件安装\n\n6. popPlayer,固定到开始屏幕\n7. > Everything\n   >\n   > 工具,选项,自启动,快捷键,ctrl+q \n   >\n   > 设置排除扫描某些文件夹:\n   >\n   > 工具,选项,排除列表\n8. 核心软件里面,安装Ghelper2.2.1.all,Chrome,添加扩展程序，然后登陆， [无法添加扩展程序解决办法](https://blog.csdn.net/wancongconga/article/details/106665648 )\n9. Chrome设置默认下载位置，设置为默认浏览器\n10. 下火绒，启动项管理，弹窗拦截\n11. 安装欧陆词典 开机自启 快捷键 ctrl+L\n\n","source":"_posts/Tools笔记/重装系统.md","raw":"---\ntitle: 重装系统与windows常用配置\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,主要介绍重装系统与windows常用配置'\ncategories: 常用工具\ntags:\n  - 工具\nabbrlink: '12863071'\ndate: 2019-12-01 00:00:00\n---\n\n> 隔几个月就重装系统,记录下来之后好安装 \n\n1. 下载地址[win10](https://www.microsoft.com/zh-cn/software-download/windows10)\n2. 运行下载的软件,下载进U盘.(会初始化U盘,并且挺久的)\n3. 进入BIOS,以U盘启动(神州是F2进入BIOS,选boot manager 直接点击U盘)\n4. 自定义安装，不要选升级\n5. 将固态硬盘所有分区删除，剩下一块未分配空间。选新建，应用。选主分区，下一步\n\n### 一些设置\n\n1. 关闭触摸板:在设置里面关闭触摸板\n2. 设置IE下载路径，方便统一管理\n3. 下载软件注意自定义安装设置\n4. 删除桌面图标:右键单击桌面，“个性化”“主题”“桌面图标设置”\n5. win+e显示C盘D盘等:window+e “查看”，点击右边“选项”，设置为此电脑\n6. 关闭windows安全中心,下载弹窗提醒的时候,选择关闭\n7. 驱动安装（安装04_NVIDIA下的） [神州驱动官网下载](http://www.hasee.com/Chinese/download/computer.aspx?cid=105001003001001)\n8. 驱动设置(神州).（先在桌面空白处，点击鼠标右键——选择“NVIDIA”控制面板进入——选择“管理3D设置”——将显卡设置为全局“高性能NVIDIA显卡“运行，——点击应用）设置physx配置-勾选独显-点击应用             \n\n### 安装完成了，进行软件安装\n\n6. popPlayer,固定到开始屏幕\n7. > Everything\n   >\n   > 工具,选项,自启动,快捷键,ctrl+q \n   >\n   > 设置排除扫描某些文件夹:\n   >\n   > 工具,选项,排除列表\n8. 核心软件里面,安装Ghelper2.2.1.all,Chrome,添加扩展程序，然后登陆， [无法添加扩展程序解决办法](https://blog.csdn.net/wancongconga/article/details/106665648 )\n9. Chrome设置默认下载位置，设置为默认浏览器\n10. 下火绒，启动项管理，弹窗拦截\n11. 安装欧陆词典 开机自启 快捷键 ctrl+L\n\n","slug":"Tools笔记/重装系统","published":1,"updated":"2020-11-12T11:57:30.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6x9003ijotp1jxt72px","content":"<blockquote>\n<p>隔几个月就重装系统,记录下来之后好安装 </p>\n</blockquote>\n<ol>\n<li>下载地址<a href=\"https://www.microsoft.com/zh-cn/software-download/windows10\" target=\"_blank\" rel=\"noopener\">win10</a></li>\n<li>运行下载的软件,下载进U盘.(会初始化U盘,并且挺久的)</li>\n<li>进入BIOS,以U盘启动(神州是F2进入BIOS,选boot manager 直接点击U盘)</li>\n<li>自定义安装，不要选升级</li>\n<li>将固态硬盘所有分区删除，剩下一块未分配空间。选新建，应用。选主分区，下一步</li>\n</ol>\n<h3 id=\"一些设置\"><a href=\"#一些设置\" class=\"headerlink\" title=\"一些设置\"></a>一些设置</h3><ol>\n<li>关闭触摸板:在设置里面关闭触摸板</li>\n<li>设置IE下载路径，方便统一管理</li>\n<li>下载软件注意自定义安装设置</li>\n<li>删除桌面图标:右键单击桌面，“个性化”“主题”“桌面图标设置”</li>\n<li>win+e显示C盘D盘等:window+e “查看”，点击右边“选项”，设置为此电脑</li>\n<li>关闭windows安全中心,下载弹窗提醒的时候,选择关闭</li>\n<li>驱动安装（安装04_NVIDIA下的） <a href=\"http://www.hasee.com/Chinese/download/computer.aspx?cid=105001003001001\" target=\"_blank\" rel=\"noopener\">神州驱动官网下载</a></li>\n<li>驱动设置(神州).（先在桌面空白处，点击鼠标右键——选择“NVIDIA”控制面板进入——选择“管理3D设置”——将显卡设置为全局“高性能NVIDIA显卡“运行，——点击应用）设置physx配置-勾选独显-点击应用             </li>\n</ol>\n<h3 id=\"安装完成了，进行软件安装\"><a href=\"#安装完成了，进行软件安装\" class=\"headerlink\" title=\"安装完成了，进行软件安装\"></a>安装完成了，进行软件安装</h3><ol start=\"6\">\n<li>popPlayer,固定到开始屏幕</li>\n<li><blockquote>\n<p>Everything</p>\n<p>工具,选项,自启动,快捷键,ctrl+q </p>\n<p>设置排除扫描某些文件夹:</p>\n<p>工具,选项,排除列表</p>\n</blockquote>\n</li>\n<li>核心软件里面,安装Ghelper2.2.1.all,Chrome,添加扩展程序，然后登陆， <a href=\"https://blog.csdn.net/wancongconga/article/details/106665648\" target=\"_blank\" rel=\"noopener\">无法添加扩展程序解决办法</a></li>\n<li>Chrome设置默认下载位置，设置为默认浏览器</li>\n<li>下火绒，启动项管理，弹窗拦截</li>\n<li>安装欧陆词典 开机自启 快捷键 ctrl+L</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>隔几个月就重装系统,记录下来之后好安装 </p>\n</blockquote>\n<ol>\n<li>下载地址<a href=\"https://www.microsoft.com/zh-cn/software-download/windows10\" target=\"_blank\" rel=\"noopener\">win10</a></li>\n<li>运行下载的软件,下载进U盘.(会初始化U盘,并且挺久的)</li>\n<li>进入BIOS,以U盘启动(神州是F2进入BIOS,选boot manager 直接点击U盘)</li>\n<li>自定义安装，不要选升级</li>\n<li>将固态硬盘所有分区删除，剩下一块未分配空间。选新建，应用。选主分区，下一步</li>\n</ol>\n<h3 id=\"一些设置\"><a href=\"#一些设置\" class=\"headerlink\" title=\"一些设置\"></a>一些设置</h3><ol>\n<li>关闭触摸板:在设置里面关闭触摸板</li>\n<li>设置IE下载路径，方便统一管理</li>\n<li>下载软件注意自定义安装设置</li>\n<li>删除桌面图标:右键单击桌面，“个性化”“主题”“桌面图标设置”</li>\n<li>win+e显示C盘D盘等:window+e “查看”，点击右边“选项”，设置为此电脑</li>\n<li>关闭windows安全中心,下载弹窗提醒的时候,选择关闭</li>\n<li>驱动安装（安装04_NVIDIA下的） <a href=\"http://www.hasee.com/Chinese/download/computer.aspx?cid=105001003001001\" target=\"_blank\" rel=\"noopener\">神州驱动官网下载</a></li>\n<li>驱动设置(神州).（先在桌面空白处，点击鼠标右键——选择“NVIDIA”控制面板进入——选择“管理3D设置”——将显卡设置为全局“高性能NVIDIA显卡“运行，——点击应用）设置physx配置-勾选独显-点击应用             </li>\n</ol>\n<h3 id=\"安装完成了，进行软件安装\"><a href=\"#安装完成了，进行软件安装\" class=\"headerlink\" title=\"安装完成了，进行软件安装\"></a>安装完成了，进行软件安装</h3><ol start=\"6\">\n<li>popPlayer,固定到开始屏幕</li>\n<li><blockquote>\n<p>Everything</p>\n<p>工具,选项,自启动,快捷键,ctrl+q </p>\n<p>设置排除扫描某些文件夹:</p>\n<p>工具,选项,排除列表</p>\n</blockquote>\n</li>\n<li>核心软件里面,安装Ghelper2.2.1.all,Chrome,添加扩展程序，然后登陆， <a href=\"https://blog.csdn.net/wancongconga/article/details/106665648\" target=\"_blank\" rel=\"noopener\">无法添加扩展程序解决办法</a></li>\n<li>Chrome设置默认下载位置，设置为默认浏览器</li>\n<li>下火绒，启动项管理，弹窗拦截</li>\n<li>安装欧陆词典 开机自启 快捷键 ctrl+L</li>\n</ol>\n"},{"title":"windows常用命令与使用","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"一些常用工具的笔记,主要写了windows常用命令与使用","abbrlink":"cdafbbdb","date":"2019-12-24T16:00:00.000Z","_content":"\n# 常用\n\n1.window+空格，切换输入法\n2.Win + R 打开运行对话框,cmd命令\n3.Win + Q 快速打开搜索\n4.Alt+F4 快速关闭当前页面的快捷键\n5.window+E我的电脑\n6.快速切换窗口alt+tab\n7.Win+D：显示桌面，第二次键击恢复桌面\n8.Win +上下左右箭头 控制窗口大小\n9.Delete(或 Ctrl+D) 删除所选项目并将其移动到“回收站”\n10.Shift+Del 不先将所选项目移动到“回收站”而直接将其删除(不是backspace)\n11.F2 重命名选定项目\n12.Ctrl+Shift 加某个箭头键 选择一块文本\n13.F5(或 Ctrl+R) 刷新活动窗口\n14.Alt+向上键 在 Win资源管理器中查看上一级文件夹\n15.Ctrl+Shift+N 新建文件夹\n16.Ctrl+N 打开当前的一个新窗口\n17.Shift + F10 鼠标右键菜单\n18.Ctrl+T 打开新标签页 \n19.Ctrl+Tab 或 Ctrl+数字 切换标签页 \n20.Ctrl+W关闭当前标签页\n21.win+v，多条复制\n22.ctrl+.切换输入法为一直输入英文标点符号(不是数字键盘的那个.)\n23.按住“Shift”，右击。会比直接右击出的快捷菜单里多出个“复制为路径”(A)\n\n24.win+shift+s快速截屏\n\n25.ctrl+home,ctrl+end 到文章开头结尾\n\n\n\n---\n# 不常用\n\n1.Win + I 快速打开Win10设置栏\n2.Win + Tab(松开键盘界面不会消失) \n3.Win+G游戏录制声音之类\n4.Win+L：锁住电脑或切换用户\n5.Ctrl+向右键 将光标移动到下一个字词的起始处\nCtrl+向左键 将光标移动到上一个字词的起始处\nCtrl+向下键 将光标移动到下一个段落的起始处\nCtrl+向上键 将光标移动到上一个段落的起始处\n6.Ctrl+鼠标滚轮 更改桌面上的图标大小\n7.Alt+加下划线的字母 显示相应的菜单\n8.Alt+向左键 在 Win资源管理器中返回上次操作的文件夹\nCtrl+W 关闭当前窗口\n9.End 显示活动窗口的底端，Home 显示活动窗口的顶端\n10.F11 最大化或最小化活动窗口","source":"_posts/Tools笔记/windows.md","raw":"---\ntitle: windows常用命令与使用\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '一些常用工具的笔记,主要写了windows常用命令与使用'\ncategories: 常用工具\ntags:\n  - 工具\n  - windows\nabbrlink: cdafbbdb\ndate: 2019-12-25 00:00:00\n---\n\n# 常用\n\n1.window+空格，切换输入法\n2.Win + R 打开运行对话框,cmd命令\n3.Win + Q 快速打开搜索\n4.Alt+F4 快速关闭当前页面的快捷键\n5.window+E我的电脑\n6.快速切换窗口alt+tab\n7.Win+D：显示桌面，第二次键击恢复桌面\n8.Win +上下左右箭头 控制窗口大小\n9.Delete(或 Ctrl+D) 删除所选项目并将其移动到“回收站”\n10.Shift+Del 不先将所选项目移动到“回收站”而直接将其删除(不是backspace)\n11.F2 重命名选定项目\n12.Ctrl+Shift 加某个箭头键 选择一块文本\n13.F5(或 Ctrl+R) 刷新活动窗口\n14.Alt+向上键 在 Win资源管理器中查看上一级文件夹\n15.Ctrl+Shift+N 新建文件夹\n16.Ctrl+N 打开当前的一个新窗口\n17.Shift + F10 鼠标右键菜单\n18.Ctrl+T 打开新标签页 \n19.Ctrl+Tab 或 Ctrl+数字 切换标签页 \n20.Ctrl+W关闭当前标签页\n21.win+v，多条复制\n22.ctrl+.切换输入法为一直输入英文标点符号(不是数字键盘的那个.)\n23.按住“Shift”，右击。会比直接右击出的快捷菜单里多出个“复制为路径”(A)\n\n24.win+shift+s快速截屏\n\n25.ctrl+home,ctrl+end 到文章开头结尾\n\n\n\n---\n# 不常用\n\n1.Win + I 快速打开Win10设置栏\n2.Win + Tab(松开键盘界面不会消失) \n3.Win+G游戏录制声音之类\n4.Win+L：锁住电脑或切换用户\n5.Ctrl+向右键 将光标移动到下一个字词的起始处\nCtrl+向左键 将光标移动到上一个字词的起始处\nCtrl+向下键 将光标移动到下一个段落的起始处\nCtrl+向上键 将光标移动到上一个段落的起始处\n6.Ctrl+鼠标滚轮 更改桌面上的图标大小\n7.Alt+加下划线的字母 显示相应的菜单\n8.Alt+向左键 在 Win资源管理器中返回上次操作的文件夹\nCtrl+W 关闭当前窗口\n9.End 显示活动窗口的底端，Home 显示活动窗口的顶端\n10.F11 最大化或最小化活动窗口","slug":"Tools笔记/windows","published":1,"updated":"2020-11-12T11:57:29.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6x9003ljotpfzpa5pb2","content":"<h1 id=\"常用\"><a href=\"#常用\" class=\"headerlink\" title=\"常用\"></a>常用</h1><p>1.window+空格，切换输入法<br>2.Win + R 打开运行对话框,cmd命令<br>3.Win + Q 快速打开搜索<br>4.Alt+F4 快速关闭当前页面的快捷键<br>5.window+E我的电脑<br>6.快速切换窗口alt+tab<br>7.Win+D：显示桌面，第二次键击恢复桌面<br>8.Win +上下左右箭头 控制窗口大小<br>9.Delete(或 Ctrl+D) 删除所选项目并将其移动到“回收站”<br>10.Shift+Del 不先将所选项目移动到“回收站”而直接将其删除(不是backspace)<br>11.F2 重命名选定项目<br>12.Ctrl+Shift 加某个箭头键 选择一块文本<br>13.F5(或 Ctrl+R) 刷新活动窗口<br>14.Alt+向上键 在 Win资源管理器中查看上一级文件夹<br>15.Ctrl+Shift+N 新建文件夹<br>16.Ctrl+N 打开当前的一个新窗口<br>17.Shift + F10 鼠标右键菜单<br>18.Ctrl+T 打开新标签页<br>19.Ctrl+Tab 或 Ctrl+数字 切换标签页<br>20.Ctrl+W关闭当前标签页<br>21.win+v，多条复制<br>22.ctrl+.切换输入法为一直输入英文标点符号(不是数字键盘的那个.)<br>23.按住“Shift”，右击。会比直接右击出的快捷菜单里多出个“复制为路径”(A)</p>\n<p>24.win+shift+s快速截屏</p>\n<p>25.ctrl+home,ctrl+end 到文章开头结尾</p>\n<hr>\n<h1 id=\"不常用\"><a href=\"#不常用\" class=\"headerlink\" title=\"不常用\"></a>不常用</h1><p>1.Win + I 快速打开Win10设置栏<br>2.Win + Tab(松开键盘界面不会消失)<br>3.Win+G游戏录制声音之类<br>4.Win+L：锁住电脑或切换用户<br>5.Ctrl+向右键 将光标移动到下一个字词的起始处<br>Ctrl+向左键 将光标移动到上一个字词的起始处<br>Ctrl+向下键 将光标移动到下一个段落的起始处<br>Ctrl+向上键 将光标移动到上一个段落的起始处<br>6.Ctrl+鼠标滚轮 更改桌面上的图标大小<br>7.Alt+加下划线的字母 显示相应的菜单<br>8.Alt+向左键 在 Win资源管理器中返回上次操作的文件夹<br>Ctrl+W 关闭当前窗口<br>9.End 显示活动窗口的底端，Home 显示活动窗口的顶端<br>10.F11 最大化或最小化活动窗口</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"常用\"><a href=\"#常用\" class=\"headerlink\" title=\"常用\"></a>常用</h1><p>1.window+空格，切换输入法<br>2.Win + R 打开运行对话框,cmd命令<br>3.Win + Q 快速打开搜索<br>4.Alt+F4 快速关闭当前页面的快捷键<br>5.window+E我的电脑<br>6.快速切换窗口alt+tab<br>7.Win+D：显示桌面，第二次键击恢复桌面<br>8.Win +上下左右箭头 控制窗口大小<br>9.Delete(或 Ctrl+D) 删除所选项目并将其移动到“回收站”<br>10.Shift+Del 不先将所选项目移动到“回收站”而直接将其删除(不是backspace)<br>11.F2 重命名选定项目<br>12.Ctrl+Shift 加某个箭头键 选择一块文本<br>13.F5(或 Ctrl+R) 刷新活动窗口<br>14.Alt+向上键 在 Win资源管理器中查看上一级文件夹<br>15.Ctrl+Shift+N 新建文件夹<br>16.Ctrl+N 打开当前的一个新窗口<br>17.Shift + F10 鼠标右键菜单<br>18.Ctrl+T 打开新标签页<br>19.Ctrl+Tab 或 Ctrl+数字 切换标签页<br>20.Ctrl+W关闭当前标签页<br>21.win+v，多条复制<br>22.ctrl+.切换输入法为一直输入英文标点符号(不是数字键盘的那个.)<br>23.按住“Shift”，右击。会比直接右击出的快捷菜单里多出个“复制为路径”(A)</p>\n<p>24.win+shift+s快速截屏</p>\n<p>25.ctrl+home,ctrl+end 到文章开头结尾</p>\n<hr>\n<h1 id=\"不常用\"><a href=\"#不常用\" class=\"headerlink\" title=\"不常用\"></a>不常用</h1><p>1.Win + I 快速打开Win10设置栏<br>2.Win + Tab(松开键盘界面不会消失)<br>3.Win+G游戏录制声音之类<br>4.Win+L：锁住电脑或切换用户<br>5.Ctrl+向右键 将光标移动到下一个字词的起始处<br>Ctrl+向左键 将光标移动到上一个字词的起始处<br>Ctrl+向下键 将光标移动到下一个段落的起始处<br>Ctrl+向上键 将光标移动到上一个段落的起始处<br>6.Ctrl+鼠标滚轮 更改桌面上的图标大小<br>7.Alt+加下划线的字母 显示相应的菜单<br>8.Alt+向左键 在 Win资源管理器中返回上次操作的文件夹<br>Ctrl+W 关闭当前窗口<br>9.End 显示活动窗口的底端，Home 显示活动窗口的顶端<br>10.F11 最大化或最小化活动窗口</p>\n"},{"title":"LeetCode刷题笔记01","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记01","abbrlink":"5b7b3d5","date":"2020-03-16T16:00:00.000Z","_content":" \n> 题目出自LeetCode\n>\n> 1.两数之和\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n \n\n```\n示例:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n\n所以返回 [0, 1]\n```\n\n\n\n# 思路\n\n不断将元素加入Map集合中,key为值,value为数组的索引。这样，不断在map中查找（target-下一个数组元素），如果找到，就可以直接返回两个对应的索引。找不到，则将该元素放入map中，继续数组下一个元素。（因为规定了只有一个，所以不需要考虑覆盖map中相同key的问题）\n\n\n\n# 细节\n\n1. 返回的是数组索引\n\n2. 每种输入只会对应一个答案:找到即可返回\n\n3. 数组同一个元素只可使用一次,但是用map不需要考虑这个问题\n4. 找不到则返回{-1，-1}\n\n# 代码\n```java\npublic int[] twoSum(int[] nums, int target)\n{\n    Map<Integer, Integer> map = new HashMap<>();//value,index\n    for (int i = 0; i < nums.length; i++)\n    {\n        if(map.containsKey(target-nums[i])) \n            return new int[]{i, map.get(target - nums[i])};     \n        map.put(nums[i], i);\n    }\n    return new int[]{-1, -1};\n}\n```\n\n\n# 复杂度分析\n## 时间复杂度\nHashMap理想或者均摊情况下的时间复杂度O(1)。最坏情况对数组进行一次循环，总时间复杂度为O（N）\n## 空间复杂度\n最坏情况把所有数组都放入了Map中。所以空间复杂度为O（N）","source":"_posts/LeetCode笔记/LeetCode刷题笔记_01_两数之和.md","raw":"---\ntitle: LeetCode刷题笔记01\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记01\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - HashMap\nabbrlink: 5b7b3d5\ndate: 2020-03-17 00:00:00\n---\n \n> 题目出自LeetCode\n>\n> 1.两数之和\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n \n\n```\n示例:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n\n所以返回 [0, 1]\n```\n\n\n\n# 思路\n\n不断将元素加入Map集合中,key为值,value为数组的索引。这样，不断在map中查找（target-下一个数组元素），如果找到，就可以直接返回两个对应的索引。找不到，则将该元素放入map中，继续数组下一个元素。（因为规定了只有一个，所以不需要考虑覆盖map中相同key的问题）\n\n\n\n# 细节\n\n1. 返回的是数组索引\n\n2. 每种输入只会对应一个答案:找到即可返回\n\n3. 数组同一个元素只可使用一次,但是用map不需要考虑这个问题\n4. 找不到则返回{-1，-1}\n\n# 代码\n```java\npublic int[] twoSum(int[] nums, int target)\n{\n    Map<Integer, Integer> map = new HashMap<>();//value,index\n    for (int i = 0; i < nums.length; i++)\n    {\n        if(map.containsKey(target-nums[i])) \n            return new int[]{i, map.get(target - nums[i])};     \n        map.put(nums[i], i);\n    }\n    return new int[]{-1, -1};\n}\n```\n\n\n# 复杂度分析\n## 时间复杂度\nHashMap理想或者均摊情况下的时间复杂度O(1)。最坏情况对数组进行一次循环，总时间复杂度为O（N）\n## 空间复杂度\n最坏情况把所有数组都放入了Map中。所以空间复杂度为O（N）","slug":"LeetCode笔记/LeetCode刷题笔记_01_两数之和","published":1,"updated":"2020-11-12T11:57:29.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xa003ojotp9c952tv2","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p>1.两数之和</p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>\n<pre><code>示例:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n\n所以返回 [0, 1]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>不断将元素加入Map集合中,key为值,value为数组的索引。这样，不断在map中查找（target-下一个数组元素），如果找到，就可以直接返回两个对应的索引。找不到，则将该元素放入map中，继续数组下一个元素。（因为规定了只有一个，所以不需要考虑覆盖map中相同key的问题）</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li><p>返回的是数组索引</p>\n</li>\n<li><p>每种输入只会对应一个答案:找到即可返回</p>\n</li>\n<li><p>数组同一个元素只可使用一次,但是用map不需要考虑这个问题</p>\n</li>\n<li><p>找不到则返回{-1，-1}</p>\n</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">twoSum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//value,index</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">-</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span>i<span class=\"token punctuation\">,</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>target <span class=\"token operator\">-</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>     \n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>HashMap理想或者均摊情况下的时间复杂度O(1)。最坏情况对数组进行一次循环，总时间复杂度为O（N）</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>最坏情况把所有数组都放入了Map中。所以空间复杂度为O（N）</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p>1.两数之和</p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>\n<pre><code>示例:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n\n所以返回 [0, 1]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>不断将元素加入Map集合中,key为值,value为数组的索引。这样，不断在map中查找（target-下一个数组元素），如果找到，就可以直接返回两个对应的索引。找不到，则将该元素放入map中，继续数组下一个元素。（因为规定了只有一个，所以不需要考虑覆盖map中相同key的问题）</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li><p>返回的是数组索引</p>\n</li>\n<li><p>每种输入只会对应一个答案:找到即可返回</p>\n</li>\n<li><p>数组同一个元素只可使用一次,但是用map不需要考虑这个问题</p>\n</li>\n<li><p>找不到则返回{-1，-1}</p>\n</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int[] twoSum(int[] nums, int target)\n{\n    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();//value,index\n    for (int i = 0; i &lt; nums.length; i++)\n    {\n        if(map.containsKey(target-nums[i])) \n            return new int[]{i, map.get(target - nums[i])};     \n        map.put(nums[i], i);\n    }\n    return new int[]{-1, -1};\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>HashMap理想或者均摊情况下的时间复杂度O(1)。最坏情况对数组进行一次循环，总时间复杂度为O（N）</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>最坏情况把所有数组都放入了Map中。所以空间复杂度为O（N）</p>\n"},{"title":"LeetCode刷题笔记02","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记02","abbrlink":"9cbee26f","date":"2020-03-18T16:00:00.000Z","_content":"> 题目出自LeetCode\n>\n> 2.两数相加\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n```\n示例：\n\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n\n```\n\n\n\n# 思路\n\n可以在循环中不断计算两个指针对应的值之和,然后两个指针再指向链表下一个位置(同时考虑是否有进位的情况,以及链表是否为空的情况),计算直到两个指针为空并且没有进位 \n```java\n//伪代码\nwhile(链表1!=null || 链表2!=null || 有进位)\n{\n\t对链表1,链表2如果为null时的特殊处理\n\tvalue=链表1+链表2+进位\n\tvalue考虑是否进位的处理\n\t构造新的结果链表\n}\nreturn 结果链表\n```\n\n\n\n\n\n# 细节\n\n1.  因为都是逆序存储,所以从链表头部计算相当于从两个数的低位开始计算,就算不对齐也不会影响结果.例如2->4->3与4->5->6->2,就是342+2654\n2. 因为非空链表,而且非负整数,每个节点存储一位数字,所以不用讨论很多特殊情况,且要考虑进位\n3.  也可以采用递归,但是能用循环还是用循环\n4.  链表总是得考虑null值情况的处理\n5.  当l1==null,l2==null但是carryOver(进位)==1的情况,还要构造新的链表,所以while循环有三个条件\n6.  `carryOver = value / 10`的计算必须在`value = value % 10`之前,因为后者已经把value降为10以下\n\n# 代码\n```java\n//ListNode\npublic class ListNode\n{\n    public int val;\n    public ListNode next;\n\n    public ListNode(int x)\n    {\n        val = x;\n    }\n}\n```\n```java\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2)\n{\n    //第一个元素只是为了方便编程\n    //result代表结果链表的头部,current则构造该链表\n    ListNode result = new ListNode(-1);\n    ListNode current = result;\n\n    int carryOver = 0;//进位标志\n    //三者只要其中一个满足条件,就能计算下去\n    while (l1 != null || l2 != null || carryOver != 0)\n    {\n        //需要判断l1,l2是否为null\n        int value1 = 0, value2 = 0;\n        if (l1 != null)\n        {\n            value1 = l1.val;\n            l1 = l1.next;\n        }\n        if (l2 != null)\n        {\n            value2 = l2.val;\n            l2 = l2.next;\n        }\n\n        int value = value1 + value2 + carryOver;\n        //是否进位\n        //顺序不能颠倒,否则value已经<10,carryOver一定为0\n        carryOver = value / 10;\n        value = value % 10;\n\n        //构造结果链表\n        current.next = new ListNode(value);\n        current = current.next;\n    }\n    //链表第二个元素起才有实际的意义\n    return result.next;\n}\n```\n\n\n# 复杂度分析\n## 时间复杂度\n设m,n分别为链表1,链表2的长度,因为循环的次数是max(m,n),所以时间复杂度为O(max(m,n))\n## 空间复杂度\nO(max(m,n)),因为两个链表的值相加,最后链表长度最大为max(m,n)+1(最前面进位1的情况)","source":"_posts/LeetCode笔记/LeetCode刷题笔记_02_两数相加.md","raw":"---\ntitle: LeetCode刷题笔记02\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记02\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 链表\nabbrlink: 9cbee26f\ndate: 2020-03-19 00:00:00\n---\n> 题目出自LeetCode\n>\n> 2.两数相加\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n```\n示例：\n\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n\n```\n\n\n\n# 思路\n\n可以在循环中不断计算两个指针对应的值之和,然后两个指针再指向链表下一个位置(同时考虑是否有进位的情况,以及链表是否为空的情况),计算直到两个指针为空并且没有进位 \n```java\n//伪代码\nwhile(链表1!=null || 链表2!=null || 有进位)\n{\n\t对链表1,链表2如果为null时的特殊处理\n\tvalue=链表1+链表2+进位\n\tvalue考虑是否进位的处理\n\t构造新的结果链表\n}\nreturn 结果链表\n```\n\n\n\n\n\n# 细节\n\n1.  因为都是逆序存储,所以从链表头部计算相当于从两个数的低位开始计算,就算不对齐也不会影响结果.例如2->4->3与4->5->6->2,就是342+2654\n2. 因为非空链表,而且非负整数,每个节点存储一位数字,所以不用讨论很多特殊情况,且要考虑进位\n3.  也可以采用递归,但是能用循环还是用循环\n4.  链表总是得考虑null值情况的处理\n5.  当l1==null,l2==null但是carryOver(进位)==1的情况,还要构造新的链表,所以while循环有三个条件\n6.  `carryOver = value / 10`的计算必须在`value = value % 10`之前,因为后者已经把value降为10以下\n\n# 代码\n```java\n//ListNode\npublic class ListNode\n{\n    public int val;\n    public ListNode next;\n\n    public ListNode(int x)\n    {\n        val = x;\n    }\n}\n```\n```java\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2)\n{\n    //第一个元素只是为了方便编程\n    //result代表结果链表的头部,current则构造该链表\n    ListNode result = new ListNode(-1);\n    ListNode current = result;\n\n    int carryOver = 0;//进位标志\n    //三者只要其中一个满足条件,就能计算下去\n    while (l1 != null || l2 != null || carryOver != 0)\n    {\n        //需要判断l1,l2是否为null\n        int value1 = 0, value2 = 0;\n        if (l1 != null)\n        {\n            value1 = l1.val;\n            l1 = l1.next;\n        }\n        if (l2 != null)\n        {\n            value2 = l2.val;\n            l2 = l2.next;\n        }\n\n        int value = value1 + value2 + carryOver;\n        //是否进位\n        //顺序不能颠倒,否则value已经<10,carryOver一定为0\n        carryOver = value / 10;\n        value = value % 10;\n\n        //构造结果链表\n        current.next = new ListNode(value);\n        current = current.next;\n    }\n    //链表第二个元素起才有实际的意义\n    return result.next;\n}\n```\n\n\n# 复杂度分析\n## 时间复杂度\n设m,n分别为链表1,链表2的长度,因为循环的次数是max(m,n),所以时间复杂度为O(max(m,n))\n## 空间复杂度\nO(max(m,n)),因为两个链表的值相加,最后链表长度最大为max(m,n)+1(最前面进位1的情况)","slug":"LeetCode笔记/LeetCode刷题笔记_02_两数相加","published":1,"updated":"2020-11-12T11:57:29.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xb003sjotpg8k08de4","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p>2.两数相加</p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>\n<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>\n<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<pre><code>示例：\n\n输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n输出：7 -&gt; 0 -&gt; 8\n原因：342 + 465 = 807\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>可以在循环中不断计算两个指针对应的值之和,然后两个指针再指向链表下一个位置(同时考虑是否有进位的情况,以及链表是否为空的情况),计算直到两个指针为空并且没有进位 </p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//伪代码</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>链表<span class=\"token number\">1</span><span class=\"token operator\">!=</span>null <span class=\"token operator\">||</span> 链表<span class=\"token number\">2</span><span class=\"token operator\">!=</span>null <span class=\"token operator\">||</span> 有进位<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    对链表<span class=\"token number\">1</span><span class=\"token punctuation\">,</span>链表<span class=\"token number\">2</span>如果为null时的特殊处理\n    value<span class=\"token operator\">=</span>链表<span class=\"token number\">1</span><span class=\"token operator\">+</span>链表<span class=\"token number\">2</span><span class=\"token operator\">+</span>进位\n    value考虑是否进位的处理\n    构造新的结果链表\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">return</span> 结果链表</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>因为都是逆序存储,所以从链表头部计算相当于从两个数的低位开始计算,就算不对齐也不会影响结果.例如2-&gt;4-&gt;3与4-&gt;5-&gt;6-&gt;2,就是342+2654</li>\n<li>因为非空链表,而且非负整数,每个节点存储一位数字,所以不用讨论很多特殊情况,且要考虑进位</li>\n<li>也可以采用递归,但是能用循环还是用循环</li>\n<li>链表总是得考虑null值情况的处理</li>\n<li>当l1==null,l2==null但是carryOver(进位)==1的情况,还要构造新的链表,所以while循环有三个条件</li>\n<li><code>carryOver = value / 10</code>的计算必须在<code>value = value % 10</code>之前,因为后者已经把value降为10以下</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//ListNode</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ListNode</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> ListNode next<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        val <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> ListNode <span class=\"token function\">addTwoNumbers</span><span class=\"token punctuation\">(</span>ListNode l1<span class=\"token punctuation\">,</span> ListNode l2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//第一个元素只是为了方便编程</span>\n    <span class=\"token comment\" spellcheck=\"true\">//result代表结果链表的头部,current则构造该链表</span>\n    ListNode result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ListNode current <span class=\"token operator\">=</span> result<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> carryOver <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//进位标志</span>\n    <span class=\"token comment\" spellcheck=\"true\">//三者只要其中一个满足条件,就能计算下去</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l1 <span class=\"token operator\">!=</span> null <span class=\"token operator\">||</span> l2 <span class=\"token operator\">!=</span> null <span class=\"token operator\">||</span> carryOver <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//需要判断l1,l2是否为null</span>\n        <span class=\"token keyword\">int</span> value1 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> value2 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l1 <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            value1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n            l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l2 <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            value2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n            l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> value1 <span class=\"token operator\">+</span> value2 <span class=\"token operator\">+</span> carryOver<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//是否进位</span>\n        <span class=\"token comment\" spellcheck=\"true\">//顺序不能颠倒,否则value已经&lt;10,carryOver一定为0</span>\n        carryOver <span class=\"token operator\">=</span> value <span class=\"token operator\">/</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n        value <span class=\"token operator\">=</span> value <span class=\"token operator\">%</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//构造结果链表</span>\n        current<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//链表第二个元素起才有实际的意义</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>设m,n分别为链表1,链表2的长度,因为循环的次数是max(m,n),所以时间复杂度为O(max(m,n))</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>O(max(m,n)),因为两个链表的值相加,最后链表长度最大为max(m,n)+1(最前面进位1的情况)</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p>2.两数相加</p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>\n<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>\n<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<pre><code>示例：\n\n输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n输出：7 -&gt; 0 -&gt; 8\n原因：342 + 465 = 807\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>可以在循环中不断计算两个指针对应的值之和,然后两个指针再指向链表下一个位置(同时考虑是否有进位的情况,以及链表是否为空的情况),计算直到两个指针为空并且没有进位 </p>\n<pre><code class=\"java\">//伪代码\nwhile(链表1!=null || 链表2!=null || 有进位)\n{\n    对链表1,链表2如果为null时的特殊处理\n    value=链表1+链表2+进位\n    value考虑是否进位的处理\n    构造新的结果链表\n}\nreturn 结果链表</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>因为都是逆序存储,所以从链表头部计算相当于从两个数的低位开始计算,就算不对齐也不会影响结果.例如2-&gt;4-&gt;3与4-&gt;5-&gt;6-&gt;2,就是342+2654</li>\n<li>因为非空链表,而且非负整数,每个节点存储一位数字,所以不用讨论很多特殊情况,且要考虑进位</li>\n<li>也可以采用递归,但是能用循环还是用循环</li>\n<li>链表总是得考虑null值情况的处理</li>\n<li>当l1==null,l2==null但是carryOver(进位)==1的情况,还要构造新的链表,所以while循环有三个条件</li>\n<li><code>carryOver = value / 10</code>的计算必须在<code>value = value % 10</code>之前,因为后者已经把value降为10以下</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">//ListNode\npublic class ListNode\n{\n    public int val;\n    public ListNode next;\n\n    public ListNode(int x)\n    {\n        val = x;\n    }\n}</code></pre>\n<pre><code class=\"java\">public ListNode addTwoNumbers(ListNode l1, ListNode l2)\n{\n    //第一个元素只是为了方便编程\n    //result代表结果链表的头部,current则构造该链表\n    ListNode result = new ListNode(-1);\n    ListNode current = result;\n\n    int carryOver = 0;//进位标志\n    //三者只要其中一个满足条件,就能计算下去\n    while (l1 != null || l2 != null || carryOver != 0)\n    {\n        //需要判断l1,l2是否为null\n        int value1 = 0, value2 = 0;\n        if (l1 != null)\n        {\n            value1 = l1.val;\n            l1 = l1.next;\n        }\n        if (l2 != null)\n        {\n            value2 = l2.val;\n            l2 = l2.next;\n        }\n\n        int value = value1 + value2 + carryOver;\n        //是否进位\n        //顺序不能颠倒,否则value已经&lt;10,carryOver一定为0\n        carryOver = value / 10;\n        value = value % 10;\n\n        //构造结果链表\n        current.next = new ListNode(value);\n        current = current.next;\n    }\n    //链表第二个元素起才有实际的意义\n    return result.next;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>设m,n分别为链表1,链表2的长度,因为循环的次数是max(m,n),所以时间复杂度为O(max(m,n))</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>O(max(m,n)),因为两个链表的值相加,最后链表长度最大为max(m,n)+1(最前面进位1的情况)</p>\n"},{"title":"LeetCode刷题笔记03","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记03","abbrlink":"ebb9d2f9","date":"2020-03-19T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n```\n\n\n示例 1:\n\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n\n```\n\n\n```\n示例 2:\n\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n\n```\n\n```\n示例 3:\n\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n```\n\n# 思路\n\n\n\n```java\n\t//伪代码\n\tmaxLength=0,lo=0,hi=0\n\tMap<字符,index> map\n    for(i,ch in string)\n    {\n        hi=i\n        if(map.find(ch)!=-1) lo=max(map.find(ch)+1,lo) //说明有重复的\n        map.put(ch, hi);\n        maxLength=max(maxLength,hi-lo+1);   \n            \n    }\n    \n```\n\n\n\n\n\n# 细节\n\n1.  因为可能在中间取得最大值,所以每一次都要判断一下`maxLength=max(maxLength,hi-lo+1);`\n\n2.  通过HashMap查看是否有重复的元素,有则更新到重复元素之后,相当于去掉那个重复元素\n\n3.  一定要把最新遍历到的put到map中,这样不管里面有没有,都会更新到最前面的位置\n\n4.  `lo=max(map.find(ch)+1,lo) `是因为例如abba等,在遍历完第二个b时,lo=2,而遍历最后的a,`map.find(ch)+1`值为1,就不符合实际情况。这样做的本质是取历史不重复子串和此次不重复子串的交集。\n\n\n​\t\n\n# 代码\n```java\npublic int lengthOfLongestSubstring(String s)\n{\n    int maxLength = 0, lo = 0, hi = 0;\n    Map<Character, Integer> map = new HashMap<>();\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        hi = i;\n        if(map.containsKey(ch)) lo = Math.max(lo,map.get(ch)+1);//look\n        map.put(ch, hi);//look\n        maxLength = Math.max(maxLength, hi - lo + 1);\n    }\n    return maxLength;\n}\n```\n# 优化\n因为是字符，所以改用大小为128的数组存储,思路是一样的，但是用数组快一点\n```java\npublic int lengthOfLongestSubstring(String s)\n{\n    int result = 0,lo=0;\n    int[] map = new int[128];\n    Arrays.fill(map, -1);//初始化为-1\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        lo = Math.max(lo, map[ch]+1);\n        map[ch] = i;\n        result = Math.max(result, map[ch] - lo + 1);\n    }\n    return result;\n}\n```\n\n# 复杂度分析\n## 时间复杂度\n对字符串进行一次遍历，循环内操作都可以在常数时间内解决，例如map的put，get方法。所以时间复杂度O(N)\n## 空间复杂度\n只需要字符集大小的空间存储即可（重复的字符也是如此），所以空间复杂度为O(|E|) 其中的E代表字符集","source":"_posts/LeetCode笔记/LeetCode刷题笔记_03_ 无重复字符的最长子串.md","raw":"---\ntitle: LeetCode刷题笔记03\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记03\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 字符串\nabbrlink: ebb9d2f9\ndate: 2020-03-20 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n```\n\n\n示例 1:\n\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n\n```\n\n\n```\n示例 2:\n\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n\n```\n\n```\n示例 3:\n\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n```\n\n# 思路\n\n\n\n```java\n\t//伪代码\n\tmaxLength=0,lo=0,hi=0\n\tMap<字符,index> map\n    for(i,ch in string)\n    {\n        hi=i\n        if(map.find(ch)!=-1) lo=max(map.find(ch)+1,lo) //说明有重复的\n        map.put(ch, hi);\n        maxLength=max(maxLength,hi-lo+1);   \n            \n    }\n    \n```\n\n\n\n\n\n# 细节\n\n1.  因为可能在中间取得最大值,所以每一次都要判断一下`maxLength=max(maxLength,hi-lo+1);`\n\n2.  通过HashMap查看是否有重复的元素,有则更新到重复元素之后,相当于去掉那个重复元素\n\n3.  一定要把最新遍历到的put到map中,这样不管里面有没有,都会更新到最前面的位置\n\n4.  `lo=max(map.find(ch)+1,lo) `是因为例如abba等,在遍历完第二个b时,lo=2,而遍历最后的a,`map.find(ch)+1`值为1,就不符合实际情况。这样做的本质是取历史不重复子串和此次不重复子串的交集。\n\n\n​\t\n\n# 代码\n```java\npublic int lengthOfLongestSubstring(String s)\n{\n    int maxLength = 0, lo = 0, hi = 0;\n    Map<Character, Integer> map = new HashMap<>();\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        hi = i;\n        if(map.containsKey(ch)) lo = Math.max(lo,map.get(ch)+1);//look\n        map.put(ch, hi);//look\n        maxLength = Math.max(maxLength, hi - lo + 1);\n    }\n    return maxLength;\n}\n```\n# 优化\n因为是字符，所以改用大小为128的数组存储,思路是一样的，但是用数组快一点\n```java\npublic int lengthOfLongestSubstring(String s)\n{\n    int result = 0,lo=0;\n    int[] map = new int[128];\n    Arrays.fill(map, -1);//初始化为-1\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        lo = Math.max(lo, map[ch]+1);\n        map[ch] = i;\n        result = Math.max(result, map[ch] - lo + 1);\n    }\n    return result;\n}\n```\n\n# 复杂度分析\n## 时间复杂度\n对字符串进行一次遍历，循环内操作都可以在常数时间内解决，例如map的put，get方法。所以时间复杂度O(N)\n## 空间复杂度\n只需要字符集大小的空间存储即可（重复的字符也是如此），所以空间复杂度为O(|E|) 其中的E代表字符集","slug":"LeetCode笔记/LeetCode刷题笔记_03_ 无重复字符的最长子串","published":1,"updated":"2020-11-12T11:57:29.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xc003wjotpbaele78m","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"noopener\">3. 无重复字符的最长子串</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n<pre><code>\n\n示例 1:\n\n输入: &quot;abcabcbb&quot;\n输出: 3 \n解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。\n</code></pre>\n<pre><code>示例 2:\n\n输入: &quot;bbbbb&quot;\n输出: 1\n解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。\n</code></pre>\n<pre><code>示例 3:\n\n输入: &quot;pwwkew&quot;\n输出: 3\n解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token comment\" spellcheck=\"true\">//伪代码</span>\n    maxLength<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>lo<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>hi<span class=\"token operator\">=</span><span class=\"token number\">0</span>\n    Map<span class=\"token operator\">&lt;</span>字符<span class=\"token punctuation\">,</span>index<span class=\"token operator\">></span> map\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span>ch in string<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        hi<span class=\"token operator\">=</span>i\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token operator\">!=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> lo<span class=\"token operator\">=</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>lo<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//说明有重复的</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">,</span> hi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        maxLength<span class=\"token operator\">=</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>maxLength<span class=\"token punctuation\">,</span>hi<span class=\"token operator\">-</span>lo<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li><p>因为可能在中间取得最大值,所以每一次都要判断一下<code>maxLength=max(maxLength,hi-lo+1);</code></p>\n</li>\n<li><p>通过HashMap查看是否有重复的元素,有则更新到重复元素之后,相当于去掉那个重复元素</p>\n</li>\n<li><p>一定要把最新遍历到的put到map中,这样不管里面有没有,都会更新到最前面的位置</p>\n</li>\n<li><p><code>lo=max(map.find(ch)+1,lo) </code>是因为例如abba等,在遍历完第二个b时,lo=2,而遍历最后的a,<code>map.find(ch)+1</code>值为1,就不符合实际情况。这样做的本质是取历史不重复子串和此次不重复子串的交集。</p>\n</li>\n</ol>\n<p>​    </p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">lengthOfLongestSubstring</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> maxLength <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> lo <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> hi <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    Map<span class=\"token operator\">&lt;</span>Character<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        hi <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> lo <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>lo<span class=\"token punctuation\">,</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">,</span> hi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look</span>\n        maxLength <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>maxLength<span class=\"token punctuation\">,</span> hi <span class=\"token operator\">-</span> lo <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> maxLength<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><p>因为是字符，所以改用大小为128的数组存储,思路是一样的，但是用数组快一点</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">lengthOfLongestSubstring</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>lo<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">128</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//初始化为-1</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        lo <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>lo<span class=\"token punctuation\">,</span> map<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> map<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> lo <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>对字符串进行一次遍历，循环内操作都可以在常数时间内解决，例如map的put，get方法。所以时间复杂度O(N)</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>只需要字符集大小的空间存储即可（重复的字符也是如此），所以空间复杂度为O(|E|) 其中的E代表字符集</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"noopener\">3. 无重复字符的最长子串</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n<pre><code>\n\n示例 1:\n\n输入: &quot;abcabcbb&quot;\n输出: 3 \n解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。\n</code></pre>\n<pre><code>示例 2:\n\n输入: &quot;bbbbb&quot;\n输出: 1\n解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。\n</code></pre>\n<pre><code>示例 3:\n\n输入: &quot;pwwkew&quot;\n输出: 3\n解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code class=\"java\">    //伪代码\n    maxLength=0,lo=0,hi=0\n    Map&lt;字符,index&gt; map\n    for(i,ch in string)\n    {\n        hi=i\n        if(map.find(ch)!=-1) lo=max(map.find(ch)+1,lo) //说明有重复的\n        map.put(ch, hi);\n        maxLength=max(maxLength,hi-lo+1);   \n\n    }\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li><p>因为可能在中间取得最大值,所以每一次都要判断一下<code>maxLength=max(maxLength,hi-lo+1);</code></p>\n</li>\n<li><p>通过HashMap查看是否有重复的元素,有则更新到重复元素之后,相当于去掉那个重复元素</p>\n</li>\n<li><p>一定要把最新遍历到的put到map中,这样不管里面有没有,都会更新到最前面的位置</p>\n</li>\n<li><p><code>lo=max(map.find(ch)+1,lo) </code>是因为例如abba等,在遍历完第二个b时,lo=2,而遍历最后的a,<code>map.find(ch)+1</code>值为1,就不符合实际情况。这样做的本质是取历史不重复子串和此次不重复子串的交集。</p>\n</li>\n</ol>\n<p>​    </p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int lengthOfLongestSubstring(String s)\n{\n    int maxLength = 0, lo = 0, hi = 0;\n    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();\n    for (int i = 0; i &lt; s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        hi = i;\n        if(map.containsKey(ch)) lo = Math.max(lo,map.get(ch)+1);//look\n        map.put(ch, hi);//look\n        maxLength = Math.max(maxLength, hi - lo + 1);\n    }\n    return maxLength;\n}</code></pre>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><p>因为是字符，所以改用大小为128的数组存储,思路是一样的，但是用数组快一点</p>\n<pre><code class=\"java\">public int lengthOfLongestSubstring(String s)\n{\n    int result = 0,lo=0;\n    int[] map = new int[128];\n    Arrays.fill(map, -1);//初始化为-1\n    for (int i = 0; i &lt; s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        lo = Math.max(lo, map[ch]+1);\n        map[ch] = i;\n        result = Math.max(result, map[ch] - lo + 1);\n    }\n    return result;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>对字符串进行一次遍历，循环内操作都可以在常数时间内解决，例如map的put，get方法。所以时间复杂度O(N)</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>只需要字符集大小的空间存储即可（重复的字符也是如此），所以空间复杂度为O(|E|) 其中的E代表字符集</p>\n"},{"title":"LeetCode刷题笔记101","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"6db92529","date":"2020-05-20T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n\n```\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n```\n\n# 思路\n\n递归,每次分为两次递归,判断最外层的两个节点,最内侧两节点是否相等\n\n# 细节\n\n注意节点为空的情况\n\n\n# 代码\n```java\npublic boolean isSymmetric(TreeNode root)\n{\n    return recursive(root, root);\n}\n\nprivate boolean recursive(TreeNode left,TreeNode right)\n{\n    if(left==null && right==null)\n    {\n        return true;\n    }\n    else if(left==null || right==null)\n    {\n        return false;\n    }\n    else\n    {\n        return left.val == right.val && recursive(left.left, right.right) && recursive(left.right, right.left);\n    }\n}\n```\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_101. 对称二叉树.md","raw":"---\ntitle: LeetCode刷题笔记101\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 二叉树\n  - 递归\nabbrlink: 6db92529\ndate: 2020-05-21 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n\n```\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n```\n\n# 思路\n\n递归,每次分为两次递归,判断最外层的两个节点,最内侧两节点是否相等\n\n# 细节\n\n注意节点为空的情况\n\n\n# 代码\n```java\npublic boolean isSymmetric(TreeNode root)\n{\n    return recursive(root, root);\n}\n\nprivate boolean recursive(TreeNode left,TreeNode right)\n{\n    if(left==null && right==null)\n    {\n        return true;\n    }\n    else if(left==null || right==null)\n    {\n        return false;\n    }\n    else\n    {\n        return left.val == right.val && recursive(left.left, right.right) && recursive(left.right, right.left);\n    }\n}\n```\n","slug":"LeetCode笔记/LeetCode刷题笔记_101. 对称二叉树","published":1,"updated":"2020-11-12T11:57:29.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xd003zjotp8easeo1r","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">101. 对称二叉树</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二叉树，检查它是否是镜像对称的。</p>\n<pre><code>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>递归,每次分为两次递归,判断最外层的两个节点,最内侧两节点是否相等</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>注意节点为空的情况</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isSymmetric</span><span class=\"token punctuation\">(</span>TreeNode root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>TreeNode left<span class=\"token punctuation\">,</span>TreeNode right<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">==</span>null <span class=\"token operator\">&amp;&amp;</span> right<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">==</span>null <span class=\"token operator\">||</span> right<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> left<span class=\"token punctuation\">.</span>val <span class=\"token operator\">==</span> right<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">101. 对称二叉树</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二叉树，检查它是否是镜像对称的。</p>\n<pre><code>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>递归,每次分为两次递归,判断最外层的两个节点,最内侧两节点是否相等</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>注意节点为空的情况</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public boolean isSymmetric(TreeNode root)\n{\n    return recursive(root, root);\n}\n\nprivate boolean recursive(TreeNode left,TreeNode right)\n{\n    if(left==null &amp;&amp; right==null)\n    {\n        return true;\n    }\n    else if(left==null || right==null)\n    {\n        return false;\n    }\n    else\n    {\n        return left.val == right.val &amp;&amp; recursive(left.left, right.right) &amp;&amp; recursive(left.right, right.left);\n    }\n}</code></pre>\n"},{"title":"LeetCode刷题笔记05","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记05","abbrlink":"2da77cc","date":"2020-03-20T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>   [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n\n```\n\n示例 1:\n\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n\n```\n\n\n```\n示例 2:\n\n输入: \"cbbd\"\n输出: \"bb\"\n```\n\n# 思路\n遍历一次数组，对每次遍历，从那个字符为中心开始向左右扩展直到不能扩展为止。扩展分为一个字符扩展和两个字符扩展两种。\n\n\n\n```java\nfor(char ch,int i in string)\n{\n\tint lo=i,hi=i;\n\t//单向扩展\n\twhile()\n\t{\n\t\t//如果符合条件，则一直扩展\n\t\t--lo,++hi;\n\t}\n\t\n\tresult=max(result,substring(lo,hi+1));\n\t//双向扩展\n\tlo=i,hi=i+1;\n\twhile()\n\t{\n\t\t//如果符合条件，则一直扩展\n\t\t--lo,++hi;\n\t}\n}\n\n```\n\n\n\n\t# 细节\n\n1. 如果不用额外空间，就用两个指针指向要返回字符串的位置，他们的初始值应该都是0。那么这样就先要判断s是否为空字符串。\n2. 注意s.substring()截取的是左闭右开区间，自己设计的变量标识是[left,right]\n\n# 代码\n```java\npublic String longestPalindrome(String s)\n{\n    if(s.length()==0) return s;\n    int left = 0, right = 0;//结果\n\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        int lo = i, hi = i;\n        //单向扩展\n        while(lo-1>=0 && hi+1<s.length() && s.charAt(lo-1)==s.charAt(hi+1))\n        {\n            --lo;\n            ++hi;\n        }\n        //其实是right-left+1 < hi-lo+1\n        if((right-left)<(hi-lo))\n        {\n            left = lo;\n            right = hi;\n        }\n\n        //双向扩展\n        lo = i;\n        hi = i + 1;\n        //如果一开始就不能双向扩展,就不用管了\n        if(hi<s.length() && s.charAt(lo)==s.charAt(hi))\n        {\n            while(lo-1>=0 && hi+1<s.length() && s.charAt(lo-1)==s.charAt(hi+1))\n            {\n                --lo;\n                ++hi;\n            }\n            if((right-left)<(hi-lo))\n            {\n                left = lo;\n                right = hi;\n            }\n        }\n    }\n    return s.substring(left,right+1);\n}\n```\n\n\n# 复杂度分析\n## 时间复杂度\n\n循环遍历的时间复杂度为O(N),中心扩散的时间复杂度也为O(N),所以总共为$ O(N^2) $\n\n\n## 空间复杂度\n\n只用了几个变量，和string的长度无关，所以是O(1)","source":"_posts/LeetCode笔记/LeetCode刷题笔记_05_最长回文子串.md","raw":"---\ntitle: LeetCode刷题笔记05\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记05\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 字符串\nabbrlink: 2da77cc\ndate: 2020-03-21 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>   [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n\n```\n\n示例 1:\n\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n\n```\n\n\n```\n示例 2:\n\n输入: \"cbbd\"\n输出: \"bb\"\n```\n\n# 思路\n遍历一次数组，对每次遍历，从那个字符为中心开始向左右扩展直到不能扩展为止。扩展分为一个字符扩展和两个字符扩展两种。\n\n\n\n```java\nfor(char ch,int i in string)\n{\n\tint lo=i,hi=i;\n\t//单向扩展\n\twhile()\n\t{\n\t\t//如果符合条件，则一直扩展\n\t\t--lo,++hi;\n\t}\n\t\n\tresult=max(result,substring(lo,hi+1));\n\t//双向扩展\n\tlo=i,hi=i+1;\n\twhile()\n\t{\n\t\t//如果符合条件，则一直扩展\n\t\t--lo,++hi;\n\t}\n}\n\n```\n\n\n\n\t# 细节\n\n1. 如果不用额外空间，就用两个指针指向要返回字符串的位置，他们的初始值应该都是0。那么这样就先要判断s是否为空字符串。\n2. 注意s.substring()截取的是左闭右开区间，自己设计的变量标识是[left,right]\n\n# 代码\n```java\npublic String longestPalindrome(String s)\n{\n    if(s.length()==0) return s;\n    int left = 0, right = 0;//结果\n\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        int lo = i, hi = i;\n        //单向扩展\n        while(lo-1>=0 && hi+1<s.length() && s.charAt(lo-1)==s.charAt(hi+1))\n        {\n            --lo;\n            ++hi;\n        }\n        //其实是right-left+1 < hi-lo+1\n        if((right-left)<(hi-lo))\n        {\n            left = lo;\n            right = hi;\n        }\n\n        //双向扩展\n        lo = i;\n        hi = i + 1;\n        //如果一开始就不能双向扩展,就不用管了\n        if(hi<s.length() && s.charAt(lo)==s.charAt(hi))\n        {\n            while(lo-1>=0 && hi+1<s.length() && s.charAt(lo-1)==s.charAt(hi+1))\n            {\n                --lo;\n                ++hi;\n            }\n            if((right-left)<(hi-lo))\n            {\n                left = lo;\n                right = hi;\n            }\n        }\n    }\n    return s.substring(left,right+1);\n}\n```\n\n\n# 复杂度分析\n## 时间复杂度\n\n循环遍历的时间复杂度为O(N),中心扩散的时间复杂度也为O(N),所以总共为$ O(N^2) $\n\n\n## 空间复杂度\n\n只用了几个变量，和string的长度无关，所以是O(1)","slug":"LeetCode笔记/LeetCode刷题笔记_05_最长回文子串","published":1,"updated":"2020-11-12T11:57:29.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xe0041jotp41uqgiz1","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p>  <a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">5. 最长回文子串</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>\n<pre><code>\n示例 1:\n\n输入: &quot;babad&quot;\n输出: &quot;bab&quot;\n注意: &quot;aba&quot; 也是一个有效答案。\n</code></pre>\n<pre><code>示例 2:\n\n输入: &quot;cbbd&quot;\n输出: &quot;bb&quot;</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>遍历一次数组，对每次遍历，从那个字符为中心开始向左右扩展直到不能扩展为止。扩展分为一个字符扩展和两个字符扩展两种。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> ch<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> i in string<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> lo<span class=\"token operator\">=</span>i<span class=\"token punctuation\">,</span>hi<span class=\"token operator\">=</span>i<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//单向扩展</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果符合条件，则一直扩展</span>\n        <span class=\"token operator\">--</span>lo<span class=\"token punctuation\">,</span><span class=\"token operator\">++</span>hi<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    result<span class=\"token operator\">=</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>lo<span class=\"token punctuation\">,</span>hi<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//双向扩展</span>\n    lo<span class=\"token operator\">=</span>i<span class=\"token punctuation\">,</span>hi<span class=\"token operator\">=</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果符合条件，则一直扩展</span>\n        <span class=\"token operator\">--</span>lo<span class=\"token punctuation\">,</span><span class=\"token operator\">++</span>hi<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<pre><code># 细节</code></pre>\n<ol>\n<li>如果不用额外空间，就用两个指针指向要返回字符串的位置，他们的初始值应该都是0。那么这样就先要判断s是否为空字符串。</li>\n<li>注意s.substring()截取的是左闭右开区间，自己设计的变量标识是[left,right]</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> String <span class=\"token function\">longestPalindrome</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> right <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//结果</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> lo <span class=\"token operator\">=</span> i<span class=\"token punctuation\">,</span> hi <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//单向扩展</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">>=</span><span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> hi<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>hi<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">--</span>lo<span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">++</span>hi<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//其实是right-left+1 &lt; hi-lo+1</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>right<span class=\"token operator\">-</span>left<span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span>hi<span class=\"token operator\">-</span>lo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            left <span class=\"token operator\">=</span> lo<span class=\"token punctuation\">;</span>\n            right <span class=\"token operator\">=</span> hi<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//双向扩展</span>\n        lo <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        hi <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果一开始就不能双向扩展,就不用管了</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>hi<span class=\"token operator\">&lt;</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>lo<span class=\"token punctuation\">)</span><span class=\"token operator\">==</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>hi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">>=</span><span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> hi<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>hi<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token operator\">--</span>lo<span class=\"token punctuation\">;</span>\n                <span class=\"token operator\">++</span>hi<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>right<span class=\"token operator\">-</span>left<span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span>hi<span class=\"token operator\">-</span>lo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                left <span class=\"token operator\">=</span> lo<span class=\"token punctuation\">;</span>\n                right <span class=\"token operator\">=</span> hi<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span>right<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>循环遍历的时间复杂度为O(N),中心扩散的时间复杂度也为O(N),所以总共为$ O(N^2) $</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>只用了几个变量，和string的长度无关，所以是O(1)</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p>  <a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"noopener\">5. 最长回文子串</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>\n<pre><code>\n示例 1:\n\n输入: &quot;babad&quot;\n输出: &quot;bab&quot;\n注意: &quot;aba&quot; 也是一个有效答案。\n</code></pre>\n<pre><code>示例 2:\n\n输入: &quot;cbbd&quot;\n输出: &quot;bb&quot;</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>遍历一次数组，对每次遍历，从那个字符为中心开始向左右扩展直到不能扩展为止。扩展分为一个字符扩展和两个字符扩展两种。</p>\n<pre><code class=\"java\">for(char ch,int i in string)\n{\n    int lo=i,hi=i;\n    //单向扩展\n    while()\n    {\n        //如果符合条件，则一直扩展\n        --lo,++hi;\n    }\n\n    result=max(result,substring(lo,hi+1));\n    //双向扩展\n    lo=i,hi=i+1;\n    while()\n    {\n        //如果符合条件，则一直扩展\n        --lo,++hi;\n    }\n}\n</code></pre>\n<pre><code># 细节</code></pre>\n<ol>\n<li>如果不用额外空间，就用两个指针指向要返回字符串的位置，他们的初始值应该都是0。那么这样就先要判断s是否为空字符串。</li>\n<li>注意s.substring()截取的是左闭右开区间，自己设计的变量标识是[left,right]</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public String longestPalindrome(String s)\n{\n    if(s.length()==0) return s;\n    int left = 0, right = 0;//结果\n\n    for (int i = 0; i &lt; s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        int lo = i, hi = i;\n        //单向扩展\n        while(lo-1&gt;=0 &amp;&amp; hi+1&lt;s.length() &amp;&amp; s.charAt(lo-1)==s.charAt(hi+1))\n        {\n            --lo;\n            ++hi;\n        }\n        //其实是right-left+1 &lt; hi-lo+1\n        if((right-left)&lt;(hi-lo))\n        {\n            left = lo;\n            right = hi;\n        }\n\n        //双向扩展\n        lo = i;\n        hi = i + 1;\n        //如果一开始就不能双向扩展,就不用管了\n        if(hi&lt;s.length() &amp;&amp; s.charAt(lo)==s.charAt(hi))\n        {\n            while(lo-1&gt;=0 &amp;&amp; hi+1&lt;s.length() &amp;&amp; s.charAt(lo-1)==s.charAt(hi+1))\n            {\n                --lo;\n                ++hi;\n            }\n            if((right-left)&lt;(hi-lo))\n            {\n                left = lo;\n                right = hi;\n            }\n        }\n    }\n    return s.substring(left,right+1);\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>循环遍历的时间复杂度为O(N),中心扩散的时间复杂度也为O(N),所以总共为$ O(N^2) $</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>只用了几个变量，和string的长度无关，所以是O(1)</p>\n"},{"title":"LeetCode刷题笔记102","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"f4b07493","date":"2020-05-21T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n ```\n\n示例：\n二叉树：[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n ```\n# 思路\n\n递归的思路：从根节点，高度为0处开始递归。首次进入某层时,就开辟新的空间,随后进入相同的层则直接根据他所在的高度加入即可\n\n\n\n\n# 代码\n\n```java\nprivate List<List<Integer>> result = new LinkedList<>();\n\npublic List<List<Integer>> levelOrder(TreeNode root)\n{\n    recursive(root, 0);\n    return result;\n}\n\nprivate void recursive(TreeNode node, int height)\n{\n    if(node==null)\n    {\n        return;\n    }\n    //最多就是等于,不会大于,因为每层不满足都会构建\n    if(height==result.size())\n    {\n        result.add(new LinkedList<>());\n    }\n    result.get(height).add(node.val);\n\n    recursive(node.left,height+1);\n    recursive(node.right,height+1);\n}\n```","source":"_posts/LeetCode笔记/LeetCode刷题笔记_102. 二叉树的层序遍历.md","raw":"---\ntitle: LeetCode刷题笔记102\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 二叉树\n  - 层次遍历\nabbrlink: f4b07493\ndate: 2020-05-22 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n ```\n\n示例：\n二叉树：[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n ```\n# 思路\n\n递归的思路：从根节点，高度为0处开始递归。首次进入某层时,就开辟新的空间,随后进入相同的层则直接根据他所在的高度加入即可\n\n\n\n\n# 代码\n\n```java\nprivate List<List<Integer>> result = new LinkedList<>();\n\npublic List<List<Integer>> levelOrder(TreeNode root)\n{\n    recursive(root, 0);\n    return result;\n}\n\nprivate void recursive(TreeNode node, int height)\n{\n    if(node==null)\n    {\n        return;\n    }\n    //最多就是等于,不会大于,因为每层不满足都会构建\n    if(height==result.size())\n    {\n        result.add(new LinkedList<>());\n    }\n    result.get(height).add(node.val);\n\n    recursive(node.left,height+1);\n    recursive(node.right,height+1);\n}\n```","slug":"LeetCode笔记/LeetCode刷题笔记_102. 二叉树的层序遍历","published":1,"updated":"2020-11-12T11:57:29.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xg0045jotpgy23fqfp","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p>[102. 二叉树的层序遍历](<a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-level-order-traversal</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n<pre><code>\n示例：\n二叉树：[3,9,20,null,null,15,7],\n\n   3\n  / \\\n 9  20\n   /  \\\n  15   7\n返回其层次遍历结果：\n\n[\n [3],\n [9,20],\n [15,7]\n]\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>递归的思路：从根节点，高度为0处开始递归。首次进入某层时,就开辟新的空间,随后进入相同的层则直接根据他所在的高度加入即可</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> <span class=\"token function\">levelOrder</span><span class=\"token punctuation\">(</span>TreeNode root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>TreeNode node<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> height<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//最多就是等于,不会大于,因为每层不满足都会构建</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>height<span class=\"token operator\">==</span>result<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span>height<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span>height<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p>[102. 二叉树的层序遍历](<a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/binary-tree-level-order-traversal</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n<pre><code>\n示例：\n二叉树：[3,9,20,null,null,15,7],\n\n   3\n  / \\\n 9  20\n   /  \\\n  15   7\n返回其层次遍历结果：\n\n[\n [3],\n [9,20],\n [15,7]\n]\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>递归的思路：从根节点，高度为0处开始递归。首次进入某层时,就开辟新的空间,随后进入相同的层则直接根据他所在的高度加入即可</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">private List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();\n\npublic List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)\n{\n    recursive(root, 0);\n    return result;\n}\n\nprivate void recursive(TreeNode node, int height)\n{\n    if(node==null)\n    {\n        return;\n    }\n    //最多就是等于,不会大于,因为每层不满足都会构建\n    if(height==result.size())\n    {\n        result.add(new LinkedList&lt;&gt;());\n    }\n    result.get(height).add(node.val);\n\n    recursive(node.left,height+1);\n    recursive(node.right,height+1);\n}</code></pre>\n"},{"title":"LeetCode刷题笔记04","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记04","abbrlink":"75dd475a","date":"2020-03-21T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>   [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。\n\n请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n\n你可以假设 nums1 和 nums2 不会同时为空。\n\n\n```\n\n示例 1:\n\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n\n```\n\n\n```\n示例 2:\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n\n```\n\n# 思路\n\n选择两个数组中较小的一个,先将之对半分,通过计算,对另一个数组在某位置也切一刀，使得两个数组切下那刀后左右两边数量相同。然后判断切出来的数字是否是中位数。如果不是中位数，则继续二分，直到找到中位数。\n\n\n```java\n选择较小的那个数组;\nlo=0,hi=数组长度-1;\nwhile(true)\n{\n    mid=lo+(hi-lo)/2;\n    在另一个数组切一刀，使得切下去后两边元素相等;\n    判断是否为中位数，是则退出循环，否则根据大小判断增大lo或者减小hi;\n}\n```\n\n\n\n\n\n# 细节\n\n1. 切分也要能在两个数的中间切，不然可能切不平衡。所以开始先要对两个数组扩充成2*n+1的大小(逻辑上扩充，物理上不扩充)\n2. 要判断切割后是否是中位数，则要找到切割元素的左右两边的值，所以要定义四个变量标识两个数组的左右两边的值。\n3. 计算第二个数组的中位数：mid1,mid2也是在逻辑扩充后的数组上操作.扩充后总共有2（m+n+1)个元素，切分的mid1代表了num1左边元素的个数，mid1+mid2应该等于m+n，所以mid2=m+n-mid1.(可画图分析)\n4. 计算切分元素两边的值：如果mid为基数，切的是元素，mid/2即可得到元素，他的左右两边就是他本身。如果是偶数，则是切两个数之间，mid/2就是右边元素，(mid-1)/2就是左边元素。因为（基数-1）/2效果一样，所以两种情况可以合并。\n5. 还要考虑左右两边如果是没有数字的问题。\n6. 判断往哪边二分可以画图分析.如果找到了值,返回的中位数为四个值中最中间的两个(也可以画图讨论正确性).\n7. 标为look的为之前写错后来改的部分\n\n​\t\n\n# 代码\n```java\npublic double findMedianSortedArrays(int[] nums1, int[] nums2)\n{\n    int m = nums1.length, n = nums2.length;\n    //只选取小的切分 所以取反,look 直接return,而不是调用\n    if (m > n) return findMedianSortedArrays(nums2, nums1);\n\n    int L1, R1, L2, R2;//切割元素左右两边的值\n    int mid1, mid2;\n    //逻辑上扩充成2*n+1,但是最后一个元素还要-1\n    int lo = 0, hi = 2 * m;\n\n    while (lo<=hi)\n    {\n        mid1 = lo + (hi - lo) / 2;\n        mid2 = m + n - mid1;//计算得到\n        //计算切分元素两边的值\n        //look 首先判断条件是2*m,扩充后的数组\n        //且L1,L2为值,不是索引,所以是nums1[(mid1 - 1) / 2]而不是(mid1 - 1) / 2\n        L1 = (mid1 == 0 ? Integer.MIN_VALUE : nums1[(mid1 - 1) / 2]);\n        R1 = (mid1 == 2*m ? Integer.MAX_VALUE : nums1[mid1 / 2]);\n        L2 = (mid2 == 0 ? Integer.MIN_VALUE : nums2[(mid2 - 1) / 2]);\n        R2 = (mid2 == 2*n ? Integer.MAX_VALUE : nums2[mid2 / 2]);\n\n        if(L1 > R2) hi = mid1 - 1;\n        else if(L2 > R1) lo = mid1 + 1;\n        else return (Math.max(L1, L2) + Math.min(R1, R2)) / 2.0;//look 注意运算优先级\n    }\n    return -1.0;\n}\n```\n\n\n# 复杂度分析\n## 时间复杂度\n选取最小的数组进行二分,而且二分循环中为常数操作,所以O(min(m,n))\n## 空间复杂度\n只定义了固定的几个变量,O(1)","source":"_posts/LeetCode笔记/LeetCode刷题笔记_04_ 寻找两个正序数组的中位数.md","raw":"---\ntitle: LeetCode刷题笔记04\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记04\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 数组\nabbrlink: 75dd475a\ndate: 2020-03-22 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>   [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。\n\n请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n\n你可以假设 nums1 和 nums2 不会同时为空。\n\n\n```\n\n示例 1:\n\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n\n```\n\n\n```\n示例 2:\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n\n```\n\n# 思路\n\n选择两个数组中较小的一个,先将之对半分,通过计算,对另一个数组在某位置也切一刀，使得两个数组切下那刀后左右两边数量相同。然后判断切出来的数字是否是中位数。如果不是中位数，则继续二分，直到找到中位数。\n\n\n```java\n选择较小的那个数组;\nlo=0,hi=数组长度-1;\nwhile(true)\n{\n    mid=lo+(hi-lo)/2;\n    在另一个数组切一刀，使得切下去后两边元素相等;\n    判断是否为中位数，是则退出循环，否则根据大小判断增大lo或者减小hi;\n}\n```\n\n\n\n\n\n# 细节\n\n1. 切分也要能在两个数的中间切，不然可能切不平衡。所以开始先要对两个数组扩充成2*n+1的大小(逻辑上扩充，物理上不扩充)\n2. 要判断切割后是否是中位数，则要找到切割元素的左右两边的值，所以要定义四个变量标识两个数组的左右两边的值。\n3. 计算第二个数组的中位数：mid1,mid2也是在逻辑扩充后的数组上操作.扩充后总共有2（m+n+1)个元素，切分的mid1代表了num1左边元素的个数，mid1+mid2应该等于m+n，所以mid2=m+n-mid1.(可画图分析)\n4. 计算切分元素两边的值：如果mid为基数，切的是元素，mid/2即可得到元素，他的左右两边就是他本身。如果是偶数，则是切两个数之间，mid/2就是右边元素，(mid-1)/2就是左边元素。因为（基数-1）/2效果一样，所以两种情况可以合并。\n5. 还要考虑左右两边如果是没有数字的问题。\n6. 判断往哪边二分可以画图分析.如果找到了值,返回的中位数为四个值中最中间的两个(也可以画图讨论正确性).\n7. 标为look的为之前写错后来改的部分\n\n​\t\n\n# 代码\n```java\npublic double findMedianSortedArrays(int[] nums1, int[] nums2)\n{\n    int m = nums1.length, n = nums2.length;\n    //只选取小的切分 所以取反,look 直接return,而不是调用\n    if (m > n) return findMedianSortedArrays(nums2, nums1);\n\n    int L1, R1, L2, R2;//切割元素左右两边的值\n    int mid1, mid2;\n    //逻辑上扩充成2*n+1,但是最后一个元素还要-1\n    int lo = 0, hi = 2 * m;\n\n    while (lo<=hi)\n    {\n        mid1 = lo + (hi - lo) / 2;\n        mid2 = m + n - mid1;//计算得到\n        //计算切分元素两边的值\n        //look 首先判断条件是2*m,扩充后的数组\n        //且L1,L2为值,不是索引,所以是nums1[(mid1 - 1) / 2]而不是(mid1 - 1) / 2\n        L1 = (mid1 == 0 ? Integer.MIN_VALUE : nums1[(mid1 - 1) / 2]);\n        R1 = (mid1 == 2*m ? Integer.MAX_VALUE : nums1[mid1 / 2]);\n        L2 = (mid2 == 0 ? Integer.MIN_VALUE : nums2[(mid2 - 1) / 2]);\n        R2 = (mid2 == 2*n ? Integer.MAX_VALUE : nums2[mid2 / 2]);\n\n        if(L1 > R2) hi = mid1 - 1;\n        else if(L2 > R1) lo = mid1 + 1;\n        else return (Math.max(L1, L2) + Math.min(R1, R2)) / 2.0;//look 注意运算优先级\n    }\n    return -1.0;\n}\n```\n\n\n# 复杂度分析\n## 时间复杂度\n选取最小的数组进行二分,而且二分循环中为常数操作,所以O(min(m,n))\n## 空间复杂度\n只定义了固定的几个变量,O(1)","slug":"LeetCode笔记/LeetCode刷题笔记_04_ 寻找两个正序数组的中位数","published":1,"updated":"2020-11-12T11:57:29.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xg0048jotpcr9n3pgu","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p>  <a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\" rel=\"noopener\">4. 寻找两个正序数组的中位数</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p>\n<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>\n<p>你可以假设 nums1 和 nums2 不会同时为空。</p>\n<pre><code>\n示例 1:\n\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n</code></pre>\n<pre><code>示例 2:\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>选择两个数组中较小的一个,先将之对半分,通过计算,对另一个数组在某位置也切一刀，使得两个数组切下那刀后左右两边数量相同。然后判断切出来的数字是否是中位数。如果不是中位数，则继续二分，直到找到中位数。</p>\n<pre class=\" language-java\"><code class=\"language-java\">选择较小的那个数组<span class=\"token punctuation\">;</span>\nlo<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>hi<span class=\"token operator\">=</span>数组长度<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    mid<span class=\"token operator\">=</span>lo<span class=\"token operator\">+</span><span class=\"token punctuation\">(</span>hi<span class=\"token operator\">-</span>lo<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    在另一个数组切一刀，使得切下去后两边元素相等<span class=\"token punctuation\">;</span>\n    判断是否为中位数，是则退出循环，否则根据大小判断增大lo或者减小hi<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>切分也要能在两个数的中间切，不然可能切不平衡。所以开始先要对两个数组扩充成2*n+1的大小(逻辑上扩充，物理上不扩充)</li>\n<li>要判断切割后是否是中位数，则要找到切割元素的左右两边的值，所以要定义四个变量标识两个数组的左右两边的值。</li>\n<li>计算第二个数组的中位数：mid1,mid2也是在逻辑扩充后的数组上操作.扩充后总共有2（m+n+1)个元素，切分的mid1代表了num1左边元素的个数，mid1+mid2应该等于m+n，所以mid2=m+n-mid1.(可画图分析)</li>\n<li>计算切分元素两边的值：如果mid为基数，切的是元素，mid/2即可得到元素，他的左右两边就是他本身。如果是偶数，则是切两个数之间，mid/2就是右边元素，(mid-1)/2就是左边元素。因为（基数-1）/2效果一样，所以两种情况可以合并。</li>\n<li>还要考虑左右两边如果是没有数字的问题。</li>\n<li>判断往哪边二分可以画图分析.如果找到了值,返回的中位数为四个值中最中间的两个(也可以画图讨论正确性).</li>\n<li>标为look的为之前写错后来改的部分</li>\n</ol>\n<p>​    </p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">findMedianSortedArrays</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> nums1<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> nums2<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//只选取小的切分 所以取反,look 直接return,而不是调用</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">></span> n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">findMedianSortedArrays</span><span class=\"token punctuation\">(</span>nums2<span class=\"token punctuation\">,</span> nums1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> L1<span class=\"token punctuation\">,</span> R1<span class=\"token punctuation\">,</span> L2<span class=\"token punctuation\">,</span> R2<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//切割元素左右两边的值</span>\n    <span class=\"token keyword\">int</span> mid1<span class=\"token punctuation\">,</span> mid2<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//逻辑上扩充成2*n+1,但是最后一个元素还要-1</span>\n    <span class=\"token keyword\">int</span> lo <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> hi <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> m<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>lo<span class=\"token operator\">&lt;=</span>hi<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        mid1 <span class=\"token operator\">=</span> lo <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>hi <span class=\"token operator\">-</span> lo<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        mid2 <span class=\"token operator\">=</span> m <span class=\"token operator\">+</span> n <span class=\"token operator\">-</span> mid1<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//计算得到</span>\n        <span class=\"token comment\" spellcheck=\"true\">//计算切分元素两边的值</span>\n        <span class=\"token comment\" spellcheck=\"true\">//look 首先判断条件是2*m,扩充后的数组</span>\n        <span class=\"token comment\" spellcheck=\"true\">//且L1,L2为值,不是索引,所以是nums1[(mid1 - 1) / 2]而不是(mid1 - 1) / 2</span>\n        L1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>mid1 <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> Integer<span class=\"token punctuation\">.</span>MIN_VALUE <span class=\"token operator\">:</span> nums1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>mid1 <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        R1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>mid1 <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span>m <span class=\"token operator\">?</span> Integer<span class=\"token punctuation\">.</span>MAX_VALUE <span class=\"token operator\">:</span> nums1<span class=\"token punctuation\">[</span>mid1 <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        L2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>mid2 <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> Integer<span class=\"token punctuation\">.</span>MIN_VALUE <span class=\"token operator\">:</span> nums2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>mid2 <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        R2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>mid2 <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span>n <span class=\"token operator\">?</span> Integer<span class=\"token punctuation\">.</span>MAX_VALUE <span class=\"token operator\">:</span> nums2<span class=\"token punctuation\">[</span>mid2 <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>L1 <span class=\"token operator\">></span> R2<span class=\"token punctuation\">)</span> hi <span class=\"token operator\">=</span> mid1 <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>L2 <span class=\"token operator\">></span> R1<span class=\"token punctuation\">)</span> lo <span class=\"token operator\">=</span> mid1 <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>L1<span class=\"token punctuation\">,</span> L2<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>R1<span class=\"token punctuation\">,</span> R2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2.0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look 注意运算优先级</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>选取最小的数组进行二分,而且二分循环中为常数操作,所以O(min(m,n))</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>只定义了固定的几个变量,O(1)</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p>  <a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\" rel=\"noopener\">4. 寻找两个正序数组的中位数</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p>\n<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>\n<p>你可以假设 nums1 和 nums2 不会同时为空。</p>\n<pre><code>\n示例 1:\n\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n</code></pre>\n<pre><code>示例 2:\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>选择两个数组中较小的一个,先将之对半分,通过计算,对另一个数组在某位置也切一刀，使得两个数组切下那刀后左右两边数量相同。然后判断切出来的数字是否是中位数。如果不是中位数，则继续二分，直到找到中位数。</p>\n<pre><code class=\"java\">选择较小的那个数组;\nlo=0,hi=数组长度-1;\nwhile(true)\n{\n    mid=lo+(hi-lo)/2;\n    在另一个数组切一刀，使得切下去后两边元素相等;\n    判断是否为中位数，是则退出循环，否则根据大小判断增大lo或者减小hi;\n}</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>切分也要能在两个数的中间切，不然可能切不平衡。所以开始先要对两个数组扩充成2*n+1的大小(逻辑上扩充，物理上不扩充)</li>\n<li>要判断切割后是否是中位数，则要找到切割元素的左右两边的值，所以要定义四个变量标识两个数组的左右两边的值。</li>\n<li>计算第二个数组的中位数：mid1,mid2也是在逻辑扩充后的数组上操作.扩充后总共有2（m+n+1)个元素，切分的mid1代表了num1左边元素的个数，mid1+mid2应该等于m+n，所以mid2=m+n-mid1.(可画图分析)</li>\n<li>计算切分元素两边的值：如果mid为基数，切的是元素，mid/2即可得到元素，他的左右两边就是他本身。如果是偶数，则是切两个数之间，mid/2就是右边元素，(mid-1)/2就是左边元素。因为（基数-1）/2效果一样，所以两种情况可以合并。</li>\n<li>还要考虑左右两边如果是没有数字的问题。</li>\n<li>判断往哪边二分可以画图分析.如果找到了值,返回的中位数为四个值中最中间的两个(也可以画图讨论正确性).</li>\n<li>标为look的为之前写错后来改的部分</li>\n</ol>\n<p>​    </p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public double findMedianSortedArrays(int[] nums1, int[] nums2)\n{\n    int m = nums1.length, n = nums2.length;\n    //只选取小的切分 所以取反,look 直接return,而不是调用\n    if (m &gt; n) return findMedianSortedArrays(nums2, nums1);\n\n    int L1, R1, L2, R2;//切割元素左右两边的值\n    int mid1, mid2;\n    //逻辑上扩充成2*n+1,但是最后一个元素还要-1\n    int lo = 0, hi = 2 * m;\n\n    while (lo&lt;=hi)\n    {\n        mid1 = lo + (hi - lo) / 2;\n        mid2 = m + n - mid1;//计算得到\n        //计算切分元素两边的值\n        //look 首先判断条件是2*m,扩充后的数组\n        //且L1,L2为值,不是索引,所以是nums1[(mid1 - 1) / 2]而不是(mid1 - 1) / 2\n        L1 = (mid1 == 0 ? Integer.MIN_VALUE : nums1[(mid1 - 1) / 2]);\n        R1 = (mid1 == 2*m ? Integer.MAX_VALUE : nums1[mid1 / 2]);\n        L2 = (mid2 == 0 ? Integer.MIN_VALUE : nums2[(mid2 - 1) / 2]);\n        R2 = (mid2 == 2*n ? Integer.MAX_VALUE : nums2[mid2 / 2]);\n\n        if(L1 &gt; R2) hi = mid1 - 1;\n        else if(L2 &gt; R1) lo = mid1 + 1;\n        else return (Math.max(L1, L2) + Math.min(R1, R2)) / 2.0;//look 注意运算优先级\n    }\n    return -1.0;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>选取最小的数组进行二分,而且二分循环中为常数操作,所以O(min(m,n))</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>只定义了固定的几个变量,O(1)</p>\n"},{"title":"LeetCode刷题笔记104","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"1dd3d1a6","date":"2020-05-23T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n```\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n   \n返回它的最大深度 3 。\n```\n\n\n\n\n# 代码\n```java\npublic int maxDepth(TreeNode root)\n{\n\tif(root==null) return 0;\n\treturn Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n}\n```\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_104. 二叉树的最大深度.md","raw":"---\ntitle: LeetCode刷题笔记104\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 二叉树\n  - 递归\nabbrlink: 1dd3d1a6\ndate: 2020-05-24 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n```\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n   \n返回它的最大深度 3 。\n```\n\n\n\n\n# 代码\n```java\npublic int maxDepth(TreeNode root)\n{\n\tif(root==null) return 0;\n\treturn Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n}\n```\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_104. 二叉树的最大深度","published":1,"updated":"2020-11-12T11:57:29.386Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xl004djotpeedy3xjk","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">104. 二叉树的最大深度</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<p>说明: 叶子节点是指没有子节点的节点。</p>\n<pre><code>示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最大深度 3 。</code></pre>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxDepth</span><span class=\"token punctuation\">(</span>TreeNode root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">maxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">maxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">104. 二叉树的最大深度</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<p>说明: 叶子节点是指没有子节点的节点。</p>\n<pre><code>示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最大深度 3 。</code></pre>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int maxDepth(TreeNode root)\n{\n    if(root==null) return 0;\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n}</code></pre>\n"},{"title":"LeetCode刷题笔记10","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"6babb202","date":"2020-03-22T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\n\n'.' 匹配任意单个字符\n'*' 匹配零个或多个前面的那一个元素\n所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n\n说明:\n\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n示例 1:\n\n```\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n```\n示例 2:\n```\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n```\n示例 3:\n```\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n```\n示例 4:\n```\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n```\n示例 5:\n```\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\n```\n\n# 思路\n\n动态规划:\n\n定义`dp[i][j]`为s的`[0,i-1]`个字符与p的前`[0,j-1]`个字符是否匹配.\n\n结束:`dp[m][n]`\n\n初始化:\n\n```java\n//s为空时,p匹配s的情况:\ndp[0][0]=true;\n//如果这个位置为*,则还可能为true,即让前个位置字符匹配0次,查看是否相等\n//注意越界检查等等\nfor(j in [1,n])\n\tif(p[j-1]=='*') dp[0][j]=dp[0][j-2]\n\telse dp[0][j]=false;\n\n//p为空时,p匹配s的情况:\n//无特殊情况\nfor(i in [1,n])\n\tdp[0][i]=false;\n\n```\n递推公式:\n```java\n//匹配的情况最好\nif(s[i-1]==p[j-1] || p[j-1]=='.') \n{\n\tdp[i][j]=dp[i-1][j-1];\n}\nelse if(p[j-1]=='*')//是特殊字符*\n{\n\t//分三种情况讨论,分别是匹配0次,1次,n次\n\t//只要其中一种匹配成功即可,即为||\n\t//匹配n次比较复杂 要求s[0,i-2]的都匹配了(即dp[i-1][j]匹配),再看s[i-1]是否能匹配上p中要复制的字符,即p.charAt(j - 2)和它相等或者为.的情况(.*)\n\tdp[i][j]=dp[i][j-2] || dp[i][j-1] || \n\t(dp[i-1][j] && (p[j-2]=='.' || p[j-2]==s[i-1]));\n}\n\n```\n\n\n\n# 细节\n1. 要注意很多的数组边界情况\n2. s.length()的情况不用考虑\n3. `*`匹配多个的逻辑要注意,并且要考虑 `.*`的情况\n\n\n# 代码\n```java\npublic boolean isMatch(String s, String p)\n{\n    //look如果判断s.length()==0,会很难处理 因为\"\"与\".*\"是匹配的\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n\n    //初始化 不需要判断s,p的长度是否0,因为dp[0][0]肯定存在\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++) dp[i][0] = false;\n    //默认*不能出现在最前面\n    for (int j = 1; j <= n; j++)\n    {\n        if (p.charAt(j - 1) == '*' && j >= 2) dp[0][j] = dp[0][j - 2];\n        else dp[0][j] = false;\n    }\n\n    for (int i = 1; i <= m; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            char charS = s.charAt(i - 1);\n            char charP = p.charAt(j - 1);\n\n            if (charS == charP || charP == '.')\n            {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            else if (charP == '*' && j >= 2)\n            {\n                //look,匹配多个判断,首先要s[0,i-2]的都匹配了(即dp[i-1][j]匹配),再看s[i-1]是否能匹配上p中要复制的字符\n                //即p.charAt(j - 2)和它相等或者为.的情况(.*)\n                boolean matchMore = (dp[i - 1][j] && (p.charAt(j - 2) == '.' || p.charAt(j - 2) == charS));\n                dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || matchMore;\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n\n# 复杂度分析\n\n## 时间复杂度\n\n二重循环,$ O(MN) $\n\n## 空间复杂度\n\ndp数组,$ O(MN) $","source":"_posts/LeetCode笔记/LeetCode刷题笔记_10_正则表达式匹配.md","raw":"---\ntitle: LeetCode刷题笔记10\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 字符串\nabbrlink: 6babb202\ndate: 2020-03-23 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\n\n'.' 匹配任意单个字符\n'*' 匹配零个或多个前面的那一个元素\n所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n\n说明:\n\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n示例 1:\n\n```\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n```\n示例 2:\n```\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n```\n示例 3:\n```\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n```\n示例 4:\n```\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n```\n示例 5:\n```\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\n```\n\n# 思路\n\n动态规划:\n\n定义`dp[i][j]`为s的`[0,i-1]`个字符与p的前`[0,j-1]`个字符是否匹配.\n\n结束:`dp[m][n]`\n\n初始化:\n\n```java\n//s为空时,p匹配s的情况:\ndp[0][0]=true;\n//如果这个位置为*,则还可能为true,即让前个位置字符匹配0次,查看是否相等\n//注意越界检查等等\nfor(j in [1,n])\n\tif(p[j-1]=='*') dp[0][j]=dp[0][j-2]\n\telse dp[0][j]=false;\n\n//p为空时,p匹配s的情况:\n//无特殊情况\nfor(i in [1,n])\n\tdp[0][i]=false;\n\n```\n递推公式:\n```java\n//匹配的情况最好\nif(s[i-1]==p[j-1] || p[j-1]=='.') \n{\n\tdp[i][j]=dp[i-1][j-1];\n}\nelse if(p[j-1]=='*')//是特殊字符*\n{\n\t//分三种情况讨论,分别是匹配0次,1次,n次\n\t//只要其中一种匹配成功即可,即为||\n\t//匹配n次比较复杂 要求s[0,i-2]的都匹配了(即dp[i-1][j]匹配),再看s[i-1]是否能匹配上p中要复制的字符,即p.charAt(j - 2)和它相等或者为.的情况(.*)\n\tdp[i][j]=dp[i][j-2] || dp[i][j-1] || \n\t(dp[i-1][j] && (p[j-2]=='.' || p[j-2]==s[i-1]));\n}\n\n```\n\n\n\n# 细节\n1. 要注意很多的数组边界情况\n2. s.length()的情况不用考虑\n3. `*`匹配多个的逻辑要注意,并且要考虑 `.*`的情况\n\n\n# 代码\n```java\npublic boolean isMatch(String s, String p)\n{\n    //look如果判断s.length()==0,会很难处理 因为\"\"与\".*\"是匹配的\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n\n    //初始化 不需要判断s,p的长度是否0,因为dp[0][0]肯定存在\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++) dp[i][0] = false;\n    //默认*不能出现在最前面\n    for (int j = 1; j <= n; j++)\n    {\n        if (p.charAt(j - 1) == '*' && j >= 2) dp[0][j] = dp[0][j - 2];\n        else dp[0][j] = false;\n    }\n\n    for (int i = 1; i <= m; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            char charS = s.charAt(i - 1);\n            char charP = p.charAt(j - 1);\n\n            if (charS == charP || charP == '.')\n            {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            else if (charP == '*' && j >= 2)\n            {\n                //look,匹配多个判断,首先要s[0,i-2]的都匹配了(即dp[i-1][j]匹配),再看s[i-1]是否能匹配上p中要复制的字符\n                //即p.charAt(j - 2)和它相等或者为.的情况(.*)\n                boolean matchMore = (dp[i - 1][j] && (p.charAt(j - 2) == '.' || p.charAt(j - 2) == charS));\n                dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || matchMore;\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n\n# 复杂度分析\n\n## 时间复杂度\n\n二重循环,$ O(MN) $\n\n## 空间复杂度\n\ndp数组,$ O(MN) $","slug":"LeetCode笔记/LeetCode刷题笔记_10_正则表达式匹配","published":1,"updated":"2020-11-12T11:57:29.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xm004gjotp4vlc0c13","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/regular-expression-matching/\" target=\"_blank\" rel=\"noopener\">10. 正则表达式匹配</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>\n<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>\n<p>说明:</p>\n<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br>示例 1:</p>\n<pre><code>输入:\ns = &quot;aa&quot;\np = &quot;a&quot;\n输出: false\n解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</code></pre>\n<p>示例 2:</p>\n<pre><code>输入:\ns = &quot;aa&quot;\np = &quot;a*&quot;\n输出: true\n解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</code></pre>\n<p>示例 3:</p>\n<pre><code>输入:\ns = &quot;ab&quot;\np = &quot;.*&quot;\n输出: true\n解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</code></pre>\n<p>示例 4:</p>\n<pre><code>输入:\ns = &quot;aab&quot;\np = &quot;c*a*b&quot;\n输出: true\n解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</code></pre>\n<p>示例 5:</p>\n<pre><code>输入:\ns = &quot;mississippi&quot;\np = &quot;mis*is*p*.&quot;\n输出: false</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>动态规划:</p>\n<p>定义<code>dp[i][j]</code>为s的<code>[0,i-1]</code>个字符与p的前<code>[0,j-1]</code>个字符是否匹配.</p>\n<p>结束:<code>dp[m][n]</code></p>\n<p>初始化:</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//s为空时,p匹配s的情况:</span>\ndp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//如果这个位置为*,则还可能为true,即让前个位置字符匹配0次,查看是否相等</span>\n<span class=\"token comment\" spellcheck=\"true\">//注意越界检查等等</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>j in <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span> dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">else</span> dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//p为空时,p匹配s的情况:</span>\n<span class=\"token comment\" spellcheck=\"true\">//无特殊情况</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i in <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>递推公式:</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//匹配的情况最好</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>p<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> p<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n    dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//是特殊字符*</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//分三种情况讨论,分别是匹配0次,1次,n次</span>\n    <span class=\"token comment\" spellcheck=\"true\">//只要其中一种匹配成功即可,即为||</span>\n    <span class=\"token comment\" spellcheck=\"true\">//匹配n次比较复杂 要求s[0,i-2]的都匹配了(即dp[i-1][j]匹配),再看s[i-1]是否能匹配上p中要复制的字符,即p.charAt(j - 2)和它相等或者为.的情况(.*)</span>\n    dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> \n    <span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token string\">'.'</span> <span class=\"token operator\">||</span> p<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>s<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>要注意很多的数组边界情况</li>\n<li>s.length()的情况不用考虑</li>\n<li><code>*</code>匹配多个的逻辑要注意,并且要考虑 <code>.*</code>的情况</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isMatch</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">,</span> String p<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//look如果判断s.length()==0,会很难处理 因为\"\"与\".*\"是匹配的</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> dp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">boolean</span><span class=\"token punctuation\">[</span>m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//初始化 不需要判断s,p的长度是否0,因为dp[0][0]肯定存在</span>\n    dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//默认*不能出现在最前面</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token string\">'*'</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">>=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">char</span> charS <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">char</span> charP <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>charS <span class=\"token operator\">==</span> charP <span class=\"token operator\">||</span> charP <span class=\"token operator\">==</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>charP <span class=\"token operator\">==</span> <span class=\"token string\">'*'</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">>=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//look,匹配多个判断,首先要s[0,i-2]的都匹配了(即dp[i-1][j]匹配),再看s[i-1]是否能匹配上p中要复制的字符</span>\n                <span class=\"token comment\" spellcheck=\"true\">//即p.charAt(j - 2)和它相等或者为.的情况(.*)</span>\n                <span class=\"token keyword\">boolean</span> matchMore <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token string\">'.'</span> <span class=\"token operator\">||</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> charS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> matchMore<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>二重循环,$ O(MN) $</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>dp数组,$ O(MN) $</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/regular-expression-matching/\" target=\"_blank\" rel=\"noopener\">10. 正则表达式匹配</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>\n<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>\n<p>说明:</p>\n<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br>示例 1:</p>\n<pre><code>输入:\ns = &quot;aa&quot;\np = &quot;a&quot;\n输出: false\n解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</code></pre>\n<p>示例 2:</p>\n<pre><code>输入:\ns = &quot;aa&quot;\np = &quot;a*&quot;\n输出: true\n解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</code></pre>\n<p>示例 3:</p>\n<pre><code>输入:\ns = &quot;ab&quot;\np = &quot;.*&quot;\n输出: true\n解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</code></pre>\n<p>示例 4:</p>\n<pre><code>输入:\ns = &quot;aab&quot;\np = &quot;c*a*b&quot;\n输出: true\n解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</code></pre>\n<p>示例 5:</p>\n<pre><code>输入:\ns = &quot;mississippi&quot;\np = &quot;mis*is*p*.&quot;\n输出: false</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>动态规划:</p>\n<p>定义<code>dp[i][j]</code>为s的<code>[0,i-1]</code>个字符与p的前<code>[0,j-1]</code>个字符是否匹配.</p>\n<p>结束:<code>dp[m][n]</code></p>\n<p>初始化:</p>\n<pre><code class=\"java\">//s为空时,p匹配s的情况:\ndp[0][0]=true;\n//如果这个位置为*,则还可能为true,即让前个位置字符匹配0次,查看是否相等\n//注意越界检查等等\nfor(j in [1,n])\n    if(p[j-1]==&#39;*&#39;) dp[0][j]=dp[0][j-2]\n    else dp[0][j]=false;\n\n//p为空时,p匹配s的情况:\n//无特殊情况\nfor(i in [1,n])\n    dp[0][i]=false;\n</code></pre>\n<p>递推公式:</p>\n<pre><code class=\"java\">//匹配的情况最好\nif(s[i-1]==p[j-1] || p[j-1]==&#39;.&#39;) \n{\n    dp[i][j]=dp[i-1][j-1];\n}\nelse if(p[j-1]==&#39;*&#39;)//是特殊字符*\n{\n    //分三种情况讨论,分别是匹配0次,1次,n次\n    //只要其中一种匹配成功即可,即为||\n    //匹配n次比较复杂 要求s[0,i-2]的都匹配了(即dp[i-1][j]匹配),再看s[i-1]是否能匹配上p中要复制的字符,即p.charAt(j - 2)和它相等或者为.的情况(.*)\n    dp[i][j]=dp[i][j-2] || dp[i][j-1] || \n    (dp[i-1][j] &amp;&amp; (p[j-2]==&#39;.&#39; || p[j-2]==s[i-1]));\n}\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>要注意很多的数组边界情况</li>\n<li>s.length()的情况不用考虑</li>\n<li><code>*</code>匹配多个的逻辑要注意,并且要考虑 <code>.*</code>的情况</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public boolean isMatch(String s, String p)\n{\n    //look如果判断s.length()==0,会很难处理 因为&quot;&quot;与&quot;.*&quot;是匹配的\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n\n    //初始化 不需要判断s,p的长度是否0,因为dp[0][0]肯定存在\n    dp[0][0] = true;\n    for (int i = 1; i &lt;= m; i++) dp[i][0] = false;\n    //默认*不能出现在最前面\n    for (int j = 1; j &lt;= n; j++)\n    {\n        if (p.charAt(j - 1) == &#39;*&#39; &amp;&amp; j &gt;= 2) dp[0][j] = dp[0][j - 2];\n        else dp[0][j] = false;\n    }\n\n    for (int i = 1; i &lt;= m; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            char charS = s.charAt(i - 1);\n            char charP = p.charAt(j - 1);\n\n            if (charS == charP || charP == &#39;.&#39;)\n            {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            else if (charP == &#39;*&#39; &amp;&amp; j &gt;= 2)\n            {\n                //look,匹配多个判断,首先要s[0,i-2]的都匹配了(即dp[i-1][j]匹配),再看s[i-1]是否能匹配上p中要复制的字符\n                //即p.charAt(j - 2)和它相等或者为.的情况(.*)\n                boolean matchMore = (dp[i - 1][j] &amp;&amp; (p.charAt(j - 2) == &#39;.&#39; || p.charAt(j - 2) == charS));\n                dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || matchMore;\n            }\n        }\n    }\n\n    return dp[m][n];\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>二重循环,$ O(MN) $</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>dp数组,$ O(MN) $</p>\n"},{"title":"LeetCode刷题笔记114","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"4c8e0e7","date":"2020-05-26T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)\n>\n> 其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个二叉树，原地将它展开为一个单链表。\n\n\n```\n例如，给定二叉树\n\n    1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n将其展开为：\n\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n\n```\n\n# 思路\n\n按照中序遍历的顺序构造成链表,并将之放在右子树的位置上\n\n# 细节\n\n需要原地展开\n\n# 代码\n\n```java\n/**\n *\n * 该做法是不断将右子树放在左子树的最后一个节点上,再将左子树变为右子树\n * 更加直观,更加符合中左右的形式\n */\npublic void flatten(TreeNode root)\n{\n    while(root!=null)\n    {\n        //没有左子树,则直接到下一个右子树上,不需要继续考虑\n        if(root.left!=null)\n        {\n            //找到左子树最右节点\n            TreeNode temp = root.left;\n            while(temp.right!=null)\n            {\n                temp = temp.right;\n            }\n\n            //将右子树放在左子树的最后一个节点上\n            temp.right = root.right;\n\n            //将左子树变为右子树\n            root.right = root.left;\n            root.left = null;\n        }\n        root = root.right;\n    }\n}\n```\n\n```java\n\n    /**\n     * 该方法是先把左子树放当前节点右边,当到最后一个左节点时,再放入右节点\n     * 速度比较慢\n     */\npublic void flatten(TreeNode root)\n{\n    Stack<TreeNode> stack = new Stack<>();\n    while(root!=null)\n    {\n        //保存当前节点的右节点\n        if(root.right!=null)\n        {\n            stack.push(root.right);\n        }\n\n        //将当前节点的左子树转移到右子树\n        root.right = root.left;\n        root.left = null;\n\n        //说明往左遍历结束了\n        if(root.right==null)\n        {\n            if(!stack.isEmpty())\n            {\n                root.right = stack.pop();\n            }\n            else\n            {\n                //说明左右子树都没了\n                return;\n            }\n        }\n        root = root.right;\n    }\n}\n```\n\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_114. 二叉树展开为链表.md","raw":"---\ntitle: LeetCode刷题笔记114\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 二叉树\n  - 链表\nabbrlink: 4c8e0e7\ndate: 2020-05-27 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)\n>\n> 其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个二叉树，原地将它展开为一个单链表。\n\n\n```\n例如，给定二叉树\n\n    1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n将其展开为：\n\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n\n```\n\n# 思路\n\n按照中序遍历的顺序构造成链表,并将之放在右子树的位置上\n\n# 细节\n\n需要原地展开\n\n# 代码\n\n```java\n/**\n *\n * 该做法是不断将右子树放在左子树的最后一个节点上,再将左子树变为右子树\n * 更加直观,更加符合中左右的形式\n */\npublic void flatten(TreeNode root)\n{\n    while(root!=null)\n    {\n        //没有左子树,则直接到下一个右子树上,不需要继续考虑\n        if(root.left!=null)\n        {\n            //找到左子树最右节点\n            TreeNode temp = root.left;\n            while(temp.right!=null)\n            {\n                temp = temp.right;\n            }\n\n            //将右子树放在左子树的最后一个节点上\n            temp.right = root.right;\n\n            //将左子树变为右子树\n            root.right = root.left;\n            root.left = null;\n        }\n        root = root.right;\n    }\n}\n```\n\n```java\n\n    /**\n     * 该方法是先把左子树放当前节点右边,当到最后一个左节点时,再放入右节点\n     * 速度比较慢\n     */\npublic void flatten(TreeNode root)\n{\n    Stack<TreeNode> stack = new Stack<>();\n    while(root!=null)\n    {\n        //保存当前节点的右节点\n        if(root.right!=null)\n        {\n            stack.push(root.right);\n        }\n\n        //将当前节点的左子树转移到右子树\n        root.right = root.left;\n        root.left = null;\n\n        //说明往左遍历结束了\n        if(root.right==null)\n        {\n            if(!stack.isEmpty())\n            {\n                root.right = stack.pop();\n            }\n            else\n            {\n                //说明左右子树都没了\n                return;\n            }\n        }\n        root = root.right;\n    }\n}\n```\n\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_114. 二叉树展开为链表","published":1,"updated":"2020-11-12T11:57:29.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xn004jjotpg48j2x1s","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/\" target=\"_blank\" rel=\"noopener\">114. 二叉树展开为链表</a></p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二叉树，原地将它展开为一个单链表。</p>\n<pre><code>例如，给定二叉树\n\n    1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n将其展开为：\n\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>按照中序遍历的顺序构造成链表,并将之放在右子树的位置上</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>需要原地展开</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n *\n * 该做法是不断将右子树放在左子树的最后一个节点上,再将左子树变为右子树\n * 更加直观,更加符合中左右的形式\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">flatten</span><span class=\"token punctuation\">(</span>TreeNode root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//没有左子树,则直接到下一个右子树上,不需要继续考虑</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>left<span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//找到左子树最右节点</span>\n            TreeNode temp <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">.</span>right<span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                temp <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">//将右子树放在左子树的最后一个节点上</span>\n            temp<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">//将左子树变为右子树</span>\n            root<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">;</span>\n            root<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        root <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 该方法是先把左子树放当前节点右边,当到最后一个左节点时,再放入右节点\n     * 速度比较慢\n     */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">flatten</span><span class=\"token punctuation\">(</span>TreeNode root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Stack<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">></span> stack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//保存当前节点的右节点</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>right<span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//将当前节点的左子树转移到右子树</span>\n        root<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">;</span>\n        root<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//说明往左遍历结束了</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>right<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                root<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//说明左右子树都没了</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        root <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/\" target=\"_blank\" rel=\"noopener\">114. 二叉树展开为链表</a></p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二叉树，原地将它展开为一个单链表。</p>\n<pre><code>例如，给定二叉树\n\n    1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n将其展开为：\n\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>按照中序遍历的顺序构造成链表,并将之放在右子树的位置上</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>需要原地展开</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">/**\n *\n * 该做法是不断将右子树放在左子树的最后一个节点上,再将左子树变为右子树\n * 更加直观,更加符合中左右的形式\n */\npublic void flatten(TreeNode root)\n{\n    while(root!=null)\n    {\n        //没有左子树,则直接到下一个右子树上,不需要继续考虑\n        if(root.left!=null)\n        {\n            //找到左子树最右节点\n            TreeNode temp = root.left;\n            while(temp.right!=null)\n            {\n                temp = temp.right;\n            }\n\n            //将右子树放在左子树的最后一个节点上\n            temp.right = root.right;\n\n            //将左子树变为右子树\n            root.right = root.left;\n            root.left = null;\n        }\n        root = root.right;\n    }\n}</code></pre>\n<pre><code class=\"java\">\n    /**\n     * 该方法是先把左子树放当前节点右边,当到最后一个左节点时,再放入右节点\n     * 速度比较慢\n     */\npublic void flatten(TreeNode root)\n{\n    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n    while(root!=null)\n    {\n        //保存当前节点的右节点\n        if(root.right!=null)\n        {\n            stack.push(root.right);\n        }\n\n        //将当前节点的左子树转移到右子树\n        root.right = root.left;\n        root.left = null;\n\n        //说明往左遍历结束了\n        if(root.right==null)\n        {\n            if(!stack.isEmpty())\n            {\n                root.right = stack.pop();\n            }\n            else\n            {\n                //说明左右子树都没了\n                return;\n            }\n        }\n        root = root.right;\n    }\n}</code></pre>\n"},{"title":"LeetCode刷题笔记105","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"6ad4e130","date":"2020-05-24T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n根据一棵树的前序遍历与中序遍历构造二叉树。\n\n注意:\n\t你可以假设树中没有重复的元素。\n\n```\n例如，给出\n\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n# 思路\n\n对于前序与中序遍历的数组[lo,hi]:\n\n+ 前序的根节点是lo,中序的根节点是i\n+ 前序的左子树是[lo+1,i],右子树是[i+1,hi]\n+ 中序的左子树是[lo,i-1],右子树是[i+1,hi]\n\n由此,可以先构造根节点,然后根据前序中序的左右数组构造他的左右节点,一直不断递归下去...\n\n# 细节\n\n1. 注意几次递归后前序,中序数组可能不是上下对称的,所以他们索引index得区分为preIndex,inIndex\n2. 用map存储可以加快速度\n\n# 代码\n\n```java\n/**\n * look 用map存储加快速度\n树中没有重复元素\n用map存储inorder数组的值和对应索引\n 方便找到根节点位置\n */\nprivate Map<Integer, Integer> map = new HashMap<>();\n\npublic TreeNode buildTree(int[] preorder, int[] inorder)\n{\n    for (int i = 0; i < inorder.length; i++)\n    {\n        map.put(inorder[i], i);\n    }\n    return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);\n}\n\nprivate TreeNode buildTree(int[] preorder, int preLo, int preHi, int[] inorder, int inLo, int inHi)\n{\n    if (preLo > preHi || inLo > inHi)\n    {\n        return null;\n    }\n    //找到根节点在中序遍历的索引位置\n    int inIndex = map.get(preorder[preLo]);\n    //look,i在经过几次之后,只是对应了inorder的i,但是对于preorder,应该只是一个偏移量\n    //inIndex - inLo代表左子树的个数,preIndex则是前序遍历左子树的最后一个元素\n    int preIndex = preLo + inIndex - inLo;\n    TreeNode root = new TreeNode(preorder[preLo]);\n    root.left = buildTree(preorder, preLo + 1, preIndex, inorder, inLo, inIndex - 1);\n    root.right = buildTree(preorder, preIndex + 1, preHi, inorder, inIndex + 1, inHi);\n    return root;\n}\n```\n\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_105. 从前序与中序遍历序列构造二叉树.md","raw":"---\ntitle: LeetCode刷题笔记105\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 二叉树\n  - 遍历\nabbrlink: 6ad4e130\ndate: 2020-05-25 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n根据一棵树的前序遍历与中序遍历构造二叉树。\n\n注意:\n\t你可以假设树中没有重复的元素。\n\n```\n例如，给出\n\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n# 思路\n\n对于前序与中序遍历的数组[lo,hi]:\n\n+ 前序的根节点是lo,中序的根节点是i\n+ 前序的左子树是[lo+1,i],右子树是[i+1,hi]\n+ 中序的左子树是[lo,i-1],右子树是[i+1,hi]\n\n由此,可以先构造根节点,然后根据前序中序的左右数组构造他的左右节点,一直不断递归下去...\n\n# 细节\n\n1. 注意几次递归后前序,中序数组可能不是上下对称的,所以他们索引index得区分为preIndex,inIndex\n2. 用map存储可以加快速度\n\n# 代码\n\n```java\n/**\n * look 用map存储加快速度\n树中没有重复元素\n用map存储inorder数组的值和对应索引\n 方便找到根节点位置\n */\nprivate Map<Integer, Integer> map = new HashMap<>();\n\npublic TreeNode buildTree(int[] preorder, int[] inorder)\n{\n    for (int i = 0; i < inorder.length; i++)\n    {\n        map.put(inorder[i], i);\n    }\n    return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);\n}\n\nprivate TreeNode buildTree(int[] preorder, int preLo, int preHi, int[] inorder, int inLo, int inHi)\n{\n    if (preLo > preHi || inLo > inHi)\n    {\n        return null;\n    }\n    //找到根节点在中序遍历的索引位置\n    int inIndex = map.get(preorder[preLo]);\n    //look,i在经过几次之后,只是对应了inorder的i,但是对于preorder,应该只是一个偏移量\n    //inIndex - inLo代表左子树的个数,preIndex则是前序遍历左子树的最后一个元素\n    int preIndex = preLo + inIndex - inLo;\n    TreeNode root = new TreeNode(preorder[preLo]);\n    root.left = buildTree(preorder, preLo + 1, preIndex, inorder, inLo, inIndex - 1);\n    root.right = buildTree(preorder, preIndex + 1, preHi, inorder, inIndex + 1, inHi);\n    return root;\n}\n```\n\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_105. 从前序与中序遍历序列构造二叉树","published":1,"updated":"2020-11-12T11:57:29.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xo004mjotpas42hlq7","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">105. 从前序与中序遍历序列构造二叉树</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>\n<p>注意:<br>    你可以假设树中没有重复的元素。</p>\n<pre><code>例如，给出\n\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>对于前序与中序遍历的数组[lo,hi]:</p>\n<ul>\n<li>前序的根节点是lo,中序的根节点是i</li>\n<li>前序的左子树是[lo+1,i],右子树是[i+1,hi]</li>\n<li>中序的左子树是[lo,i-1],右子树是[i+1,hi]</li>\n</ul>\n<p>由此,可以先构造根节点,然后根据前序中序的左右数组构造他的左右节点,一直不断递归下去…</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意几次递归后前序,中序数组可能不是上下对称的,所以他们索引index得区分为preIndex,inIndex</li>\n<li>用map存储可以加快速度</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * look 用map存储加快速度\n树中没有重复元素\n用map存储inorder数组的值和对应索引\n 方便找到根节点位置\n */</span>\n<span class=\"token keyword\">private</span> Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> TreeNode <span class=\"token function\">buildTree</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> preorder<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> inorder<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> inorder<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>inorder<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">buildTree</span><span class=\"token punctuation\">(</span>preorder<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> preorder<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> inorder<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> inorder<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> TreeNode <span class=\"token function\">buildTree</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> preorder<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> preLo<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> preHi<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> inorder<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> inLo<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> inHi<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>preLo <span class=\"token operator\">></span> preHi <span class=\"token operator\">||</span> inLo <span class=\"token operator\">></span> inHi<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//找到根节点在中序遍历的索引位置</span>\n    <span class=\"token keyword\">int</span> inIndex <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>preorder<span class=\"token punctuation\">[</span>preLo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//look,i在经过几次之后,只是对应了inorder的i,但是对于preorder,应该只是一个偏移量</span>\n    <span class=\"token comment\" spellcheck=\"true\">//inIndex - inLo代表左子树的个数,preIndex则是前序遍历左子树的最后一个元素</span>\n    <span class=\"token keyword\">int</span> preIndex <span class=\"token operator\">=</span> preLo <span class=\"token operator\">+</span> inIndex <span class=\"token operator\">-</span> inLo<span class=\"token punctuation\">;</span>\n    TreeNode root <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">(</span>preorder<span class=\"token punctuation\">[</span>preLo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    root<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> <span class=\"token function\">buildTree</span><span class=\"token punctuation\">(</span>preorder<span class=\"token punctuation\">,</span> preLo <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> preIndex<span class=\"token punctuation\">,</span> inorder<span class=\"token punctuation\">,</span> inLo<span class=\"token punctuation\">,</span> inIndex <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    root<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> <span class=\"token function\">buildTree</span><span class=\"token punctuation\">(</span>preorder<span class=\"token punctuation\">,</span> preIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> preHi<span class=\"token punctuation\">,</span> inorder<span class=\"token punctuation\">,</span> inIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> inHi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> root<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">105. 从前序与中序遍历序列构造二叉树</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>\n<p>注意:<br>    你可以假设树中没有重复的元素。</p>\n<pre><code>例如，给出\n\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>对于前序与中序遍历的数组[lo,hi]:</p>\n<ul>\n<li>前序的根节点是lo,中序的根节点是i</li>\n<li>前序的左子树是[lo+1,i],右子树是[i+1,hi]</li>\n<li>中序的左子树是[lo,i-1],右子树是[i+1,hi]</li>\n</ul>\n<p>由此,可以先构造根节点,然后根据前序中序的左右数组构造他的左右节点,一直不断递归下去…</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意几次递归后前序,中序数组可能不是上下对称的,所以他们索引index得区分为preIndex,inIndex</li>\n<li>用map存储可以加快速度</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">/**\n * look 用map存储加快速度\n树中没有重复元素\n用map存储inorder数组的值和对应索引\n 方便找到根节点位置\n */\nprivate Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n\npublic TreeNode buildTree(int[] preorder, int[] inorder)\n{\n    for (int i = 0; i &lt; inorder.length; i++)\n    {\n        map.put(inorder[i], i);\n    }\n    return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);\n}\n\nprivate TreeNode buildTree(int[] preorder, int preLo, int preHi, int[] inorder, int inLo, int inHi)\n{\n    if (preLo &gt; preHi || inLo &gt; inHi)\n    {\n        return null;\n    }\n    //找到根节点在中序遍历的索引位置\n    int inIndex = map.get(preorder[preLo]);\n    //look,i在经过几次之后,只是对应了inorder的i,但是对于preorder,应该只是一个偏移量\n    //inIndex - inLo代表左子树的个数,preIndex则是前序遍历左子树的最后一个元素\n    int preIndex = preLo + inIndex - inLo;\n    TreeNode root = new TreeNode(preorder[preLo]);\n    root.left = buildTree(preorder, preLo + 1, preIndex, inorder, inLo, inIndex - 1);\n    root.right = buildTree(preorder, preIndex + 1, preHi, inorder, inIndex + 1, inHi);\n    return root;\n}</code></pre>\n"},{"title":"LeetCode刷题笔记11","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"1cac8294","date":"2020-03-24T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n说明：你不能倾斜容器，且 n 的值至少为 2。\n\n \n\n**示例：**\n\n```\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n```\n\n# 思路\n\n面积=底*高.显然首尾元素的底最大。所以可以从首尾不断的缩小，找出最大值.\n\n缩小可以让高度较小的那条边缩小，就不会漏掉解\n\n```java\nlo=0,hi=n-1;\nresult=0;\nwhile(lo<hi)\n{\n    result=max(result,(hi-lo)*min(nums[lo],nums[hi]));\n    if(nums[lo]>nums[hi]) --hi;\n    else ++lo;\n}\n```\n\n\n\n# 细节\n\n可以进行优化,即选择了小的那个支柱后，往内侧寻找，可以采用while循环的方式。如果都是小于等于支柱的高，就一直循环（注意边界），节省开销。\n\n\n# 代码\n\n```java\npublic int maxArea(int[] height)\n{\n    int n = height.length;\n    int lo = 0, hi = n - 1;\n    int result = 0;\n    while (lo < hi)//lo==hi的话，只有一个，是没有面积的\n    {\n        result = Math.max(result, (hi - lo) * Math.min(height[lo], height[hi]));\n        if (height[lo] > height[hi]) //右边是短板\n        {\n            //因为底不断变小,所以高小于支柱的可以都淘汰\n            int temp = height[hi];\n            //必须先强制-1,不然可能死循环 高相等的总面积也小\n            //不会越界,最多减小到lo\n            while (--hi>lo && height[hi]<=temp);\n        }\n        else\n        {\n            int temp = height[lo];\n            while(++lo<hi && height[lo]<=temp);\n        }\n\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$ O（N) $ \n\n## 空间复杂度\n\n$ O(1) $","source":"_posts/LeetCode笔记/LeetCode刷题笔记_11_盛最多水的容器.md","raw":"---\ntitle: LeetCode刷题笔记11\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 算法\nabbrlink: 1cac8294\ndate: 2020-03-25 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n说明：你不能倾斜容器，且 n 的值至少为 2。\n\n \n\n**示例：**\n\n```\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n```\n\n# 思路\n\n面积=底*高.显然首尾元素的底最大。所以可以从首尾不断的缩小，找出最大值.\n\n缩小可以让高度较小的那条边缩小，就不会漏掉解\n\n```java\nlo=0,hi=n-1;\nresult=0;\nwhile(lo<hi)\n{\n    result=max(result,(hi-lo)*min(nums[lo],nums[hi]));\n    if(nums[lo]>nums[hi]) --hi;\n    else ++lo;\n}\n```\n\n\n\n# 细节\n\n可以进行优化,即选择了小的那个支柱后，往内侧寻找，可以采用while循环的方式。如果都是小于等于支柱的高，就一直循环（注意边界），节省开销。\n\n\n# 代码\n\n```java\npublic int maxArea(int[] height)\n{\n    int n = height.length;\n    int lo = 0, hi = n - 1;\n    int result = 0;\n    while (lo < hi)//lo==hi的话，只有一个，是没有面积的\n    {\n        result = Math.max(result, (hi - lo) * Math.min(height[lo], height[hi]));\n        if (height[lo] > height[hi]) //右边是短板\n        {\n            //因为底不断变小,所以高小于支柱的可以都淘汰\n            int temp = height[hi];\n            //必须先强制-1,不然可能死循环 高相等的总面积也小\n            //不会越界,最多减小到lo\n            while (--hi>lo && height[hi]<=temp);\n        }\n        else\n        {\n            int temp = height[lo];\n            while(++lo<hi && height[lo]<=temp);\n        }\n\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$ O（N) $ \n\n## 空间复杂度\n\n$ O(1) $","slug":"LeetCode笔记/LeetCode刷题笔记_11_盛最多水的容器","published":1,"updated":"2020-11-12T11:57:29.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xo004pjotp7edygz15","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/container-with-most-water/\" target=\"_blank\" rel=\"noopener\">11. 盛最多水的容器</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>\n<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>\n<p><strong>示例：</strong></p>\n<pre><code>输入：[1,8,6,2,5,4,8,3,7]\n输出：49</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>面积=底*高.显然首尾元素的底最大。所以可以从首尾不断的缩小，找出最大值.</p>\n<p>缩小可以让高度较小的那条边缩小，就不会漏掉解</p>\n<pre class=\" language-java\"><code class=\"language-java\">lo<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>hi<span class=\"token operator\">=</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nresult<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">&lt;</span>hi<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    result<span class=\"token operator\">=</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span>hi<span class=\"token operator\">-</span>lo<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">--</span>hi<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token operator\">++</span>lo<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>可以进行优化,即选择了小的那个支柱后，往内侧寻找，可以采用while循环的方式。如果都是小于等于支柱的高，就一直循环（注意边界），节省开销。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxArea</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> height<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> height<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> lo <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> hi <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>lo <span class=\"token operator\">&lt;</span> hi<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//lo==hi的话，只有一个，是没有面积的</span>\n    <span class=\"token punctuation\">{</span>\n        result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>hi <span class=\"token operator\">-</span> lo<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>height<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>height<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> height<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//右边是短板</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//因为底不断变小,所以高小于支柱的可以都淘汰</span>\n            <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> height<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//必须先强制-1,不然可能死循环 高相等的总面积也小</span>\n            <span class=\"token comment\" spellcheck=\"true\">//不会越界,最多减小到lo</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">--</span>hi<span class=\"token operator\">></span>lo <span class=\"token operator\">&amp;&amp;</span> height<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;=</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> height<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>lo<span class=\"token operator\">&lt;</span>hi <span class=\"token operator\">&amp;&amp;</span> height<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;=</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$ O（N) $ </p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$ O(1) $</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/container-with-most-water/\" target=\"_blank\" rel=\"noopener\">11. 盛最多水的容器</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>\n<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>\n<p><strong>示例：</strong></p>\n<pre><code>输入：[1,8,6,2,5,4,8,3,7]\n输出：49</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>面积=底*高.显然首尾元素的底最大。所以可以从首尾不断的缩小，找出最大值.</p>\n<p>缩小可以让高度较小的那条边缩小，就不会漏掉解</p>\n<pre><code class=\"java\">lo=0,hi=n-1;\nresult=0;\nwhile(lo&lt;hi)\n{\n    result=max(result,(hi-lo)*min(nums[lo],nums[hi]));\n    if(nums[lo]&gt;nums[hi]) --hi;\n    else ++lo;\n}</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>可以进行优化,即选择了小的那个支柱后，往内侧寻找，可以采用while循环的方式。如果都是小于等于支柱的高，就一直循环（注意边界），节省开销。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int maxArea(int[] height)\n{\n    int n = height.length;\n    int lo = 0, hi = n - 1;\n    int result = 0;\n    while (lo &lt; hi)//lo==hi的话，只有一个，是没有面积的\n    {\n        result = Math.max(result, (hi - lo) * Math.min(height[lo], height[hi]));\n        if (height[lo] &gt; height[hi]) //右边是短板\n        {\n            //因为底不断变小,所以高小于支柱的可以都淘汰\n            int temp = height[hi];\n            //必须先强制-1,不然可能死循环 高相等的总面积也小\n            //不会越界,最多减小到lo\n            while (--hi&gt;lo &amp;&amp; height[hi]&lt;=temp);\n        }\n        else\n        {\n            int temp = height[lo];\n            while(++lo&lt;hi &amp;&amp; height[lo]&lt;=temp);\n        }\n\n    }\n    return result;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$ O（N) $ </p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$ O(1) $</p>\n"},{"title":"LeetCode刷题笔记121","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"5f8f47ab","date":"2020-05-28T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n\n注意：你不能在买入股票前卖出股票。\n\n \n\n示例 1:\n```\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n示例 2:\n```\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n# 思路\n\n\n\n\n\n```java\n动态规划:\n\nsell[i]:代表第i天卖出得到的最大利润\n\nbuy[i]:代表第i天买入的最大利润\n\nsell[i] = max(0,price[i] - buy[i-1])\n\nbuy[i] = max(-price[i],buy[i-1])\n\n初始化:buy[0]=-price[0],sell[0]=0\n\n结果:result=max(result,sell[i])\n```\n\n\n\n# 细节\n\n都可以节约空间,减少一个维度\n\n\n# 代码\n\n```java\n//无化简的动态规划\npublic int maxProfit(int[] prices)\n{\n    int N = prices.length;\n    if (N == 0)\n    {\n        return 0;\n    }\n    int[] buy = new int[N];\n    int[] sell = new int[N];\n    int result = 0;\n\n    buy[0] = -prices[0];\n    sell[0] = 0;\n\n    for (int i = 1; i < N; i++)\n    {\n        buy[i] = Math.max(-prices[i], buy[i - 1]);\n        //look,是+,不是-,因为buy[i]是负数\n        sell[i] = Math.max(0, prices[i] + buy[i - 1]);\n        result = Math.max(result, sell[i]);\n    }\n    return result;\n}\n\n//节约空间\npublic int maxProfit(int[] prices)\n{\n    int N = prices.length;\n    if (N == 0) return 0;\n    int buy=-prices[0],sell=0,result = 0;\n    for (int i = 1; i < N; i++)\n    {\n        sell = Math.max(0, prices[i] + buy);\n        buy = Math.max(-prices[i], buy);\n        result = Math.max(result, sell);\n    }\n    return result;\n}\n```\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_121. 买卖股票的最佳时机.md","raw":"---\ntitle: LeetCode刷题笔记121\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 数组\n  - 动态规划\nabbrlink: 5f8f47ab\ndate: 2020-05-29 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n\n注意：你不能在买入股票前卖出股票。\n\n \n\n示例 1:\n```\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n示例 2:\n```\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n# 思路\n\n\n\n\n\n```java\n动态规划:\n\nsell[i]:代表第i天卖出得到的最大利润\n\nbuy[i]:代表第i天买入的最大利润\n\nsell[i] = max(0,price[i] - buy[i-1])\n\nbuy[i] = max(-price[i],buy[i-1])\n\n初始化:buy[0]=-price[0],sell[0]=0\n\n结果:result=max(result,sell[i])\n```\n\n\n\n# 细节\n\n都可以节约空间,减少一个维度\n\n\n# 代码\n\n```java\n//无化简的动态规划\npublic int maxProfit(int[] prices)\n{\n    int N = prices.length;\n    if (N == 0)\n    {\n        return 0;\n    }\n    int[] buy = new int[N];\n    int[] sell = new int[N];\n    int result = 0;\n\n    buy[0] = -prices[0];\n    sell[0] = 0;\n\n    for (int i = 1; i < N; i++)\n    {\n        buy[i] = Math.max(-prices[i], buy[i - 1]);\n        //look,是+,不是-,因为buy[i]是负数\n        sell[i] = Math.max(0, prices[i] + buy[i - 1]);\n        result = Math.max(result, sell[i]);\n    }\n    return result;\n}\n\n//节约空间\npublic int maxProfit(int[] prices)\n{\n    int N = prices.length;\n    if (N == 0) return 0;\n    int buy=-prices[0],sell=0,result = 0;\n    for (int i = 1; i < N; i++)\n    {\n        sell = Math.max(0, prices[i] + buy);\n        buy = Math.max(-prices[i], buy);\n        result = Math.max(result, sell);\n    }\n    return result;\n}\n```\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_121. 买卖股票的最佳时机","published":1,"updated":"2020-11-12T11:57:29.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xq004tjotp6qwghwnk","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"noopener\">121. 买卖股票的最佳时机</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>\n<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>\n<p>注意：你不能在买入股票前卖出股票。</p>\n<p> </p>\n<p>示例 1:</p>\n<pre><code>输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre class=\" language-java\"><code class=\"language-java\">动态规划<span class=\"token operator\">:</span>\n\nsell<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span>代表第i天卖出得到的最大利润\n\nbuy<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span>代表第i天买入的最大利润\n\nsell<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>price<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> buy<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\nbuy<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>price<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>buy<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n初始化<span class=\"token operator\">:</span>buy<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token operator\">-</span>price<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>sell<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>\n\n结果<span class=\"token operator\">:</span>result<span class=\"token operator\">=</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span>sell<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>都可以节约空间,减少一个维度</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//无化简的动态规划</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxProfit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> prices<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> prices<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>N <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> sell <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    buy<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>prices<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    sell<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        buy<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>prices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> buy<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//look,是+,不是-,因为buy[i]是负数</span>\n        sell<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> prices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> buy<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> sell<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//节约空间</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxProfit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> prices<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> prices<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>N <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> buy<span class=\"token operator\">=</span><span class=\"token operator\">-</span>prices<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>sell<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        sell <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> prices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> buy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        buy <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>prices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> buy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> sell<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"noopener\">121. 买卖股票的最佳时机</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>\n<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>\n<p>注意：你不能在买入股票前卖出股票。</p>\n<p> </p>\n<p>示例 1:</p>\n<pre><code>输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code class=\"java\">动态规划:\n\nsell[i]:代表第i天卖出得到的最大利润\n\nbuy[i]:代表第i天买入的最大利润\n\nsell[i] = max(0,price[i] - buy[i-1])\n\nbuy[i] = max(-price[i],buy[i-1])\n\n初始化:buy[0]=-price[0],sell[0]=0\n\n结果:result=max(result,sell[i])</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>都可以节约空间,减少一个维度</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">//无化简的动态规划\npublic int maxProfit(int[] prices)\n{\n    int N = prices.length;\n    if (N == 0)\n    {\n        return 0;\n    }\n    int[] buy = new int[N];\n    int[] sell = new int[N];\n    int result = 0;\n\n    buy[0] = -prices[0];\n    sell[0] = 0;\n\n    for (int i = 1; i &lt; N; i++)\n    {\n        buy[i] = Math.max(-prices[i], buy[i - 1]);\n        //look,是+,不是-,因为buy[i]是负数\n        sell[i] = Math.max(0, prices[i] + buy[i - 1]);\n        result = Math.max(result, sell[i]);\n    }\n    return result;\n}\n\n//节约空间\npublic int maxProfit(int[] prices)\n{\n    int N = prices.length;\n    if (N == 0) return 0;\n    int buy=-prices[0],sell=0,result = 0;\n    for (int i = 1; i &lt; N; i++)\n    {\n        sell = Math.max(0, prices[i] + buy);\n        buy = Math.max(-prices[i], buy);\n        result = Math.max(result, sell);\n    }\n    return result;\n}</code></pre>\n"},{"title":"LeetCode刷题笔记139","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"484ffed8","date":"2020-05-31T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  139.单词拆分\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n说明：\n\n拆分时可以重复使用字典中的单词。\n\t\t你可以假设字典中没有重复的单词。\n示例 1：\n\n```\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n```\n示例 2：\n```\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。\n     注意你可以重复使用字典中的单词。\n```\n示例 3：\n```\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n```\n\n# 思路\n\n```\n动态规划\ndp[i]代表s.substring(0,i)能否被表示\ndp[0]=true\nreturn dp[s.length()]\ndp[i]=\n\tfor j in [0,i):\n\t\t只要包含了一个(前一部分存在,剩下的那个单词在wordDict中)\n\t\t\n```\n\n\n\n\n\n# 代码\n\n```\npublic boolean wordBreak(String s, List<String> wordDict)\n{\n    if(s==null || s.length()==0) return false;\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 0; i < dp.length; i++)\n    {\n        for (int j = 0; j < i; j++)\n        {\n            if (dp[j] && wordDict.contains(s.substring(j, i)))\n            {\n                dp[i] = true;\n                break;//look 找到一个即可,不用继续找了\n            }\n        }\n    }\n    return dp[s.length()];\n}\n```\n\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_139. 单词拆分.md","raw":"---\ntitle: LeetCode刷题笔记139\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 字符串\n  - 动态规划\nabbrlink: 484ffed8\ndate: 2020-06-01 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  139.单词拆分\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n说明：\n\n拆分时可以重复使用字典中的单词。\n\t\t你可以假设字典中没有重复的单词。\n示例 1：\n\n```\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n```\n示例 2：\n```\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。\n     注意你可以重复使用字典中的单词。\n```\n示例 3：\n```\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n```\n\n# 思路\n\n```\n动态规划\ndp[i]代表s.substring(0,i)能否被表示\ndp[0]=true\nreturn dp[s.length()]\ndp[i]=\n\tfor j in [0,i):\n\t\t只要包含了一个(前一部分存在,剩下的那个单词在wordDict中)\n\t\t\n```\n\n\n\n\n\n# 代码\n\n```\npublic boolean wordBreak(String s, List<String> wordDict)\n{\n    if(s==null || s.length()==0) return false;\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 0; i < dp.length; i++)\n    {\n        for (int j = 0; j < i; j++)\n        {\n            if (dp[j] && wordDict.contains(s.substring(j, i)))\n            {\n                dp[i] = true;\n                break;//look 找到一个即可,不用继续找了\n            }\n        }\n    }\n    return dp[s.length()];\n}\n```\n\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_139. 单词拆分","published":1,"updated":"2020-11-12T11:57:29.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xr004wjotp6rc60cuy","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> 139.单词拆分</p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>\n<p>说明：</p>\n<p>拆分时可以重复使用字典中的单词。<br>        你可以假设字典中没有重复的单词。<br>示例 1：</p>\n<pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]\n输出: true\n解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</code></pre>\n<p>示例 2：</p>\n<pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]\n输出: true\n解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。\n     注意你可以重复使用字典中的单词。</code></pre>\n<p>示例 3：</p>\n<pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]\n输出: false</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code>动态规划\ndp[i]代表s.substring(0,i)能否被表示\ndp[0]=true\nreturn dp[s.length()]\ndp[i]=\n    for j in [0,i):\n        只要包含了一个(前一部分存在,剩下的那个单词在wordDict中)\n</code></pre>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code>public boolean wordBreak(String s, List&lt;String&gt; wordDict)\n{\n    if(s==null || s.length()==0) return false;\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 0; i &lt; dp.length; i++)\n    {\n        for (int j = 0; j &lt; i; j++)\n        {\n            if (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i)))\n            {\n                dp[i] = true;\n                break;//look 找到一个即可,不用继续找了\n            }\n        }\n    }\n    return dp[s.length()];\n}</code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> 139.单词拆分</p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>\n<p>说明：</p>\n<p>拆分时可以重复使用字典中的单词。<br>        你可以假设字典中没有重复的单词。<br>示例 1：</p>\n<pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]\n输出: true\n解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</code></pre>\n<p>示例 2：</p>\n<pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]\n输出: true\n解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。\n     注意你可以重复使用字典中的单词。</code></pre>\n<p>示例 3：</p>\n<pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]\n输出: false</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code>动态规划\ndp[i]代表s.substring(0,i)能否被表示\ndp[0]=true\nreturn dp[s.length()]\ndp[i]=\n    for j in [0,i):\n        只要包含了一个(前一部分存在,剩下的那个单词在wordDict中)\n</code></pre>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code>public boolean wordBreak(String s, List&lt;String&gt; wordDict)\n{\n    if(s==null || s.length()==0) return false;\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 0; i &lt; dp.length; i++)\n    {\n        for (int j = 0; j &lt; i; j++)\n        {\n            if (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i)))\n            {\n                dp[i] = true;\n                break;//look 找到一个即可,不用继续找了\n            }\n        }\n    }\n    return dp[s.length()];\n}</code></pre>\n"},{"title":"LeetCode刷题笔记136","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"d8f0e349","date":"2020-05-30T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n示例 1:\n```\n输入: [2,2,1]\n输出: 1\n```\n示例 2:\n```\n输入: [4,1,2,1,2]\n输出: 4\n```\n\n\n# 思路\n因为一个数对同一个数异或两次会得到原本的结果，所以对数组循环遍历一遍，对每一个数进行异或，就会得到单独剩下的那个数。\n\n\n# 代码\n\n\n\n```java\npublic int singleNumber(int[] nums)\n{\n    if(nums.length==0) throw new IllegalArgumentException();\n    int result = nums[0];\n    for (int i = 1; i < nums.length; i++) result ^= nums[i];\n    return result;\n}\n```","source":"_posts/LeetCode笔记/LeetCode刷题笔记_136. 只出现一次的数字.md","raw":"---\ntitle: LeetCode刷题笔记136\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 数组\n  - 异或\nabbrlink: d8f0e349\ndate: 2020-05-31 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n示例 1:\n```\n输入: [2,2,1]\n输出: 1\n```\n示例 2:\n```\n输入: [4,1,2,1,2]\n输出: 4\n```\n\n\n# 思路\n因为一个数对同一个数异或两次会得到原本的结果，所以对数组循环遍历一遍，对每一个数进行异或，就会得到单独剩下的那个数。\n\n\n# 代码\n\n\n\n```java\npublic int singleNumber(int[] nums)\n{\n    if(nums.length==0) throw new IllegalArgumentException();\n    int result = nums[0];\n    for (int i = 1; i < nums.length; i++) result ^= nums[i];\n    return result;\n}\n```","slug":"LeetCode笔记/LeetCode刷题笔记_136. 只出现一次的数字","published":1,"updated":"2020-11-12T11:57:29.395Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xt0050jotp1q5i10um","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/single-number/\" target=\"_blank\" rel=\"noopener\">136. 只出现一次的数字</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n<p>说明：</p>\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n<p>示例 1:</p>\n<pre><code>输入: [2,2,1]\n输出: 1</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: [4,1,2,1,2]\n输出: 4</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>因为一个数对同一个数异或两次会得到原本的结果，所以对数组循环遍历一遍，对每一个数进行异或，就会得到单独剩下的那个数。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">singleNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> result <span class=\"token operator\">^=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/single-number/\" target=\"_blank\" rel=\"noopener\">136. 只出现一次的数字</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n<p>说明：</p>\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n<p>示例 1:</p>\n<pre><code>输入: [2,2,1]\n输出: 1</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: [4,1,2,1,2]\n输出: 4</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>因为一个数对同一个数异或两次会得到原本的结果，所以对数组循环遍历一遍，对每一个数进行异或，就会得到单独剩下的那个数。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int singleNumber(int[] nums)\n{\n    if(nums.length==0) throw new IllegalArgumentException();\n    int result = nums[0];\n    for (int i = 1; i &lt; nums.length; i++) result ^= nums[i];\n    return result;\n}</code></pre>\n"},{"title":"LeetCode刷题笔记146","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"97b1758e","date":"2020-06-05T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> 146. LRU缓存机制\n>\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。\n\n获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。\n写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n \n\n进阶:\n\n你是否可以在 O(1) 时间复杂度内完成这两种操作？\n\n \n\n示例:\n\n```\n\nLRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得关键字 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得关键字 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4\n```\n\n# 思路\n\n1. 可以使用`LinkedHashMap`,已经封装好了方法,只需要重写`removeEldestEntry`方法即可\n2. 自己实现逻辑,则使用双向链表与哈希表结合,其实就是上述1方法的具体实现方式\n\n# 细节\n\n# 代码\n\n```java\npublic class LRUCache\n{\n    private Map<Integer, Node> map;//存储的是key,Node\n    DoubleList cache;//用于保证删除是O(1)\n    private int capacity;\n\n    private class Node\n    {\n        int key;\n        int value;\n        Node next;\n        Node pre;\n\n        Node(int key, int value)\n        {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    private class DoubleList\n    {\n        Node first;//头尾虚节点\n        Node last;\n        int size;\n\n        DoubleList()\n        {\n            first = new Node(0, 0);\n            last = new Node(0, 0);\n            first.next = last;\n            last.pre = first;\n            size = 0;\n        }\n\n        void addFirst(Node node)\n        {\n            node.pre=first;\n            node.next=first.next;\n            first.next.pre=node;\n            first.next=node;\n            ++size;\n        }\n\n        Node remove(Node node)\n        {\n\n            node.pre.next = node.next;\n            node.next.pre = node.pre;\n\n            node.pre = null;\n            node.next = null;\n\n            --size;\n\n            return node;\n        }\n\n        Node removeLast()\n        {\n            if(size==0) return null;\n            return remove(last.pre);\n        }\n\n\n    }\n\n    public LRUCache(int capacity)\n    {\n        this.map = new HashMap<>();\n        this.cache = new DoubleList();\n        this.capacity = capacity;\n    }\n\n    public int get(int key)\n    {\n        if (!map.containsKey(key)) return -1;\n        int value = map.get(key).value;\n        put(key, value);\n        return value;\n    }\n\n    public void put(int key, int value)\n    {\n        Node node = new Node(key, value);\n        if (map.containsKey(key))\n        {\n            cache.remove(map.get(key));\n            cache.addFirst(node);\n        }\n        else\n        {\n            if (capacity == cache.size)\n            {\n                Node last = cache.removeLast();\n                map.remove(last.key);//这是为什么Node要存key,val,不能只存val\n            }\n            cache.addFirst(node);\n        }\n        map.put(key, node);\n    }\n}\n```\n\n```java\n/**\n调用库的实现方法\n\nLinkedHashMap<Integer, Integer>\n它是一个将所有Entry节点链入一个双向链表的HashMap\n此外，LinkedHashMap可以很好的支持LRU算法\n它额外维护了一个双向链表用于保持迭代顺序,该迭代顺序可以是插入顺序，也可以是访问顺序。\n * @author 12549\n */\npublic class LRUCache extends LinkedHashMap<Integer, Integer>\n{\n    private Integer capacity;\n    /*\n    当accessOrder标志位为true时，表示双向链表中的元素按照访问的先后顺序排列\n    当标志位accessOrder的值为false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序\n    当我们要用LinkedHashMap实现LRU算法时，就需要调用该构造方法并将accessOrder置为true。\n    当accessOrder为true时，get方法和put方法都会调用recordAccess方法使得最近使用的Entry移到双向链表的末尾\n     */\n\n    public LRUCache(int capacity)\n    {\n        super(capacity,0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key)\n    {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value)\n    {\n        super.put(key, value);\n    }\n\n    /*\n    该方法是用来被重写的，一般地，如果用LinkedHashMap实现LRU算法，就要重写该方法。\n    比如可以将该方法覆写为如果设定的内存已满，则返回true，\n    这样当再次向LinkedHashMap中putEntry时，\n    在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）。\n     */\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest)\n    {\n        return size()>capacity;\n    }\n}\n```","source":"_posts/LeetCode笔记/LeetCode刷题笔记_146. LRU缓存机制.md","raw":"---\ntitle: LeetCode刷题笔记146\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Map\n  - LRU\nabbrlink: 97b1758e\ndate: 2020-06-06 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> 146. LRU缓存机制\n>\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。\n\n获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。\n写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n \n\n进阶:\n\n你是否可以在 O(1) 时间复杂度内完成这两种操作？\n\n \n\n示例:\n\n```\n\nLRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得关键字 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得关键字 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4\n```\n\n# 思路\n\n1. 可以使用`LinkedHashMap`,已经封装好了方法,只需要重写`removeEldestEntry`方法即可\n2. 自己实现逻辑,则使用双向链表与哈希表结合,其实就是上述1方法的具体实现方式\n\n# 细节\n\n# 代码\n\n```java\npublic class LRUCache\n{\n    private Map<Integer, Node> map;//存储的是key,Node\n    DoubleList cache;//用于保证删除是O(1)\n    private int capacity;\n\n    private class Node\n    {\n        int key;\n        int value;\n        Node next;\n        Node pre;\n\n        Node(int key, int value)\n        {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    private class DoubleList\n    {\n        Node first;//头尾虚节点\n        Node last;\n        int size;\n\n        DoubleList()\n        {\n            first = new Node(0, 0);\n            last = new Node(0, 0);\n            first.next = last;\n            last.pre = first;\n            size = 0;\n        }\n\n        void addFirst(Node node)\n        {\n            node.pre=first;\n            node.next=first.next;\n            first.next.pre=node;\n            first.next=node;\n            ++size;\n        }\n\n        Node remove(Node node)\n        {\n\n            node.pre.next = node.next;\n            node.next.pre = node.pre;\n\n            node.pre = null;\n            node.next = null;\n\n            --size;\n\n            return node;\n        }\n\n        Node removeLast()\n        {\n            if(size==0) return null;\n            return remove(last.pre);\n        }\n\n\n    }\n\n    public LRUCache(int capacity)\n    {\n        this.map = new HashMap<>();\n        this.cache = new DoubleList();\n        this.capacity = capacity;\n    }\n\n    public int get(int key)\n    {\n        if (!map.containsKey(key)) return -1;\n        int value = map.get(key).value;\n        put(key, value);\n        return value;\n    }\n\n    public void put(int key, int value)\n    {\n        Node node = new Node(key, value);\n        if (map.containsKey(key))\n        {\n            cache.remove(map.get(key));\n            cache.addFirst(node);\n        }\n        else\n        {\n            if (capacity == cache.size)\n            {\n                Node last = cache.removeLast();\n                map.remove(last.key);//这是为什么Node要存key,val,不能只存val\n            }\n            cache.addFirst(node);\n        }\n        map.put(key, node);\n    }\n}\n```\n\n```java\n/**\n调用库的实现方法\n\nLinkedHashMap<Integer, Integer>\n它是一个将所有Entry节点链入一个双向链表的HashMap\n此外，LinkedHashMap可以很好的支持LRU算法\n它额外维护了一个双向链表用于保持迭代顺序,该迭代顺序可以是插入顺序，也可以是访问顺序。\n * @author 12549\n */\npublic class LRUCache extends LinkedHashMap<Integer, Integer>\n{\n    private Integer capacity;\n    /*\n    当accessOrder标志位为true时，表示双向链表中的元素按照访问的先后顺序排列\n    当标志位accessOrder的值为false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序\n    当我们要用LinkedHashMap实现LRU算法时，就需要调用该构造方法并将accessOrder置为true。\n    当accessOrder为true时，get方法和put方法都会调用recordAccess方法使得最近使用的Entry移到双向链表的末尾\n     */\n\n    public LRUCache(int capacity)\n    {\n        super(capacity,0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key)\n    {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value)\n    {\n        super.put(key, value);\n    }\n\n    /*\n    该方法是用来被重写的，一般地，如果用LinkedHashMap实现LRU算法，就要重写该方法。\n    比如可以将该方法覆写为如果设定的内存已满，则返回true，\n    这样当再次向LinkedHashMap中putEntry时，\n    在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）。\n     */\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest)\n    {\n        return size()>capacity;\n    }\n}\n```","slug":"LeetCode笔记/LeetCode刷题笔记_146. LRU缓存机制","published":1,"updated":"2020-11-12T11:57:29.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xu0053jotpfaib5lvq","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<ol start=\"146\">\n<li>LRU缓存机制</li>\n</ol>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>\n<p>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>\n<p>进阶:</p>\n<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>\n<p>示例:</p>\n<pre><code>\nLRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得关键字 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得关键字 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ol>\n<li>可以使用<code>LinkedHashMap</code>,已经封装好了方法,只需要重写<code>removeEldestEntry</code>方法即可</li>\n<li>自己实现逻辑,则使用双向链表与哈希表结合,其实就是上述1方法的具体实现方式</li>\n</ol>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LRUCache</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Node<span class=\"token operator\">></span> map<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//存储的是key,Node</span>\n    DoubleList cache<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//用于保证删除是O(1)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> key<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span>\n        Node next<span class=\"token punctuation\">;</span>\n        Node pre<span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DoubleList</span>\n    <span class=\"token punctuation\">{</span>\n        Node first<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//头尾虚节点</span>\n        Node last<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">DoubleList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            first <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            last <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            first<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> last<span class=\"token punctuation\">;</span>\n            last<span class=\"token punctuation\">.</span>pre <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span>\n            size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">void</span> <span class=\"token function\">addFirst</span><span class=\"token punctuation\">(</span>Node node<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            node<span class=\"token punctuation\">.</span>pre<span class=\"token operator\">=</span>first<span class=\"token punctuation\">;</span>\n            node<span class=\"token punctuation\">.</span>next<span class=\"token operator\">=</span>first<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            first<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>pre<span class=\"token operator\">=</span>node<span class=\"token punctuation\">;</span>\n            first<span class=\"token punctuation\">.</span>next<span class=\"token operator\">=</span>node<span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">++</span>size<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        Node <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>Node node<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n\n            node<span class=\"token punctuation\">.</span>pre<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            node<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>pre <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>pre<span class=\"token punctuation\">;</span>\n\n            node<span class=\"token punctuation\">.</span>pre <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n            node<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n            <span class=\"token operator\">--</span>size<span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        Node <span class=\"token function\">removeLast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>size<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>last<span class=\"token punctuation\">.</span>pre<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">LRUCache</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>cache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DoubleList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>capacity <span class=\"token operator\">=</span> capacity<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Node node <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            cache<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            cache<span class=\"token punctuation\">.</span><span class=\"token function\">addFirst</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>capacity <span class=\"token operator\">==</span> cache<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                Node last <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">removeLast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                map<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>last<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//这是为什么Node要存key,val,不能只存val</span>\n            <span class=\"token punctuation\">}</span>\n            cache<span class=\"token punctuation\">.</span><span class=\"token function\">addFirst</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n调用库的实现方法\n\nLinkedHashMap&lt;Integer, Integer>\n它是一个将所有Entry节点链入一个双向链表的HashMap\n此外，LinkedHashMap可以很好的支持LRU算法\n它额外维护了一个双向链表用于保持迭代顺序,该迭代顺序可以是插入顺序，也可以是访问顺序。\n * @author 12549\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LRUCache</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">LinkedHashMap</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Integer capacity<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    当accessOrder标志位为true时，表示双向链表中的元素按照访问的先后顺序排列\n    当标志位accessOrder的值为false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序\n    当我们要用LinkedHashMap实现LRU算法时，就需要调用该构造方法并将accessOrder置为true。\n    当accessOrder为true时，get方法和put方法都会调用recordAccess方法使得最近使用的Entry移到双向链表的末尾\n     */</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">LRUCache</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>capacity<span class=\"token punctuation\">,</span><span class=\"token number\">0.75F</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>capacity <span class=\"token operator\">=</span> capacity<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">getOrDefault</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    该方法是用来被重写的，一般地，如果用LinkedHashMap实现LRU算法，就要重写该方法。\n    比如可以将该方法覆写为如果设定的内存已满，则返回true，\n    这样当再次向LinkedHashMap中putEntry时，\n    在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）。\n     */</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">removeEldestEntry</span><span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> eldest<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span>capacity<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<ol start=\"146\">\n<li>LRU缓存机制</li>\n</ol>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>\n<p>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>\n<p>进阶:</p>\n<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>\n<p>示例:</p>\n<pre><code>\nLRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得关键字 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得关键字 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ol>\n<li>可以使用<code>LinkedHashMap</code>,已经封装好了方法,只需要重写<code>removeEldestEntry</code>方法即可</li>\n<li>自己实现逻辑,则使用双向链表与哈希表结合,其实就是上述1方法的具体实现方式</li>\n</ol>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public class LRUCache\n{\n    private Map&lt;Integer, Node&gt; map;//存储的是key,Node\n    DoubleList cache;//用于保证删除是O(1)\n    private int capacity;\n\n    private class Node\n    {\n        int key;\n        int value;\n        Node next;\n        Node pre;\n\n        Node(int key, int value)\n        {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    private class DoubleList\n    {\n        Node first;//头尾虚节点\n        Node last;\n        int size;\n\n        DoubleList()\n        {\n            first = new Node(0, 0);\n            last = new Node(0, 0);\n            first.next = last;\n            last.pre = first;\n            size = 0;\n        }\n\n        void addFirst(Node node)\n        {\n            node.pre=first;\n            node.next=first.next;\n            first.next.pre=node;\n            first.next=node;\n            ++size;\n        }\n\n        Node remove(Node node)\n        {\n\n            node.pre.next = node.next;\n            node.next.pre = node.pre;\n\n            node.pre = null;\n            node.next = null;\n\n            --size;\n\n            return node;\n        }\n\n        Node removeLast()\n        {\n            if(size==0) return null;\n            return remove(last.pre);\n        }\n\n\n    }\n\n    public LRUCache(int capacity)\n    {\n        this.map = new HashMap&lt;&gt;();\n        this.cache = new DoubleList();\n        this.capacity = capacity;\n    }\n\n    public int get(int key)\n    {\n        if (!map.containsKey(key)) return -1;\n        int value = map.get(key).value;\n        put(key, value);\n        return value;\n    }\n\n    public void put(int key, int value)\n    {\n        Node node = new Node(key, value);\n        if (map.containsKey(key))\n        {\n            cache.remove(map.get(key));\n            cache.addFirst(node);\n        }\n        else\n        {\n            if (capacity == cache.size)\n            {\n                Node last = cache.removeLast();\n                map.remove(last.key);//这是为什么Node要存key,val,不能只存val\n            }\n            cache.addFirst(node);\n        }\n        map.put(key, node);\n    }\n}</code></pre>\n<pre><code class=\"java\">/**\n调用库的实现方法\n\nLinkedHashMap&lt;Integer, Integer&gt;\n它是一个将所有Entry节点链入一个双向链表的HashMap\n此外，LinkedHashMap可以很好的支持LRU算法\n它额外维护了一个双向链表用于保持迭代顺序,该迭代顺序可以是插入顺序，也可以是访问顺序。\n * @author 12549\n */\npublic class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;\n{\n    private Integer capacity;\n    /*\n    当accessOrder标志位为true时，表示双向链表中的元素按照访问的先后顺序排列\n    当标志位accessOrder的值为false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序\n    当我们要用LinkedHashMap实现LRU算法时，就需要调用该构造方法并将accessOrder置为true。\n    当accessOrder为true时，get方法和put方法都会调用recordAccess方法使得最近使用的Entry移到双向链表的末尾\n     */\n\n    public LRUCache(int capacity)\n    {\n        super(capacity,0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key)\n    {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value)\n    {\n        super.put(key, value);\n    }\n\n    /*\n    该方法是用来被重写的，一般地，如果用LinkedHashMap实现LRU算法，就要重写该方法。\n    比如可以将该方法覆写为如果设定的内存已满，则返回true，\n    这样当再次向LinkedHashMap中putEntry时，\n    在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）。\n     */\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest)\n    {\n        return size()&gt;capacity;\n    }\n}</code></pre>\n"},{"title":"LeetCode刷题笔记148","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"LeetCode刷题笔记","abbrlink":"70095889","date":"2020-06-07T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> 148. 排序链表\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。\n```\n示例 1:\n\n输入: 4->2->1->3\n输出: 1->2->3->4\n```\n```\n示例 2:\n\n输入: -1->5->3->4->0\n输出: -1->0->3->4->5\n```\n\n# 思路\n\n归并法排序,用循环合并两个有序数组\n\n# 细节\n\n1. fast可以先等于head.next,避免将两条链表断开的麻烦操作\n2. 对一个链表继续递归进行`sortList`时,注意接收传回的引用\n\n# 代码\n\n```java\npublic ListNode sortList(ListNode head)\n{\n    if (head == null || head.next == null) return head;\n\n    //将链表大致平分成head,slow两条\n    //look 先将fast向后移动一位,这样切分单数数组就是前面少一个,后面多一个.切分双数正好相等\n    //而且这样可以减少处理的麻烦\n    ListNode slow = head, fast = head.next;\n    while (fast != null && fast.next != null)\n    {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    ListNode second = slow.next;\n    slow.next = null;//为了断开中点前一个节点与中点之间的连接\n\n\n    head = sortList(head);//look,要接收改变后的链表的引用\n    second = sortList(second);\n\n    //对两条有序链表进行合并操作\n    ListNode pre = new ListNode(-1);\n    ListNode temp = pre;\n\n    while (head != null && second != null)\n    {\n        int value = 0;\n        if (head.val < second.val)\n        {\n            value = head.val;\n            head = head.next;\n        }\n        else\n        {\n            value = second.val;\n            second = second.next;\n        }\n        temp.next = new ListNode(value);\n        temp = temp.next;\n    }\n    temp.next = (head == null ? second : head);\n\n    return pre.next;\n}\n```\n\n\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_148. 排序链表.md","raw":"---\ntitle: LeetCode刷题笔记148\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 链表\n  - 排序\nabbrlink: '70095889'\ndate: 2020-06-08 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> 148. 排序链表\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。\n```\n示例 1:\n\n输入: 4->2->1->3\n输出: 1->2->3->4\n```\n```\n示例 2:\n\n输入: -1->5->3->4->0\n输出: -1->0->3->4->5\n```\n\n# 思路\n\n归并法排序,用循环合并两个有序数组\n\n# 细节\n\n1. fast可以先等于head.next,避免将两条链表断开的麻烦操作\n2. 对一个链表继续递归进行`sortList`时,注意接收传回的引用\n\n# 代码\n\n```java\npublic ListNode sortList(ListNode head)\n{\n    if (head == null || head.next == null) return head;\n\n    //将链表大致平分成head,slow两条\n    //look 先将fast向后移动一位,这样切分单数数组就是前面少一个,后面多一个.切分双数正好相等\n    //而且这样可以减少处理的麻烦\n    ListNode slow = head, fast = head.next;\n    while (fast != null && fast.next != null)\n    {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    ListNode second = slow.next;\n    slow.next = null;//为了断开中点前一个节点与中点之间的连接\n\n\n    head = sortList(head);//look,要接收改变后的链表的引用\n    second = sortList(second);\n\n    //对两条有序链表进行合并操作\n    ListNode pre = new ListNode(-1);\n    ListNode temp = pre;\n\n    while (head != null && second != null)\n    {\n        int value = 0;\n        if (head.val < second.val)\n        {\n            value = head.val;\n            head = head.next;\n        }\n        else\n        {\n            value = second.val;\n            second = second.next;\n        }\n        temp.next = new ListNode(value);\n        temp = temp.next;\n    }\n    temp.next = (head == null ? second : head);\n\n    return pre.next;\n}\n```\n\n\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_148. 排序链表","published":1,"updated":"2020-11-12T11:57:29.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xv0056jotp6o8f92l0","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<ol start=\"148\">\n<li><p>排序链表</p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</li>\n</ol>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>\n<pre><code>示例 1:\n\n输入: 4-&gt;2-&gt;1-&gt;3\n输出: 1-&gt;2-&gt;3-&gt;4</code></pre>\n<pre><code>示例 2:\n\n输入: -1-&gt;5-&gt;3-&gt;4-&gt;0\n输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>归并法排序,用循环合并两个有序数组</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>fast可以先等于head.next,避免将两条链表断开的麻烦操作</li>\n<li>对一个链表继续递归进行<code>sortList</code>时,注意接收传回的引用</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> ListNode <span class=\"token function\">sortList</span><span class=\"token punctuation\">(</span>ListNode head<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> head<span class=\"token punctuation\">.</span>next <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> head<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//将链表大致平分成head,slow两条</span>\n    <span class=\"token comment\" spellcheck=\"true\">//look 先将fast向后移动一位,这样切分单数数组就是前面少一个,后面多一个.切分双数正好相等</span>\n    <span class=\"token comment\" spellcheck=\"true\">//而且这样可以减少处理的麻烦</span>\n    ListNode slow <span class=\"token operator\">=</span> head<span class=\"token punctuation\">,</span> fast <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>fast <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> fast<span class=\"token punctuation\">.</span>next <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    ListNode second <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    slow<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//为了断开中点前一个节点与中点之间的连接</span>\n\n\n    head <span class=\"token operator\">=</span> <span class=\"token function\">sortList</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look,要接收改变后的链表的引用</span>\n    second <span class=\"token operator\">=</span> <span class=\"token function\">sortList</span><span class=\"token punctuation\">(</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//对两条有序链表进行合并操作</span>\n    ListNode pre <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ListNode temp <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>head <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> second <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;</span> second<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            value <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n            head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            value <span class=\"token operator\">=</span> second<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n            second <span class=\"token operator\">=</span> second<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        temp<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        temp <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    temp<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> null <span class=\"token operator\">?</span> second <span class=\"token operator\">:</span> head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> pre<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<ol start=\"148\">\n<li><p>排序链表</p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</li>\n</ol>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>\n<pre><code>示例 1:\n\n输入: 4-&gt;2-&gt;1-&gt;3\n输出: 1-&gt;2-&gt;3-&gt;4</code></pre>\n<pre><code>示例 2:\n\n输入: -1-&gt;5-&gt;3-&gt;4-&gt;0\n输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>归并法排序,用循环合并两个有序数组</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>fast可以先等于head.next,避免将两条链表断开的麻烦操作</li>\n<li>对一个链表继续递归进行<code>sortList</code>时,注意接收传回的引用</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public ListNode sortList(ListNode head)\n{\n    if (head == null || head.next == null) return head;\n\n    //将链表大致平分成head,slow两条\n    //look 先将fast向后移动一位,这样切分单数数组就是前面少一个,后面多一个.切分双数正好相等\n    //而且这样可以减少处理的麻烦\n    ListNode slow = head, fast = head.next;\n    while (fast != null &amp;&amp; fast.next != null)\n    {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    ListNode second = slow.next;\n    slow.next = null;//为了断开中点前一个节点与中点之间的连接\n\n\n    head = sortList(head);//look,要接收改变后的链表的引用\n    second = sortList(second);\n\n    //对两条有序链表进行合并操作\n    ListNode pre = new ListNode(-1);\n    ListNode temp = pre;\n\n    while (head != null &amp;&amp; second != null)\n    {\n        int value = 0;\n        if (head.val &lt; second.val)\n        {\n            value = head.val;\n            head = head.next;\n        }\n        else\n        {\n            value = second.val;\n            second = second.next;\n        }\n        temp.next = new ListNode(value);\n        temp = temp.next;\n    }\n    temp.next = (head == null ? second : head);\n\n    return pre.next;\n}</code></pre>\n"},{"title":"LeetCode刷题笔记142","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"90dcb197","date":"2020-06-03T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n>\n> \n>\n> 其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n说明：不允许修改给定的链表。\n\n \n\n示例 1：\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：tail connects to node index 1\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n示例 2：\n```\n输入：head = [1,2], pos = 0\n输出：tail connects to node index 0\n解释：链表中有一个环，其尾部连接到第一个节点。\n```\n\n示例 3：\n```\n输入：head = [1], pos = -1\n输出：no cycle\n解释：链表中没有环。\n```\n\n\n# 思路\n先让快慢指针相遇,再让一个指针从头开始,与慢指针同时向后走,他们相遇,则到了入口(可通过画图证明正确性)\n# 细节\n\n在判断有没有循环链表的时候就先把没有循环的链表直接返回,避免之后找首节点的逻辑错误\n\n# 代码\n\n```java\npublic ListNode detectCycle(ListNode head)\n{\n    ListNode fast = head, slow = head;\n    while (true)\n    {\n        if(fast == null || fast.next == null) return null;\n        fast = fast.next.next;\n        slow = slow.next;\n        if (slow == fast) break;\n    }\n    //必然有循环\n    fast = head;\n    while (true)\n    {\n        if(slow==fast) return fast;\n        fast = fast.next;\n        slow = slow.next;\n    }\n}\n```\n\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_142. 环形链表 II.md","raw":"---\ntitle: LeetCode刷题笔记142\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 链表\n  - 快慢指针\nabbrlink: 90dcb197\ndate: 2020-06-04 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n>\n> \n>\n> 其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n说明：不允许修改给定的链表。\n\n \n\n示例 1：\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：tail connects to node index 1\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n示例 2：\n```\n输入：head = [1,2], pos = 0\n输出：tail connects to node index 0\n解释：链表中有一个环，其尾部连接到第一个节点。\n```\n\n示例 3：\n```\n输入：head = [1], pos = -1\n输出：no cycle\n解释：链表中没有环。\n```\n\n\n# 思路\n先让快慢指针相遇,再让一个指针从头开始,与慢指针同时向后走,他们相遇,则到了入口(可通过画图证明正确性)\n# 细节\n\n在判断有没有循环链表的时候就先把没有循环的链表直接返回,避免之后找首节点的逻辑错误\n\n# 代码\n\n```java\npublic ListNode detectCycle(ListNode head)\n{\n    ListNode fast = head, slow = head;\n    while (true)\n    {\n        if(fast == null || fast.next == null) return null;\n        fast = fast.next.next;\n        slow = slow.next;\n        if (slow == fast) break;\n    }\n    //必然有循环\n    fast = head;\n    while (true)\n    {\n        if(slow==fast) return fast;\n        fast = fast.next;\n        slow = slow.next;\n    }\n}\n```\n\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_142. 环形链表 II","published":1,"updated":"2020-11-12T11:57:29.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xw0058jotp9e065d7j","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\" target=\"_blank\" rel=\"noopener\">142. 环形链表 II</a></p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>\n<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>\n<p>说明：不允许修改给定的链表。</p>\n<p> </p>\n<p>示例 1：</p>\n<pre><code>输入：head = [3,2,0,-4], pos = 1\n输出：tail connects to node index 1\n解释：链表中有一个环，其尾部连接到第二个节点。</code></pre>\n<p>示例 2：</p>\n<pre><code>输入：head = [1,2], pos = 0\n输出：tail connects to node index 0\n解释：链表中有一个环，其尾部连接到第一个节点。</code></pre>\n<p>示例 3：</p>\n<pre><code>输入：head = [1], pos = -1\n输出：no cycle\n解释：链表中没有环。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>先让快慢指针相遇,再让一个指针从头开始,与慢指针同时向后走,他们相遇,则到了入口(可通过画图证明正确性)</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>在判断有没有循环链表的时候就先把没有循环的链表直接返回,避免之后找首节点的逻辑错误</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> ListNode <span class=\"token function\">detectCycle</span><span class=\"token punctuation\">(</span>ListNode head<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ListNode fast <span class=\"token operator\">=</span> head<span class=\"token punctuation\">,</span> slow <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fast <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> fast<span class=\"token punctuation\">.</span>next <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n        fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>slow <span class=\"token operator\">==</span> fast<span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//必然有循环</span>\n    fast <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>slow<span class=\"token operator\">==</span>fast<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> fast<span class=\"token punctuation\">;</span>\n        fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\" target=\"_blank\" rel=\"noopener\">142. 环形链表 II</a></p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>\n<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>\n<p>说明：不允许修改给定的链表。</p>\n<p> </p>\n<p>示例 1：</p>\n<pre><code>输入：head = [3,2,0,-4], pos = 1\n输出：tail connects to node index 1\n解释：链表中有一个环，其尾部连接到第二个节点。</code></pre>\n<p>示例 2：</p>\n<pre><code>输入：head = [1,2], pos = 0\n输出：tail connects to node index 0\n解释：链表中有一个环，其尾部连接到第一个节点。</code></pre>\n<p>示例 3：</p>\n<pre><code>输入：head = [1], pos = -1\n输出：no cycle\n解释：链表中没有环。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>先让快慢指针相遇,再让一个指针从头开始,与慢指针同时向后走,他们相遇,则到了入口(可通过画图证明正确性)</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>在判断有没有循环链表的时候就先把没有循环的链表直接返回,避免之后找首节点的逻辑错误</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public ListNode detectCycle(ListNode head)\n{\n    ListNode fast = head, slow = head;\n    while (true)\n    {\n        if(fast == null || fast.next == null) return null;\n        fast = fast.next.next;\n        slow = slow.next;\n        if (slow == fast) break;\n    }\n    //必然有循环\n    fast = head;\n    while (true)\n    {\n        if(slow==fast) return fast;\n        fast = fast.next;\n        slow = slow.next;\n    }\n}</code></pre>\n"},{"title":"LeetCode刷题笔记152","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"LeetCode刷题笔记","abbrlink":"89c780d6","date":"2020-06-09T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)\n>\n> \n>\n> 其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n\n \n\n示例 1:\n```\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n```\n示例 2:\n```\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n```\n\n# 思路\n\n```\ndp[i]代表连续子数组乘到i的最大值\nmin[i]代表连续子数组乘到i的最小值\n\nint result=0;\ndp[0]=nums[0]\nmin[0]=nums[0]\nfor i in N:\n    if(nums[i]>0) \n    {\n        dp[i]=nums[i]*max(1,dp[i-1]);//适当时候抛弃前面的\n\t\tmin[i]=min(min[i-1],1)*nums[i];\n    }\n    else\n    {\n        dp[i]=nums[i]*min(min[i-1],1);//适当时候抛弃前面的\n        min[i]=max(dp[i-1],1)*nums[i];\n    }\n    result=max(dp[i],result)\n\n```\n\n```\n//简化后的思路:\n\t\tfor (int i = 1; i < N; i++)\n        {\n            int temp = max;\n            max = Math.max(max * nums[i], Math.max(nums[i] * min, nums[i]));\n            min = Math.min(min * nums[i], Math.min(temp * nums[i], nums[i]));\n            result = Math.max(max, result);\n        }\n```\n\n\n\n# 细节\n\n压缩空间后,记得处理好他们的依赖关系\n\n# 代码\n\n```java\n//经典动态规划\npublic int maxProduct(int[] nums)\n{\n    int N = nums.length;\n    if (N == 0) return 0;\n\n    int[] max = new int[N];\n    int[] min = new int[N];\n\n    int result = nums[0];//注意初始值\n    max[0] = nums[0];\n    min[0] = nums[0];\n\n    for (int i = 1; i < N; i++)\n    {\n        if (nums[i] > 0)\n        {\n            max[i] = nums[i] * Math.max(1, max[i - 1]);//适当时候抛弃前面的\n            min[i] = Math.min(min[i - 1], 1) * nums[i];\n        }\n        else\n        {\n            max[i] = nums[i] * Math.min(min[i - 1], 1);//适当时候抛弃前面的\n            min[i] = Math.max(max[i - 1], 1) * nums[i];\n        }\n        result = Math.max(max[i], result);\n    }\n    return result;\n}\n```\n\n```java\n//压缩空间\npublic int maxProduct(int[] nums)\n{\n    int N = nums.length;\n    if(N==0) return 0;\n    int max = nums[0], min = nums[0], result = nums[0];\n\n    for (int i = 1; i < N; i++)\n    {\n        if (nums[i] > 0)\n        {\n            max = nums[i] * Math.max(1, max);//适当时候抛弃前面的\n            min = Math.min(min, 1) * nums[i];\n        }\n        else\n        {\n            int temp=max;\n            max = nums[i] * Math.min(min, 1);//适当时候抛弃前面的\n            //look,这里min依赖与max[i-1]\n            min = Math.max(temp, 1) * nums[i];\n        }\n    }\n    return result;\n}\n```\n\n```java\n    //压缩空间后进一步简化版本\n    public int maxProduct(int[] nums)\n    {\n        int N = nums.length;\n        if (N == 0) return 0;\n        int max = nums[0], min = nums[0], result = nums[0];\n\n        for (int i = 1; i < N; i++)\n        {\n            int temp = max;\n            max = Math.max(max * nums[i], Math.max(nums[i] * min, nums[i]));\n            min = Math.min(min * nums[i], Math.min(temp * nums[i], nums[i]));\n            result = Math.max(max, result);\n        }\n        return result;\n    }\n```","source":"_posts/LeetCode笔记/LeetCode刷题笔记_152. 乘积最大子数组.md","raw":"---\ntitle: LeetCode刷题笔记152\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 数组\n  - 动态规划\nabbrlink: 89c780d6\ndate: 2020-06-10 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)\n>\n> \n>\n> 其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n\n \n\n示例 1:\n```\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n```\n示例 2:\n```\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n```\n\n# 思路\n\n```\ndp[i]代表连续子数组乘到i的最大值\nmin[i]代表连续子数组乘到i的最小值\n\nint result=0;\ndp[0]=nums[0]\nmin[0]=nums[0]\nfor i in N:\n    if(nums[i]>0) \n    {\n        dp[i]=nums[i]*max(1,dp[i-1]);//适当时候抛弃前面的\n\t\tmin[i]=min(min[i-1],1)*nums[i];\n    }\n    else\n    {\n        dp[i]=nums[i]*min(min[i-1],1);//适当时候抛弃前面的\n        min[i]=max(dp[i-1],1)*nums[i];\n    }\n    result=max(dp[i],result)\n\n```\n\n```\n//简化后的思路:\n\t\tfor (int i = 1; i < N; i++)\n        {\n            int temp = max;\n            max = Math.max(max * nums[i], Math.max(nums[i] * min, nums[i]));\n            min = Math.min(min * nums[i], Math.min(temp * nums[i], nums[i]));\n            result = Math.max(max, result);\n        }\n```\n\n\n\n# 细节\n\n压缩空间后,记得处理好他们的依赖关系\n\n# 代码\n\n```java\n//经典动态规划\npublic int maxProduct(int[] nums)\n{\n    int N = nums.length;\n    if (N == 0) return 0;\n\n    int[] max = new int[N];\n    int[] min = new int[N];\n\n    int result = nums[0];//注意初始值\n    max[0] = nums[0];\n    min[0] = nums[0];\n\n    for (int i = 1; i < N; i++)\n    {\n        if (nums[i] > 0)\n        {\n            max[i] = nums[i] * Math.max(1, max[i - 1]);//适当时候抛弃前面的\n            min[i] = Math.min(min[i - 1], 1) * nums[i];\n        }\n        else\n        {\n            max[i] = nums[i] * Math.min(min[i - 1], 1);//适当时候抛弃前面的\n            min[i] = Math.max(max[i - 1], 1) * nums[i];\n        }\n        result = Math.max(max[i], result);\n    }\n    return result;\n}\n```\n\n```java\n//压缩空间\npublic int maxProduct(int[] nums)\n{\n    int N = nums.length;\n    if(N==0) return 0;\n    int max = nums[0], min = nums[0], result = nums[0];\n\n    for (int i = 1; i < N; i++)\n    {\n        if (nums[i] > 0)\n        {\n            max = nums[i] * Math.max(1, max);//适当时候抛弃前面的\n            min = Math.min(min, 1) * nums[i];\n        }\n        else\n        {\n            int temp=max;\n            max = nums[i] * Math.min(min, 1);//适当时候抛弃前面的\n            //look,这里min依赖与max[i-1]\n            min = Math.max(temp, 1) * nums[i];\n        }\n    }\n    return result;\n}\n```\n\n```java\n    //压缩空间后进一步简化版本\n    public int maxProduct(int[] nums)\n    {\n        int N = nums.length;\n        if (N == 0) return 0;\n        int max = nums[0], min = nums[0], result = nums[0];\n\n        for (int i = 1; i < N; i++)\n        {\n            int temp = max;\n            max = Math.max(max * nums[i], Math.max(nums[i] * min, nums[i]));\n            min = Math.min(min * nums[i], Math.min(temp * nums[i], nums[i]));\n            result = Math.max(max, result);\n        }\n        return result;\n    }\n```","slug":"LeetCode笔记/LeetCode刷题笔记_152. 乘积最大子数组","published":1,"updated":"2020-11-12T11:57:29.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6xy005bjotpg30z87qs","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-product-subarray/\" target=\"_blank\" rel=\"noopener\">152. 乘积最大子数组</a></p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>\n<p> </p>\n<p>示例 1:</p>\n<pre><code>输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code>dp[i]代表连续子数组乘到i的最大值\nmin[i]代表连续子数组乘到i的最小值\n\nint result=0;\ndp[0]=nums[0]\nmin[0]=nums[0]\nfor i in N:\n    if(nums[i]&gt;0) \n    {\n        dp[i]=nums[i]*max(1,dp[i-1]);//适当时候抛弃前面的\n        min[i]=min(min[i-1],1)*nums[i];\n    }\n    else\n    {\n        dp[i]=nums[i]*min(min[i-1],1);//适当时候抛弃前面的\n        min[i]=max(dp[i-1],1)*nums[i];\n    }\n    result=max(dp[i],result)\n</code></pre>\n<pre><code>//简化后的思路:\n        for (int i = 1; i &lt; N; i++)\n        {\n            int temp = max;\n            max = Math.max(max * nums[i], Math.max(nums[i] * min, nums[i]));\n            min = Math.min(min * nums[i], Math.min(temp * nums[i], nums[i]));\n            result = Math.max(max, result);\n        }</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>压缩空间后,记得处理好他们的依赖关系</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//经典动态规划</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxProduct</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>N <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> max <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> min <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//注意初始值</span>\n    max<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    min<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            max<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//适当时候抛弃前面的</span>\n            min<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            max<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//适当时候抛弃前面的</span>\n            min<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//压缩空间</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxProduct</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> min <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> result <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            max <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//适当时候抛弃前面的</span>\n            min <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> temp<span class=\"token operator\">=</span>max<span class=\"token punctuation\">;</span>\n            max <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//适当时候抛弃前面的</span>\n            <span class=\"token comment\" spellcheck=\"true\">//look,这里min依赖与max[i-1]</span>\n            min <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token comment\" spellcheck=\"true\">//压缩空间后进一步简化版本</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxProduct</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>N <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> min <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> result <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> max<span class=\"token punctuation\">;</span>\n            max <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>max <span class=\"token operator\">*</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> min<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            min <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>min <span class=\"token operator\">*</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>temp <span class=\"token operator\">*</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-product-subarray/\" target=\"_blank\" rel=\"noopener\">152. 乘积最大子数组</a></p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>\n<p> </p>\n<p>示例 1:</p>\n<pre><code>输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code>dp[i]代表连续子数组乘到i的最大值\nmin[i]代表连续子数组乘到i的最小值\n\nint result=0;\ndp[0]=nums[0]\nmin[0]=nums[0]\nfor i in N:\n    if(nums[i]&gt;0) \n    {\n        dp[i]=nums[i]*max(1,dp[i-1]);//适当时候抛弃前面的\n        min[i]=min(min[i-1],1)*nums[i];\n    }\n    else\n    {\n        dp[i]=nums[i]*min(min[i-1],1);//适当时候抛弃前面的\n        min[i]=max(dp[i-1],1)*nums[i];\n    }\n    result=max(dp[i],result)\n</code></pre>\n<pre><code>//简化后的思路:\n        for (int i = 1; i &lt; N; i++)\n        {\n            int temp = max;\n            max = Math.max(max * nums[i], Math.max(nums[i] * min, nums[i]));\n            min = Math.min(min * nums[i], Math.min(temp * nums[i], nums[i]));\n            result = Math.max(max, result);\n        }</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>压缩空间后,记得处理好他们的依赖关系</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">//经典动态规划\npublic int maxProduct(int[] nums)\n{\n    int N = nums.length;\n    if (N == 0) return 0;\n\n    int[] max = new int[N];\n    int[] min = new int[N];\n\n    int result = nums[0];//注意初始值\n    max[0] = nums[0];\n    min[0] = nums[0];\n\n    for (int i = 1; i &lt; N; i++)\n    {\n        if (nums[i] &gt; 0)\n        {\n            max[i] = nums[i] * Math.max(1, max[i - 1]);//适当时候抛弃前面的\n            min[i] = Math.min(min[i - 1], 1) * nums[i];\n        }\n        else\n        {\n            max[i] = nums[i] * Math.min(min[i - 1], 1);//适当时候抛弃前面的\n            min[i] = Math.max(max[i - 1], 1) * nums[i];\n        }\n        result = Math.max(max[i], result);\n    }\n    return result;\n}</code></pre>\n<pre><code class=\"java\">//压缩空间\npublic int maxProduct(int[] nums)\n{\n    int N = nums.length;\n    if(N==0) return 0;\n    int max = nums[0], min = nums[0], result = nums[0];\n\n    for (int i = 1; i &lt; N; i++)\n    {\n        if (nums[i] &gt; 0)\n        {\n            max = nums[i] * Math.max(1, max);//适当时候抛弃前面的\n            min = Math.min(min, 1) * nums[i];\n        }\n        else\n        {\n            int temp=max;\n            max = nums[i] * Math.min(min, 1);//适当时候抛弃前面的\n            //look,这里min依赖与max[i-1]\n            min = Math.max(temp, 1) * nums[i];\n        }\n    }\n    return result;\n}</code></pre>\n<pre><code class=\"java\">    //压缩空间后进一步简化版本\n    public int maxProduct(int[] nums)\n    {\n        int N = nums.length;\n        if (N == 0) return 0;\n        int max = nums[0], min = nums[0], result = nums[0];\n\n        for (int i = 1; i &lt; N; i++)\n        {\n            int temp = max;\n            max = Math.max(max * nums[i], Math.max(nums[i] * min, nums[i]));\n            min = Math.min(min * nums[i], Math.min(temp * nums[i], nums[i]));\n            result = Math.max(max, result);\n        }\n        return result;\n    }</code></pre>\n"},{"title":"LeetCode刷题笔记141","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"9d5e02d","date":"2020-06-02T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n```\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n```\n\n```\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n```\n\n提示：\n\n```\n链表中节点的数目范围是 [0, 104]\n-105 <= Node.val <= 105\npos 为 -1 或者链表中的一个 有效索引 。\n```\n\n\n# 代码\n\n```java\npublic boolean hasCycle(ListNode head)\n{\n    ListNode fast = head, slow = head;\n    while(fast!=null && fast.next!=null)\n    {\n        fast = fast.next.next;\n        slow = slow.next;\n        if(fast==slow) return true;\n    }\n    return false;\n}\n```\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_141. 环形链表.md","raw":"---\ntitle: LeetCode刷题笔记141\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 链表\n  - 快慢指针\nabbrlink: 9d5e02d\ndate: 2020-06-03 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n```\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n```\n\n```\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n```\n\n提示：\n\n```\n链表中节点的数目范围是 [0, 104]\n-105 <= Node.val <= 105\npos 为 -1 或者链表中的一个 有效索引 。\n```\n\n\n# 代码\n\n```java\npublic boolean hasCycle(ListNode head)\n{\n    ListNode fast = head, slow = head;\n    while(fast!=null && fast.next!=null)\n    {\n        fast = fast.next.next;\n        slow = slow.next;\n        if(fast==slow) return true;\n    }\n    return false;\n}\n```\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_141. 环形链表","published":1,"updated":"2020-11-12T11:57:29.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6y0005ejotp8ev7cxzl","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\">141. 环形链表</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>\n<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>\n<pre><code>输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。</code></pre>\n<pre><code>输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。</code></pre>\n<pre><code>输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。</code></pre>\n<p>提示：</p>\n<pre><code>链表中节点的数目范围是 [0, 104]\n-105 &lt;= Node.val &lt;= 105\npos 为 -1 或者链表中的一个 有效索引 。</code></pre>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">hasCycle</span><span class=\"token punctuation\">(</span>ListNode head<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ListNode fast <span class=\"token operator\">=</span> head<span class=\"token punctuation\">,</span> slow <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast<span class=\"token operator\">!=</span>null <span class=\"token operator\">&amp;&amp;</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fast<span class=\"token operator\">==</span>slow<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\">141. 环形链表</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>\n<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>\n<pre><code>输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。</code></pre>\n<pre><code>输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。</code></pre>\n<pre><code>输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。</code></pre>\n<p>提示：</p>\n<pre><code>链表中节点的数目范围是 [0, 104]\n-105 &lt;= Node.val &lt;= 105\npos 为 -1 或者链表中的一个 有效索引 。</code></pre>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public boolean hasCycle(ListNode head)\n{\n    ListNode fast = head, slow = head;\n    while(fast!=null &amp;&amp; fast.next!=null)\n    {\n        fast = fast.next.next;\n        slow = slow.next;\n        if(fast==slow) return true;\n    }\n    return false;\n}</code></pre>\n"},{"title":"LeetCode刷题笔记155","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"LeetCode刷题笔记","abbrlink":"17a31575","date":"2020-06-12T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)\n>\n> \n>\n> 其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n```\npush(x) —— 将元素 x 推入栈中。\npop() —— 删除栈顶的元素。\ntop() —— 获取栈顶元素。\ngetMin() —— 检索栈中的最小元素。\n```\n\n示例:\n```\n输入：\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.getMin();   --> 返回 -2.\n\n```\n\n提示：\n\npop、top 和 getMin 操作总是在 非空栈 上调用。\n\n\n\n# 思路\n\n多用一个栈保存最小值\n\n# 细节\n\n栈与存储最小元素的辅助栈最小元素要一一对应,不能因为重复就不存了.\n\n# 代码\n\n```java\npublic class MinStack\n{\n    Deque<Integer> stack;\n    Deque<Integer> minStack;\n\n\n    public MinStack()\n    {\n        stack = new LinkedList<>();\n        minStack = new LinkedList<>();\n    }\n\n    public void push(int x)\n    {\n        stack.push(x);\n        //小于等于都存,一一对应,好删除\n        if (minStack.isEmpty() || x <= minStack.peek()) minStack.push(x);\n    }\n\n    public void pop()\n    {\n        if(stack.pop().equals(minStack.peek())) minStack.pop();\n    }\n\n    public int top()\n    {\n        if (stack.isEmpty()) throw new RuntimeException();\n        return stack.peek();\n    }\n\n    public int getMin()\n    {\n        if (minStack.isEmpty()) throw new RuntimeException();\n        return minStack.peek();\n    }\n}\n```\n\n\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_155. 最小栈.md","raw":"---\ntitle: LeetCode刷题笔记155\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 栈\n  - 算法\nabbrlink: 17a31575\ndate: 2020-06-13 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)\n>\n> \n>\n> 其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n```\npush(x) —— 将元素 x 推入栈中。\npop() —— 删除栈顶的元素。\ntop() —— 获取栈顶元素。\ngetMin() —— 检索栈中的最小元素。\n```\n\n示例:\n```\n输入：\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.getMin();   --> 返回 -2.\n\n```\n\n提示：\n\npop、top 和 getMin 操作总是在 非空栈 上调用。\n\n\n\n# 思路\n\n多用一个栈保存最小值\n\n# 细节\n\n栈与存储最小元素的辅助栈最小元素要一一对应,不能因为重复就不存了.\n\n# 代码\n\n```java\npublic class MinStack\n{\n    Deque<Integer> stack;\n    Deque<Integer> minStack;\n\n\n    public MinStack()\n    {\n        stack = new LinkedList<>();\n        minStack = new LinkedList<>();\n    }\n\n    public void push(int x)\n    {\n        stack.push(x);\n        //小于等于都存,一一对应,好删除\n        if (minStack.isEmpty() || x <= minStack.peek()) minStack.push(x);\n    }\n\n    public void pop()\n    {\n        if(stack.pop().equals(minStack.peek())) minStack.pop();\n    }\n\n    public int top()\n    {\n        if (stack.isEmpty()) throw new RuntimeException();\n        return stack.peek();\n    }\n\n    public int getMin()\n    {\n        if (minStack.isEmpty()) throw new RuntimeException();\n        return minStack.peek();\n    }\n}\n```\n\n\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_155. 最小栈","published":1,"updated":"2020-11-12T11:57:29.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6y2005ijotpg6rw4fof","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/min-stack/\" target=\"_blank\" rel=\"noopener\">155. 最小栈</a></p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>\n<pre><code>push(x) —— 将元素 x 推入栈中。\npop() —— 删除栈顶的元素。\ntop() —— 获取栈顶元素。\ngetMin() —— 检索栈中的最小元素。</code></pre>\n<p>示例:</p>\n<pre><code>输入：\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.getMin();   --&gt; 返回 -2.\n</code></pre>\n<p>提示：</p>\n<p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>多用一个栈保存最小值</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>栈与存储最小元素的辅助栈最小元素要一一对应,不能因为重复就不存了.</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MinStack</span>\n<span class=\"token punctuation\">{</span>\n    Deque<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> stack<span class=\"token punctuation\">;</span>\n    Deque<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> minStack<span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">MinStack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        stack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        minStack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//小于等于都存,一一对应,好删除</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>minStack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> x <span class=\"token operator\">&lt;=</span> minStack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> minStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>minStack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> minStack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getMin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>minStack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> minStack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/min-stack/\" target=\"_blank\" rel=\"noopener\">155. 最小栈</a></p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>\n<pre><code>push(x) —— 将元素 x 推入栈中。\npop() —— 删除栈顶的元素。\ntop() —— 获取栈顶元素。\ngetMin() —— 检索栈中的最小元素。</code></pre>\n<p>示例:</p>\n<pre><code>输入：\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.getMin();   --&gt; 返回 -2.\n</code></pre>\n<p>提示：</p>\n<p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>多用一个栈保存最小值</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>栈与存储最小元素的辅助栈最小元素要一一对应,不能因为重复就不存了.</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public class MinStack\n{\n    Deque&lt;Integer&gt; stack;\n    Deque&lt;Integer&gt; minStack;\n\n\n    public MinStack()\n    {\n        stack = new LinkedList&lt;&gt;();\n        minStack = new LinkedList&lt;&gt;();\n    }\n\n    public void push(int x)\n    {\n        stack.push(x);\n        //小于等于都存,一一对应,好删除\n        if (minStack.isEmpty() || x &lt;= minStack.peek()) minStack.push(x);\n    }\n\n    public void pop()\n    {\n        if(stack.pop().equals(minStack.peek())) minStack.pop();\n    }\n\n    public int top()\n    {\n        if (stack.isEmpty()) throw new RuntimeException();\n        return stack.peek();\n    }\n\n    public int getMin()\n    {\n        if (minStack.isEmpty()) throw new RuntimeException();\n        return minStack.peek();\n    }\n}</code></pre>\n"},{"title":"LeetCode刷题笔记17","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"f5cf27a1","date":"2020-03-27T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n\n![Mon Aug 10 064242 CST 2020](https://tongji4m3.oss-cn-beijing.aliyuncs.com/Mon Aug 10 064242 CST 2020.png)\n```java\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n```\n说明:\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n\n# 思路\n\n用数组存储数字与字符串的对应关系.\n\n递归,先加入字符,递归到下一层,再移除那个字符\n\n到最后一个的时候,就加入结果,停止本层的递归\n\n```java\nif(i==length)\n\tresult.add(stringBuilder.toString());\n\nfor(ch in map[i])//每个数字字符对应的字符串\n{\n\tstringBuilder.append(ch);\n    recursive(i+1);\n    stringBuilder.remove(ch);\n}\n\n```\n\n\n\n# 细节\n\n1. 把方法局部变量变成成员变量,加快速度\n2. 注意传入空串时的返回\n3. 用`map[digits.charAt(index)-'0']`转换优化速度\n\n\n# 代码\n\n```java\npublic class Demo17\n{\n    private String[] map = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    private LinkedList<String> result = new LinkedList<>();\n    private StringBuilder stringBuilder = new StringBuilder();\n\n\n    //方法局部变量变成成员变量,加快速度\n    public List<String> letterCombinations(String digits)\n    {\n        //look 长度为0,返回空,而不是空的字符串串\n        if(digits==null || digits.length()==0) return result;\n        recursive(digits,0);\n        return result;\n    }\n\n    //result为结果集合,stringBuilder存储中间字符串,index代表递归到哪个数字字符\n    private void recursive(String digits, int index)\n    {\n        if(index==digits.length())\n        {\n            result.add(stringBuilder.toString());\n            return;\n        }\n\n        //优化速度\n        String string = map[digits.charAt(index)-'0'];//例如abc\n        for (int i = 0; i < string.length(); i++)\n        {\n            stringBuilder.append(string.charAt(i));//例如加入a\n            recursive(digits, index + 1);//继续下一层\n            stringBuilder.deleteCharAt(stringBuilder.length() - 1);//删除刚刚加入的\n        }\n    }\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n因为是普通的递归,所以结果有多少种,时间复杂度就是多少.假如x是`234568`的总数量(一个数字对应三个字母),y是`79`数字的总数量(对应四个字符).总时间复杂度为$O(3^x4^y)$ ,(x+y)为输入的总字符串长度.\n\n## 空间复杂度\n\n需要存储这些结果,空间复杂度也为$O(3^x4^y)$","source":"_posts/LeetCode笔记/LeetCode刷题笔记_17_ 电话号码的字母组合.md","raw":"---\ntitle: LeetCode刷题笔记17\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 字符串\nabbrlink: f5cf27a1\ndate: 2020-03-28 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n\n![Mon Aug 10 064242 CST 2020](https://tongji4m3.oss-cn-beijing.aliyuncs.com/Mon Aug 10 064242 CST 2020.png)\n```java\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n```\n说明:\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n\n# 思路\n\n用数组存储数字与字符串的对应关系.\n\n递归,先加入字符,递归到下一层,再移除那个字符\n\n到最后一个的时候,就加入结果,停止本层的递归\n\n```java\nif(i==length)\n\tresult.add(stringBuilder.toString());\n\nfor(ch in map[i])//每个数字字符对应的字符串\n{\n\tstringBuilder.append(ch);\n    recursive(i+1);\n    stringBuilder.remove(ch);\n}\n\n```\n\n\n\n# 细节\n\n1. 把方法局部变量变成成员变量,加快速度\n2. 注意传入空串时的返回\n3. 用`map[digits.charAt(index)-'0']`转换优化速度\n\n\n# 代码\n\n```java\npublic class Demo17\n{\n    private String[] map = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    private LinkedList<String> result = new LinkedList<>();\n    private StringBuilder stringBuilder = new StringBuilder();\n\n\n    //方法局部变量变成成员变量,加快速度\n    public List<String> letterCombinations(String digits)\n    {\n        //look 长度为0,返回空,而不是空的字符串串\n        if(digits==null || digits.length()==0) return result;\n        recursive(digits,0);\n        return result;\n    }\n\n    //result为结果集合,stringBuilder存储中间字符串,index代表递归到哪个数字字符\n    private void recursive(String digits, int index)\n    {\n        if(index==digits.length())\n        {\n            result.add(stringBuilder.toString());\n            return;\n        }\n\n        //优化速度\n        String string = map[digits.charAt(index)-'0'];//例如abc\n        for (int i = 0; i < string.length(); i++)\n        {\n            stringBuilder.append(string.charAt(i));//例如加入a\n            recursive(digits, index + 1);//继续下一层\n            stringBuilder.deleteCharAt(stringBuilder.length() - 1);//删除刚刚加入的\n        }\n    }\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n因为是普通的递归,所以结果有多少种,时间复杂度就是多少.假如x是`234568`的总数量(一个数字对应三个字母),y是`79`数字的总数量(对应四个字符).总时间复杂度为$O(3^x4^y)$ ,(x+y)为输入的总字符串长度.\n\n## 空间复杂度\n\n需要存储这些结果,空间复杂度也为$O(3^x4^y)$","slug":"LeetCode笔记/LeetCode刷题笔记_17_ 电话号码的字母组合","published":1,"updated":"2020-11-12T11:57:29.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6y3005kjotpe3nza4vb","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/\" target=\"_blank\" rel=\"noopener\">17. 电话号码的字母组合</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>\n<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n<p>![Mon Aug 10 064242 CST 2020](<a href=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/Mon\" target=\"_blank\" rel=\"noopener\">https://tongji4m3.oss-cn-beijing.aliyuncs.com/Mon</a> Aug 10 064242 CST 2020.png)</p>\n<pre class=\" language-java\"><code class=\"language-java\">输入：<span class=\"token string\">\"23\"</span>\n输出：<span class=\"token punctuation\">[</span><span class=\"token string\">\"ad\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ae\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"af\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bd\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"be\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bf\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cd\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ce\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cf\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span></code></pre>\n<p>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>用数组存储数字与字符串的对应关系.</p>\n<p>递归,先加入字符,递归到下一层,再移除那个字符</p>\n<p>到最后一个的时候,就加入结果,停止本层的递归</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">==</span>length<span class=\"token punctuation\">)</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>ch in map<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//每个数字字符对应的字符串</span>\n<span class=\"token punctuation\">{</span>\n    stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>把方法局部变量变成成员变量,加快速度</li>\n<li>注意传入空串时的返回</li>\n<li>用<code>map[digits.charAt(index)-&#39;0&#39;]</code>转换优化速度</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo17</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> map <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"def\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ghi\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"jkl\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"mno\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"pqrs\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"tuv\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"wxyz\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> LinkedList<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> StringBuilder stringBuilder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token comment\" spellcheck=\"true\">//方法局部变量变成成员变量,加快速度</span>\n    <span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token function\">letterCombinations</span><span class=\"token punctuation\">(</span>String digits<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//look 长度为0,返回空,而不是空的字符串串</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>digits<span class=\"token operator\">==</span>null <span class=\"token operator\">||</span> digits<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>digits<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//result为结果集合,stringBuilder存储中间字符串,index代表递归到哪个数字字符</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>String digits<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">==</span>digits<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//优化速度</span>\n        String string <span class=\"token operator\">=</span> map<span class=\"token punctuation\">[</span>digits<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//例如abc</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> string<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//例如加入a</span>\n            <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>digits<span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//继续下一层</span>\n            stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">deleteCharAt</span><span class=\"token punctuation\">(</span>stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//删除刚刚加入的</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>因为是普通的递归,所以结果有多少种,时间复杂度就是多少.假如x是<code>234568</code>的总数量(一个数字对应三个字母),y是<code>79</code>数字的总数量(对应四个字符).总时间复杂度为$O(3^x4^y)$ ,(x+y)为输入的总字符串长度.</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>需要存储这些结果,空间复杂度也为$O(3^x4^y)$</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/\" target=\"_blank\" rel=\"noopener\">17. 电话号码的字母组合</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>\n<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n<p>![Mon Aug 10 064242 CST 2020](<a href=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/Mon\" target=\"_blank\" rel=\"noopener\">https://tongji4m3.oss-cn-beijing.aliyuncs.com/Mon</a> Aug 10 064242 CST 2020.png)</p>\n<pre><code class=\"java\">输入：&quot;23&quot;\n输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</code></pre>\n<p>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>用数组存储数字与字符串的对应关系.</p>\n<p>递归,先加入字符,递归到下一层,再移除那个字符</p>\n<p>到最后一个的时候,就加入结果,停止本层的递归</p>\n<pre><code class=\"java\">if(i==length)\n    result.add(stringBuilder.toString());\n\nfor(ch in map[i])//每个数字字符对应的字符串\n{\n    stringBuilder.append(ch);\n    recursive(i+1);\n    stringBuilder.remove(ch);\n}\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>把方法局部变量变成成员变量,加快速度</li>\n<li>注意传入空串时的返回</li>\n<li>用<code>map[digits.charAt(index)-&#39;0&#39;]</code>转换优化速度</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public class Demo17\n{\n    private String[] map = {&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};\n    private LinkedList&lt;String&gt; result = new LinkedList&lt;&gt;();\n    private StringBuilder stringBuilder = new StringBuilder();\n\n\n    //方法局部变量变成成员变量,加快速度\n    public List&lt;String&gt; letterCombinations(String digits)\n    {\n        //look 长度为0,返回空,而不是空的字符串串\n        if(digits==null || digits.length()==0) return result;\n        recursive(digits,0);\n        return result;\n    }\n\n    //result为结果集合,stringBuilder存储中间字符串,index代表递归到哪个数字字符\n    private void recursive(String digits, int index)\n    {\n        if(index==digits.length())\n        {\n            result.add(stringBuilder.toString());\n            return;\n        }\n\n        //优化速度\n        String string = map[digits.charAt(index)-&#39;0&#39;];//例如abc\n        for (int i = 0; i &lt; string.length(); i++)\n        {\n            stringBuilder.append(string.charAt(i));//例如加入a\n            recursive(digits, index + 1);//继续下一层\n            stringBuilder.deleteCharAt(stringBuilder.length() - 1);//删除刚刚加入的\n        }\n    }\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>因为是普通的递归,所以结果有多少种,时间复杂度就是多少.假如x是<code>234568</code>的总数量(一个数字对应三个字母),y是<code>79</code>数字的总数量(对应四个字符).总时间复杂度为$O(3^x4^y)$ ,(x+y)为输入的总字符串长度.</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>需要存储这些结果,空间复杂度也为$O(3^x4^y)$</p>\n"},{"title":"LeetCode刷题笔记15","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"1bc1468d","date":"2020-03-25T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [15. 三数之和](https://leetcode-cn.com/problems/3sum/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n \n\n示例：\n\n```\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n\n\n\n\n\n# 思路\n\n```\n先排序，然后逐个遍历i，双指针lo=i+1,hi=n-1,找到lo>=hi为止\n去除重复：i遇到重复的跳过，nums[i]+nums[lo]+nums[hi]==0时，++lo,--hi同时循环进行\n因为可能下一个还是同样值的lo，hi，且一个移动之后，不可能再相等，为了更快两个一起移动\n```\n\n```java\nsort(nums);\n\nfor(i in nums)\n{\n    lo=i+1,hi=n-1;\n    处理第一个元素重复的情况;\n    //至少为三元组\n    while(lo<hi)\n    {\n        if(nums[lo]+nums[hi]+nums[i]==0)\n        {\n            加入result中;\n        \t注意处理重复的情况;\n        }\n        else\n        {\n            根据大小关系--hi或者++lo;\n        }\n    }\n}\n\n\n```\n\n\n\n# 细节\n\n1. 注意第一个处理重复要从1开始,不然会越界\n2. 如果第一个就大于0,排序后的肯定找不到.所以可以优化\n3. 注意后面两个元素处理重复的技巧\n\n\n# 代码\n\n```java\npublic List<List<Integer>> threeSum(int[] nums)\n{\n    List<List<Integer>> result = new LinkedList<>();\n    Arrays.sort(nums);\n\n    for (int i = 0; i < nums.length; i++)\n    {\n        if(nums[i]>0) break;//优化\n        //处理第一个元素的重复\n        if(i>0 && nums[i]==nums[i-1]) continue;\n\n        int lo = i + 1, hi = nums.length - 1;\n        while(lo<hi)//至少有三个元素\n        {\n            if(nums[i]+nums[lo]+nums[hi]==0)\n            {\n                result.add(Arrays.asList(nums[i], nums[lo], nums[hi]));\n                //去重\n                //look,必须至少强制位移一次\n                //因为去掉重复,所以一个位移了,另外一个必然是要位移的\n                //                    while(lo<hi && nums[lo+1]==nums[lo]) ++lo;\n                //                    while(lo<hi && nums[hi]==nums[hi-1]) --hi;\n                //look,注意细节,如果先++lo了,那肯定会错,因为两个相等了\n                //                    while(lo<hi && nums[++lo]==nums[lo]);\n                //                    while(lo<hi && nums[--hi]==nums[hi]);\n                while(lo<hi && nums[lo]==nums[++lo]);\n                while(lo<hi && nums[hi]==nums[--hi]);\n            }\n            else if(nums[i]+nums[lo]+nums[hi]>0) --hi;\n            else ++lo;\n        }\n\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N^2)$,外层遍历一次数组,随后又用lo,hi内层循环遍历\n\n## 空间复杂度\n\n$O(1)$ 忽略返回结果消耗的内存,忽略Arrays.sort()有可能消耗的内存","source":"_posts/LeetCode笔记/LeetCode刷题笔记_15_三数之和.md","raw":"---\ntitle: LeetCode刷题笔记15\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 算法\nabbrlink: 1bc1468d\ndate: 2020-03-26 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [15. 三数之和](https://leetcode-cn.com/problems/3sum/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n \n\n示例：\n\n```\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n\n\n\n\n\n# 思路\n\n```\n先排序，然后逐个遍历i，双指针lo=i+1,hi=n-1,找到lo>=hi为止\n去除重复：i遇到重复的跳过，nums[i]+nums[lo]+nums[hi]==0时，++lo,--hi同时循环进行\n因为可能下一个还是同样值的lo，hi，且一个移动之后，不可能再相等，为了更快两个一起移动\n```\n\n```java\nsort(nums);\n\nfor(i in nums)\n{\n    lo=i+1,hi=n-1;\n    处理第一个元素重复的情况;\n    //至少为三元组\n    while(lo<hi)\n    {\n        if(nums[lo]+nums[hi]+nums[i]==0)\n        {\n            加入result中;\n        \t注意处理重复的情况;\n        }\n        else\n        {\n            根据大小关系--hi或者++lo;\n        }\n    }\n}\n\n\n```\n\n\n\n# 细节\n\n1. 注意第一个处理重复要从1开始,不然会越界\n2. 如果第一个就大于0,排序后的肯定找不到.所以可以优化\n3. 注意后面两个元素处理重复的技巧\n\n\n# 代码\n\n```java\npublic List<List<Integer>> threeSum(int[] nums)\n{\n    List<List<Integer>> result = new LinkedList<>();\n    Arrays.sort(nums);\n\n    for (int i = 0; i < nums.length; i++)\n    {\n        if(nums[i]>0) break;//优化\n        //处理第一个元素的重复\n        if(i>0 && nums[i]==nums[i-1]) continue;\n\n        int lo = i + 1, hi = nums.length - 1;\n        while(lo<hi)//至少有三个元素\n        {\n            if(nums[i]+nums[lo]+nums[hi]==0)\n            {\n                result.add(Arrays.asList(nums[i], nums[lo], nums[hi]));\n                //去重\n                //look,必须至少强制位移一次\n                //因为去掉重复,所以一个位移了,另外一个必然是要位移的\n                //                    while(lo<hi && nums[lo+1]==nums[lo]) ++lo;\n                //                    while(lo<hi && nums[hi]==nums[hi-1]) --hi;\n                //look,注意细节,如果先++lo了,那肯定会错,因为两个相等了\n                //                    while(lo<hi && nums[++lo]==nums[lo]);\n                //                    while(lo<hi && nums[--hi]==nums[hi]);\n                while(lo<hi && nums[lo]==nums[++lo]);\n                while(lo<hi && nums[hi]==nums[--hi]);\n            }\n            else if(nums[i]+nums[lo]+nums[hi]>0) --hi;\n            else ++lo;\n        }\n\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N^2)$,外层遍历一次数组,随后又用lo,hi内层循环遍历\n\n## 空间复杂度\n\n$O(1)$ 忽略返回结果消耗的内存,忽略Arrays.sort()有可能消耗的内存","slug":"LeetCode笔记/LeetCode刷题笔记_15_三数之和","published":1,"updated":"2020-11-12T11:57:29.505Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6y4005njotp6bu71iew","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/3sum/\" target=\"_blank\" rel=\"noopener\">15. 三数之和</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>\n<p>注意：答案中不可以包含重复的三元组。</p>\n<p>示例：</p>\n<pre><code>给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code>先排序，然后逐个遍历i，双指针lo=i+1,hi=n-1,找到lo&gt;=hi为止\n去除重复：i遇到重复的跳过，nums[i]+nums[lo]+nums[hi]==0时，++lo,--hi同时循环进行\n因为可能下一个还是同样值的lo，hi，且一个移动之后，不可能再相等，为了更快两个一起移动</code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i in nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    lo<span class=\"token operator\">=</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>hi<span class=\"token operator\">=</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    处理第一个元素重复的情况<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//至少为三元组</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">&lt;</span>hi<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            加入result中<span class=\"token punctuation\">;</span>\n            注意处理重复的情况<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            根据大小关系<span class=\"token operator\">--</span>hi或者<span class=\"token operator\">++</span>lo<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意第一个处理重复要从1开始,不然会越界</li>\n<li>如果第一个就大于0,排序后的肯定找不到.所以可以优化</li>\n<li>注意后面两个元素处理重复的技巧</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> <span class=\"token function\">threeSum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//优化</span>\n        <span class=\"token comment\" spellcheck=\"true\">//处理第一个元素的重复</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">></span><span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">int</span> lo <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> hi <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">&lt;</span>hi<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//至少有三个元素</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//去重</span>\n                <span class=\"token comment\" spellcheck=\"true\">//look,必须至少强制位移一次</span>\n                <span class=\"token comment\" spellcheck=\"true\">//因为去掉重复,所以一个位移了,另外一个必然是要位移的</span>\n                <span class=\"token comment\" spellcheck=\"true\">//                    while(lo&lt;hi &amp;&amp; nums[lo+1]==nums[lo]) ++lo;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//                    while(lo&lt;hi &amp;&amp; nums[hi]==nums[hi-1]) --hi;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//look,注意细节,如果先++lo了,那肯定会错,因为两个相等了</span>\n                <span class=\"token comment\" spellcheck=\"true\">//                    while(lo&lt;hi &amp;&amp; nums[++lo]==nums[lo]);</span>\n                <span class=\"token comment\" spellcheck=\"true\">//                    while(lo&lt;hi &amp;&amp; nums[--hi]==nums[hi]);</span>\n                <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">&lt;</span>hi <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>nums<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">&lt;</span>hi <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>nums<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">--</span>hi<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token operator\">++</span>lo<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N^2)$,外层遍历一次数组,随后又用lo,hi内层循环遍历</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$ 忽略返回结果消耗的内存,忽略Arrays.sort()有可能消耗的内存</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/3sum/\" target=\"_blank\" rel=\"noopener\">15. 三数之和</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>\n<p>注意：答案中不可以包含重复的三元组。</p>\n<p>示例：</p>\n<pre><code>给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code>先排序，然后逐个遍历i，双指针lo=i+1,hi=n-1,找到lo&gt;=hi为止\n去除重复：i遇到重复的跳过，nums[i]+nums[lo]+nums[hi]==0时，++lo,--hi同时循环进行\n因为可能下一个还是同样值的lo，hi，且一个移动之后，不可能再相等，为了更快两个一起移动</code></pre>\n<pre><code class=\"java\">sort(nums);\n\nfor(i in nums)\n{\n    lo=i+1,hi=n-1;\n    处理第一个元素重复的情况;\n    //至少为三元组\n    while(lo&lt;hi)\n    {\n        if(nums[lo]+nums[hi]+nums[i]==0)\n        {\n            加入result中;\n            注意处理重复的情况;\n        }\n        else\n        {\n            根据大小关系--hi或者++lo;\n        }\n    }\n}\n\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意第一个处理重复要从1开始,不然会越界</li>\n<li>如果第一个就大于0,排序后的肯定找不到.所以可以优化</li>\n<li>注意后面两个元素处理重复的技巧</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums)\n{\n    List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();\n    Arrays.sort(nums);\n\n    for (int i = 0; i &lt; nums.length; i++)\n    {\n        if(nums[i]&gt;0) break;//优化\n        //处理第一个元素的重复\n        if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue;\n\n        int lo = i + 1, hi = nums.length - 1;\n        while(lo&lt;hi)//至少有三个元素\n        {\n            if(nums[i]+nums[lo]+nums[hi]==0)\n            {\n                result.add(Arrays.asList(nums[i], nums[lo], nums[hi]));\n                //去重\n                //look,必须至少强制位移一次\n                //因为去掉重复,所以一个位移了,另外一个必然是要位移的\n                //                    while(lo&lt;hi &amp;&amp; nums[lo+1]==nums[lo]) ++lo;\n                //                    while(lo&lt;hi &amp;&amp; nums[hi]==nums[hi-1]) --hi;\n                //look,注意细节,如果先++lo了,那肯定会错,因为两个相等了\n                //                    while(lo&lt;hi &amp;&amp; nums[++lo]==nums[lo]);\n                //                    while(lo&lt;hi &amp;&amp; nums[--hi]==nums[hi]);\n                while(lo&lt;hi &amp;&amp; nums[lo]==nums[++lo]);\n                while(lo&lt;hi &amp;&amp; nums[hi]==nums[--hi]);\n            }\n            else if(nums[i]+nums[lo]+nums[hi]&gt;0) --hi;\n            else ++lo;\n        }\n\n    }\n    return result;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N^2)$,外层遍历一次数组,随后又用lo,hi内层循环遍历</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$ 忽略返回结果消耗的内存,忽略Arrays.sort()有可能消耗的内存</p>\n"},{"title":"LeetCode刷题笔记_207_课程表","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"LeetCode刷题笔记,主要是图论,拓扑排序判断是否有环等相关知识。","abbrlink":"5e9da042","date":"2020-06-12T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n你这个学期必须选修 `numCourse` 门课程，记为 0 到`numCourse-1` 。\n\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：`[0,1]`\n\n给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？\n\n \n\n示例 1:\n\n```java\n\n输入: 2, [[1,0]] \n输出: true\n解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。\n```\n示例 2:\n```java\n输入: 2, [[1,0],[0,1]]\n输出: false\n解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。\n```\n\n提示：\n\n```java\n输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。\n你可以假定输入的先决条件中没有重复的边。\n1 <= numCourses <= 10^5\n```\n\n\n\n\n\n\n\n# 思路\n\n该题为拓扑排序相关问题。\n\n首先先**构造图**。可以先将课程转为图的顶点，再为课程关系转为有向图中的边。\n\n随后判断图是否是**无环图**,无环图则代表这样的课程顺序符合规范。具体做法为用`dfs`进行遍历，且每次遍历时维护一个cycle以作为每次有环的判断。\n\n# 细节\n\n维护一个全局变量`hasCycle`可以在有环时直接退出`dfs`，并且能够在有环后不进行更深层次的递归，优化程序速度。\n\n\n# 代码\n\n```java\nclass Solution {\n    private Map<Integer, List<Integer>> graph;\n    private boolean[] marked;\n    private boolean[] cycle;\n    private boolean hasCycle;\n    \n    public void createGraph(int numCourses, int[][] prerequisites)\n    {\n        //存储点和他们的邻接边\n        graph = new HashMap<>(numCourses);\n        //初始化图\n        for (int i = 0; i < numCourses; i++) graph.put(i, new LinkedList<>());\n        //添加有向边\n        for (int i = 0; i < prerequisites.length; i++) graph.get(prerequisites[i][1]).add(prerequisites[i][0]);\n\n        //标记数组\n        marked = new boolean[numCourses];\n        //负责判断是否有环的临时数组\n        cycle = new boolean[numCourses];\n    }\n    \n    /**\n     * 拓扑排序相关问题\n     * 有向图,判断是否有环\n     * 构造图,dfs判断即可\n     */\n    public boolean canFinish(int numCourses, int[][] prerequisites)\n    {\n        createGraph(numCourses,prerequisites);\n        \n        for (int i = 0; i < numCourses; i++)\n        {\n            //以没标记过的顶点作为某个根节点进行深搜\n            if (!marked[i]) dfs(i);\n        }\n        //无环则可上课\n        return !hasCycle;\n    }\n\n    private void dfs(int v)\n    {\n        //顶点标记为已访问\n        marked[v] = true;\n        cycle[v] = true;\n        for (Integer w : graph.get(v))\n        {\n            if(hasCycle) return;//为了避免有环还在不断寻找\n            if (!marked[w])\n            {\n                dfs(w);\n            }\n            else if(cycle[w])\n            {\n                hasCycle = true;\n                return;\n            }\n        }\n        cycle[v] = false;\n    }\n}\n```\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_207. 课程表.md","raw":"---\ntitle: LeetCode刷题笔记_207_课程表\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 'LeetCode刷题笔记,主要是图论,拓扑排序判断是否有环等相关知识。'\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 图\n  - dfs\nabbrlink: 5e9da042\ndate: 2020-06-13 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n你这个学期必须选修 `numCourse` 门课程，记为 0 到`numCourse-1` 。\n\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：`[0,1]`\n\n给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？\n\n \n\n示例 1:\n\n```java\n\n输入: 2, [[1,0]] \n输出: true\n解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。\n```\n示例 2:\n```java\n输入: 2, [[1,0],[0,1]]\n输出: false\n解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。\n```\n\n提示：\n\n```java\n输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。\n你可以假定输入的先决条件中没有重复的边。\n1 <= numCourses <= 10^5\n```\n\n\n\n\n\n\n\n# 思路\n\n该题为拓扑排序相关问题。\n\n首先先**构造图**。可以先将课程转为图的顶点，再为课程关系转为有向图中的边。\n\n随后判断图是否是**无环图**,无环图则代表这样的课程顺序符合规范。具体做法为用`dfs`进行遍历，且每次遍历时维护一个cycle以作为每次有环的判断。\n\n# 细节\n\n维护一个全局变量`hasCycle`可以在有环时直接退出`dfs`，并且能够在有环后不进行更深层次的递归，优化程序速度。\n\n\n# 代码\n\n```java\nclass Solution {\n    private Map<Integer, List<Integer>> graph;\n    private boolean[] marked;\n    private boolean[] cycle;\n    private boolean hasCycle;\n    \n    public void createGraph(int numCourses, int[][] prerequisites)\n    {\n        //存储点和他们的邻接边\n        graph = new HashMap<>(numCourses);\n        //初始化图\n        for (int i = 0; i < numCourses; i++) graph.put(i, new LinkedList<>());\n        //添加有向边\n        for (int i = 0; i < prerequisites.length; i++) graph.get(prerequisites[i][1]).add(prerequisites[i][0]);\n\n        //标记数组\n        marked = new boolean[numCourses];\n        //负责判断是否有环的临时数组\n        cycle = new boolean[numCourses];\n    }\n    \n    /**\n     * 拓扑排序相关问题\n     * 有向图,判断是否有环\n     * 构造图,dfs判断即可\n     */\n    public boolean canFinish(int numCourses, int[][] prerequisites)\n    {\n        createGraph(numCourses,prerequisites);\n        \n        for (int i = 0; i < numCourses; i++)\n        {\n            //以没标记过的顶点作为某个根节点进行深搜\n            if (!marked[i]) dfs(i);\n        }\n        //无环则可上课\n        return !hasCycle;\n    }\n\n    private void dfs(int v)\n    {\n        //顶点标记为已访问\n        marked[v] = true;\n        cycle[v] = true;\n        for (Integer w : graph.get(v))\n        {\n            if(hasCycle) return;//为了避免有环还在不断寻找\n            if (!marked[w])\n            {\n                dfs(w);\n            }\n            else if(cycle[w])\n            {\n                hasCycle = true;\n                return;\n            }\n        }\n        cycle[v] = false;\n    }\n}\n```\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_207. 课程表","published":1,"updated":"2021-02-04T00:46:22.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6y5005qjotp7vxy8ans","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/course-schedule/\" target=\"_blank\" rel=\"noopener\">207. 课程表</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>你这个学期必须选修 <code>numCourse</code> 门课程，记为 0 到<code>numCourse-1</code> 。</p>\n<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：<code>[0,1]</code></p>\n<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>\n<p>示例 1:</p>\n<pre class=\" language-java\"><code class=\"language-java\">\n输入<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> \n输出<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n解释<span class=\"token operator\">:</span> 总共有 <span class=\"token number\">2</span> 门课程。学习课程 <span class=\"token number\">1</span> 之前，你需要完成课程 <span class=\"token number\">0</span>。所以这是可能的。</code></pre>\n<p>示例 2:</p>\n<pre class=\" language-java\"><code class=\"language-java\">输入<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n输出<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span>\n解释<span class=\"token operator\">:</span> 总共有 <span class=\"token number\">2</span> 门课程。学习课程 <span class=\"token number\">1</span> 之前，你需要先完成课程 <span class=\"token number\">0</span>；并且学习课程 <span class=\"token number\">0</span> 之前，你还应先完成课程 <span class=\"token number\">1</span>。这是不可能的。</code></pre>\n<p>提示：</p>\n<pre class=\" language-java\"><code class=\"language-java\">输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。\n你可以假定输入的先决条件中没有重复的边。\n<span class=\"token number\">1</span> <span class=\"token operator\">&lt;=</span> numCourses <span class=\"token operator\">&lt;=</span> <span class=\"token number\">10</span><span class=\"token operator\">^</span><span class=\"token number\">5</span></code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>该题为拓扑排序相关问题。</p>\n<p>首先先<strong>构造图</strong>。可以先将课程转为图的顶点，再为课程关系转为有向图中的边。</p>\n<p>随后判断图是否是<strong>无环图</strong>,无环图则代表这样的课程顺序符合规范。具体做法为用<code>dfs</code>进行遍历，且每次遍历时维护一个cycle以作为每次有环的判断。</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>维护一个全局变量<code>hasCycle</code>可以在有环时直接退出<code>dfs</code>，并且能够在有环后不进行更深层次的递归，优化程序速度。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> graph<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> marked<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> cycle<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> hasCycle<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">createGraph</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> numCourses<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> prerequisites<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//存储点和他们的邻接边</span>\n        graph <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>numCourses<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//初始化图</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> numCourses<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> graph<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//添加有向边</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> prerequisites<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> graph<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>prerequisites<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>prerequisites<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//标记数组</span>\n        marked <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">boolean</span><span class=\"token punctuation\">[</span>numCourses<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//负责判断是否有环的临时数组</span>\n        cycle <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">boolean</span><span class=\"token punctuation\">[</span>numCourses<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 拓扑排序相关问题\n     * 有向图,判断是否有环\n     * 构造图,dfs判断即可\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">canFinish</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> numCourses<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> prerequisites<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">createGraph</span><span class=\"token punctuation\">(</span>numCourses<span class=\"token punctuation\">,</span>prerequisites<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> numCourses<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//以没标记过的顶点作为某个根节点进行深搜</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>marked<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//无环则可上课</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span>hasCycle<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//顶点标记为已访问</span>\n        marked<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        cycle<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Integer w <span class=\"token operator\">:</span> graph<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>hasCycle<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//为了避免有环还在不断寻找</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>marked<span class=\"token punctuation\">[</span>w<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cycle<span class=\"token punctuation\">[</span>w<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                hasCycle <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        cycle<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/course-schedule/\" target=\"_blank\" rel=\"noopener\">207. 课程表</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>你这个学期必须选修 <code>numCourse</code> 门课程，记为 0 到<code>numCourse-1</code> 。</p>\n<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：<code>[0,1]</code></p>\n<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>\n<p>示例 1:</p>\n<pre><code class=\"java\">\n输入: 2, [[1,0]] \n输出: true\n解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</code></pre>\n<p>示例 2:</p>\n<pre><code class=\"java\">输入: 2, [[1,0],[0,1]]\n输出: false\n解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</code></pre>\n<p>提示：</p>\n<pre><code class=\"java\">输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。\n你可以假定输入的先决条件中没有重复的边。\n1 &lt;= numCourses &lt;= 10^5</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>该题为拓扑排序相关问题。</p>\n<p>首先先<strong>构造图</strong>。可以先将课程转为图的顶点，再为课程关系转为有向图中的边。</p>\n<p>随后判断图是否是<strong>无环图</strong>,无环图则代表这样的课程顺序符合规范。具体做法为用<code>dfs</code>进行遍历，且每次遍历时维护一个cycle以作为每次有环的判断。</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>维护一个全局变量<code>hasCycle</code>可以在有环时直接退出<code>dfs</code>，并且能够在有环后不进行更深层次的递归，优化程序速度。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">class Solution {\n    private Map&lt;Integer, List&lt;Integer&gt;&gt; graph;\n    private boolean[] marked;\n    private boolean[] cycle;\n    private boolean hasCycle;\n\n    public void createGraph(int numCourses, int[][] prerequisites)\n    {\n        //存储点和他们的邻接边\n        graph = new HashMap&lt;&gt;(numCourses);\n        //初始化图\n        for (int i = 0; i &lt; numCourses; i++) graph.put(i, new LinkedList&lt;&gt;());\n        //添加有向边\n        for (int i = 0; i &lt; prerequisites.length; i++) graph.get(prerequisites[i][1]).add(prerequisites[i][0]);\n\n        //标记数组\n        marked = new boolean[numCourses];\n        //负责判断是否有环的临时数组\n        cycle = new boolean[numCourses];\n    }\n\n    /**\n     * 拓扑排序相关问题\n     * 有向图,判断是否有环\n     * 构造图,dfs判断即可\n     */\n    public boolean canFinish(int numCourses, int[][] prerequisites)\n    {\n        createGraph(numCourses,prerequisites);\n\n        for (int i = 0; i &lt; numCourses; i++)\n        {\n            //以没标记过的顶点作为某个根节点进行深搜\n            if (!marked[i]) dfs(i);\n        }\n        //无环则可上课\n        return !hasCycle;\n    }\n\n    private void dfs(int v)\n    {\n        //顶点标记为已访问\n        marked[v] = true;\n        cycle[v] = true;\n        for (Integer w : graph.get(v))\n        {\n            if(hasCycle) return;//为了避免有环还在不断寻找\n            if (!marked[w])\n            {\n                dfs(w);\n            }\n            else if(cycle[w])\n            {\n                hasCycle = true;\n                return;\n            }\n        }\n        cycle[v] = false;\n    }\n}</code></pre>\n"},{"title":"LeetCode刷题笔记19","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"12770aa6","date":"2020-03-29T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n\n示例：\n```\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n```\n说明：\n\n给定的 n 保证是有效的。\n\n进阶：\n\n你能尝试使用一趟扫描实现吗？\n\n# 思路\n\n设置快慢指针,快指针先走n步,然后快慢指针同步走,当快指针的next为null时,慢指针next为要删除的元素\n\n# 细节\n\n1. 处理列表head为null的情况\n2. 处理要删除头节点去情况\n\n# 代码\n\n```java\n/*\n    边界:如果head=null,返回null\n    因为n保证是合理的,所以1<=n<=head.length\n    如果n==head.length那么fast为null,此时是删除首元素\n     */\npublic ListNode removeNthFromEnd(ListNode head, int n)\n{\n    if(head==null) return null;\n    if(n<=0) throw new IllegalArgumentException();//必须>0\n\n    ListNode fast=head, slow=head;\n    for (int i = 0; i < n; i++)\n    {\n        if(fast==null) throw new IllegalArgumentException();\n        fast = fast.next;\n    }\n    //如果fast==null,说明删除第一个元素\n    if(fast==null)\n    {\n        ListNode temp = head.next;\n        head.next = null;\n        return temp;\n    }\n    //快慢指针一起往前\n    while(fast.next!=null)\n    {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    //此时slow.next指向要删除的元素\n    slow.next = slow.next.next;\n    return head;\n}\n```\n\n\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$\n\n## 空间复杂度\n\n$O(1)$","source":"_posts/LeetCode笔记/LeetCode刷题笔记_19_删除链表的倒数第N个节点.md","raw":"---\ntitle: LeetCode刷题笔记19\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 链表\nabbrlink: 12770aa6\ndate: 2020-03-30 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n\n示例：\n```\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n```\n说明：\n\n给定的 n 保证是有效的。\n\n进阶：\n\n你能尝试使用一趟扫描实现吗？\n\n# 思路\n\n设置快慢指针,快指针先走n步,然后快慢指针同步走,当快指针的next为null时,慢指针next为要删除的元素\n\n# 细节\n\n1. 处理列表head为null的情况\n2. 处理要删除头节点去情况\n\n# 代码\n\n```java\n/*\n    边界:如果head=null,返回null\n    因为n保证是合理的,所以1<=n<=head.length\n    如果n==head.length那么fast为null,此时是删除首元素\n     */\npublic ListNode removeNthFromEnd(ListNode head, int n)\n{\n    if(head==null) return null;\n    if(n<=0) throw new IllegalArgumentException();//必须>0\n\n    ListNode fast=head, slow=head;\n    for (int i = 0; i < n; i++)\n    {\n        if(fast==null) throw new IllegalArgumentException();\n        fast = fast.next;\n    }\n    //如果fast==null,说明删除第一个元素\n    if(fast==null)\n    {\n        ListNode temp = head.next;\n        head.next = null;\n        return temp;\n    }\n    //快慢指针一起往前\n    while(fast.next!=null)\n    {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    //此时slow.next指向要删除的元素\n    slow.next = slow.next.next;\n    return head;\n}\n```\n\n\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$\n\n## 空间复杂度\n\n$O(1)$","slug":"LeetCode笔记/LeetCode刷题笔记_19_删除链表的倒数第N个节点","published":1,"updated":"2020-11-12T11:57:29.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6y7005ujotp0fxh78p3","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\" target=\"_blank\" rel=\"noopener\">19. 删除链表的倒数第N个节点</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>\n<p>示例：</p>\n<pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre>\n<p>说明：</p>\n<p>给定的 n 保证是有效的。</p>\n<p>进阶：</p>\n<p>你能尝试使用一趟扫描实现吗？</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>设置快慢指针,快指针先走n步,然后快慢指针同步走,当快指针的next为null时,慢指针next为要删除的元素</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>处理列表head为null的情况</li>\n<li>处理要删除头节点去情况</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/*\n    边界:如果head=null,返回null\n    因为n保证是合理的,所以1&lt;=n&lt;=head.length\n    如果n==head.length那么fast为null,此时是删除首元素\n     */</span>\n<span class=\"token keyword\">public</span> ListNode <span class=\"token function\">removeNthFromEnd</span><span class=\"token punctuation\">(</span>ListNode head<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">&lt;=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//必须>0</span>\n\n    ListNode fast<span class=\"token operator\">=</span>head<span class=\"token punctuation\">,</span> slow<span class=\"token operator\">=</span>head<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fast<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果fast==null,说明删除第一个元素</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fast<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        ListNode temp <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        head<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> temp<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//快慢指针一起往前</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast<span class=\"token punctuation\">.</span>next<span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//此时slow.next指向要删除的元素</span>\n    slow<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> head<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\" target=\"_blank\" rel=\"noopener\">19. 删除链表的倒数第N个节点</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>\n<p>示例：</p>\n<pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre>\n<p>说明：</p>\n<p>给定的 n 保证是有效的。</p>\n<p>进阶：</p>\n<p>你能尝试使用一趟扫描实现吗？</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>设置快慢指针,快指针先走n步,然后快慢指针同步走,当快指针的next为null时,慢指针next为要删除的元素</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>处理列表head为null的情况</li>\n<li>处理要删除头节点去情况</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">/*\n    边界:如果head=null,返回null\n    因为n保证是合理的,所以1&lt;=n&lt;=head.length\n    如果n==head.length那么fast为null,此时是删除首元素\n     */\npublic ListNode removeNthFromEnd(ListNode head, int n)\n{\n    if(head==null) return null;\n    if(n&lt;=0) throw new IllegalArgumentException();//必须&gt;0\n\n    ListNode fast=head, slow=head;\n    for (int i = 0; i &lt; n; i++)\n    {\n        if(fast==null) throw new IllegalArgumentException();\n        fast = fast.next;\n    }\n    //如果fast==null,说明删除第一个元素\n    if(fast==null)\n    {\n        ListNode temp = head.next;\n        head.next = null;\n        return temp;\n    }\n    //快慢指针一起往前\n    while(fast.next!=null)\n    {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    //此时slow.next指向要删除的元素\n    slow.next = slow.next.next;\n    return head;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$</p>\n"},{"title":"LeetCode刷题笔记20","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"4086e1c1","date":"2020-03-31T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n\t\t左括号必须以正确的顺序闭合。\n\t\t注意空字符串可被认为是有效字符串。\n\n示例 1:\n```\n输入: \"()\"\n输出: true\n```\n示例 2:\n```\n输入: \"()[]{}\"\n输出: true\n```\n示例 3:\n```\n输入: \"(]\"\n输出: false\n```\n示例 4:\n```\n输入: \"([)]\"\n输出: false\n```\n示例 5:\n```\n输入: \"{[]}\"\n输出: true\n```\n\n\n\n# 思路\n\n用stack存储左括号,遇到括号则从栈顶取出,如果不匹配,则返回false.一直到最后,如果栈不为空,也返回false\n\n```\n//伪代码\nfor(ch in string)\n{\n\tif(ch=='(' || ch=='[' || ch=='{') \n\t{\n\t\tstack.push(ch);\n\t}\n\telse\n\t{\n\t\tif(stack.isEmpty() || stack.pop()!=ch) return false;\n\t}\n\tif(!stack.isEmpty()) return false;\n}\n```\n\n\n\n# 细节\n\n1. 注意匹配条件,不是相等\n2. 注意最后还要判断`stack.isEmpty()`\n\n\n# 代码\n\n```java\npublic boolean isValid(String s)\n{\n    Stack<Character> stack = new Stack<>();\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        if (ch == '(' || ch == '[' || ch == '{')\n        {\n            stack.push(ch);\n        }\n        else\n        {\n            //look 是匹配,不是相等\n            //if(stack.isEmpty() || stack.pop()!=ch) return false;\n            if (stack.isEmpty()) return false;\n\n            char temp = stack.pop();\n            switch (ch)\n            {\n                case ')':\n                    if (temp != '(') return false;\n                    break;\n                case ']':\n                    if (temp != '[') return false;\n                    break;\n                case '}':\n                    if (temp != '{') return false;\n                    break;\n            }\n\n        }\n    }\n    return stack.isEmpty();\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$ O(N) $,遍历字符串,并且每次遍历时只进行$ O(1) $的常数操作\n\n## 空间复杂度\n\n$ O(N) $,最坏情况下要把所有字符串都入栈,例如`((((((((`","source":"_posts/LeetCode笔记/LeetCode刷题笔记_20_ 有效的括号.md","raw":"---\ntitle: LeetCode刷题笔记20\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 字符串\nabbrlink: 4086e1c1\ndate: 2020-04-01 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n\t\t左括号必须以正确的顺序闭合。\n\t\t注意空字符串可被认为是有效字符串。\n\n示例 1:\n```\n输入: \"()\"\n输出: true\n```\n示例 2:\n```\n输入: \"()[]{}\"\n输出: true\n```\n示例 3:\n```\n输入: \"(]\"\n输出: false\n```\n示例 4:\n```\n输入: \"([)]\"\n输出: false\n```\n示例 5:\n```\n输入: \"{[]}\"\n输出: true\n```\n\n\n\n# 思路\n\n用stack存储左括号,遇到括号则从栈顶取出,如果不匹配,则返回false.一直到最后,如果栈不为空,也返回false\n\n```\n//伪代码\nfor(ch in string)\n{\n\tif(ch=='(' || ch=='[' || ch=='{') \n\t{\n\t\tstack.push(ch);\n\t}\n\telse\n\t{\n\t\tif(stack.isEmpty() || stack.pop()!=ch) return false;\n\t}\n\tif(!stack.isEmpty()) return false;\n}\n```\n\n\n\n# 细节\n\n1. 注意匹配条件,不是相等\n2. 注意最后还要判断`stack.isEmpty()`\n\n\n# 代码\n\n```java\npublic boolean isValid(String s)\n{\n    Stack<Character> stack = new Stack<>();\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        if (ch == '(' || ch == '[' || ch == '{')\n        {\n            stack.push(ch);\n        }\n        else\n        {\n            //look 是匹配,不是相等\n            //if(stack.isEmpty() || stack.pop()!=ch) return false;\n            if (stack.isEmpty()) return false;\n\n            char temp = stack.pop();\n            switch (ch)\n            {\n                case ')':\n                    if (temp != '(') return false;\n                    break;\n                case ']':\n                    if (temp != '[') return false;\n                    break;\n                case '}':\n                    if (temp != '{') return false;\n                    break;\n            }\n\n        }\n    }\n    return stack.isEmpty();\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$ O(N) $,遍历字符串,并且每次遍历时只进行$ O(1) $的常数操作\n\n## 空间复杂度\n\n$ O(N) $,最坏情况下要把所有字符串都入栈,例如`((((((((`","slug":"LeetCode笔记/LeetCode刷题笔记_20_ 有效的括号","published":1,"updated":"2020-11-12T11:57:29.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6y8005wjotph2i750lt","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\" target=\"_blank\" rel=\"noopener\">20. 有效的括号</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<p>左括号必须用相同类型的右括号闭合。<br>        左括号必须以正确的顺序闭合。<br>        注意空字符串可被认为是有效字符串。</p>\n<p>示例 1:</p>\n<pre><code>输入: &quot;()&quot;\n输出: true</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: &quot;()[]{}&quot;\n输出: true</code></pre>\n<p>示例 3:</p>\n<pre><code>输入: &quot;(]&quot;\n输出: false</code></pre>\n<p>示例 4:</p>\n<pre><code>输入: &quot;([)]&quot;\n输出: false</code></pre>\n<p>示例 5:</p>\n<pre><code>输入: &quot;{[]}&quot;\n输出: true</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>用stack存储左括号,遇到括号则从栈顶取出,如果不匹配,则返回false.一直到最后,如果栈不为空,也返回false</p>\n<pre><code>//伪代码\nfor(ch in string)\n{\n    if(ch==&#39;(&#39; || ch==&#39;[&#39; || ch==&#39;{&#39;) \n    {\n        stack.push(ch);\n    }\n    else\n    {\n        if(stack.isEmpty() || stack.pop()!=ch) return false;\n    }\n    if(!stack.isEmpty()) return false;\n}</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意匹配条件,不是相等</li>\n<li>注意最后还要判断<code>stack.isEmpty()</code></li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Stack<span class=\"token operator\">&lt;</span>Character<span class=\"token operator\">></span> stack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ch <span class=\"token operator\">==</span> <span class=\"token string\">'('</span> <span class=\"token operator\">||</span> ch <span class=\"token operator\">==</span> <span class=\"token string\">'['</span> <span class=\"token operator\">||</span> ch <span class=\"token operator\">==</span> <span class=\"token string\">'{'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//look 是匹配,不是相等</span>\n            <span class=\"token comment\" spellcheck=\"true\">//if(stack.isEmpty() || stack.pop()!=ch) return false;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">char</span> temp <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">case</span> <span class=\"token string\">')'</span><span class=\"token operator\">:</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>temp <span class=\"token operator\">!=</span> <span class=\"token string\">'('</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">case</span> <span class=\"token string\">']'</span><span class=\"token operator\">:</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>temp <span class=\"token operator\">!=</span> <span class=\"token string\">'['</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">case</span> <span class=\"token string\">'}'</span><span class=\"token operator\">:</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>temp <span class=\"token operator\">!=</span> <span class=\"token string\">'{'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$ O(N) $,遍历字符串,并且每次遍历时只进行$ O(1) $的常数操作</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$ O(N) $,最坏情况下要把所有字符串都入栈,例如<code>((((((((</code></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\" target=\"_blank\" rel=\"noopener\">20. 有效的括号</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<p>左括号必须用相同类型的右括号闭合。<br>        左括号必须以正确的顺序闭合。<br>        注意空字符串可被认为是有效字符串。</p>\n<p>示例 1:</p>\n<pre><code>输入: &quot;()&quot;\n输出: true</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: &quot;()[]{}&quot;\n输出: true</code></pre>\n<p>示例 3:</p>\n<pre><code>输入: &quot;(]&quot;\n输出: false</code></pre>\n<p>示例 4:</p>\n<pre><code>输入: &quot;([)]&quot;\n输出: false</code></pre>\n<p>示例 5:</p>\n<pre><code>输入: &quot;{[]}&quot;\n输出: true</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>用stack存储左括号,遇到括号则从栈顶取出,如果不匹配,则返回false.一直到最后,如果栈不为空,也返回false</p>\n<pre><code>//伪代码\nfor(ch in string)\n{\n    if(ch==&#39;(&#39; || ch==&#39;[&#39; || ch==&#39;{&#39;) \n    {\n        stack.push(ch);\n    }\n    else\n    {\n        if(stack.isEmpty() || stack.pop()!=ch) return false;\n    }\n    if(!stack.isEmpty()) return false;\n}</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意匹配条件,不是相等</li>\n<li>注意最后还要判断<code>stack.isEmpty()</code></li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public boolean isValid(String s)\n{\n    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();\n    for (int i = 0; i &lt; s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        if (ch == &#39;(&#39; || ch == &#39;[&#39; || ch == &#39;{&#39;)\n        {\n            stack.push(ch);\n        }\n        else\n        {\n            //look 是匹配,不是相等\n            //if(stack.isEmpty() || stack.pop()!=ch) return false;\n            if (stack.isEmpty()) return false;\n\n            char temp = stack.pop();\n            switch (ch)\n            {\n                case &#39;)&#39;:\n                    if (temp != &#39;(&#39;) return false;\n                    break;\n                case &#39;]&#39;:\n                    if (temp != &#39;[&#39;) return false;\n                    break;\n                case &#39;}&#39;:\n                    if (temp != &#39;{&#39;) return false;\n                    break;\n            }\n\n        }\n    }\n    return stack.isEmpty();\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$ O(N) $,遍历字符串,并且每次遍历时只进行$ O(1) $的常数操作</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$ O(N) $,最坏情况下要把所有字符串都入栈,例如<code>((((((((</code></p>\n"},{"title":"LeetCode刷题笔记21","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"3781d157","date":"2020-04-01T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n \n\n示例：\n```\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n```\n\n\n# 细节\n如果迭代的想要更快,可以直接改指针指向原链表.但是这样指向同一条链表可能不太好\n\n# 代码\n```java\n//递归\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2)\n    {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n\n        ListNode result = null;\n\n        if(l1.val<l2.val)\n        {\n            result = new ListNode(l1.val);\n            result.next=mergeTwoLists(l1.next, l2);\n        }\n        else\n        {\n            result = new ListNode(l2.val);\n            result.next=mergeTwoLists(l1, l2.next);\n        }\n        return result;\n    }\n```\n```java\n//迭代\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2)\n    {\n        ListNode pre = new ListNode(-1), curr = pre;\n        while (l1 != null && l2 != null)\n        {\n            if (l1.val < l2.val)\n            {\n                ListNode temp = new ListNode(l1.val);\n                curr.next = temp;\n                curr = temp;\n                l1 = l1.next;\n            }\n            else\n            {\n                ListNode temp = new ListNode(l2.val);\n                curr.next = temp;\n                curr = temp;\n                l2 = l2.next;\n            }\n        }\n\n        while (l1 != null)\n        {\n            ListNode temp = new ListNode(l1.val);\n            curr.next = temp;\n            curr = temp;\n            l1 = l1.next;\n        }\n\n        while (l2 != null)\n        {\n            ListNode temp = new ListNode(l2.val);\n            curr.next = temp;\n            curr = temp;\n            l2 = l2.next;\n        }\n\n        return pre.next;\n    }\n```\n\n\n# 复杂度分析\n## 时间复杂度\n$ O(n + m) $,每次都会递归调用一个节点\n\n\n## 空间复杂度\n递归:$ O(n + m) $,递归调用需要消耗栈空间,递归调用最坏情况 `m+n` 次\n\t\t迭代:$ O(1) $ 只需要常数的空间存放若干变量","source":"_posts/LeetCode笔记/LeetCode刷题笔记_21_ 合并两个有序链表.md","raw":"---\ntitle: LeetCode刷题笔记21\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 链表\nabbrlink: 3781d157\ndate: 2020-04-02 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n \n\n示例：\n```\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n```\n\n\n# 细节\n如果迭代的想要更快,可以直接改指针指向原链表.但是这样指向同一条链表可能不太好\n\n# 代码\n```java\n//递归\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2)\n    {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n\n        ListNode result = null;\n\n        if(l1.val<l2.val)\n        {\n            result = new ListNode(l1.val);\n            result.next=mergeTwoLists(l1.next, l2);\n        }\n        else\n        {\n            result = new ListNode(l2.val);\n            result.next=mergeTwoLists(l1, l2.next);\n        }\n        return result;\n    }\n```\n```java\n//迭代\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2)\n    {\n        ListNode pre = new ListNode(-1), curr = pre;\n        while (l1 != null && l2 != null)\n        {\n            if (l1.val < l2.val)\n            {\n                ListNode temp = new ListNode(l1.val);\n                curr.next = temp;\n                curr = temp;\n                l1 = l1.next;\n            }\n            else\n            {\n                ListNode temp = new ListNode(l2.val);\n                curr.next = temp;\n                curr = temp;\n                l2 = l2.next;\n            }\n        }\n\n        while (l1 != null)\n        {\n            ListNode temp = new ListNode(l1.val);\n            curr.next = temp;\n            curr = temp;\n            l1 = l1.next;\n        }\n\n        while (l2 != null)\n        {\n            ListNode temp = new ListNode(l2.val);\n            curr.next = temp;\n            curr = temp;\n            l2 = l2.next;\n        }\n\n        return pre.next;\n    }\n```\n\n\n# 复杂度分析\n## 时间复杂度\n$ O(n + m) $,每次都会递归调用一个节点\n\n\n## 空间复杂度\n递归:$ O(n + m) $,递归调用需要消耗栈空间,递归调用最坏情况 `m+n` 次\n\t\t迭代:$ O(1) $ 只需要常数的空间存放若干变量","slug":"LeetCode笔记/LeetCode刷题笔记_21_ 合并两个有序链表","published":1,"updated":"2020-11-12T11:57:29.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6y9005zjotpf1e52ngn","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">21. 合并两个有序链表</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>\n<p> </p>\n<p>示例：</p>\n<pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4\n输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>如果迭代的想要更快,可以直接改指针指向原链表.但是这样指向同一条链表可能不太好</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//递归</span>\n    <span class=\"token keyword\">public</span> ListNode <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>ListNode l1<span class=\"token punctuation\">,</span> ListNode l2<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l1<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> l2<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l2<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> l1<span class=\"token punctuation\">;</span>\n\n        ListNode result <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>val<span class=\"token operator\">&lt;</span>l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            result<span class=\"token punctuation\">.</span>next<span class=\"token operator\">=</span><span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span>l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            result<span class=\"token punctuation\">.</span>next<span class=\"token operator\">=</span><span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//迭代</span>\n    <span class=\"token keyword\">public</span> ListNode <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>ListNode l1<span class=\"token punctuation\">,</span> ListNode l2<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        ListNode pre <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> curr <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l1 <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> l2 <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;</span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                ListNode temp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                curr<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n                curr <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n                l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">{</span>\n                ListNode temp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span>l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                curr<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n                curr <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n                l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l1 <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            ListNode temp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            curr<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n            curr <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n            l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l2 <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            ListNode temp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span>l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            curr<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n            curr <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n            l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> pre<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$ O(n + m) $,每次都会递归调用一个节点</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>递归:$ O(n + m) $,递归调用需要消耗栈空间,递归调用最坏情况 <code>m+n</code> 次<br>        迭代:$ O(1) $ 只需要常数的空间存放若干变量</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">21. 合并两个有序链表</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>\n<p> </p>\n<p>示例：</p>\n<pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4\n输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>如果迭代的想要更快,可以直接改指针指向原链表.但是这样指向同一条链表可能不太好</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">//递归\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2)\n    {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n\n        ListNode result = null;\n\n        if(l1.val&lt;l2.val)\n        {\n            result = new ListNode(l1.val);\n            result.next=mergeTwoLists(l1.next, l2);\n        }\n        else\n        {\n            result = new ListNode(l2.val);\n            result.next=mergeTwoLists(l1, l2.next);\n        }\n        return result;\n    }</code></pre>\n<pre><code class=\"java\">//迭代\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2)\n    {\n        ListNode pre = new ListNode(-1), curr = pre;\n        while (l1 != null &amp;&amp; l2 != null)\n        {\n            if (l1.val &lt; l2.val)\n            {\n                ListNode temp = new ListNode(l1.val);\n                curr.next = temp;\n                curr = temp;\n                l1 = l1.next;\n            }\n            else\n            {\n                ListNode temp = new ListNode(l2.val);\n                curr.next = temp;\n                curr = temp;\n                l2 = l2.next;\n            }\n        }\n\n        while (l1 != null)\n        {\n            ListNode temp = new ListNode(l1.val);\n            curr.next = temp;\n            curr = temp;\n            l1 = l1.next;\n        }\n\n        while (l2 != null)\n        {\n            ListNode temp = new ListNode(l2.val);\n            curr.next = temp;\n            curr = temp;\n            l2 = l2.next;\n        }\n\n        return pre.next;\n    }</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$ O(n + m) $,每次都会递归调用一个节点</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>递归:$ O(n + m) $,递归调用需要消耗栈空间,递归调用最坏情况 <code>m+n</code> 次<br>        迭代:$ O(1) $ 只需要常数的空间存放若干变量</p>\n"},{"title":"LeetCode刷题笔记_208_实现 Trie (前缀树)","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"LeetCode刷题笔记","abbrlink":"f5d941ba","date":"2020-06-13T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n```java\n实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。\n\n示例:\n\nTrie trie = new Trie();\n\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // 返回 true\ntrie.search(\"app\");     // 返回 false\ntrie.startsWith(\"app\"); // 返回 true\ntrie.insert(\"app\");   \ntrie.search(\"app\");     // 返回 true\n说明:\n\n你可以假设所有的输入都是由小写字母 a-z 构成的。\n保证所有输入均为非空字符串。\n```\n\n# 思路\n\n使用`26叉树`的结构,每当有一个单词加进来,就顺着路径不断的初始化`Node`,并且在最后一个`Node`出赋值,代表单词的结束。\n\n查找过程即根据单词每个字符对应的数组下标，不断在**单词搜索树中查询**，如果找到为空的`Node`，或者结尾处为-1，代表这个单词不存在。\n\n查找前缀过程和查找过程一样，**只是他不要求前缀结尾部分的Node值为-1**\n\n# \n\n\n# 代码\n\n```java\npublic class Demo208\n{\n    private Node root;\n\n    private class Node\n    {\n        int value;\n        Node [] next;\n\n        public Node()\n        {\n            this.value = -1;\n            this.next = new Node[26];\n        }\n    }\n    public Demo208()\n    {\n        root = new Node();\n    }\n\n    public void insert(String word)\n    {\n        Node temp = root;\n        for (char ch : word.toCharArray())\n        {\n            int index = ch - 'a';\n            if(temp.next[index]==null) temp.next[index] = new Node();\n            temp = temp.next[index];\n        }\n        temp.value = 1;\n    }\n\n    public boolean search(String word)\n    {\n        Node temp = root;\n        for (char ch : word.toCharArray())\n        {\n            int index = ch - 'a';\n            if(temp.next[index]==null) return false;\n            temp = temp.next[index];\n        }\n        return temp.value == 1;\n    }\n\n    public boolean startsWith(String prefix)\n    {\n        Node temp = root;\n        for (char ch : prefix.toCharArray())\n        {\n            int index = ch - 'a';\n            if(temp.next[index]==null) return false;\n            temp = temp.next[index];\n        }\n        return true;\n    }\n}\n```","source":"_posts/LeetCode笔记/LeetCode刷题笔记_208. 实现 Trie (前缀树).md","raw":"---\ntitle: LeetCode刷题笔记_208_实现 Trie (前缀树)\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 字符串\n  - 树\nabbrlink: f5d941ba\ndate: 2020-06-14 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n```java\n实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。\n\n示例:\n\nTrie trie = new Trie();\n\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // 返回 true\ntrie.search(\"app\");     // 返回 false\ntrie.startsWith(\"app\"); // 返回 true\ntrie.insert(\"app\");   \ntrie.search(\"app\");     // 返回 true\n说明:\n\n你可以假设所有的输入都是由小写字母 a-z 构成的。\n保证所有输入均为非空字符串。\n```\n\n# 思路\n\n使用`26叉树`的结构,每当有一个单词加进来,就顺着路径不断的初始化`Node`,并且在最后一个`Node`出赋值,代表单词的结束。\n\n查找过程即根据单词每个字符对应的数组下标，不断在**单词搜索树中查询**，如果找到为空的`Node`，或者结尾处为-1，代表这个单词不存在。\n\n查找前缀过程和查找过程一样，**只是他不要求前缀结尾部分的Node值为-1**\n\n# \n\n\n# 代码\n\n```java\npublic class Demo208\n{\n    private Node root;\n\n    private class Node\n    {\n        int value;\n        Node [] next;\n\n        public Node()\n        {\n            this.value = -1;\n            this.next = new Node[26];\n        }\n    }\n    public Demo208()\n    {\n        root = new Node();\n    }\n\n    public void insert(String word)\n    {\n        Node temp = root;\n        for (char ch : word.toCharArray())\n        {\n            int index = ch - 'a';\n            if(temp.next[index]==null) temp.next[index] = new Node();\n            temp = temp.next[index];\n        }\n        temp.value = 1;\n    }\n\n    public boolean search(String word)\n    {\n        Node temp = root;\n        for (char ch : word.toCharArray())\n        {\n            int index = ch - 'a';\n            if(temp.next[index]==null) return false;\n            temp = temp.next[index];\n        }\n        return temp.value == 1;\n    }\n\n    public boolean startsWith(String prefix)\n    {\n        Node temp = root;\n        for (char ch : prefix.toCharArray())\n        {\n            int index = ch - 'a';\n            if(temp.next[index]==null) return false;\n            temp = temp.next[index];\n        }\n        return true;\n    }\n}\n```","slug":"LeetCode笔记/LeetCode刷题笔记_208. 实现 Trie (前缀树)","published":1,"updated":"2021-02-04T00:46:12.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6ya0062jotp4m2u7ezk","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/implement-trie-prefix-tree/\" target=\"_blank\" rel=\"noopener\">208. 实现 Trie (前缀树)</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><pre class=\" language-java\"><code class=\"language-java\">实现一个 <span class=\"token function\">Trie</span> <span class=\"token punctuation\">(</span>前缀树<span class=\"token punctuation\">)</span>，包含 insert<span class=\"token punctuation\">,</span> search<span class=\"token punctuation\">,</span> 和 startsWith 这三个操作。\n\n示例<span class=\"token operator\">:</span>\n\nTrie trie <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Trie</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ntrie<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntrie<span class=\"token punctuation\">.</span><span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// 返回 true</span>\ntrie<span class=\"token punctuation\">.</span><span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// 返回 false</span>\ntrie<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 返回 true</span>\ntrie<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \ntrie<span class=\"token punctuation\">.</span><span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// 返回 true</span>\n说明<span class=\"token operator\">:</span>\n\n你可以假设所有的输入都是由小写字母 a<span class=\"token operator\">-</span>z 构成的。\n保证所有输入均为非空字符串。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>使用<code>26叉树</code>的结构,每当有一个单词加进来,就顺着路径不断的初始化<code>Node</code>,并且在最后一个<code>Node</code>出赋值,代表单词的结束。</p>\n<p>查找过程即根据单词每个字符对应的数组下标，不断在<strong>单词搜索树中查询</strong>，如果找到为空的<code>Node</code>，或者结尾处为-1，代表这个单词不存在。</p>\n<p>查找前缀过程和查找过程一样，<strong>只是他不要求前缀结尾部分的Node值为-1</strong></p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo208</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Node root<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span>\n        Node <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> next<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">[</span><span class=\"token number\">26</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Demo208</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        root <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>String word<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Node temp <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> ch <span class=\"token operator\">:</span> word<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> ch <span class=\"token operator\">-</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span> temp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            temp <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        temp<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>String word<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Node temp <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> ch <span class=\"token operator\">:</span> word<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> ch <span class=\"token operator\">-</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            temp <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> temp<span class=\"token punctuation\">.</span>value <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span>String prefix<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Node temp <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> ch <span class=\"token operator\">:</span> prefix<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> ch <span class=\"token operator\">-</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            temp <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/implement-trie-prefix-tree/\" target=\"_blank\" rel=\"noopener\">208. 实现 Trie (前缀树)</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><pre><code class=\"java\">实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。\n\n示例:\n\nTrie trie = new Trie();\n\ntrie.insert(&quot;apple&quot;);\ntrie.search(&quot;apple&quot;);   // 返回 true\ntrie.search(&quot;app&quot;);     // 返回 false\ntrie.startsWith(&quot;app&quot;); // 返回 true\ntrie.insert(&quot;app&quot;);   \ntrie.search(&quot;app&quot;);     // 返回 true\n说明:\n\n你可以假设所有的输入都是由小写字母 a-z 构成的。\n保证所有输入均为非空字符串。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>使用<code>26叉树</code>的结构,每当有一个单词加进来,就顺着路径不断的初始化<code>Node</code>,并且在最后一个<code>Node</code>出赋值,代表单词的结束。</p>\n<p>查找过程即根据单词每个字符对应的数组下标，不断在<strong>单词搜索树中查询</strong>，如果找到为空的<code>Node</code>，或者结尾处为-1，代表这个单词不存在。</p>\n<p>查找前缀过程和查找过程一样，<strong>只是他不要求前缀结尾部分的Node值为-1</strong></p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public class Demo208\n{\n    private Node root;\n\n    private class Node\n    {\n        int value;\n        Node [] next;\n\n        public Node()\n        {\n            this.value = -1;\n            this.next = new Node[26];\n        }\n    }\n    public Demo208()\n    {\n        root = new Node();\n    }\n\n    public void insert(String word)\n    {\n        Node temp = root;\n        for (char ch : word.toCharArray())\n        {\n            int index = ch - &#39;a&#39;;\n            if(temp.next[index]==null) temp.next[index] = new Node();\n            temp = temp.next[index];\n        }\n        temp.value = 1;\n    }\n\n    public boolean search(String word)\n    {\n        Node temp = root;\n        for (char ch : word.toCharArray())\n        {\n            int index = ch - &#39;a&#39;;\n            if(temp.next[index]==null) return false;\n            temp = temp.next[index];\n        }\n        return temp.value == 1;\n    }\n\n    public boolean startsWith(String prefix)\n    {\n        Node temp = root;\n        for (char ch : prefix.toCharArray())\n        {\n            int index = ch - &#39;a&#39;;\n            if(temp.next[index]==null) return false;\n            temp = temp.next[index];\n        }\n        return true;\n    }\n}</code></pre>\n"},{"title":"LeetCode刷题笔记221._最大正方形","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"LeetCode刷题笔记","abbrlink":"7b573481","date":"2020-06-14T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。\n```java\n示例:\n\n输入: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\n输出: 4\n```\n\n\n# 思路\n1. 采用动态规划的思想,`dp[i][j]`代表最大的正方形边长,从左到右,从上到下进行扫描\n2. 或者可以采用处理这种问题的通用方法,即定义`height,left,right`数组,逐层扫描,逐层计算result\n\n# 细节\n\n## 方法1\n\n1. 初始化为:`int[][] dp = new int[m + 1][n + 1];`,这样可以不需要再处理初始的边界问题\n2. 动态规划递推公式为:` dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;`,因为是正方形,所以需要他左,上,左上三个角都有才能构成更大的正方形。\n\n## 方法2\n\n1. 在对每一层处理时，首先要考虑他们和上一层的关系\n2. `left`数组是从左往右处理，`right`数组是从右往左处理\n3. 小心处理当`matrix[i][j]==0`的情况，要考虑对下层的影响。例如当`matrix[i][j]==0`，需要让`left[j] = 0`，以便下层缩小范围。\n\n\n\n# 代码\n\n## 方法1\n\n```java\npublic int maximalSquare(char[][] matrix)\n{\n    if (matrix.length == 0) return 0;\n    int m = matrix.length, n = matrix[0].length;\n    int result = 0;\n    int[][] dp = new int[m + 1][n + 1];//dp[i][j]代表最大的正方形边长\n    for (int i = 1; i <= m; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            if(matrix[i-1][j-1]=='1')\n            {\n                dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\n                result = Math.max(result, dp[i][j] * dp[i][j]);\n            }\n        }\n    }\n\n    return result;\n}\n```\n\n## 方法2\n\n```java\npublic int maximalSquare(char[][] matrix)\n{\n    if (matrix.length == 0) return 0;\n    int m = matrix.length, n = matrix[0].length;\n    int result = 0;\n    int[] height = new int[n];\n    int[] left = new int[n];\n    int[] right = new int[n];\n\n    for (int i = 0; i < n; i++) right[i] = n; //look\n\n    for (int i = 0; i < m; i++)\n    {\n        //对height赋值\n        for (int j = 0; j < n; j++)\n        {\n            if (matrix[i][j] == '1') height[j] += 1;\n            else height[j] = 0;\n        }\n\n        //对left赋值\n        int leftIndex = 0;\n        for (int j = 0; j < n; j++)\n        {\n            if (matrix[i][j] == '1')\n            {\n                //继承上一个的\n                left[j] = Math.max(leftIndex,left[j]);\n            }\n            else\n            {\n                left[j] = 0;//考虑下面继承他的范围,就要放宽\n                leftIndex = j + 1;\n            }\n        }\n\n        //right赋值\n        int rightIndex = n;\n        for(int j = n-1; j >= 0; j--)\n        {\n            if (matrix[i][j] == '1')\n            {\n                right[j] = Math.min(rightIndex,right[j]);\n            }\n            else\n            {\n                right[j] = n;\n                rightIndex = j;\n            }\n        }\n\n        //计算正方形\n        for (int j = 0; j < n; j++)\n        {\n            int value = Math.min(right[j] - left[j], height[j]);\n            result = Math.max(result, value * value);\n        }\n    }\n\n    return result;\n}\n```","source":"_posts/LeetCode笔记/LeetCode刷题笔记_221. 最大正方形.md","raw":"---\ntitle: LeetCode刷题笔记221._最大正方形\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 动态规划\n  - 二维数组\nabbrlink: 7b573481\ndate: 2020-06-15 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。\n```java\n示例:\n\n输入: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\n输出: 4\n```\n\n\n# 思路\n1. 采用动态规划的思想,`dp[i][j]`代表最大的正方形边长,从左到右,从上到下进行扫描\n2. 或者可以采用处理这种问题的通用方法,即定义`height,left,right`数组,逐层扫描,逐层计算result\n\n# 细节\n\n## 方法1\n\n1. 初始化为:`int[][] dp = new int[m + 1][n + 1];`,这样可以不需要再处理初始的边界问题\n2. 动态规划递推公式为:` dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;`,因为是正方形,所以需要他左,上,左上三个角都有才能构成更大的正方形。\n\n## 方法2\n\n1. 在对每一层处理时，首先要考虑他们和上一层的关系\n2. `left`数组是从左往右处理，`right`数组是从右往左处理\n3. 小心处理当`matrix[i][j]==0`的情况，要考虑对下层的影响。例如当`matrix[i][j]==0`，需要让`left[j] = 0`，以便下层缩小范围。\n\n\n\n# 代码\n\n## 方法1\n\n```java\npublic int maximalSquare(char[][] matrix)\n{\n    if (matrix.length == 0) return 0;\n    int m = matrix.length, n = matrix[0].length;\n    int result = 0;\n    int[][] dp = new int[m + 1][n + 1];//dp[i][j]代表最大的正方形边长\n    for (int i = 1; i <= m; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            if(matrix[i-1][j-1]=='1')\n            {\n                dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\n                result = Math.max(result, dp[i][j] * dp[i][j]);\n            }\n        }\n    }\n\n    return result;\n}\n```\n\n## 方法2\n\n```java\npublic int maximalSquare(char[][] matrix)\n{\n    if (matrix.length == 0) return 0;\n    int m = matrix.length, n = matrix[0].length;\n    int result = 0;\n    int[] height = new int[n];\n    int[] left = new int[n];\n    int[] right = new int[n];\n\n    for (int i = 0; i < n; i++) right[i] = n; //look\n\n    for (int i = 0; i < m; i++)\n    {\n        //对height赋值\n        for (int j = 0; j < n; j++)\n        {\n            if (matrix[i][j] == '1') height[j] += 1;\n            else height[j] = 0;\n        }\n\n        //对left赋值\n        int leftIndex = 0;\n        for (int j = 0; j < n; j++)\n        {\n            if (matrix[i][j] == '1')\n            {\n                //继承上一个的\n                left[j] = Math.max(leftIndex,left[j]);\n            }\n            else\n            {\n                left[j] = 0;//考虑下面继承他的范围,就要放宽\n                leftIndex = j + 1;\n            }\n        }\n\n        //right赋值\n        int rightIndex = n;\n        for(int j = n-1; j >= 0; j--)\n        {\n            if (matrix[i][j] == '1')\n            {\n                right[j] = Math.min(rightIndex,right[j]);\n            }\n            else\n            {\n                right[j] = n;\n                rightIndex = j;\n            }\n        }\n\n        //计算正方形\n        for (int j = 0; j < n; j++)\n        {\n            int value = Math.min(right[j] - left[j], height[j]);\n            result = Math.max(result, value * value);\n        }\n    }\n\n    return result;\n}\n```","slug":"LeetCode笔记/LeetCode刷题笔记_221. 最大正方形","published":1,"updated":"2021-02-04T00:45:58.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yb0066jotphl2u0mqf","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximal-square/\" target=\"_blank\" rel=\"noopener\">221. 最大正方形</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>\n<pre class=\" language-java\"><code class=\"language-java\">示例<span class=\"token operator\">:</span>\n\n输入<span class=\"token operator\">:</span> \n\n<span class=\"token number\">1</span> <span class=\"token number\">0</span> <span class=\"token number\">1</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span>\n<span class=\"token number\">1</span> <span class=\"token number\">0</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span>\n<span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span>\n<span class=\"token number\">1</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">1</span> <span class=\"token number\">0</span>\n\n输出<span class=\"token operator\">:</span> <span class=\"token number\">4</span></code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ol>\n<li>采用动态规划的思想,<code>dp[i][j]</code>代表最大的正方形边长,从左到右,从上到下进行扫描</li>\n<li>或者可以采用处理这种问题的通用方法,即定义<code>height,left,right</code>数组,逐层扫描,逐层计算result</li>\n</ol>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><h2 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h2><ol>\n<li>初始化为:<code>int[][] dp = new int[m + 1][n + 1];</code>,这样可以不需要再处理初始的边界问题</li>\n<li>动态规划递推公式为:<code> dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;</code>,因为是正方形,所以需要他左,上,左上三个角都有才能构成更大的正方形。</li>\n</ol>\n<h2 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h2><ol>\n<li>在对每一层处理时，首先要考虑他们和上一层的关系</li>\n<li><code>left</code>数组是从左往右处理，<code>right</code>数组是从右往左处理</li>\n<li>小心处理当<code>matrix[i][j]==0</code>的情况，要考虑对下层的影响。例如当<code>matrix[i][j]==0</code>，需要让<code>left[j] = 0</code>，以便下层缩小范围。</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><h2 id=\"方法1-1\"><a href=\"#方法1-1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maximalSquare</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> matrix<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> matrix<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> dp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//dp[i][j]代表最大的正方形边长</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dp<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"方法2-1\"><a href=\"#方法2-1\" class=\"headerlink\" title=\"方法2\"></a>方法2</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maximalSquare</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> matrix<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> matrix<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> height <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> left <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> right <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> right<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//look</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//对height赋值</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span> height<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> height<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//对left赋值</span>\n        <span class=\"token keyword\">int</span> leftIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//继承上一个的</span>\n                left<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>leftIndex<span class=\"token punctuation\">,</span>left<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">{</span>\n                left<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//考虑下面继承他的范围,就要放宽</span>\n                leftIndex <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//right赋值</span>\n        <span class=\"token keyword\">int</span> rightIndex <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                right<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>rightIndex<span class=\"token punctuation\">,</span>right<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">{</span>\n                right<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n                rightIndex <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//计算正方形</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> left<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> value <span class=\"token operator\">*</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximal-square/\" target=\"_blank\" rel=\"noopener\">221. 最大正方形</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>\n<pre><code class=\"java\">示例:\n\n输入: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\n输出: 4</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ol>\n<li>采用动态规划的思想,<code>dp[i][j]</code>代表最大的正方形边长,从左到右,从上到下进行扫描</li>\n<li>或者可以采用处理这种问题的通用方法,即定义<code>height,left,right</code>数组,逐层扫描,逐层计算result</li>\n</ol>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><h2 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h2><ol>\n<li>初始化为:<code>int[][] dp = new int[m + 1][n + 1];</code>,这样可以不需要再处理初始的边界问题</li>\n<li>动态规划递推公式为:<code> dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;</code>,因为是正方形,所以需要他左,上,左上三个角都有才能构成更大的正方形。</li>\n</ol>\n<h2 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h2><ol>\n<li>在对每一层处理时，首先要考虑他们和上一层的关系</li>\n<li><code>left</code>数组是从左往右处理，<code>right</code>数组是从右往左处理</li>\n<li>小心处理当<code>matrix[i][j]==0</code>的情况，要考虑对下层的影响。例如当<code>matrix[i][j]==0</code>，需要让<code>left[j] = 0</code>，以便下层缩小范围。</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><h2 id=\"方法1-1\"><a href=\"#方法1-1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h2><pre><code class=\"java\">public int maximalSquare(char[][] matrix)\n{\n    if (matrix.length == 0) return 0;\n    int m = matrix.length, n = matrix[0].length;\n    int result = 0;\n    int[][] dp = new int[m + 1][n + 1];//dp[i][j]代表最大的正方形边长\n    for (int i = 1; i &lt;= m; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if(matrix[i-1][j-1]==&#39;1&#39;)\n            {\n                dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\n                result = Math.max(result, dp[i][j] * dp[i][j]);\n            }\n        }\n    }\n\n    return result;\n}</code></pre>\n<h2 id=\"方法2-1\"><a href=\"#方法2-1\" class=\"headerlink\" title=\"方法2\"></a>方法2</h2><pre><code class=\"java\">public int maximalSquare(char[][] matrix)\n{\n    if (matrix.length == 0) return 0;\n    int m = matrix.length, n = matrix[0].length;\n    int result = 0;\n    int[] height = new int[n];\n    int[] left = new int[n];\n    int[] right = new int[n];\n\n    for (int i = 0; i &lt; n; i++) right[i] = n; //look\n\n    for (int i = 0; i &lt; m; i++)\n    {\n        //对height赋值\n        for (int j = 0; j &lt; n; j++)\n        {\n            if (matrix[i][j] == &#39;1&#39;) height[j] += 1;\n            else height[j] = 0;\n        }\n\n        //对left赋值\n        int leftIndex = 0;\n        for (int j = 0; j &lt; n; j++)\n        {\n            if (matrix[i][j] == &#39;1&#39;)\n            {\n                //继承上一个的\n                left[j] = Math.max(leftIndex,left[j]);\n            }\n            else\n            {\n                left[j] = 0;//考虑下面继承他的范围,就要放宽\n                leftIndex = j + 1;\n            }\n        }\n\n        //right赋值\n        int rightIndex = n;\n        for(int j = n-1; j &gt;= 0; j--)\n        {\n            if (matrix[i][j] == &#39;1&#39;)\n            {\n                right[j] = Math.min(rightIndex,right[j]);\n            }\n            else\n            {\n                right[j] = n;\n                rightIndex = j;\n            }\n        }\n\n        //计算正方形\n        for (int j = 0; j &lt; n; j++)\n        {\n            int value = Math.min(right[j] - left[j], height[j]);\n            result = Math.max(result, value * value);\n        }\n    }\n\n    return result;\n}</code></pre>\n"},{"title":"LeetCode刷题笔记22","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"ae8880ed","date":"2020-04-02T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n \n\n示例：\n```\n输入：n = 3\n输出：[\n       \"((()))\",\n       \"(()())\",\n       \"(())()\",\n       \"()(())\",\n       \"()()()\"\n     ]\n```\n\n# 思路\n\n回溯法.可以画出解空间树，加剪枝帮助理解。\n\n```java\nrecursive(n,n)//左括号个数，右括号个数开始都为n\n    \nrecursive(leftCount,rightCount)\n{\n    if(rightCount<leftCount) return; //限定条件 说明)比(多\n    if(rightCount==0 && leftCount==0) result.add(stringBuilder);\n    \n    if(leftCount>0)//限定条件 说明(用完了\n    {\n        stringBuilder.append('(');\n        recursive(leftCount-1,rightCount);//往左走，即往结果加个（\n        移除stringBuilder刚加入的元素，即返回到父节点\n    }\n    if(rightCount>0) //限定条件 说明)用完了\n    {\n        stringBuilder.append(')');\n        recursive(leftCount,rightCount-1);//往右走，即往结果加个）\n        移除stringBuilder刚加入的元素，即返回到父节点\n    }\n}\n```\n\n\n\n# 细节\n\n1. 注意n=0的返回值\n2. 注意递归返回时，要把stringBuilder刚加入的元素清除。画解空间树就一目了然\n\n\n# 代码\n\n```java\npublic class Demo22\n{\n    private List<String> result = new LinkedList<>();\n    private StringBuilder stringBuilder = new StringBuilder();\n\n    public List<String> generateParenthesis(int n)\n    {\n        if(n==0) return result; //n==0,返回的是空集合,不是空字符串\n        dfs(n, n);//左括号个数，右括号个数开始都为n\n        return result;\n    }\n\n    public void dfs(int leftCount, int rightCount)\n    {\n        if(rightCount<leftCount) return; //限定条件 说明)比(多\n        if(rightCount==0 && leftCount==0) result.add(stringBuilder.toString());\n\n        if(leftCount>0)//限定条件 说明(用完了\n        {\n            stringBuilder.append('(');\n            dfs(leftCount-1,rightCount);//往左走，即往结果加个（\n            stringBuilder.deleteCharAt(stringBuilder.length() - 1);//回到上一层,父节点\n        }\n        if(rightCount>0) //限定条件 说明)用完了\n        {\n            stringBuilder.append(')');\n            dfs(leftCount,rightCount-1);//往右走，即往结果加个）\n            stringBuilder.deleteCharAt(stringBuilder.length() - 1);//回到上一层,父节点\n        }\n    }\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$ O(4^n/\\sqrt n) $\n\n## 空间复杂度\n\n空间复杂度：O(n)，除了result之外，所需空间取决于递归栈的深度，每一层递归函数需要 O(1)的空间，最多递归 2n 层，因此空间复杂度为 O(n)。\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_22_括号生成.md","raw":"---\ntitle: LeetCode刷题笔记22\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 递归\nabbrlink: ae8880ed\ndate: 2020-04-03 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n \n\n示例：\n```\n输入：n = 3\n输出：[\n       \"((()))\",\n       \"(()())\",\n       \"(())()\",\n       \"()(())\",\n       \"()()()\"\n     ]\n```\n\n# 思路\n\n回溯法.可以画出解空间树，加剪枝帮助理解。\n\n```java\nrecursive(n,n)//左括号个数，右括号个数开始都为n\n    \nrecursive(leftCount,rightCount)\n{\n    if(rightCount<leftCount) return; //限定条件 说明)比(多\n    if(rightCount==0 && leftCount==0) result.add(stringBuilder);\n    \n    if(leftCount>0)//限定条件 说明(用完了\n    {\n        stringBuilder.append('(');\n        recursive(leftCount-1,rightCount);//往左走，即往结果加个（\n        移除stringBuilder刚加入的元素，即返回到父节点\n    }\n    if(rightCount>0) //限定条件 说明)用完了\n    {\n        stringBuilder.append(')');\n        recursive(leftCount,rightCount-1);//往右走，即往结果加个）\n        移除stringBuilder刚加入的元素，即返回到父节点\n    }\n}\n```\n\n\n\n# 细节\n\n1. 注意n=0的返回值\n2. 注意递归返回时，要把stringBuilder刚加入的元素清除。画解空间树就一目了然\n\n\n# 代码\n\n```java\npublic class Demo22\n{\n    private List<String> result = new LinkedList<>();\n    private StringBuilder stringBuilder = new StringBuilder();\n\n    public List<String> generateParenthesis(int n)\n    {\n        if(n==0) return result; //n==0,返回的是空集合,不是空字符串\n        dfs(n, n);//左括号个数，右括号个数开始都为n\n        return result;\n    }\n\n    public void dfs(int leftCount, int rightCount)\n    {\n        if(rightCount<leftCount) return; //限定条件 说明)比(多\n        if(rightCount==0 && leftCount==0) result.add(stringBuilder.toString());\n\n        if(leftCount>0)//限定条件 说明(用完了\n        {\n            stringBuilder.append('(');\n            dfs(leftCount-1,rightCount);//往左走，即往结果加个（\n            stringBuilder.deleteCharAt(stringBuilder.length() - 1);//回到上一层,父节点\n        }\n        if(rightCount>0) //限定条件 说明)用完了\n        {\n            stringBuilder.append(')');\n            dfs(leftCount,rightCount-1);//往右走，即往结果加个）\n            stringBuilder.deleteCharAt(stringBuilder.length() - 1);//回到上一层,父节点\n        }\n    }\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$ O(4^n/\\sqrt n) $\n\n## 空间复杂度\n\n空间复杂度：O(n)，除了result之外，所需空间取决于递归栈的深度，每一层递归函数需要 O(1)的空间，最多递归 2n 层，因此空间复杂度为 O(n)。\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_22_括号生成","published":1,"updated":"2020-11-12T11:57:29.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yc0069jotp71wtgoad","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/generate-parentheses/\" target=\"_blank\" rel=\"noopener\">22. 括号生成</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>\n<p> </p>\n<p>示例：</p>\n<pre><code>输入：n = 3\n输出：[\n       &quot;((()))&quot;,\n       &quot;(()())&quot;,\n       &quot;(())()&quot;,\n       &quot;()(())&quot;,\n       &quot;()()()&quot;\n     ]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>回溯法.可以画出解空间树，加剪枝帮助理解。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//左括号个数，右括号个数开始都为n</span>\n\n<span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>leftCount<span class=\"token punctuation\">,</span>rightCount<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>rightCount<span class=\"token operator\">&lt;</span>leftCount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//限定条件 说明)比(多</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>rightCount<span class=\"token operator\">==</span><span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> leftCount<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>stringBuilder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>leftCount<span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//限定条件 说明(用完了</span>\n    <span class=\"token punctuation\">{</span>\n        stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">'('</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>leftCount<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>rightCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//往左走，即往结果加个（</span>\n        移除stringBuilder刚加入的元素，即返回到父节点\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>rightCount<span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//限定条件 说明)用完了</span>\n    <span class=\"token punctuation\">{</span>\n        stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">')'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>leftCount<span class=\"token punctuation\">,</span>rightCount<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//往右走，即往结果加个）</span>\n        移除stringBuilder刚加入的元素，即返回到父节点\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意n=0的返回值</li>\n<li>注意递归返回时，要把stringBuilder刚加入的元素清除。画解空间树就一目了然</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo22</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> StringBuilder stringBuilder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token function\">generateParenthesis</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//n==0,返回的是空集合,不是空字符串</span>\n        <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//左括号个数，右括号个数开始都为n</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> leftCount<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> rightCount<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>rightCount<span class=\"token operator\">&lt;</span>leftCount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//限定条件 说明)比(多</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>rightCount<span class=\"token operator\">==</span><span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> leftCount<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>leftCount<span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//限定条件 说明(用完了</span>\n        <span class=\"token punctuation\">{</span>\n            stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">'('</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>leftCount<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>rightCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//往左走，即往结果加个（</span>\n            stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">deleteCharAt</span><span class=\"token punctuation\">(</span>stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//回到上一层,父节点</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>rightCount<span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//限定条件 说明)用完了</span>\n        <span class=\"token punctuation\">{</span>\n            stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">')'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>leftCount<span class=\"token punctuation\">,</span>rightCount<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//往右走，即往结果加个）</span>\n            stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">deleteCharAt</span><span class=\"token punctuation\">(</span>stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//回到上一层,父节点</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$ O(4^n/\\sqrt n) $</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>空间复杂度：O(n)，除了result之外，所需空间取决于递归栈的深度，每一层递归函数需要 O(1)的空间，最多递归 2n 层，因此空间复杂度为 O(n)。</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/generate-parentheses/\" target=\"_blank\" rel=\"noopener\">22. 括号生成</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>\n<p> </p>\n<p>示例：</p>\n<pre><code>输入：n = 3\n输出：[\n       &quot;((()))&quot;,\n       &quot;(()())&quot;,\n       &quot;(())()&quot;,\n       &quot;()(())&quot;,\n       &quot;()()()&quot;\n     ]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>回溯法.可以画出解空间树，加剪枝帮助理解。</p>\n<pre><code class=\"java\">recursive(n,n)//左括号个数，右括号个数开始都为n\n\nrecursive(leftCount,rightCount)\n{\n    if(rightCount&lt;leftCount) return; //限定条件 说明)比(多\n    if(rightCount==0 &amp;&amp; leftCount==0) result.add(stringBuilder);\n\n    if(leftCount&gt;0)//限定条件 说明(用完了\n    {\n        stringBuilder.append(&#39;(&#39;);\n        recursive(leftCount-1,rightCount);//往左走，即往结果加个（\n        移除stringBuilder刚加入的元素，即返回到父节点\n    }\n    if(rightCount&gt;0) //限定条件 说明)用完了\n    {\n        stringBuilder.append(&#39;)&#39;);\n        recursive(leftCount,rightCount-1);//往右走，即往结果加个）\n        移除stringBuilder刚加入的元素，即返回到父节点\n    }\n}</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意n=0的返回值</li>\n<li>注意递归返回时，要把stringBuilder刚加入的元素清除。画解空间树就一目了然</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public class Demo22\n{\n    private List&lt;String&gt; result = new LinkedList&lt;&gt;();\n    private StringBuilder stringBuilder = new StringBuilder();\n\n    public List&lt;String&gt; generateParenthesis(int n)\n    {\n        if(n==0) return result; //n==0,返回的是空集合,不是空字符串\n        dfs(n, n);//左括号个数，右括号个数开始都为n\n        return result;\n    }\n\n    public void dfs(int leftCount, int rightCount)\n    {\n        if(rightCount&lt;leftCount) return; //限定条件 说明)比(多\n        if(rightCount==0 &amp;&amp; leftCount==0) result.add(stringBuilder.toString());\n\n        if(leftCount&gt;0)//限定条件 说明(用完了\n        {\n            stringBuilder.append(&#39;(&#39;);\n            dfs(leftCount-1,rightCount);//往左走，即往结果加个（\n            stringBuilder.deleteCharAt(stringBuilder.length() - 1);//回到上一层,父节点\n        }\n        if(rightCount&gt;0) //限定条件 说明)用完了\n        {\n            stringBuilder.append(&#39;)&#39;);\n            dfs(leftCount,rightCount-1);//往右走，即往结果加个）\n            stringBuilder.deleteCharAt(stringBuilder.length() - 1);//回到上一层,父节点\n        }\n    }\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$ O(4^n/\\sqrt n) $</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>空间复杂度：O(n)，除了result之外，所需空间取决于递归栈的深度，每一层递归函数需要 O(1)的空间，最多递归 2n 层，因此空间复杂度为 O(n)。</p>\n"},{"title":"LeetCode刷题笔记31","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"2e9ae016","date":"2020-04-06T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须原地修改，只允许使用额外常数空间。\n\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n```\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n```\n\n# 思路\n从后往前,找到第一个非递增数(说明他可以换)。换则继续从后往前找到第一个大于它的数，将他们两交换。再将换的索引之前的逆序，即可得到下一个排列。\n要注意54321这种全逆序的情况\n# 细节\n\n1. 注意什么时候要返回了\n2. 注意索引的一些细节，还有反转数组时的索引\n\n\n# 代码\n```java\npublic void nextPermutation(int[] nums)\n{\n    int n = nums.length;\n    int index;//从倒数第二个元素开始比\n    for (index = n - 2; index >= 0; index--)\n    {\n        if (nums[index] < nums[index + 1]) break;//=号不行\n    }\n    if (index < 0) //说明是54321这种或者为空,或者只有一个元素\n    {\n        //颠倒即可\n        reverse(nums, 0, n - 1);\n        return;\n    }\n    //找到第一个大于他的\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (nums[index] < nums[i])//=号不行\n        {\n            exch(nums, index, i);\n            //从index+1,到n-1,反转数组\n            reverse(nums, index + 1, n - 1);\n            return;//look,做完直接return了\n        }\n    }\n}\n\n//lo,hi为要反转数组的开始,结束索引位置\nprivate void reverse(int[] nums, int lo, int hi)\n{\n    for (int i = 0; i < (hi - lo + 1) / 2; i++) exch(nums, lo + i, hi - i);\n    //look 判断条件这有问题\n    //        for (int i = lo; i < (hi - lo + 1) / 2; i++) exch(nums, i, hi - i);\n}\n\nprivate void exch(int[] nums, int i, int j)\n{\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n```\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$，最坏情况下只需要对整个数组进行两次扫描，以及一次数组反转\n\n## 空间复杂度\n\n$O(1)$,在原数组上进行交换","source":"_posts/LeetCode笔记/LeetCode刷题笔记_31_ 下一个排列.md","raw":"---\ntitle: LeetCode刷题笔记31\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 全排列\nabbrlink: 2e9ae016\ndate: 2020-04-07 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须原地修改，只允许使用额外常数空间。\n\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n```\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n```\n\n# 思路\n从后往前,找到第一个非递增数(说明他可以换)。换则继续从后往前找到第一个大于它的数，将他们两交换。再将换的索引之前的逆序，即可得到下一个排列。\n要注意54321这种全逆序的情况\n# 细节\n\n1. 注意什么时候要返回了\n2. 注意索引的一些细节，还有反转数组时的索引\n\n\n# 代码\n```java\npublic void nextPermutation(int[] nums)\n{\n    int n = nums.length;\n    int index;//从倒数第二个元素开始比\n    for (index = n - 2; index >= 0; index--)\n    {\n        if (nums[index] < nums[index + 1]) break;//=号不行\n    }\n    if (index < 0) //说明是54321这种或者为空,或者只有一个元素\n    {\n        //颠倒即可\n        reverse(nums, 0, n - 1);\n        return;\n    }\n    //找到第一个大于他的\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (nums[index] < nums[i])//=号不行\n        {\n            exch(nums, index, i);\n            //从index+1,到n-1,反转数组\n            reverse(nums, index + 1, n - 1);\n            return;//look,做完直接return了\n        }\n    }\n}\n\n//lo,hi为要反转数组的开始,结束索引位置\nprivate void reverse(int[] nums, int lo, int hi)\n{\n    for (int i = 0; i < (hi - lo + 1) / 2; i++) exch(nums, lo + i, hi - i);\n    //look 判断条件这有问题\n    //        for (int i = lo; i < (hi - lo + 1) / 2; i++) exch(nums, i, hi - i);\n}\n\nprivate void exch(int[] nums, int i, int j)\n{\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n```\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$，最坏情况下只需要对整个数组进行两次扫描，以及一次数组反转\n\n## 空间复杂度\n\n$O(1)$,在原数组上进行交换","slug":"LeetCode笔记/LeetCode刷题笔记_31_ 下一个排列","published":1,"updated":"2020-11-12T11:57:29.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yc006bjotphqccgb9g","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/next-permutation/\" target=\"_blank\" rel=\"noopener\">31. 下一个排列</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>\n<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>\n<p>必须原地修改，只允许使用额外常数空间。</p>\n<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>\n<pre><code>1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>从后往前,找到第一个非递增数(说明他可以换)。换则继续从后往前找到第一个大于它的数，将他们两交换。再将换的索引之前的逆序，即可得到下一个排列。<br>要注意54321这种全逆序的情况</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意什么时候要返回了</li>\n<li>注意索引的一些细节，还有反转数组时的索引</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">nextPermutation</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//从倒数第二个元素开始比</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> index <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> index<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">[</span>index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//=号不行</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//说明是54321这种或者为空,或者只有一个元素</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//颠倒即可</span>\n        <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//找到第一个大于他的</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//=号不行</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">exch</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//从index+1,到n-1,反转数组</span>\n            <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look,做完直接return了</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//lo,hi为要反转数组的开始,结束索引位置</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> lo<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> hi<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span>hi <span class=\"token operator\">-</span> lo <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token function\">exch</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> lo <span class=\"token operator\">+</span> i<span class=\"token punctuation\">,</span> hi <span class=\"token operator\">-</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//look 判断条件这有问题</span>\n    <span class=\"token comment\" spellcheck=\"true\">//        for (int i = lo; i &lt; (hi - lo + 1) / 2; i++) exch(nums, i, hi - i);</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">exch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$，最坏情况下只需要对整个数组进行两次扫描，以及一次数组反转</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$,在原数组上进行交换</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/next-permutation/\" target=\"_blank\" rel=\"noopener\">31. 下一个排列</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>\n<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>\n<p>必须原地修改，只允许使用额外常数空间。</p>\n<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>\n<pre><code>1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>从后往前,找到第一个非递增数(说明他可以换)。换则继续从后往前找到第一个大于它的数，将他们两交换。再将换的索引之前的逆序，即可得到下一个排列。<br>要注意54321这种全逆序的情况</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意什么时候要返回了</li>\n<li>注意索引的一些细节，还有反转数组时的索引</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public void nextPermutation(int[] nums)\n{\n    int n = nums.length;\n    int index;//从倒数第二个元素开始比\n    for (index = n - 2; index &gt;= 0; index--)\n    {\n        if (nums[index] &lt; nums[index + 1]) break;//=号不行\n    }\n    if (index &lt; 0) //说明是54321这种或者为空,或者只有一个元素\n    {\n        //颠倒即可\n        reverse(nums, 0, n - 1);\n        return;\n    }\n    //找到第一个大于他的\n    for (int i = n - 1; i &gt;= 0; i--)\n    {\n        if (nums[index] &lt; nums[i])//=号不行\n        {\n            exch(nums, index, i);\n            //从index+1,到n-1,反转数组\n            reverse(nums, index + 1, n - 1);\n            return;//look,做完直接return了\n        }\n    }\n}\n\n//lo,hi为要反转数组的开始,结束索引位置\nprivate void reverse(int[] nums, int lo, int hi)\n{\n    for (int i = 0; i &lt; (hi - lo + 1) / 2; i++) exch(nums, lo + i, hi - i);\n    //look 判断条件这有问题\n    //        for (int i = lo; i &lt; (hi - lo + 1) / 2; i++) exch(nums, i, hi - i);\n}\n\nprivate void exch(int[] nums, int i, int j)\n{\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$，最坏情况下只需要对整个数组进行两次扫描，以及一次数组反转</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$,在原数组上进行交换</p>\n"},{"title":"LeetCode刷题笔记32","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"b793b1ac","date":"2020-04-07T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)\n>\n>\n> 其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n\n示例 1:\n```\n输入: \"(()\"\n输出: 2\n解释: 最长有效括号子串为 \"()\"\n```\n示例 2:\n```\n输入: \")()())\"\n输出: 4\n解释: 最长有效括号子串为 \"()()\"\n```\n\n# 思路\n## Stack\n\n用Stack存储左括号的位置,并且栈底总是存储最后一个没有被匹配的右括号的下标。这样每次遇到左括号就push。\n\n遇到右括号则先弹出Stack中的一个元素，如果此时栈未空，说明弹栈把最后一个没有被匹配的右括号的下标弹出去的,就说明该右括号是没有左括号匹配的。则将他放入栈底。如果不为空，则说明有左括号匹配，则计算result。\n\n## left，right指针\n\n先正向遍历，适用右括号比左括号多的情况\n\n再反向遍历，适用右括号比左括号少的情况\n\n# 细节\n\n1. 用栈的话要注意初始在栈底放一个元素占位。而且记得计算时要先弹出一个元素\n2. 用left，right指针要注意反向遍历时，是左括号比右括号多时才清零\n\n\n# 代码\n```java\n//栈\n//在栈底放最后一个没有被匹配的右括号的下标\npublic int longestValidParentheses(String s)\n{\n    int result = 0;\n    Stack<Integer> stack = new Stack<>();\n    stack.push(-1);//默认的栈底,这样计算会正确\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        if (ch == '(')\n        {\n            stack.push(i);\n        }\n        else\n        {\n            stack.pop();\n            //说明弹栈把最后一个没有被匹配的右括号的下标弹出去的,就说明该)也是没有(匹配的\n            if (stack.isEmpty()) stack.push(i);\n            else result = Math.max(result, i - stack.peek());\n        }\n    }\n    return result;\n}\n```\n\n```java\n//使用left，right指针\n/*\n    完美匹配肯定测得出来\n    如果是不完美匹配,要么是左括号过多,要么是右括号过多\n    如果是右括号过多,则在过多的那个地方,都给清0,就不会影响后续的判断了\n    如果是左括号过多,则应在之后反向判断,转为右括号过多,就能正常判断了\n */\npublic int longestValidParentheses(String s)\n{\n    int result = 0, left = 0, right = 0;\n    //第一轮匹配的是右括号多的情况 即类似())(()))这些\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        if (ch == '(') ++left;\n        else ++right;\n        if (left == right)\n        {\n            result = Math.max(result, 2 * left);\n        }\n        else if (right > left)\n        {\n            left = 0;\n            right = 0;\n        }\n    }\n    //反向遍历 判断左括号过多的情况\n    left = 0;\n    right = 0;\n    for (int i = s.length() - 1; i >= 0; i--)\n    {\n        char ch = s.charAt(i);\n        if (ch == '(') ++left;\n        else ++right;\n        if (left == right)\n        {\n            result = Math.max(result, 2 * left);\n        }\n        else if (right < left) //这里要改变\n        {\n            left = 0;\n            right = 0;\n        }\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n\n## 时间复杂度\n\n使用栈:$O(N)$\n\t\t使用left，right指针：$O(N)$\n\n## 空间复杂度\n使用栈:$O(N)$\n\t\t使用left，right指针：$O(1)$","source":"_posts/LeetCode笔记/LeetCode刷题笔记_32_最长有效括号.md","raw":"---\ntitle: LeetCode刷题笔记32\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 字符串\nabbrlink: b793b1ac\ndate: 2020-04-08 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)\n>\n>\n> 其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n\n示例 1:\n```\n输入: \"(()\"\n输出: 2\n解释: 最长有效括号子串为 \"()\"\n```\n示例 2:\n```\n输入: \")()())\"\n输出: 4\n解释: 最长有效括号子串为 \"()()\"\n```\n\n# 思路\n## Stack\n\n用Stack存储左括号的位置,并且栈底总是存储最后一个没有被匹配的右括号的下标。这样每次遇到左括号就push。\n\n遇到右括号则先弹出Stack中的一个元素，如果此时栈未空，说明弹栈把最后一个没有被匹配的右括号的下标弹出去的,就说明该右括号是没有左括号匹配的。则将他放入栈底。如果不为空，则说明有左括号匹配，则计算result。\n\n## left，right指针\n\n先正向遍历，适用右括号比左括号多的情况\n\n再反向遍历，适用右括号比左括号少的情况\n\n# 细节\n\n1. 用栈的话要注意初始在栈底放一个元素占位。而且记得计算时要先弹出一个元素\n2. 用left，right指针要注意反向遍历时，是左括号比右括号多时才清零\n\n\n# 代码\n```java\n//栈\n//在栈底放最后一个没有被匹配的右括号的下标\npublic int longestValidParentheses(String s)\n{\n    int result = 0;\n    Stack<Integer> stack = new Stack<>();\n    stack.push(-1);//默认的栈底,这样计算会正确\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        if (ch == '(')\n        {\n            stack.push(i);\n        }\n        else\n        {\n            stack.pop();\n            //说明弹栈把最后一个没有被匹配的右括号的下标弹出去的,就说明该)也是没有(匹配的\n            if (stack.isEmpty()) stack.push(i);\n            else result = Math.max(result, i - stack.peek());\n        }\n    }\n    return result;\n}\n```\n\n```java\n//使用left，right指针\n/*\n    完美匹配肯定测得出来\n    如果是不完美匹配,要么是左括号过多,要么是右括号过多\n    如果是右括号过多,则在过多的那个地方,都给清0,就不会影响后续的判断了\n    如果是左括号过多,则应在之后反向判断,转为右括号过多,就能正常判断了\n */\npublic int longestValidParentheses(String s)\n{\n    int result = 0, left = 0, right = 0;\n    //第一轮匹配的是右括号多的情况 即类似())(()))这些\n    for (int i = 0; i < s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        if (ch == '(') ++left;\n        else ++right;\n        if (left == right)\n        {\n            result = Math.max(result, 2 * left);\n        }\n        else if (right > left)\n        {\n            left = 0;\n            right = 0;\n        }\n    }\n    //反向遍历 判断左括号过多的情况\n    left = 0;\n    right = 0;\n    for (int i = s.length() - 1; i >= 0; i--)\n    {\n        char ch = s.charAt(i);\n        if (ch == '(') ++left;\n        else ++right;\n        if (left == right)\n        {\n            result = Math.max(result, 2 * left);\n        }\n        else if (right < left) //这里要改变\n        {\n            left = 0;\n            right = 0;\n        }\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n\n## 时间复杂度\n\n使用栈:$O(N)$\n\t\t使用left，right指针：$O(N)$\n\n## 空间复杂度\n使用栈:$O(N)$\n\t\t使用left，right指针：$O(1)$","slug":"LeetCode笔记/LeetCode刷题笔记_32_最长有效括号","published":1,"updated":"2020-11-12T11:57:29.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6ye006ejotpb03da097","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/longest-valid-parentheses/\" target=\"_blank\" rel=\"noopener\">32. 最长有效括号</a></p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>\n<p>示例 1:</p>\n<pre><code>输入: &quot;(()&quot;\n输出: 2\n解释: 最长有效括号子串为 &quot;()&quot;</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: &quot;)()())&quot;\n输出: 4\n解释: 最长有效括号子串为 &quot;()()&quot;</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><h2 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h2><p>用Stack存储左括号的位置,并且栈底总是存储最后一个没有被匹配的右括号的下标。这样每次遇到左括号就push。</p>\n<p>遇到右括号则先弹出Stack中的一个元素，如果此时栈未空，说明弹栈把最后一个没有被匹配的右括号的下标弹出去的,就说明该右括号是没有左括号匹配的。则将他放入栈底。如果不为空，则说明有左括号匹配，则计算result。</p>\n<h2 id=\"left，right指针\"><a href=\"#left，right指针\" class=\"headerlink\" title=\"left，right指针\"></a>left，right指针</h2><p>先正向遍历，适用右括号比左括号多的情况</p>\n<p>再反向遍历，适用右括号比左括号少的情况</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>用栈的话要注意初始在栈底放一个元素占位。而且记得计算时要先弹出一个元素</li>\n<li>用left，right指针要注意反向遍历时，是左括号比右括号多时才清零</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//栈</span>\n<span class=\"token comment\" spellcheck=\"true\">//在栈底放最后一个没有被匹配的右括号的下标</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">longestValidParentheses</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    Stack<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> stack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//默认的栈底,这样计算会正确</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ch <span class=\"token operator\">==</span> <span class=\"token string\">'('</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//说明弹栈把最后一个没有被匹配的右括号的下标弹出去的,就说明该)也是没有(匹配的</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//使用left，right指针</span>\n<span class=\"token comment\" spellcheck=\"true\">/*\n    完美匹配肯定测得出来\n    如果是不完美匹配,要么是左括号过多,要么是右括号过多\n    如果是右括号过多,则在过多的那个地方,都给清0,就不会影响后续的判断了\n    如果是左括号过多,则应在之后反向判断,转为右括号过多,就能正常判断了\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">longestValidParentheses</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> right <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//第一轮匹配的是右括号多的情况 即类似())(()))这些</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ch <span class=\"token operator\">==</span> <span class=\"token string\">'('</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">++</span>left<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token operator\">++</span>right<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">==</span> right<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right <span class=\"token operator\">></span> left<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            right <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//反向遍历 判断左括号过多的情况</span>\n    left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    right <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ch <span class=\"token operator\">==</span> <span class=\"token string\">'('</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">++</span>left<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token operator\">++</span>right<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">==</span> right<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right <span class=\"token operator\">&lt;</span> left<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//这里要改变</span>\n        <span class=\"token punctuation\">{</span>\n            left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            right <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>使用栈:$O(N)$<br>        使用left，right指针：$O(N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>使用栈:$O(N)$<br>        使用left，right指针：$O(1)$</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/longest-valid-parentheses/\" target=\"_blank\" rel=\"noopener\">32. 最长有效括号</a></p>\n<p>其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>\n<p>示例 1:</p>\n<pre><code>输入: &quot;(()&quot;\n输出: 2\n解释: 最长有效括号子串为 &quot;()&quot;</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: &quot;)()())&quot;\n输出: 4\n解释: 最长有效括号子串为 &quot;()()&quot;</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><h2 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h2><p>用Stack存储左括号的位置,并且栈底总是存储最后一个没有被匹配的右括号的下标。这样每次遇到左括号就push。</p>\n<p>遇到右括号则先弹出Stack中的一个元素，如果此时栈未空，说明弹栈把最后一个没有被匹配的右括号的下标弹出去的,就说明该右括号是没有左括号匹配的。则将他放入栈底。如果不为空，则说明有左括号匹配，则计算result。</p>\n<h2 id=\"left，right指针\"><a href=\"#left，right指针\" class=\"headerlink\" title=\"left，right指针\"></a>left，right指针</h2><p>先正向遍历，适用右括号比左括号多的情况</p>\n<p>再反向遍历，适用右括号比左括号少的情况</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>用栈的话要注意初始在栈底放一个元素占位。而且记得计算时要先弹出一个元素</li>\n<li>用left，right指针要注意反向遍历时，是左括号比右括号多时才清零</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">//栈\n//在栈底放最后一个没有被匹配的右括号的下标\npublic int longestValidParentheses(String s)\n{\n    int result = 0;\n    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n    stack.push(-1);//默认的栈底,这样计算会正确\n    for (int i = 0; i &lt; s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        if (ch == &#39;(&#39;)\n        {\n            stack.push(i);\n        }\n        else\n        {\n            stack.pop();\n            //说明弹栈把最后一个没有被匹配的右括号的下标弹出去的,就说明该)也是没有(匹配的\n            if (stack.isEmpty()) stack.push(i);\n            else result = Math.max(result, i - stack.peek());\n        }\n    }\n    return result;\n}</code></pre>\n<pre><code class=\"java\">//使用left，right指针\n/*\n    完美匹配肯定测得出来\n    如果是不完美匹配,要么是左括号过多,要么是右括号过多\n    如果是右括号过多,则在过多的那个地方,都给清0,就不会影响后续的判断了\n    如果是左括号过多,则应在之后反向判断,转为右括号过多,就能正常判断了\n */\npublic int longestValidParentheses(String s)\n{\n    int result = 0, left = 0, right = 0;\n    //第一轮匹配的是右括号多的情况 即类似())(()))这些\n    for (int i = 0; i &lt; s.length(); i++)\n    {\n        char ch = s.charAt(i);\n        if (ch == &#39;(&#39;) ++left;\n        else ++right;\n        if (left == right)\n        {\n            result = Math.max(result, 2 * left);\n        }\n        else if (right &gt; left)\n        {\n            left = 0;\n            right = 0;\n        }\n    }\n    //反向遍历 判断左括号过多的情况\n    left = 0;\n    right = 0;\n    for (int i = s.length() - 1; i &gt;= 0; i--)\n    {\n        char ch = s.charAt(i);\n        if (ch == &#39;(&#39;) ++left;\n        else ++right;\n        if (left == right)\n        {\n            result = Math.max(result, 2 * left);\n        }\n        else if (right &lt; left) //这里要改变\n        {\n            left = 0;\n            right = 0;\n        }\n    }\n    return result;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>使用栈:$O(N)$<br>        使用left，right指针：$O(N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>使用栈:$O(N)$<br>        使用left，right指针：$O(1)$</p>\n"},{"title":"LeetCode刷题笔记23","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"d98fb07b","date":"2020-04-05T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n\n示例:\n```\n输入:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n输出: 1->1->2->3->4->4->5->6\n```\n\n\n\n# 思路\n\n分治法：调用之前写过的`mergeTwoLists`不断两两合并到只剩一条链表\n\n优先队列法：把每个链表的首元素放入优先队列，每次取出最小的，并且把那条链表的下一个元素加入。不断进行直到优先队列为空\n\n# 细节\n\n1. 优先队列法内存消耗小,但比较慢.\n2. 优先队列法需要存储每个元素对应的链表,所以就要定义二元组,所以就要重新传入比较器。而且要自己构造链表，注意pre和cur。\n\n# 代码\n\n```java\n//归并法\npublic ListNode mergeKLists(ListNode[] lists)\n{\n    int n = lists.length;\n    if (n == 0) return null;\n    while (n > 1)\n    {\n        for (int i = 0; i < n / 2; i++)\n        {\n            lists[i] = mergeTwoLists(lists[i], lists[n - 1 - i]);\n        }\n        n = (n + 1) / 2;//考虑奇数有一个没参与合并,但是要参与下一次运算\n    }\n    return lists[0];\n}\n\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2)\n{\n    if (l1 == null) return l2;\n    if (l2 == null) return l1;\n\n    ListNode result = null;\n\n    if (l1.val < l2.val)\n    {\n        result = new ListNode(l1.val);\n        result.next = mergeTwoLists(l1.next, l2);\n    }\n    else\n    {\n        result = new ListNode(l2.val);\n        result.next = mergeTwoLists(l1, l2.next);\n    }\n    return result;\n}\n```\n\n```java\n//优先队列法\nclass Tuple\n{\n    Integer key;\n    Integer value;\n\n    public Tuple(Integer key, Integer value)\n    {\n        this.key = key;\n        this.value = value;\n    }\n}\n\npublic ListNode mergeKLists(ListNode[] lists)\n{\n    ListNode pre = new ListNode(-1),cur=pre;\n    //用优先队列存储每个链表最前面的值,以及他们对应是哪个链表\n    Queue<Tuple> queue = new PriorityQueue<>((tuple1,tuple2)->(tuple1.key-tuple2.key));\n    for (int i = 0; i < lists.length; i++)\n    {\n        //注意要非null\n        if(lists[i]!=null)\n        {\n            queue.add(new Tuple(lists[i].val, i));\n            lists[i] = lists[i].next;\n        }\n    }\n    while(!queue.isEmpty())\n    {\n        Tuple tuple = queue.poll();//弹出最小的一个数\n\n        //look,自己创建链表的问题l,不能用pre来算\n        cur.next=new ListNode(tuple.key);\n        cur = cur.next;\n\n        //look,引用的问题,应该是让数组的引用向下一位\n        if(lists[tuple.value]!=null)\n        {\n            queue.add(new Tuple(lists[tuple.value].val,tuple.value));//tuple.values标识是哪个链表\n            lists[tuple.value] = lists[tuple.value].next;\n        }\n    }\n    return pre.next;\n}\n```\n\n\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n分治法：第一轮合并k/2组链表，每组代价为$O(2n)$,第二轮合并k/4组链表，每组代价为$O(4n)$,一共合并log k次，所以为$O(kn*log k)$\n\n优先队列法:每次优先队列最多只有k个元素，插入，删除代价为$ O(log k) $,最多有kn个节点要操作，所以为$O(kn*log k)$\n\n## 空间复杂度\n\n分治法：$ O(log k) $,递归用到的栈空间\n\n优先队列法:$ O(k) $,优先队列元素不超过k个","source":"_posts/LeetCode笔记/LeetCode刷题笔记_23_合并K个排序链表.md","raw":"---\ntitle: LeetCode刷题笔记23\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 归并\n  - 链表\nabbrlink: d98fb07b\ndate: 2020-04-06 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n\n示例:\n```\n输入:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n输出: 1->1->2->3->4->4->5->6\n```\n\n\n\n# 思路\n\n分治法：调用之前写过的`mergeTwoLists`不断两两合并到只剩一条链表\n\n优先队列法：把每个链表的首元素放入优先队列，每次取出最小的，并且把那条链表的下一个元素加入。不断进行直到优先队列为空\n\n# 细节\n\n1. 优先队列法内存消耗小,但比较慢.\n2. 优先队列法需要存储每个元素对应的链表,所以就要定义二元组,所以就要重新传入比较器。而且要自己构造链表，注意pre和cur。\n\n# 代码\n\n```java\n//归并法\npublic ListNode mergeKLists(ListNode[] lists)\n{\n    int n = lists.length;\n    if (n == 0) return null;\n    while (n > 1)\n    {\n        for (int i = 0; i < n / 2; i++)\n        {\n            lists[i] = mergeTwoLists(lists[i], lists[n - 1 - i]);\n        }\n        n = (n + 1) / 2;//考虑奇数有一个没参与合并,但是要参与下一次运算\n    }\n    return lists[0];\n}\n\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2)\n{\n    if (l1 == null) return l2;\n    if (l2 == null) return l1;\n\n    ListNode result = null;\n\n    if (l1.val < l2.val)\n    {\n        result = new ListNode(l1.val);\n        result.next = mergeTwoLists(l1.next, l2);\n    }\n    else\n    {\n        result = new ListNode(l2.val);\n        result.next = mergeTwoLists(l1, l2.next);\n    }\n    return result;\n}\n```\n\n```java\n//优先队列法\nclass Tuple\n{\n    Integer key;\n    Integer value;\n\n    public Tuple(Integer key, Integer value)\n    {\n        this.key = key;\n        this.value = value;\n    }\n}\n\npublic ListNode mergeKLists(ListNode[] lists)\n{\n    ListNode pre = new ListNode(-1),cur=pre;\n    //用优先队列存储每个链表最前面的值,以及他们对应是哪个链表\n    Queue<Tuple> queue = new PriorityQueue<>((tuple1,tuple2)->(tuple1.key-tuple2.key));\n    for (int i = 0; i < lists.length; i++)\n    {\n        //注意要非null\n        if(lists[i]!=null)\n        {\n            queue.add(new Tuple(lists[i].val, i));\n            lists[i] = lists[i].next;\n        }\n    }\n    while(!queue.isEmpty())\n    {\n        Tuple tuple = queue.poll();//弹出最小的一个数\n\n        //look,自己创建链表的问题l,不能用pre来算\n        cur.next=new ListNode(tuple.key);\n        cur = cur.next;\n\n        //look,引用的问题,应该是让数组的引用向下一位\n        if(lists[tuple.value]!=null)\n        {\n            queue.add(new Tuple(lists[tuple.value].val,tuple.value));//tuple.values标识是哪个链表\n            lists[tuple.value] = lists[tuple.value].next;\n        }\n    }\n    return pre.next;\n}\n```\n\n\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n分治法：第一轮合并k/2组链表，每组代价为$O(2n)$,第二轮合并k/4组链表，每组代价为$O(4n)$,一共合并log k次，所以为$O(kn*log k)$\n\n优先队列法:每次优先队列最多只有k个元素，插入，删除代价为$ O(log k) $,最多有kn个节点要操作，所以为$O(kn*log k)$\n\n## 空间复杂度\n\n分治法：$ O(log k) $,递归用到的栈空间\n\n优先队列法:$ O(k) $,优先队列元素不超过k个","slug":"LeetCode笔记/LeetCode刷题笔记_23_合并K个排序链表","published":1,"updated":"2020-11-12T11:57:29.578Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yf006gjotp9ccs4ba2","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/merge-k-sorted-lists/\" target=\"_blank\" rel=\"noopener\">23. 合并K个排序链表</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>\n<p>示例:</p>\n<pre><code>输入:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>分治法：调用之前写过的<code>mergeTwoLists</code>不断两两合并到只剩一条链表</p>\n<p>优先队列法：把每个链表的首元素放入优先队列，每次取出最小的，并且把那条链表的下一个元素加入。不断进行直到优先队列为空</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>优先队列法内存消耗小,但比较慢.</li>\n<li>优先队列法需要存储每个元素对应的链表,所以就要定义二元组,所以就要重新传入比较器。而且要自己构造链表，注意pre和cur。</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//归并法</span>\n<span class=\"token keyword\">public</span> ListNode <span class=\"token function\">mergeKLists</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> lists<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> lists<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            lists<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>lists<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> lists<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">-</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        n <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//考虑奇数有一个没参与合并,但是要参与下一次运算</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> lists<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> ListNode <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>ListNode l1<span class=\"token punctuation\">,</span> ListNode l2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l1 <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> l2<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l2 <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> l1<span class=\"token punctuation\">;</span>\n\n    ListNode result <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;</span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        result<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">{</span>\n        result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span>l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        result<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//优先队列法</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Tuple</span>\n<span class=\"token punctuation\">{</span>\n    Integer key<span class=\"token punctuation\">;</span>\n    Integer value<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Tuple</span><span class=\"token punctuation\">(</span>Integer key<span class=\"token punctuation\">,</span> Integer value<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> ListNode <span class=\"token function\">mergeKLists</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> lists<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ListNode pre <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>cur<span class=\"token operator\">=</span>pre<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//用优先队列存储每个链表最前面的值,以及他们对应是哪个链表</span>\n    Queue<span class=\"token operator\">&lt;</span>Tuple<span class=\"token operator\">></span> queue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PriorityQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tuple1<span class=\"token punctuation\">,</span>tuple2<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>tuple1<span class=\"token punctuation\">.</span>key<span class=\"token operator\">-</span>tuple2<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> lists<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//注意要非null</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>lists<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            queue<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Tuple</span><span class=\"token punctuation\">(</span>lists<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            lists<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> lists<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>queue<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Tuple tuple <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//弹出最小的一个数</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//look,自己创建链表的问题l,不能用pre来算</span>\n        cur<span class=\"token punctuation\">.</span>next<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span>tuple<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cur <span class=\"token operator\">=</span> cur<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//look,引用的问题,应该是让数组的引用向下一位</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>lists<span class=\"token punctuation\">[</span>tuple<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">]</span><span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            queue<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Tuple</span><span class=\"token punctuation\">(</span>lists<span class=\"token punctuation\">[</span>tuple<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">,</span>tuple<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//tuple.values标识是哪个链表</span>\n            lists<span class=\"token punctuation\">[</span>tuple<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> lists<span class=\"token punctuation\">[</span>tuple<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> pre<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>分治法：第一轮合并k/2组链表，每组代价为$O(2n)$,第二轮合并k/4组链表，每组代价为$O(4n)$,一共合并log k次，所以为$O(kn*log k)$</p>\n<p>优先队列法:每次优先队列最多只有k个元素，插入，删除代价为$ O(log k) $,最多有kn个节点要操作，所以为$O(kn*log k)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>分治法：$ O(log k) $,递归用到的栈空间</p>\n<p>优先队列法:$ O(k) $,优先队列元素不超过k个</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/merge-k-sorted-lists/\" target=\"_blank\" rel=\"noopener\">23. 合并K个排序链表</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>\n<p>示例:</p>\n<pre><code>输入:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>分治法：调用之前写过的<code>mergeTwoLists</code>不断两两合并到只剩一条链表</p>\n<p>优先队列法：把每个链表的首元素放入优先队列，每次取出最小的，并且把那条链表的下一个元素加入。不断进行直到优先队列为空</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>优先队列法内存消耗小,但比较慢.</li>\n<li>优先队列法需要存储每个元素对应的链表,所以就要定义二元组,所以就要重新传入比较器。而且要自己构造链表，注意pre和cur。</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">//归并法\npublic ListNode mergeKLists(ListNode[] lists)\n{\n    int n = lists.length;\n    if (n == 0) return null;\n    while (n &gt; 1)\n    {\n        for (int i = 0; i &lt; n / 2; i++)\n        {\n            lists[i] = mergeTwoLists(lists[i], lists[n - 1 - i]);\n        }\n        n = (n + 1) / 2;//考虑奇数有一个没参与合并,但是要参与下一次运算\n    }\n    return lists[0];\n}\n\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2)\n{\n    if (l1 == null) return l2;\n    if (l2 == null) return l1;\n\n    ListNode result = null;\n\n    if (l1.val &lt; l2.val)\n    {\n        result = new ListNode(l1.val);\n        result.next = mergeTwoLists(l1.next, l2);\n    }\n    else\n    {\n        result = new ListNode(l2.val);\n        result.next = mergeTwoLists(l1, l2.next);\n    }\n    return result;\n}</code></pre>\n<pre><code class=\"java\">//优先队列法\nclass Tuple\n{\n    Integer key;\n    Integer value;\n\n    public Tuple(Integer key, Integer value)\n    {\n        this.key = key;\n        this.value = value;\n    }\n}\n\npublic ListNode mergeKLists(ListNode[] lists)\n{\n    ListNode pre = new ListNode(-1),cur=pre;\n    //用优先队列存储每个链表最前面的值,以及他们对应是哪个链表\n    Queue&lt;Tuple&gt; queue = new PriorityQueue&lt;&gt;((tuple1,tuple2)-&gt;(tuple1.key-tuple2.key));\n    for (int i = 0; i &lt; lists.length; i++)\n    {\n        //注意要非null\n        if(lists[i]!=null)\n        {\n            queue.add(new Tuple(lists[i].val, i));\n            lists[i] = lists[i].next;\n        }\n    }\n    while(!queue.isEmpty())\n    {\n        Tuple tuple = queue.poll();//弹出最小的一个数\n\n        //look,自己创建链表的问题l,不能用pre来算\n        cur.next=new ListNode(tuple.key);\n        cur = cur.next;\n\n        //look,引用的问题,应该是让数组的引用向下一位\n        if(lists[tuple.value]!=null)\n        {\n            queue.add(new Tuple(lists[tuple.value].val,tuple.value));//tuple.values标识是哪个链表\n            lists[tuple.value] = lists[tuple.value].next;\n        }\n    }\n    return pre.next;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>分治法：第一轮合并k/2组链表，每组代价为$O(2n)$,第二轮合并k/4组链表，每组代价为$O(4n)$,一共合并log k次，所以为$O(kn*log k)$</p>\n<p>优先队列法:每次优先队列最多只有k个元素，插入，删除代价为$ O(log k) $,最多有kn个节点要操作，所以为$O(kn*log k)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>分治法：$ O(log k) $,递归用到的栈空间</p>\n<p>优先队列法:$ O(k) $,优先队列元素不超过k个</p>\n"},{"title":"LeetCode刷题笔记33","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"c094813a","date":"2020-04-09T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。\n\n搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。\n\n你可以假设数组中不存在重复的元素。\n\n你的算法时间复杂度必须是 O(log n) 级别。\n\n示例 1:\n\n```\n输入: nums = [4,5,6,7,0,1,2], target = 0\n输出: 4\n```\n\n\n\n示例 2:\n\n```\n输入: nums = [4,5,6,7,0,1,2], target = 3\n输出: -1\n```\n\n# 思路\n\n```java\n//伪代码\nint lo=0,hi=n-1;\nwhile(lo<=hi)\n{\n    int mid=lo+(hi-lo)/2;\n    if(nums[mid]==target) return mid;\n    \n    if(target>nums[hi])//target在数组切分后的左边\n    {\n        //可以简化\n        if(nums[mid]>target) hi=mid-1;//mid在左边的上半部分\n        else if(nums[mid]>nums[lo]) lo=mid+1;//mid在左边的下半部分\n        else  hi=mid-1;//在右边部分\n    }\n    else//在右边\n    {\n        //可以简化\n        if(nums[mid]<target) lo=mid+1;//mid在右边的下半部分\n        else if(nums[mid]>nums[lo]) lo=mid+1;//mid在左边部分\n        else  hi=mid-1;//在右边的上半部分\n    }\n}\n```\n\n\n\n# 细节\n\n1. 要画图分析,分情况讨论\n2. 注意是纯递增的情况。经验是nums[mid]与nums[lo],nums[hi]最接近的一个比较\n\n\n# 代码\n\n```java\n/*\n    画图分析!\n    关键是先定下target的位置\n    不存在重复,那么lo与hi对应的值不会相等(lo!=hi)时\n     */\npublic int search(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo <= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n        if (nums[mid] == target) return mid;\n\n        if (target > nums[hi])//target在数组切分后的左边\n        {\n            if(nums[mid] < target && nums[mid] > nums[lo]) lo = mid + 1;\n            else hi = mid - 1;\n        }\n        else//在右边\n        {\n            //look 要考虑是纯递增的情况\n            if(nums[mid] > target && nums[mid] < nums[hi]) hi = mid - 1;\n            else lo = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(log N)$\n\n## 空间复杂度\n\n$O(1)$","source":"_posts/LeetCode笔记/LeetCode刷题笔记_33_ 搜索旋转排序数组.md","raw":"---\ntitle: LeetCode刷题笔记33\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 二分搜索\nabbrlink: c094813a\ndate: 2020-04-10 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。\n\n搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。\n\n你可以假设数组中不存在重复的元素。\n\n你的算法时间复杂度必须是 O(log n) 级别。\n\n示例 1:\n\n```\n输入: nums = [4,5,6,7,0,1,2], target = 0\n输出: 4\n```\n\n\n\n示例 2:\n\n```\n输入: nums = [4,5,6,7,0,1,2], target = 3\n输出: -1\n```\n\n# 思路\n\n```java\n//伪代码\nint lo=0,hi=n-1;\nwhile(lo<=hi)\n{\n    int mid=lo+(hi-lo)/2;\n    if(nums[mid]==target) return mid;\n    \n    if(target>nums[hi])//target在数组切分后的左边\n    {\n        //可以简化\n        if(nums[mid]>target) hi=mid-1;//mid在左边的上半部分\n        else if(nums[mid]>nums[lo]) lo=mid+1;//mid在左边的下半部分\n        else  hi=mid-1;//在右边部分\n    }\n    else//在右边\n    {\n        //可以简化\n        if(nums[mid]<target) lo=mid+1;//mid在右边的下半部分\n        else if(nums[mid]>nums[lo]) lo=mid+1;//mid在左边部分\n        else  hi=mid-1;//在右边的上半部分\n    }\n}\n```\n\n\n\n# 细节\n\n1. 要画图分析,分情况讨论\n2. 注意是纯递增的情况。经验是nums[mid]与nums[lo],nums[hi]最接近的一个比较\n\n\n# 代码\n\n```java\n/*\n    画图分析!\n    关键是先定下target的位置\n    不存在重复,那么lo与hi对应的值不会相等(lo!=hi)时\n     */\npublic int search(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo <= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n        if (nums[mid] == target) return mid;\n\n        if (target > nums[hi])//target在数组切分后的左边\n        {\n            if(nums[mid] < target && nums[mid] > nums[lo]) lo = mid + 1;\n            else hi = mid - 1;\n        }\n        else//在右边\n        {\n            //look 要考虑是纯递增的情况\n            if(nums[mid] > target && nums[mid] < nums[hi]) hi = mid - 1;\n            else lo = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(log N)$\n\n## 空间复杂度\n\n$O(1)$","slug":"LeetCode笔记/LeetCode刷题笔记_33_ 搜索旋转排序数组","published":1,"updated":"2020-11-12T11:57:29.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yg006jjotpaz800uja","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">33. 搜索旋转排序数组</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>\n<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>\n<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>\n<p>你可以假设数组中不存在重复的元素。</p>\n<p>你的算法时间复杂度必须是 O(log n) 级别。</p>\n<p>示例 1:</p>\n<pre><code>输入: nums = [4,5,6,7,0,1,2], target = 0\n输出: 4</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: nums = [4,5,6,7,0,1,2], target = 3\n输出: -1</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//伪代码</span>\n<span class=\"token keyword\">int</span> lo<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>hi<span class=\"token operator\">=</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">&lt;=</span>hi<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> mid<span class=\"token operator\">=</span>lo<span class=\"token operator\">+</span><span class=\"token punctuation\">(</span>hi<span class=\"token operator\">-</span>lo<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span>target<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">></span>nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//target在数组切分后的左边</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//可以简化</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>target<span class=\"token punctuation\">)</span> hi<span class=\"token operator\">=</span>mid<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//mid在左边的上半部分</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> lo<span class=\"token operator\">=</span>mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//mid在左边的下半部分</span>\n        <span class=\"token keyword\">else</span>  hi<span class=\"token operator\">=</span>mid<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//在右边部分</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span><span class=\"token comment\" spellcheck=\"true\">//在右边</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//可以简化</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;</span>target<span class=\"token punctuation\">)</span> lo<span class=\"token operator\">=</span>mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//mid在右边的下半部分</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> lo<span class=\"token operator\">=</span>mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//mid在左边部分</span>\n        <span class=\"token keyword\">else</span>  hi<span class=\"token operator\">=</span>mid<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//在右边的上半部分</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>要画图分析,分情况讨论</li>\n<li>注意是纯递增的情况。经验是nums[mid]与nums[lo],nums[hi]最接近的一个比较</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/*\n    画图分析!\n    关键是先定下target的位置\n    不存在重复,那么lo与hi对应的值不会相等(lo!=hi)时\n     */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> lo <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> hi <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>lo <span class=\"token operator\">&lt;=</span> hi<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> lo <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>hi <span class=\"token operator\">-</span> lo<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>target <span class=\"token operator\">></span> nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//target在数组切分后的左边</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> target <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> lo <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> hi <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span><span class=\"token comment\" spellcheck=\"true\">//在右边</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//look 要考虑是纯递增的情况</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> target <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> hi <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> lo <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(log N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\" rel=\"noopener\">33. 搜索旋转排序数组</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>\n<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>\n<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>\n<p>你可以假设数组中不存在重复的元素。</p>\n<p>你的算法时间复杂度必须是 O(log n) 级别。</p>\n<p>示例 1:</p>\n<pre><code>输入: nums = [4,5,6,7,0,1,2], target = 0\n输出: 4</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: nums = [4,5,6,7,0,1,2], target = 3\n输出: -1</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code class=\"java\">//伪代码\nint lo=0,hi=n-1;\nwhile(lo&lt;=hi)\n{\n    int mid=lo+(hi-lo)/2;\n    if(nums[mid]==target) return mid;\n\n    if(target&gt;nums[hi])//target在数组切分后的左边\n    {\n        //可以简化\n        if(nums[mid]&gt;target) hi=mid-1;//mid在左边的上半部分\n        else if(nums[mid]&gt;nums[lo]) lo=mid+1;//mid在左边的下半部分\n        else  hi=mid-1;//在右边部分\n    }\n    else//在右边\n    {\n        //可以简化\n        if(nums[mid]&lt;target) lo=mid+1;//mid在右边的下半部分\n        else if(nums[mid]&gt;nums[lo]) lo=mid+1;//mid在左边部分\n        else  hi=mid-1;//在右边的上半部分\n    }\n}</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>要画图分析,分情况讨论</li>\n<li>注意是纯递增的情况。经验是nums[mid]与nums[lo],nums[hi]最接近的一个比较</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">/*\n    画图分析!\n    关键是先定下target的位置\n    不存在重复,那么lo与hi对应的值不会相等(lo!=hi)时\n     */\npublic int search(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo &lt;= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n        if (nums[mid] == target) return mid;\n\n        if (target &gt; nums[hi])//target在数组切分后的左边\n        {\n            if(nums[mid] &lt; target &amp;&amp; nums[mid] &gt; nums[lo]) lo = mid + 1;\n            else hi = mid - 1;\n        }\n        else//在右边\n        {\n            //look 要考虑是纯递增的情况\n            if(nums[mid] &gt; target &amp;&amp; nums[mid] &lt; nums[hi]) hi = mid - 1;\n            else lo = mid + 1;\n        }\n    }\n    return -1;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(log N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$</p>\n"},{"title":"LeetCode刷题笔记39","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"20416824","date":"2020-04-12T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n所有数字（包括 target）都是正整数。\n\t\t解集不能包含重复的组合。 \n\n```\n示例 1：\n\n输入：candidates = [2,3,6,7], target = 7,\n所求解集为：\n[\n  [7],\n  [2,2,3]\n]\n```\n\n```\n示例 2：\n\n输入：candidates = [2,3,5], target = 8,\n所求解集为：\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n```\n\n```\n提示：\n\n1 <= candidates.length <= 30\n1 <= candidates[i] <= 200\ncandidate 中的每个元素都是独一无二的。\n1 <= target <= 500\n```\n\n\n\n# 思路\n\n采用回溯法\n\n因为元素都是独一无二的且不重复,所以很多特殊情况不用考虑。例如当target等于0时，就不用往该分支下进行了。\n\n而且result中不含重复，所以需要措施跳过重复的（循环中小于父节点的）。\n\n```\n//伪代码\nsort(nums);\nint sum=0;\nList temp;\n\n\nrecursive(target)\n{\n\tif(target==0) \n\t{\n\t\tresult.add(temp);\n\t\treturn;\n\t}\n    for(i in N)\n    {\n        if(nums[i]>target) return;//剪枝条件\n        if(nums[i]<temp.top()) continue;//剪枝条件 避免重复\n        \n\n        temp.add(nums[i]);\n\t\trecursive(target-nums[i]);\t\t\n        temp.remove(nums[i]);\n    }\n}\n\n```\n\n\n\n# 细节\n\n1. 加入结果时，要注意引用问题，重新复制到一个新的list\n2. 注意处理重复问题\n3. 注意剪枝优化问题\n\n\n# 代码\n\n```java\nprivate List<Integer> temp = new LinkedList<>();\nprivate List<List<Integer>> result = new LinkedList<>();\n\npublic List<List<Integer>> combinationSum(int[] candidates, int target)\n{\n    Arrays.sort(candidates);\n    recursive(candidates, target,0);\n    return result;\n}\nvoid recursive(int[] candidates,int target,int begin)\n{\n    if(target==0)\n    {\n        result.add(new LinkedList<>(temp));//look 这里有引用问题,应该是复制一个新的给result\n        return;\n    }\n    for (int i = begin; i < candidates.length; i++)\n    {\n        if(candidates[i]>target) return;//剪枝条件\n        \n        //look 注意越界问题\n        //可优化成开始条件\n        //if(!temp.isEmpty() && candidates[i]<temp.get(temp.size()-1)) continue;//剪枝条件 避免重复\n\n        temp.add(candidates[i]);//look 不需要sum\n        recursive(candidates,target-candidates[i],i);\n        temp.remove(temp.size()-1);\n    }\n}\n```\n\n\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_39. 组合总和.md","raw":"---\ntitle: LeetCode刷题笔记39\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 回溯\nabbrlink: '20416824'\ndate: 2020-04-13 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n所有数字（包括 target）都是正整数。\n\t\t解集不能包含重复的组合。 \n\n```\n示例 1：\n\n输入：candidates = [2,3,6,7], target = 7,\n所求解集为：\n[\n  [7],\n  [2,2,3]\n]\n```\n\n```\n示例 2：\n\n输入：candidates = [2,3,5], target = 8,\n所求解集为：\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n```\n\n```\n提示：\n\n1 <= candidates.length <= 30\n1 <= candidates[i] <= 200\ncandidate 中的每个元素都是独一无二的。\n1 <= target <= 500\n```\n\n\n\n# 思路\n\n采用回溯法\n\n因为元素都是独一无二的且不重复,所以很多特殊情况不用考虑。例如当target等于0时，就不用往该分支下进行了。\n\n而且result中不含重复，所以需要措施跳过重复的（循环中小于父节点的）。\n\n```\n//伪代码\nsort(nums);\nint sum=0;\nList temp;\n\n\nrecursive(target)\n{\n\tif(target==0) \n\t{\n\t\tresult.add(temp);\n\t\treturn;\n\t}\n    for(i in N)\n    {\n        if(nums[i]>target) return;//剪枝条件\n        if(nums[i]<temp.top()) continue;//剪枝条件 避免重复\n        \n\n        temp.add(nums[i]);\n\t\trecursive(target-nums[i]);\t\t\n        temp.remove(nums[i]);\n    }\n}\n\n```\n\n\n\n# 细节\n\n1. 加入结果时，要注意引用问题，重新复制到一个新的list\n2. 注意处理重复问题\n3. 注意剪枝优化问题\n\n\n# 代码\n\n```java\nprivate List<Integer> temp = new LinkedList<>();\nprivate List<List<Integer>> result = new LinkedList<>();\n\npublic List<List<Integer>> combinationSum(int[] candidates, int target)\n{\n    Arrays.sort(candidates);\n    recursive(candidates, target,0);\n    return result;\n}\nvoid recursive(int[] candidates,int target,int begin)\n{\n    if(target==0)\n    {\n        result.add(new LinkedList<>(temp));//look 这里有引用问题,应该是复制一个新的给result\n        return;\n    }\n    for (int i = begin; i < candidates.length; i++)\n    {\n        if(candidates[i]>target) return;//剪枝条件\n        \n        //look 注意越界问题\n        //可优化成开始条件\n        //if(!temp.isEmpty() && candidates[i]<temp.get(temp.size()-1)) continue;//剪枝条件 避免重复\n\n        temp.add(candidates[i]);//look 不需要sum\n        recursive(candidates,target-candidates[i],i);\n        temp.remove(temp.size()-1);\n    }\n}\n```\n\n\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_39. 组合总和","published":1,"updated":"2020-11-12T11:57:29.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yh006ljotp8yoj5o8p","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/combination-sum/\" target=\"_blank\" rel=\"noopener\">39. 组合总和</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>\n<p>candidates 中的数字可以无限制重复被选取。</p>\n<p>说明：</p>\n<p>所有数字（包括 target）都是正整数。<br>        解集不能包含重复的组合。 </p>\n<pre><code>示例 1：\n\n输入：candidates = [2,3,6,7], target = 7,\n所求解集为：\n[\n  [7],\n  [2,2,3]\n]</code></pre>\n<pre><code>示例 2：\n\n输入：candidates = [2,3,5], target = 8,\n所求解集为：\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]</code></pre>\n<pre><code>提示：\n\n1 &lt;= candidates.length &lt;= 30\n1 &lt;= candidates[i] &lt;= 200\ncandidate 中的每个元素都是独一无二的。\n1 &lt;= target &lt;= 500</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>采用回溯法</p>\n<p>因为元素都是独一无二的且不重复,所以很多特殊情况不用考虑。例如当target等于0时，就不用往该分支下进行了。</p>\n<p>而且result中不含重复，所以需要措施跳过重复的（循环中小于父节点的）。</p>\n<pre><code>//伪代码\nsort(nums);\nint sum=0;\nList temp;\n\n\nrecursive(target)\n{\n    if(target==0) \n    {\n        result.add(temp);\n        return;\n    }\n    for(i in N)\n    {\n        if(nums[i]&gt;target) return;//剪枝条件\n        if(nums[i]&lt;temp.top()) continue;//剪枝条件 避免重复\n\n\n        temp.add(nums[i]);\n        recursive(target-nums[i]);        \n        temp.remove(nums[i]);\n    }\n}\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>加入结果时，要注意引用问题，重新复制到一个新的list</li>\n<li>注意处理重复问题</li>\n<li>注意剪枝优化问题</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> temp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> <span class=\"token function\">combinationSum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> candidates<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> candidates<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> target<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> begin<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look 这里有引用问题,应该是复制一个新的给result</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> begin<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> candidates<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>target<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//剪枝条件</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//look 注意越界问题</span>\n        <span class=\"token comment\" spellcheck=\"true\">//可优化成开始条件</span>\n        <span class=\"token comment\" spellcheck=\"true\">//if(!temp.isEmpty() &amp;&amp; candidates[i]&lt;temp.get(temp.size()-1)) continue;//剪枝条件 避免重复</span>\n\n        temp<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look 不需要sum</span>\n        <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">,</span>target<span class=\"token operator\">-</span>candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        temp<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/combination-sum/\" target=\"_blank\" rel=\"noopener\">39. 组合总和</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>\n<p>candidates 中的数字可以无限制重复被选取。</p>\n<p>说明：</p>\n<p>所有数字（包括 target）都是正整数。<br>        解集不能包含重复的组合。 </p>\n<pre><code>示例 1：\n\n输入：candidates = [2,3,6,7], target = 7,\n所求解集为：\n[\n  [7],\n  [2,2,3]\n]</code></pre>\n<pre><code>示例 2：\n\n输入：candidates = [2,3,5], target = 8,\n所求解集为：\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]</code></pre>\n<pre><code>提示：\n\n1 &lt;= candidates.length &lt;= 30\n1 &lt;= candidates[i] &lt;= 200\ncandidate 中的每个元素都是独一无二的。\n1 &lt;= target &lt;= 500</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>采用回溯法</p>\n<p>因为元素都是独一无二的且不重复,所以很多特殊情况不用考虑。例如当target等于0时，就不用往该分支下进行了。</p>\n<p>而且result中不含重复，所以需要措施跳过重复的（循环中小于父节点的）。</p>\n<pre><code>//伪代码\nsort(nums);\nint sum=0;\nList temp;\n\n\nrecursive(target)\n{\n    if(target==0) \n    {\n        result.add(temp);\n        return;\n    }\n    for(i in N)\n    {\n        if(nums[i]&gt;target) return;//剪枝条件\n        if(nums[i]&lt;temp.top()) continue;//剪枝条件 避免重复\n\n\n        temp.add(nums[i]);\n        recursive(target-nums[i]);        \n        temp.remove(nums[i]);\n    }\n}\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>加入结果时，要注意引用问题，重新复制到一个新的list</li>\n<li>注意处理重复问题</li>\n<li>注意剪枝优化问题</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">private List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();\nprivate List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();\n\npublic List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target)\n{\n    Arrays.sort(candidates);\n    recursive(candidates, target,0);\n    return result;\n}\nvoid recursive(int[] candidates,int target,int begin)\n{\n    if(target==0)\n    {\n        result.add(new LinkedList&lt;&gt;(temp));//look 这里有引用问题,应该是复制一个新的给result\n        return;\n    }\n    for (int i = begin; i &lt; candidates.length; i++)\n    {\n        if(candidates[i]&gt;target) return;//剪枝条件\n\n        //look 注意越界问题\n        //可优化成开始条件\n        //if(!temp.isEmpty() &amp;&amp; candidates[i]&lt;temp.get(temp.size()-1)) continue;//剪枝条件 避免重复\n\n        temp.add(candidates[i]);//look 不需要sum\n        recursive(candidates,target-candidates[i],i);\n        temp.remove(temp.size()-1);\n    }\n}</code></pre>\n"},{"title":"LeetCode刷题笔记34","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"5ef01499","date":"2020-04-10T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n你的算法时间复杂度必须是 O(log n) 级别。\n\n如果数组中不存在目标值，返回 [-1, -1]。\n\n示例 1:\n```\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]\n```\n示例 2:\n```\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]\n```\n# 思路\n1. 第一种:直接找中点,然后向两边逐个找边界.\n2. 第二种:先二分查找到左边界,再二分查找右边界,删除即可\n\n\n\n\n# 代码\n```java\n//二分中心扩展性\npublic int[] searchRange(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo <= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n        if (nums[mid] == target)\n        {\n            int left = mid, right = mid;\n            while (left - 1 >= lo && nums[left - 1] == nums[mid]) --left;\n            while (right + 1 <= hi && nums[right + 1] == nums[mid]) ++right;\n            return new int[]{left, right};\n        }\n        else if (nums[mid] > target) hi = mid - 1;\n        else lo = mid + 1;\n\n    }\n    return new int[]{-1, -1};\n}\n```\n\n```java\n//查找左右边界\npublic int[] searchRange(int[] nums, int target)\n{\n    return new int[]{leftBound(nums, target), rightBound(nums, target)};\n}\n/*\n    寻找左边界\n    result的取值范围为[0,N],当target大于所有数组元素时,result取到了N\n*/\n\npublic int leftBound(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo <= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n\n        if (nums[mid] > target) hi = mid - 1;\n        else if (nums[mid] < target) lo = mid + 1;\n        else hi = mid - 1; //不直接返回,往左逼近\n    }\n    //只要找到了,lo是不会移动的\n    if(lo==nums.length || nums[lo]!=target) return -1;\n    return lo;\n}\n\npublic int rightBound(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo <= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n\n        if (nums[mid] > target) hi = mid - 1;\n        else if (nums[mid] < target) lo = mid + 1;\n        else lo = mid + 1; //不直接返回,往右边逼近\n    }\n    //只要找到了,hi是不会移动的 hi取值为[-1,N)\n    if(hi==-1 || nums[hi]!=target) return -1;\n    return hi;\n}\n```\n\n\n\n# 复杂度分析\n\n## 时间复杂度\n\n第一种方法:平均$O(log N)$,最坏$O(N)$,因为如果有很多重复的话,需要逐个遍历\n\n第二种方法:$O(log N)$,寻找左右边界,分别需要log N的时间\n\n## 空间复杂度\n\n$O(1)$,两种方法都只用了常数的时间","source":"_posts/LeetCode笔记/LeetCode刷题笔记_34. 在排序数组中查找元素的第一个和最后一个位置.md","raw":"---\ntitle: LeetCode刷题笔记34\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 二分搜索\nabbrlink: 5ef01499\ndate: 2020-04-11 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n你的算法时间复杂度必须是 O(log n) 级别。\n\n如果数组中不存在目标值，返回 [-1, -1]。\n\n示例 1:\n```\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]\n```\n示例 2:\n```\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]\n```\n# 思路\n1. 第一种:直接找中点,然后向两边逐个找边界.\n2. 第二种:先二分查找到左边界,再二分查找右边界,删除即可\n\n\n\n\n# 代码\n```java\n//二分中心扩展性\npublic int[] searchRange(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo <= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n        if (nums[mid] == target)\n        {\n            int left = mid, right = mid;\n            while (left - 1 >= lo && nums[left - 1] == nums[mid]) --left;\n            while (right + 1 <= hi && nums[right + 1] == nums[mid]) ++right;\n            return new int[]{left, right};\n        }\n        else if (nums[mid] > target) hi = mid - 1;\n        else lo = mid + 1;\n\n    }\n    return new int[]{-1, -1};\n}\n```\n\n```java\n//查找左右边界\npublic int[] searchRange(int[] nums, int target)\n{\n    return new int[]{leftBound(nums, target), rightBound(nums, target)};\n}\n/*\n    寻找左边界\n    result的取值范围为[0,N],当target大于所有数组元素时,result取到了N\n*/\n\npublic int leftBound(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo <= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n\n        if (nums[mid] > target) hi = mid - 1;\n        else if (nums[mid] < target) lo = mid + 1;\n        else hi = mid - 1; //不直接返回,往左逼近\n    }\n    //只要找到了,lo是不会移动的\n    if(lo==nums.length || nums[lo]!=target) return -1;\n    return lo;\n}\n\npublic int rightBound(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo <= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n\n        if (nums[mid] > target) hi = mid - 1;\n        else if (nums[mid] < target) lo = mid + 1;\n        else lo = mid + 1; //不直接返回,往右边逼近\n    }\n    //只要找到了,hi是不会移动的 hi取值为[-1,N)\n    if(hi==-1 || nums[hi]!=target) return -1;\n    return hi;\n}\n```\n\n\n\n# 复杂度分析\n\n## 时间复杂度\n\n第一种方法:平均$O(log N)$,最坏$O(N)$,因为如果有很多重复的话,需要逐个遍历\n\n第二种方法:$O(log N)$,寻找左右边界,分别需要log N的时间\n\n## 空间复杂度\n\n$O(1)$,两种方法都只用了常数的时间","slug":"LeetCode笔记/LeetCode刷题笔记_34. 在排序数组中查找元素的第一个和最后一个位置","published":1,"updated":"2020-11-12T11:57:29.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yi006ojotphvwlcj7o","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\" target=\"_blank\" rel=\"noopener\">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>\n<p>你的算法时间复杂度必须是 O(log n) 级别。</p>\n<p>如果数组中不存在目标值，返回 [-1, -1]。</p>\n<p>示例 1:</p>\n<pre><code>输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ol>\n<li>第一种:直接找中点,然后向两边逐个找边界.</li>\n<li>第二种:先二分查找到左边界,再二分查找右边界,删除即可</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//二分中心扩展性</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">searchRange</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> lo <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> hi <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>lo <span class=\"token operator\">&lt;=</span> hi<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> lo <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>hi <span class=\"token operator\">-</span> lo<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">,</span> right <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">>=</span> lo <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>left <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">--</span>left<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>right <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;=</span> hi <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>right <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">++</span>right<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span>left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> target<span class=\"token punctuation\">)</span> hi <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> lo <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//查找左右边界</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">searchRange</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span><span class=\"token function\">leftBound</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">rightBound</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/*\n    寻找左边界\n    result的取值范围为[0,N],当target大于所有数组元素时,result取到了N\n*/</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">leftBound</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> lo <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> hi <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>lo <span class=\"token operator\">&lt;=</span> hi<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> lo <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>hi <span class=\"token operator\">-</span> lo<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> target<span class=\"token punctuation\">)</span> hi <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> target<span class=\"token punctuation\">)</span> lo <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> hi <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//不直接返回,往左逼近</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//只要找到了,lo是不会移动的</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">==</span>nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">||</span> nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token operator\">!=</span>target<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> lo<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">rightBound</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> lo <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> hi <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>lo <span class=\"token operator\">&lt;=</span> hi<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> lo <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>hi <span class=\"token operator\">-</span> lo<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> target<span class=\"token punctuation\">)</span> hi <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> target<span class=\"token punctuation\">)</span> lo <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> lo <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//不直接返回,往右边逼近</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//只要找到了,hi是不会移动的 hi取值为[-1,N)</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>hi<span class=\"token operator\">==</span><span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">||</span> nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token operator\">!=</span>target<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> hi<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>第一种方法:平均$O(log N)$,最坏$O(N)$,因为如果有很多重复的话,需要逐个遍历</p>\n<p>第二种方法:$O(log N)$,寻找左右边界,分别需要log N的时间</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$,两种方法都只用了常数的时间</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\" target=\"_blank\" rel=\"noopener\">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>\n<p>你的算法时间复杂度必须是 O(log n) 级别。</p>\n<p>如果数组中不存在目标值，返回 [-1, -1]。</p>\n<p>示例 1:</p>\n<pre><code>输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ol>\n<li>第一种:直接找中点,然后向两边逐个找边界.</li>\n<li>第二种:先二分查找到左边界,再二分查找右边界,删除即可</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">//二分中心扩展性\npublic int[] searchRange(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo &lt;= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n        if (nums[mid] == target)\n        {\n            int left = mid, right = mid;\n            while (left - 1 &gt;= lo &amp;&amp; nums[left - 1] == nums[mid]) --left;\n            while (right + 1 &lt;= hi &amp;&amp; nums[right + 1] == nums[mid]) ++right;\n            return new int[]{left, right};\n        }\n        else if (nums[mid] &gt; target) hi = mid - 1;\n        else lo = mid + 1;\n\n    }\n    return new int[]{-1, -1};\n}</code></pre>\n<pre><code class=\"java\">//查找左右边界\npublic int[] searchRange(int[] nums, int target)\n{\n    return new int[]{leftBound(nums, target), rightBound(nums, target)};\n}\n/*\n    寻找左边界\n    result的取值范围为[0,N],当target大于所有数组元素时,result取到了N\n*/\n\npublic int leftBound(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo &lt;= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n\n        if (nums[mid] &gt; target) hi = mid - 1;\n        else if (nums[mid] &lt; target) lo = mid + 1;\n        else hi = mid - 1; //不直接返回,往左逼近\n    }\n    //只要找到了,lo是不会移动的\n    if(lo==nums.length || nums[lo]!=target) return -1;\n    return lo;\n}\n\npublic int rightBound(int[] nums, int target)\n{\n    int lo = 0, hi = nums.length - 1;\n    while (lo &lt;= hi)\n    {\n        int mid = lo + (hi - lo) / 2;\n\n        if (nums[mid] &gt; target) hi = mid - 1;\n        else if (nums[mid] &lt; target) lo = mid + 1;\n        else lo = mid + 1; //不直接返回,往右边逼近\n    }\n    //只要找到了,hi是不会移动的 hi取值为[-1,N)\n    if(hi==-1 || nums[hi]!=target) return -1;\n    return hi;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>第一种方法:平均$O(log N)$,最坏$O(N)$,因为如果有很多重复的话,需要逐个遍历</p>\n<p>第二种方法:$O(log N)$,寻找左右边界,分别需要log N的时间</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$,两种方法都只用了常数的时间</p>\n"},{"title":"LeetCode刷题笔记42","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"f8d2276b","date":"2020-04-14T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> \n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n\n**示例:**\n\n```\n输入: [0,1,0,2,1,0,1,3,2,1,2,1]\n输出: 6\n```\n\n# 思路\n\n找左边最高位置:从左往右遍历\n\n找右边最高位置:从右往左遍历\n\n找到每个位置的左边最高和右边最高高度,取他们较小的那个-那个位置的高度.即为该位置接的雨水\n\n把每个位置接的雨水累计即可\n\n# \n\n\n# 代码\n\n```java\npublic int trap(int[] height)\n{\n    int n = height.length;\n    if (n <= 2) return 0;//接不了雨水\n    int[] left = new int[n];\n    int[] right = new int[n];\n\n    left[0] = height[0];\n    for (int i = 1; i < n; i++) left[i] = Math.max(left[i - 1], height[i]);\n\n    right[n - 1] = height[n - 1];\n    for (int i = n - 2; i >= 0; i--) right[i] = Math.max(right[i + 1], height[i]);\n\n    int result = 0;\n\n    for (int i = 0; i < n; i++) result += (Math.min(left[i], right[i]) - height[i]);\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$,三次循环,每次需要N,总共3N\n\n## 空间复杂度\n\n$O(N)$,定义两个大小为N的数组,总共需要空间为2N","source":"_posts/LeetCode笔记/LeetCode刷题笔记_42. 接雨水.md","raw":"---\ntitle: LeetCode刷题笔记42\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 数组\nabbrlink: f8d2276b\ndate: 2020-04-15 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> \n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n\n**示例:**\n\n```\n输入: [0,1,0,2,1,0,1,3,2,1,2,1]\n输出: 6\n```\n\n# 思路\n\n找左边最高位置:从左往右遍历\n\n找右边最高位置:从右往左遍历\n\n找到每个位置的左边最高和右边最高高度,取他们较小的那个-那个位置的高度.即为该位置接的雨水\n\n把每个位置接的雨水累计即可\n\n# \n\n\n# 代码\n\n```java\npublic int trap(int[] height)\n{\n    int n = height.length;\n    if (n <= 2) return 0;//接不了雨水\n    int[] left = new int[n];\n    int[] right = new int[n];\n\n    left[0] = height[0];\n    for (int i = 1; i < n; i++) left[i] = Math.max(left[i - 1], height[i]);\n\n    right[n - 1] = height[n - 1];\n    for (int i = n - 2; i >= 0; i--) right[i] = Math.max(right[i + 1], height[i]);\n\n    int result = 0;\n\n    for (int i = 0; i < n; i++) result += (Math.min(left[i], right[i]) - height[i]);\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$,三次循环,每次需要N,总共3N\n\n## 空间复杂度\n\n$O(N)$,定义两个大小为N的数组,总共需要空间为2N","slug":"LeetCode笔记/LeetCode刷题笔记_42. 接雨水","published":1,"updated":"2020-11-12T11:57:29.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yi006rjotp0qz60x2w","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>\n<p><strong>示例:</strong></p>\n<pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]\n输出: 6</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>找左边最高位置:从左往右遍历</p>\n<p>找右边最高位置:从右往左遍历</p>\n<p>找到每个位置的左边最高和右边最高高度,取他们较小的那个-那个位置的高度.即为该位置接的雨水</p>\n<p>把每个位置接的雨水累计即可</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">trap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> height<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> height<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//接不了雨水</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> left <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> right <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    left<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> height<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> left<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    right<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> height<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> right<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> result <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> height<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$,三次循环,每次需要N,总共3N</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(N)$,定义两个大小为N的数组,总共需要空间为2N</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>\n<p><strong>示例:</strong></p>\n<pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]\n输出: 6</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>找左边最高位置:从左往右遍历</p>\n<p>找右边最高位置:从右往左遍历</p>\n<p>找到每个位置的左边最高和右边最高高度,取他们较小的那个-那个位置的高度.即为该位置接的雨水</p>\n<p>把每个位置接的雨水累计即可</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int trap(int[] height)\n{\n    int n = height.length;\n    if (n &lt;= 2) return 0;//接不了雨水\n    int[] left = new int[n];\n    int[] right = new int[n];\n\n    left[0] = height[0];\n    for (int i = 1; i &lt; n; i++) left[i] = Math.max(left[i - 1], height[i]);\n\n    right[n - 1] = height[n - 1];\n    for (int i = n - 2; i &gt;= 0; i--) right[i] = Math.max(right[i + 1], height[i]);\n\n    int result = 0;\n\n    for (int i = 0; i &lt; n; i++) result += (Math.min(left[i], right[i]) - height[i]);\n    return result;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$,三次循环,每次需要N,总共3N</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(N)$,定义两个大小为N的数组,总共需要空间为2N</p>\n"},{"title":"LeetCode刷题笔记46","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"ffbfe372","date":"2020-04-15T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [46. 全排列](https://leetcode-cn.com/problems/permutations/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n\n示例:\n\n```\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n\n\n# 思路\n\n传统的回溯法,和之前的差不多\n\n只是要处理重复问题,可以用marked数组解决\n\n\n\n\n# 代码\n\n```java\n/*\n    这里没有说是按照数字大小的顺序,只要排序没有重复即可\n    而这里的直接按照初始的数字顺利得到全排列 例如:7,6,8,1\n    这里第一个是7,6,8,1\n    而下面那个是,1,6,7,8\n    */\nprivate List<List<Integer>> result = new LinkedList<>();\nprivate List<Integer> temp = new LinkedList<>();\nprivate boolean[] marked;\npublic List<List<Integer>> permute(int[] nums)\n{\n    marked = new boolean[nums.length];\n    recursive(nums,0);\n    return result;\n}\n\nprivate void recursive(int[] nums,int length)\n{\n    if(length==nums.length)\n    {\n        result.add(new LinkedList<>(temp));//防止引用问题\n        return;//终止循环\n    }\n    for (int i = 0; i < nums.length; i++)\n    {\n        //用一个标记数组更加快\n        //            if(!temp.contains(nums[i]))//避免重复的\n        //            {\n        //                temp.add(nums[i]);\n        //                recursive(nums,length+1);\n        //                temp.remove(temp.size()-1);\n        //            }\n\n        if(!marked[i])\n        {\n            temp.add(nums[i]);\n            marked[i] = true;\n            recursive(nums,length+1);\n            marked[i] = false;\n            temp.remove(temp.size()-1);\n        }\n    }\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n最坏时间复杂度:$O(N×N!)$\n\n## 空间复杂度\n\n$O(N)$","source":"_posts/LeetCode笔记/LeetCode刷题笔记_46. 全排列.md","raw":"---\ntitle: LeetCode刷题笔记46\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 全排列\nabbrlink: ffbfe372\ndate: 2020-04-16 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [46. 全排列](https://leetcode-cn.com/problems/permutations/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n\n示例:\n\n```\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n\n\n# 思路\n\n传统的回溯法,和之前的差不多\n\n只是要处理重复问题,可以用marked数组解决\n\n\n\n\n# 代码\n\n```java\n/*\n    这里没有说是按照数字大小的顺序,只要排序没有重复即可\n    而这里的直接按照初始的数字顺利得到全排列 例如:7,6,8,1\n    这里第一个是7,6,8,1\n    而下面那个是,1,6,7,8\n    */\nprivate List<List<Integer>> result = new LinkedList<>();\nprivate List<Integer> temp = new LinkedList<>();\nprivate boolean[] marked;\npublic List<List<Integer>> permute(int[] nums)\n{\n    marked = new boolean[nums.length];\n    recursive(nums,0);\n    return result;\n}\n\nprivate void recursive(int[] nums,int length)\n{\n    if(length==nums.length)\n    {\n        result.add(new LinkedList<>(temp));//防止引用问题\n        return;//终止循环\n    }\n    for (int i = 0; i < nums.length; i++)\n    {\n        //用一个标记数组更加快\n        //            if(!temp.contains(nums[i]))//避免重复的\n        //            {\n        //                temp.add(nums[i]);\n        //                recursive(nums,length+1);\n        //                temp.remove(temp.size()-1);\n        //            }\n\n        if(!marked[i])\n        {\n            temp.add(nums[i]);\n            marked[i] = true;\n            recursive(nums,length+1);\n            marked[i] = false;\n            temp.remove(temp.size()-1);\n        }\n    }\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n最坏时间复杂度:$O(N×N!)$\n\n## 空间复杂度\n\n$O(N)$","slug":"LeetCode笔记/LeetCode刷题笔记_46. 全排列","published":1,"updated":"2020-11-12T11:57:29.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yk006vjotpdi4bhgf3","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/permutations/\" target=\"_blank\" rel=\"noopener\">46. 全排列</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>\n<p>示例:</p>\n<pre><code>输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>传统的回溯法,和之前的差不多</p>\n<p>只是要处理重复问题,可以用marked数组解决</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/*\n    这里没有说是按照数字大小的顺序,只要排序没有重复即可\n    而这里的直接按照初始的数字顺利得到全排列 例如:7,6,8,1\n    这里第一个是7,6,8,1\n    而下面那个是,1,6,7,8\n    */</span>\n<span class=\"token keyword\">private</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> temp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> marked<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> <span class=\"token function\">permute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    marked <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">boolean</span><span class=\"token punctuation\">[</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> length<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>length<span class=\"token operator\">==</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//防止引用问题</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//终止循环</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//用一个标记数组更加快</span>\n        <span class=\"token comment\" spellcheck=\"true\">//            if(!temp.contains(nums[i]))//避免重复的</span>\n        <span class=\"token comment\" spellcheck=\"true\">//            {</span>\n        <span class=\"token comment\" spellcheck=\"true\">//                temp.add(nums[i]);</span>\n        <span class=\"token comment\" spellcheck=\"true\">//                recursive(nums,length+1);</span>\n        <span class=\"token comment\" spellcheck=\"true\">//                temp.remove(temp.size()-1);</span>\n        <span class=\"token comment\" spellcheck=\"true\">//            }</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>marked<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            temp<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            marked<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span>length<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            marked<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            temp<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>最坏时间复杂度:$O(N×N!)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(N)$</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/permutations/\" target=\"_blank\" rel=\"noopener\">46. 全排列</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>\n<p>示例:</p>\n<pre><code>输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>传统的回溯法,和之前的差不多</p>\n<p>只是要处理重复问题,可以用marked数组解决</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">/*\n    这里没有说是按照数字大小的顺序,只要排序没有重复即可\n    而这里的直接按照初始的数字顺利得到全排列 例如:7,6,8,1\n    这里第一个是7,6,8,1\n    而下面那个是,1,6,7,8\n    */\nprivate List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();\nprivate List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();\nprivate boolean[] marked;\npublic List&lt;List&lt;Integer&gt;&gt; permute(int[] nums)\n{\n    marked = new boolean[nums.length];\n    recursive(nums,0);\n    return result;\n}\n\nprivate void recursive(int[] nums,int length)\n{\n    if(length==nums.length)\n    {\n        result.add(new LinkedList&lt;&gt;(temp));//防止引用问题\n        return;//终止循环\n    }\n    for (int i = 0; i &lt; nums.length; i++)\n    {\n        //用一个标记数组更加快\n        //            if(!temp.contains(nums[i]))//避免重复的\n        //            {\n        //                temp.add(nums[i]);\n        //                recursive(nums,length+1);\n        //                temp.remove(temp.size()-1);\n        //            }\n\n        if(!marked[i])\n        {\n            temp.add(nums[i]);\n            marked[i] = true;\n            recursive(nums,length+1);\n            marked[i] = false;\n            temp.remove(temp.size()-1);\n        }\n    }\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>最坏时间复杂度:$O(N×N!)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(N)$</p>\n"},{"title":"LeetCode刷题笔记49","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"6f00fee3","date":"2020-04-19T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n示例:\n```\n输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n输出:\n[\n  [\"ate\",\"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n```\n说明：\n\n所有输入均为小写字母。\n\t\t不考虑答案输出的顺序。\n\n# 思路\n\n用一个Map存储索引和索引对应的组。索引是由字母异位词算出来的唯一标识。这样，遍历strs数组，把索引相同的字符串放在同一组中即可\n\n关于索引的计算，可以将每个字母与一个素数绑定。对于一个字符串，则将包含的每个字母对于的素数相乘，得到的和即为索引\n\n\n\n第二种写法和上一种相似：map存储字典序字符串和对应的组。每次循环都把字符串转为字典序字符串，再判断\n\n# 细节\n\nmap直接存储用于区分组的索引，和List组即可，节约内存\n\n\n# 代码\n\n```java\n//生成素数\nprivate List<Integer> prime()\n{\n    int N = 26;\n    List<Integer> result = new LinkedList<>();\n\n    for (int i = 2; i < 1000; i++)\n    {\n        int j;\n        for (j = i - 1; j > 1; j--)\n        {\n            if (i % j == 0) break;\n        }\n        if(j==1) result.add(i);\n        if(result.size()==N) break;\n    }\n    return result;\n}\n```\n\n```java\n//素数可以提前生成好\npublic List<List<String>> groupAnagrams(String[] strs)\n{\n    Map<Integer, List<String>> map = new HashMap<>();\n    //List<Integer> prime = prime();\n    //预先准备好\n    int[] prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\n    for (String string : strs)\n    {\n        int index = 1;\n        for (char ch : string.toCharArray())\n        {\n            //                index*=prime.get(ch - 'a');\n            index*=prime[ch-'a'];\n        }\n        if(!map.containsKey(index)) map.put(index, new LinkedList<>());\n        map.get(index).add(string);\n    }\n    return new LinkedList<>(map.values());\n}\n```\n\n```java\n//第二种思路\n//map存储字典序字符串和对应的组。每次循环都把字符串转为字典序字符串，再判断\npublic List<List<String>> groupAnagrams1(String[] strs)\n{\n    Map<String, List<String>> map = new HashMap<>();\n    for (int i = 0; i < strs.length; i++)\n    {\n        //map中只存储字典序字符串\n        char[] chars = strs[i].toCharArray();\n        Arrays.sort(chars);\n        String string = String.valueOf(chars);\n        //第一次放入某类型的字母异位词\n        if (!map.containsKey(string)) map.put(string, new LinkedList<>());\n\n        map.get(string).add(strs[i]);\n    }\n    return new LinkedList<>(map.values());\n}\n```\n\n# 复杂度分析\n\n## 时间复杂度\n\n第一种方法：$O(NK)$ N是数组的长度，K是字符串的最大长度。外部循环需要遍历一遍字符串数组，内部需要对每个字符串进行索引计算。\n\n第二种方法：$O(NK \\log K)$   N是数组的长度，K是字符串的最大长度。外部循环需要遍历一遍字符串数组。内部需要对每个字符串进行排序\n\n## 空间复杂度\n\n$O(NK)$ 存储在Map的values中共需要NK的空间","source":"_posts/LeetCode笔记/LeetCode刷题笔记_49. 字母异位词分组.md","raw":"---\ntitle: LeetCode刷题笔记49\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 字符串\nabbrlink: 6f00fee3\ndate: 2020-04-20 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n示例:\n```\n输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n输出:\n[\n  [\"ate\",\"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n```\n说明：\n\n所有输入均为小写字母。\n\t\t不考虑答案输出的顺序。\n\n# 思路\n\n用一个Map存储索引和索引对应的组。索引是由字母异位词算出来的唯一标识。这样，遍历strs数组，把索引相同的字符串放在同一组中即可\n\n关于索引的计算，可以将每个字母与一个素数绑定。对于一个字符串，则将包含的每个字母对于的素数相乘，得到的和即为索引\n\n\n\n第二种写法和上一种相似：map存储字典序字符串和对应的组。每次循环都把字符串转为字典序字符串，再判断\n\n# 细节\n\nmap直接存储用于区分组的索引，和List组即可，节约内存\n\n\n# 代码\n\n```java\n//生成素数\nprivate List<Integer> prime()\n{\n    int N = 26;\n    List<Integer> result = new LinkedList<>();\n\n    for (int i = 2; i < 1000; i++)\n    {\n        int j;\n        for (j = i - 1; j > 1; j--)\n        {\n            if (i % j == 0) break;\n        }\n        if(j==1) result.add(i);\n        if(result.size()==N) break;\n    }\n    return result;\n}\n```\n\n```java\n//素数可以提前生成好\npublic List<List<String>> groupAnagrams(String[] strs)\n{\n    Map<Integer, List<String>> map = new HashMap<>();\n    //List<Integer> prime = prime();\n    //预先准备好\n    int[] prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\n    for (String string : strs)\n    {\n        int index = 1;\n        for (char ch : string.toCharArray())\n        {\n            //                index*=prime.get(ch - 'a');\n            index*=prime[ch-'a'];\n        }\n        if(!map.containsKey(index)) map.put(index, new LinkedList<>());\n        map.get(index).add(string);\n    }\n    return new LinkedList<>(map.values());\n}\n```\n\n```java\n//第二种思路\n//map存储字典序字符串和对应的组。每次循环都把字符串转为字典序字符串，再判断\npublic List<List<String>> groupAnagrams1(String[] strs)\n{\n    Map<String, List<String>> map = new HashMap<>();\n    for (int i = 0; i < strs.length; i++)\n    {\n        //map中只存储字典序字符串\n        char[] chars = strs[i].toCharArray();\n        Arrays.sort(chars);\n        String string = String.valueOf(chars);\n        //第一次放入某类型的字母异位词\n        if (!map.containsKey(string)) map.put(string, new LinkedList<>());\n\n        map.get(string).add(strs[i]);\n    }\n    return new LinkedList<>(map.values());\n}\n```\n\n# 复杂度分析\n\n## 时间复杂度\n\n第一种方法：$O(NK)$ N是数组的长度，K是字符串的最大长度。外部循环需要遍历一遍字符串数组，内部需要对每个字符串进行索引计算。\n\n第二种方法：$O(NK \\log K)$   N是数组的长度，K是字符串的最大长度。外部循环需要遍历一遍字符串数组。内部需要对每个字符串进行排序\n\n## 空间复杂度\n\n$O(NK)$ 存储在Map的values中共需要NK的空间","slug":"LeetCode笔记/LeetCode刷题笔记_49. 字母异位词分组","published":1,"updated":"2020-11-12T11:57:29.671Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yk006yjotpd67uchk1","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/group-anagrams/\" target=\"_blank\" rel=\"noopener\">49. 字母异位词分组</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>\n<p>示例:</p>\n<pre><code>输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]\n输出:\n[\n  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],\n  [&quot;nat&quot;,&quot;tan&quot;],\n  [&quot;bat&quot;]\n]</code></pre>\n<p>说明：</p>\n<p>所有输入均为小写字母。<br>        不考虑答案输出的顺序。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>用一个Map存储索引和索引对应的组。索引是由字母异位词算出来的唯一标识。这样，遍历strs数组，把索引相同的字符串放在同一组中即可</p>\n<p>关于索引的计算，可以将每个字母与一个素数绑定。对于一个字符串，则将包含的每个字母对于的素数相乘，得到的和即为索引</p>\n<p>第二种写法和上一种相似：map存储字典序字符串和对应的组。每次循环都把字符串转为字典序字符串，再判断</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>map直接存储用于区分组的索引，和List组即可，节约内存</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//生成素数</span>\n<span class=\"token keyword\">private</span> List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> <span class=\"token function\">prime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">26</span><span class=\"token punctuation\">;</span>\n    List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">=</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">%</span> j <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">==</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span>N<span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//素数可以提前生成好</span>\n<span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">>></span> <span class=\"token function\">groupAnagrams</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> strs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">>></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//List&lt;Integer> prime = prime();</span>\n    <span class=\"token comment\" spellcheck=\"true\">//预先准备好</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> prime <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">,</span> <span class=\"token number\">13</span><span class=\"token punctuation\">,</span> <span class=\"token number\">17</span><span class=\"token punctuation\">,</span> <span class=\"token number\">19</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span> <span class=\"token number\">31</span><span class=\"token punctuation\">,</span> <span class=\"token number\">37</span><span class=\"token punctuation\">,</span> <span class=\"token number\">41</span><span class=\"token punctuation\">,</span> <span class=\"token number\">43</span><span class=\"token punctuation\">,</span> <span class=\"token number\">47</span><span class=\"token punctuation\">,</span> <span class=\"token number\">53</span><span class=\"token punctuation\">,</span> <span class=\"token number\">59</span><span class=\"token punctuation\">,</span> <span class=\"token number\">61</span><span class=\"token punctuation\">,</span> <span class=\"token number\">67</span><span class=\"token punctuation\">,</span> <span class=\"token number\">71</span><span class=\"token punctuation\">,</span> <span class=\"token number\">73</span><span class=\"token punctuation\">,</span> <span class=\"token number\">79</span><span class=\"token punctuation\">,</span> <span class=\"token number\">83</span><span class=\"token punctuation\">,</span> <span class=\"token number\">89</span><span class=\"token punctuation\">,</span> <span class=\"token number\">97</span><span class=\"token punctuation\">,</span> <span class=\"token number\">101</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>String string <span class=\"token operator\">:</span> strs<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> ch <span class=\"token operator\">:</span> string<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//                index*=prime.get(ch - 'a');</span>\n            index<span class=\"token operator\">*=</span>prime<span class=\"token punctuation\">[</span>ch<span class=\"token operator\">-</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//第二种思路</span>\n<span class=\"token comment\" spellcheck=\"true\">//map存储字典序字符串和对应的组。每次循环都把字符串转为字典序字符串，再判断</span>\n<span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">>></span> <span class=\"token function\">groupAnagrams1</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> strs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">>></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> strs<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//map中只存储字典序字符串</span>\n        <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> chars <span class=\"token operator\">=</span> strs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>chars<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        String string <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>chars<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//第一次放入某类型的字母异位词</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>strs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>第一种方法：$O(NK)$ N是数组的长度，K是字符串的最大长度。外部循环需要遍历一遍字符串数组，内部需要对每个字符串进行索引计算。</p>\n<p>第二种方法：$O(NK \\log K)$   N是数组的长度，K是字符串的最大长度。外部循环需要遍历一遍字符串数组。内部需要对每个字符串进行排序</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(NK)$ 存储在Map的values中共需要NK的空间</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/group-anagrams/\" target=\"_blank\" rel=\"noopener\">49. 字母异位词分组</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>\n<p>示例:</p>\n<pre><code>输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]\n输出:\n[\n  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],\n  [&quot;nat&quot;,&quot;tan&quot;],\n  [&quot;bat&quot;]\n]</code></pre>\n<p>说明：</p>\n<p>所有输入均为小写字母。<br>        不考虑答案输出的顺序。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>用一个Map存储索引和索引对应的组。索引是由字母异位词算出来的唯一标识。这样，遍历strs数组，把索引相同的字符串放在同一组中即可</p>\n<p>关于索引的计算，可以将每个字母与一个素数绑定。对于一个字符串，则将包含的每个字母对于的素数相乘，得到的和即为索引</p>\n<p>第二种写法和上一种相似：map存储字典序字符串和对应的组。每次循环都把字符串转为字典序字符串，再判断</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>map直接存储用于区分组的索引，和List组即可，节约内存</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">//生成素数\nprivate List&lt;Integer&gt; prime()\n{\n    int N = 26;\n    List&lt;Integer&gt; result = new LinkedList&lt;&gt;();\n\n    for (int i = 2; i &lt; 1000; i++)\n    {\n        int j;\n        for (j = i - 1; j &gt; 1; j--)\n        {\n            if (i % j == 0) break;\n        }\n        if(j==1) result.add(i);\n        if(result.size()==N) break;\n    }\n    return result;\n}</code></pre>\n<pre><code class=\"java\">//素数可以提前生成好\npublic List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs)\n{\n    Map&lt;Integer, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();\n    //List&lt;Integer&gt; prime = prime();\n    //预先准备好\n    int[] prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\n    for (String string : strs)\n    {\n        int index = 1;\n        for (char ch : string.toCharArray())\n        {\n            //                index*=prime.get(ch - &#39;a&#39;);\n            index*=prime[ch-&#39;a&#39;];\n        }\n        if(!map.containsKey(index)) map.put(index, new LinkedList&lt;&gt;());\n        map.get(index).add(string);\n    }\n    return new LinkedList&lt;&gt;(map.values());\n}</code></pre>\n<pre><code class=\"java\">//第二种思路\n//map存储字典序字符串和对应的组。每次循环都把字符串转为字典序字符串，再判断\npublic List&lt;List&lt;String&gt;&gt; groupAnagrams1(String[] strs)\n{\n    Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();\n    for (int i = 0; i &lt; strs.length; i++)\n    {\n        //map中只存储字典序字符串\n        char[] chars = strs[i].toCharArray();\n        Arrays.sort(chars);\n        String string = String.valueOf(chars);\n        //第一次放入某类型的字母异位词\n        if (!map.containsKey(string)) map.put(string, new LinkedList&lt;&gt;());\n\n        map.get(string).add(strs[i]);\n    }\n    return new LinkedList&lt;&gt;(map.values());\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>第一种方法：$O(NK)$ N是数组的长度，K是字符串的最大长度。外部循环需要遍历一遍字符串数组，内部需要对每个字符串进行索引计算。</p>\n<p>第二种方法：$O(NK \\log K)$   N是数组的长度，K是字符串的最大长度。外部循环需要遍历一遍字符串数组。内部需要对每个字符串进行排序</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(NK)$ 存储在Map的values中共需要NK的空间</p>\n"},{"title":"LeetCode刷题笔记53","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"96ce26bc","date":"2020-04-21T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n示例:\n```\n输入: [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n```\n进阶:\n\n如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。\n\n# 思路\n\n从左往右遍历,如果大于0,则保留,否则不要。result则每个时刻都要判断\n\n# 细节\n\n因为子数组最少包含一个元素，所以初始化不能为0，而应该是int的最小值\n\n\n# 代码\n\n```java\n//子数组最少包含一个元素\npublic int maxSubArray(int[] nums)\n{\n    int N = nums.length;\n    int result = Integer.MIN_VALUE,temp=0;//look,因为条件是至少包含\n    for (int i = 0; i < N; i++)\n    {\n        temp = temp > 0 ? temp + nums[i] : nums[i];\n        result = Math.max(result, temp);\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$\n\n## 空间复杂度\n\n$O(1)$","source":"_posts/LeetCode笔记/LeetCode刷题笔记_53. 最大子序和.md","raw":"---\ntitle: LeetCode刷题笔记53\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 数组\nabbrlink: 96ce26bc\ndate: 2020-04-22 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n示例:\n```\n输入: [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n```\n进阶:\n\n如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。\n\n# 思路\n\n从左往右遍历,如果大于0,则保留,否则不要。result则每个时刻都要判断\n\n# 细节\n\n因为子数组最少包含一个元素，所以初始化不能为0，而应该是int的最小值\n\n\n# 代码\n\n```java\n//子数组最少包含一个元素\npublic int maxSubArray(int[] nums)\n{\n    int N = nums.length;\n    int result = Integer.MIN_VALUE,temp=0;//look,因为条件是至少包含\n    for (int i = 0; i < N; i++)\n    {\n        temp = temp > 0 ? temp + nums[i] : nums[i];\n        result = Math.max(result, temp);\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$\n\n## 空间复杂度\n\n$O(1)$","slug":"LeetCode笔记/LeetCode刷题笔记_53. 最大子序和","published":1,"updated":"2020-11-12T11:57:29.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yn0071jotp246cf92o","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">53. 最大子序和</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p>示例:</p>\n<pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre>\n<p>进阶:</p>\n<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>从左往右遍历,如果大于0,则保留,否则不要。result则每个时刻都要判断</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>因为子数组最少包含一个元素，所以初始化不能为0，而应该是int的最小值</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//子数组最少包含一个元素</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxSubArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> Integer<span class=\"token punctuation\">.</span>MIN_VALUE<span class=\"token punctuation\">,</span>temp<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look,因为条件是至少包含</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        temp <span class=\"token operator\">=</span> temp <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> temp <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">53. 最大子序和</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p>示例:</p>\n<pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre>\n<p>进阶:</p>\n<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>从左往右遍历,如果大于0,则保留,否则不要。result则每个时刻都要判断</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>因为子数组最少包含一个元素，所以初始化不能为0，而应该是int的最小值</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">//子数组最少包含一个元素\npublic int maxSubArray(int[] nums)\n{\n    int N = nums.length;\n    int result = Integer.MIN_VALUE,temp=0;//look,因为条件是至少包含\n    for (int i = 0; i &lt; N; i++)\n    {\n        temp = temp &gt; 0 ? temp + nums[i] : nums[i];\n        result = Math.max(result, temp);\n    }\n    return result;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$</p>\n"},{"title":"LeetCode刷题笔记55","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"7fad8389","date":"2020-04-22T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个位置。\n\n示例 1:\n```\n输入: [2,3,1,1,4]\n输出: true\n解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\n```\n示例 2:\n```\n输入: [3,2,1,0,4]\n输出: false\n解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n```\n\n# 思路\n\n```java\n//伪代码\nint i=0;//所处位置\nint jump=0;//能跳到的最远位置\nwhile(i<=jump)\n{\n    jump=max(jump,i+nums[i]);//i+nums[i]为通过i位置能跳到的最远处\n    if(jump>=nums.length-1) return true;\n    ++i;//不断往前走一格\n}\nreturn false;\n```\n\n\n\n\n\n\n# 代码\n\n```java\npublic boolean canJump(int[] nums)\n{\n    int i = 0;//所处位置\n    int jump = 0;//能跳到的最远位置\n    while (i <= jump)\n    {\n        jump = Math.max(jump, i + nums[i]);//i+nums[i]为通过i位置能跳到的最远处\n        if (jump >= nums.length - 1) return true;\n        ++i;//不断往前走一格\n    }\n    return false;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$,只需要遍历一次数组\n\n## 空间复杂度\n\n$O(1)$,只有两个索引","source":"_posts/LeetCode笔记/LeetCode刷题笔记_55. 跳跃游戏.md","raw":"---\ntitle: LeetCode刷题笔记55\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 数组\nabbrlink: 7fad8389\ndate: 2020-04-23 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个位置。\n\n示例 1:\n```\n输入: [2,3,1,1,4]\n输出: true\n解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\n```\n示例 2:\n```\n输入: [3,2,1,0,4]\n输出: false\n解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n```\n\n# 思路\n\n```java\n//伪代码\nint i=0;//所处位置\nint jump=0;//能跳到的最远位置\nwhile(i<=jump)\n{\n    jump=max(jump,i+nums[i]);//i+nums[i]为通过i位置能跳到的最远处\n    if(jump>=nums.length-1) return true;\n    ++i;//不断往前走一格\n}\nreturn false;\n```\n\n\n\n\n\n\n# 代码\n\n```java\npublic boolean canJump(int[] nums)\n{\n    int i = 0;//所处位置\n    int jump = 0;//能跳到的最远位置\n    while (i <= jump)\n    {\n        jump = Math.max(jump, i + nums[i]);//i+nums[i]为通过i位置能跳到的最远处\n        if (jump >= nums.length - 1) return true;\n        ++i;//不断往前走一格\n    }\n    return false;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$,只需要遍历一次数组\n\n## 空间复杂度\n\n$O(1)$,只有两个索引","slug":"LeetCode笔记/LeetCode刷题笔记_55. 跳跃游戏","published":1,"updated":"2020-11-12T11:57:29.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yo0073jotpbskj35ch","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">55. 跳跃游戏</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>判断你是否能够到达最后一个位置。</p>\n<p>示例 1:</p>\n<pre><code>输入: [2,3,1,1,4]\n输出: true\n解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: [3,2,1,0,4]\n输出: false\n解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//伪代码</span>\n<span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//所处位置</span>\n<span class=\"token keyword\">int</span> jump<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//能跳到的最远位置</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">&lt;=</span>jump<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    jump<span class=\"token operator\">=</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>jump<span class=\"token punctuation\">,</span>i<span class=\"token operator\">+</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//i+nums[i]为通过i位置能跳到的最远处</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>jump<span class=\"token operator\">>=</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">++</span>i<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//不断往前走一格</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></code></pre>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">canJump</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//所处位置</span>\n    <span class=\"token keyword\">int</span> jump <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//能跳到的最远位置</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> jump<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        jump <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>jump<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//i+nums[i]为通过i位置能跳到的最远处</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>jump <span class=\"token operator\">>=</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token operator\">++</span>i<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//不断往前走一格</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$,只需要遍历一次数组</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$,只有两个索引</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">55. 跳跃游戏</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>判断你是否能够到达最后一个位置。</p>\n<p>示例 1:</p>\n<pre><code>输入: [2,3,1,1,4]\n输出: true\n解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: [3,2,1,0,4]\n输出: false\n解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code class=\"java\">//伪代码\nint i=0;//所处位置\nint jump=0;//能跳到的最远位置\nwhile(i&lt;=jump)\n{\n    jump=max(jump,i+nums[i]);//i+nums[i]为通过i位置能跳到的最远处\n    if(jump&gt;=nums.length-1) return true;\n    ++i;//不断往前走一格\n}\nreturn false;</code></pre>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public boolean canJump(int[] nums)\n{\n    int i = 0;//所处位置\n    int jump = 0;//能跳到的最远位置\n    while (i &lt;= jump)\n    {\n        jump = Math.max(jump, i + nums[i]);//i+nums[i]为通过i位置能跳到的最远处\n        if (jump &gt;= nums.length - 1) return true;\n        ++i;//不断往前走一格\n    }\n    return false;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$,只需要遍历一次数组</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$,只有两个索引</p>\n"},{"title":"LeetCode刷题笔记48","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"1807ce75","date":"2020-04-17T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个 n × n 的二维矩阵表示一个图像。\n\n将图像顺时针旋转 90 度。\n\n说明：\n\n你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\n\n示例 1:\n```\n给定 matrix = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\n原地旋转输入矩阵，使其变为:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n```\n示例 2:\n```\n给定 matrix =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\n原地旋转输入矩阵，使其变为:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n```\n\n\n# 思路\n外围旋转中,只需要把[0,0],到[0,n-2]的依次与对应的四个角旋转即可\n因为是方阵,所以定义lo,hi表示遍历的上层,遍历的下层,而且对左右也是有用的\n# 细节\n\n\n# 代码\n\n```java\npublic void rotate(int[][] matrix)\n{\n    int lo = 0, hi = matrix.length - 1;\n    while(lo<hi)\n    {\n        for (int i = 0; i < hi - lo; i++)\n        {\n            int temp=matrix[lo][lo+i];\n            matrix[lo][lo + i] = matrix[hi - i][lo];\n            matrix[hi - i][lo] = matrix[hi][hi - i];\n            matrix[hi][hi - i] = matrix[lo + i][hi];\n            matrix[lo + i][hi] = temp;\n        }\n        ++lo;\n        --hi;\n    }\n}\n```\n\n\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_48. 旋转图像.md","raw":"---\ntitle: LeetCode刷题笔记48\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 矩阵\nabbrlink: 1807ce75\ndate: 2020-04-18 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个 n × n 的二维矩阵表示一个图像。\n\n将图像顺时针旋转 90 度。\n\n说明：\n\n你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\n\n示例 1:\n```\n给定 matrix = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\n原地旋转输入矩阵，使其变为:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n```\n示例 2:\n```\n给定 matrix =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\n原地旋转输入矩阵，使其变为:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n```\n\n\n# 思路\n外围旋转中,只需要把[0,0],到[0,n-2]的依次与对应的四个角旋转即可\n因为是方阵,所以定义lo,hi表示遍历的上层,遍历的下层,而且对左右也是有用的\n# 细节\n\n\n# 代码\n\n```java\npublic void rotate(int[][] matrix)\n{\n    int lo = 0, hi = matrix.length - 1;\n    while(lo<hi)\n    {\n        for (int i = 0; i < hi - lo; i++)\n        {\n            int temp=matrix[lo][lo+i];\n            matrix[lo][lo + i] = matrix[hi - i][lo];\n            matrix[hi - i][lo] = matrix[hi][hi - i];\n            matrix[hi][hi - i] = matrix[lo + i][hi];\n            matrix[lo + i][hi] = temp;\n        }\n        ++lo;\n        --hi;\n    }\n}\n```\n\n\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_48. 旋转图像","published":1,"updated":"2020-11-12T11:57:29.643Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yp0076jotpfrxze2h0","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/rotate-image/\" target=\"_blank\" rel=\"noopener\">48. 旋转图像</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个 n × n 的二维矩阵表示一个图像。</p>\n<p>将图像顺时针旋转 90 度。</p>\n<p>说明：</p>\n<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>\n<p>示例 1:</p>\n<pre><code>给定 matrix = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\n原地旋转输入矩阵，使其变为:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]</code></pre>\n<p>示例 2:</p>\n<pre><code>给定 matrix =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\n原地旋转输入矩阵，使其变为:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>外围旋转中,只需要把[0,0],到[0,n-2]的依次与对应的四个角旋转即可<br>因为是方阵,所以定义lo,hi表示遍历的上层,遍历的下层,而且对左右也是有用的</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> matrix<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> lo <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> hi <span class=\"token operator\">=</span> matrix<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>lo<span class=\"token operator\">&lt;</span>hi<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> hi <span class=\"token operator\">-</span> lo<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> temp<span class=\"token operator\">=</span>matrix<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>lo<span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            matrix<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>lo <span class=\"token operator\">+</span> i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> matrix<span class=\"token punctuation\">[</span>hi <span class=\"token operator\">-</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            matrix<span class=\"token punctuation\">[</span>hi <span class=\"token operator\">-</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> matrix<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>hi <span class=\"token operator\">-</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            matrix<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>hi <span class=\"token operator\">-</span> i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> matrix<span class=\"token punctuation\">[</span>lo <span class=\"token operator\">+</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            matrix<span class=\"token punctuation\">[</span>lo <span class=\"token operator\">+</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">++</span>lo<span class=\"token punctuation\">;</span>\n        <span class=\"token operator\">--</span>hi<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/rotate-image/\" target=\"_blank\" rel=\"noopener\">48. 旋转图像</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个 n × n 的二维矩阵表示一个图像。</p>\n<p>将图像顺时针旋转 90 度。</p>\n<p>说明：</p>\n<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>\n<p>示例 1:</p>\n<pre><code>给定 matrix = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\n原地旋转输入矩阵，使其变为:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]</code></pre>\n<p>示例 2:</p>\n<pre><code>给定 matrix =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\n原地旋转输入矩阵，使其变为:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>外围旋转中,只需要把[0,0],到[0,n-2]的依次与对应的四个角旋转即可<br>因为是方阵,所以定义lo,hi表示遍历的上层,遍历的下层,而且对左右也是有用的</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public void rotate(int[][] matrix)\n{\n    int lo = 0, hi = matrix.length - 1;\n    while(lo&lt;hi)\n    {\n        for (int i = 0; i &lt; hi - lo; i++)\n        {\n            int temp=matrix[lo][lo+i];\n            matrix[lo][lo + i] = matrix[hi - i][lo];\n            matrix[hi - i][lo] = matrix[hi][hi - i];\n            matrix[hi][hi - i] = matrix[lo + i][hi];\n            matrix[lo + i][hi] = temp;\n        }\n        ++lo;\n        --hi;\n    }\n}</code></pre>\n"},{"title":"LeetCode刷题笔记56","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"e6a4d233","date":"2020-04-24T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给出一个区间的集合，请合并所有重叠的区间。\n\n \n\n示例 1:\n```\n输入: intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出: [[1,6],[8,10],[15,18]]\n解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n```\n示例 2:\n```\n输入: intervals = [[1,4],[4,5]]\n输出: [[1,5]]\n解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。\n```\n提示：\n\n`intervals[i][0] <= intervals[i][1]`\n\n# 思路\n\n```python\n按区间的第一个元素排序\nfor i in N:\n    lo=intervals[i][0];\n    hi=intervals[i][1];\n    while(i+1<N && hi>=intervals[i+1][0]) hi=intervals[++i][1];//扩展该区间\n    result.add((lo,hi));\n\n```\n\n\n\n# 细节\n\n1. 区间长度要选两个合并区间最大的一个\n2. 注意集合和数组的转换操作\n\n\n# 代码\n\n```java\npublic int[][] merge(int[][] intervals)\n{\n    int N = intervals.length;\n    List<int[]> result = new LinkedList<>();\n    //按第一个元素排序\n    Arrays.sort(intervals, (a,b) -> a[0]-b[0]);\n    for (int i = 0; i < N; i++)\n    {\n        int lo=intervals[i][0];\n        int hi=intervals[i][1];\n        while(i+1<N && hi>=intervals[i+1][0])\n        {\n            ++i;//表明把下一个区间也纳入到了本区间里了\n            hi=Math.max(hi,intervals[i][1]);//look 扩展该区间,选最大的一个\n        }\n        result.add(new int[]{lo, hi});\n    }\n    return (int[][]) result.toArray(new int [result.size()][2]);\n}\n```\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N log N)$,主要是排序开销,其他的就是N开销的扫描\n\n## 空间复杂度\n\n$O(logN)$,计算出了答案外的额外空间开销,这里是排序所需的空间复杂度","source":"_posts/LeetCode笔记/LeetCode刷题笔记_56. 合并区间.md","raw":"---\ntitle: LeetCode刷题笔记56\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 数组\nabbrlink: e6a4d233\ndate: 2020-04-25 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给出一个区间的集合，请合并所有重叠的区间。\n\n \n\n示例 1:\n```\n输入: intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出: [[1,6],[8,10],[15,18]]\n解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n```\n示例 2:\n```\n输入: intervals = [[1,4],[4,5]]\n输出: [[1,5]]\n解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。\n```\n提示：\n\n`intervals[i][0] <= intervals[i][1]`\n\n# 思路\n\n```python\n按区间的第一个元素排序\nfor i in N:\n    lo=intervals[i][0];\n    hi=intervals[i][1];\n    while(i+1<N && hi>=intervals[i+1][0]) hi=intervals[++i][1];//扩展该区间\n    result.add((lo,hi));\n\n```\n\n\n\n# 细节\n\n1. 区间长度要选两个合并区间最大的一个\n2. 注意集合和数组的转换操作\n\n\n# 代码\n\n```java\npublic int[][] merge(int[][] intervals)\n{\n    int N = intervals.length;\n    List<int[]> result = new LinkedList<>();\n    //按第一个元素排序\n    Arrays.sort(intervals, (a,b) -> a[0]-b[0]);\n    for (int i = 0; i < N; i++)\n    {\n        int lo=intervals[i][0];\n        int hi=intervals[i][1];\n        while(i+1<N && hi>=intervals[i+1][0])\n        {\n            ++i;//表明把下一个区间也纳入到了本区间里了\n            hi=Math.max(hi,intervals[i][1]);//look 扩展该区间,选最大的一个\n        }\n        result.add(new int[]{lo, hi});\n    }\n    return (int[][]) result.toArray(new int [result.size()][2]);\n}\n```\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N log N)$,主要是排序开销,其他的就是N开销的扫描\n\n## 空间复杂度\n\n$O(logN)$,计算出了答案外的额外空间开销,这里是排序所需的空间复杂度","slug":"LeetCode笔记/LeetCode刷题笔记_56. 合并区间","published":1,"updated":"2020-11-12T11:57:29.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yq0079jotp73339dhd","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/merge-intervals/\" target=\"_blank\" rel=\"noopener\">56. 合并区间</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给出一个区间的集合，请合并所有重叠的区间。</p>\n<p> </p>\n<p>示例 1:</p>\n<pre><code>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出: [[1,6],[8,10],[15,18]]\n解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: intervals = [[1,4],[4,5]]\n输出: [[1,5]]\n解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</code></pre>\n<p>提示：</p>\n<p><code>intervals[i][0] &lt;= intervals[i][1]</code></p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre class=\" language-python\"><code class=\"language-python\">按区间的第一个元素排序\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> N<span class=\"token punctuation\">:</span>\n    lo<span class=\"token operator\">=</span>intervals<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    hi<span class=\"token operator\">=</span>intervals<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span>N <span class=\"token operator\">&amp;</span><span class=\"token operator\">&amp;</span> hi<span class=\"token operator\">>=</span>intervals<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> hi<span class=\"token operator\">=</span>intervals<span class=\"token punctuation\">[</span><span class=\"token operator\">+</span><span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token operator\">//</span>扩展该区间\n    result<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>lo<span class=\"token punctuation\">,</span>hi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>区间长度要选两个合并区间最大的一个</li>\n<li>注意集合和数组的转换操作</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> intervals<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> intervals<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    List<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//按第一个元素排序</span>\n    Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>intervals<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>b<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> lo<span class=\"token operator\">=</span>intervals<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> hi<span class=\"token operator\">=</span>intervals<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;</span>N <span class=\"token operator\">&amp;&amp;</span> hi<span class=\"token operator\">>=</span>intervals<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">++</span>i<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//表明把下一个区间也纳入到了本区间里了</span>\n            hi<span class=\"token operator\">=</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>hi<span class=\"token punctuation\">,</span>intervals<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look 扩展该区间,选最大的一个</span>\n        <span class=\"token punctuation\">}</span>\n        result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span>lo<span class=\"token punctuation\">,</span> hi<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span> <span class=\"token punctuation\">[</span>result<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N log N)$,主要是排序开销,其他的就是N开销的扫描</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(logN)$,计算出了答案外的额外空间开销,这里是排序所需的空间复杂度</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/merge-intervals/\" target=\"_blank\" rel=\"noopener\">56. 合并区间</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给出一个区间的集合，请合并所有重叠的区间。</p>\n<p> </p>\n<p>示例 1:</p>\n<pre><code>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出: [[1,6],[8,10],[15,18]]\n解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: intervals = [[1,4],[4,5]]\n输出: [[1,5]]\n解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</code></pre>\n<p>提示：</p>\n<p><code>intervals[i][0] &lt;= intervals[i][1]</code></p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code class=\"python\">按区间的第一个元素排序\nfor i in N:\n    lo=intervals[i][0];\n    hi=intervals[i][1];\n    while(i+1&lt;N &amp;&amp; hi&gt;=intervals[i+1][0]) hi=intervals[++i][1];//扩展该区间\n    result.add((lo,hi));\n</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>区间长度要选两个合并区间最大的一个</li>\n<li>注意集合和数组的转换操作</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int[][] merge(int[][] intervals)\n{\n    int N = intervals.length;\n    List&lt;int[]&gt; result = new LinkedList&lt;&gt;();\n    //按第一个元素排序\n    Arrays.sort(intervals, (a,b) -&gt; a[0]-b[0]);\n    for (int i = 0; i &lt; N; i++)\n    {\n        int lo=intervals[i][0];\n        int hi=intervals[i][1];\n        while(i+1&lt;N &amp;&amp; hi&gt;=intervals[i+1][0])\n        {\n            ++i;//表明把下一个区间也纳入到了本区间里了\n            hi=Math.max(hi,intervals[i][1]);//look 扩展该区间,选最大的一个\n        }\n        result.add(new int[]{lo, hi});\n    }\n    return (int[][]) result.toArray(new int [result.size()][2]);\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N log N)$,主要是排序开销,其他的就是N开销的扫描</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(logN)$,计算出了答案外的额外空间开销,这里是排序所需的空间复杂度</p>\n"},{"title":"LeetCode刷题笔记64","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"2387e0dc","date":"2020-04-28T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n示例:\n```\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n```\n\n\n# 思路\n\n普通的动态规划,但是还是要注意初始化条件\n\n\n# 代码\n\n```java\npublic int minPathSum(int[][] grid)\n{\n    int m = grid.length;\n    if(m==0) return 0;\n    int n = grid[0].length;\n    if(n==0) return 0;\n\n    //look,还是要初始化,最好先画图\n    for (int i = 1; i < m; i++) grid[i][0] += grid[i - 1][0];\n    for (int j = 1; j < n; j++) grid[0][j] += grid[0][j - 1];\n\n    for (int i = 1; i < m; i++)\n    {\n        for (int j = 1; j < n; j++)\n        {\n            grid[i][j] = grid[i][j] + Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N^2)$\n\n## 空间复杂度\n\n$O(N^2)$","source":"_posts/LeetCode笔记/LeetCode刷题笔记_64. 最小路径和.md","raw":"---\ntitle: LeetCode刷题笔记64\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 动态规划\nabbrlink: 2387e0dc\ndate: 2020-04-29 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n示例:\n```\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n```\n\n\n# 思路\n\n普通的动态规划,但是还是要注意初始化条件\n\n\n# 代码\n\n```java\npublic int minPathSum(int[][] grid)\n{\n    int m = grid.length;\n    if(m==0) return 0;\n    int n = grid[0].length;\n    if(n==0) return 0;\n\n    //look,还是要初始化,最好先画图\n    for (int i = 1; i < m; i++) grid[i][0] += grid[i - 1][0];\n    for (int j = 1; j < n; j++) grid[0][j] += grid[0][j - 1];\n\n    for (int i = 1; i < m; i++)\n    {\n        for (int j = 1; j < n; j++)\n        {\n            grid[i][j] = grid[i][j] + Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N^2)$\n\n## 空间复杂度\n\n$O(N^2)$","slug":"LeetCode笔记/LeetCode刷题笔记_64. 最小路径和","published":1,"updated":"2020-11-12T11:57:29.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yr007djotp1b0oegf9","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\" target=\"_blank\" rel=\"noopener\">64. 最小路径和</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n<p>说明：每次只能向下或者向右移动一步。</p>\n<p>示例:</p>\n<pre><code>输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>普通的动态规划,但是还是要注意初始化条件</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">minPathSum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> grid<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> grid<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>m<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> grid<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//look,还是要初始化,最好先画图</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> grid<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> grid<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> grid<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>grid<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> grid<span class=\"token punctuation\">[</span>m <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N^2)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(N^2)$</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\" target=\"_blank\" rel=\"noopener\">64. 最小路径和</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n<p>说明：每次只能向下或者向右移动一步。</p>\n<p>示例:</p>\n<pre><code>输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>普通的动态规划,但是还是要注意初始化条件</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int minPathSum(int[][] grid)\n{\n    int m = grid.length;\n    if(m==0) return 0;\n    int n = grid[0].length;\n    if(n==0) return 0;\n\n    //look,还是要初始化,最好先画图\n    for (int i = 1; i &lt; m; i++) grid[i][0] += grid[i - 1][0];\n    for (int j = 1; j &lt; n; j++) grid[0][j] += grid[0][j - 1];\n\n    for (int i = 1; i &lt; m; i++)\n    {\n        for (int j = 1; j &lt; n; j++)\n        {\n            grid[i][j] = grid[i][j] + Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N^2)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(N^2)$</p>\n"},{"title":"LeetCode刷题笔记62","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"cae445e9","date":"2020-04-26T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n示例 1:\n```\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n\n```\n示例 2:\n```\n输入: m = 7, n = 3\n输出: 28\n```\n\n提示：\n\n1 <= m, n <= 100\n题目数据保证答案小于等于 2 * 10 ^ 9\n\n\n# 思路\n标准动态规划\n```\ndp[i][j]代表有多少种路径到该点\n最后求dp[m-1][n-1]\np[i][0]=1; dp[j][0]=1\ndp[i][j]=dp[i-1][j]+dp[i][j-1]\n```\n# 细节\n\n1. m,n代表的长宽与常识上不太相同,但是不影响\n2. 先写成标准的动态规划,再简化空间开销就比较容易\n\n\n# 代码\n\n```java\n//标准动态规划\npublic int uniquePaths(int m, int n)\n{\n    int dp[][] = new int[m][n];\n    for (int i = 0; i < m; i++) dp[i][0] = 1;\n    for (int j = 0; j < n; j++) dp[0][j] = 1;\n    for (int i = 1; i < m; i++)\n    {\n        for (int j = 1; j < n; j++)\n        {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n```\n\n```java\n//节约空间 改成一维数组\npublic int uniquePaths(int m, int n)\n{\n    int dp[] = new int[n];\n    for (int i = 0; i < n; i++) dp[i] = 1;\n    for (int i = 1; i < m; i++)\n    {\n        for (int j = 1; j < n; j++)\n        {\n            dp[j] = dp[j] + dp[j - 1];\n        }\n    }\n    return dp[n - 1];\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N^2)$\n\n## 空间复杂度\n$ O(N^2) $\n节约空间,则为$ O(N) $","source":"_posts/LeetCode笔记/LeetCode刷题笔记_62. 不同路径.md","raw":"---\ntitle: LeetCode刷题笔记62\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 动态规划\nabbrlink: cae445e9\ndate: 2020-04-27 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n示例 1:\n```\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n\n```\n示例 2:\n```\n输入: m = 7, n = 3\n输出: 28\n```\n\n提示：\n\n1 <= m, n <= 100\n题目数据保证答案小于等于 2 * 10 ^ 9\n\n\n# 思路\n标准动态规划\n```\ndp[i][j]代表有多少种路径到该点\n最后求dp[m-1][n-1]\np[i][0]=1; dp[j][0]=1\ndp[i][j]=dp[i-1][j]+dp[i][j-1]\n```\n# 细节\n\n1. m,n代表的长宽与常识上不太相同,但是不影响\n2. 先写成标准的动态规划,再简化空间开销就比较容易\n\n\n# 代码\n\n```java\n//标准动态规划\npublic int uniquePaths(int m, int n)\n{\n    int dp[][] = new int[m][n];\n    for (int i = 0; i < m; i++) dp[i][0] = 1;\n    for (int j = 0; j < n; j++) dp[0][j] = 1;\n    for (int i = 1; i < m; i++)\n    {\n        for (int j = 1; j < n; j++)\n        {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n```\n\n```java\n//节约空间 改成一维数组\npublic int uniquePaths(int m, int n)\n{\n    int dp[] = new int[n];\n    for (int i = 0; i < n; i++) dp[i] = 1;\n    for (int i = 1; i < m; i++)\n    {\n        for (int j = 1; j < n; j++)\n        {\n            dp[j] = dp[j] + dp[j - 1];\n        }\n    }\n    return dp[n - 1];\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N^2)$\n\n## 空间复杂度\n$ O(N^2) $\n节约空间,则为$ O(N) $","slug":"LeetCode笔记/LeetCode刷题笔记_62. 不同路径","published":1,"updated":"2020-11-12T11:57:29.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yr007gjotpabk7gziq","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/unique-paths/\" target=\"_blank\" rel=\"noopener\">62. 不同路径</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>\n<p>问总共有多少条不同的路径？</p>\n<p>示例 1:</p>\n<pre><code>输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -&gt; 向右 -&gt; 向下\n2. 向右 -&gt; 向下 -&gt; 向右\n3. 向下 -&gt; 向右 -&gt; 向右\n</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: m = 7, n = 3\n输出: 28</code></pre>\n<p>提示：</p>\n<p>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 10 ^ 9</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>标准动态规划</p>\n<pre><code>dp[i][j]代表有多少种路径到该点\n最后求dp[m-1][n-1]\np[i][0]=1; dp[j][0]=1\ndp[i][j]=dp[i-1][j]+dp[i][j-1]</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>m,n代表的长宽与常识上不太相同,但是不影响</li>\n<li>先写成标准的动态规划,再简化空间开销就比较容易</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//标准动态规划</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">uniquePaths</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> m<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> dp<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>m <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//节约空间 改成一维数组</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">uniquePaths</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> m<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> dp<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> dp<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N^2)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$ O(N^2) $<br>节约空间,则为$ O(N) $</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/unique-paths/\" target=\"_blank\" rel=\"noopener\">62. 不同路径</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>\n<p>问总共有多少条不同的路径？</p>\n<p>示例 1:</p>\n<pre><code>输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -&gt; 向右 -&gt; 向下\n2. 向右 -&gt; 向下 -&gt; 向右\n3. 向下 -&gt; 向右 -&gt; 向右\n</code></pre>\n<p>示例 2:</p>\n<pre><code>输入: m = 7, n = 3\n输出: 28</code></pre>\n<p>提示：</p>\n<p>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 10 ^ 9</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>标准动态规划</p>\n<pre><code>dp[i][j]代表有多少种路径到该点\n最后求dp[m-1][n-1]\np[i][0]=1; dp[j][0]=1\ndp[i][j]=dp[i-1][j]+dp[i][j-1]</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>m,n代表的长宽与常识上不太相同,但是不影响</li>\n<li>先写成标准的动态规划,再简化空间开销就比较容易</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">//标准动态规划\npublic int uniquePaths(int m, int n)\n{\n    int dp[][] = new int[m][n];\n    for (int i = 0; i &lt; m; i++) dp[i][0] = 1;\n    for (int j = 0; j &lt; n; j++) dp[0][j] = 1;\n    for (int i = 1; i &lt; m; i++)\n    {\n        for (int j = 1; j &lt; n; j++)\n        {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}</code></pre>\n<pre><code class=\"java\">//节约空间 改成一维数组\npublic int uniquePaths(int m, int n)\n{\n    int dp[] = new int[n];\n    for (int i = 0; i &lt; n; i++) dp[i] = 1;\n    for (int i = 1; i &lt; m; i++)\n    {\n        for (int j = 1; j &lt; n; j++)\n        {\n            dp[j] = dp[j] + dp[j - 1];\n        }\n    }\n    return dp[n - 1];\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N^2)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$ O(N^2) $<br>节约空间,则为$ O(N) $</p>\n"},{"title":"LeetCode刷题笔记70","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"3df11584","date":"2020-04-30T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n示例 1：\n```\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n```\n示例 2：\n```\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n```\n\n# 思路\n\n其实就是斐波那契数列\n\n\n\n\n# 代码\n\n```java\npublic int climbStairs(int n)\n{\n    if(n==1 || n==2) return n;//正整数,不用考虑这么多\n\n    int first = 1, second = 2;//初始化为爬1楼,2楼的方法数量\n    for (int i = 3; i <= n; i++)//i代表楼梯数\n    {\n        int temp = first + second;\n        first = second;\n        second = temp;\n    }\n    return second;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$\n\n## 空间复杂度\n\n$O(1)$","source":"_posts/LeetCode笔记/LeetCode刷题笔记_70. 爬楼梯.md","raw":"---\ntitle: LeetCode刷题笔记70\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 动态规划\nabbrlink: 3df11584\ndate: 2020-05-01 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n示例 1：\n```\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n```\n示例 2：\n```\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n```\n\n# 思路\n\n其实就是斐波那契数列\n\n\n\n\n# 代码\n\n```java\npublic int climbStairs(int n)\n{\n    if(n==1 || n==2) return n;//正整数,不用考虑这么多\n\n    int first = 1, second = 2;//初始化为爬1楼,2楼的方法数量\n    for (int i = 3; i <= n; i++)//i代表楼梯数\n    {\n        int temp = first + second;\n        first = second;\n        second = temp;\n    }\n    return second;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$\n\n## 空间复杂度\n\n$O(1)$","slug":"LeetCode笔记/LeetCode刷题笔记_70. 爬楼梯","published":1,"updated":"2020-11-12T11:57:29.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6ys007ijotp1pzyafde","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">70. 爬楼梯</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p>注意：给定 n 是一个正整数。</p>\n<p>示例 1：</p>\n<pre><code>输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶</code></pre>\n<p>示例 2：</p>\n<pre><code>输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>其实就是斐波那契数列</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">climbStairs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">==</span><span class=\"token number\">1</span> <span class=\"token operator\">||</span> n<span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//正整数,不用考虑这么多</span>\n\n    <span class=\"token keyword\">int</span> first <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> second <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//初始化为爬1楼,2楼的方法数量</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//i代表楼梯数</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> first <span class=\"token operator\">+</span> second<span class=\"token punctuation\">;</span>\n        first <span class=\"token operator\">=</span> second<span class=\"token punctuation\">;</span>\n        second <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> second<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">70. 爬楼梯</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p>注意：给定 n 是一个正整数。</p>\n<p>示例 1：</p>\n<pre><code>输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶</code></pre>\n<p>示例 2：</p>\n<pre><code>输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>其实就是斐波那契数列</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int climbStairs(int n)\n{\n    if(n==1 || n==2) return n;//正整数,不用考虑这么多\n\n    int first = 1, second = 2;//初始化为爬1楼,2楼的方法数量\n    for (int i = 3; i &lt;= n; i++)//i代表楼梯数\n    {\n        int temp = first + second;\n        first = second;\n        second = temp;\n    }\n    return second;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$</p>\n"},{"title":"LeetCode刷题笔记72","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"d3ff74a8","date":"2020-05-02T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n插入一个字符\n删除一个字符\n替换一个字符\n\n\n示例 1：\n```\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n```\n示例 2：\n```\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n```\n\n\n# 思路\n```\ndp[i][j]代表将word1的前i-1个字符与word2的前j-1个字符转换的最小操作\n返回dp[m][n]\n初始化: dp[0][0]=0 dp[i][0]=i dp[0][j]=j\n递推方程:\n上边代表增加,左边代表删除,左上代表替换,因为可能不用替换\ndp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(word1[i-1]==word2[j-1] ? 0:1))\n```\n# 细节\n\n1. 注意不匹配时要加一的操作\n2. 如果节约空间,则可以用一维数组表示,可以从二维上推导,要注意的是推导过程中列的初始化操作的改变,以及用一个变量存储左上角元素时的细节\n\n\n# 代码\n\n```java\npublic int minDistance(String word1, String word2)\n{\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i < m + 1; i++) dp[i][0] = i;\n    for (int j = 0; j < n + 1; j++) dp[0][j] = j;\n\n    for (int i = 1; i < m + 1; i++)\n    {\n        for (int j = 1; j < n + 1; j++)\n        {\n            //look,需要+1,并且注意+1的时机\n            dp[i][j] = Math.min(dp[i - 1][j] + 1,\n                                Math.min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + (word1.charAt(i - 1) == word2.charAt(j - 1) ? 0 : 1)));\n        }\n    }\n    return dp[m][n];\n}\n```\n\n```java\n//节约空间\npublic int minDistance(String word1, String word2)\n{\n    int m = word1.length(), n = word2.length();\n\n    int[] dp = new int[n + 1];\n    for (int j = 0; j < n + 1; j++) dp[j] = j;\n\n    for (int i = 1; i < m + 1; i++)\n    {\n        int leftTop = dp[0];//look 记录左上角的值 注意和下面一条的顺序\n        dp[0] = i;//look 不要忽略这里的初始化\n        for (int j = 1; j < n + 1; j++)\n        {\n            int temp = dp[j];\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[j] = leftTop;\n            else dp[j] = Math.min(dp[j], Math.min(dp[j - 1], leftTop)) + 1;\n            leftTop = temp;\n        }\n    }\n    return dp[n];\n}\n```\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N^2)$\n\n## 空间复杂度\n\n$O(N^2)$ 空间优化:$O(N)$","source":"_posts/LeetCode笔记/LeetCode刷题笔记_72. 编辑距离.md","raw":"---\ntitle: LeetCode刷题笔记72\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 字符串\n  - 动态规划\nabbrlink: d3ff74a8\ndate: 2020-05-03 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n插入一个字符\n删除一个字符\n替换一个字符\n\n\n示例 1：\n```\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n```\n示例 2：\n```\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n```\n\n\n# 思路\n```\ndp[i][j]代表将word1的前i-1个字符与word2的前j-1个字符转换的最小操作\n返回dp[m][n]\n初始化: dp[0][0]=0 dp[i][0]=i dp[0][j]=j\n递推方程:\n上边代表增加,左边代表删除,左上代表替换,因为可能不用替换\ndp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(word1[i-1]==word2[j-1] ? 0:1))\n```\n# 细节\n\n1. 注意不匹配时要加一的操作\n2. 如果节约空间,则可以用一维数组表示,可以从二维上推导,要注意的是推导过程中列的初始化操作的改变,以及用一个变量存储左上角元素时的细节\n\n\n# 代码\n\n```java\npublic int minDistance(String word1, String word2)\n{\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i < m + 1; i++) dp[i][0] = i;\n    for (int j = 0; j < n + 1; j++) dp[0][j] = j;\n\n    for (int i = 1; i < m + 1; i++)\n    {\n        for (int j = 1; j < n + 1; j++)\n        {\n            //look,需要+1,并且注意+1的时机\n            dp[i][j] = Math.min(dp[i - 1][j] + 1,\n                                Math.min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + (word1.charAt(i - 1) == word2.charAt(j - 1) ? 0 : 1)));\n        }\n    }\n    return dp[m][n];\n}\n```\n\n```java\n//节约空间\npublic int minDistance(String word1, String word2)\n{\n    int m = word1.length(), n = word2.length();\n\n    int[] dp = new int[n + 1];\n    for (int j = 0; j < n + 1; j++) dp[j] = j;\n\n    for (int i = 1; i < m + 1; i++)\n    {\n        int leftTop = dp[0];//look 记录左上角的值 注意和下面一条的顺序\n        dp[0] = i;//look 不要忽略这里的初始化\n        for (int j = 1; j < n + 1; j++)\n        {\n            int temp = dp[j];\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[j] = leftTop;\n            else dp[j] = Math.min(dp[j], Math.min(dp[j - 1], leftTop)) + 1;\n            leftTop = temp;\n        }\n    }\n    return dp[n];\n}\n```\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N^2)$\n\n## 空间复杂度\n\n$O(N^2)$ 空间优化:$O(N)$","slug":"LeetCode笔记/LeetCode刷题笔记_72. 编辑距离","published":1,"updated":"2020-11-12T11:57:29.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yt007ljotpghfc2drm","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/edit-distance/\" target=\"_blank\" rel=\"noopener\">72. 编辑距离</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>\n<p>你可以对一个单词进行如下三种操作：</p>\n<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>\n<p>示例 1：</p>\n<pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;\n输出：3\n解释：\nhorse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)\nrorse -&gt; rose (删除 &#39;r&#39;)\nrose -&gt; ros (删除 &#39;e&#39;)</code></pre>\n<p>示例 2：</p>\n<pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;\n输出：5\n解释：\nintention -&gt; inention (删除 &#39;t&#39;)\ninention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)\nenention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)\nexention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)\nexection -&gt; execution (插入 &#39;u&#39;)</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code>dp[i][j]代表将word1的前i-1个字符与word2的前j-1个字符转换的最小操作\n返回dp[m][n]\n初始化: dp[0][0]=0 dp[i][0]=i dp[0][j]=j\n递推方程:\n上边代表增加,左边代表删除,左上代表替换,因为可能不用替换\ndp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(word1[i-1]==word2[j-1] ? 0:1))</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意不匹配时要加一的操作</li>\n<li>如果节约空间,则可以用一维数组表示,可以从二维上推导,要注意的是推导过程中列的初始化操作的改变,以及用一个变量存储左上角元素时的细节</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">minDistance</span><span class=\"token punctuation\">(</span>String word1<span class=\"token punctuation\">,</span> String word2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> word1<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> word2<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> dp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//look,需要+1,并且注意+1的时机</span>\n            dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n                                Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> dp<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>word1<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> word2<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//节约空间</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">minDistance</span><span class=\"token punctuation\">(</span>String word1<span class=\"token punctuation\">,</span> String word2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> word1<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> word2<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> dp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> leftTop <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look 记录左上角的值 注意和下面一条的顺序</span>\n        dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look 不要忽略这里的初始化</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>word1<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> word2<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> leftTop<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> leftTop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            leftTop <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N^2)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(N^2)$ 空间优化:$O(N)$</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/edit-distance/\" target=\"_blank\" rel=\"noopener\">72. 编辑距离</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>\n<p>你可以对一个单词进行如下三种操作：</p>\n<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>\n<p>示例 1：</p>\n<pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;\n输出：3\n解释：\nhorse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)\nrorse -&gt; rose (删除 &#39;r&#39;)\nrose -&gt; ros (删除 &#39;e&#39;)</code></pre>\n<p>示例 2：</p>\n<pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;\n输出：5\n解释：\nintention -&gt; inention (删除 &#39;t&#39;)\ninention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)\nenention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)\nexention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)\nexection -&gt; execution (插入 &#39;u&#39;)</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code>dp[i][j]代表将word1的前i-1个字符与word2的前j-1个字符转换的最小操作\n返回dp[m][n]\n初始化: dp[0][0]=0 dp[i][0]=i dp[0][j]=j\n递推方程:\n上边代表增加,左边代表删除,左上代表替换,因为可能不用替换\ndp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(word1[i-1]==word2[j-1] ? 0:1))</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意不匹配时要加一的操作</li>\n<li>如果节约空间,则可以用一维数组表示,可以从二维上推导,要注意的是推导过程中列的初始化操作的改变,以及用一个变量存储左上角元素时的细节</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int minDistance(String word1, String word2)\n{\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i &lt; m + 1; i++) dp[i][0] = i;\n    for (int j = 0; j &lt; n + 1; j++) dp[0][j] = j;\n\n    for (int i = 1; i &lt; m + 1; i++)\n    {\n        for (int j = 1; j &lt; n + 1; j++)\n        {\n            //look,需要+1,并且注意+1的时机\n            dp[i][j] = Math.min(dp[i - 1][j] + 1,\n                                Math.min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + (word1.charAt(i - 1) == word2.charAt(j - 1) ? 0 : 1)));\n        }\n    }\n    return dp[m][n];\n}</code></pre>\n<pre><code class=\"java\">//节约空间\npublic int minDistance(String word1, String word2)\n{\n    int m = word1.length(), n = word2.length();\n\n    int[] dp = new int[n + 1];\n    for (int j = 0; j &lt; n + 1; j++) dp[j] = j;\n\n    for (int i = 1; i &lt; m + 1; i++)\n    {\n        int leftTop = dp[0];//look 记录左上角的值 注意和下面一条的顺序\n        dp[0] = i;//look 不要忽略这里的初始化\n        for (int j = 1; j &lt; n + 1; j++)\n        {\n            int temp = dp[j];\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[j] = leftTop;\n            else dp[j] = Math.min(dp[j], Math.min(dp[j - 1], leftTop)) + 1;\n            leftTop = temp;\n        }\n    }\n    return dp[n];\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N^2)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(N^2)$ 空间优化:$O(N)$</p>\n"},{"title":"LeetCode刷题笔记75","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"4d9be10b","date":"2020-05-04T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)\n\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n# 描述\n\n给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n注意:\n不能使用代码库中的排序函数来解决这道题。\n\n示例:\n\n```\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n```\n\n\n进阶：\n\n一个直观的解决方案是使用计数排序的两趟扫描算法。\n首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n# 思路\n\n采用快排的partition思想,在数组首尾定义指针,lo标识0的结束(保证lo-1处一定为0),hi标识2的开始(保证hi+1处一定为2).再用指针i来遍历数组\n\n一个比较好的测试用例`2 0 1 0 1 2`\n\n# 代码\n```java\npublic void sortColors(int[] nums)\n{\n    int lo=0,hi=nums.length-1;\n    int i=0;\n    while(i<=hi)\n    {\n        if(nums[i]==0)\n        {\n            //exch(nums,i++,lo++); 由于特殊性,化简\n            nums[i++] = nums[lo];\n            nums[lo++] = 0;\n        }\n        else if(nums[i]==1)\n        {\n            ++i;\n        }\n        else\n        {\n            //                exch(nums,i,hi--);\n            nums[i] = nums[hi];\n            nums[hi--] = 2;\n        }\n\n    }\n}\n```\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_75. 颜色分类.md","raw":"---\ntitle: LeetCode刷题笔记75\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 快排\nabbrlink: 4d9be10b\ndate: 2020-05-05 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)\n\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n# 描述\n\n给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n注意:\n不能使用代码库中的排序函数来解决这道题。\n\n示例:\n\n```\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n```\n\n\n进阶：\n\n一个直观的解决方案是使用计数排序的两趟扫描算法。\n首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n# 思路\n\n采用快排的partition思想,在数组首尾定义指针,lo标识0的结束(保证lo-1处一定为0),hi标识2的开始(保证hi+1处一定为2).再用指针i来遍历数组\n\n一个比较好的测试用例`2 0 1 0 1 2`\n\n# 代码\n```java\npublic void sortColors(int[] nums)\n{\n    int lo=0,hi=nums.length-1;\n    int i=0;\n    while(i<=hi)\n    {\n        if(nums[i]==0)\n        {\n            //exch(nums,i++,lo++); 由于特殊性,化简\n            nums[i++] = nums[lo];\n            nums[lo++] = 0;\n        }\n        else if(nums[i]==1)\n        {\n            ++i;\n        }\n        else\n        {\n            //                exch(nums,i,hi--);\n            nums[i] = nums[hi];\n            nums[hi--] = 2;\n        }\n\n    }\n}\n```\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_75. 颜色分类","published":1,"updated":"2020-11-12T11:57:29.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yu007njotpbxls86fn","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/sort-colors/\" target=\"_blank\" rel=\"noopener\">75. 颜色分类</a></p>\n</blockquote>\n<blockquote>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>\n<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>\n<p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p>\n<p>示例:</p>\n<pre><code>输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]</code></pre>\n<p>进阶：</p>\n<p>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>采用快排的partition思想,在数组首尾定义指针,lo标识0的结束(保证lo-1处一定为0),hi标识2的开始(保证hi+1处一定为2).再用指针i来遍历数组</p>\n<p>一个比较好的测试用例<code>2 0 1 0 1 2</code></p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sortColors</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> lo<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>hi<span class=\"token operator\">=</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">&lt;=</span>hi<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//exch(nums,i++,lo++); 由于特殊性,化简</span>\n            nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            nums<span class=\"token punctuation\">[</span>lo<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">++</span>i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//                exch(nums,i,hi--);</span>\n            nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            nums<span class=\"token punctuation\">[</span>hi<span class=\"token operator\">--</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/sort-colors/\" target=\"_blank\" rel=\"noopener\">75. 颜色分类</a></p>\n</blockquote>\n<blockquote>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>\n<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>\n<p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p>\n<p>示例:</p>\n<pre><code>输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]</code></pre>\n<p>进阶：</p>\n<p>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>采用快排的partition思想,在数组首尾定义指针,lo标识0的结束(保证lo-1处一定为0),hi标识2的开始(保证hi+1处一定为2).再用指针i来遍历数组</p>\n<p>一个比较好的测试用例<code>2 0 1 0 1 2</code></p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public void sortColors(int[] nums)\n{\n    int lo=0,hi=nums.length-1;\n    int i=0;\n    while(i&lt;=hi)\n    {\n        if(nums[i]==0)\n        {\n            //exch(nums,i++,lo++); 由于特殊性,化简\n            nums[i++] = nums[lo];\n            nums[lo++] = 0;\n        }\n        else if(nums[i]==1)\n        {\n            ++i;\n        }\n        else\n        {\n            //                exch(nums,i,hi--);\n            nums[i] = nums[hi];\n            nums[hi--] = 2;\n        }\n\n    }\n}</code></pre>\n"},{"title":"LeetCode刷题笔记76","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"d492b0b1","date":"2020-05-06T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。\n\n \n\n示例：\n\n```\n输入：S = \"ADOBECODEBANC\", T = \"ABC\"\n输出：\"BANC\"\n```\n\n\n\n提示：\n\n```\n如果 S 中不存这样的子串，则返回空字符串 \"\"。\n如果 S 中存在这样的子串，我们保证它是唯一的答案。\n```\n\n\n\n# 思路\n\n滑动窗口的方法:先扩大hi,使之包含T,然后增加lo,使之最小直到不满足要求。继续循环扩大hi\n\n```\n//初步思路\nint lo=0,hi=0;//左右指针,指向最小覆盖子串的首尾\nint result=0;\nwhile(hi<N) \n{\t\n\twhile([lo,hi]区间包含T)\n\t{\n\t\tresult=max(result,hi-lo+1);\n\t\t++lo;//增加lo\n\t}\n\t++hi;//扩大hi\n}\n\n```\n\n关键在于如何判断：[lo,hi]区间包含T\n\n可以让map存储T中字符与出现次数,循环中如果出现了T中字符，则加入window中\n\n用一个值判断map与windows中字符的匹配情况（如果一个字符出现的次数相同则匹配）\n\n```\nint lo=0,hi=0;//左右指针,指向最小覆盖子串的首尾\nint match=0;//匹配情况\n\nfor ch in T:\n\tmap.put(ch,map.get(ch)+1)\n\nwhile(hi<N) \n{\n\tchar ch=T[hi]\n\tif(map.contains(ch))\n\t{\n\t\twindow.put(ch,window.get(ch)+1);\n\t\tif(map.get(ch)==window.get(ch)) ++match; //windows中该字符太多不会匹配多次\n\t}\n\t//说明至少包含了T所有字符\n\twhile(match==map.size())\n\t{\n\t\tresult=max(result,hi-lo+1);\n\t\tif(map.contains(T[lo])) //说明滑动了一个T中字符\n\t\t{\n\t\t\twindow.put(T[lo],window.get(T[lo])-1);//look ch代表的是T[hi]\n\t\t\tif(map.get(T[lo])>window.get(T[lo])) --match;\n\t\t}\n\t\t++lo;//增加lo\n\t}\n\t++hi;//扩大hi\n}\n```\n\n\n\n\n\n# 代码\n\n```java\npublic String minWindow(String s, String t)\n{\n    int lo=0,hi=0;//左右指针,指向最小覆盖子串的首尾\n    int start=0,length=Integer.MAX_VALUE;//look 记录结果 求最小,length应该为最大\n    int match = 0;//匹配情况\n\n    Map<Character, Integer> map = new HashMap<>();\n    Map<Character, Integer> window = new HashMap<>();//代表滑动窗口\n    for (char ch : t.toCharArray())\n    {\n        map.put(ch, map.getOrDefault(ch, 0) + 1);\n    }\n\n    while(hi<s.length())\n    {\n        char chHi = s.charAt(hi);//look 命名为ch可能导致下面误导用ch表示S[lo]\n        if(map.containsKey(chHi)) //如果出现了T中字符,则放入\n        {\n            window.put(chHi, window.getOrDefault(chHi, 0) + 1);\n            if(map.get(chHi).equals(window.get(chHi))) ++match; //windows中该字符太多不会匹配多次\n        }\n        while(match==map.size())\n        {\n            if(length>hi-lo+1)\n            {\n                length = hi - lo + 1;\n                start = lo;\n            }\n            char chLo = s.charAt(lo);\n            if(map.containsKey(chLo)) //说明滑动了一个T中字符\n            {\n                window.put(chLo,window.get(chLo)-1);\n                if(map.get(chLo)>window.get(chLo)) --match;\n            }\n            ++lo;//增加lo\n        }\n\n        ++hi;//扩大hi\n    }\n    //如果不包含这样的子串,那length没变\n    if(length==Integer.MAX_VALUE) return \"\";\n    return s.substring(start,start+length);\n}\n```\n\n\n\n\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_76. 最小覆盖子串.md","raw":"---\ntitle: LeetCode刷题笔记76\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 字符串\n  - 滑动窗口\nabbrlink: d492b0b1\ndate: 2020-05-07 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。\n\n \n\n示例：\n\n```\n输入：S = \"ADOBECODEBANC\", T = \"ABC\"\n输出：\"BANC\"\n```\n\n\n\n提示：\n\n```\n如果 S 中不存这样的子串，则返回空字符串 \"\"。\n如果 S 中存在这样的子串，我们保证它是唯一的答案。\n```\n\n\n\n# 思路\n\n滑动窗口的方法:先扩大hi,使之包含T,然后增加lo,使之最小直到不满足要求。继续循环扩大hi\n\n```\n//初步思路\nint lo=0,hi=0;//左右指针,指向最小覆盖子串的首尾\nint result=0;\nwhile(hi<N) \n{\t\n\twhile([lo,hi]区间包含T)\n\t{\n\t\tresult=max(result,hi-lo+1);\n\t\t++lo;//增加lo\n\t}\n\t++hi;//扩大hi\n}\n\n```\n\n关键在于如何判断：[lo,hi]区间包含T\n\n可以让map存储T中字符与出现次数,循环中如果出现了T中字符，则加入window中\n\n用一个值判断map与windows中字符的匹配情况（如果一个字符出现的次数相同则匹配）\n\n```\nint lo=0,hi=0;//左右指针,指向最小覆盖子串的首尾\nint match=0;//匹配情况\n\nfor ch in T:\n\tmap.put(ch,map.get(ch)+1)\n\nwhile(hi<N) \n{\n\tchar ch=T[hi]\n\tif(map.contains(ch))\n\t{\n\t\twindow.put(ch,window.get(ch)+1);\n\t\tif(map.get(ch)==window.get(ch)) ++match; //windows中该字符太多不会匹配多次\n\t}\n\t//说明至少包含了T所有字符\n\twhile(match==map.size())\n\t{\n\t\tresult=max(result,hi-lo+1);\n\t\tif(map.contains(T[lo])) //说明滑动了一个T中字符\n\t\t{\n\t\t\twindow.put(T[lo],window.get(T[lo])-1);//look ch代表的是T[hi]\n\t\t\tif(map.get(T[lo])>window.get(T[lo])) --match;\n\t\t}\n\t\t++lo;//增加lo\n\t}\n\t++hi;//扩大hi\n}\n```\n\n\n\n\n\n# 代码\n\n```java\npublic String minWindow(String s, String t)\n{\n    int lo=0,hi=0;//左右指针,指向最小覆盖子串的首尾\n    int start=0,length=Integer.MAX_VALUE;//look 记录结果 求最小,length应该为最大\n    int match = 0;//匹配情况\n\n    Map<Character, Integer> map = new HashMap<>();\n    Map<Character, Integer> window = new HashMap<>();//代表滑动窗口\n    for (char ch : t.toCharArray())\n    {\n        map.put(ch, map.getOrDefault(ch, 0) + 1);\n    }\n\n    while(hi<s.length())\n    {\n        char chHi = s.charAt(hi);//look 命名为ch可能导致下面误导用ch表示S[lo]\n        if(map.containsKey(chHi)) //如果出现了T中字符,则放入\n        {\n            window.put(chHi, window.getOrDefault(chHi, 0) + 1);\n            if(map.get(chHi).equals(window.get(chHi))) ++match; //windows中该字符太多不会匹配多次\n        }\n        while(match==map.size())\n        {\n            if(length>hi-lo+1)\n            {\n                length = hi - lo + 1;\n                start = lo;\n            }\n            char chLo = s.charAt(lo);\n            if(map.containsKey(chLo)) //说明滑动了一个T中字符\n            {\n                window.put(chLo,window.get(chLo)-1);\n                if(map.get(chLo)>window.get(chLo)) --match;\n            }\n            ++lo;//增加lo\n        }\n\n        ++hi;//扩大hi\n    }\n    //如果不包含这样的子串,那length没变\n    if(length==Integer.MAX_VALUE) return \"\";\n    return s.substring(start,start+length);\n}\n```\n\n\n\n\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_76. 最小覆盖子串","published":1,"updated":"2020-11-12T11:57:29.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yv007rjotpfz7mdt0m","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\" target=\"_blank\" rel=\"noopener\">76. 最小覆盖子串</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。</p>\n<p>示例：</p>\n<pre><code>输入：S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;\n输出：&quot;BANC&quot;</code></pre>\n<p>提示：</p>\n<pre><code>如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。\n如果 S 中存在这样的子串，我们保证它是唯一的答案。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>滑动窗口的方法:先扩大hi,使之包含T,然后增加lo,使之最小直到不满足要求。继续循环扩大hi</p>\n<pre><code>//初步思路\nint lo=0,hi=0;//左右指针,指向最小覆盖子串的首尾\nint result=0;\nwhile(hi&lt;N) \n{    \n    while([lo,hi]区间包含T)\n    {\n        result=max(result,hi-lo+1);\n        ++lo;//增加lo\n    }\n    ++hi;//扩大hi\n}\n</code></pre>\n<p>关键在于如何判断：[lo,hi]区间包含T</p>\n<p>可以让map存储T中字符与出现次数,循环中如果出现了T中字符，则加入window中</p>\n<p>用一个值判断map与windows中字符的匹配情况（如果一个字符出现的次数相同则匹配）</p>\n<pre><code>int lo=0,hi=0;//左右指针,指向最小覆盖子串的首尾\nint match=0;//匹配情况\n\nfor ch in T:\n    map.put(ch,map.get(ch)+1)\n\nwhile(hi&lt;N) \n{\n    char ch=T[hi]\n    if(map.contains(ch))\n    {\n        window.put(ch,window.get(ch)+1);\n        if(map.get(ch)==window.get(ch)) ++match; //windows中该字符太多不会匹配多次\n    }\n    //说明至少包含了T所有字符\n    while(match==map.size())\n    {\n        result=max(result,hi-lo+1);\n        if(map.contains(T[lo])) //说明滑动了一个T中字符\n        {\n            window.put(T[lo],window.get(T[lo])-1);//look ch代表的是T[hi]\n            if(map.get(T[lo])&gt;window.get(T[lo])) --match;\n        }\n        ++lo;//增加lo\n    }\n    ++hi;//扩大hi\n}</code></pre>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> String <span class=\"token function\">minWindow</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">,</span> String t<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> lo<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>hi<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//左右指针,指向最小覆盖子串的首尾</span>\n    <span class=\"token keyword\">int</span> start<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>length<span class=\"token operator\">=</span>Integer<span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look 记录结果 求最小,length应该为最大</span>\n    <span class=\"token keyword\">int</span> match <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//匹配情况</span>\n\n    Map<span class=\"token operator\">&lt;</span>Character<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Map<span class=\"token operator\">&lt;</span>Character<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> window <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//代表滑动窗口</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> ch <span class=\"token operator\">:</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">,</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">getOrDefault</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>hi<span class=\"token operator\">&lt;</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span> chHi <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>hi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//look 命名为ch可能导致下面误导用ch表示S[lo]</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>chHi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//如果出现了T中字符,则放入</span>\n        <span class=\"token punctuation\">{</span>\n            window<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>chHi<span class=\"token punctuation\">,</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">getOrDefault</span><span class=\"token punctuation\">(</span>chHi<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>chHi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>chHi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">++</span>match<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//windows中该字符太多不会匹配多次</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>match<span class=\"token operator\">==</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>length<span class=\"token operator\">></span>hi<span class=\"token operator\">-</span>lo<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                length <span class=\"token operator\">=</span> hi <span class=\"token operator\">-</span> lo <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                start <span class=\"token operator\">=</span> lo<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">char</span> chLo <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>lo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>chLo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//说明滑动了一个T中字符</span>\n            <span class=\"token punctuation\">{</span>\n                window<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>chLo<span class=\"token punctuation\">,</span>window<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>chLo<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>chLo<span class=\"token punctuation\">)</span><span class=\"token operator\">></span>window<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>chLo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">--</span>match<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token operator\">++</span>lo<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//增加lo</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token operator\">++</span>hi<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//扩大hi</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果不包含这样的子串,那length没变</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>length<span class=\"token operator\">==</span>Integer<span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span>start<span class=\"token operator\">+</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\" target=\"_blank\" rel=\"noopener\">76. 最小覆盖子串</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。</p>\n<p>示例：</p>\n<pre><code>输入：S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;\n输出：&quot;BANC&quot;</code></pre>\n<p>提示：</p>\n<pre><code>如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。\n如果 S 中存在这样的子串，我们保证它是唯一的答案。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>滑动窗口的方法:先扩大hi,使之包含T,然后增加lo,使之最小直到不满足要求。继续循环扩大hi</p>\n<pre><code>//初步思路\nint lo=0,hi=0;//左右指针,指向最小覆盖子串的首尾\nint result=0;\nwhile(hi&lt;N) \n{    \n    while([lo,hi]区间包含T)\n    {\n        result=max(result,hi-lo+1);\n        ++lo;//增加lo\n    }\n    ++hi;//扩大hi\n}\n</code></pre>\n<p>关键在于如何判断：[lo,hi]区间包含T</p>\n<p>可以让map存储T中字符与出现次数,循环中如果出现了T中字符，则加入window中</p>\n<p>用一个值判断map与windows中字符的匹配情况（如果一个字符出现的次数相同则匹配）</p>\n<pre><code>int lo=0,hi=0;//左右指针,指向最小覆盖子串的首尾\nint match=0;//匹配情况\n\nfor ch in T:\n    map.put(ch,map.get(ch)+1)\n\nwhile(hi&lt;N) \n{\n    char ch=T[hi]\n    if(map.contains(ch))\n    {\n        window.put(ch,window.get(ch)+1);\n        if(map.get(ch)==window.get(ch)) ++match; //windows中该字符太多不会匹配多次\n    }\n    //说明至少包含了T所有字符\n    while(match==map.size())\n    {\n        result=max(result,hi-lo+1);\n        if(map.contains(T[lo])) //说明滑动了一个T中字符\n        {\n            window.put(T[lo],window.get(T[lo])-1);//look ch代表的是T[hi]\n            if(map.get(T[lo])&gt;window.get(T[lo])) --match;\n        }\n        ++lo;//增加lo\n    }\n    ++hi;//扩大hi\n}</code></pre>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public String minWindow(String s, String t)\n{\n    int lo=0,hi=0;//左右指针,指向最小覆盖子串的首尾\n    int start=0,length=Integer.MAX_VALUE;//look 记录结果 求最小,length应该为最大\n    int match = 0;//匹配情况\n\n    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();\n    Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();//代表滑动窗口\n    for (char ch : t.toCharArray())\n    {\n        map.put(ch, map.getOrDefault(ch, 0) + 1);\n    }\n\n    while(hi&lt;s.length())\n    {\n        char chHi = s.charAt(hi);//look 命名为ch可能导致下面误导用ch表示S[lo]\n        if(map.containsKey(chHi)) //如果出现了T中字符,则放入\n        {\n            window.put(chHi, window.getOrDefault(chHi, 0) + 1);\n            if(map.get(chHi).equals(window.get(chHi))) ++match; //windows中该字符太多不会匹配多次\n        }\n        while(match==map.size())\n        {\n            if(length&gt;hi-lo+1)\n            {\n                length = hi - lo + 1;\n                start = lo;\n            }\n            char chLo = s.charAt(lo);\n            if(map.containsKey(chLo)) //说明滑动了一个T中字符\n            {\n                window.put(chLo,window.get(chLo)-1);\n                if(map.get(chLo)&gt;window.get(chLo)) --match;\n            }\n            ++lo;//增加lo\n        }\n\n        ++hi;//扩大hi\n    }\n    //如果不包含这样的子串,那length没变\n    if(length==Integer.MAX_VALUE) return &quot;&quot;;\n    return s.substring(start,start+length);\n}</code></pre>\n"},{"title":"LeetCode刷题笔记79","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"442dad20","date":"2020-05-10T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个二维网格和一个单词，找出该单词是否存在于网格中。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n \n\n示例:\n```\nboard =\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n给定 word = \"ABCCED\", 返回 true\n给定 word = \"SEE\", 返回 true\n给定 word = \"ABCB\", 返回 false\n```\n\n\n\n提示：\n```\nboard 和 word 中只包含大写和小写英文字母。\n1 <= board.length <= 200\n1 <= board[i].length <= 200\n1 <= word.length <= 10^3\n```\n\n# 思路\n\n深度优先搜索,在同一个搜索中,将搜索过的改变为*或其他标识,搜索后再恢复\n\n```java\nfor i in M:\n\tfor j in N:\n\t\tif dfs(i,j,0) return true; //如果找到了就直接结束,找不到就继续找\n\n\ndfs(int i,int j,int index)\n{\n    if(board[i][j]!=word[index]) return false;\n    if(index==word.length-1) return true;\n    \n    temp=board[i][j];\n    board[i][j]='*';//标记为已访问\n    \n    如果符合边界条件,dfs(他的上下左右,index+1);\n    \n    board[i][j]=temp;//这次深搜结束,恢复\n}\n```\n\n\n\n# 细节\n\n1. 找到了可以直接返回,不进入二维数组,找不到则要继续,所以注意条件\n2. dfs里,return的条件是四个方向都找不到才返回false\n\n# 代码\n\n```java\npublic boolean exist(char[][] board, String word)\n{\n    if (board.length == 0)\n    {\n        return false;\n    }\n    int m = board.length, n = board[0].length;\n\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (dfs(board, word, i, j, 0))\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, String word, int i, int j, int index)\n{\n    if (board[i][j] != word.charAt(index))\n    {\n        return false;\n    }\n    if (index == word.length() - 1)\n    {\n        return true;\n    }\n\n    char temp = board[i][j];\n    //标记为已访问\n    board[i][j] = '*';\n\n    boolean result = false;\n\n    if (i - 1 >= 0)\n    {\n        result = dfs(board, word, i - 1, j, index + 1);\n    }\n    if (i + 1 < board.length)\n    {\n        result = result || dfs(board, word, i + 1, j, index + 1);\n    }\n    if (j - 1 >= 0)\n    {\n        result = result || dfs(board, word, i, j - 1, index + 1);\n    }\n    if (j + 1 < board[0].length)\n    {\n        result = result || dfs(board, word, i, j + 1, index + 1);\n    }\n    //这次深搜结束,恢复\n    board[i][j] = temp;\n    return result;\n}\n```\n\n\n\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_79. 单词搜索.md","raw":"---\ntitle: LeetCode刷题笔记79\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 深搜\nabbrlink: 442dad20\ndate: 2020-05-11 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个二维网格和一个单词，找出该单词是否存在于网格中。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n \n\n示例:\n```\nboard =\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n给定 word = \"ABCCED\", 返回 true\n给定 word = \"SEE\", 返回 true\n给定 word = \"ABCB\", 返回 false\n```\n\n\n\n提示：\n```\nboard 和 word 中只包含大写和小写英文字母。\n1 <= board.length <= 200\n1 <= board[i].length <= 200\n1 <= word.length <= 10^3\n```\n\n# 思路\n\n深度优先搜索,在同一个搜索中,将搜索过的改变为*或其他标识,搜索后再恢复\n\n```java\nfor i in M:\n\tfor j in N:\n\t\tif dfs(i,j,0) return true; //如果找到了就直接结束,找不到就继续找\n\n\ndfs(int i,int j,int index)\n{\n    if(board[i][j]!=word[index]) return false;\n    if(index==word.length-1) return true;\n    \n    temp=board[i][j];\n    board[i][j]='*';//标记为已访问\n    \n    如果符合边界条件,dfs(他的上下左右,index+1);\n    \n    board[i][j]=temp;//这次深搜结束,恢复\n}\n```\n\n\n\n# 细节\n\n1. 找到了可以直接返回,不进入二维数组,找不到则要继续,所以注意条件\n2. dfs里,return的条件是四个方向都找不到才返回false\n\n# 代码\n\n```java\npublic boolean exist(char[][] board, String word)\n{\n    if (board.length == 0)\n    {\n        return false;\n    }\n    int m = board.length, n = board[0].length;\n\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (dfs(board, word, i, j, 0))\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, String word, int i, int j, int index)\n{\n    if (board[i][j] != word.charAt(index))\n    {\n        return false;\n    }\n    if (index == word.length() - 1)\n    {\n        return true;\n    }\n\n    char temp = board[i][j];\n    //标记为已访问\n    board[i][j] = '*';\n\n    boolean result = false;\n\n    if (i - 1 >= 0)\n    {\n        result = dfs(board, word, i - 1, j, index + 1);\n    }\n    if (i + 1 < board.length)\n    {\n        result = result || dfs(board, word, i + 1, j, index + 1);\n    }\n    if (j - 1 >= 0)\n    {\n        result = result || dfs(board, word, i, j - 1, index + 1);\n    }\n    if (j + 1 < board[0].length)\n    {\n        result = result || dfs(board, word, i, j + 1, index + 1);\n    }\n    //这次深搜结束,恢复\n    board[i][j] = temp;\n    return result;\n}\n```\n\n\n\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_79. 单词搜索","published":1,"updated":"2020-11-12T11:57:29.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yw007ujotp9c317jtv","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/word-search/\" target=\"_blank\" rel=\"noopener\">79. 单词搜索</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n<p> </p>\n<p>示例:</p>\n<pre><code>board =\n[\n  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],\n  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],\n  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]\n]\n给定 word = &quot;ABCCED&quot;, 返回 true\n给定 word = &quot;SEE&quot;, 返回 true\n给定 word = &quot;ABCB&quot;, 返回 false</code></pre>\n<p>提示：</p>\n<pre><code>board 和 word 中只包含大写和小写英文字母。\n1 &lt;= board.length &lt;= 200\n1 &lt;= board[i].length &lt;= 200\n1 &lt;= word.length &lt;= 10^3</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>深度优先搜索,在同一个搜索中,将搜索过的改变为*或其他标识,搜索后再恢复</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span> i in M<span class=\"token operator\">:</span>\n    <span class=\"token keyword\">for</span> j in N<span class=\"token operator\">:</span>\n        <span class=\"token keyword\">if</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span>j<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//如果找到了就直接结束,找不到就继续找</span>\n\n\n<span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> j<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">!=</span>word<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">==</span>word<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n    temp<span class=\"token operator\">=</span>board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//标记为已访问</span>\n\n    如果符合边界条件<span class=\"token punctuation\">,</span><span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>他的上下左右<span class=\"token punctuation\">,</span>index<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>temp<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//这次深搜结束,恢复</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>找到了可以直接返回,不进入二维数组,找不到则要继续,所以注意条件</li>\n<li>dfs里,return的条件是四个方向都找不到才返回false</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">exist</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> board<span class=\"token punctuation\">,</span> String word<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> board<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> board<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> board<span class=\"token punctuation\">,</span> String word<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> word<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">==</span> word<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">char</span> temp <span class=\"token operator\">=</span> board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//标记为已访问</span>\n    board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">boolean</span> result <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        result <span class=\"token operator\">=</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> board<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        result <span class=\"token operator\">=</span> result <span class=\"token operator\">||</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        result <span class=\"token operator\">=</span> result <span class=\"token operator\">||</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> board<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        result <span class=\"token operator\">=</span> result <span class=\"token operator\">||</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//这次深搜结束,恢复</span>\n    board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/word-search/\" target=\"_blank\" rel=\"noopener\">79. 单词搜索</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n<p> </p>\n<p>示例:</p>\n<pre><code>board =\n[\n  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],\n  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],\n  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]\n]\n给定 word = &quot;ABCCED&quot;, 返回 true\n给定 word = &quot;SEE&quot;, 返回 true\n给定 word = &quot;ABCB&quot;, 返回 false</code></pre>\n<p>提示：</p>\n<pre><code>board 和 word 中只包含大写和小写英文字母。\n1 &lt;= board.length &lt;= 200\n1 &lt;= board[i].length &lt;= 200\n1 &lt;= word.length &lt;= 10^3</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>深度优先搜索,在同一个搜索中,将搜索过的改变为*或其他标识,搜索后再恢复</p>\n<pre><code class=\"java\">for i in M:\n    for j in N:\n        if dfs(i,j,0) return true; //如果找到了就直接结束,找不到就继续找\n\n\ndfs(int i,int j,int index)\n{\n    if(board[i][j]!=word[index]) return false;\n    if(index==word.length-1) return true;\n\n    temp=board[i][j];\n    board[i][j]=&#39;*&#39;;//标记为已访问\n\n    如果符合边界条件,dfs(他的上下左右,index+1);\n\n    board[i][j]=temp;//这次深搜结束,恢复\n}</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>找到了可以直接返回,不进入二维数组,找不到则要继续,所以注意条件</li>\n<li>dfs里,return的条件是四个方向都找不到才返回false</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public boolean exist(char[][] board, String word)\n{\n    if (board.length == 0)\n    {\n        return false;\n    }\n    int m = board.length, n = board[0].length;\n\n    for (int i = 0; i &lt; m; i++)\n    {\n        for (int j = 0; j &lt; n; j++)\n        {\n            if (dfs(board, word, i, j, 0))\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, String word, int i, int j, int index)\n{\n    if (board[i][j] != word.charAt(index))\n    {\n        return false;\n    }\n    if (index == word.length() - 1)\n    {\n        return true;\n    }\n\n    char temp = board[i][j];\n    //标记为已访问\n    board[i][j] = &#39;*&#39;;\n\n    boolean result = false;\n\n    if (i - 1 &gt;= 0)\n    {\n        result = dfs(board, word, i - 1, j, index + 1);\n    }\n    if (i + 1 &lt; board.length)\n    {\n        result = result || dfs(board, word, i + 1, j, index + 1);\n    }\n    if (j - 1 &gt;= 0)\n    {\n        result = result || dfs(board, word, i, j - 1, index + 1);\n    }\n    if (j + 1 &lt; board[0].length)\n    {\n        result = result || dfs(board, word, i, j + 1, index + 1);\n    }\n    //这次深搜结束,恢复\n    board[i][j] = temp;\n    return result;\n}</code></pre>\n"},{"title":"LeetCode刷题笔记78","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"332a9db6","date":"2020-05-08T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [78. 子集](https://leetcode-cn.com/problems/subsets/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n# 描述\n\n给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。\n\n示例:\n```\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n# 思路\n\n画出解空间树,相当于把解空间树所有的元素都加入到了集合中(去掉重复的集合)\n\n```java\nboolean [] marked;\nrecursive(0);\n\nrecursive(int height)\n{\n    result.add(temp);\n    if(height==N) return;\n    for i in N\n    {\n        if(!marked[i])\n        {\n            temp.add(nums[i]);\n            marked[i]=true;\n            recursive(height+1);\n            marked[i]=false;\n            temp.remove(nums[i]);          \n              \n        }\n    }\n}\n```\n\n\n\n\n\n# 细节\n\n1. 注意还要去掉重复的集合,所以可以直接采用偏序简化代码\n\n\n# 代码\n\n```java\nprivate List<Integer> temp = new LinkedList<>();\nprivate List<List<Integer>> result = new LinkedList<>();\n\npublic List<List<Integer>> subsets(int[] nums)\n{\n    recursive(nums,0);\n    return result;\n}\n\npublic void recursive(int[] nums,int start)\n{\n    result.add(new LinkedList<>(temp));\n\n    for (int i = start; i < nums.length; i++)\n    {\n        temp.add(nums[i]);\n        recursive(nums,i+1);\n        temp.remove(temp.size()-1);\n    }\n}\n```\n\n```java\n//循环\n//本质上就是模拟一个个元素不断加入集合的过程\npublic List<List<Integer>> subsets(int[] nums)\n{\n    List<List<Integer>> result = new LinkedList<>();\n    result.add(new LinkedList<>());//刚开始为空集\n\n    for (int i = 0; i < nums.length; i++)\n    {\n        //加入元素nums[i]所得到的额外的list\n        List<List<Integer>> list = new LinkedList<>();\n        for (List<Integer> e : result)//就是通过原本的每个集合都加入该元素\n        {\n            List<Integer> temp = new LinkedList<>(e);\n            temp.add(nums[i]);\n            list.add(temp);\n        }\n        result.addAll(list);\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(1)$\n\n## 空间复杂度\n\n$O(1)$","source":"_posts/LeetCode笔记/LeetCode刷题笔记_78. 子集.md","raw":"---\ntitle: LeetCode刷题笔记78\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 解空间树\nabbrlink: 332a9db6\ndate: 2020-05-09 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [78. 子集](https://leetcode-cn.com/problems/subsets/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n# 描述\n\n给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。\n\n示例:\n```\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n# 思路\n\n画出解空间树,相当于把解空间树所有的元素都加入到了集合中(去掉重复的集合)\n\n```java\nboolean [] marked;\nrecursive(0);\n\nrecursive(int height)\n{\n    result.add(temp);\n    if(height==N) return;\n    for i in N\n    {\n        if(!marked[i])\n        {\n            temp.add(nums[i]);\n            marked[i]=true;\n            recursive(height+1);\n            marked[i]=false;\n            temp.remove(nums[i]);          \n              \n        }\n    }\n}\n```\n\n\n\n\n\n# 细节\n\n1. 注意还要去掉重复的集合,所以可以直接采用偏序简化代码\n\n\n# 代码\n\n```java\nprivate List<Integer> temp = new LinkedList<>();\nprivate List<List<Integer>> result = new LinkedList<>();\n\npublic List<List<Integer>> subsets(int[] nums)\n{\n    recursive(nums,0);\n    return result;\n}\n\npublic void recursive(int[] nums,int start)\n{\n    result.add(new LinkedList<>(temp));\n\n    for (int i = start; i < nums.length; i++)\n    {\n        temp.add(nums[i]);\n        recursive(nums,i+1);\n        temp.remove(temp.size()-1);\n    }\n}\n```\n\n```java\n//循环\n//本质上就是模拟一个个元素不断加入集合的过程\npublic List<List<Integer>> subsets(int[] nums)\n{\n    List<List<Integer>> result = new LinkedList<>();\n    result.add(new LinkedList<>());//刚开始为空集\n\n    for (int i = 0; i < nums.length; i++)\n    {\n        //加入元素nums[i]所得到的额外的list\n        List<List<Integer>> list = new LinkedList<>();\n        for (List<Integer> e : result)//就是通过原本的每个集合都加入该元素\n        {\n            List<Integer> temp = new LinkedList<>(e);\n            temp.add(nums[i]);\n            list.add(temp);\n        }\n        result.addAll(list);\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(1)$\n\n## 空间复杂度\n\n$O(1)$","slug":"LeetCode笔记/LeetCode刷题笔记_78. 子集","published":1,"updated":"2020-11-12T11:57:29.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yx007yjotp1c0313d9","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/subsets/\" target=\"_blank\" rel=\"noopener\">78. 子集</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>\n<p>说明：解集不能包含重复的子集。</p>\n<p>示例:</p>\n<pre><code>输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>画出解空间树,相当于把解空间树所有的元素都加入到了集合中(去掉重复的集合)</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">boolean</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> marked<span class=\"token punctuation\">;</span>\n<span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> height<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>height<span class=\"token operator\">==</span>N<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> i in N\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>marked<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            temp<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            marked<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>height<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            marked<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            temp<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          \n\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意还要去掉重复的集合,所以可以直接采用偏序简化代码</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> temp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> <span class=\"token function\">subsets</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> start<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        temp<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        temp<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//循环</span>\n<span class=\"token comment\" spellcheck=\"true\">//本质上就是模拟一个个元素不断加入集合的过程</span>\n<span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> <span class=\"token function\">subsets</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//刚开始为空集</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//加入元素nums[i]所得到的额外的list</span>\n        List<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">>></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> e <span class=\"token operator\">:</span> result<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//就是通过原本的每个集合都加入该元素</span>\n        <span class=\"token punctuation\">{</span>\n            List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> temp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            temp<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        result<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(1)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/subsets/\" target=\"_blank\" rel=\"noopener\">78. 子集</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>\n<p>说明：解集不能包含重复的子集。</p>\n<p>示例:</p>\n<pre><code>输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>画出解空间树,相当于把解空间树所有的元素都加入到了集合中(去掉重复的集合)</p>\n<pre><code class=\"java\">boolean [] marked;\nrecursive(0);\n\nrecursive(int height)\n{\n    result.add(temp);\n    if(height==N) return;\n    for i in N\n    {\n        if(!marked[i])\n        {\n            temp.add(nums[i]);\n            marked[i]=true;\n            recursive(height+1);\n            marked[i]=false;\n            temp.remove(nums[i]);          \n\n        }\n    }\n}</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>注意还要去掉重复的集合,所以可以直接采用偏序简化代码</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">private List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();\nprivate List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();\n\npublic List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums)\n{\n    recursive(nums,0);\n    return result;\n}\n\npublic void recursive(int[] nums,int start)\n{\n    result.add(new LinkedList&lt;&gt;(temp));\n\n    for (int i = start; i &lt; nums.length; i++)\n    {\n        temp.add(nums[i]);\n        recursive(nums,i+1);\n        temp.remove(temp.size()-1);\n    }\n}</code></pre>\n<pre><code class=\"java\">//循环\n//本质上就是模拟一个个元素不断加入集合的过程\npublic List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums)\n{\n    List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();\n    result.add(new LinkedList&lt;&gt;());//刚开始为空集\n\n    for (int i = 0; i &lt; nums.length; i++)\n    {\n        //加入元素nums[i]所得到的额外的list\n        List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;();\n        for (List&lt;Integer&gt; e : result)//就是通过原本的每个集合都加入该元素\n        {\n            List&lt;Integer&gt; temp = new LinkedList&lt;&gt;(e);\n            temp.add(nums[i]);\n            list.add(temp);\n        }\n        result.addAll(list);\n    }\n    return result;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(1)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(1)$</p>\n"},{"title":"LeetCode刷题笔记84","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"bd04cd52","date":"2020-05-12T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n**示例:**\n\n```\n输入: [2,1,5,6,2,3]\n输出: 10\n```\n\n# 思路\n\n整体思路是最大矩形是遍历一遍数组，分别查看以索引i为高度所形成的矩形，取他们的最大值\n\n维护一个递增序列。当遇到一个递减的元素，前面比他高的元素所能形成的矩形已经确定了，即可计算出来。然后继续，直到遍历完数组，此时有一个递增序列。\n\n对于这个序列中的某个元素nums[i],他的右边界是数组最后一个元素，左边界是下一个栈元素+1（画图出来考虑）\n\n[liweiwei1419的解法](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/)\n\n```java\nStack<Integer> stack;//递增序列 存储的是索引下标 \nfor i in N\n{\n\t//nums[stack.top()]=nums[i]的要留下,因为前面的元素还可以继续扩展\n    while(!stack.isEmpty() && nums[stack.top()]>nums[i])\n\t{\n\t\t//这里计算的是以弹出那个元素为高度的最大矩形\n\t\tint index=stack.pop();\n\t\tresult=max(result,(i-index)*nums[index]);\n\t}\n\tstack.push(i);//此时为递增序列\n}\n//对递增序列进行计算\n//这些元素每一个都可以扩展到数组尽头\nwhile(!stack.isEmpty())\n{\n\t//范围是[ stack.top()+1 , N-1 ]\n\tint index=stack.pop();\n\tresult=max(result,(N-stack.top()-1)*nums[index]);\n}\n```\n\n\n\n# 细节\n\n1. stack底部用一个-1标识，不然计算索引为0的元素的左边界有问题\n2. 注意左边界的计算不能直接为索引i（因为要注意左边比他高的被忽略而不在栈中的元素）\n3. 注意计算的都是以该索引位置的值为高，他左右两边能扩展的最大距离为宽\n\n\n# 代码\n\n```java\npublic int largestRectangleArea(int[] heights)\n{\n    //递增序列 存储的是索引下标\n    Stack<Integer> stack = new Stack<>();\n    int result = 0;\n    int n = heights.length;\n    //防止最左边元素计算不了面积\n    stack.push(-1);\n    for (int i = 0; i < n; i++)\n    {\n        //heights[stack.top()]=heights[i]的要留下,因为前面的元素还可以继续扩展\n        while (stack.peek() != -1 && heights[stack.peek()] > heights[i])\n        {\n            //这里计算的是以弹出那个元素为高度的最大矩形\n            int index = stack.pop();\n            //look 这里也要按照下面的思路,即该元素的左边界是stack.top()+1 而不能仅仅是(i - index) * heights[index]\n            result = Math.max(result, (i - stack.peek() - 1) * heights[index]);\n        }\n        //此时为递增序列\n        stack.push(i);\n    }\n    //对递增序列进行计算\n    //这些元素每一个都可以扩展到数组尽头\n    while (stack.peek() != -1)\n    {\n        //范围是[ stack.top()+1 , N-1 ]\n        int index = stack.pop();\n        result = Math.max(result, (n - stack.peek() - 1) * heights[index]);\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$\n\n## 空间复杂度\n\n$O(N)$","source":"_posts/LeetCode笔记/LeetCode刷题笔记_84. 柱状图中最大的矩形.md","raw":"---\ntitle: LeetCode刷题笔记84\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 栈\n  - 数组\nabbrlink: bd04cd52\ndate: 2020-05-13 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n**示例:**\n\n```\n输入: [2,1,5,6,2,3]\n输出: 10\n```\n\n# 思路\n\n整体思路是最大矩形是遍历一遍数组，分别查看以索引i为高度所形成的矩形，取他们的最大值\n\n维护一个递增序列。当遇到一个递减的元素，前面比他高的元素所能形成的矩形已经确定了，即可计算出来。然后继续，直到遍历完数组，此时有一个递增序列。\n\n对于这个序列中的某个元素nums[i],他的右边界是数组最后一个元素，左边界是下一个栈元素+1（画图出来考虑）\n\n[liweiwei1419的解法](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/)\n\n```java\nStack<Integer> stack;//递增序列 存储的是索引下标 \nfor i in N\n{\n\t//nums[stack.top()]=nums[i]的要留下,因为前面的元素还可以继续扩展\n    while(!stack.isEmpty() && nums[stack.top()]>nums[i])\n\t{\n\t\t//这里计算的是以弹出那个元素为高度的最大矩形\n\t\tint index=stack.pop();\n\t\tresult=max(result,(i-index)*nums[index]);\n\t}\n\tstack.push(i);//此时为递增序列\n}\n//对递增序列进行计算\n//这些元素每一个都可以扩展到数组尽头\nwhile(!stack.isEmpty())\n{\n\t//范围是[ stack.top()+1 , N-1 ]\n\tint index=stack.pop();\n\tresult=max(result,(N-stack.top()-1)*nums[index]);\n}\n```\n\n\n\n# 细节\n\n1. stack底部用一个-1标识，不然计算索引为0的元素的左边界有问题\n2. 注意左边界的计算不能直接为索引i（因为要注意左边比他高的被忽略而不在栈中的元素）\n3. 注意计算的都是以该索引位置的值为高，他左右两边能扩展的最大距离为宽\n\n\n# 代码\n\n```java\npublic int largestRectangleArea(int[] heights)\n{\n    //递增序列 存储的是索引下标\n    Stack<Integer> stack = new Stack<>();\n    int result = 0;\n    int n = heights.length;\n    //防止最左边元素计算不了面积\n    stack.push(-1);\n    for (int i = 0; i < n; i++)\n    {\n        //heights[stack.top()]=heights[i]的要留下,因为前面的元素还可以继续扩展\n        while (stack.peek() != -1 && heights[stack.peek()] > heights[i])\n        {\n            //这里计算的是以弹出那个元素为高度的最大矩形\n            int index = stack.pop();\n            //look 这里也要按照下面的思路,即该元素的左边界是stack.top()+1 而不能仅仅是(i - index) * heights[index]\n            result = Math.max(result, (i - stack.peek() - 1) * heights[index]);\n        }\n        //此时为递增序列\n        stack.push(i);\n    }\n    //对递增序列进行计算\n    //这些元素每一个都可以扩展到数组尽头\n    while (stack.peek() != -1)\n    {\n        //范围是[ stack.top()+1 , N-1 ]\n        int index = stack.pop();\n        result = Math.max(result, (n - stack.peek() - 1) * heights[index]);\n    }\n    return result;\n}\n```\n\n\n\n# 复杂度分析\n## 时间复杂度\n\n$O(N)$\n\n## 空间复杂度\n\n$O(N)$","slug":"LeetCode笔记/LeetCode刷题笔记_84. 柱状图中最大的矩形","published":1,"updated":"2020-11-12T11:57:29.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yy0080jotpgrtbefou","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\" target=\"_blank\" rel=\"noopener\">84. 柱状图中最大的矩形</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n<p><strong>示例:</strong></p>\n<pre><code>输入: [2,1,5,6,2,3]\n输出: 10</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>整体思路是最大矩形是遍历一遍数组，分别查看以索引i为高度所形成的矩形，取他们的最大值</p>\n<p>维护一个递增序列。当遇到一个递减的元素，前面比他高的元素所能形成的矩形已经确定了，即可计算出来。然后继续，直到遍历完数组，此时有一个递增序列。</p>\n<p>对于这个序列中的某个元素nums[i],他的右边界是数组最后一个元素，左边界是下一个栈元素+1（画图出来考虑）</p>\n<p><a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/\" target=\"_blank\" rel=\"noopener\">liweiwei1419的解法</a></p>\n<pre class=\" language-java\"><code class=\"language-java\">Stack<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> stack<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//递增序列 存储的是索引下标 </span>\n<span class=\"token keyword\">for</span> i in N\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//nums[stack.top()]=nums[i]的要留下,因为前面的元素还可以继续扩展</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//这里计算的是以弹出那个元素为高度的最大矩形</span>\n        <span class=\"token keyword\">int</span> index<span class=\"token operator\">=</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        result<span class=\"token operator\">=</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">-</span>index<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>nums<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//此时为递增序列</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//对递增序列进行计算</span>\n<span class=\"token comment\" spellcheck=\"true\">//这些元素每一个都可以扩展到数组尽头</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//范围是[ stack.top()+1 , N-1 ]</span>\n    <span class=\"token keyword\">int</span> index<span class=\"token operator\">=</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    result<span class=\"token operator\">=</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">-</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>nums<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>stack底部用一个-1标识，不然计算索引为0的元素的左边界有问题</li>\n<li>注意左边界的计算不能直接为索引i（因为要注意左边比他高的被忽略而不在栈中的元素）</li>\n<li>注意计算的都是以该索引位置的值为高，他左右两边能扩展的最大距离为宽</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">largestRectangleArea</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> heights<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//递增序列 存储的是索引下标</span>\n    Stack<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> stack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> heights<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//防止最左边元素计算不了面积</span>\n    stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//heights[stack.top()]=heights[i]的要留下,因为前面的元素还可以继续扩展</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> heights<span class=\"token punctuation\">[</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> heights<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//这里计算的是以弹出那个元素为高度的最大矩形</span>\n            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//look 这里也要按照下面的思路,即该元素的左边界是stack.top()+1 而不能仅仅是(i - index) * heights[index]</span>\n            result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> heights<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//此时为递增序列</span>\n        stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//对递增序列进行计算</span>\n    <span class=\"token comment\" spellcheck=\"true\">//这些元素每一个都可以扩展到数组尽头</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//范围是[ stack.top()+1 , N-1 ]</span>\n        <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        result <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> heights<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(N)$</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\" target=\"_blank\" rel=\"noopener\">84. 柱状图中最大的矩形</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n<p><strong>示例:</strong></p>\n<pre><code>输入: [2,1,5,6,2,3]\n输出: 10</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>整体思路是最大矩形是遍历一遍数组，分别查看以索引i为高度所形成的矩形，取他们的最大值</p>\n<p>维护一个递增序列。当遇到一个递减的元素，前面比他高的元素所能形成的矩形已经确定了，即可计算出来。然后继续，直到遍历完数组，此时有一个递增序列。</p>\n<p>对于这个序列中的某个元素nums[i],他的右边界是数组最后一个元素，左边界是下一个栈元素+1（画图出来考虑）</p>\n<p><a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/\" target=\"_blank\" rel=\"noopener\">liweiwei1419的解法</a></p>\n<pre><code class=\"java\">Stack&lt;Integer&gt; stack;//递增序列 存储的是索引下标 \nfor i in N\n{\n    //nums[stack.top()]=nums[i]的要留下,因为前面的元素还可以继续扩展\n    while(!stack.isEmpty() &amp;&amp; nums[stack.top()]&gt;nums[i])\n    {\n        //这里计算的是以弹出那个元素为高度的最大矩形\n        int index=stack.pop();\n        result=max(result,(i-index)*nums[index]);\n    }\n    stack.push(i);//此时为递增序列\n}\n//对递增序列进行计算\n//这些元素每一个都可以扩展到数组尽头\nwhile(!stack.isEmpty())\n{\n    //范围是[ stack.top()+1 , N-1 ]\n    int index=stack.pop();\n    result=max(result,(N-stack.top()-1)*nums[index]);\n}</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ol>\n<li>stack底部用一个-1标识，不然计算索引为0的元素的左边界有问题</li>\n<li>注意左边界的计算不能直接为索引i（因为要注意左边比他高的被忽略而不在栈中的元素）</li>\n<li>注意计算的都是以该索引位置的值为高，他左右两边能扩展的最大距离为宽</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int largestRectangleArea(int[] heights)\n{\n    //递增序列 存储的是索引下标\n    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n    int result = 0;\n    int n = heights.length;\n    //防止最左边元素计算不了面积\n    stack.push(-1);\n    for (int i = 0; i &lt; n; i++)\n    {\n        //heights[stack.top()]=heights[i]的要留下,因为前面的元素还可以继续扩展\n        while (stack.peek() != -1 &amp;&amp; heights[stack.peek()] &gt; heights[i])\n        {\n            //这里计算的是以弹出那个元素为高度的最大矩形\n            int index = stack.pop();\n            //look 这里也要按照下面的思路,即该元素的左边界是stack.top()+1 而不能仅仅是(i - index) * heights[index]\n            result = Math.max(result, (i - stack.peek() - 1) * heights[index]);\n        }\n        //此时为递增序列\n        stack.push(i);\n    }\n    //对递增序列进行计算\n    //这些元素每一个都可以扩展到数组尽头\n    while (stack.peek() != -1)\n    {\n        //范围是[ stack.top()+1 , N-1 ]\n        int index = stack.pop();\n        result = Math.max(result, (n - stack.peek() - 1) * heights[index]);\n    }\n    return result;\n}</code></pre>\n<h1 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h1><h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>$O(N)$</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>$O(N)$</p>\n"},{"title":"LeetCode刷题笔记94","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"a41ffc13","date":"2020-05-14T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n>  [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个二叉树，返回它的中序 遍历。\n\n示例:\n```\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n```\n\n# 思路\n\n迭代:用栈的方式,思路和递归差不多。先往左走到底，不能走就回退一格，加入当前元素。然后继续查看当前元素的右节点。搞定完该节点，再回退一格。直到弄完根节点。\n\n# 细节\n\n# 代码\n\n```java\n//递归\npublic List<Integer> inorderTraversal(TreeNode root)\n{\n    List<Integer> result = new LinkedList<>();\n    recursive(root, result);\n    return result;\n}\n\nprivate void recursive(TreeNode node, List<Integer> result)\n{\n    if(node==null)\n    {\n        return;\n    }\n    recursive(node.left,result);\n    result.add(node.val);\n    recursive(node.right,result);\n}\n```\n\n\n\n```java\n//迭代\npublic List<Integer> inorderTraversal(TreeNode root)\n{\n    List<Integer> result = new LinkedList<>();\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode current = root;\n    \n    //current!=null 代表了还存在右节点\n    //!stack.isEmpty() 代表了存在父节点\n    //当然开始时只是看根节点\n    while(current!=null || !stack.isEmpty())\n    {\n        while(current!=null)\n        {\n            stack.push(current);\n            current = current.left;\n        }\n        current = stack.pop();\n        result.add(current.val);\n        current = current.right;\n    }\n    return result;\n}\n```\n\n\n\n\n\n","source":"_posts/LeetCode笔记/LeetCode刷题笔记_94. 二叉树的中序遍历.md","raw":"---\ntitle: LeetCode刷题笔记94\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - Java\n  - 二叉树\nabbrlink: a41ffc13\ndate: 2020-05-15 00:00:00\n---\n\n> 题目出自LeetCode\n>\n>  [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n给定一个二叉树，返回它的中序 遍历。\n\n示例:\n```\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n```\n\n# 思路\n\n迭代:用栈的方式,思路和递归差不多。先往左走到底，不能走就回退一格，加入当前元素。然后继续查看当前元素的右节点。搞定完该节点，再回退一格。直到弄完根节点。\n\n# 细节\n\n# 代码\n\n```java\n//递归\npublic List<Integer> inorderTraversal(TreeNode root)\n{\n    List<Integer> result = new LinkedList<>();\n    recursive(root, result);\n    return result;\n}\n\nprivate void recursive(TreeNode node, List<Integer> result)\n{\n    if(node==null)\n    {\n        return;\n    }\n    recursive(node.left,result);\n    result.add(node.val);\n    recursive(node.right,result);\n}\n```\n\n\n\n```java\n//迭代\npublic List<Integer> inorderTraversal(TreeNode root)\n{\n    List<Integer> result = new LinkedList<>();\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode current = root;\n    \n    //current!=null 代表了还存在右节点\n    //!stack.isEmpty() 代表了存在父节点\n    //当然开始时只是看根节点\n    while(current!=null || !stack.isEmpty())\n    {\n        while(current!=null)\n        {\n            stack.push(current);\n            current = current.left;\n        }\n        current = stack.pop();\n        result.add(current.val);\n        current = current.right;\n    }\n    return result;\n}\n```\n\n\n\n\n\n","slug":"LeetCode笔记/LeetCode刷题笔记_94. 二叉树的中序遍历","published":1,"updated":"2020-11-12T11:57:29.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6yz0083jotpaczbca4l","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">94. 二叉树的中序遍历</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二叉树，返回它的中序 遍历。</p>\n<p>示例:</p>\n<pre><code>输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>迭代:用栈的方式,思路和递归差不多。先往左走到底，不能走就回退一格，加入当前元素。然后继续查看当前元素的右节点。搞定完该节点，再回退一格。直到弄完根节点。</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//递归</span>\n<span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> <span class=\"token function\">inorderTraversal</span><span class=\"token punctuation\">(</span>TreeNode root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>TreeNode node<span class=\"token punctuation\">,</span> List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> result<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//迭代</span>\n<span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> <span class=\"token function\">inorderTraversal</span><span class=\"token punctuation\">(</span>TreeNode root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    List<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Stack<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">></span> stack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    TreeNode current <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//current!=null 代表了还存在右节点</span>\n    <span class=\"token comment\" spellcheck=\"true\">//!stack.isEmpty() 代表了存在父节点</span>\n    <span class=\"token comment\" spellcheck=\"true\">//当然开始时只是看根节点</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>current<span class=\"token operator\">!=</span>null <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>current<span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        current <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p> <a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">94. 二叉树的中序遍历</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二叉树，返回它的中序 遍历。</p>\n<p>示例:</p>\n<pre><code>输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>迭代:用栈的方式,思路和递归差不多。先往左走到底，不能走就回退一格，加入当前元素。然后继续查看当前元素的右节点。搞定完该节点，再回退一格。直到弄完根节点。</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">//递归\npublic List&lt;Integer&gt; inorderTraversal(TreeNode root)\n{\n    List&lt;Integer&gt; result = new LinkedList&lt;&gt;();\n    recursive(root, result);\n    return result;\n}\n\nprivate void recursive(TreeNode node, List&lt;Integer&gt; result)\n{\n    if(node==null)\n    {\n        return;\n    }\n    recursive(node.left,result);\n    result.add(node.val);\n    recursive(node.right,result);\n}</code></pre>\n<pre><code class=\"java\">//迭代\npublic List&lt;Integer&gt; inorderTraversal(TreeNode root)\n{\n    List&lt;Integer&gt; result = new LinkedList&lt;&gt;();\n    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n    TreeNode current = root;\n\n    //current!=null 代表了还存在右节点\n    //!stack.isEmpty() 代表了存在父节点\n    //当然开始时只是看根节点\n    while(current!=null || !stack.isEmpty())\n    {\n        while(current!=null)\n        {\n            stack.push(current);\n            current = current.left;\n        }\n        current = stack.pop();\n        result.add(current.val);\n        current = current.right;\n    }\n    return result;\n}</code></pre>\n"},{"title":"LeetCode刷题笔记98","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"ada9b038","date":"2020-05-18T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n节点的左子树只包含小于当前节点的数。\n\t\t节点的右子树只包含大于当前节点的数。\n\t\t所有左子树和右子树自身必须也是二叉搜索树。\n示例 1:\n\n```\n输入:\n    2\n   / \\\n  1   3\n输出: true\n```\n\n\n\n\n示例 2:\n```\n输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n```\n\n# 思路\n\n中序遍历,如果后面的节点小于等于前面的节点,就不是二叉搜索树\n\n# 细节\n\n使用isFirst避免下面特殊情况出现错误:\n\n如果最左边的正好是Integer.MIN_VALUE或者有两个Integer.MIN_VALUE\n\n# 代码\n\n```java\npublic boolean isValidBST(TreeNode root)\n{\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode temp = root;\n    boolean isFirst = true;\n    int pre=0;\n    while(temp!=null || !stack.isEmpty())\n    {\n        while(temp!=null)\n        {\n            stack.push(temp);\n            temp = temp.left;\n        }\n        temp = stack.pop();\n        if(isFirst)\n        {\n            pre = temp.val;\n            isFirst = false;\n        }\n        else if(temp.val<=pre)\n        {\n            return false;\n        }\n        pre = temp.val;\n        temp = temp.right;\n    }\n    return true;\n}\n```","source":"_posts/LeetCode笔记/LeetCode刷题笔记_98. 验证二叉搜索树.md","raw":"---\ntitle: LeetCode刷题笔记98\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 二叉树\n  - 递归\nabbrlink: ada9b038\ndate: 2020-05-19 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n节点的左子树只包含小于当前节点的数。\n\t\t节点的右子树只包含大于当前节点的数。\n\t\t所有左子树和右子树自身必须也是二叉搜索树。\n示例 1:\n\n```\n输入:\n    2\n   / \\\n  1   3\n输出: true\n```\n\n\n\n\n示例 2:\n```\n输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n```\n\n# 思路\n\n中序遍历,如果后面的节点小于等于前面的节点,就不是二叉搜索树\n\n# 细节\n\n使用isFirst避免下面特殊情况出现错误:\n\n如果最左边的正好是Integer.MIN_VALUE或者有两个Integer.MIN_VALUE\n\n# 代码\n\n```java\npublic boolean isValidBST(TreeNode root)\n{\n    Stack<TreeNode> stack=new Stack<>();\n    TreeNode temp = root;\n    boolean isFirst = true;\n    int pre=0;\n    while(temp!=null || !stack.isEmpty())\n    {\n        while(temp!=null)\n        {\n            stack.push(temp);\n            temp = temp.left;\n        }\n        temp = stack.pop();\n        if(isFirst)\n        {\n            pre = temp.val;\n            isFirst = false;\n        }\n        else if(temp.val<=pre)\n        {\n            return false;\n        }\n        pre = temp.val;\n        temp = temp.right;\n    }\n    return true;\n}\n```","slug":"LeetCode笔记/LeetCode刷题笔记_98. 验证二叉搜索树","published":1,"updated":"2020-11-12T11:57:29.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6z00085jotphqgr3dgx","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">98. 验证二叉搜索树</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<p>假设一个二叉搜索树具有如下特征：</p>\n<p>节点的左子树只包含小于当前节点的数。<br>        节点的右子树只包含大于当前节点的数。<br>        所有左子树和右子树自身必须也是二叉搜索树。<br>示例 1:</p>\n<pre><code>输入:\n    2\n   / \\\n  1   3\n输出: true</code></pre>\n<p>示例 2:</p>\n<pre><code>输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>中序遍历,如果后面的节点小于等于前面的节点,就不是二叉搜索树</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>使用isFirst避免下面特殊情况出现错误:</p>\n<p>如果最左边的正好是Integer.MIN_VALUE或者有两个Integer.MIN_VALUE</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isValidBST</span><span class=\"token punctuation\">(</span>TreeNode root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Stack<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">></span> stack<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    TreeNode temp <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span> isFirst <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> pre<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>temp<span class=\"token operator\">!=</span>null <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>temp<span class=\"token operator\">!=</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            temp <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        temp <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>isFirst<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            pre <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n            isFirst <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">.</span>val<span class=\"token operator\">&lt;=</span>pre<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        pre <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n        temp <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">98. 验证二叉搜索树</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<p>假设一个二叉搜索树具有如下特征：</p>\n<p>节点的左子树只包含小于当前节点的数。<br>        节点的右子树只包含大于当前节点的数。<br>        所有左子树和右子树自身必须也是二叉搜索树。<br>示例 1:</p>\n<pre><code>输入:\n    2\n   / \\\n  1   3\n输出: true</code></pre>\n<p>示例 2:</p>\n<pre><code>输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>中序遍历,如果后面的节点小于等于前面的节点,就不是二叉搜索树</p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>使用isFirst避免下面特殊情况出现错误:</p>\n<p>如果最左边的正好是Integer.MIN_VALUE或者有两个Integer.MIN_VALUE</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public boolean isValidBST(TreeNode root)\n{\n    Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();\n    TreeNode temp = root;\n    boolean isFirst = true;\n    int pre=0;\n    while(temp!=null || !stack.isEmpty())\n    {\n        while(temp!=null)\n        {\n            stack.push(temp);\n            temp = temp.left;\n        }\n        temp = stack.pop();\n        if(isFirst)\n        {\n            pre = temp.val;\n            isFirst = false;\n        }\n        else if(temp.val&lt;=pre)\n        {\n            return false;\n        }\n        pre = temp.val;\n        temp = temp.right;\n    }\n    return true;\n}</code></pre>\n"},{"title":"第一章--计算机网络和因特网","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<<计算机网络：自顶向下方法>>读书笔记,第一章--计算机网络和因特网。","abbrlink":"4411b5fd","date":"2020-10-31T16:00:00.000Z","_content":"\n# 概览\n\n+ 某层向他的上一层提供服务,每层通过在该层中执行某些动作或直接使用下层的服务来提供服务。\n+ 一个协议层能够使用软件，硬件或两者的结合来实现。\n+ 五层因特网协议栈包括：应用层，运输层，网络层，链路层，物理层\n+ 7层ISO OSI参考模型包括：应用层，表示层，会话层，运输层，网络层，链路层，物理层\n\n# 应用层\n\n+ 包括`HTTP`,`SMTP`,`FTP`协议\n+ 域名系统`DNS`\n+ 应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。把这种位于应用层的信息分组称为报文\n\n# 运输层\n\n+ 两种运输协议`TCP`,`IP`,利用其中任何一个都能传输应用层报文\n+ `TCP`提供了面向连接的服务，包括确保传递和流量控制\n+ `UDP`提供无连接服务，不提供不必要的服务，没有可靠性，没有流量控制，没有拥塞控制\n+ 运输层的分组叫做报文段\n\n# 网络层\n\n+ 负责将称为数据报的网络层分组从一台主机移动到另一台主机\n+ 网际协议`IP`，`IP`仅有一个\n+ 还包括了路由选择协议，根据该路由将数据报从源传输到目的地\n+ 通过源和目的地之间的一系列路由器路由数据报\n\n# 链路层\n\n+ 在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点，在下一个节点，链路层将数据报上传给网络层\n+ 链路层分组称为帧\n+ 链路层任务是将整个帧从一个网络元素移动到邻近的网络元素\n\n# 物理层\n\n+ 负责将帧中的一个个比特从一个节点移动到下一个节点\n\n# 封装\n\n+ 路由器实现了物理层，链路层，网络层，而链路层交换机只实现了物理层，链路层\n+ 应用层报文传送到运输层，加上了运输层首部信息构成了运输层报文段\n+ 运输层向网络层传递该报文段，又增加了网络层首部信息，形成网络层数据报\n+ 之后传递给链路层，增加链路层首部信息生成链路层帧\n+ 在每层，都有首部字段和有效载荷字段（来自上一层的分组）","source":"_posts/计算机网络/01_计算机网络和因特网.md","raw":"---\ntitle: 第一章--计算机网络和因特网\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<<计算机网络：自顶向下方法>>读书笔记,第一章--计算机网络和因特网。'\ncategories: 计算机网络\ntags:\n  - 计算机网络\n  - OSI参考模型\n  - TCP/IP\nabbrlink: 4411b5fd\ndate: 2020-11-01 00:00:00\n---\n\n# 概览\n\n+ 某层向他的上一层提供服务,每层通过在该层中执行某些动作或直接使用下层的服务来提供服务。\n+ 一个协议层能够使用软件，硬件或两者的结合来实现。\n+ 五层因特网协议栈包括：应用层，运输层，网络层，链路层，物理层\n+ 7层ISO OSI参考模型包括：应用层，表示层，会话层，运输层，网络层，链路层，物理层\n\n# 应用层\n\n+ 包括`HTTP`,`SMTP`,`FTP`协议\n+ 域名系统`DNS`\n+ 应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。把这种位于应用层的信息分组称为报文\n\n# 运输层\n\n+ 两种运输协议`TCP`,`IP`,利用其中任何一个都能传输应用层报文\n+ `TCP`提供了面向连接的服务，包括确保传递和流量控制\n+ `UDP`提供无连接服务，不提供不必要的服务，没有可靠性，没有流量控制，没有拥塞控制\n+ 运输层的分组叫做报文段\n\n# 网络层\n\n+ 负责将称为数据报的网络层分组从一台主机移动到另一台主机\n+ 网际协议`IP`，`IP`仅有一个\n+ 还包括了路由选择协议，根据该路由将数据报从源传输到目的地\n+ 通过源和目的地之间的一系列路由器路由数据报\n\n# 链路层\n\n+ 在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点，在下一个节点，链路层将数据报上传给网络层\n+ 链路层分组称为帧\n+ 链路层任务是将整个帧从一个网络元素移动到邻近的网络元素\n\n# 物理层\n\n+ 负责将帧中的一个个比特从一个节点移动到下一个节点\n\n# 封装\n\n+ 路由器实现了物理层，链路层，网络层，而链路层交换机只实现了物理层，链路层\n+ 应用层报文传送到运输层，加上了运输层首部信息构成了运输层报文段\n+ 运输层向网络层传递该报文段，又增加了网络层首部信息，形成网络层数据报\n+ 之后传递给链路层，增加链路层首部信息生成链路层帧\n+ 在每层，都有首部字段和有效载荷字段（来自上一层的分组）","slug":"计算机网络/01_计算机网络和因特网","published":1,"updated":"2021-02-04T00:35:08.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6z10088jotpd8ce9l9y","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><ul>\n<li>某层向他的上一层提供服务,每层通过在该层中执行某些动作或直接使用下层的服务来提供服务。</li>\n<li>一个协议层能够使用软件，硬件或两者的结合来实现。</li>\n<li>五层因特网协议栈包括：应用层，运输层，网络层，链路层，物理层</li>\n<li>7层ISO OSI参考模型包括：应用层，表示层，会话层，运输层，网络层，链路层，物理层</li>\n</ul>\n<h1 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h1><ul>\n<li>包括<code>HTTP</code>,<code>SMTP</code>,<code>FTP</code>协议</li>\n<li>域名系统<code>DNS</code></li>\n<li>应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。把这种位于应用层的信息分组称为报文</li>\n</ul>\n<h1 id=\"运输层\"><a href=\"#运输层\" class=\"headerlink\" title=\"运输层\"></a>运输层</h1><ul>\n<li>两种运输协议<code>TCP</code>,<code>IP</code>,利用其中任何一个都能传输应用层报文</li>\n<li><code>TCP</code>提供了面向连接的服务，包括确保传递和流量控制</li>\n<li><code>UDP</code>提供无连接服务，不提供不必要的服务，没有可靠性，没有流量控制，没有拥塞控制</li>\n<li>运输层的分组叫做报文段</li>\n</ul>\n<h1 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h1><ul>\n<li>负责将称为数据报的网络层分组从一台主机移动到另一台主机</li>\n<li>网际协议<code>IP</code>，<code>IP</code>仅有一个</li>\n<li>还包括了路由选择协议，根据该路由将数据报从源传输到目的地</li>\n<li>通过源和目的地之间的一系列路由器路由数据报</li>\n</ul>\n<h1 id=\"链路层\"><a href=\"#链路层\" class=\"headerlink\" title=\"链路层\"></a>链路层</h1><ul>\n<li>在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点，在下一个节点，链路层将数据报上传给网络层</li>\n<li>链路层分组称为帧</li>\n<li>链路层任务是将整个帧从一个网络元素移动到邻近的网络元素</li>\n</ul>\n<h1 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h1><ul>\n<li>负责将帧中的一个个比特从一个节点移动到下一个节点</li>\n</ul>\n<h1 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h1><ul>\n<li>路由器实现了物理层，链路层，网络层，而链路层交换机只实现了物理层，链路层</li>\n<li>应用层报文传送到运输层，加上了运输层首部信息构成了运输层报文段</li>\n<li>运输层向网络层传递该报文段，又增加了网络层首部信息，形成网络层数据报</li>\n<li>之后传递给链路层，增加链路层首部信息生成链路层帧</li>\n<li>在每层，都有首部字段和有效载荷字段（来自上一层的分组）</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><ul>\n<li>某层向他的上一层提供服务,每层通过在该层中执行某些动作或直接使用下层的服务来提供服务。</li>\n<li>一个协议层能够使用软件，硬件或两者的结合来实现。</li>\n<li>五层因特网协议栈包括：应用层，运输层，网络层，链路层，物理层</li>\n<li>7层ISO OSI参考模型包括：应用层，表示层，会话层，运输层，网络层，链路层，物理层</li>\n</ul>\n<h1 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h1><ul>\n<li>包括<code>HTTP</code>,<code>SMTP</code>,<code>FTP</code>协议</li>\n<li>域名系统<code>DNS</code></li>\n<li>应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。把这种位于应用层的信息分组称为报文</li>\n</ul>\n<h1 id=\"运输层\"><a href=\"#运输层\" class=\"headerlink\" title=\"运输层\"></a>运输层</h1><ul>\n<li>两种运输协议<code>TCP</code>,<code>IP</code>,利用其中任何一个都能传输应用层报文</li>\n<li><code>TCP</code>提供了面向连接的服务，包括确保传递和流量控制</li>\n<li><code>UDP</code>提供无连接服务，不提供不必要的服务，没有可靠性，没有流量控制，没有拥塞控制</li>\n<li>运输层的分组叫做报文段</li>\n</ul>\n<h1 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h1><ul>\n<li>负责将称为数据报的网络层分组从一台主机移动到另一台主机</li>\n<li>网际协议<code>IP</code>，<code>IP</code>仅有一个</li>\n<li>还包括了路由选择协议，根据该路由将数据报从源传输到目的地</li>\n<li>通过源和目的地之间的一系列路由器路由数据报</li>\n</ul>\n<h1 id=\"链路层\"><a href=\"#链路层\" class=\"headerlink\" title=\"链路层\"></a>链路层</h1><ul>\n<li>在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点，在下一个节点，链路层将数据报上传给网络层</li>\n<li>链路层分组称为帧</li>\n<li>链路层任务是将整个帧从一个网络元素移动到邻近的网络元素</li>\n</ul>\n<h1 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h1><ul>\n<li>负责将帧中的一个个比特从一个节点移动到下一个节点</li>\n</ul>\n<h1 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h1><ul>\n<li>路由器实现了物理层，链路层，网络层，而链路层交换机只实现了物理层，链路层</li>\n<li>应用层报文传送到运输层，加上了运输层首部信息构成了运输层报文段</li>\n<li>运输层向网络层传递该报文段，又增加了网络层首部信息，形成网络层数据报</li>\n<li>之后传递给链路层，增加链路层首部信息生成链路层帧</li>\n<li>在每层，都有首部字段和有效载荷字段（来自上一层的分组）</li>\n</ul>\n"},{"title":"第三章--运输层","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<<计算机网络：自顶向下方法>>读书笔记,第三章--运输层。","abbrlink":"9ec9055a","date":"2020-11-07T16:00:00.000Z","_content":"\n# 运输层服务\n\n+ 运输层未应用进程提供逻辑通信功能\n\n+ 运输层协议是在端系统中而不是路由器中实现的\n\n+ 在发送端,运输层讲从发送应用程序进程接收到的报文转换成运输层分组,即**报文段**\n\n+ 即将报文分为较小的块,每块假设一个运输层首部,将他们传递给网络层\n\n+ 网络层封装成数据报发送\n\n+ 网络路由器仅作用于该数据报的网络层字段,不检查运输层报文段的字段\n\n+ 有复用和分用两个过程,写信后一切发(复用),收到的回信分发给具体的每个人(分用)\n\n\t\n\n## 运输层和网络层的关系\n\n+ 网络层提供了主机之间的逻辑通信,而运输层提供进程之间的逻辑通信\n+ 类似于两个家庭之间依靠邮政(网络层)发送邮件,依靠孩子(运输层)分发给家庭中的每个人\n+ 运输层协议只工作在端系统中,运输层只负责将来自应用进程的报文移动到网络边缘(网络层),对他在网络核心如何移动并不关心\n+ 中间路由器也不识别运输层报文段的任何信息\n+ 运输层能够提供的服务常常受限于底层网络层协议的服务模型\n\n## 概述\n\n+ `IP`称为不可靠服务\n+ 每台主机至少有一个网络层地址,即`IP`地址\n+ 运输层的基本职责就是把两个端系统之间的`IP`的交互服务扩展为运行在端系统上的两个进程之间的交互服务,称为**运输层的多路复用与多路分解**\n+ `UDP`只提供进程到进程之间的数据交互和差错检查,是不可靠的服务\n+ `TCP`额外提供**可靠数据传输**,**拥塞控制**\n\n## 端口号\n\n+ `16bit`,一共`65536`个\n+ 服务端端口号:熟知端口号 `0-1023`,登记端口号`1024-49151`\n+ 客户端端口号:仅在客户进程运行时才动态选择的端口号,`49151-65536`\n\n# UDP\n\n## 特点\n\n1. 只提供复用分用,差错检测功能\n2. 无连接\n3. 不保证可靠交付\n4. 面向报文的,适合一次性传输少量数据的网络应用(就是一次发送一个完整的报文,不分成报文段)\n5. 无拥塞控制,适合实时应用\n6. 首部开销小(`8B`)\n\n## 首部格式\n\n+ 16位源端口号(如果不需要回应则可以全零)\n+ 16位目的端口号\n+ 16位`UDP`长度,`UDP`报文的整个长度\n+ 16位`UDP`校验和,检验整个`UDP`数据报是否有错,错则丢弃\n\n# TCP\n\n+ 面向连接\n+ 只能有两个端点,点对点的\n+ 可靠有序,不丢不重\n+ 提供全双工通信. 有发送缓存(准备发送的数据和已发送但尚未收到确认的数据)和接收缓存\n+ 面向字节流.看成无结构的字节流\n\n## 报文段首部格式\n\n### 20B的固定首部\n\n+ 源端口,目的端口\n+ 序号:在一个TCP连接中传送的字节流中每一个字节都按顺序编号,本字段表示本报文段所发送数据的第一个字节的序号\n+ 确认号:期望收到对方下一个报文段的第一个数据字节的序号.如果确认号为N,代表到序号N-1为止的所有数据都已正确收到\n+ 数据偏移(首部长度):TCP报文段的数据起始处距离TCP报文段的起始处有多远,以4B为单位.控制位:`URG`(紧急位,标识优先级),`ACK`(连接建立后所有传送报文段应把他置为1),`PSH`(接收方进行的紧急处理),`RST`(复位,说明出现了严重差错,必须释放连接),`SYN`(同步位,表明是一个连接请求/连接接收报文),`FIN`(此报文段发送方数据已发完,要求释放连接).窗口字段:指发送本报文段的一方的接收窗口,即现在允许对方发送的数据量\n+ 校验和:校验首部+数据 紧急指针:`URG=1`时才有意义,指出本报文段中紧急数据的字节数\n\n+ 选项(最大报文段长度MSS,时间戳等) 和 填充字段(为了对齐)\n\n## 连接管理\n\n主动发起连接建立的应用进程叫做客户,被动等待连接建立的应用进程叫做服务器\n\n## 可靠传输\n\n1. 校验,与`UDP`校验一样,增加伪首部\n2. 序号,按字节为单位编上序号,根据序号来保证\n3. 确认,接收方确定后发一个确认报文段.采用累计确认机制,即前面的必须都收到,不能留空\n4. 重传,超时重传,重传时间 自适应算法,动态改变重传时间`RTTs`(加权平均往返时间) ,每当比期望序号大的失序报文段到达时,会发送冗余`ACK`,指明下一个期待字节的序号\n\n## 流量控制\n\n+ 利用**滑动窗口**机制实现流量控制\n+ 接收方根据自己接收缓存的大小,动态调整窗口字段`rwnd`给发送方\n+ 发送方的发送窗口取决于窗口字段`rwnd`和拥塞窗口`cwnd`的最小值\n\n## 拥塞控制\n\n### 假设\n\n1. 假定数据单方向传送,而另一个方向只传送确认\n2. 接收方总是有足够大的缓存空间,因此发送窗口大小取决于拥塞程度,拥塞窗口是发送方设置的,反映的是自己估算的网络拥塞程度\n\n### 慢开始和拥塞避免\n\n### 快重传和快恢复\n\n\n\n\n\n\n\n","source":"_posts/计算机网络/03_运输层.md","raw":"---\ntitle: 第三章--运输层\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<<计算机网络：自顶向下方法>>读书笔记,第三章--运输层。'\ncategories: 计算机网络\ntags:\n  - 运输层\n  - TCP\n  - UDP\nabbrlink: 9ec9055a\ndate: 2020-11-08 00:00:00\n---\n\n# 运输层服务\n\n+ 运输层未应用进程提供逻辑通信功能\n\n+ 运输层协议是在端系统中而不是路由器中实现的\n\n+ 在发送端,运输层讲从发送应用程序进程接收到的报文转换成运输层分组,即**报文段**\n\n+ 即将报文分为较小的块,每块假设一个运输层首部,将他们传递给网络层\n\n+ 网络层封装成数据报发送\n\n+ 网络路由器仅作用于该数据报的网络层字段,不检查运输层报文段的字段\n\n+ 有复用和分用两个过程,写信后一切发(复用),收到的回信分发给具体的每个人(分用)\n\n\t\n\n## 运输层和网络层的关系\n\n+ 网络层提供了主机之间的逻辑通信,而运输层提供进程之间的逻辑通信\n+ 类似于两个家庭之间依靠邮政(网络层)发送邮件,依靠孩子(运输层)分发给家庭中的每个人\n+ 运输层协议只工作在端系统中,运输层只负责将来自应用进程的报文移动到网络边缘(网络层),对他在网络核心如何移动并不关心\n+ 中间路由器也不识别运输层报文段的任何信息\n+ 运输层能够提供的服务常常受限于底层网络层协议的服务模型\n\n## 概述\n\n+ `IP`称为不可靠服务\n+ 每台主机至少有一个网络层地址,即`IP`地址\n+ 运输层的基本职责就是把两个端系统之间的`IP`的交互服务扩展为运行在端系统上的两个进程之间的交互服务,称为**运输层的多路复用与多路分解**\n+ `UDP`只提供进程到进程之间的数据交互和差错检查,是不可靠的服务\n+ `TCP`额外提供**可靠数据传输**,**拥塞控制**\n\n## 端口号\n\n+ `16bit`,一共`65536`个\n+ 服务端端口号:熟知端口号 `0-1023`,登记端口号`1024-49151`\n+ 客户端端口号:仅在客户进程运行时才动态选择的端口号,`49151-65536`\n\n# UDP\n\n## 特点\n\n1. 只提供复用分用,差错检测功能\n2. 无连接\n3. 不保证可靠交付\n4. 面向报文的,适合一次性传输少量数据的网络应用(就是一次发送一个完整的报文,不分成报文段)\n5. 无拥塞控制,适合实时应用\n6. 首部开销小(`8B`)\n\n## 首部格式\n\n+ 16位源端口号(如果不需要回应则可以全零)\n+ 16位目的端口号\n+ 16位`UDP`长度,`UDP`报文的整个长度\n+ 16位`UDP`校验和,检验整个`UDP`数据报是否有错,错则丢弃\n\n# TCP\n\n+ 面向连接\n+ 只能有两个端点,点对点的\n+ 可靠有序,不丢不重\n+ 提供全双工通信. 有发送缓存(准备发送的数据和已发送但尚未收到确认的数据)和接收缓存\n+ 面向字节流.看成无结构的字节流\n\n## 报文段首部格式\n\n### 20B的固定首部\n\n+ 源端口,目的端口\n+ 序号:在一个TCP连接中传送的字节流中每一个字节都按顺序编号,本字段表示本报文段所发送数据的第一个字节的序号\n+ 确认号:期望收到对方下一个报文段的第一个数据字节的序号.如果确认号为N,代表到序号N-1为止的所有数据都已正确收到\n+ 数据偏移(首部长度):TCP报文段的数据起始处距离TCP报文段的起始处有多远,以4B为单位.控制位:`URG`(紧急位,标识优先级),`ACK`(连接建立后所有传送报文段应把他置为1),`PSH`(接收方进行的紧急处理),`RST`(复位,说明出现了严重差错,必须释放连接),`SYN`(同步位,表明是一个连接请求/连接接收报文),`FIN`(此报文段发送方数据已发完,要求释放连接).窗口字段:指发送本报文段的一方的接收窗口,即现在允许对方发送的数据量\n+ 校验和:校验首部+数据 紧急指针:`URG=1`时才有意义,指出本报文段中紧急数据的字节数\n\n+ 选项(最大报文段长度MSS,时间戳等) 和 填充字段(为了对齐)\n\n## 连接管理\n\n主动发起连接建立的应用进程叫做客户,被动等待连接建立的应用进程叫做服务器\n\n## 可靠传输\n\n1. 校验,与`UDP`校验一样,增加伪首部\n2. 序号,按字节为单位编上序号,根据序号来保证\n3. 确认,接收方确定后发一个确认报文段.采用累计确认机制,即前面的必须都收到,不能留空\n4. 重传,超时重传,重传时间 自适应算法,动态改变重传时间`RTTs`(加权平均往返时间) ,每当比期望序号大的失序报文段到达时,会发送冗余`ACK`,指明下一个期待字节的序号\n\n## 流量控制\n\n+ 利用**滑动窗口**机制实现流量控制\n+ 接收方根据自己接收缓存的大小,动态调整窗口字段`rwnd`给发送方\n+ 发送方的发送窗口取决于窗口字段`rwnd`和拥塞窗口`cwnd`的最小值\n\n## 拥塞控制\n\n### 假设\n\n1. 假定数据单方向传送,而另一个方向只传送确认\n2. 接收方总是有足够大的缓存空间,因此发送窗口大小取决于拥塞程度,拥塞窗口是发送方设置的,反映的是自己估算的网络拥塞程度\n\n### 慢开始和拥塞避免\n\n### 快重传和快恢复\n\n\n\n\n\n\n\n","slug":"计算机网络/03_运输层","published":1,"updated":"2020-11-12T11:57:30.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6z2008bjotpcflc22hc","content":"<h1 id=\"运输层服务\"><a href=\"#运输层服务\" class=\"headerlink\" title=\"运输层服务\"></a>运输层服务</h1><ul>\n<li><p>运输层未应用进程提供逻辑通信功能</p>\n</li>\n<li><p>运输层协议是在端系统中而不是路由器中实现的</p>\n</li>\n<li><p>在发送端,运输层讲从发送应用程序进程接收到的报文转换成运输层分组,即<strong>报文段</strong></p>\n</li>\n<li><p>即将报文分为较小的块,每块假设一个运输层首部,将他们传递给网络层</p>\n</li>\n<li><p>网络层封装成数据报发送</p>\n</li>\n<li><p>网络路由器仅作用于该数据报的网络层字段,不检查运输层报文段的字段</p>\n</li>\n<li><p>有复用和分用两个过程,写信后一切发(复用),收到的回信分发给具体的每个人(分用)</p>\n</li>\n</ul>\n<h2 id=\"运输层和网络层的关系\"><a href=\"#运输层和网络层的关系\" class=\"headerlink\" title=\"运输层和网络层的关系\"></a>运输层和网络层的关系</h2><ul>\n<li>网络层提供了主机之间的逻辑通信,而运输层提供进程之间的逻辑通信</li>\n<li>类似于两个家庭之间依靠邮政(网络层)发送邮件,依靠孩子(运输层)分发给家庭中的每个人</li>\n<li>运输层协议只工作在端系统中,运输层只负责将来自应用进程的报文移动到网络边缘(网络层),对他在网络核心如何移动并不关心</li>\n<li>中间路由器也不识别运输层报文段的任何信息</li>\n<li>运输层能够提供的服务常常受限于底层网络层协议的服务模型</li>\n</ul>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li><code>IP</code>称为不可靠服务</li>\n<li>每台主机至少有一个网络层地址,即<code>IP</code>地址</li>\n<li>运输层的基本职责就是把两个端系统之间的<code>IP</code>的交互服务扩展为运行在端系统上的两个进程之间的交互服务,称为<strong>运输层的多路复用与多路分解</strong></li>\n<li><code>UDP</code>只提供进程到进程之间的数据交互和差错检查,是不可靠的服务</li>\n<li><code>TCP</code>额外提供<strong>可靠数据传输</strong>,<strong>拥塞控制</strong></li>\n</ul>\n<h2 id=\"端口号\"><a href=\"#端口号\" class=\"headerlink\" title=\"端口号\"></a>端口号</h2><ul>\n<li><code>16bit</code>,一共<code>65536</code>个</li>\n<li>服务端端口号:熟知端口号 <code>0-1023</code>,登记端口号<code>1024-49151</code></li>\n<li>客户端端口号:仅在客户进程运行时才动态选择的端口号,<code>49151-65536</code></li>\n</ul>\n<h1 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h1><h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>只提供复用分用,差错检测功能</li>\n<li>无连接</li>\n<li>不保证可靠交付</li>\n<li>面向报文的,适合一次性传输少量数据的网络应用(就是一次发送一个完整的报文,不分成报文段)</li>\n<li>无拥塞控制,适合实时应用</li>\n<li>首部开销小(<code>8B</code>)</li>\n</ol>\n<h2 id=\"首部格式\"><a href=\"#首部格式\" class=\"headerlink\" title=\"首部格式\"></a>首部格式</h2><ul>\n<li>16位源端口号(如果不需要回应则可以全零)</li>\n<li>16位目的端口号</li>\n<li>16位<code>UDP</code>长度,<code>UDP</code>报文的整个长度</li>\n<li>16位<code>UDP</code>校验和,检验整个<code>UDP</code>数据报是否有错,错则丢弃</li>\n</ul>\n<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><ul>\n<li>面向连接</li>\n<li>只能有两个端点,点对点的</li>\n<li>可靠有序,不丢不重</li>\n<li>提供全双工通信. 有发送缓存(准备发送的数据和已发送但尚未收到确认的数据)和接收缓存</li>\n<li>面向字节流.看成无结构的字节流</li>\n</ul>\n<h2 id=\"报文段首部格式\"><a href=\"#报文段首部格式\" class=\"headerlink\" title=\"报文段首部格式\"></a>报文段首部格式</h2><h3 id=\"20B的固定首部\"><a href=\"#20B的固定首部\" class=\"headerlink\" title=\"20B的固定首部\"></a>20B的固定首部</h3><ul>\n<li><p>源端口,目的端口</p>\n</li>\n<li><p>序号:在一个TCP连接中传送的字节流中每一个字节都按顺序编号,本字段表示本报文段所发送数据的第一个字节的序号</p>\n</li>\n<li><p>确认号:期望收到对方下一个报文段的第一个数据字节的序号.如果确认号为N,代表到序号N-1为止的所有数据都已正确收到</p>\n</li>\n<li><p>数据偏移(首部长度):TCP报文段的数据起始处距离TCP报文段的起始处有多远,以4B为单位.控制位:<code>URG</code>(紧急位,标识优先级),<code>ACK</code>(连接建立后所有传送报文段应把他置为1),<code>PSH</code>(接收方进行的紧急处理),<code>RST</code>(复位,说明出现了严重差错,必须释放连接),<code>SYN</code>(同步位,表明是一个连接请求/连接接收报文),<code>FIN</code>(此报文段发送方数据已发完,要求释放连接).窗口字段:指发送本报文段的一方的接收窗口,即现在允许对方发送的数据量</p>\n</li>\n<li><p>校验和:校验首部+数据 紧急指针:<code>URG=1</code>时才有意义,指出本报文段中紧急数据的字节数</p>\n</li>\n<li><p>选项(最大报文段长度MSS,时间戳等) 和 填充字段(为了对齐)</p>\n</li>\n</ul>\n<h2 id=\"连接管理\"><a href=\"#连接管理\" class=\"headerlink\" title=\"连接管理\"></a>连接管理</h2><p>主动发起连接建立的应用进程叫做客户,被动等待连接建立的应用进程叫做服务器</p>\n<h2 id=\"可靠传输\"><a href=\"#可靠传输\" class=\"headerlink\" title=\"可靠传输\"></a>可靠传输</h2><ol>\n<li>校验,与<code>UDP</code>校验一样,增加伪首部</li>\n<li>序号,按字节为单位编上序号,根据序号来保证</li>\n<li>确认,接收方确定后发一个确认报文段.采用累计确认机制,即前面的必须都收到,不能留空</li>\n<li>重传,超时重传,重传时间 自适应算法,动态改变重传时间<code>RTTs</code>(加权平均往返时间) ,每当比期望序号大的失序报文段到达时,会发送冗余<code>ACK</code>,指明下一个期待字节的序号</li>\n</ol>\n<h2 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h2><ul>\n<li>利用<strong>滑动窗口</strong>机制实现流量控制</li>\n<li>接收方根据自己接收缓存的大小,动态调整窗口字段<code>rwnd</code>给发送方</li>\n<li>发送方的发送窗口取决于窗口字段<code>rwnd</code>和拥塞窗口<code>cwnd</code>的最小值</li>\n</ul>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><h3 id=\"假设\"><a href=\"#假设\" class=\"headerlink\" title=\"假设\"></a>假设</h3><ol>\n<li>假定数据单方向传送,而另一个方向只传送确认</li>\n<li>接收方总是有足够大的缓存空间,因此发送窗口大小取决于拥塞程度,拥塞窗口是发送方设置的,反映的是自己估算的网络拥塞程度</li>\n</ol>\n<h3 id=\"慢开始和拥塞避免\"><a href=\"#慢开始和拥塞避免\" class=\"headerlink\" title=\"慢开始和拥塞避免\"></a>慢开始和拥塞避免</h3><h3 id=\"快重传和快恢复\"><a href=\"#快重传和快恢复\" class=\"headerlink\" title=\"快重传和快恢复\"></a>快重传和快恢复</h3>","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"运输层服务\"><a href=\"#运输层服务\" class=\"headerlink\" title=\"运输层服务\"></a>运输层服务</h1><ul>\n<li><p>运输层未应用进程提供逻辑通信功能</p>\n</li>\n<li><p>运输层协议是在端系统中而不是路由器中实现的</p>\n</li>\n<li><p>在发送端,运输层讲从发送应用程序进程接收到的报文转换成运输层分组,即<strong>报文段</strong></p>\n</li>\n<li><p>即将报文分为较小的块,每块假设一个运输层首部,将他们传递给网络层</p>\n</li>\n<li><p>网络层封装成数据报发送</p>\n</li>\n<li><p>网络路由器仅作用于该数据报的网络层字段,不检查运输层报文段的字段</p>\n</li>\n<li><p>有复用和分用两个过程,写信后一切发(复用),收到的回信分发给具体的每个人(分用)</p>\n</li>\n</ul>\n<h2 id=\"运输层和网络层的关系\"><a href=\"#运输层和网络层的关系\" class=\"headerlink\" title=\"运输层和网络层的关系\"></a>运输层和网络层的关系</h2><ul>\n<li>网络层提供了主机之间的逻辑通信,而运输层提供进程之间的逻辑通信</li>\n<li>类似于两个家庭之间依靠邮政(网络层)发送邮件,依靠孩子(运输层)分发给家庭中的每个人</li>\n<li>运输层协议只工作在端系统中,运输层只负责将来自应用进程的报文移动到网络边缘(网络层),对他在网络核心如何移动并不关心</li>\n<li>中间路由器也不识别运输层报文段的任何信息</li>\n<li>运输层能够提供的服务常常受限于底层网络层协议的服务模型</li>\n</ul>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li><code>IP</code>称为不可靠服务</li>\n<li>每台主机至少有一个网络层地址,即<code>IP</code>地址</li>\n<li>运输层的基本职责就是把两个端系统之间的<code>IP</code>的交互服务扩展为运行在端系统上的两个进程之间的交互服务,称为<strong>运输层的多路复用与多路分解</strong></li>\n<li><code>UDP</code>只提供进程到进程之间的数据交互和差错检查,是不可靠的服务</li>\n<li><code>TCP</code>额外提供<strong>可靠数据传输</strong>,<strong>拥塞控制</strong></li>\n</ul>\n<h2 id=\"端口号\"><a href=\"#端口号\" class=\"headerlink\" title=\"端口号\"></a>端口号</h2><ul>\n<li><code>16bit</code>,一共<code>65536</code>个</li>\n<li>服务端端口号:熟知端口号 <code>0-1023</code>,登记端口号<code>1024-49151</code></li>\n<li>客户端端口号:仅在客户进程运行时才动态选择的端口号,<code>49151-65536</code></li>\n</ul>\n<h1 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h1><h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>只提供复用分用,差错检测功能</li>\n<li>无连接</li>\n<li>不保证可靠交付</li>\n<li>面向报文的,适合一次性传输少量数据的网络应用(就是一次发送一个完整的报文,不分成报文段)</li>\n<li>无拥塞控制,适合实时应用</li>\n<li>首部开销小(<code>8B</code>)</li>\n</ol>\n<h2 id=\"首部格式\"><a href=\"#首部格式\" class=\"headerlink\" title=\"首部格式\"></a>首部格式</h2><ul>\n<li>16位源端口号(如果不需要回应则可以全零)</li>\n<li>16位目的端口号</li>\n<li>16位<code>UDP</code>长度,<code>UDP</code>报文的整个长度</li>\n<li>16位<code>UDP</code>校验和,检验整个<code>UDP</code>数据报是否有错,错则丢弃</li>\n</ul>\n<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><ul>\n<li>面向连接</li>\n<li>只能有两个端点,点对点的</li>\n<li>可靠有序,不丢不重</li>\n<li>提供全双工通信. 有发送缓存(准备发送的数据和已发送但尚未收到确认的数据)和接收缓存</li>\n<li>面向字节流.看成无结构的字节流</li>\n</ul>\n<h2 id=\"报文段首部格式\"><a href=\"#报文段首部格式\" class=\"headerlink\" title=\"报文段首部格式\"></a>报文段首部格式</h2><h3 id=\"20B的固定首部\"><a href=\"#20B的固定首部\" class=\"headerlink\" title=\"20B的固定首部\"></a>20B的固定首部</h3><ul>\n<li><p>源端口,目的端口</p>\n</li>\n<li><p>序号:在一个TCP连接中传送的字节流中每一个字节都按顺序编号,本字段表示本报文段所发送数据的第一个字节的序号</p>\n</li>\n<li><p>确认号:期望收到对方下一个报文段的第一个数据字节的序号.如果确认号为N,代表到序号N-1为止的所有数据都已正确收到</p>\n</li>\n<li><p>数据偏移(首部长度):TCP报文段的数据起始处距离TCP报文段的起始处有多远,以4B为单位.控制位:<code>URG</code>(紧急位,标识优先级),<code>ACK</code>(连接建立后所有传送报文段应把他置为1),<code>PSH</code>(接收方进行的紧急处理),<code>RST</code>(复位,说明出现了严重差错,必须释放连接),<code>SYN</code>(同步位,表明是一个连接请求/连接接收报文),<code>FIN</code>(此报文段发送方数据已发完,要求释放连接).窗口字段:指发送本报文段的一方的接收窗口,即现在允许对方发送的数据量</p>\n</li>\n<li><p>校验和:校验首部+数据 紧急指针:<code>URG=1</code>时才有意义,指出本报文段中紧急数据的字节数</p>\n</li>\n<li><p>选项(最大报文段长度MSS,时间戳等) 和 填充字段(为了对齐)</p>\n</li>\n</ul>\n<h2 id=\"连接管理\"><a href=\"#连接管理\" class=\"headerlink\" title=\"连接管理\"></a>连接管理</h2><p>主动发起连接建立的应用进程叫做客户,被动等待连接建立的应用进程叫做服务器</p>\n<h2 id=\"可靠传输\"><a href=\"#可靠传输\" class=\"headerlink\" title=\"可靠传输\"></a>可靠传输</h2><ol>\n<li>校验,与<code>UDP</code>校验一样,增加伪首部</li>\n<li>序号,按字节为单位编上序号,根据序号来保证</li>\n<li>确认,接收方确定后发一个确认报文段.采用累计确认机制,即前面的必须都收到,不能留空</li>\n<li>重传,超时重传,重传时间 自适应算法,动态改变重传时间<code>RTTs</code>(加权平均往返时间) ,每当比期望序号大的失序报文段到达时,会发送冗余<code>ACK</code>,指明下一个期待字节的序号</li>\n</ol>\n<h2 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h2><ul>\n<li>利用<strong>滑动窗口</strong>机制实现流量控制</li>\n<li>接收方根据自己接收缓存的大小,动态调整窗口字段<code>rwnd</code>给发送方</li>\n<li>发送方的发送窗口取决于窗口字段<code>rwnd</code>和拥塞窗口<code>cwnd</code>的最小值</li>\n</ul>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><h3 id=\"假设\"><a href=\"#假设\" class=\"headerlink\" title=\"假设\"></a>假设</h3><ol>\n<li>假定数据单方向传送,而另一个方向只传送确认</li>\n<li>接收方总是有足够大的缓存空间,因此发送窗口大小取决于拥塞程度,拥塞窗口是发送方设置的,反映的是自己估算的网络拥塞程度</li>\n</ol>\n<h3 id=\"慢开始和拥塞避免\"><a href=\"#慢开始和拥塞避免\" class=\"headerlink\" title=\"慢开始和拥塞避免\"></a>慢开始和拥塞避免</h3><h3 id=\"快重传和快恢复\"><a href=\"#快重传和快恢复\" class=\"headerlink\" title=\"快重传和快恢复\"></a>快重传和快恢复</h3>"},{"title":"LeetCode刷题笔记96","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":true,"summary":"LeetCode刷题笔记","abbrlink":"4a119d3f","date":"2020-05-16T16:00:00.000Z","_content":"\n> 题目出自LeetCode\n>\n> [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n\n示例:\n```\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n```\n\n# 思路\n\n```\n动态规划:\n\ndp[i]代表n=i时组成的二叉搜索树的种类数量\n\n初始化: dp[0]=1,dp[1]=1\n\n递推方程:\nfor j in [1,i]:\n\t\tdp[i]+=dp[j-1]*dp[i-j]\n\n返回:dp[n]\n```\n\n\n\n```\nfor i in [2,n]:\n\tfor j in [1,i]:\n\t\tdp[i]+=dp[j-1]*dp[i-j]\n```\n\n\n\n# 细节\n\n注意i从2开始\n\n\n# 代码\n\n```java\npublic int numTrees(int n)\n{\n    if(n<1)\n    {\n        throw new IllegalArgumentException();\n    }\n\n    int[] dp = new int[n + 1];\n    //dp[0]=1也可以代表的是,左边(右边)为空的情况有一种\n    dp[0] = 1;\n    dp[1] = 1;\n    //look,i要从2开始,1的话是初始值,如果从1开始,则dp[1]=2\n    for (int i = 2; i <= n; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n    return dp[n];\n}\n```","source":"_posts/LeetCode笔记/LeetCode刷题笔记_96. 不同的二叉搜索树.md","raw":"---\ntitle: LeetCode刷题笔记96\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: true\nsummary: LeetCode刷题笔记\ncategories: LeetCode笔记\ntags:\n  - LeetCode\n  - 二叉树\n  - 动态规划\nabbrlink: 4a119d3f\ndate: 2020-05-17 00:00:00\n---\n\n> 题目出自LeetCode\n>\n> [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)\n>\n>  其他题解或源码可以访问： [tongji4m3](https://github.com/tongji4m3/LeetCode)\n\n\n\n# 描述\n\n给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n\n示例:\n```\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n```\n\n# 思路\n\n```\n动态规划:\n\ndp[i]代表n=i时组成的二叉搜索树的种类数量\n\n初始化: dp[0]=1,dp[1]=1\n\n递推方程:\nfor j in [1,i]:\n\t\tdp[i]+=dp[j-1]*dp[i-j]\n\n返回:dp[n]\n```\n\n\n\n```\nfor i in [2,n]:\n\tfor j in [1,i]:\n\t\tdp[i]+=dp[j-1]*dp[i-j]\n```\n\n\n\n# 细节\n\n注意i从2开始\n\n\n# 代码\n\n```java\npublic int numTrees(int n)\n{\n    if(n<1)\n    {\n        throw new IllegalArgumentException();\n    }\n\n    int[] dp = new int[n + 1];\n    //dp[0]=1也可以代表的是,左边(右边)为空的情况有一种\n    dp[0] = 1;\n    dp[1] = 1;\n    //look,i要从2开始,1的话是初始值,如果从1开始,则dp[1]=2\n    for (int i = 2; i <= n; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n    return dp[n];\n}\n```","slug":"LeetCode笔记/LeetCode刷题笔记_96. 不同的二叉搜索树","published":1,"updated":"2020-11-12T11:57:29.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6z3008gjotp506q7jfs","content":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">96. 不同的二叉搜索树</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>\n<p>示例:</p>\n<pre><code>输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code>动态规划:\n\ndp[i]代表n=i时组成的二叉搜索树的种类数量\n\n初始化: dp[0]=1,dp[1]=1\n\n递推方程:\nfor j in [1,i]:\n        dp[i]+=dp[j-1]*dp[i-j]\n\n返回:dp[n]</code></pre>\n<pre><code>for i in [2,n]:\n    for j in [1,i]:\n        dp[i]+=dp[j-1]*dp[i-j]</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>注意i从2开始</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">numTrees</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">&lt;</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> dp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//dp[0]=1也可以代表的是,左边(右边)为空的情况有一种</span>\n    dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    dp<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//look,i要从2开始,1的话是初始值,如果从1开始,则dp[1]=2</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> dp<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> dp<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>题目出自LeetCode</p>\n<p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees/\" target=\"_blank\" rel=\"noopener\">96. 不同的二叉搜索树</a></p>\n<p> 其他题解或源码可以访问： <a href=\"https://github.com/tongji4m3/LeetCode\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n</blockquote>\n<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>\n<p>示例:</p>\n<pre><code>输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n</code></pre>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><pre><code>动态规划:\n\ndp[i]代表n=i时组成的二叉搜索树的种类数量\n\n初始化: dp[0]=1,dp[1]=1\n\n递推方程:\nfor j in [1,i]:\n        dp[i]+=dp[j-1]*dp[i-j]\n\n返回:dp[n]</code></pre>\n<pre><code>for i in [2,n]:\n    for j in [1,i]:\n        dp[i]+=dp[j-1]*dp[i-j]</code></pre>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><p>注意i从2开始</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"java\">public int numTrees(int n)\n{\n    if(n&lt;1)\n    {\n        throw new IllegalArgumentException();\n    }\n\n    int[] dp = new int[n + 1];\n    //dp[0]=1也可以代表的是,左边(右边)为空的情况有一种\n    dp[0] = 1;\n    dp[1] = 1;\n    //look,i要从2开始,1的话是初始值,如果从1开始,则dp[1]=2\n    for (int i = 2; i &lt;= n; i++)\n    {\n        for (int j = 1; j &lt;= i; j++)\n        {\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n    return dp[n];\n}</code></pre>\n"},{"title":"第二章--应用层","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<<计算机网络：自顶向下方法>>读书笔记,第二章--应用层。","abbrlink":"3a03a942","date":"2020-11-03T16:00:00.000Z","_content":"\n# 应用层协议原理\n\n+ 研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序\n\n## 进程通信\n\n+ 在一对进程之间的通信会话场景中,发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为客户,在会话开始时等待联系的进程是服务器\n+ 套接字是同一台主机内应用层和运输层之间的接口。\n+ 由于套接字是建立在网络应用程序的可编程接口，也称为应用程序和网络之间的应用程序编程接口（API）\n+ 开发者对运输层的控制仅限于：1.选择运输层协议 2.设定几个运输层参数，例如最大缓存等\n+ 指定**IP地址，端口号**\n\n## 运输服务选择\n\n### 可靠数据传输\n\n当一个运输协议提供这样的服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程\n\n### 吞吐量\n\n可用吞吐量就是发送进程能够向接收进程交付比特的速率\n\n运输层协议能够以某种特定的速率提供确保的可用吞吐量\n\n具有吞吐量要求的应用程序被称为带宽敏感的应用\n\n### 定时\n\n发送方注入进套接字中的每个比特到达接收方的套接字不迟于`100ms`\n\n对交互式实时应用程序有用\n\n### 安全性\n\n运输协议能加密由发送进程传输的所有数据，并且在发送和接收进程之间提供机密性，防止被其他方式观测到，并且在交付给接收进程之前解密数据\n\n### TCP\n\n#### 面向连接服务\n\n在数据报文流动之前，让客户和服务器互相交换运输层控制信息，提醒客户和服务器做好准备。在握手阶段，一个**TCP连接**就在两个进程的套接字之间建立了\n\n是全双工的，双方可以同时进行报文收发，结束后，必须拆除连接\n\n#### 可靠的数据传送服务\n\n可以无差错，按适当顺序交付所有发送的数据，没有字节的丢失和冗余\n\n### UDP\n\n+ 轻量级运输协议，只提供最小服务、\n+ 无连接的，通信前没有握手过程\n+ 提供不可靠的数据传送服务，并不保证报文到达接收进程，且可能是乱序到达的\n\n## 应用层协议\n\n+ 定义了运行在不同端系统上的应用程序如何相互传递报文\n\n+ `HTTP`超文本传输协议\n+ `SMTP`简单邮件传输协议\n\n# HTTP\n\n服务器向客户发送被请求的文件,而不存储任何关于该客户的状态信息,无状态协议\n\n## 持续连接的HTTP\n\n`HTTP 1.1`持续连接:服务器在发送响应后保存该`TCP`连接打开,在相同的客户和服务器之间,后续的请求和响应报文能够通过相同的连接进行传送\n\n如果一条连接经过一定时间间隔仍未被使用,`HTTP`服务器就会关闭该连接\n\n## cookie\n\n`cookie`用于标识一个用户.用户首次访问一个站点时,可能需要提供一个用户标识.在后续会话中,浏览器向服务器传递一个`cookie`首部,从而向该服务器标识了用户.因此`cookie`可以在无状态的`HTTP`之上建立一个用户会话层\n\n## Web缓存\n\n+ Web缓存器也叫做代理服务器,能够代表初始的`Web`服务器来满足`HTTP`请求的网络实体\n+ 它有自己的磁盘存储空间,并在存储空间中保存最近请求过的对象的副本.\n+ 可以配置用户的浏览器,使得用户所有的`HTTP`请求首先指向`Web`缓冲器,每个对某对象的浏览器请求首先会把定向到该`Web`缓冲器\n+ `Web`缓冲器通常由`ISP`购买并安装,一所大学可能在他的校园网上安装一台缓冲器,并且将所有校园网上的用户浏览器配置为指向他\n\n### 流程\n\n1. 浏览器创建一个到`Web`缓冲器的`TCP`连接\n2. `Web`缓冲器进行检查,有副本直接返回\n3. 没有则自己打开一个与该对象的初始服务器的`TCP`连接\n4. `Web`缓冲器在本地存储副本,并通过现有的`TCP`连接返回给浏览器\n\n### 条件GET方法\n\n用于判断缓存是否修改\n\n1. 代理服务器向Web服务器发送请求,得到对象以及对象的最后修改时间\n2. 一个星期后,另一个用户访问该缓存,缓冲区通过条件`GET`执行最新检查\n3. 即发送了自己存储的最后修改时间,如果Web服务器发现该对象在指定日期后对该对象修改过,才重新发送该对象,否则只会发送空对象\n4. 即`304 Not Modified`,告诉缓冲器,可以使用该对象\n\n# DNS\n\n域名系统,能进行主机名到`IP`地址转换的目录服务\n\n1. 一个由分层的`DNS`服务器实现的分布式数据库\n2. 一个使得主机能够查询分布式数据库的应用层协议\n3. `DNS`运行在`UDP`上,端口号为53\n4. `DNS`是为因特网上的用户应用程序以及其他软件提供一种核心功能,即将主机名转换为其背后的`IP`地址\n5. `DNS`通常是由其他应用层协议所使用的,将用户提供的主机名解析为`IP`地址\n6. 想获得的`IP`地址通常就缓存在一个附近的`DNS`服务器,有助于减少`DNS`的网络流量和`DNS`的平均时延\n\n## DNS是应用层协议\n\n1. 它使用客户-服务器模式运行在通信的端系统之间\n2. 在通信的端系统之间通过下面的端到端运输协议来传送DNS报文\n\n## 请求URL过程\n\n假设一个用户访问`tongji4m3.club/index.html`\n\n1. 同一台用户主机上运行着`DNS`应用的客户端\n2. 浏览器从上述`URL`中抽取处主机名`tongji4m3.club`,并将该主机名传给DNS客户端\n3. `DNS`客户端会向`DNS`服务器发送一个包含主机名的请求\n4. `DNS`客户端会收到一份回答报文,包含对应主机名的`IP`地址\n5. 浏览器接收该`IP`地址,向该`IP`地址的80端口的`HTTP`服务器进程发送一个`TCP`连接\n\n## DNS其他服务\n\n+ 主机别名,应用程序可以通过主机别名获得对应的规范主机名和`IP`地址\n+ 邮件服务器别名\n+ 负载分配:繁忙的站点被冗余分配在多台服务器上,每台服务器都有不同的IP地址,一个`IP`地址集合因此与同一个规范主机名相联系.当客户对映射到某地址集合的名字发出一个`DNS`请求时,该服务器用`IP`地址的整个集合进行响应,但在每个回答中循环这些地址次序\n\n## DNS工作机理概述\n\n### 分布式,层次数据库\n\n+ 没有一台`DNS`服务器拥有因特网上所有主机的映射,这些映射分布在所有的`DNS`服务器上\n+ 根`DNS`服务器,根名字服务器提供`TLD`服务器的`IP`地址\n+ 顶级域服务器,对应每个顶级域(com,edu,gov等)和所有国家的顶级域(如uk,fr),都有`TLD`服务器\n+ 权威DNS服务器,具有公共可访问主机的每个组织机构都必须提供公共可访问的`DNS`记录,将主机名称映射为`IP`地址\n+ 本地`DNS`服务器.每个`ISP`都有一台本地`DNS`服务器,起着代理的作用\n\n### DNS记录和报文\n\n`DNS`服务器存储了资源记录(RR),提供了主机名到`IP`地址的映射\n\n资源记录:`(Name,Value,Type,TTL)`\n\n+ TTL是该记录的生存时间,决定RR应当从缓存中删除的时间\n+ `Type=A`,则是主机名,IP地址\n+ `Type=NS`,则`Name`是一个域,如`foo.com`,而`Value`是知道如何获得该域中主机`IP`地址的权威`DNS`服务器的主机名,用于沿着查询链来路由`DNS`查询\n+ 如果`Type=CNAME`,则`Value`是别名为`Name`的主机对应的规范主机名\n+ 如果`Type=MX`则`Value`是别名为`Name`的邮件服务器的规范主机名","source":"_posts/计算机网络/02_应用层.md","raw":"---\ntitle: 第二章--应用层\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<<计算机网络：自顶向下方法>>读书笔记,第二章--应用层。'\ncategories: 计算机网络\ntags:\n  - DNS\n  - 应用层\n  - HTTP\nabbrlink: 3a03a942\ndate: 2020-11-04 00:00:00\n---\n\n# 应用层协议原理\n\n+ 研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序\n\n## 进程通信\n\n+ 在一对进程之间的通信会话场景中,发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为客户,在会话开始时等待联系的进程是服务器\n+ 套接字是同一台主机内应用层和运输层之间的接口。\n+ 由于套接字是建立在网络应用程序的可编程接口，也称为应用程序和网络之间的应用程序编程接口（API）\n+ 开发者对运输层的控制仅限于：1.选择运输层协议 2.设定几个运输层参数，例如最大缓存等\n+ 指定**IP地址，端口号**\n\n## 运输服务选择\n\n### 可靠数据传输\n\n当一个运输协议提供这样的服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程\n\n### 吞吐量\n\n可用吞吐量就是发送进程能够向接收进程交付比特的速率\n\n运输层协议能够以某种特定的速率提供确保的可用吞吐量\n\n具有吞吐量要求的应用程序被称为带宽敏感的应用\n\n### 定时\n\n发送方注入进套接字中的每个比特到达接收方的套接字不迟于`100ms`\n\n对交互式实时应用程序有用\n\n### 安全性\n\n运输协议能加密由发送进程传输的所有数据，并且在发送和接收进程之间提供机密性，防止被其他方式观测到，并且在交付给接收进程之前解密数据\n\n### TCP\n\n#### 面向连接服务\n\n在数据报文流动之前，让客户和服务器互相交换运输层控制信息，提醒客户和服务器做好准备。在握手阶段，一个**TCP连接**就在两个进程的套接字之间建立了\n\n是全双工的，双方可以同时进行报文收发，结束后，必须拆除连接\n\n#### 可靠的数据传送服务\n\n可以无差错，按适当顺序交付所有发送的数据，没有字节的丢失和冗余\n\n### UDP\n\n+ 轻量级运输协议，只提供最小服务、\n+ 无连接的，通信前没有握手过程\n+ 提供不可靠的数据传送服务，并不保证报文到达接收进程，且可能是乱序到达的\n\n## 应用层协议\n\n+ 定义了运行在不同端系统上的应用程序如何相互传递报文\n\n+ `HTTP`超文本传输协议\n+ `SMTP`简单邮件传输协议\n\n# HTTP\n\n服务器向客户发送被请求的文件,而不存储任何关于该客户的状态信息,无状态协议\n\n## 持续连接的HTTP\n\n`HTTP 1.1`持续连接:服务器在发送响应后保存该`TCP`连接打开,在相同的客户和服务器之间,后续的请求和响应报文能够通过相同的连接进行传送\n\n如果一条连接经过一定时间间隔仍未被使用,`HTTP`服务器就会关闭该连接\n\n## cookie\n\n`cookie`用于标识一个用户.用户首次访问一个站点时,可能需要提供一个用户标识.在后续会话中,浏览器向服务器传递一个`cookie`首部,从而向该服务器标识了用户.因此`cookie`可以在无状态的`HTTP`之上建立一个用户会话层\n\n## Web缓存\n\n+ Web缓存器也叫做代理服务器,能够代表初始的`Web`服务器来满足`HTTP`请求的网络实体\n+ 它有自己的磁盘存储空间,并在存储空间中保存最近请求过的对象的副本.\n+ 可以配置用户的浏览器,使得用户所有的`HTTP`请求首先指向`Web`缓冲器,每个对某对象的浏览器请求首先会把定向到该`Web`缓冲器\n+ `Web`缓冲器通常由`ISP`购买并安装,一所大学可能在他的校园网上安装一台缓冲器,并且将所有校园网上的用户浏览器配置为指向他\n\n### 流程\n\n1. 浏览器创建一个到`Web`缓冲器的`TCP`连接\n2. `Web`缓冲器进行检查,有副本直接返回\n3. 没有则自己打开一个与该对象的初始服务器的`TCP`连接\n4. `Web`缓冲器在本地存储副本,并通过现有的`TCP`连接返回给浏览器\n\n### 条件GET方法\n\n用于判断缓存是否修改\n\n1. 代理服务器向Web服务器发送请求,得到对象以及对象的最后修改时间\n2. 一个星期后,另一个用户访问该缓存,缓冲区通过条件`GET`执行最新检查\n3. 即发送了自己存储的最后修改时间,如果Web服务器发现该对象在指定日期后对该对象修改过,才重新发送该对象,否则只会发送空对象\n4. 即`304 Not Modified`,告诉缓冲器,可以使用该对象\n\n# DNS\n\n域名系统,能进行主机名到`IP`地址转换的目录服务\n\n1. 一个由分层的`DNS`服务器实现的分布式数据库\n2. 一个使得主机能够查询分布式数据库的应用层协议\n3. `DNS`运行在`UDP`上,端口号为53\n4. `DNS`是为因特网上的用户应用程序以及其他软件提供一种核心功能,即将主机名转换为其背后的`IP`地址\n5. `DNS`通常是由其他应用层协议所使用的,将用户提供的主机名解析为`IP`地址\n6. 想获得的`IP`地址通常就缓存在一个附近的`DNS`服务器,有助于减少`DNS`的网络流量和`DNS`的平均时延\n\n## DNS是应用层协议\n\n1. 它使用客户-服务器模式运行在通信的端系统之间\n2. 在通信的端系统之间通过下面的端到端运输协议来传送DNS报文\n\n## 请求URL过程\n\n假设一个用户访问`tongji4m3.club/index.html`\n\n1. 同一台用户主机上运行着`DNS`应用的客户端\n2. 浏览器从上述`URL`中抽取处主机名`tongji4m3.club`,并将该主机名传给DNS客户端\n3. `DNS`客户端会向`DNS`服务器发送一个包含主机名的请求\n4. `DNS`客户端会收到一份回答报文,包含对应主机名的`IP`地址\n5. 浏览器接收该`IP`地址,向该`IP`地址的80端口的`HTTP`服务器进程发送一个`TCP`连接\n\n## DNS其他服务\n\n+ 主机别名,应用程序可以通过主机别名获得对应的规范主机名和`IP`地址\n+ 邮件服务器别名\n+ 负载分配:繁忙的站点被冗余分配在多台服务器上,每台服务器都有不同的IP地址,一个`IP`地址集合因此与同一个规范主机名相联系.当客户对映射到某地址集合的名字发出一个`DNS`请求时,该服务器用`IP`地址的整个集合进行响应,但在每个回答中循环这些地址次序\n\n## DNS工作机理概述\n\n### 分布式,层次数据库\n\n+ 没有一台`DNS`服务器拥有因特网上所有主机的映射,这些映射分布在所有的`DNS`服务器上\n+ 根`DNS`服务器,根名字服务器提供`TLD`服务器的`IP`地址\n+ 顶级域服务器,对应每个顶级域(com,edu,gov等)和所有国家的顶级域(如uk,fr),都有`TLD`服务器\n+ 权威DNS服务器,具有公共可访问主机的每个组织机构都必须提供公共可访问的`DNS`记录,将主机名称映射为`IP`地址\n+ 本地`DNS`服务器.每个`ISP`都有一台本地`DNS`服务器,起着代理的作用\n\n### DNS记录和报文\n\n`DNS`服务器存储了资源记录(RR),提供了主机名到`IP`地址的映射\n\n资源记录:`(Name,Value,Type,TTL)`\n\n+ TTL是该记录的生存时间,决定RR应当从缓存中删除的时间\n+ `Type=A`,则是主机名,IP地址\n+ `Type=NS`,则`Name`是一个域,如`foo.com`,而`Value`是知道如何获得该域中主机`IP`地址的权威`DNS`服务器的主机名,用于沿着查询链来路由`DNS`查询\n+ 如果`Type=CNAME`,则`Value`是别名为`Name`的主机对应的规范主机名\n+ 如果`Type=MX`则`Value`是别名为`Name`的邮件服务器的规范主机名","slug":"计算机网络/02_应用层","published":1,"updated":"2020-11-12T11:57:30.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6z3008jjotpacx2915c","content":"<h1 id=\"应用层协议原理\"><a href=\"#应用层协议原理\" class=\"headerlink\" title=\"应用层协议原理\"></a>应用层协议原理</h1><ul>\n<li>研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序</li>\n</ul>\n<h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><ul>\n<li>在一对进程之间的通信会话场景中,发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为客户,在会话开始时等待联系的进程是服务器</li>\n<li>套接字是同一台主机内应用层和运输层之间的接口。</li>\n<li>由于套接字是建立在网络应用程序的可编程接口，也称为应用程序和网络之间的应用程序编程接口（API）</li>\n<li>开发者对运输层的控制仅限于：1.选择运输层协议 2.设定几个运输层参数，例如最大缓存等</li>\n<li>指定<strong>IP地址，端口号</strong></li>\n</ul>\n<h2 id=\"运输服务选择\"><a href=\"#运输服务选择\" class=\"headerlink\" title=\"运输服务选择\"></a>运输服务选择</h2><h3 id=\"可靠数据传输\"><a href=\"#可靠数据传输\" class=\"headerlink\" title=\"可靠数据传输\"></a>可靠数据传输</h3><p>当一个运输协议提供这样的服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程</p>\n<h3 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h3><p>可用吞吐量就是发送进程能够向接收进程交付比特的速率</p>\n<p>运输层协议能够以某种特定的速率提供确保的可用吞吐量</p>\n<p>具有吞吐量要求的应用程序被称为带宽敏感的应用</p>\n<h3 id=\"定时\"><a href=\"#定时\" class=\"headerlink\" title=\"定时\"></a>定时</h3><p>发送方注入进套接字中的每个比特到达接收方的套接字不迟于<code>100ms</code></p>\n<p>对交互式实时应用程序有用</p>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>运输协议能加密由发送进程传输的所有数据，并且在发送和接收进程之间提供机密性，防止被其他方式观测到，并且在交付给接收进程之前解密数据</p>\n<h3 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3><h4 id=\"面向连接服务\"><a href=\"#面向连接服务\" class=\"headerlink\" title=\"面向连接服务\"></a>面向连接服务</h4><p>在数据报文流动之前，让客户和服务器互相交换运输层控制信息，提醒客户和服务器做好准备。在握手阶段，一个<strong>TCP连接</strong>就在两个进程的套接字之间建立了</p>\n<p>是全双工的，双方可以同时进行报文收发，结束后，必须拆除连接</p>\n<h4 id=\"可靠的数据传送服务\"><a href=\"#可靠的数据传送服务\" class=\"headerlink\" title=\"可靠的数据传送服务\"></a>可靠的数据传送服务</h4><p>可以无差错，按适当顺序交付所有发送的数据，没有字节的丢失和冗余</p>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><ul>\n<li>轻量级运输协议，只提供最小服务、</li>\n<li>无连接的，通信前没有握手过程</li>\n<li>提供不可靠的数据传送服务，并不保证报文到达接收进程，且可能是乱序到达的</li>\n</ul>\n<h2 id=\"应用层协议\"><a href=\"#应用层协议\" class=\"headerlink\" title=\"应用层协议\"></a>应用层协议</h2><ul>\n<li><p>定义了运行在不同端系统上的应用程序如何相互传递报文</p>\n</li>\n<li><p><code>HTTP</code>超文本传输协议</p>\n</li>\n<li><p><code>SMTP</code>简单邮件传输协议</p>\n</li>\n</ul>\n<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>服务器向客户发送被请求的文件,而不存储任何关于该客户的状态信息,无状态协议</p>\n<h2 id=\"持续连接的HTTP\"><a href=\"#持续连接的HTTP\" class=\"headerlink\" title=\"持续连接的HTTP\"></a>持续连接的HTTP</h2><p><code>HTTP 1.1</code>持续连接:服务器在发送响应后保存该<code>TCP</code>连接打开,在相同的客户和服务器之间,后续的请求和响应报文能够通过相同的连接进行传送</p>\n<p>如果一条连接经过一定时间间隔仍未被使用,<code>HTTP</code>服务器就会关闭该连接</p>\n<h2 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h2><p><code>cookie</code>用于标识一个用户.用户首次访问一个站点时,可能需要提供一个用户标识.在后续会话中,浏览器向服务器传递一个<code>cookie</code>首部,从而向该服务器标识了用户.因此<code>cookie</code>可以在无状态的<code>HTTP</code>之上建立一个用户会话层</p>\n<h2 id=\"Web缓存\"><a href=\"#Web缓存\" class=\"headerlink\" title=\"Web缓存\"></a>Web缓存</h2><ul>\n<li>Web缓存器也叫做代理服务器,能够代表初始的<code>Web</code>服务器来满足<code>HTTP</code>请求的网络实体</li>\n<li>它有自己的磁盘存储空间,并在存储空间中保存最近请求过的对象的副本.</li>\n<li>可以配置用户的浏览器,使得用户所有的<code>HTTP</code>请求首先指向<code>Web</code>缓冲器,每个对某对象的浏览器请求首先会把定向到该<code>Web</code>缓冲器</li>\n<li><code>Web</code>缓冲器通常由<code>ISP</code>购买并安装,一所大学可能在他的校园网上安装一台缓冲器,并且将所有校园网上的用户浏览器配置为指向他</li>\n</ul>\n<h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ol>\n<li>浏览器创建一个到<code>Web</code>缓冲器的<code>TCP</code>连接</li>\n<li><code>Web</code>缓冲器进行检查,有副本直接返回</li>\n<li>没有则自己打开一个与该对象的初始服务器的<code>TCP</code>连接</li>\n<li><code>Web</code>缓冲器在本地存储副本,并通过现有的<code>TCP</code>连接返回给浏览器</li>\n</ol>\n<h3 id=\"条件GET方法\"><a href=\"#条件GET方法\" class=\"headerlink\" title=\"条件GET方法\"></a>条件GET方法</h3><p>用于判断缓存是否修改</p>\n<ol>\n<li>代理服务器向Web服务器发送请求,得到对象以及对象的最后修改时间</li>\n<li>一个星期后,另一个用户访问该缓存,缓冲区通过条件<code>GET</code>执行最新检查</li>\n<li>即发送了自己存储的最后修改时间,如果Web服务器发现该对象在指定日期后对该对象修改过,才重新发送该对象,否则只会发送空对象</li>\n<li>即<code>304 Not Modified</code>,告诉缓冲器,可以使用该对象</li>\n</ol>\n<h1 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h1><p>域名系统,能进行主机名到<code>IP</code>地址转换的目录服务</p>\n<ol>\n<li>一个由分层的<code>DNS</code>服务器实现的分布式数据库</li>\n<li>一个使得主机能够查询分布式数据库的应用层协议</li>\n<li><code>DNS</code>运行在<code>UDP</code>上,端口号为53</li>\n<li><code>DNS</code>是为因特网上的用户应用程序以及其他软件提供一种核心功能,即将主机名转换为其背后的<code>IP</code>地址</li>\n<li><code>DNS</code>通常是由其他应用层协议所使用的,将用户提供的主机名解析为<code>IP</code>地址</li>\n<li>想获得的<code>IP</code>地址通常就缓存在一个附近的<code>DNS</code>服务器,有助于减少<code>DNS</code>的网络流量和<code>DNS</code>的平均时延</li>\n</ol>\n<h2 id=\"DNS是应用层协议\"><a href=\"#DNS是应用层协议\" class=\"headerlink\" title=\"DNS是应用层协议\"></a>DNS是应用层协议</h2><ol>\n<li>它使用客户-服务器模式运行在通信的端系统之间</li>\n<li>在通信的端系统之间通过下面的端到端运输协议来传送DNS报文</li>\n</ol>\n<h2 id=\"请求URL过程\"><a href=\"#请求URL过程\" class=\"headerlink\" title=\"请求URL过程\"></a>请求URL过程</h2><p>假设一个用户访问<code>tongji4m3.club/index.html</code></p>\n<ol>\n<li>同一台用户主机上运行着<code>DNS</code>应用的客户端</li>\n<li>浏览器从上述<code>URL</code>中抽取处主机名<code>tongji4m3.club</code>,并将该主机名传给DNS客户端</li>\n<li><code>DNS</code>客户端会向<code>DNS</code>服务器发送一个包含主机名的请求</li>\n<li><code>DNS</code>客户端会收到一份回答报文,包含对应主机名的<code>IP</code>地址</li>\n<li>浏览器接收该<code>IP</code>地址,向该<code>IP</code>地址的80端口的<code>HTTP</code>服务器进程发送一个<code>TCP</code>连接</li>\n</ol>\n<h2 id=\"DNS其他服务\"><a href=\"#DNS其他服务\" class=\"headerlink\" title=\"DNS其他服务\"></a>DNS其他服务</h2><ul>\n<li>主机别名,应用程序可以通过主机别名获得对应的规范主机名和<code>IP</code>地址</li>\n<li>邮件服务器别名</li>\n<li>负载分配:繁忙的站点被冗余分配在多台服务器上,每台服务器都有不同的IP地址,一个<code>IP</code>地址集合因此与同一个规范主机名相联系.当客户对映射到某地址集合的名字发出一个<code>DNS</code>请求时,该服务器用<code>IP</code>地址的整个集合进行响应,但在每个回答中循环这些地址次序</li>\n</ul>\n<h2 id=\"DNS工作机理概述\"><a href=\"#DNS工作机理概述\" class=\"headerlink\" title=\"DNS工作机理概述\"></a>DNS工作机理概述</h2><h3 id=\"分布式-层次数据库\"><a href=\"#分布式-层次数据库\" class=\"headerlink\" title=\"分布式,层次数据库\"></a>分布式,层次数据库</h3><ul>\n<li>没有一台<code>DNS</code>服务器拥有因特网上所有主机的映射,这些映射分布在所有的<code>DNS</code>服务器上</li>\n<li>根<code>DNS</code>服务器,根名字服务器提供<code>TLD</code>服务器的<code>IP</code>地址</li>\n<li>顶级域服务器,对应每个顶级域(com,edu,gov等)和所有国家的顶级域(如uk,fr),都有<code>TLD</code>服务器</li>\n<li>权威DNS服务器,具有公共可访问主机的每个组织机构都必须提供公共可访问的<code>DNS</code>记录,将主机名称映射为<code>IP</code>地址</li>\n<li>本地<code>DNS</code>服务器.每个<code>ISP</code>都有一台本地<code>DNS</code>服务器,起着代理的作用</li>\n</ul>\n<h3 id=\"DNS记录和报文\"><a href=\"#DNS记录和报文\" class=\"headerlink\" title=\"DNS记录和报文\"></a>DNS记录和报文</h3><p><code>DNS</code>服务器存储了资源记录(RR),提供了主机名到<code>IP</code>地址的映射</p>\n<p>资源记录:<code>(Name,Value,Type,TTL)</code></p>\n<ul>\n<li>TTL是该记录的生存时间,决定RR应当从缓存中删除的时间</li>\n<li><code>Type=A</code>,则是主机名,IP地址</li>\n<li><code>Type=NS</code>,则<code>Name</code>是一个域,如<code>foo.com</code>,而<code>Value</code>是知道如何获得该域中主机<code>IP</code>地址的权威<code>DNS</code>服务器的主机名,用于沿着查询链来路由<code>DNS</code>查询</li>\n<li>如果<code>Type=CNAME</code>,则<code>Value</code>是别名为<code>Name</code>的主机对应的规范主机名</li>\n<li>如果<code>Type=MX</code>则<code>Value</code>是别名为<code>Name</code>的邮件服务器的规范主机名</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"应用层协议原理\"><a href=\"#应用层协议原理\" class=\"headerlink\" title=\"应用层协议原理\"></a>应用层协议原理</h1><ul>\n<li>研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序</li>\n</ul>\n<h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><ul>\n<li>在一对进程之间的通信会话场景中,发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为客户,在会话开始时等待联系的进程是服务器</li>\n<li>套接字是同一台主机内应用层和运输层之间的接口。</li>\n<li>由于套接字是建立在网络应用程序的可编程接口，也称为应用程序和网络之间的应用程序编程接口（API）</li>\n<li>开发者对运输层的控制仅限于：1.选择运输层协议 2.设定几个运输层参数，例如最大缓存等</li>\n<li>指定<strong>IP地址，端口号</strong></li>\n</ul>\n<h2 id=\"运输服务选择\"><a href=\"#运输服务选择\" class=\"headerlink\" title=\"运输服务选择\"></a>运输服务选择</h2><h3 id=\"可靠数据传输\"><a href=\"#可靠数据传输\" class=\"headerlink\" title=\"可靠数据传输\"></a>可靠数据传输</h3><p>当一个运输协议提供这样的服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程</p>\n<h3 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h3><p>可用吞吐量就是发送进程能够向接收进程交付比特的速率</p>\n<p>运输层协议能够以某种特定的速率提供确保的可用吞吐量</p>\n<p>具有吞吐量要求的应用程序被称为带宽敏感的应用</p>\n<h3 id=\"定时\"><a href=\"#定时\" class=\"headerlink\" title=\"定时\"></a>定时</h3><p>发送方注入进套接字中的每个比特到达接收方的套接字不迟于<code>100ms</code></p>\n<p>对交互式实时应用程序有用</p>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>运输协议能加密由发送进程传输的所有数据，并且在发送和接收进程之间提供机密性，防止被其他方式观测到，并且在交付给接收进程之前解密数据</p>\n<h3 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3><h4 id=\"面向连接服务\"><a href=\"#面向连接服务\" class=\"headerlink\" title=\"面向连接服务\"></a>面向连接服务</h4><p>在数据报文流动之前，让客户和服务器互相交换运输层控制信息，提醒客户和服务器做好准备。在握手阶段，一个<strong>TCP连接</strong>就在两个进程的套接字之间建立了</p>\n<p>是全双工的，双方可以同时进行报文收发，结束后，必须拆除连接</p>\n<h4 id=\"可靠的数据传送服务\"><a href=\"#可靠的数据传送服务\" class=\"headerlink\" title=\"可靠的数据传送服务\"></a>可靠的数据传送服务</h4><p>可以无差错，按适当顺序交付所有发送的数据，没有字节的丢失和冗余</p>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><ul>\n<li>轻量级运输协议，只提供最小服务、</li>\n<li>无连接的，通信前没有握手过程</li>\n<li>提供不可靠的数据传送服务，并不保证报文到达接收进程，且可能是乱序到达的</li>\n</ul>\n<h2 id=\"应用层协议\"><a href=\"#应用层协议\" class=\"headerlink\" title=\"应用层协议\"></a>应用层协议</h2><ul>\n<li><p>定义了运行在不同端系统上的应用程序如何相互传递报文</p>\n</li>\n<li><p><code>HTTP</code>超文本传输协议</p>\n</li>\n<li><p><code>SMTP</code>简单邮件传输协议</p>\n</li>\n</ul>\n<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>服务器向客户发送被请求的文件,而不存储任何关于该客户的状态信息,无状态协议</p>\n<h2 id=\"持续连接的HTTP\"><a href=\"#持续连接的HTTP\" class=\"headerlink\" title=\"持续连接的HTTP\"></a>持续连接的HTTP</h2><p><code>HTTP 1.1</code>持续连接:服务器在发送响应后保存该<code>TCP</code>连接打开,在相同的客户和服务器之间,后续的请求和响应报文能够通过相同的连接进行传送</p>\n<p>如果一条连接经过一定时间间隔仍未被使用,<code>HTTP</code>服务器就会关闭该连接</p>\n<h2 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h2><p><code>cookie</code>用于标识一个用户.用户首次访问一个站点时,可能需要提供一个用户标识.在后续会话中,浏览器向服务器传递一个<code>cookie</code>首部,从而向该服务器标识了用户.因此<code>cookie</code>可以在无状态的<code>HTTP</code>之上建立一个用户会话层</p>\n<h2 id=\"Web缓存\"><a href=\"#Web缓存\" class=\"headerlink\" title=\"Web缓存\"></a>Web缓存</h2><ul>\n<li>Web缓存器也叫做代理服务器,能够代表初始的<code>Web</code>服务器来满足<code>HTTP</code>请求的网络实体</li>\n<li>它有自己的磁盘存储空间,并在存储空间中保存最近请求过的对象的副本.</li>\n<li>可以配置用户的浏览器,使得用户所有的<code>HTTP</code>请求首先指向<code>Web</code>缓冲器,每个对某对象的浏览器请求首先会把定向到该<code>Web</code>缓冲器</li>\n<li><code>Web</code>缓冲器通常由<code>ISP</code>购买并安装,一所大学可能在他的校园网上安装一台缓冲器,并且将所有校园网上的用户浏览器配置为指向他</li>\n</ul>\n<h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ol>\n<li>浏览器创建一个到<code>Web</code>缓冲器的<code>TCP</code>连接</li>\n<li><code>Web</code>缓冲器进行检查,有副本直接返回</li>\n<li>没有则自己打开一个与该对象的初始服务器的<code>TCP</code>连接</li>\n<li><code>Web</code>缓冲器在本地存储副本,并通过现有的<code>TCP</code>连接返回给浏览器</li>\n</ol>\n<h3 id=\"条件GET方法\"><a href=\"#条件GET方法\" class=\"headerlink\" title=\"条件GET方法\"></a>条件GET方法</h3><p>用于判断缓存是否修改</p>\n<ol>\n<li>代理服务器向Web服务器发送请求,得到对象以及对象的最后修改时间</li>\n<li>一个星期后,另一个用户访问该缓存,缓冲区通过条件<code>GET</code>执行最新检查</li>\n<li>即发送了自己存储的最后修改时间,如果Web服务器发现该对象在指定日期后对该对象修改过,才重新发送该对象,否则只会发送空对象</li>\n<li>即<code>304 Not Modified</code>,告诉缓冲器,可以使用该对象</li>\n</ol>\n<h1 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h1><p>域名系统,能进行主机名到<code>IP</code>地址转换的目录服务</p>\n<ol>\n<li>一个由分层的<code>DNS</code>服务器实现的分布式数据库</li>\n<li>一个使得主机能够查询分布式数据库的应用层协议</li>\n<li><code>DNS</code>运行在<code>UDP</code>上,端口号为53</li>\n<li><code>DNS</code>是为因特网上的用户应用程序以及其他软件提供一种核心功能,即将主机名转换为其背后的<code>IP</code>地址</li>\n<li><code>DNS</code>通常是由其他应用层协议所使用的,将用户提供的主机名解析为<code>IP</code>地址</li>\n<li>想获得的<code>IP</code>地址通常就缓存在一个附近的<code>DNS</code>服务器,有助于减少<code>DNS</code>的网络流量和<code>DNS</code>的平均时延</li>\n</ol>\n<h2 id=\"DNS是应用层协议\"><a href=\"#DNS是应用层协议\" class=\"headerlink\" title=\"DNS是应用层协议\"></a>DNS是应用层协议</h2><ol>\n<li>它使用客户-服务器模式运行在通信的端系统之间</li>\n<li>在通信的端系统之间通过下面的端到端运输协议来传送DNS报文</li>\n</ol>\n<h2 id=\"请求URL过程\"><a href=\"#请求URL过程\" class=\"headerlink\" title=\"请求URL过程\"></a>请求URL过程</h2><p>假设一个用户访问<code>tongji4m3.club/index.html</code></p>\n<ol>\n<li>同一台用户主机上运行着<code>DNS</code>应用的客户端</li>\n<li>浏览器从上述<code>URL</code>中抽取处主机名<code>tongji4m3.club</code>,并将该主机名传给DNS客户端</li>\n<li><code>DNS</code>客户端会向<code>DNS</code>服务器发送一个包含主机名的请求</li>\n<li><code>DNS</code>客户端会收到一份回答报文,包含对应主机名的<code>IP</code>地址</li>\n<li>浏览器接收该<code>IP</code>地址,向该<code>IP</code>地址的80端口的<code>HTTP</code>服务器进程发送一个<code>TCP</code>连接</li>\n</ol>\n<h2 id=\"DNS其他服务\"><a href=\"#DNS其他服务\" class=\"headerlink\" title=\"DNS其他服务\"></a>DNS其他服务</h2><ul>\n<li>主机别名,应用程序可以通过主机别名获得对应的规范主机名和<code>IP</code>地址</li>\n<li>邮件服务器别名</li>\n<li>负载分配:繁忙的站点被冗余分配在多台服务器上,每台服务器都有不同的IP地址,一个<code>IP</code>地址集合因此与同一个规范主机名相联系.当客户对映射到某地址集合的名字发出一个<code>DNS</code>请求时,该服务器用<code>IP</code>地址的整个集合进行响应,但在每个回答中循环这些地址次序</li>\n</ul>\n<h2 id=\"DNS工作机理概述\"><a href=\"#DNS工作机理概述\" class=\"headerlink\" title=\"DNS工作机理概述\"></a>DNS工作机理概述</h2><h3 id=\"分布式-层次数据库\"><a href=\"#分布式-层次数据库\" class=\"headerlink\" title=\"分布式,层次数据库\"></a>分布式,层次数据库</h3><ul>\n<li>没有一台<code>DNS</code>服务器拥有因特网上所有主机的映射,这些映射分布在所有的<code>DNS</code>服务器上</li>\n<li>根<code>DNS</code>服务器,根名字服务器提供<code>TLD</code>服务器的<code>IP</code>地址</li>\n<li>顶级域服务器,对应每个顶级域(com,edu,gov等)和所有国家的顶级域(如uk,fr),都有<code>TLD</code>服务器</li>\n<li>权威DNS服务器,具有公共可访问主机的每个组织机构都必须提供公共可访问的<code>DNS</code>记录,将主机名称映射为<code>IP</code>地址</li>\n<li>本地<code>DNS</code>服务器.每个<code>ISP</code>都有一台本地<code>DNS</code>服务器,起着代理的作用</li>\n</ul>\n<h3 id=\"DNS记录和报文\"><a href=\"#DNS记录和报文\" class=\"headerlink\" title=\"DNS记录和报文\"></a>DNS记录和报文</h3><p><code>DNS</code>服务器存储了资源记录(RR),提供了主机名到<code>IP</code>地址的映射</p>\n<p>资源记录:<code>(Name,Value,Type,TTL)</code></p>\n<ul>\n<li>TTL是该记录的生存时间,决定RR应当从缓存中删除的时间</li>\n<li><code>Type=A</code>,则是主机名,IP地址</li>\n<li><code>Type=NS</code>,则<code>Name</code>是一个域,如<code>foo.com</code>,而<code>Value</code>是知道如何获得该域中主机<code>IP</code>地址的权威<code>DNS</code>服务器的主机名,用于沿着查询链来路由<code>DNS</code>查询</li>\n<li>如果<code>Type=CNAME</code>,则<code>Value</code>是别名为<code>Name</code>的主机对应的规范主机名</li>\n<li>如果<code>Type=MX</code>则<code>Value</code>是别名为<code>Name</code>的邮件服务器的规范主机名</li>\n</ul>\n"},{"title":"项目------Web项目-简单的购物网站","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":false,"mathjax":false,"summary":"Web项目-简单的购物网站文档。一个简单的前后端项目，其中前端只用了HTML，Css，JS","abbrlink":"a8f59b26","date":"2020-05-11T16:00:00.000Z","_content":"# 项目简介\n\n本项目是基于BS架构的简单购物网站。主要实现了用户注册登录，商品展示，添加购物车，结算下单，查询历史订单信息五个功能。前后端分为两个项目，都采用了IDEA进行开发。其中前端使用了HTML，CSS，JavaScript技术，并且使用原生ajax向后端发起请求。后端则使用maven管理依赖，使用springboot框架，并且整合了mybatis框架以连接MySQL数据库。并且该项目前后端分离，且严格分离html，css和js。其中，整个项目部署在了云服务器上，访问地址为：\n\n<http://47.103.203.188:8080/project/html/index.html>\n\n源码可在Github上查看:[tongji4m3](https://github.com/tongji4m3/webProject)\n\n# 项目技术架构介绍\n\n## 前端\n\n>   前端项目一共有4个文件夹，分别存储了`html`，`css`，`js`，`img`文件。其中每一个html文件都会引用css，js文件夹中与之对应的文件，并且在主页以及商品详情中引用img文件夹里的相应图片。\n\n>   每个商品的商品详情则是放在了html/productDetails中。图片则根据商品名称放在不同的文件夹下。而ajax请求的路径，则统一放置在了js/api.js文件中。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/615544abc332617d714709043dbca86c.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/04fdb77cca62acf21e33e753bc975cdc.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/083899cb9561ac40e8dafeac0b44459e.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e7508c123b5b86102d8d41dc5d5cc9c7.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/fa09cc6d1dbc52e50f4a16820a79e526.png)\n\n## 数据库\n\n>   共分为四个表，user表存储用户信息，product表存储商品信息，shoppingCart存储购物车信息并且关联了user表和product表，myOrder存储订单信息并且关联了user表和product表。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2e26a50a7b8e4736fb2340349809f374.png)\n\n## 后端\n\n>   后端使用三层架构的模式，controller包为界面层，负责从前端获取json数据，并且调用业务逻辑层获取相关的数据封装成json格式并且返回给前端。而service包下为业务逻辑层，主要负责进行一些业务处理，并且调用数据访问层得到数据并返回给界面层。mapper包下负责查询数据库，获取相关信息，并且将一些信息封装成实体类并且返回给业务逻辑层。domain包下则是一个个实体类。\n\n>   controller包下主要有三个类，分别负责对用户登录注册等功能的处理的UserController类，对购物车和订单操作的处理的OperatorController类，以及返回验证码的CheckCodeController类。\n\n>   service包下基本就是对应于controller包下三个类的对应接口和实行类。mapper包下就是对应于controller包下三个类的接口，他们的具体逻辑实现通过xml配置文件实现。\n\n>   domain包下分别有用户，商品，购物车，订单的实体类，并且还有一个封装了要返回信息的ResultInformation类。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e6fa4af191f391f3aa29ad41014470d3.png)\n\n#  项目功能介绍\n\n## 首页\n\n>   首页主要实现了一个首页导航栏以及商品简略信息的查看功能，导航栏能跳转到登录，注册，购物车，订单页面中。并且实现了对登录者用户名的存储，展示以及注销功能。商品简略信息则有一些动态效果，并且点击能跳转到相应的商品详情页面。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/803e7752c2cb01a3b406c7cc2284f798.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2ae59d5f365c24d7d4ef356712e4c3e0.png)\n\n## 用户注册登录\n\n>   登录于注册功能都有对表单的校验功能，并且注册功能还有验证码功能，点击可以动态刷新，但是由于跨域session存储不了的问题，后端没有去校验验证码。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f6cf9544375e71bab20397f08978c4bd.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f88237bd17dc0dbee7b23d8c7e8b89b7.png)\n\n## 商品详情页面\n\n>   每个商品的商品详情中，有一个导航栏，有一个定时切换商品不同图片的轮播图，以及商品详情的文字描述，以及加入购物车和立即购买按钮，两个按钮都会判断是否登录而采取不同动作。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/0dcbe38556203a7b32055ca2e384ecc9.png)\n\n## 添加购物车\n\n>   在商品详情点击添加购物车后，如果未登录，将跳转到登录界面，否则将之加入购物车，并且前往购物车界面，购物车页面会展示已经加入购物车的商品，并且可以选择购买或者删除该商品。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/40a0aab6c095373eaddc834c12ca7036.png)\n\n## 结算下单\n\n当在商品详情选择立即购买，或者在购物车点击购买时，将跳转到购买界面，显示要购买的商品，以及购买人的信息。点击购买，则模拟购买成功，并且跳转到历史订单界面。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/debe58129dc0bfdc1597629e0945ce7d.png)\n\n## 历史订单查询\n\n登录状态才能进入历史订单页面，进入后将展示购买过的商品，并且可以删除订单。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/57c5639f4db15bda5e7cb79bcc7db8bf.png)\n","source":"_posts/项目笔记/Web项目-简单的购物网站.md","raw":"---\ntitle: 项目------Web项目-简单的购物网站\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: false\nmathjax: false\nsummary: Web项目-简单的购物网站文档。一个简单的前后端项目，其中前端只用了HTML，Css，JS\ncategories: 项目文档\ntags:\n  - HTML\n  - JavaScript\n  - Springboot\nabbrlink: a8f59b26\ndate: 2020-05-12 00:00:00\n---\n# 项目简介\n\n本项目是基于BS架构的简单购物网站。主要实现了用户注册登录，商品展示，添加购物车，结算下单，查询历史订单信息五个功能。前后端分为两个项目，都采用了IDEA进行开发。其中前端使用了HTML，CSS，JavaScript技术，并且使用原生ajax向后端发起请求。后端则使用maven管理依赖，使用springboot框架，并且整合了mybatis框架以连接MySQL数据库。并且该项目前后端分离，且严格分离html，css和js。其中，整个项目部署在了云服务器上，访问地址为：\n\n<http://47.103.203.188:8080/project/html/index.html>\n\n源码可在Github上查看:[tongji4m3](https://github.com/tongji4m3/webProject)\n\n# 项目技术架构介绍\n\n## 前端\n\n>   前端项目一共有4个文件夹，分别存储了`html`，`css`，`js`，`img`文件。其中每一个html文件都会引用css，js文件夹中与之对应的文件，并且在主页以及商品详情中引用img文件夹里的相应图片。\n\n>   每个商品的商品详情则是放在了html/productDetails中。图片则根据商品名称放在不同的文件夹下。而ajax请求的路径，则统一放置在了js/api.js文件中。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/615544abc332617d714709043dbca86c.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/04fdb77cca62acf21e33e753bc975cdc.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/083899cb9561ac40e8dafeac0b44459e.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e7508c123b5b86102d8d41dc5d5cc9c7.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/fa09cc6d1dbc52e50f4a16820a79e526.png)\n\n## 数据库\n\n>   共分为四个表，user表存储用户信息，product表存储商品信息，shoppingCart存储购物车信息并且关联了user表和product表，myOrder存储订单信息并且关联了user表和product表。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2e26a50a7b8e4736fb2340349809f374.png)\n\n## 后端\n\n>   后端使用三层架构的模式，controller包为界面层，负责从前端获取json数据，并且调用业务逻辑层获取相关的数据封装成json格式并且返回给前端。而service包下为业务逻辑层，主要负责进行一些业务处理，并且调用数据访问层得到数据并返回给界面层。mapper包下负责查询数据库，获取相关信息，并且将一些信息封装成实体类并且返回给业务逻辑层。domain包下则是一个个实体类。\n\n>   controller包下主要有三个类，分别负责对用户登录注册等功能的处理的UserController类，对购物车和订单操作的处理的OperatorController类，以及返回验证码的CheckCodeController类。\n\n>   service包下基本就是对应于controller包下三个类的对应接口和实行类。mapper包下就是对应于controller包下三个类的接口，他们的具体逻辑实现通过xml配置文件实现。\n\n>   domain包下分别有用户，商品，购物车，订单的实体类，并且还有一个封装了要返回信息的ResultInformation类。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e6fa4af191f391f3aa29ad41014470d3.png)\n\n#  项目功能介绍\n\n## 首页\n\n>   首页主要实现了一个首页导航栏以及商品简略信息的查看功能，导航栏能跳转到登录，注册，购物车，订单页面中。并且实现了对登录者用户名的存储，展示以及注销功能。商品简略信息则有一些动态效果，并且点击能跳转到相应的商品详情页面。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/803e7752c2cb01a3b406c7cc2284f798.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2ae59d5f365c24d7d4ef356712e4c3e0.png)\n\n## 用户注册登录\n\n>   登录于注册功能都有对表单的校验功能，并且注册功能还有验证码功能，点击可以动态刷新，但是由于跨域session存储不了的问题，后端没有去校验验证码。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f6cf9544375e71bab20397f08978c4bd.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f88237bd17dc0dbee7b23d8c7e8b89b7.png)\n\n## 商品详情页面\n\n>   每个商品的商品详情中，有一个导航栏，有一个定时切换商品不同图片的轮播图，以及商品详情的文字描述，以及加入购物车和立即购买按钮，两个按钮都会判断是否登录而采取不同动作。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/0dcbe38556203a7b32055ca2e384ecc9.png)\n\n## 添加购物车\n\n>   在商品详情点击添加购物车后，如果未登录，将跳转到登录界面，否则将之加入购物车，并且前往购物车界面，购物车页面会展示已经加入购物车的商品，并且可以选择购买或者删除该商品。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/40a0aab6c095373eaddc834c12ca7036.png)\n\n## 结算下单\n\n当在商品详情选择立即购买，或者在购物车点击购买时，将跳转到购买界面，显示要购买的商品，以及购买人的信息。点击购买，则模拟购买成功，并且跳转到历史订单界面。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/debe58129dc0bfdc1597629e0945ce7d.png)\n\n## 历史订单查询\n\n登录状态才能进入历史订单页面，进入后将展示购买过的商品，并且可以删除订单。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/57c5639f4db15bda5e7cb79bcc7db8bf.png)\n","slug":"项目笔记/Web项目-简单的购物网站","published":1,"updated":"2021-02-04T00:35:26.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6z4008mjotp95uvfxkh","content":"<h1 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h1><p>本项目是基于BS架构的简单购物网站。主要实现了用户注册登录，商品展示，添加购物车，结算下单，查询历史订单信息五个功能。前后端分为两个项目，都采用了IDEA进行开发。其中前端使用了HTML，CSS，JavaScript技术，并且使用原生ajax向后端发起请求。后端则使用maven管理依赖，使用springboot框架，并且整合了mybatis框架以连接MySQL数据库。并且该项目前后端分离，且严格分离html，css和js。其中，整个项目部署在了云服务器上，访问地址为：</p>\n<p><a href=\"http://47.103.203.188:8080/project/html/index.html\" target=\"_blank\" rel=\"noopener\">http://47.103.203.188:8080/project/html/index.html</a></p>\n<p>源码可在Github上查看:<a href=\"https://github.com/tongji4m3/webProject\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n<h1 id=\"项目技术架构介绍\"><a href=\"#项目技术架构介绍\" class=\"headerlink\" title=\"项目技术架构介绍\"></a>项目技术架构介绍</h1><h2 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h2><blockquote>\n<p>  前端项目一共有4个文件夹，分别存储了<code>html</code>，<code>css</code>，<code>js</code>，<code>img</code>文件。其中每一个html文件都会引用css，js文件夹中与之对应的文件，并且在主页以及商品详情中引用img文件夹里的相应图片。</p>\n</blockquote>\n<blockquote>\n<p>  每个商品的商品详情则是放在了html/productDetails中。图片则根据商品名称放在不同的文件夹下。而ajax请求的路径，则统一放置在了js/api.js文件中。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/615544abc332617d714709043dbca86c.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/04fdb77cca62acf21e33e753bc975cdc.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/083899cb9561ac40e8dafeac0b44459e.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e7508c123b5b86102d8d41dc5d5cc9c7.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/fa09cc6d1dbc52e50f4a16820a79e526.png\"></p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><blockquote>\n<p>  共分为四个表，user表存储用户信息，product表存储商品信息，shoppingCart存储购物车信息并且关联了user表和product表，myOrder存储订单信息并且关联了user表和product表。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2e26a50a7b8e4736fb2340349809f374.png\"></p>\n<h2 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h2><blockquote>\n<p>  后端使用三层架构的模式，controller包为界面层，负责从前端获取json数据，并且调用业务逻辑层获取相关的数据封装成json格式并且返回给前端。而service包下为业务逻辑层，主要负责进行一些业务处理，并且调用数据访问层得到数据并返回给界面层。mapper包下负责查询数据库，获取相关信息，并且将一些信息封装成实体类并且返回给业务逻辑层。domain包下则是一个个实体类。</p>\n</blockquote>\n<blockquote>\n<p>  controller包下主要有三个类，分别负责对用户登录注册等功能的处理的UserController类，对购物车和订单操作的处理的OperatorController类，以及返回验证码的CheckCodeController类。</p>\n</blockquote>\n<blockquote>\n<p>  service包下基本就是对应于controller包下三个类的对应接口和实行类。mapper包下就是对应于controller包下三个类的接口，他们的具体逻辑实现通过xml配置文件实现。</p>\n</blockquote>\n<blockquote>\n<p>  domain包下分别有用户，商品，购物车，订单的实体类，并且还有一个封装了要返回信息的ResultInformation类。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e6fa4af191f391f3aa29ad41014470d3.png\"></p>\n<h1 id=\"项目功能介绍\"><a href=\"#项目功能介绍\" class=\"headerlink\" title=\"项目功能介绍\"></a>项目功能介绍</h1><h2 id=\"首页\"><a href=\"#首页\" class=\"headerlink\" title=\"首页\"></a>首页</h2><blockquote>\n<p>  首页主要实现了一个首页导航栏以及商品简略信息的查看功能，导航栏能跳转到登录，注册，购物车，订单页面中。并且实现了对登录者用户名的存储，展示以及注销功能。商品简略信息则有一些动态效果，并且点击能跳转到相应的商品详情页面。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/803e7752c2cb01a3b406c7cc2284f798.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2ae59d5f365c24d7d4ef356712e4c3e0.png\"></p>\n<h2 id=\"用户注册登录\"><a href=\"#用户注册登录\" class=\"headerlink\" title=\"用户注册登录\"></a>用户注册登录</h2><blockquote>\n<p>  登录于注册功能都有对表单的校验功能，并且注册功能还有验证码功能，点击可以动态刷新，但是由于跨域session存储不了的问题，后端没有去校验验证码。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f6cf9544375e71bab20397f08978c4bd.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f88237bd17dc0dbee7b23d8c7e8b89b7.png\"></p>\n<h2 id=\"商品详情页面\"><a href=\"#商品详情页面\" class=\"headerlink\" title=\"商品详情页面\"></a>商品详情页面</h2><blockquote>\n<p>  每个商品的商品详情中，有一个导航栏，有一个定时切换商品不同图片的轮播图，以及商品详情的文字描述，以及加入购物车和立即购买按钮，两个按钮都会判断是否登录而采取不同动作。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/0dcbe38556203a7b32055ca2e384ecc9.png\"></p>\n<h2 id=\"添加购物车\"><a href=\"#添加购物车\" class=\"headerlink\" title=\"添加购物车\"></a>添加购物车</h2><blockquote>\n<p>  在商品详情点击添加购物车后，如果未登录，将跳转到登录界面，否则将之加入购物车，并且前往购物车界面，购物车页面会展示已经加入购物车的商品，并且可以选择购买或者删除该商品。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/40a0aab6c095373eaddc834c12ca7036.png\"></p>\n<h2 id=\"结算下单\"><a href=\"#结算下单\" class=\"headerlink\" title=\"结算下单\"></a>结算下单</h2><p>当在商品详情选择立即购买，或者在购物车点击购买时，将跳转到购买界面，显示要购买的商品，以及购买人的信息。点击购买，则模拟购买成功，并且跳转到历史订单界面。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/debe58129dc0bfdc1597629e0945ce7d.png\"></p>\n<h2 id=\"历史订单查询\"><a href=\"#历史订单查询\" class=\"headerlink\" title=\"历史订单查询\"></a>历史订单查询</h2><p>登录状态才能进入历史订单页面，进入后将展示购买过的商品，并且可以删除订单。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/57c5639f4db15bda5e7cb79bcc7db8bf.png\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h1><p>本项目是基于BS架构的简单购物网站。主要实现了用户注册登录，商品展示，添加购物车，结算下单，查询历史订单信息五个功能。前后端分为两个项目，都采用了IDEA进行开发。其中前端使用了HTML，CSS，JavaScript技术，并且使用原生ajax向后端发起请求。后端则使用maven管理依赖，使用springboot框架，并且整合了mybatis框架以连接MySQL数据库。并且该项目前后端分离，且严格分离html，css和js。其中，整个项目部署在了云服务器上，访问地址为：</p>\n<p><a href=\"http://47.103.203.188:8080/project/html/index.html\" target=\"_blank\" rel=\"noopener\">http://47.103.203.188:8080/project/html/index.html</a></p>\n<p>源码可在Github上查看:<a href=\"https://github.com/tongji4m3/webProject\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n<h1 id=\"项目技术架构介绍\"><a href=\"#项目技术架构介绍\" class=\"headerlink\" title=\"项目技术架构介绍\"></a>项目技术架构介绍</h1><h2 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h2><blockquote>\n<p>  前端项目一共有4个文件夹，分别存储了<code>html</code>，<code>css</code>，<code>js</code>，<code>img</code>文件。其中每一个html文件都会引用css，js文件夹中与之对应的文件，并且在主页以及商品详情中引用img文件夹里的相应图片。</p>\n</blockquote>\n<blockquote>\n<p>  每个商品的商品详情则是放在了html/productDetails中。图片则根据商品名称放在不同的文件夹下。而ajax请求的路径，则统一放置在了js/api.js文件中。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/615544abc332617d714709043dbca86c.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/04fdb77cca62acf21e33e753bc975cdc.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/083899cb9561ac40e8dafeac0b44459e.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e7508c123b5b86102d8d41dc5d5cc9c7.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/fa09cc6d1dbc52e50f4a16820a79e526.png\"></p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><blockquote>\n<p>  共分为四个表，user表存储用户信息，product表存储商品信息，shoppingCart存储购物车信息并且关联了user表和product表，myOrder存储订单信息并且关联了user表和product表。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2e26a50a7b8e4736fb2340349809f374.png\"></p>\n<h2 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h2><blockquote>\n<p>  后端使用三层架构的模式，controller包为界面层，负责从前端获取json数据，并且调用业务逻辑层获取相关的数据封装成json格式并且返回给前端。而service包下为业务逻辑层，主要负责进行一些业务处理，并且调用数据访问层得到数据并返回给界面层。mapper包下负责查询数据库，获取相关信息，并且将一些信息封装成实体类并且返回给业务逻辑层。domain包下则是一个个实体类。</p>\n</blockquote>\n<blockquote>\n<p>  controller包下主要有三个类，分别负责对用户登录注册等功能的处理的UserController类，对购物车和订单操作的处理的OperatorController类，以及返回验证码的CheckCodeController类。</p>\n</blockquote>\n<blockquote>\n<p>  service包下基本就是对应于controller包下三个类的对应接口和实行类。mapper包下就是对应于controller包下三个类的接口，他们的具体逻辑实现通过xml配置文件实现。</p>\n</blockquote>\n<blockquote>\n<p>  domain包下分别有用户，商品，购物车，订单的实体类，并且还有一个封装了要返回信息的ResultInformation类。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e6fa4af191f391f3aa29ad41014470d3.png\"></p>\n<h1 id=\"项目功能介绍\"><a href=\"#项目功能介绍\" class=\"headerlink\" title=\"项目功能介绍\"></a>项目功能介绍</h1><h2 id=\"首页\"><a href=\"#首页\" class=\"headerlink\" title=\"首页\"></a>首页</h2><blockquote>\n<p>  首页主要实现了一个首页导航栏以及商品简略信息的查看功能，导航栏能跳转到登录，注册，购物车，订单页面中。并且实现了对登录者用户名的存储，展示以及注销功能。商品简略信息则有一些动态效果，并且点击能跳转到相应的商品详情页面。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/803e7752c2cb01a3b406c7cc2284f798.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2ae59d5f365c24d7d4ef356712e4c3e0.png\"></p>\n<h2 id=\"用户注册登录\"><a href=\"#用户注册登录\" class=\"headerlink\" title=\"用户注册登录\"></a>用户注册登录</h2><blockquote>\n<p>  登录于注册功能都有对表单的校验功能，并且注册功能还有验证码功能，点击可以动态刷新，但是由于跨域session存储不了的问题，后端没有去校验验证码。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f6cf9544375e71bab20397f08978c4bd.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f88237bd17dc0dbee7b23d8c7e8b89b7.png\"></p>\n<h2 id=\"商品详情页面\"><a href=\"#商品详情页面\" class=\"headerlink\" title=\"商品详情页面\"></a>商品详情页面</h2><blockquote>\n<p>  每个商品的商品详情中，有一个导航栏，有一个定时切换商品不同图片的轮播图，以及商品详情的文字描述，以及加入购物车和立即购买按钮，两个按钮都会判断是否登录而采取不同动作。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/0dcbe38556203a7b32055ca2e384ecc9.png\"></p>\n<h2 id=\"添加购物车\"><a href=\"#添加购物车\" class=\"headerlink\" title=\"添加购物车\"></a>添加购物车</h2><blockquote>\n<p>  在商品详情点击添加购物车后，如果未登录，将跳转到登录界面，否则将之加入购物车，并且前往购物车界面，购物车页面会展示已经加入购物车的商品，并且可以选择购买或者删除该商品。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/40a0aab6c095373eaddc834c12ca7036.png\"></p>\n<h2 id=\"结算下单\"><a href=\"#结算下单\" class=\"headerlink\" title=\"结算下单\"></a>结算下单</h2><p>当在商品详情选择立即购买，或者在购物车点击购买时，将跳转到购买界面，显示要购买的商品，以及购买人的信息。点击购买，则模拟购买成功，并且跳转到历史订单界面。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/debe58129dc0bfdc1597629e0945ce7d.png\"></p>\n<h2 id=\"历史订单查询\"><a href=\"#历史订单查询\" class=\"headerlink\" title=\"历史订单查询\"></a>历史订单查询</h2><p>登录状态才能进入历史订单页面，进入后将展示购买过的商品，并且可以删除订单。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/57c5639f4db15bda5e7cb79bcc7db8bf.png\"></p>\n"},{"title":"项目------Web游戏-俄罗斯方块","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"Web游戏-俄罗斯方块。一个简单的前端项目，其中前端只用了HTML，Css，JS","abbrlink":"1a7d60e1","date":"2020-05-17T16:00:00.000Z","_content":"\n\n\n# 1.整体架构\n## 项目介绍\n\n该项目是基于html+css+js开发的俄罗斯方块前端游戏。项目已部署到远程服务器,可直接访问:\n[运行游戏](http://47.103.203.188:8080/tetris/html/index.html%20)。\n\n源码可在Github上查看:[tongji4m3](https://github.com/tongji4m3/tetris)\n\n## 项目架构\n\n本项目总体分为四个文件夹:html,css,js,img。img包含了背景图片。html中只有index.html，负责游戏的展示。css文件中只有index.css，负责对index.html的美化。游戏具体逻辑包含在js文件中。\n\njs文件夹中，const.js定义了整个游戏的常量，例如游戏长宽，方块颜色，键盘的键与数值等。tetris.js代表着一种特点的方块类型,方块位置，也包含了方块变换等。controller.js执行了游戏的具体逻辑，如控制方块下落，方块变体，是否得分，游戏是否结束等等。view.js负责游戏区与下一方块区表格的动态生成以及游戏方块的绘制等等。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/400f4a8a4575cfc57aa331b5ca9384d0.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e71387d08a0edb58f8cf89a113046d3e.png)\n\n#  2.项目实现\n\n## index.html实现\n\nindex.html中首先引入了相关的css文件以及js文件。主体通过div将页面分为三部分：左边为游戏区域,右边为辅助区域(右上角为下一方块预告区,右下角为操作说明区)。\n\n在游戏区以及下一方块预告区，都只放了一个table标签，并且赋予一个id，之后通过index.css控制他的样式，通过view.js动态往表格添加行列，以可以根据传入值动态改变游戏区的长宽。预告区则是一些文本，其中的分数和速度则有id，可以在js中根据游戏进度动态改变。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/af5562472786187932abcc87e75ab368.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/5873677b292faf23ec0d32ac45b894cd.png)\n\n## index.css实现\n\n主要设置了整体的背景，以及控制了游戏区，下一方块预告区，操作提示区的相对位置。以及游戏区，下一方块区中每个小方格的样式。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc1363b58fa790fe2c2afc425ee5224a.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/adde641caf8036e3decbbf65152774a2.png)\n\n## const.js实现\n\n该文件定义了整体程序需要用到的一些常量，一是为了便于修改，二是通过字符串代替数字，便于代码阅读。首先定义了游戏主界面的宽高以及下一方块提示区的宽高。其次定义了初始方块产生的位置。然后定义了不同种类的方块对应的字符串，例如WALL代表墙。还定义了使用到的键盘的键与值的对应关系。最后定义了使用到的颜色。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4eb1393726b1c70932db9b9a6287446f.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f245fcf5964cb84c4d7083ecd9c2c0af.png)\n\n## tetris.js实现\n\n定义二维位置坐标类,方便坐标表示。然后定义了方块类，包含了重要点坐标，方块类型，方块颜色，整体形状坐标。\n\n众所周知，一个整体的方块由四个原子方块组成。所以重要点坐标标记了该整体方块的一个点的位置，然后其他三个点则可以通过该重要点的坐标以及该方块类型得到（通过makeTetris（）函数生成）。每个整体方块的颜色是随机生成的。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/59c997eed9e8d30617a6aabe67254eba.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7e74e0992e569b2628c3cac42a68e59b.png)\n\nmakeTetris（）函数则就是根据上述的重要点坐标（x,y）以及方块类型flag来生成。俄罗斯方块一共21种类型，对应每种类型生成他四个点的坐标并存储在数组中。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/35704969093fe1e901b55eadcac5eafe.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/0c9987edd2cd3b74290d0bd9d89f90a0.png)\n\nchangeTetris（）函数是为了支持方块变形而存在的。首先改变flag到他的下一个转体的flag。因为除了田字形只有一种类型外，其他四个为一组，所以可以简单的操作即可得到转变后的flag。得到之后，调用之前的makeTetris（）即可得到转变后的整体方块的四个坐标。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ca147ba64e0255f954c09c405ea3d1d0.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/330bc00838630d6a247e3ecc12d9b978.png)\n\nrechangeTetris（）函数是changeTetris（）函数的逆运算，为的是模拟转体后发现空间不够则要转回原本的形状。实现起来差不多，只是形状改变的方向不一样。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3d764fa633e30b9ebd5bffa4d45617d1.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3ae5b038767dc3722b78ab9f8dd2fb98.png)\n\n## view.js实现\n\n主要是负责图像的绘制，即往表中根据const.js中定义的宽高，动态的生成表格的行和列，代表了每个小方块。还绘制了小方块的颜色。\n\n首先，定义了游戏区，下一方块预告区（以下简称next区）的二维数组，之后基本通过操作二维数组来实现功能。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/61a8798f8379f9dd2619dbe949f8db0a.png)\n\n初始化函数init（）。负责将游戏区和next区的二维数组初始化。游戏区一部分初始化为EMPTY代表此时没有方块，边缘初始化为WALL，代表是墙。next区则全部初始化为EMPTY。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4ca0365317a84550829ab1a6d50707e4.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d5906f8c4fdc7277485e11fa2528cbc.png)\n\nappend（）函数。负责在屏幕上动态添加表格，即根据const定义的宽高往游戏区，next区动态添加对应的表格。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/43f75f32f0e95c419c863ef70deca9ee.png)\n\ndraw（）函数。负责绘制游戏区的方块颜色，根据不同种类的方块（空白，墙，已经落下的，正在落下的），绘制不同的颜色。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4941c27368fd441a6c23e062e499d53b.png)\n\ndrawSmall（）函数。负责next区的绘图。和draw（）原理一样。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/24a9df9727e853d16d487d1837d19345.png)\n\n## controller.js实现\n\n该js文件负责游戏的具体逻辑实现。首先定义了一些全局变量。例如当前方块类型flag，下一方块类型nextFlag。当前方块tetris，下一方块nextTetris。以及两个变量movable，gameOver表示是否能移动，是否游戏结束。以及两个变量speed，scope代表速度和得分。最后moveDownId是控制方块不断下移函数moveDown的定时器的返回值，为了能停止定时器，调整速度等等。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2c28d9c4c4177c6c4319e5d566a84708.png)\n\nwindow.onload（）函数。是该js文件的入口，当html页面一加载就进入该函数。他调用了之后用到的函数，大概逻辑是：先初始化游戏区，next区的二维数组，然后将初始的表格给动态添加好。随后就绘制游戏区和next区的方块。随后就调用定时器，每隔一段时间调用moveDown函数，让当前方块下移。最后还添加了事件监听。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7b5f787a34c8ddd2507502bf53e6e019.png)\n\naddEventListener（）函数。添加键盘事件监听。根据不同的键盘按键，采取对应的措施。如果是UP，则方块先变形，如果不能变形，则回退。如果是DOWN，则让方块向下移动一位，且调用makeTetris()函数，让核心小方块之外的其他三个小方块坐标也发生改变，同样的，如果是不能向下移动，则取消刚刚的操作。LEFT，RIGHT函数以此类推。SPACE，则简单的将moveable=！moveable就实现了暂停。而+-号则改变速度，首先先把speed变量做相应的改变然后先通过之前提到的定时器ID：moveDownId来停止movedown函数的定时器，再新建一个定时器（因为不这样的话，定时器的速度会按照之前的速度，即不会改变）。同时，获取html上的对应speed元素，并且修改值。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e6a9e4e2b06a4389ad8feededdfb2507.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1a47e25419e9f80947f4def13f522543.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/34c6511cb734ef2e44074a464ba59f11.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/24039215d38011643738882aaf85eb1d.png)\n\nmoveDown()函数：之前所提到的，就是通过定时器调用moveDown()函数实现方块的自动下落，是一个比较关键的函数。\n\n该函数首先会判断，如果没有暂停，则将tetris的核心小方块x坐标下移，并且将其他三个小方块也下移。随后判断是否可移动，如果是不可移动的，说明该方块已经落到了下面，则调用newStart（）函数生成新的方块继续。如果是可以移动的，则调用updateBoard()函数更新方块位置，并且通过draw（）函数绘制当前方块情况。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/be5da2aa64d60769e110aa603716428c.png)\n\nupdateBoard()函数：负责每次方块下落时将游戏区的二维数组更新，具体逻辑是先将数组中值等于NEW，即刚刚落下的给赋值为EMPTY。再将当前tetris的四个小方块位置坐标标记为NEW。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3b8654ef815c9f7f75fcbdec25d0cf13.png)\n\nisMovable()函数：负责碰撞检测。具体做法是，对方块中的每一个小方块，首先判断是否数组越界，然后判断坐标所在位置是否是OLD或者WALL，是则返回false，代表不能移动。（因为碰撞检测是在updateBoard()之前，所以还不会覆盖）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/eb9e4430fd0acd00661d6640d79e2be3.png)\n\nnewStart()函数：当一个方块下落到不能继续下落时调用该方法。首先将方块整体上移一格，以抵消之前的下移操作。随后更新方块，将此方块变成已下落状态。并且此时还调用clearLine()进行满行清空操作。最后还判断游戏是否结束，结束则调用newGame（）函数进行相关清理工作，未结束则把之前的nextTetris变成当前的tetris，并且重新生成下一方块并展示。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8a54cb8e243f1378882a9fed179467c6.png)\n\nnewGame()函数：初始化数组，重新绘图，并且终止定时器。\n\nisOver()函数：用于判断游戏是否结束，具体是查看游戏区的顶部是否已经有了已经落下的方块，或者是应该落下新方块的位置是否已经有了方块。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/cfc9aaa6c9d76397d6ad9e09d9bdfc4b.png)\n\nclearLine()函数则负责消除满行。具体做法是，从游戏区的底部往上进行扫描操作，并且计算每一行的方块数，如果某一行满了，则让该行清空。并且让这一行上面的所有方块都不断下移，把空出来的位置填满，并且又从底部重新开始扫描（因为可能消去之后下面的区域又全满了）。最后更新分数，并且展示在屏幕上。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9d8d9a9b4d714bd37b1acc3018bddd14.png)\n\n#  3.项目展示\n\n初始页面：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/bc2c190196439d37817452551c1df7db.png)\n\n消除一行并且改变了速度的页面：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f75a7f497951e45f40c107fddb4510e6.png)\n","source":"_posts/项目笔记/Web游戏_俄罗斯方块.md","raw":"---\ntitle: 项目------Web游戏-俄罗斯方块\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: Web游戏-俄罗斯方块。一个简单的前端项目，其中前端只用了HTML，Css，JS\ncategories: 项目文档\ntags:\n  - HTML\n  - JavaScript\n  - CSS\nabbrlink: 1a7d60e1\ndate: 2020-05-18 00:00:00\n---\n\n\n\n# 1.整体架构\n## 项目介绍\n\n该项目是基于html+css+js开发的俄罗斯方块前端游戏。项目已部署到远程服务器,可直接访问:\n[运行游戏](http://47.103.203.188:8080/tetris/html/index.html%20)。\n\n源码可在Github上查看:[tongji4m3](https://github.com/tongji4m3/tetris)\n\n## 项目架构\n\n本项目总体分为四个文件夹:html,css,js,img。img包含了背景图片。html中只有index.html，负责游戏的展示。css文件中只有index.css，负责对index.html的美化。游戏具体逻辑包含在js文件中。\n\njs文件夹中，const.js定义了整个游戏的常量，例如游戏长宽，方块颜色，键盘的键与数值等。tetris.js代表着一种特点的方块类型,方块位置，也包含了方块变换等。controller.js执行了游戏的具体逻辑，如控制方块下落，方块变体，是否得分，游戏是否结束等等。view.js负责游戏区与下一方块区表格的动态生成以及游戏方块的绘制等等。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/400f4a8a4575cfc57aa331b5ca9384d0.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e71387d08a0edb58f8cf89a113046d3e.png)\n\n#  2.项目实现\n\n## index.html实现\n\nindex.html中首先引入了相关的css文件以及js文件。主体通过div将页面分为三部分：左边为游戏区域,右边为辅助区域(右上角为下一方块预告区,右下角为操作说明区)。\n\n在游戏区以及下一方块预告区，都只放了一个table标签，并且赋予一个id，之后通过index.css控制他的样式，通过view.js动态往表格添加行列，以可以根据传入值动态改变游戏区的长宽。预告区则是一些文本，其中的分数和速度则有id，可以在js中根据游戏进度动态改变。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/af5562472786187932abcc87e75ab368.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/5873677b292faf23ec0d32ac45b894cd.png)\n\n## index.css实现\n\n主要设置了整体的背景，以及控制了游戏区，下一方块预告区，操作提示区的相对位置。以及游戏区，下一方块区中每个小方格的样式。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc1363b58fa790fe2c2afc425ee5224a.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/adde641caf8036e3decbbf65152774a2.png)\n\n## const.js实现\n\n该文件定义了整体程序需要用到的一些常量，一是为了便于修改，二是通过字符串代替数字，便于代码阅读。首先定义了游戏主界面的宽高以及下一方块提示区的宽高。其次定义了初始方块产生的位置。然后定义了不同种类的方块对应的字符串，例如WALL代表墙。还定义了使用到的键盘的键与值的对应关系。最后定义了使用到的颜色。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4eb1393726b1c70932db9b9a6287446f.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f245fcf5964cb84c4d7083ecd9c2c0af.png)\n\n## tetris.js实现\n\n定义二维位置坐标类,方便坐标表示。然后定义了方块类，包含了重要点坐标，方块类型，方块颜色，整体形状坐标。\n\n众所周知，一个整体的方块由四个原子方块组成。所以重要点坐标标记了该整体方块的一个点的位置，然后其他三个点则可以通过该重要点的坐标以及该方块类型得到（通过makeTetris（）函数生成）。每个整体方块的颜色是随机生成的。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/59c997eed9e8d30617a6aabe67254eba.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7e74e0992e569b2628c3cac42a68e59b.png)\n\nmakeTetris（）函数则就是根据上述的重要点坐标（x,y）以及方块类型flag来生成。俄罗斯方块一共21种类型，对应每种类型生成他四个点的坐标并存储在数组中。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/35704969093fe1e901b55eadcac5eafe.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/0c9987edd2cd3b74290d0bd9d89f90a0.png)\n\nchangeTetris（）函数是为了支持方块变形而存在的。首先改变flag到他的下一个转体的flag。因为除了田字形只有一种类型外，其他四个为一组，所以可以简单的操作即可得到转变后的flag。得到之后，调用之前的makeTetris（）即可得到转变后的整体方块的四个坐标。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ca147ba64e0255f954c09c405ea3d1d0.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/330bc00838630d6a247e3ecc12d9b978.png)\n\nrechangeTetris（）函数是changeTetris（）函数的逆运算，为的是模拟转体后发现空间不够则要转回原本的形状。实现起来差不多，只是形状改变的方向不一样。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3d764fa633e30b9ebd5bffa4d45617d1.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3ae5b038767dc3722b78ab9f8dd2fb98.png)\n\n## view.js实现\n\n主要是负责图像的绘制，即往表中根据const.js中定义的宽高，动态的生成表格的行和列，代表了每个小方块。还绘制了小方块的颜色。\n\n首先，定义了游戏区，下一方块预告区（以下简称next区）的二维数组，之后基本通过操作二维数组来实现功能。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/61a8798f8379f9dd2619dbe949f8db0a.png)\n\n初始化函数init（）。负责将游戏区和next区的二维数组初始化。游戏区一部分初始化为EMPTY代表此时没有方块，边缘初始化为WALL，代表是墙。next区则全部初始化为EMPTY。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4ca0365317a84550829ab1a6d50707e4.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d5906f8c4fdc7277485e11fa2528cbc.png)\n\nappend（）函数。负责在屏幕上动态添加表格，即根据const定义的宽高往游戏区，next区动态添加对应的表格。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/43f75f32f0e95c419c863ef70deca9ee.png)\n\ndraw（）函数。负责绘制游戏区的方块颜色，根据不同种类的方块（空白，墙，已经落下的，正在落下的），绘制不同的颜色。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4941c27368fd441a6c23e062e499d53b.png)\n\ndrawSmall（）函数。负责next区的绘图。和draw（）原理一样。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/24a9df9727e853d16d487d1837d19345.png)\n\n## controller.js实现\n\n该js文件负责游戏的具体逻辑实现。首先定义了一些全局变量。例如当前方块类型flag，下一方块类型nextFlag。当前方块tetris，下一方块nextTetris。以及两个变量movable，gameOver表示是否能移动，是否游戏结束。以及两个变量speed，scope代表速度和得分。最后moveDownId是控制方块不断下移函数moveDown的定时器的返回值，为了能停止定时器，调整速度等等。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2c28d9c4c4177c6c4319e5d566a84708.png)\n\nwindow.onload（）函数。是该js文件的入口，当html页面一加载就进入该函数。他调用了之后用到的函数，大概逻辑是：先初始化游戏区，next区的二维数组，然后将初始的表格给动态添加好。随后就绘制游戏区和next区的方块。随后就调用定时器，每隔一段时间调用moveDown函数，让当前方块下移。最后还添加了事件监听。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7b5f787a34c8ddd2507502bf53e6e019.png)\n\naddEventListener（）函数。添加键盘事件监听。根据不同的键盘按键，采取对应的措施。如果是UP，则方块先变形，如果不能变形，则回退。如果是DOWN，则让方块向下移动一位，且调用makeTetris()函数，让核心小方块之外的其他三个小方块坐标也发生改变，同样的，如果是不能向下移动，则取消刚刚的操作。LEFT，RIGHT函数以此类推。SPACE，则简单的将moveable=！moveable就实现了暂停。而+-号则改变速度，首先先把speed变量做相应的改变然后先通过之前提到的定时器ID：moveDownId来停止movedown函数的定时器，再新建一个定时器（因为不这样的话，定时器的速度会按照之前的速度，即不会改变）。同时，获取html上的对应speed元素，并且修改值。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e6a9e4e2b06a4389ad8feededdfb2507.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1a47e25419e9f80947f4def13f522543.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/34c6511cb734ef2e44074a464ba59f11.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/24039215d38011643738882aaf85eb1d.png)\n\nmoveDown()函数：之前所提到的，就是通过定时器调用moveDown()函数实现方块的自动下落，是一个比较关键的函数。\n\n该函数首先会判断，如果没有暂停，则将tetris的核心小方块x坐标下移，并且将其他三个小方块也下移。随后判断是否可移动，如果是不可移动的，说明该方块已经落到了下面，则调用newStart（）函数生成新的方块继续。如果是可以移动的，则调用updateBoard()函数更新方块位置，并且通过draw（）函数绘制当前方块情况。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/be5da2aa64d60769e110aa603716428c.png)\n\nupdateBoard()函数：负责每次方块下落时将游戏区的二维数组更新，具体逻辑是先将数组中值等于NEW，即刚刚落下的给赋值为EMPTY。再将当前tetris的四个小方块位置坐标标记为NEW。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3b8654ef815c9f7f75fcbdec25d0cf13.png)\n\nisMovable()函数：负责碰撞检测。具体做法是，对方块中的每一个小方块，首先判断是否数组越界，然后判断坐标所在位置是否是OLD或者WALL，是则返回false，代表不能移动。（因为碰撞检测是在updateBoard()之前，所以还不会覆盖）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/eb9e4430fd0acd00661d6640d79e2be3.png)\n\nnewStart()函数：当一个方块下落到不能继续下落时调用该方法。首先将方块整体上移一格，以抵消之前的下移操作。随后更新方块，将此方块变成已下落状态。并且此时还调用clearLine()进行满行清空操作。最后还判断游戏是否结束，结束则调用newGame（）函数进行相关清理工作，未结束则把之前的nextTetris变成当前的tetris，并且重新生成下一方块并展示。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8a54cb8e243f1378882a9fed179467c6.png)\n\nnewGame()函数：初始化数组，重新绘图，并且终止定时器。\n\nisOver()函数：用于判断游戏是否结束，具体是查看游戏区的顶部是否已经有了已经落下的方块，或者是应该落下新方块的位置是否已经有了方块。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/cfc9aaa6c9d76397d6ad9e09d9bdfc4b.png)\n\nclearLine()函数则负责消除满行。具体做法是，从游戏区的底部往上进行扫描操作，并且计算每一行的方块数，如果某一行满了，则让该行清空。并且让这一行上面的所有方块都不断下移，把空出来的位置填满，并且又从底部重新开始扫描（因为可能消去之后下面的区域又全满了）。最后更新分数，并且展示在屏幕上。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9d8d9a9b4d714bd37b1acc3018bddd14.png)\n\n#  3.项目展示\n\n初始页面：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/bc2c190196439d37817452551c1df7db.png)\n\n消除一行并且改变了速度的页面：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f75a7f497951e45f40c107fddb4510e6.png)\n","slug":"项目笔记/Web游戏_俄罗斯方块","published":1,"updated":"2020-11-12T11:57:30.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6z5008pjotp21f97lgj","content":"<h1 id=\"1-整体架构\"><a href=\"#1-整体架构\" class=\"headerlink\" title=\"1.整体架构\"></a>1.整体架构</h1><h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><p>该项目是基于html+css+js开发的俄罗斯方块前端游戏。项目已部署到远程服务器,可直接访问:<br><a href=\"http://47.103.203.188:8080/tetris/html/index.html%20\" target=\"_blank\" rel=\"noopener\">运行游戏</a>。</p>\n<p>源码可在Github上查看:<a href=\"https://github.com/tongji4m3/tetris\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n<h2 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"></a>项目架构</h2><p>本项目总体分为四个文件夹:html,css,js,img。img包含了背景图片。html中只有index.html，负责游戏的展示。css文件中只有index.css，负责对index.html的美化。游戏具体逻辑包含在js文件中。</p>\n<p>js文件夹中，const.js定义了整个游戏的常量，例如游戏长宽，方块颜色，键盘的键与数值等。tetris.js代表着一种特点的方块类型,方块位置，也包含了方块变换等。controller.js执行了游戏的具体逻辑，如控制方块下落，方块变体，是否得分，游戏是否结束等等。view.js负责游戏区与下一方块区表格的动态生成以及游戏方块的绘制等等。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/400f4a8a4575cfc57aa331b5ca9384d0.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e71387d08a0edb58f8cf89a113046d3e.png\"></p>\n<h1 id=\"2-项目实现\"><a href=\"#2-项目实现\" class=\"headerlink\" title=\"2.项目实现\"></a>2.项目实现</h1><h2 id=\"index-html实现\"><a href=\"#index-html实现\" class=\"headerlink\" title=\"index.html实现\"></a>index.html实现</h2><p>index.html中首先引入了相关的css文件以及js文件。主体通过div将页面分为三部分：左边为游戏区域,右边为辅助区域(右上角为下一方块预告区,右下角为操作说明区)。</p>\n<p>在游戏区以及下一方块预告区，都只放了一个table标签，并且赋予一个id，之后通过index.css控制他的样式，通过view.js动态往表格添加行列，以可以根据传入值动态改变游戏区的长宽。预告区则是一些文本，其中的分数和速度则有id，可以在js中根据游戏进度动态改变。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/af5562472786187932abcc87e75ab368.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/5873677b292faf23ec0d32ac45b894cd.png\"></p>\n<h2 id=\"index-css实现\"><a href=\"#index-css实现\" class=\"headerlink\" title=\"index.css实现\"></a>index.css实现</h2><p>主要设置了整体的背景，以及控制了游戏区，下一方块预告区，操作提示区的相对位置。以及游戏区，下一方块区中每个小方格的样式。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc1363b58fa790fe2c2afc425ee5224a.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/adde641caf8036e3decbbf65152774a2.png\"></p>\n<h2 id=\"const-js实现\"><a href=\"#const-js实现\" class=\"headerlink\" title=\"const.js实现\"></a>const.js实现</h2><p>该文件定义了整体程序需要用到的一些常量，一是为了便于修改，二是通过字符串代替数字，便于代码阅读。首先定义了游戏主界面的宽高以及下一方块提示区的宽高。其次定义了初始方块产生的位置。然后定义了不同种类的方块对应的字符串，例如WALL代表墙。还定义了使用到的键盘的键与值的对应关系。最后定义了使用到的颜色。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4eb1393726b1c70932db9b9a6287446f.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f245fcf5964cb84c4d7083ecd9c2c0af.png\"></p>\n<h2 id=\"tetris-js实现\"><a href=\"#tetris-js实现\" class=\"headerlink\" title=\"tetris.js实现\"></a>tetris.js实现</h2><p>定义二维位置坐标类,方便坐标表示。然后定义了方块类，包含了重要点坐标，方块类型，方块颜色，整体形状坐标。</p>\n<p>众所周知，一个整体的方块由四个原子方块组成。所以重要点坐标标记了该整体方块的一个点的位置，然后其他三个点则可以通过该重要点的坐标以及该方块类型得到（通过makeTetris（）函数生成）。每个整体方块的颜色是随机生成的。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/59c997eed9e8d30617a6aabe67254eba.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7e74e0992e569b2628c3cac42a68e59b.png\"></p>\n<p>makeTetris（）函数则就是根据上述的重要点坐标（x,y）以及方块类型flag来生成。俄罗斯方块一共21种类型，对应每种类型生成他四个点的坐标并存储在数组中。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/35704969093fe1e901b55eadcac5eafe.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/0c9987edd2cd3b74290d0bd9d89f90a0.png\"></p>\n<p>changeTetris（）函数是为了支持方块变形而存在的。首先改变flag到他的下一个转体的flag。因为除了田字形只有一种类型外，其他四个为一组，所以可以简单的操作即可得到转变后的flag。得到之后，调用之前的makeTetris（）即可得到转变后的整体方块的四个坐标。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ca147ba64e0255f954c09c405ea3d1d0.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/330bc00838630d6a247e3ecc12d9b978.png\"></p>\n<p>rechangeTetris（）函数是changeTetris（）函数的逆运算，为的是模拟转体后发现空间不够则要转回原本的形状。实现起来差不多，只是形状改变的方向不一样。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3d764fa633e30b9ebd5bffa4d45617d1.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3ae5b038767dc3722b78ab9f8dd2fb98.png\"></p>\n<h2 id=\"view-js实现\"><a href=\"#view-js实现\" class=\"headerlink\" title=\"view.js实现\"></a>view.js实现</h2><p>主要是负责图像的绘制，即往表中根据const.js中定义的宽高，动态的生成表格的行和列，代表了每个小方块。还绘制了小方块的颜色。</p>\n<p>首先，定义了游戏区，下一方块预告区（以下简称next区）的二维数组，之后基本通过操作二维数组来实现功能。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/61a8798f8379f9dd2619dbe949f8db0a.png\"></p>\n<p>初始化函数init（）。负责将游戏区和next区的二维数组初始化。游戏区一部分初始化为EMPTY代表此时没有方块，边缘初始化为WALL，代表是墙。next区则全部初始化为EMPTY。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4ca0365317a84550829ab1a6d50707e4.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d5906f8c4fdc7277485e11fa2528cbc.png\"></p>\n<p>append（）函数。负责在屏幕上动态添加表格，即根据const定义的宽高往游戏区，next区动态添加对应的表格。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/43f75f32f0e95c419c863ef70deca9ee.png\"></p>\n<p>draw（）函数。负责绘制游戏区的方块颜色，根据不同种类的方块（空白，墙，已经落下的，正在落下的），绘制不同的颜色。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4941c27368fd441a6c23e062e499d53b.png\"></p>\n<p>drawSmall（）函数。负责next区的绘图。和draw（）原理一样。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/24a9df9727e853d16d487d1837d19345.png\"></p>\n<h2 id=\"controller-js实现\"><a href=\"#controller-js实现\" class=\"headerlink\" title=\"controller.js实现\"></a>controller.js实现</h2><p>该js文件负责游戏的具体逻辑实现。首先定义了一些全局变量。例如当前方块类型flag，下一方块类型nextFlag。当前方块tetris，下一方块nextTetris。以及两个变量movable，gameOver表示是否能移动，是否游戏结束。以及两个变量speed，scope代表速度和得分。最后moveDownId是控制方块不断下移函数moveDown的定时器的返回值，为了能停止定时器，调整速度等等。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2c28d9c4c4177c6c4319e5d566a84708.png\"></p>\n<p>window.onload（）函数。是该js文件的入口，当html页面一加载就进入该函数。他调用了之后用到的函数，大概逻辑是：先初始化游戏区，next区的二维数组，然后将初始的表格给动态添加好。随后就绘制游戏区和next区的方块。随后就调用定时器，每隔一段时间调用moveDown函数，让当前方块下移。最后还添加了事件监听。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7b5f787a34c8ddd2507502bf53e6e019.png\"></p>\n<p>addEventListener（）函数。添加键盘事件监听。根据不同的键盘按键，采取对应的措施。如果是UP，则方块先变形，如果不能变形，则回退。如果是DOWN，则让方块向下移动一位，且调用makeTetris()函数，让核心小方块之外的其他三个小方块坐标也发生改变，同样的，如果是不能向下移动，则取消刚刚的操作。LEFT，RIGHT函数以此类推。SPACE，则简单的将moveable=！moveable就实现了暂停。而+-号则改变速度，首先先把speed变量做相应的改变然后先通过之前提到的定时器ID：moveDownId来停止movedown函数的定时器，再新建一个定时器（因为不这样的话，定时器的速度会按照之前的速度，即不会改变）。同时，获取html上的对应speed元素，并且修改值。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e6a9e4e2b06a4389ad8feededdfb2507.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1a47e25419e9f80947f4def13f522543.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/34c6511cb734ef2e44074a464ba59f11.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/24039215d38011643738882aaf85eb1d.png\"></p>\n<p>moveDown()函数：之前所提到的，就是通过定时器调用moveDown()函数实现方块的自动下落，是一个比较关键的函数。</p>\n<p>该函数首先会判断，如果没有暂停，则将tetris的核心小方块x坐标下移，并且将其他三个小方块也下移。随后判断是否可移动，如果是不可移动的，说明该方块已经落到了下面，则调用newStart（）函数生成新的方块继续。如果是可以移动的，则调用updateBoard()函数更新方块位置，并且通过draw（）函数绘制当前方块情况。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/be5da2aa64d60769e110aa603716428c.png\"></p>\n<p>updateBoard()函数：负责每次方块下落时将游戏区的二维数组更新，具体逻辑是先将数组中值等于NEW，即刚刚落下的给赋值为EMPTY。再将当前tetris的四个小方块位置坐标标记为NEW。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3b8654ef815c9f7f75fcbdec25d0cf13.png\"></p>\n<p>isMovable()函数：负责碰撞检测。具体做法是，对方块中的每一个小方块，首先判断是否数组越界，然后判断坐标所在位置是否是OLD或者WALL，是则返回false，代表不能移动。（因为碰撞检测是在updateBoard()之前，所以还不会覆盖）。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/eb9e4430fd0acd00661d6640d79e2be3.png\"></p>\n<p>newStart()函数：当一个方块下落到不能继续下落时调用该方法。首先将方块整体上移一格，以抵消之前的下移操作。随后更新方块，将此方块变成已下落状态。并且此时还调用clearLine()进行满行清空操作。最后还判断游戏是否结束，结束则调用newGame（）函数进行相关清理工作，未结束则把之前的nextTetris变成当前的tetris，并且重新生成下一方块并展示。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8a54cb8e243f1378882a9fed179467c6.png\"></p>\n<p>newGame()函数：初始化数组，重新绘图，并且终止定时器。</p>\n<p>isOver()函数：用于判断游戏是否结束，具体是查看游戏区的顶部是否已经有了已经落下的方块，或者是应该落下新方块的位置是否已经有了方块。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/cfc9aaa6c9d76397d6ad9e09d9bdfc4b.png\"></p>\n<p>clearLine()函数则负责消除满行。具体做法是，从游戏区的底部往上进行扫描操作，并且计算每一行的方块数，如果某一行满了，则让该行清空。并且让这一行上面的所有方块都不断下移，把空出来的位置填满，并且又从底部重新开始扫描（因为可能消去之后下面的区域又全满了）。最后更新分数，并且展示在屏幕上。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9d8d9a9b4d714bd37b1acc3018bddd14.png\"></p>\n<h1 id=\"3-项目展示\"><a href=\"#3-项目展示\" class=\"headerlink\" title=\"3.项目展示\"></a>3.项目展示</h1><p>初始页面：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/bc2c190196439d37817452551c1df7db.png\"></p>\n<p>消除一行并且改变了速度的页面：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f75a7f497951e45f40c107fddb4510e6.png\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"1-整体架构\"><a href=\"#1-整体架构\" class=\"headerlink\" title=\"1.整体架构\"></a>1.整体架构</h1><h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><p>该项目是基于html+css+js开发的俄罗斯方块前端游戏。项目已部署到远程服务器,可直接访问:<br><a href=\"http://47.103.203.188:8080/tetris/html/index.html%20\" target=\"_blank\" rel=\"noopener\">运行游戏</a>。</p>\n<p>源码可在Github上查看:<a href=\"https://github.com/tongji4m3/tetris\" target=\"_blank\" rel=\"noopener\">tongji4m3</a></p>\n<h2 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"></a>项目架构</h2><p>本项目总体分为四个文件夹:html,css,js,img。img包含了背景图片。html中只有index.html，负责游戏的展示。css文件中只有index.css，负责对index.html的美化。游戏具体逻辑包含在js文件中。</p>\n<p>js文件夹中，const.js定义了整个游戏的常量，例如游戏长宽，方块颜色，键盘的键与数值等。tetris.js代表着一种特点的方块类型,方块位置，也包含了方块变换等。controller.js执行了游戏的具体逻辑，如控制方块下落，方块变体，是否得分，游戏是否结束等等。view.js负责游戏区与下一方块区表格的动态生成以及游戏方块的绘制等等。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/400f4a8a4575cfc57aa331b5ca9384d0.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e71387d08a0edb58f8cf89a113046d3e.png\"></p>\n<h1 id=\"2-项目实现\"><a href=\"#2-项目实现\" class=\"headerlink\" title=\"2.项目实现\"></a>2.项目实现</h1><h2 id=\"index-html实现\"><a href=\"#index-html实现\" class=\"headerlink\" title=\"index.html实现\"></a>index.html实现</h2><p>index.html中首先引入了相关的css文件以及js文件。主体通过div将页面分为三部分：左边为游戏区域,右边为辅助区域(右上角为下一方块预告区,右下角为操作说明区)。</p>\n<p>在游戏区以及下一方块预告区，都只放了一个table标签，并且赋予一个id，之后通过index.css控制他的样式，通过view.js动态往表格添加行列，以可以根据传入值动态改变游戏区的长宽。预告区则是一些文本，其中的分数和速度则有id，可以在js中根据游戏进度动态改变。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/af5562472786187932abcc87e75ab368.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/5873677b292faf23ec0d32ac45b894cd.png\"></p>\n<h2 id=\"index-css实现\"><a href=\"#index-css实现\" class=\"headerlink\" title=\"index.css实现\"></a>index.css实现</h2><p>主要设置了整体的背景，以及控制了游戏区，下一方块预告区，操作提示区的相对位置。以及游戏区，下一方块区中每个小方格的样式。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc1363b58fa790fe2c2afc425ee5224a.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/adde641caf8036e3decbbf65152774a2.png\"></p>\n<h2 id=\"const-js实现\"><a href=\"#const-js实现\" class=\"headerlink\" title=\"const.js实现\"></a>const.js实现</h2><p>该文件定义了整体程序需要用到的一些常量，一是为了便于修改，二是通过字符串代替数字，便于代码阅读。首先定义了游戏主界面的宽高以及下一方块提示区的宽高。其次定义了初始方块产生的位置。然后定义了不同种类的方块对应的字符串，例如WALL代表墙。还定义了使用到的键盘的键与值的对应关系。最后定义了使用到的颜色。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4eb1393726b1c70932db9b9a6287446f.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f245fcf5964cb84c4d7083ecd9c2c0af.png\"></p>\n<h2 id=\"tetris-js实现\"><a href=\"#tetris-js实现\" class=\"headerlink\" title=\"tetris.js实现\"></a>tetris.js实现</h2><p>定义二维位置坐标类,方便坐标表示。然后定义了方块类，包含了重要点坐标，方块类型，方块颜色，整体形状坐标。</p>\n<p>众所周知，一个整体的方块由四个原子方块组成。所以重要点坐标标记了该整体方块的一个点的位置，然后其他三个点则可以通过该重要点的坐标以及该方块类型得到（通过makeTetris（）函数生成）。每个整体方块的颜色是随机生成的。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/59c997eed9e8d30617a6aabe67254eba.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7e74e0992e569b2628c3cac42a68e59b.png\"></p>\n<p>makeTetris（）函数则就是根据上述的重要点坐标（x,y）以及方块类型flag来生成。俄罗斯方块一共21种类型，对应每种类型生成他四个点的坐标并存储在数组中。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/35704969093fe1e901b55eadcac5eafe.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/0c9987edd2cd3b74290d0bd9d89f90a0.png\"></p>\n<p>changeTetris（）函数是为了支持方块变形而存在的。首先改变flag到他的下一个转体的flag。因为除了田字形只有一种类型外，其他四个为一组，所以可以简单的操作即可得到转变后的flag。得到之后，调用之前的makeTetris（）即可得到转变后的整体方块的四个坐标。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ca147ba64e0255f954c09c405ea3d1d0.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/330bc00838630d6a247e3ecc12d9b978.png\"></p>\n<p>rechangeTetris（）函数是changeTetris（）函数的逆运算，为的是模拟转体后发现空间不够则要转回原本的形状。实现起来差不多，只是形状改变的方向不一样。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3d764fa633e30b9ebd5bffa4d45617d1.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3ae5b038767dc3722b78ab9f8dd2fb98.png\"></p>\n<h2 id=\"view-js实现\"><a href=\"#view-js实现\" class=\"headerlink\" title=\"view.js实现\"></a>view.js实现</h2><p>主要是负责图像的绘制，即往表中根据const.js中定义的宽高，动态的生成表格的行和列，代表了每个小方块。还绘制了小方块的颜色。</p>\n<p>首先，定义了游戏区，下一方块预告区（以下简称next区）的二维数组，之后基本通过操作二维数组来实现功能。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/61a8798f8379f9dd2619dbe949f8db0a.png\"></p>\n<p>初始化函数init（）。负责将游戏区和next区的二维数组初始化。游戏区一部分初始化为EMPTY代表此时没有方块，边缘初始化为WALL，代表是墙。next区则全部初始化为EMPTY。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4ca0365317a84550829ab1a6d50707e4.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d5906f8c4fdc7277485e11fa2528cbc.png\"></p>\n<p>append（）函数。负责在屏幕上动态添加表格，即根据const定义的宽高往游戏区，next区动态添加对应的表格。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/43f75f32f0e95c419c863ef70deca9ee.png\"></p>\n<p>draw（）函数。负责绘制游戏区的方块颜色，根据不同种类的方块（空白，墙，已经落下的，正在落下的），绘制不同的颜色。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4941c27368fd441a6c23e062e499d53b.png\"></p>\n<p>drawSmall（）函数。负责next区的绘图。和draw（）原理一样。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/24a9df9727e853d16d487d1837d19345.png\"></p>\n<h2 id=\"controller-js实现\"><a href=\"#controller-js实现\" class=\"headerlink\" title=\"controller.js实现\"></a>controller.js实现</h2><p>该js文件负责游戏的具体逻辑实现。首先定义了一些全局变量。例如当前方块类型flag，下一方块类型nextFlag。当前方块tetris，下一方块nextTetris。以及两个变量movable，gameOver表示是否能移动，是否游戏结束。以及两个变量speed，scope代表速度和得分。最后moveDownId是控制方块不断下移函数moveDown的定时器的返回值，为了能停止定时器，调整速度等等。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2c28d9c4c4177c6c4319e5d566a84708.png\"></p>\n<p>window.onload（）函数。是该js文件的入口，当html页面一加载就进入该函数。他调用了之后用到的函数，大概逻辑是：先初始化游戏区，next区的二维数组，然后将初始的表格给动态添加好。随后就绘制游戏区和next区的方块。随后就调用定时器，每隔一段时间调用moveDown函数，让当前方块下移。最后还添加了事件监听。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7b5f787a34c8ddd2507502bf53e6e019.png\"></p>\n<p>addEventListener（）函数。添加键盘事件监听。根据不同的键盘按键，采取对应的措施。如果是UP，则方块先变形，如果不能变形，则回退。如果是DOWN，则让方块向下移动一位，且调用makeTetris()函数，让核心小方块之外的其他三个小方块坐标也发生改变，同样的，如果是不能向下移动，则取消刚刚的操作。LEFT，RIGHT函数以此类推。SPACE，则简单的将moveable=！moveable就实现了暂停。而+-号则改变速度，首先先把speed变量做相应的改变然后先通过之前提到的定时器ID：moveDownId来停止movedown函数的定时器，再新建一个定时器（因为不这样的话，定时器的速度会按照之前的速度，即不会改变）。同时，获取html上的对应speed元素，并且修改值。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e6a9e4e2b06a4389ad8feededdfb2507.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1a47e25419e9f80947f4def13f522543.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/34c6511cb734ef2e44074a464ba59f11.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/24039215d38011643738882aaf85eb1d.png\"></p>\n<p>moveDown()函数：之前所提到的，就是通过定时器调用moveDown()函数实现方块的自动下落，是一个比较关键的函数。</p>\n<p>该函数首先会判断，如果没有暂停，则将tetris的核心小方块x坐标下移，并且将其他三个小方块也下移。随后判断是否可移动，如果是不可移动的，说明该方块已经落到了下面，则调用newStart（）函数生成新的方块继续。如果是可以移动的，则调用updateBoard()函数更新方块位置，并且通过draw（）函数绘制当前方块情况。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/be5da2aa64d60769e110aa603716428c.png\"></p>\n<p>updateBoard()函数：负责每次方块下落时将游戏区的二维数组更新，具体逻辑是先将数组中值等于NEW，即刚刚落下的给赋值为EMPTY。再将当前tetris的四个小方块位置坐标标记为NEW。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3b8654ef815c9f7f75fcbdec25d0cf13.png\"></p>\n<p>isMovable()函数：负责碰撞检测。具体做法是，对方块中的每一个小方块，首先判断是否数组越界，然后判断坐标所在位置是否是OLD或者WALL，是则返回false，代表不能移动。（因为碰撞检测是在updateBoard()之前，所以还不会覆盖）。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/eb9e4430fd0acd00661d6640d79e2be3.png\"></p>\n<p>newStart()函数：当一个方块下落到不能继续下落时调用该方法。首先将方块整体上移一格，以抵消之前的下移操作。随后更新方块，将此方块变成已下落状态。并且此时还调用clearLine()进行满行清空操作。最后还判断游戏是否结束，结束则调用newGame（）函数进行相关清理工作，未结束则把之前的nextTetris变成当前的tetris，并且重新生成下一方块并展示。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8a54cb8e243f1378882a9fed179467c6.png\"></p>\n<p>newGame()函数：初始化数组，重新绘图，并且终止定时器。</p>\n<p>isOver()函数：用于判断游戏是否结束，具体是查看游戏区的顶部是否已经有了已经落下的方块，或者是应该落下新方块的位置是否已经有了方块。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/cfc9aaa6c9d76397d6ad9e09d9bdfc4b.png\"></p>\n<p>clearLine()函数则负责消除满行。具体做法是，从游戏区的底部往上进行扫描操作，并且计算每一行的方块数，如果某一行满了，则让该行清空。并且让这一行上面的所有方块都不断下移，把空出来的位置填满，并且又从底部重新开始扫描（因为可能消去之后下面的区域又全满了）。最后更新分数，并且展示在屏幕上。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9d8d9a9b4d714bd37b1acc3018bddd14.png\"></p>\n<h1 id=\"3-项目展示\"><a href=\"#3-项目展示\" class=\"headerlink\" title=\"3.项目展示\"></a>3.项目展示</h1><p>初始页面：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/bc2c190196439d37817452551c1df7db.png\"></p>\n<p>消除一行并且改变了速度的页面：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f75a7f497951e45f40c107fddb4510e6.png\"></p>\n"},{"title":"项目------操作系统_电梯调度项目","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"操作系统_电梯调度项目。主要是模拟电梯运行过程,并用Swing框架展示页面。","abbrlink":"4ef3d1ce","date":"2020-05-29T16:00:00.000Z","_content":"# [电梯调度项目源码_Github地址](https://github.com/tongji4m3/memoryProject)\n#   项目目的\n\n-   学习调度算法\n\n-   通过实现电梯调度，体会操作系统调度过程\n\n-   学习特定环境下多线程编程方法\n\n#   项目需求\n\n-   某一层楼20层，有五部互联的电梯。基于线程思想，编写一个电梯调度程序。（可考虑：楼层和电梯数可设置）。\n\n-   每个电梯里面设置必要功能键：如数字键、关门键、开门键、上行键、下行键、报警键、当前电梯的楼层数、上升及下降状态等。\n\n-   每层楼的每部电梯门口，应该有上行和下行按钮和当前电梯状态的数码显示器。\n\n-   五部电梯门口的按钮是互联结的，即当一个电梯按钮按下去时，其他电梯的相应按钮也就同时点亮，表示也按下去了。\n\n-   所有电梯初始状态都在第一层。每个电梯如果在它的上层或者下层没有相应请求情况下，则应该在原地保持不动。\n\n-   调度算法自行设计。\n\n#   项目设计及算法\n\n##  项目开发概览\n\n-   采用JAVA开发语言,使用JAVA的Swing类库来进行图形界面设计与开发。\n\n-   在windows操作系统环境下，采用IDEA作为开发工具。\n\n-   通过实现 Runnable 接口来进行多线程编程。\n\n-   采用扫描算法（SCAN算法）来进行电梯调度。\n\n## 扫描算法介绍\n\n-   简介：扫描算法（SCAN）\n    是一种按照楼层顺序依次服务请求，它让电梯在最底层和最顶层之间连续往返运行，在运行过程中响应处在于电梯运行方向相同的各楼层上的请求。\n\n-   优点:进行寻找楼层的优化，效率比较高。较好地解决了电梯移动的问题，在这个算法中，每个电梯响应乘客请求使乘客获得服务的次序是由其发出请求的乘客的位置与当前电梯位置之间的距离来决定的。所有的与电梯运行方向相同的乘客的请求在一次电向上运行或向下运行的过程中完成，免去了电梯频繁的来回移动。\n\n-   缺点:扫描算法是一个非实时算法，他的平均响应时间较长。\n\n## 项目多线程\n\n>   计划在项目中通过implement\n>   Runnable接口来实现多线程，之后重写里面的run（）方法。并且通过new\n>   Thread(该类).start()来开启一条多线程。\n\n>   其中，电梯要采用多线程方式启动以此实现调度，并且电梯调度控制类也需要以多线程方式调度，以此实时监听任务并且调度电梯。除此之外，在电梯视图控制类也需要多线程方式启动，以此实时监听并且控制画面刷新。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/b2b901b25dc6a7e6a874f48b8c59ce66.png)\n\n## 项目架构\n\n-   总体采用三层架构,分别是实体层，展示层,控制层。\n\n-   实体层中有三个类，Const类负责存储项目的各种常量，Elevator类负责创建电梯实体，Task类则负责存储实际需求任务。\n\n-   展示层则负责页面的展示，共有三个类，View负责展示整体画面。ElevatorView负责展示电梯内部的按钮，ElevatorOutView负责展示每层楼电梯外部按钮。\n\n-   控制层负责控制事件触发以及调度算法执行。ElevatorOutViewControl负责电梯按钮触发事件以及动态刷新页面等等。ElevatorsControl则根据SCAN算法负责对所有触发的任务进行电梯调度。\n\n-   最后，MainTest是函数的入口，负责以多线程的方式启动ElevatorsControl类，并且启动整个视图View。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/70cf77f8256087dc81a91e8107406d60.jpg)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9538497173b402aa0e037e6ff47396bb.png)\n\n#  项目实现\n\n##   domain包下类实现\n\n###  Const类实现\n\n>   该类存储了项目需要的一些全局变量。例如电梯数量，楼层高度；各种视图的位置大小等，还有用UP，DOWN，STOP来代表电梯状态。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d0120d5480182e8f69bfd07dfa2fd1a6.png)\n\n###  Elevator类实现\n\n>   定义了电梯序号，当前该电梯所处位置，以及当前状态，例如UP,DOWN等。而且该类实现了Runnable接口，实现run（）方法，之后调度时就可以以多线程方式启动电梯。\n\n>   部分代码如下（下同）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e08e56b4c83ab8265608e3d0a79e063e.png)\n\n###  Task类实现\n\n>   该类主要提供要操作的任务，共有三个变量：需要上行还是下行；当前位置，要去的位置。该类在电梯内外都能使用，当在电梯外时，to即要去的位置设置为-1即可。并且提供set，get方法，以及构造函数等。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3422a76f6d2b8aba3ae47056ba2c67a9.png)\n\n##   view包下类实现\n\n###  ElevatorView类实现\n\n>   该类通过继承Jpanel类来负责展示电梯内部视图，例如开门关门按钮，要去的楼层按钮等，并且对按钮提供了事件监听。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/64634ad3a094fc1d7bf04f2db86e2f1b.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/619067c8f9591193ea1958173259060d.png)\n\n###  ElevatorOutView类实现\n\n>   该类也继承了Jpanel，负责展示楼层间的电梯外部视图。主要有上升下降按钮，以及显示电梯状态以及位置的文本。还包含了一个ElevatorControl类对象，以为需要得到里面的电梯对象。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/619067c8f9591193ea1958173259060d.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d9e7185cf83f3e64ff58f4be3f9a9e92.png)\n\n###  View类实现\n\n>   该类是视图的最外层，负责展示其他组件，如电梯内部，外部视图等。它通过继承Jframe类实现该功能。他可以调用ElevatorView类与ElevatorOutView类来批量创造电梯内外视图，达到最终效果。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/faa67568b8f558e807cad36c271373fb.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8fb4d6f9147a4466562fedfefb942b82.png)\n\n##   control包下类实现\n\n###   ElevatorOutViewControl类实现\n\n>   该类主要有两个功能,一是对外部电梯按钮进行事件监听,并且向控制器添加任务,\n>   二是对外部电梯标签进行刷新,以标识电梯目前的位置以及状态。\n\n>   首先初始化时，会创建20\\*5个ElevatorOutView对象，代表每层楼，每个电梯都有一个外部视图。其次，会分别给所有ElevatorOutView对象的开门关门键提供事件监听，当按下按钮时，会在控制器中添加任务，并且同楼层的电梯的相同方向按钮会同时变红，代表被按下。\n\n>   该类也实现了Runnable接口，在run方法中，每隔100ms刷新页面，将最新的电梯状态展示，并且将已完成任务从control类控制列表中删除。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f1fad668c43ca41ee9b665f51f0f3963.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ba53b196d33be1fa43db04190cfcb19f.png)\n\n###   ElevatorsControl类实现\n\n>   负责电梯的实际调度，当没有任务时，电梯将静止不动。有任务时，电梯将持续的往返扫描运行，并且将Elevator对象中的location每秒向上或向下改变1楼（取决于当前电梯运行的状态）。且设置有1个任务则第一个电梯运行，有两个则前两个电梯运行..大于5个任务则所有电梯都不断扫描运行。因为会在ElevatorOutViewControl对象中实时响应任务，所有任务会实时更新，而电梯状态也会实时更新。例如当任务数量从5变为4时，则电梯5将变为静止状态。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4ff18f1c272f4f3db3ccb6cf2b7c7f1c.png)\n\n#  项目界面展示\n\n##   总体界面展示\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e5a65a44d44fe8c757ece5a49751a127.png)\n\n>   左边为五部电梯的内部视图，灰色标签表明具体是哪部电梯的内部视图，其中按钮则分别是要去的楼层，报警键，开门关门键。\n\n>   右边则是楼层视图，以行来分析，则一行中，最左边是楼层高度，其次是电梯在该楼层的上行下行按钮以及电梯的状态和电梯目前的位置（因为初始在1楼而且为静止状态，所以显示为∎1）。因为有五个电梯，所以有5个电梯的按钮及状态显示。共有20行，代表20楼，每行为每楼可进行的按钮。\n\n>   以一列来看，则每一列代表了每个电梯在各个楼层的上下行操作按钮，以及电梯状态，因为为同一个电梯，所以每一列的电梯状态都相同，标志了该电梯目前的状态以及该电梯所处的楼层。因为有五个电梯，所以有五列。\n\n##   电梯运行界面展示\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3d2b3c03c8da120f68f0ffe0d11c87eb.png)\n\n>   如图为按下了2个上楼,2个下楼按钮的电梯图,可以看出,同楼层按钮是互联结的,并且此时一号电梯处于上升状态,且目前在7楼,其他电梯同理。注意，此时电梯5处于静止状态，并且在一楼。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/dc70bb469eeae097811a17de09f26d21.png)\n\n>   接上图，在电梯上行的时候，处理了楼层8，楼层11的上行请求，所以上行请求消失。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/685efb1e717ce692a1656e1387baabf6.png)\n\n>   如图，因为电梯1下行，处理完了两个下行请求。且之后没有任务时，就处于静止状态。\n\n##  电梯内部按钮界面\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3baf35d4b474eacc8b7c6d6f6569dbda.png)\n\n>   如图，电梯内部按钮都可以按下,如选择哪层楼，开门关门等。\n\n#  项目实现情况与可行性分析\n\n##   实现情况\n\n-   实现多线程电梯及实现Scan电梯调度算法。\n\n-   五部电梯门口的按钮是互联结的，实现同时按下。\n\n-   楼层和电梯数可设置。\n\n-   所有电梯初始状态都在第一层。\n\n-   每个电梯如果在它的上层或者下层没有相应请求情况下，则保持不动。\n\n-   每个电梯里面设置必要功能键。\n\n-   每层楼的每部电梯门口，有上行和下行按钮和当前电梯状态的数码显示器。\n\n-   只能在楼层等待电梯时发出任务请求。进入电梯内部后不能操纵电梯内部按钮（如开门，关门，上升下降到某层楼等）。\n\n##   可行性分析\n\n-   该项目基本实现了电梯的调度功能，基本能完成需求\n\n-   没有实现进入电梯内部后的任务请求调度，只能是进入电梯后等待电梯不断上下扫描到达目的地。\n\n-   调度算法不够合理，电梯只会不断上下扫描，响应可能会比较久。例如当所有电梯都处于8楼，而且是上行时。此时如果在7楼新提出了一个上行请求时，电梯会先上升到顶楼，再下到1楼，再上升到7楼才会响应这个请求。但幸运的是，这种情况出现的概率比较小，因为有5辆电梯。他们大概率处于不同的状态，或者是静止状态，所以能很快做出响应。\n\n-   没有考虑到电梯人数超载问题\n","source":"_posts/项目笔记/处理机管理-电梯调度.md","raw":"---\ntitle: 项目------操作系统_电梯调度项目\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '操作系统_电梯调度项目。主要是模拟电梯运行过程,并用Swing框架展示页面。'\ncategories: 项目文档\ntags:\n  - Java\n  - 操作系统\n  - Swing\nabbrlink: 4ef3d1ce\ndate: 2020-05-30 00:00:00\n---\n# [电梯调度项目源码_Github地址](https://github.com/tongji4m3/memoryProject)\n#   项目目的\n\n-   学习调度算法\n\n-   通过实现电梯调度，体会操作系统调度过程\n\n-   学习特定环境下多线程编程方法\n\n#   项目需求\n\n-   某一层楼20层，有五部互联的电梯。基于线程思想，编写一个电梯调度程序。（可考虑：楼层和电梯数可设置）。\n\n-   每个电梯里面设置必要功能键：如数字键、关门键、开门键、上行键、下行键、报警键、当前电梯的楼层数、上升及下降状态等。\n\n-   每层楼的每部电梯门口，应该有上行和下行按钮和当前电梯状态的数码显示器。\n\n-   五部电梯门口的按钮是互联结的，即当一个电梯按钮按下去时，其他电梯的相应按钮也就同时点亮，表示也按下去了。\n\n-   所有电梯初始状态都在第一层。每个电梯如果在它的上层或者下层没有相应请求情况下，则应该在原地保持不动。\n\n-   调度算法自行设计。\n\n#   项目设计及算法\n\n##  项目开发概览\n\n-   采用JAVA开发语言,使用JAVA的Swing类库来进行图形界面设计与开发。\n\n-   在windows操作系统环境下，采用IDEA作为开发工具。\n\n-   通过实现 Runnable 接口来进行多线程编程。\n\n-   采用扫描算法（SCAN算法）来进行电梯调度。\n\n## 扫描算法介绍\n\n-   简介：扫描算法（SCAN）\n    是一种按照楼层顺序依次服务请求，它让电梯在最底层和最顶层之间连续往返运行，在运行过程中响应处在于电梯运行方向相同的各楼层上的请求。\n\n-   优点:进行寻找楼层的优化，效率比较高。较好地解决了电梯移动的问题，在这个算法中，每个电梯响应乘客请求使乘客获得服务的次序是由其发出请求的乘客的位置与当前电梯位置之间的距离来决定的。所有的与电梯运行方向相同的乘客的请求在一次电向上运行或向下运行的过程中完成，免去了电梯频繁的来回移动。\n\n-   缺点:扫描算法是一个非实时算法，他的平均响应时间较长。\n\n## 项目多线程\n\n>   计划在项目中通过implement\n>   Runnable接口来实现多线程，之后重写里面的run（）方法。并且通过new\n>   Thread(该类).start()来开启一条多线程。\n\n>   其中，电梯要采用多线程方式启动以此实现调度，并且电梯调度控制类也需要以多线程方式调度，以此实时监听任务并且调度电梯。除此之外，在电梯视图控制类也需要多线程方式启动，以此实时监听并且控制画面刷新。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/b2b901b25dc6a7e6a874f48b8c59ce66.png)\n\n## 项目架构\n\n-   总体采用三层架构,分别是实体层，展示层,控制层。\n\n-   实体层中有三个类，Const类负责存储项目的各种常量，Elevator类负责创建电梯实体，Task类则负责存储实际需求任务。\n\n-   展示层则负责页面的展示，共有三个类，View负责展示整体画面。ElevatorView负责展示电梯内部的按钮，ElevatorOutView负责展示每层楼电梯外部按钮。\n\n-   控制层负责控制事件触发以及调度算法执行。ElevatorOutViewControl负责电梯按钮触发事件以及动态刷新页面等等。ElevatorsControl则根据SCAN算法负责对所有触发的任务进行电梯调度。\n\n-   最后，MainTest是函数的入口，负责以多线程的方式启动ElevatorsControl类，并且启动整个视图View。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/70cf77f8256087dc81a91e8107406d60.jpg)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9538497173b402aa0e037e6ff47396bb.png)\n\n#  项目实现\n\n##   domain包下类实现\n\n###  Const类实现\n\n>   该类存储了项目需要的一些全局变量。例如电梯数量，楼层高度；各种视图的位置大小等，还有用UP，DOWN，STOP来代表电梯状态。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d0120d5480182e8f69bfd07dfa2fd1a6.png)\n\n###  Elevator类实现\n\n>   定义了电梯序号，当前该电梯所处位置，以及当前状态，例如UP,DOWN等。而且该类实现了Runnable接口，实现run（）方法，之后调度时就可以以多线程方式启动电梯。\n\n>   部分代码如下（下同）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e08e56b4c83ab8265608e3d0a79e063e.png)\n\n###  Task类实现\n\n>   该类主要提供要操作的任务，共有三个变量：需要上行还是下行；当前位置，要去的位置。该类在电梯内外都能使用，当在电梯外时，to即要去的位置设置为-1即可。并且提供set，get方法，以及构造函数等。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3422a76f6d2b8aba3ae47056ba2c67a9.png)\n\n##   view包下类实现\n\n###  ElevatorView类实现\n\n>   该类通过继承Jpanel类来负责展示电梯内部视图，例如开门关门按钮，要去的楼层按钮等，并且对按钮提供了事件监听。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/64634ad3a094fc1d7bf04f2db86e2f1b.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/619067c8f9591193ea1958173259060d.png)\n\n###  ElevatorOutView类实现\n\n>   该类也继承了Jpanel，负责展示楼层间的电梯外部视图。主要有上升下降按钮，以及显示电梯状态以及位置的文本。还包含了一个ElevatorControl类对象，以为需要得到里面的电梯对象。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/619067c8f9591193ea1958173259060d.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d9e7185cf83f3e64ff58f4be3f9a9e92.png)\n\n###  View类实现\n\n>   该类是视图的最外层，负责展示其他组件，如电梯内部，外部视图等。它通过继承Jframe类实现该功能。他可以调用ElevatorView类与ElevatorOutView类来批量创造电梯内外视图，达到最终效果。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/faa67568b8f558e807cad36c271373fb.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8fb4d6f9147a4466562fedfefb942b82.png)\n\n##   control包下类实现\n\n###   ElevatorOutViewControl类实现\n\n>   该类主要有两个功能,一是对外部电梯按钮进行事件监听,并且向控制器添加任务,\n>   二是对外部电梯标签进行刷新,以标识电梯目前的位置以及状态。\n\n>   首先初始化时，会创建20\\*5个ElevatorOutView对象，代表每层楼，每个电梯都有一个外部视图。其次，会分别给所有ElevatorOutView对象的开门关门键提供事件监听，当按下按钮时，会在控制器中添加任务，并且同楼层的电梯的相同方向按钮会同时变红，代表被按下。\n\n>   该类也实现了Runnable接口，在run方法中，每隔100ms刷新页面，将最新的电梯状态展示，并且将已完成任务从control类控制列表中删除。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f1fad668c43ca41ee9b665f51f0f3963.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ba53b196d33be1fa43db04190cfcb19f.png)\n\n###   ElevatorsControl类实现\n\n>   负责电梯的实际调度，当没有任务时，电梯将静止不动。有任务时，电梯将持续的往返扫描运行，并且将Elevator对象中的location每秒向上或向下改变1楼（取决于当前电梯运行的状态）。且设置有1个任务则第一个电梯运行，有两个则前两个电梯运行..大于5个任务则所有电梯都不断扫描运行。因为会在ElevatorOutViewControl对象中实时响应任务，所有任务会实时更新，而电梯状态也会实时更新。例如当任务数量从5变为4时，则电梯5将变为静止状态。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4ff18f1c272f4f3db3ccb6cf2b7c7f1c.png)\n\n#  项目界面展示\n\n##   总体界面展示\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e5a65a44d44fe8c757ece5a49751a127.png)\n\n>   左边为五部电梯的内部视图，灰色标签表明具体是哪部电梯的内部视图，其中按钮则分别是要去的楼层，报警键，开门关门键。\n\n>   右边则是楼层视图，以行来分析，则一行中，最左边是楼层高度，其次是电梯在该楼层的上行下行按钮以及电梯的状态和电梯目前的位置（因为初始在1楼而且为静止状态，所以显示为∎1）。因为有五个电梯，所以有5个电梯的按钮及状态显示。共有20行，代表20楼，每行为每楼可进行的按钮。\n\n>   以一列来看，则每一列代表了每个电梯在各个楼层的上下行操作按钮，以及电梯状态，因为为同一个电梯，所以每一列的电梯状态都相同，标志了该电梯目前的状态以及该电梯所处的楼层。因为有五个电梯，所以有五列。\n\n##   电梯运行界面展示\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3d2b3c03c8da120f68f0ffe0d11c87eb.png)\n\n>   如图为按下了2个上楼,2个下楼按钮的电梯图,可以看出,同楼层按钮是互联结的,并且此时一号电梯处于上升状态,且目前在7楼,其他电梯同理。注意，此时电梯5处于静止状态，并且在一楼。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/dc70bb469eeae097811a17de09f26d21.png)\n\n>   接上图，在电梯上行的时候，处理了楼层8，楼层11的上行请求，所以上行请求消失。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/685efb1e717ce692a1656e1387baabf6.png)\n\n>   如图，因为电梯1下行，处理完了两个下行请求。且之后没有任务时，就处于静止状态。\n\n##  电梯内部按钮界面\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3baf35d4b474eacc8b7c6d6f6569dbda.png)\n\n>   如图，电梯内部按钮都可以按下,如选择哪层楼，开门关门等。\n\n#  项目实现情况与可行性分析\n\n##   实现情况\n\n-   实现多线程电梯及实现Scan电梯调度算法。\n\n-   五部电梯门口的按钮是互联结的，实现同时按下。\n\n-   楼层和电梯数可设置。\n\n-   所有电梯初始状态都在第一层。\n\n-   每个电梯如果在它的上层或者下层没有相应请求情况下，则保持不动。\n\n-   每个电梯里面设置必要功能键。\n\n-   每层楼的每部电梯门口，有上行和下行按钮和当前电梯状态的数码显示器。\n\n-   只能在楼层等待电梯时发出任务请求。进入电梯内部后不能操纵电梯内部按钮（如开门，关门，上升下降到某层楼等）。\n\n##   可行性分析\n\n-   该项目基本实现了电梯的调度功能，基本能完成需求\n\n-   没有实现进入电梯内部后的任务请求调度，只能是进入电梯后等待电梯不断上下扫描到达目的地。\n\n-   调度算法不够合理，电梯只会不断上下扫描，响应可能会比较久。例如当所有电梯都处于8楼，而且是上行时。此时如果在7楼新提出了一个上行请求时，电梯会先上升到顶楼，再下到1楼，再上升到7楼才会响应这个请求。但幸运的是，这种情况出现的概率比较小，因为有5辆电梯。他们大概率处于不同的状态，或者是静止状态，所以能很快做出响应。\n\n-   没有考虑到电梯人数超载问题\n","slug":"项目笔记/处理机管理-电梯调度","published":1,"updated":"2020-11-12T11:57:30.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6z5008sjotp6a2n4vub","content":"<h1 id=\"电梯调度项目源码-Github地址\"><a href=\"#电梯调度项目源码-Github地址\" class=\"headerlink\" title=\"电梯调度项目源码_Github地址\"></a><a href=\"https://github.com/tongji4m3/memoryProject\" target=\"_blank\" rel=\"noopener\">电梯调度项目源码_Github地址</a></h1><h1 id=\"项目目的\"><a href=\"#项目目的\" class=\"headerlink\" title=\"项目目的\"></a>项目目的</h1><ul>\n<li><p>学习调度算法</p>\n</li>\n<li><p>通过实现电梯调度，体会操作系统调度过程</p>\n</li>\n<li><p>学习特定环境下多线程编程方法</p>\n</li>\n</ul>\n<h1 id=\"项目需求\"><a href=\"#项目需求\" class=\"headerlink\" title=\"项目需求\"></a>项目需求</h1><ul>\n<li><p>某一层楼20层，有五部互联的电梯。基于线程思想，编写一个电梯调度程序。（可考虑：楼层和电梯数可设置）。</p>\n</li>\n<li><p>每个电梯里面设置必要功能键：如数字键、关门键、开门键、上行键、下行键、报警键、当前电梯的楼层数、上升及下降状态等。</p>\n</li>\n<li><p>每层楼的每部电梯门口，应该有上行和下行按钮和当前电梯状态的数码显示器。</p>\n</li>\n<li><p>五部电梯门口的按钮是互联结的，即当一个电梯按钮按下去时，其他电梯的相应按钮也就同时点亮，表示也按下去了。</p>\n</li>\n<li><p>所有电梯初始状态都在第一层。每个电梯如果在它的上层或者下层没有相应请求情况下，则应该在原地保持不动。</p>\n</li>\n<li><p>调度算法自行设计。</p>\n</li>\n</ul>\n<h1 id=\"项目设计及算法\"><a href=\"#项目设计及算法\" class=\"headerlink\" title=\"项目设计及算法\"></a>项目设计及算法</h1><h2 id=\"项目开发概览\"><a href=\"#项目开发概览\" class=\"headerlink\" title=\"项目开发概览\"></a>项目开发概览</h2><ul>\n<li><p>采用JAVA开发语言,使用JAVA的Swing类库来进行图形界面设计与开发。</p>\n</li>\n<li><p>在windows操作系统环境下，采用IDEA作为开发工具。</p>\n</li>\n<li><p>通过实现 Runnable 接口来进行多线程编程。</p>\n</li>\n<li><p>采用扫描算法（SCAN算法）来进行电梯调度。</p>\n</li>\n</ul>\n<h2 id=\"扫描算法介绍\"><a href=\"#扫描算法介绍\" class=\"headerlink\" title=\"扫描算法介绍\"></a>扫描算法介绍</h2><ul>\n<li><p>简介：扫描算法（SCAN）<br>是一种按照楼层顺序依次服务请求，它让电梯在最底层和最顶层之间连续往返运行，在运行过程中响应处在于电梯运行方向相同的各楼层上的请求。</p>\n</li>\n<li><p>优点:进行寻找楼层的优化，效率比较高。较好地解决了电梯移动的问题，在这个算法中，每个电梯响应乘客请求使乘客获得服务的次序是由其发出请求的乘客的位置与当前电梯位置之间的距离来决定的。所有的与电梯运行方向相同的乘客的请求在一次电向上运行或向下运行的过程中完成，免去了电梯频繁的来回移动。</p>\n</li>\n<li><p>缺点:扫描算法是一个非实时算法，他的平均响应时间较长。</p>\n</li>\n</ul>\n<h2 id=\"项目多线程\"><a href=\"#项目多线程\" class=\"headerlink\" title=\"项目多线程\"></a>项目多线程</h2><blockquote>\n<p>  计划在项目中通过implement<br>  Runnable接口来实现多线程，之后重写里面的run（）方法。并且通过new<br>  Thread(该类).start()来开启一条多线程。</p>\n</blockquote>\n<blockquote>\n<p>  其中，电梯要采用多线程方式启动以此实现调度，并且电梯调度控制类也需要以多线程方式调度，以此实时监听任务并且调度电梯。除此之外，在电梯视图控制类也需要多线程方式启动，以此实时监听并且控制画面刷新。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/b2b901b25dc6a7e6a874f48b8c59ce66.png\"></p>\n<h2 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"></a>项目架构</h2><ul>\n<li><p>总体采用三层架构,分别是实体层，展示层,控制层。</p>\n</li>\n<li><p>实体层中有三个类，Const类负责存储项目的各种常量，Elevator类负责创建电梯实体，Task类则负责存储实际需求任务。</p>\n</li>\n<li><p>展示层则负责页面的展示，共有三个类，View负责展示整体画面。ElevatorView负责展示电梯内部的按钮，ElevatorOutView负责展示每层楼电梯外部按钮。</p>\n</li>\n<li><p>控制层负责控制事件触发以及调度算法执行。ElevatorOutViewControl负责电梯按钮触发事件以及动态刷新页面等等。ElevatorsControl则根据SCAN算法负责对所有触发的任务进行电梯调度。</p>\n</li>\n<li><p>最后，MainTest是函数的入口，负责以多线程的方式启动ElevatorsControl类，并且启动整个视图View。</p>\n</li>\n</ul>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/70cf77f8256087dc81a91e8107406d60.jpg\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9538497173b402aa0e037e6ff47396bb.png\"></p>\n<h1 id=\"项目实现\"><a href=\"#项目实现\" class=\"headerlink\" title=\"项目实现\"></a>项目实现</h1><h2 id=\"domain包下类实现\"><a href=\"#domain包下类实现\" class=\"headerlink\" title=\"domain包下类实现\"></a>domain包下类实现</h2><h3 id=\"Const类实现\"><a href=\"#Const类实现\" class=\"headerlink\" title=\"Const类实现\"></a>Const类实现</h3><blockquote>\n<p>  该类存储了项目需要的一些全局变量。例如电梯数量，楼层高度；各种视图的位置大小等，还有用UP，DOWN，STOP来代表电梯状态。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d0120d5480182e8f69bfd07dfa2fd1a6.png\"></p>\n<h3 id=\"Elevator类实现\"><a href=\"#Elevator类实现\" class=\"headerlink\" title=\"Elevator类实现\"></a>Elevator类实现</h3><blockquote>\n<p>  定义了电梯序号，当前该电梯所处位置，以及当前状态，例如UP,DOWN等。而且该类实现了Runnable接口，实现run（）方法，之后调度时就可以以多线程方式启动电梯。</p>\n</blockquote>\n<blockquote>\n<p>  部分代码如下（下同）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e08e56b4c83ab8265608e3d0a79e063e.png\"></p>\n<h3 id=\"Task类实现\"><a href=\"#Task类实现\" class=\"headerlink\" title=\"Task类实现\"></a>Task类实现</h3><blockquote>\n<p>  该类主要提供要操作的任务，共有三个变量：需要上行还是下行；当前位置，要去的位置。该类在电梯内外都能使用，当在电梯外时，to即要去的位置设置为-1即可。并且提供set，get方法，以及构造函数等。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3422a76f6d2b8aba3ae47056ba2c67a9.png\"></p>\n<h2 id=\"view包下类实现\"><a href=\"#view包下类实现\" class=\"headerlink\" title=\"view包下类实现\"></a>view包下类实现</h2><h3 id=\"ElevatorView类实现\"><a href=\"#ElevatorView类实现\" class=\"headerlink\" title=\"ElevatorView类实现\"></a>ElevatorView类实现</h3><blockquote>\n<p>  该类通过继承Jpanel类来负责展示电梯内部视图，例如开门关门按钮，要去的楼层按钮等，并且对按钮提供了事件监听。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/64634ad3a094fc1d7bf04f2db86e2f1b.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/619067c8f9591193ea1958173259060d.png\"></p>\n<h3 id=\"ElevatorOutView类实现\"><a href=\"#ElevatorOutView类实现\" class=\"headerlink\" title=\"ElevatorOutView类实现\"></a>ElevatorOutView类实现</h3><blockquote>\n<p>  该类也继承了Jpanel，负责展示楼层间的电梯外部视图。主要有上升下降按钮，以及显示电梯状态以及位置的文本。还包含了一个ElevatorControl类对象，以为需要得到里面的电梯对象。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/619067c8f9591193ea1958173259060d.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d9e7185cf83f3e64ff58f4be3f9a9e92.png\"></p>\n<h3 id=\"View类实现\"><a href=\"#View类实现\" class=\"headerlink\" title=\"View类实现\"></a>View类实现</h3><blockquote>\n<p>  该类是视图的最外层，负责展示其他组件，如电梯内部，外部视图等。它通过继承Jframe类实现该功能。他可以调用ElevatorView类与ElevatorOutView类来批量创造电梯内外视图，达到最终效果。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/faa67568b8f558e807cad36c271373fb.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8fb4d6f9147a4466562fedfefb942b82.png\"></p>\n<h2 id=\"control包下类实现\"><a href=\"#control包下类实现\" class=\"headerlink\" title=\"control包下类实现\"></a>control包下类实现</h2><h3 id=\"ElevatorOutViewControl类实现\"><a href=\"#ElevatorOutViewControl类实现\" class=\"headerlink\" title=\"ElevatorOutViewControl类实现\"></a>ElevatorOutViewControl类实现</h3><blockquote>\n<p>  该类主要有两个功能,一是对外部电梯按钮进行事件监听,并且向控制器添加任务,<br>  二是对外部电梯标签进行刷新,以标识电梯目前的位置以及状态。</p>\n</blockquote>\n<blockquote>\n<p>  首先初始化时，会创建20*5个ElevatorOutView对象，代表每层楼，每个电梯都有一个外部视图。其次，会分别给所有ElevatorOutView对象的开门关门键提供事件监听，当按下按钮时，会在控制器中添加任务，并且同楼层的电梯的相同方向按钮会同时变红，代表被按下。</p>\n</blockquote>\n<blockquote>\n<p>  该类也实现了Runnable接口，在run方法中，每隔100ms刷新页面，将最新的电梯状态展示，并且将已完成任务从control类控制列表中删除。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f1fad668c43ca41ee9b665f51f0f3963.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ba53b196d33be1fa43db04190cfcb19f.png\"></p>\n<h3 id=\"ElevatorsControl类实现\"><a href=\"#ElevatorsControl类实现\" class=\"headerlink\" title=\"ElevatorsControl类实现\"></a>ElevatorsControl类实现</h3><blockquote>\n<p>  负责电梯的实际调度，当没有任务时，电梯将静止不动。有任务时，电梯将持续的往返扫描运行，并且将Elevator对象中的location每秒向上或向下改变1楼（取决于当前电梯运行的状态）。且设置有1个任务则第一个电梯运行，有两个则前两个电梯运行..大于5个任务则所有电梯都不断扫描运行。因为会在ElevatorOutViewControl对象中实时响应任务，所有任务会实时更新，而电梯状态也会实时更新。例如当任务数量从5变为4时，则电梯5将变为静止状态。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4ff18f1c272f4f3db3ccb6cf2b7c7f1c.png\"></p>\n<h1 id=\"项目界面展示\"><a href=\"#项目界面展示\" class=\"headerlink\" title=\"项目界面展示\"></a>项目界面展示</h1><h2 id=\"总体界面展示\"><a href=\"#总体界面展示\" class=\"headerlink\" title=\"总体界面展示\"></a>总体界面展示</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e5a65a44d44fe8c757ece5a49751a127.png\"></p>\n<blockquote>\n<p>  左边为五部电梯的内部视图，灰色标签表明具体是哪部电梯的内部视图，其中按钮则分别是要去的楼层，报警键，开门关门键。</p>\n</blockquote>\n<blockquote>\n<p>  右边则是楼层视图，以行来分析，则一行中，最左边是楼层高度，其次是电梯在该楼层的上行下行按钮以及电梯的状态和电梯目前的位置（因为初始在1楼而且为静止状态，所以显示为∎1）。因为有五个电梯，所以有5个电梯的按钮及状态显示。共有20行，代表20楼，每行为每楼可进行的按钮。</p>\n</blockquote>\n<blockquote>\n<p>  以一列来看，则每一列代表了每个电梯在各个楼层的上下行操作按钮，以及电梯状态，因为为同一个电梯，所以每一列的电梯状态都相同，标志了该电梯目前的状态以及该电梯所处的楼层。因为有五个电梯，所以有五列。</p>\n</blockquote>\n<h2 id=\"电梯运行界面展示\"><a href=\"#电梯运行界面展示\" class=\"headerlink\" title=\"电梯运行界面展示\"></a>电梯运行界面展示</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3d2b3c03c8da120f68f0ffe0d11c87eb.png\"></p>\n<blockquote>\n<p>  如图为按下了2个上楼,2个下楼按钮的电梯图,可以看出,同楼层按钮是互联结的,并且此时一号电梯处于上升状态,且目前在7楼,其他电梯同理。注意，此时电梯5处于静止状态，并且在一楼。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/dc70bb469eeae097811a17de09f26d21.png\"></p>\n<blockquote>\n<p>  接上图，在电梯上行的时候，处理了楼层8，楼层11的上行请求，所以上行请求消失。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/685efb1e717ce692a1656e1387baabf6.png\"></p>\n<blockquote>\n<p>  如图，因为电梯1下行，处理完了两个下行请求。且之后没有任务时，就处于静止状态。</p>\n</blockquote>\n<h2 id=\"电梯内部按钮界面\"><a href=\"#电梯内部按钮界面\" class=\"headerlink\" title=\"电梯内部按钮界面\"></a>电梯内部按钮界面</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3baf35d4b474eacc8b7c6d6f6569dbda.png\"></p>\n<blockquote>\n<p>  如图，电梯内部按钮都可以按下,如选择哪层楼，开门关门等。</p>\n</blockquote>\n<h1 id=\"项目实现情况与可行性分析\"><a href=\"#项目实现情况与可行性分析\" class=\"headerlink\" title=\"项目实现情况与可行性分析\"></a>项目实现情况与可行性分析</h1><h2 id=\"实现情况\"><a href=\"#实现情况\" class=\"headerlink\" title=\"实现情况\"></a>实现情况</h2><ul>\n<li><p>实现多线程电梯及实现Scan电梯调度算法。</p>\n</li>\n<li><p>五部电梯门口的按钮是互联结的，实现同时按下。</p>\n</li>\n<li><p>楼层和电梯数可设置。</p>\n</li>\n<li><p>所有电梯初始状态都在第一层。</p>\n</li>\n<li><p>每个电梯如果在它的上层或者下层没有相应请求情况下，则保持不动。</p>\n</li>\n<li><p>每个电梯里面设置必要功能键。</p>\n</li>\n<li><p>每层楼的每部电梯门口，有上行和下行按钮和当前电梯状态的数码显示器。</p>\n</li>\n<li><p>只能在楼层等待电梯时发出任务请求。进入电梯内部后不能操纵电梯内部按钮（如开门，关门，上升下降到某层楼等）。</p>\n</li>\n</ul>\n<h2 id=\"可行性分析\"><a href=\"#可行性分析\" class=\"headerlink\" title=\"可行性分析\"></a>可行性分析</h2><ul>\n<li><p>该项目基本实现了电梯的调度功能，基本能完成需求</p>\n</li>\n<li><p>没有实现进入电梯内部后的任务请求调度，只能是进入电梯后等待电梯不断上下扫描到达目的地。</p>\n</li>\n<li><p>调度算法不够合理，电梯只会不断上下扫描，响应可能会比较久。例如当所有电梯都处于8楼，而且是上行时。此时如果在7楼新提出了一个上行请求时，电梯会先上升到顶楼，再下到1楼，再上升到7楼才会响应这个请求。但幸运的是，这种情况出现的概率比较小，因为有5辆电梯。他们大概率处于不同的状态，或者是静止状态，所以能很快做出响应。</p>\n</li>\n<li><p>没有考虑到电梯人数超载问题</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"电梯调度项目源码-Github地址\"><a href=\"#电梯调度项目源码-Github地址\" class=\"headerlink\" title=\"电梯调度项目源码_Github地址\"></a><a href=\"https://github.com/tongji4m3/memoryProject\" target=\"_blank\" rel=\"noopener\">电梯调度项目源码_Github地址</a></h1><h1 id=\"项目目的\"><a href=\"#项目目的\" class=\"headerlink\" title=\"项目目的\"></a>项目目的</h1><ul>\n<li><p>学习调度算法</p>\n</li>\n<li><p>通过实现电梯调度，体会操作系统调度过程</p>\n</li>\n<li><p>学习特定环境下多线程编程方法</p>\n</li>\n</ul>\n<h1 id=\"项目需求\"><a href=\"#项目需求\" class=\"headerlink\" title=\"项目需求\"></a>项目需求</h1><ul>\n<li><p>某一层楼20层，有五部互联的电梯。基于线程思想，编写一个电梯调度程序。（可考虑：楼层和电梯数可设置）。</p>\n</li>\n<li><p>每个电梯里面设置必要功能键：如数字键、关门键、开门键、上行键、下行键、报警键、当前电梯的楼层数、上升及下降状态等。</p>\n</li>\n<li><p>每层楼的每部电梯门口，应该有上行和下行按钮和当前电梯状态的数码显示器。</p>\n</li>\n<li><p>五部电梯门口的按钮是互联结的，即当一个电梯按钮按下去时，其他电梯的相应按钮也就同时点亮，表示也按下去了。</p>\n</li>\n<li><p>所有电梯初始状态都在第一层。每个电梯如果在它的上层或者下层没有相应请求情况下，则应该在原地保持不动。</p>\n</li>\n<li><p>调度算法自行设计。</p>\n</li>\n</ul>\n<h1 id=\"项目设计及算法\"><a href=\"#项目设计及算法\" class=\"headerlink\" title=\"项目设计及算法\"></a>项目设计及算法</h1><h2 id=\"项目开发概览\"><a href=\"#项目开发概览\" class=\"headerlink\" title=\"项目开发概览\"></a>项目开发概览</h2><ul>\n<li><p>采用JAVA开发语言,使用JAVA的Swing类库来进行图形界面设计与开发。</p>\n</li>\n<li><p>在windows操作系统环境下，采用IDEA作为开发工具。</p>\n</li>\n<li><p>通过实现 Runnable 接口来进行多线程编程。</p>\n</li>\n<li><p>采用扫描算法（SCAN算法）来进行电梯调度。</p>\n</li>\n</ul>\n<h2 id=\"扫描算法介绍\"><a href=\"#扫描算法介绍\" class=\"headerlink\" title=\"扫描算法介绍\"></a>扫描算法介绍</h2><ul>\n<li><p>简介：扫描算法（SCAN）<br>是一种按照楼层顺序依次服务请求，它让电梯在最底层和最顶层之间连续往返运行，在运行过程中响应处在于电梯运行方向相同的各楼层上的请求。</p>\n</li>\n<li><p>优点:进行寻找楼层的优化，效率比较高。较好地解决了电梯移动的问题，在这个算法中，每个电梯响应乘客请求使乘客获得服务的次序是由其发出请求的乘客的位置与当前电梯位置之间的距离来决定的。所有的与电梯运行方向相同的乘客的请求在一次电向上运行或向下运行的过程中完成，免去了电梯频繁的来回移动。</p>\n</li>\n<li><p>缺点:扫描算法是一个非实时算法，他的平均响应时间较长。</p>\n</li>\n</ul>\n<h2 id=\"项目多线程\"><a href=\"#项目多线程\" class=\"headerlink\" title=\"项目多线程\"></a>项目多线程</h2><blockquote>\n<p>  计划在项目中通过implement<br>  Runnable接口来实现多线程，之后重写里面的run（）方法。并且通过new<br>  Thread(该类).start()来开启一条多线程。</p>\n</blockquote>\n<blockquote>\n<p>  其中，电梯要采用多线程方式启动以此实现调度，并且电梯调度控制类也需要以多线程方式调度，以此实时监听任务并且调度电梯。除此之外，在电梯视图控制类也需要多线程方式启动，以此实时监听并且控制画面刷新。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/b2b901b25dc6a7e6a874f48b8c59ce66.png\"></p>\n<h2 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"></a>项目架构</h2><ul>\n<li><p>总体采用三层架构,分别是实体层，展示层,控制层。</p>\n</li>\n<li><p>实体层中有三个类，Const类负责存储项目的各种常量，Elevator类负责创建电梯实体，Task类则负责存储实际需求任务。</p>\n</li>\n<li><p>展示层则负责页面的展示，共有三个类，View负责展示整体画面。ElevatorView负责展示电梯内部的按钮，ElevatorOutView负责展示每层楼电梯外部按钮。</p>\n</li>\n<li><p>控制层负责控制事件触发以及调度算法执行。ElevatorOutViewControl负责电梯按钮触发事件以及动态刷新页面等等。ElevatorsControl则根据SCAN算法负责对所有触发的任务进行电梯调度。</p>\n</li>\n<li><p>最后，MainTest是函数的入口，负责以多线程的方式启动ElevatorsControl类，并且启动整个视图View。</p>\n</li>\n</ul>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/70cf77f8256087dc81a91e8107406d60.jpg\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9538497173b402aa0e037e6ff47396bb.png\"></p>\n<h1 id=\"项目实现\"><a href=\"#项目实现\" class=\"headerlink\" title=\"项目实现\"></a>项目实现</h1><h2 id=\"domain包下类实现\"><a href=\"#domain包下类实现\" class=\"headerlink\" title=\"domain包下类实现\"></a>domain包下类实现</h2><h3 id=\"Const类实现\"><a href=\"#Const类实现\" class=\"headerlink\" title=\"Const类实现\"></a>Const类实现</h3><blockquote>\n<p>  该类存储了项目需要的一些全局变量。例如电梯数量，楼层高度；各种视图的位置大小等，还有用UP，DOWN，STOP来代表电梯状态。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d0120d5480182e8f69bfd07dfa2fd1a6.png\"></p>\n<h3 id=\"Elevator类实现\"><a href=\"#Elevator类实现\" class=\"headerlink\" title=\"Elevator类实现\"></a>Elevator类实现</h3><blockquote>\n<p>  定义了电梯序号，当前该电梯所处位置，以及当前状态，例如UP,DOWN等。而且该类实现了Runnable接口，实现run（）方法，之后调度时就可以以多线程方式启动电梯。</p>\n</blockquote>\n<blockquote>\n<p>  部分代码如下（下同）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e08e56b4c83ab8265608e3d0a79e063e.png\"></p>\n<h3 id=\"Task类实现\"><a href=\"#Task类实现\" class=\"headerlink\" title=\"Task类实现\"></a>Task类实现</h3><blockquote>\n<p>  该类主要提供要操作的任务，共有三个变量：需要上行还是下行；当前位置，要去的位置。该类在电梯内外都能使用，当在电梯外时，to即要去的位置设置为-1即可。并且提供set，get方法，以及构造函数等。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3422a76f6d2b8aba3ae47056ba2c67a9.png\"></p>\n<h2 id=\"view包下类实现\"><a href=\"#view包下类实现\" class=\"headerlink\" title=\"view包下类实现\"></a>view包下类实现</h2><h3 id=\"ElevatorView类实现\"><a href=\"#ElevatorView类实现\" class=\"headerlink\" title=\"ElevatorView类实现\"></a>ElevatorView类实现</h3><blockquote>\n<p>  该类通过继承Jpanel类来负责展示电梯内部视图，例如开门关门按钮，要去的楼层按钮等，并且对按钮提供了事件监听。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/64634ad3a094fc1d7bf04f2db86e2f1b.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/619067c8f9591193ea1958173259060d.png\"></p>\n<h3 id=\"ElevatorOutView类实现\"><a href=\"#ElevatorOutView类实现\" class=\"headerlink\" title=\"ElevatorOutView类实现\"></a>ElevatorOutView类实现</h3><blockquote>\n<p>  该类也继承了Jpanel，负责展示楼层间的电梯外部视图。主要有上升下降按钮，以及显示电梯状态以及位置的文本。还包含了一个ElevatorControl类对象，以为需要得到里面的电梯对象。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/619067c8f9591193ea1958173259060d.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d9e7185cf83f3e64ff58f4be3f9a9e92.png\"></p>\n<h3 id=\"View类实现\"><a href=\"#View类实现\" class=\"headerlink\" title=\"View类实现\"></a>View类实现</h3><blockquote>\n<p>  该类是视图的最外层，负责展示其他组件，如电梯内部，外部视图等。它通过继承Jframe类实现该功能。他可以调用ElevatorView类与ElevatorOutView类来批量创造电梯内外视图，达到最终效果。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/faa67568b8f558e807cad36c271373fb.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8fb4d6f9147a4466562fedfefb942b82.png\"></p>\n<h2 id=\"control包下类实现\"><a href=\"#control包下类实现\" class=\"headerlink\" title=\"control包下类实现\"></a>control包下类实现</h2><h3 id=\"ElevatorOutViewControl类实现\"><a href=\"#ElevatorOutViewControl类实现\" class=\"headerlink\" title=\"ElevatorOutViewControl类实现\"></a>ElevatorOutViewControl类实现</h3><blockquote>\n<p>  该类主要有两个功能,一是对外部电梯按钮进行事件监听,并且向控制器添加任务,<br>  二是对外部电梯标签进行刷新,以标识电梯目前的位置以及状态。</p>\n</blockquote>\n<blockquote>\n<p>  首先初始化时，会创建20*5个ElevatorOutView对象，代表每层楼，每个电梯都有一个外部视图。其次，会分别给所有ElevatorOutView对象的开门关门键提供事件监听，当按下按钮时，会在控制器中添加任务，并且同楼层的电梯的相同方向按钮会同时变红，代表被按下。</p>\n</blockquote>\n<blockquote>\n<p>  该类也实现了Runnable接口，在run方法中，每隔100ms刷新页面，将最新的电梯状态展示，并且将已完成任务从control类控制列表中删除。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f1fad668c43ca41ee9b665f51f0f3963.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ba53b196d33be1fa43db04190cfcb19f.png\"></p>\n<h3 id=\"ElevatorsControl类实现\"><a href=\"#ElevatorsControl类实现\" class=\"headerlink\" title=\"ElevatorsControl类实现\"></a>ElevatorsControl类实现</h3><blockquote>\n<p>  负责电梯的实际调度，当没有任务时，电梯将静止不动。有任务时，电梯将持续的往返扫描运行，并且将Elevator对象中的location每秒向上或向下改变1楼（取决于当前电梯运行的状态）。且设置有1个任务则第一个电梯运行，有两个则前两个电梯运行..大于5个任务则所有电梯都不断扫描运行。因为会在ElevatorOutViewControl对象中实时响应任务，所有任务会实时更新，而电梯状态也会实时更新。例如当任务数量从5变为4时，则电梯5将变为静止状态。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4ff18f1c272f4f3db3ccb6cf2b7c7f1c.png\"></p>\n<h1 id=\"项目界面展示\"><a href=\"#项目界面展示\" class=\"headerlink\" title=\"项目界面展示\"></a>项目界面展示</h1><h2 id=\"总体界面展示\"><a href=\"#总体界面展示\" class=\"headerlink\" title=\"总体界面展示\"></a>总体界面展示</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e5a65a44d44fe8c757ece5a49751a127.png\"></p>\n<blockquote>\n<p>  左边为五部电梯的内部视图，灰色标签表明具体是哪部电梯的内部视图，其中按钮则分别是要去的楼层，报警键，开门关门键。</p>\n</blockquote>\n<blockquote>\n<p>  右边则是楼层视图，以行来分析，则一行中，最左边是楼层高度，其次是电梯在该楼层的上行下行按钮以及电梯的状态和电梯目前的位置（因为初始在1楼而且为静止状态，所以显示为∎1）。因为有五个电梯，所以有5个电梯的按钮及状态显示。共有20行，代表20楼，每行为每楼可进行的按钮。</p>\n</blockquote>\n<blockquote>\n<p>  以一列来看，则每一列代表了每个电梯在各个楼层的上下行操作按钮，以及电梯状态，因为为同一个电梯，所以每一列的电梯状态都相同，标志了该电梯目前的状态以及该电梯所处的楼层。因为有五个电梯，所以有五列。</p>\n</blockquote>\n<h2 id=\"电梯运行界面展示\"><a href=\"#电梯运行界面展示\" class=\"headerlink\" title=\"电梯运行界面展示\"></a>电梯运行界面展示</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3d2b3c03c8da120f68f0ffe0d11c87eb.png\"></p>\n<blockquote>\n<p>  如图为按下了2个上楼,2个下楼按钮的电梯图,可以看出,同楼层按钮是互联结的,并且此时一号电梯处于上升状态,且目前在7楼,其他电梯同理。注意，此时电梯5处于静止状态，并且在一楼。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/dc70bb469eeae097811a17de09f26d21.png\"></p>\n<blockquote>\n<p>  接上图，在电梯上行的时候，处理了楼层8，楼层11的上行请求，所以上行请求消失。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/685efb1e717ce692a1656e1387baabf6.png\"></p>\n<blockquote>\n<p>  如图，因为电梯1下行，处理完了两个下行请求。且之后没有任务时，就处于静止状态。</p>\n</blockquote>\n<h2 id=\"电梯内部按钮界面\"><a href=\"#电梯内部按钮界面\" class=\"headerlink\" title=\"电梯内部按钮界面\"></a>电梯内部按钮界面</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3baf35d4b474eacc8b7c6d6f6569dbda.png\"></p>\n<blockquote>\n<p>  如图，电梯内部按钮都可以按下,如选择哪层楼，开门关门等。</p>\n</blockquote>\n<h1 id=\"项目实现情况与可行性分析\"><a href=\"#项目实现情况与可行性分析\" class=\"headerlink\" title=\"项目实现情况与可行性分析\"></a>项目实现情况与可行性分析</h1><h2 id=\"实现情况\"><a href=\"#实现情况\" class=\"headerlink\" title=\"实现情况\"></a>实现情况</h2><ul>\n<li><p>实现多线程电梯及实现Scan电梯调度算法。</p>\n</li>\n<li><p>五部电梯门口的按钮是互联结的，实现同时按下。</p>\n</li>\n<li><p>楼层和电梯数可设置。</p>\n</li>\n<li><p>所有电梯初始状态都在第一层。</p>\n</li>\n<li><p>每个电梯如果在它的上层或者下层没有相应请求情况下，则保持不动。</p>\n</li>\n<li><p>每个电梯里面设置必要功能键。</p>\n</li>\n<li><p>每层楼的每部电梯门口，有上行和下行按钮和当前电梯状态的数码显示器。</p>\n</li>\n<li><p>只能在楼层等待电梯时发出任务请求。进入电梯内部后不能操纵电梯内部按钮（如开门，关门，上升下降到某层楼等）。</p>\n</li>\n</ul>\n<h2 id=\"可行性分析\"><a href=\"#可行性分析\" class=\"headerlink\" title=\"可行性分析\"></a>可行性分析</h2><ul>\n<li><p>该项目基本实现了电梯的调度功能，基本能完成需求</p>\n</li>\n<li><p>没有实现进入电梯内部后的任务请求调度，只能是进入电梯后等待电梯不断上下扫描到达目的地。</p>\n</li>\n<li><p>调度算法不够合理，电梯只会不断上下扫描，响应可能会比较久。例如当所有电梯都处于8楼，而且是上行时。此时如果在7楼新提出了一个上行请求时，电梯会先上升到顶楼，再下到1楼，再上升到7楼才会响应这个请求。但幸运的是，这种情况出现的概率比较小，因为有5辆电梯。他们大概率处于不同的状态，或者是静止状态，所以能很快做出响应。</p>\n</li>\n<li><p>没有考虑到电梯人数超载问题</p>\n</li>\n</ul>\n"},{"title":"项目------操作系统_内存管理项目","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"操作系统_内存管理项目。一个简单的Java项目，主要是模拟操作系统的内存管理过程。","abbrlink":"8f00f39","date":"2020-05-20T16:00:00.000Z","_content":"\n# [内存管理源码_Github地址](https://github.com/tongji4m3/memoryProject)\n#  项目目的\n\n-   动态分区分配方式\n\n    -   数据结构、分配算法\n\n    -   加深对动态分区存储管理方式及其实现过程的理解。\n\n-   请求分区分配方式\n\n    -   页面、页表、地址转换\n\n    -   页面置换过程\n\n    -   加深对请求调页系统的原理和实现过程的理解\n\n#  项目需求\n\n##   动态分区分配方式的模拟\n\n-   要求:\n\n>   假设初始态下，可用内存空间为640K，并有下列请求序列，请分别用首次适应算法和最佳适应算法进行内存块的分配和回收，并显示出每次分配和回收后的空闲分区链的情况来。\n\n-   请求序列:\n\n>   作业1申请130K\n\n>   作业2申请60K\n\n>   作业3申请100k\n\n>   作业2释放60K\n\n>   作业4申请200K\n\n>   作业3释放100K\n\n>   作业1释放130K\n\n>   作业5申请140K\n\n>   作业6申请60K\n\n>   作业7申请50K\n\n>   作业6释放60K\n\n##  请求调页存储管理方式模拟\n\n-   内容\n\n>   假设每个页面可存放10条指令，分配给一个作业的内存块为4。模拟一个作业的执行过程，该作业有320条指令，即它的地址空间为32页，目前所有页还没有调入内存。\n\n-   模拟过程\n\n-   在模拟过程中，如果所访问指令在内存中，则显示其物理地址，并转到下一条指令；如果没有在内存中，则发生缺页，此时需要记录缺页次数，并将其调入内存。如果4个内存块中已装入作业，则需进行页面置换。\n\n-   所有320条指令执行完成后，计算并显示作业执行过程中发生的缺页率。\n\n-   置换算法可以选用FIFO或者LRU算法\n\n-   作业中指令访问次序可以按照下面原则形成:50%的指令是顺序执行的，25%是均匀分布在前地址部分，25％是均匀分布在后地址部分\n\n-   具体实施方法(参考):\n\n-   在0－319条指令之间，随机选取一个起始执行指令，如序号为m\n\n-   顺序执行下一条指令，即序号为m+1的指令\n\n-   通过随机数，跳转到前地址部分0－m-1中的某个指令处，其序号为m1\n\n-   顺序执行下一条指令，即序号为m1+1的指令\n\n-   通过随机数，跳转到后地址部分m1+2\\~319中的某条指令处，其序号为m2\n\n-   顺序执行下一条指令，即m2+1处的指令。\n\n-   重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直到执行完320条指令。\n\n#  项目设计及算法\n\n## 项目整体结构\n\n本项目是采用java语言开发的，通过命令行互动的内存管理项目。主要分为2个包(dynamic,request)和一个主类MainTest。通过主类的main函数选择相应的算法进行模拟。\n\n其中的dynamic包主要是完成对动态分区分配的模拟，他有两个子包，一个是存储实体的domain包，里面包括了要执行的作业（Task类），以及空闲分区链中的每一项(FreeItem)。而另一个子包algorithm中，有一个类FitAlgorithm,抽取了FF和BF的整个流程里面重复的代码片段。并且他可以根据选择的参数，来决定调用首次适应算法（BF类）还是最佳适应算法（FF类）中的方法。\n\n而request包主要是完成请求调页方式的模拟，也有两个子包domain以及algorithm。在domain包中有两个类，PageItem类主要负责存储页表中的项，InstructionSequence则负责提供一组特定规则的随机序列，模拟指令。而algorithm包中，只有一个类requestPage，负责完成请求调页方式模拟的逻辑以及展示页面。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d0e3fe82479fd4fb3080a5a5e1c7d55b.png)\n\n## 首次适应算法\n\n-   实现：根据空闲分区链中地址从低到高的顺序，从空闲分区链的第一个地址找起，把最先能够满足要求的空闲区分配给作业。如果满足要求的空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。\n\n-   优点:查找时间短，算法开销小，回收分区后不需要对空闲分区队列重新排序，综合性能最好。\n\n-   缺点:低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销。\n\n##  最佳适应算法\n\n-   实现：通常是采用空闲分区以容量递增的顺序排列，每次选择容量最小的能满足需求的空闲分区。但我的具体实现是从按地址递增的空闲分区链中,先筛选出符合条件的空闲分区,再从中找到最小的一个空闲分区，如果该空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。因为这样可以不用对空闲分区按照容量递增排序，可以复用FF中的分区回收算法。\n\n-   优点:优先使用更小的分区，保留更多的大分区，所以会有更多的大分区保留下来，更能满足大进程的需求。\n\n-   缺点:会留下许多难以利用的，很小的空闲分区，称为碎片碎片。每次都要找到最小的可用的空闲分区，算法的开销大。\n\n##  LRU置换算法\n\n-   实现：在每一个页表项的访问字段中记录了上次访问时间（用一个不断递增的变量实现）。当内存块中已经满了，需要置换时，\n    就查看内存块里面的四个页面，根据访问字段选取出最近最久未使用的页面，并且模拟调出内存，再把所需要的页面调入内存（实际上就是在对应的内存块数组中放入该页面的索引），并且把该页面访问时间改为最新的。\n\n-   优点:性能很好，缺页率较低，是局部性原理的合理近似，\n\n-   缺点:算法开销较大，需要记录页面使用时间的先后关系，硬件开销太大。\n\n#  项目实现\n\n##  MainTest类实现\n\n>   通过命令行输入的参数，选择对应的算法进行模拟。其中，1表示选择首次适应算法，2表示选择最佳适应算法，3表示进行请求调页存储管理方式模拟。\n\n>   其中，选择1和2将使用FitAlgorithm类并且传入该参数来选择首次适应算法，或者最佳适应算法。选择3则使用RequestPage类进行请求调页方式模拟。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/55475d0b605c779c4904f5382947faf7.png)\n\n##  dynamic包下类实现\n\n###  Task类实现\n\n>   实体类，字段包含了作业名称，进行的操作（释放/申请），释放/申请的内存大小。并且重写了toString方法，使得展示更符合阅读规范。\n\n>   该类有一个静态方法，getTask，将存储了一系列的任务列表封装成链表并返回。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/39f5702ea2f2f5b06f3762634a5de6ac.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/6072930d7d7c4d44c763e3039d6edb13.png)\n\n###  FreeItem类实现\n\n>   该类也是实体类，有三个字段，分别是空闲分区的起始地址，长度，以及分配情况（未分配，或者分配给了哪一个作业）。同样重写了toString()方法，使得格式更加整齐。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/6c98c1f5062c26c75f7fc8e317746285.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/81019078308e9a96ee5c8e3352cf1f61.png)\n\n###  FitAlgorithm类实现\n\n>   该类负责实现动态分区分配的具体逻辑，并且通过传入参数选择FF或者BF算法进行内存分配。\n\n>   首先，初始化空闲分区链，已分配分区链，并且从Task类中拿到具体的任务要求。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2fc55d3ae09686706127c470c8424bc9.png)\n\n>   然后每次从任务列表中取出第一条任务，根据该任务需要申请/释放内存进行相应操作（下面会讲），然后打印出空闲分区链及已分配分区链此时的情况。每间隔两秒循环一次，直到任务列表为空。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/b54aeb5a1851c9e0bf8a653ae19bb3cc.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/394e1dd3e381d7c937a5faacf8dc6991.png)\n\n>   任务如果进行的是释放操作，则首先从已分配分区表中得到该作业在内存中的起始地址以及大小，随后在空闲分区表中释放该区域内存。但是这样一共有四种情况：\n>   1.释放该作业内存后和后面的空闲分区相连,2.释放该作业内存后和前面的空闲分区相连,3.\n>   释放该作业内存后和前面以及后面的空闲分区连成一大块,4释放的该作业内存和前后空闲分区都不相连。(需要考虑是否存在前后空闲分区的情况)。\n\n>   四种情况示意图如下：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9e0be407bff7128705dd54b2bdf0e8cd.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/87b03cf926c8a919f2f8b3aa5b225702.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1db0d7a3c1095736db718dfc17016277.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/addd2254cb6cad29ef4e555a38896bca.png)\n\n>   任务如果是申请操作，则根据之前在main函数选择的数字来采取对应的算法（FF或者BF）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/a8e8cdfc194b64de62874f63a3e546c7.png)\n\n###  FF类实现\n\n>   采取首次适应算法进行内存分配，主要实现在静态函数ff中。根据空闲分区链中地址从低到高的顺序，从空闲分区链的第一个地址找起，把最先能够满足要求的空闲区分配给作业。如果满足要求的空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/6676b7082e5ff71f0c30d7993dc9de3a.png)\n\n###  BF类实现\n\n>   采取最佳适应算法进行内存分配，主要实现在静态函数bf中。从按地址递增的空闲分区链中,先筛选出符合条件的空闲分区,再从中找到最小的一个空闲分区，如果该空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1e9dcb8919ac79588d66666235616c24.png)\n\n##  request包下类实现\n\n###  InstructionSequence类实现\n\n>   主要作用是根据ppt的方式,得到指令序列.并且是通过伪随机数,每次都得到同样的一组随机数,便于测试与复现。\n\n>   大致先随机选取作业中的一条指令，并且按顺序得到下一条指令，随后不断循环，重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直到得到320条指令（最后两条指令由于数组大小原因，选择了随机某条指令以及按顺序的下一条指令）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e8f1c50bd23c6834f5ba6374ff13cf9d.png)\n\n### PageItem类实现\n\n>   该类是实体类，代表了页表中的页表项，有四个字段：页号，内存块号（-1代表不在内存中），状态（true代表在内存中，false代表不在内存中），访问字段（记录上次访问时间，以实现LRU算法）。初始化中，所有页面都不在内存中，最久访问字段也设置为-1。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/11dd591286f905e60f7ed914a221b8f7.png)\n\n### RequestPage类实现\n\n>   该类实现请求调页的主要功能。首先定义了缺页次数字段，已经最近访问时间visitCount(初始化为0,每次访问页面后赋值到页面的访问字段并且+1)，并且初始化了该作业的32个页面。并且初始化分配给该作业的4个内存块（开始内存块中无页面）。随后通过之前的InstructionSequence类得到了指令序列。随后就对指令序列的每条指令进行执行（随后会说），最后打印缺页率。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2b74914710aa33e14622215e0e316eca.png)\n\n>   在每条指令的执行过程中，首先先找到该指令所属的页号。如果该页面在内存块中，则打印出指令的物理地址，并且将访问时间设为最近的（visitCount++）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2174614935e27dc4d473a8fed6ce2c55.png)\n\n>   如果缺页了，但是内存块中还有空余位置，则将页面直接放入空闲的内存块中，并且让缺页次数+1，并且设置最近访问时间，而且不需要页面置换。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d287b0087981a986ced3ba6ff2c20bad.png)\n\n>   如果缺页了，并且4个内存块中都装满了作业，则使用LRU算法进行页面置换。首先查看内存块里面的四个页面，根据访问字段选取出最近最久未使用的页面，并且模拟调出内存，再把所需要的页面调入内存（实际上就是在对应的内存块数组中放入该页面的索引），并且把该页面访问时间改为最新的。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ef0b8793e707f6b75da6212d09e13e28.png)\n\n>   最后，展示页表目前的情况，但是由于作业的总页数太大，所以只展示了曾经放入内存块中的页面（通过判断访问时间是否\\>=0实现）。并且还展示了4个内存块里面存储的页面号。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/db9b37208a2e0a329f104c5c30b21f78.png)\n\n#  项目界面展示\n\n## 动态分区分配-FF算法界面展示\n\n>   处理作业1后的情况：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/df6a6335e312d038091dea6a3463e415.png)\n\n>   处理作业2，作业3情况也类似，只截处理完作业3的图:\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/10e2779fe65ed692275f26620b156f25.png)\n\n>   释放作业2内存：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/875cb49b31240357406074307c454a9e.png)\n\n>   作业4申请，作业3，作业1释放后：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4479c4ee520de74517d4932804c2757e.png)\n\n>   作业5申请，这里是FF和BF算法在该作业序列里不一样的地方，FF算法在这里按地址顺序寻找到前面的低地址空闲分区就分配了，但是BF会找到最后的那块容量最小的内存分区进行分配：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/425f09d23162c2d467be3f7d6aa17bfd.png)\n\n>   作业6，作业7申请后：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ee201abca741ee6466f5ea97ea66f686.png)\n\n>   最后一个序列，作业6释放内存：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/04e29ec16f986738cea51c9b16ecf785.png)\n\n## 动态分区分配-BF算法界面展示\n\n>   前面的都和FF算法一样，只是在作业5申请时有了变化，这里找到了容量较小的空闲分区进行分配：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/888b21728dd642ae54394740c7cfe12c.png)\n\n>   作业6，作业7申请：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7beb1dc31066e275047d7cf2635192f0.png)\n\n>   最后一条，作业6释放：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/833e9dc938bf5f2bc170ad8db8b5bf9a.png)\n\n>   5.3请求调页-LRU算法界面展示\n\n>   执行第一条指令，116：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/386f3697478d202ba923225ba4dacea2.png)\n\n>   第二条，指令117（之后的指令两两基本同一个页面，所以每隔2条指令截图一次）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ab6e684d1f44ad3e0ad0aa044c5f50f4.png)\n\n>   第三条，指令80：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7777c3ef8f32aef7b3263f067500c3c8.png)\n\n>   第五条，指令250：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/80764683f5943b3fb58b0dd8a506f75c.png)\n\n>   第七条，指令160：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ea3a5a81d2039ab695d954e663f59cb8.png)\n\n>   第九条，指令259（没有缺页，但是更新了访问时间）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2273642bb1b7703abd15eb43cbb1943c.png)\n\n>   第十条，指令260（虽然和259相连，但是不在同一页上，所以缺页，并且发生页面置换。替换最近未访问的页号11，且页号11状态标志为不在内存块中）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/c3f8eaff0646ace444b67bb1ab793a22.png)\n\n>   第十一条，指令54（缺页，页面置换。替换最久未使用的页面8）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/bbfececf9d264f8072f05286d7e5b533.png)\n\n>   随后的指令基本类似，只截取最后两条指令：\n\n>   指令81：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4553ca7dd481a10d6b5125f57225c080.png)\n\n>   指令82：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/b66e80ebebb962cd6a678cda6d10a7f8.png)\n","source":"_posts/项目笔记/操作系统_内存管理项目.md","raw":"---\ntitle: 项目------操作系统_内存管理项目\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 操作系统_内存管理项目。一个简单的Java项目，主要是模拟操作系统的内存管理过程。\ncategories: 项目文档\ntags:\n  - Java\n  - 操作系统\n  - 内存管理\nabbrlink: 8f00f39\ndate: 2020-05-21 00:00:00\n---\n\n# [内存管理源码_Github地址](https://github.com/tongji4m3/memoryProject)\n#  项目目的\n\n-   动态分区分配方式\n\n    -   数据结构、分配算法\n\n    -   加深对动态分区存储管理方式及其实现过程的理解。\n\n-   请求分区分配方式\n\n    -   页面、页表、地址转换\n\n    -   页面置换过程\n\n    -   加深对请求调页系统的原理和实现过程的理解\n\n#  项目需求\n\n##   动态分区分配方式的模拟\n\n-   要求:\n\n>   假设初始态下，可用内存空间为640K，并有下列请求序列，请分别用首次适应算法和最佳适应算法进行内存块的分配和回收，并显示出每次分配和回收后的空闲分区链的情况来。\n\n-   请求序列:\n\n>   作业1申请130K\n\n>   作业2申请60K\n\n>   作业3申请100k\n\n>   作业2释放60K\n\n>   作业4申请200K\n\n>   作业3释放100K\n\n>   作业1释放130K\n\n>   作业5申请140K\n\n>   作业6申请60K\n\n>   作业7申请50K\n\n>   作业6释放60K\n\n##  请求调页存储管理方式模拟\n\n-   内容\n\n>   假设每个页面可存放10条指令，分配给一个作业的内存块为4。模拟一个作业的执行过程，该作业有320条指令，即它的地址空间为32页，目前所有页还没有调入内存。\n\n-   模拟过程\n\n-   在模拟过程中，如果所访问指令在内存中，则显示其物理地址，并转到下一条指令；如果没有在内存中，则发生缺页，此时需要记录缺页次数，并将其调入内存。如果4个内存块中已装入作业，则需进行页面置换。\n\n-   所有320条指令执行完成后，计算并显示作业执行过程中发生的缺页率。\n\n-   置换算法可以选用FIFO或者LRU算法\n\n-   作业中指令访问次序可以按照下面原则形成:50%的指令是顺序执行的，25%是均匀分布在前地址部分，25％是均匀分布在后地址部分\n\n-   具体实施方法(参考):\n\n-   在0－319条指令之间，随机选取一个起始执行指令，如序号为m\n\n-   顺序执行下一条指令，即序号为m+1的指令\n\n-   通过随机数，跳转到前地址部分0－m-1中的某个指令处，其序号为m1\n\n-   顺序执行下一条指令，即序号为m1+1的指令\n\n-   通过随机数，跳转到后地址部分m1+2\\~319中的某条指令处，其序号为m2\n\n-   顺序执行下一条指令，即m2+1处的指令。\n\n-   重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直到执行完320条指令。\n\n#  项目设计及算法\n\n## 项目整体结构\n\n本项目是采用java语言开发的，通过命令行互动的内存管理项目。主要分为2个包(dynamic,request)和一个主类MainTest。通过主类的main函数选择相应的算法进行模拟。\n\n其中的dynamic包主要是完成对动态分区分配的模拟，他有两个子包，一个是存储实体的domain包，里面包括了要执行的作业（Task类），以及空闲分区链中的每一项(FreeItem)。而另一个子包algorithm中，有一个类FitAlgorithm,抽取了FF和BF的整个流程里面重复的代码片段。并且他可以根据选择的参数，来决定调用首次适应算法（BF类）还是最佳适应算法（FF类）中的方法。\n\n而request包主要是完成请求调页方式的模拟，也有两个子包domain以及algorithm。在domain包中有两个类，PageItem类主要负责存储页表中的项，InstructionSequence则负责提供一组特定规则的随机序列，模拟指令。而algorithm包中，只有一个类requestPage，负责完成请求调页方式模拟的逻辑以及展示页面。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d0e3fe82479fd4fb3080a5a5e1c7d55b.png)\n\n## 首次适应算法\n\n-   实现：根据空闲分区链中地址从低到高的顺序，从空闲分区链的第一个地址找起，把最先能够满足要求的空闲区分配给作业。如果满足要求的空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。\n\n-   优点:查找时间短，算法开销小，回收分区后不需要对空闲分区队列重新排序，综合性能最好。\n\n-   缺点:低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销。\n\n##  最佳适应算法\n\n-   实现：通常是采用空闲分区以容量递增的顺序排列，每次选择容量最小的能满足需求的空闲分区。但我的具体实现是从按地址递增的空闲分区链中,先筛选出符合条件的空闲分区,再从中找到最小的一个空闲分区，如果该空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。因为这样可以不用对空闲分区按照容量递增排序，可以复用FF中的分区回收算法。\n\n-   优点:优先使用更小的分区，保留更多的大分区，所以会有更多的大分区保留下来，更能满足大进程的需求。\n\n-   缺点:会留下许多难以利用的，很小的空闲分区，称为碎片碎片。每次都要找到最小的可用的空闲分区，算法的开销大。\n\n##  LRU置换算法\n\n-   实现：在每一个页表项的访问字段中记录了上次访问时间（用一个不断递增的变量实现）。当内存块中已经满了，需要置换时，\n    就查看内存块里面的四个页面，根据访问字段选取出最近最久未使用的页面，并且模拟调出内存，再把所需要的页面调入内存（实际上就是在对应的内存块数组中放入该页面的索引），并且把该页面访问时间改为最新的。\n\n-   优点:性能很好，缺页率较低，是局部性原理的合理近似，\n\n-   缺点:算法开销较大，需要记录页面使用时间的先后关系，硬件开销太大。\n\n#  项目实现\n\n##  MainTest类实现\n\n>   通过命令行输入的参数，选择对应的算法进行模拟。其中，1表示选择首次适应算法，2表示选择最佳适应算法，3表示进行请求调页存储管理方式模拟。\n\n>   其中，选择1和2将使用FitAlgorithm类并且传入该参数来选择首次适应算法，或者最佳适应算法。选择3则使用RequestPage类进行请求调页方式模拟。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/55475d0b605c779c4904f5382947faf7.png)\n\n##  dynamic包下类实现\n\n###  Task类实现\n\n>   实体类，字段包含了作业名称，进行的操作（释放/申请），释放/申请的内存大小。并且重写了toString方法，使得展示更符合阅读规范。\n\n>   该类有一个静态方法，getTask，将存储了一系列的任务列表封装成链表并返回。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/39f5702ea2f2f5b06f3762634a5de6ac.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/6072930d7d7c4d44c763e3039d6edb13.png)\n\n###  FreeItem类实现\n\n>   该类也是实体类，有三个字段，分别是空闲分区的起始地址，长度，以及分配情况（未分配，或者分配给了哪一个作业）。同样重写了toString()方法，使得格式更加整齐。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/6c98c1f5062c26c75f7fc8e317746285.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/81019078308e9a96ee5c8e3352cf1f61.png)\n\n###  FitAlgorithm类实现\n\n>   该类负责实现动态分区分配的具体逻辑，并且通过传入参数选择FF或者BF算法进行内存分配。\n\n>   首先，初始化空闲分区链，已分配分区链，并且从Task类中拿到具体的任务要求。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2fc55d3ae09686706127c470c8424bc9.png)\n\n>   然后每次从任务列表中取出第一条任务，根据该任务需要申请/释放内存进行相应操作（下面会讲），然后打印出空闲分区链及已分配分区链此时的情况。每间隔两秒循环一次，直到任务列表为空。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/b54aeb5a1851c9e0bf8a653ae19bb3cc.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/394e1dd3e381d7c937a5faacf8dc6991.png)\n\n>   任务如果进行的是释放操作，则首先从已分配分区表中得到该作业在内存中的起始地址以及大小，随后在空闲分区表中释放该区域内存。但是这样一共有四种情况：\n>   1.释放该作业内存后和后面的空闲分区相连,2.释放该作业内存后和前面的空闲分区相连,3.\n>   释放该作业内存后和前面以及后面的空闲分区连成一大块,4释放的该作业内存和前后空闲分区都不相连。(需要考虑是否存在前后空闲分区的情况)。\n\n>   四种情况示意图如下：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9e0be407bff7128705dd54b2bdf0e8cd.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/87b03cf926c8a919f2f8b3aa5b225702.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1db0d7a3c1095736db718dfc17016277.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/addd2254cb6cad29ef4e555a38896bca.png)\n\n>   任务如果是申请操作，则根据之前在main函数选择的数字来采取对应的算法（FF或者BF）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/a8e8cdfc194b64de62874f63a3e546c7.png)\n\n###  FF类实现\n\n>   采取首次适应算法进行内存分配，主要实现在静态函数ff中。根据空闲分区链中地址从低到高的顺序，从空闲分区链的第一个地址找起，把最先能够满足要求的空闲区分配给作业。如果满足要求的空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/6676b7082e5ff71f0c30d7993dc9de3a.png)\n\n###  BF类实现\n\n>   采取最佳适应算法进行内存分配，主要实现在静态函数bf中。从按地址递增的空闲分区链中,先筛选出符合条件的空闲分区,再从中找到最小的一个空闲分区，如果该空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1e9dcb8919ac79588d66666235616c24.png)\n\n##  request包下类实现\n\n###  InstructionSequence类实现\n\n>   主要作用是根据ppt的方式,得到指令序列.并且是通过伪随机数,每次都得到同样的一组随机数,便于测试与复现。\n\n>   大致先随机选取作业中的一条指令，并且按顺序得到下一条指令，随后不断循环，重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直到得到320条指令（最后两条指令由于数组大小原因，选择了随机某条指令以及按顺序的下一条指令）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e8f1c50bd23c6834f5ba6374ff13cf9d.png)\n\n### PageItem类实现\n\n>   该类是实体类，代表了页表中的页表项，有四个字段：页号，内存块号（-1代表不在内存中），状态（true代表在内存中，false代表不在内存中），访问字段（记录上次访问时间，以实现LRU算法）。初始化中，所有页面都不在内存中，最久访问字段也设置为-1。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/11dd591286f905e60f7ed914a221b8f7.png)\n\n### RequestPage类实现\n\n>   该类实现请求调页的主要功能。首先定义了缺页次数字段，已经最近访问时间visitCount(初始化为0,每次访问页面后赋值到页面的访问字段并且+1)，并且初始化了该作业的32个页面。并且初始化分配给该作业的4个内存块（开始内存块中无页面）。随后通过之前的InstructionSequence类得到了指令序列。随后就对指令序列的每条指令进行执行（随后会说），最后打印缺页率。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2b74914710aa33e14622215e0e316eca.png)\n\n>   在每条指令的执行过程中，首先先找到该指令所属的页号。如果该页面在内存块中，则打印出指令的物理地址，并且将访问时间设为最近的（visitCount++）。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2174614935e27dc4d473a8fed6ce2c55.png)\n\n>   如果缺页了，但是内存块中还有空余位置，则将页面直接放入空闲的内存块中，并且让缺页次数+1，并且设置最近访问时间，而且不需要页面置换。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d287b0087981a986ced3ba6ff2c20bad.png)\n\n>   如果缺页了，并且4个内存块中都装满了作业，则使用LRU算法进行页面置换。首先查看内存块里面的四个页面，根据访问字段选取出最近最久未使用的页面，并且模拟调出内存，再把所需要的页面调入内存（实际上就是在对应的内存块数组中放入该页面的索引），并且把该页面访问时间改为最新的。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ef0b8793e707f6b75da6212d09e13e28.png)\n\n>   最后，展示页表目前的情况，但是由于作业的总页数太大，所以只展示了曾经放入内存块中的页面（通过判断访问时间是否\\>=0实现）。并且还展示了4个内存块里面存储的页面号。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/db9b37208a2e0a329f104c5c30b21f78.png)\n\n#  项目界面展示\n\n## 动态分区分配-FF算法界面展示\n\n>   处理作业1后的情况：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/df6a6335e312d038091dea6a3463e415.png)\n\n>   处理作业2，作业3情况也类似，只截处理完作业3的图:\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/10e2779fe65ed692275f26620b156f25.png)\n\n>   释放作业2内存：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/875cb49b31240357406074307c454a9e.png)\n\n>   作业4申请，作业3，作业1释放后：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4479c4ee520de74517d4932804c2757e.png)\n\n>   作业5申请，这里是FF和BF算法在该作业序列里不一样的地方，FF算法在这里按地址顺序寻找到前面的低地址空闲分区就分配了，但是BF会找到最后的那块容量最小的内存分区进行分配：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/425f09d23162c2d467be3f7d6aa17bfd.png)\n\n>   作业6，作业7申请后：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ee201abca741ee6466f5ea97ea66f686.png)\n\n>   最后一个序列，作业6释放内存：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/04e29ec16f986738cea51c9b16ecf785.png)\n\n## 动态分区分配-BF算法界面展示\n\n>   前面的都和FF算法一样，只是在作业5申请时有了变化，这里找到了容量较小的空闲分区进行分配：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/888b21728dd642ae54394740c7cfe12c.png)\n\n>   作业6，作业7申请：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7beb1dc31066e275047d7cf2635192f0.png)\n\n>   最后一条，作业6释放：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/833e9dc938bf5f2bc170ad8db8b5bf9a.png)\n\n>   5.3请求调页-LRU算法界面展示\n\n>   执行第一条指令，116：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/386f3697478d202ba923225ba4dacea2.png)\n\n>   第二条，指令117（之后的指令两两基本同一个页面，所以每隔2条指令截图一次）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ab6e684d1f44ad3e0ad0aa044c5f50f4.png)\n\n>   第三条，指令80：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7777c3ef8f32aef7b3263f067500c3c8.png)\n\n>   第五条，指令250：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/80764683f5943b3fb58b0dd8a506f75c.png)\n\n>   第七条，指令160：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ea3a5a81d2039ab695d954e663f59cb8.png)\n\n>   第九条，指令259（没有缺页，但是更新了访问时间）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2273642bb1b7703abd15eb43cbb1943c.png)\n\n>   第十条，指令260（虽然和259相连，但是不在同一页上，所以缺页，并且发生页面置换。替换最近未访问的页号11，且页号11状态标志为不在内存块中）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/c3f8eaff0646ace444b67bb1ab793a22.png)\n\n>   第十一条，指令54（缺页，页面置换。替换最久未使用的页面8）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/bbfececf9d264f8072f05286d7e5b533.png)\n\n>   随后的指令基本类似，只截取最后两条指令：\n\n>   指令81：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4553ca7dd481a10d6b5125f57225c080.png)\n\n>   指令82：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/b66e80ebebb962cd6a678cda6d10a7f8.png)\n","slug":"项目笔记/操作系统_内存管理项目","published":1,"updated":"2020-11-12T11:57:30.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6z6008wjotp0049hc9u","content":"<h1 id=\"内存管理源码-Github地址\"><a href=\"#内存管理源码-Github地址\" class=\"headerlink\" title=\"内存管理源码_Github地址\"></a><a href=\"https://github.com/tongji4m3/memoryProject\" target=\"_blank\" rel=\"noopener\">内存管理源码_Github地址</a></h1><h1 id=\"项目目的\"><a href=\"#项目目的\" class=\"headerlink\" title=\"项目目的\"></a>项目目的</h1><ul>\n<li><p>动态分区分配方式</p>\n<ul>\n<li><p>数据结构、分配算法</p>\n</li>\n<li><p>加深对动态分区存储管理方式及其实现过程的理解。</p>\n</li>\n</ul>\n</li>\n<li><p>请求分区分配方式</p>\n<ul>\n<li><p>页面、页表、地址转换</p>\n</li>\n<li><p>页面置换过程</p>\n</li>\n<li><p>加深对请求调页系统的原理和实现过程的理解</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"项目需求\"><a href=\"#项目需求\" class=\"headerlink\" title=\"项目需求\"></a>项目需求</h1><h2 id=\"动态分区分配方式的模拟\"><a href=\"#动态分区分配方式的模拟\" class=\"headerlink\" title=\"动态分区分配方式的模拟\"></a>动态分区分配方式的模拟</h2><ul>\n<li>要求:</li>\n</ul>\n<blockquote>\n<p>  假设初始态下，可用内存空间为640K，并有下列请求序列，请分别用首次适应算法和最佳适应算法进行内存块的分配和回收，并显示出每次分配和回收后的空闲分区链的情况来。</p>\n</blockquote>\n<ul>\n<li>请求序列:</li>\n</ul>\n<blockquote>\n<p>  作业1申请130K</p>\n</blockquote>\n<blockquote>\n<p>  作业2申请60K</p>\n</blockquote>\n<blockquote>\n<p>  作业3申请100k</p>\n</blockquote>\n<blockquote>\n<p>  作业2释放60K</p>\n</blockquote>\n<blockquote>\n<p>  作业4申请200K</p>\n</blockquote>\n<blockquote>\n<p>  作业3释放100K</p>\n</blockquote>\n<blockquote>\n<p>  作业1释放130K</p>\n</blockquote>\n<blockquote>\n<p>  作业5申请140K</p>\n</blockquote>\n<blockquote>\n<p>  作业6申请60K</p>\n</blockquote>\n<blockquote>\n<p>  作业7申请50K</p>\n</blockquote>\n<blockquote>\n<p>  作业6释放60K</p>\n</blockquote>\n<h2 id=\"请求调页存储管理方式模拟\"><a href=\"#请求调页存储管理方式模拟\" class=\"headerlink\" title=\"请求调页存储管理方式模拟\"></a>请求调页存储管理方式模拟</h2><ul>\n<li>内容</li>\n</ul>\n<blockquote>\n<p>  假设每个页面可存放10条指令，分配给一个作业的内存块为4。模拟一个作业的执行过程，该作业有320条指令，即它的地址空间为32页，目前所有页还没有调入内存。</p>\n</blockquote>\n<ul>\n<li><p>模拟过程</p>\n</li>\n<li><p>在模拟过程中，如果所访问指令在内存中，则显示其物理地址，并转到下一条指令；如果没有在内存中，则发生缺页，此时需要记录缺页次数，并将其调入内存。如果4个内存块中已装入作业，则需进行页面置换。</p>\n</li>\n<li><p>所有320条指令执行完成后，计算并显示作业执行过程中发生的缺页率。</p>\n</li>\n<li><p>置换算法可以选用FIFO或者LRU算法</p>\n</li>\n<li><p>作业中指令访问次序可以按照下面原则形成:50%的指令是顺序执行的，25%是均匀分布在前地址部分，25％是均匀分布在后地址部分</p>\n</li>\n<li><p>具体实施方法(参考):</p>\n</li>\n<li><p>在0－319条指令之间，随机选取一个起始执行指令，如序号为m</p>\n</li>\n<li><p>顺序执行下一条指令，即序号为m+1的指令</p>\n</li>\n<li><p>通过随机数，跳转到前地址部分0－m-1中的某个指令处，其序号为m1</p>\n</li>\n<li><p>顺序执行下一条指令，即序号为m1+1的指令</p>\n</li>\n<li><p>通过随机数，跳转到后地址部分m1+2~319中的某条指令处，其序号为m2</p>\n</li>\n<li><p>顺序执行下一条指令，即m2+1处的指令。</p>\n</li>\n<li><p>重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直到执行完320条指令。</p>\n</li>\n</ul>\n<h1 id=\"项目设计及算法\"><a href=\"#项目设计及算法\" class=\"headerlink\" title=\"项目设计及算法\"></a>项目设计及算法</h1><h2 id=\"项目整体结构\"><a href=\"#项目整体结构\" class=\"headerlink\" title=\"项目整体结构\"></a>项目整体结构</h2><p>本项目是采用java语言开发的，通过命令行互动的内存管理项目。主要分为2个包(dynamic,request)和一个主类MainTest。通过主类的main函数选择相应的算法进行模拟。</p>\n<p>其中的dynamic包主要是完成对动态分区分配的模拟，他有两个子包，一个是存储实体的domain包，里面包括了要执行的作业（Task类），以及空闲分区链中的每一项(FreeItem)。而另一个子包algorithm中，有一个类FitAlgorithm,抽取了FF和BF的整个流程里面重复的代码片段。并且他可以根据选择的参数，来决定调用首次适应算法（BF类）还是最佳适应算法（FF类）中的方法。</p>\n<p>而request包主要是完成请求调页方式的模拟，也有两个子包domain以及algorithm。在domain包中有两个类，PageItem类主要负责存储页表中的项，InstructionSequence则负责提供一组特定规则的随机序列，模拟指令。而algorithm包中，只有一个类requestPage，负责完成请求调页方式模拟的逻辑以及展示页面。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d0e3fe82479fd4fb3080a5a5e1c7d55b.png\"></p>\n<h2 id=\"首次适应算法\"><a href=\"#首次适应算法\" class=\"headerlink\" title=\"首次适应算法\"></a>首次适应算法</h2><ul>\n<li><p>实现：根据空闲分区链中地址从低到高的顺序，从空闲分区链的第一个地址找起，把最先能够满足要求的空闲区分配给作业。如果满足要求的空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。</p>\n</li>\n<li><p>优点:查找时间短，算法开销小，回收分区后不需要对空闲分区队列重新排序，综合性能最好。</p>\n</li>\n<li><p>缺点:低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销。</p>\n</li>\n</ul>\n<h2 id=\"最佳适应算法\"><a href=\"#最佳适应算法\" class=\"headerlink\" title=\"最佳适应算法\"></a>最佳适应算法</h2><ul>\n<li><p>实现：通常是采用空闲分区以容量递增的顺序排列，每次选择容量最小的能满足需求的空闲分区。但我的具体实现是从按地址递增的空闲分区链中,先筛选出符合条件的空闲分区,再从中找到最小的一个空闲分区，如果该空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。因为这样可以不用对空闲分区按照容量递增排序，可以复用FF中的分区回收算法。</p>\n</li>\n<li><p>优点:优先使用更小的分区，保留更多的大分区，所以会有更多的大分区保留下来，更能满足大进程的需求。</p>\n</li>\n<li><p>缺点:会留下许多难以利用的，很小的空闲分区，称为碎片碎片。每次都要找到最小的可用的空闲分区，算法的开销大。</p>\n</li>\n</ul>\n<h2 id=\"LRU置换算法\"><a href=\"#LRU置换算法\" class=\"headerlink\" title=\"LRU置换算法\"></a>LRU置换算法</h2><ul>\n<li><p>实现：在每一个页表项的访问字段中记录了上次访问时间（用一个不断递增的变量实现）。当内存块中已经满了，需要置换时，<br>就查看内存块里面的四个页面，根据访问字段选取出最近最久未使用的页面，并且模拟调出内存，再把所需要的页面调入内存（实际上就是在对应的内存块数组中放入该页面的索引），并且把该页面访问时间改为最新的。</p>\n</li>\n<li><p>优点:性能很好，缺页率较低，是局部性原理的合理近似，</p>\n</li>\n<li><p>缺点:算法开销较大，需要记录页面使用时间的先后关系，硬件开销太大。</p>\n</li>\n</ul>\n<h1 id=\"项目实现\"><a href=\"#项目实现\" class=\"headerlink\" title=\"项目实现\"></a>项目实现</h1><h2 id=\"MainTest类实现\"><a href=\"#MainTest类实现\" class=\"headerlink\" title=\"MainTest类实现\"></a>MainTest类实现</h2><blockquote>\n<p>  通过命令行输入的参数，选择对应的算法进行模拟。其中，1表示选择首次适应算法，2表示选择最佳适应算法，3表示进行请求调页存储管理方式模拟。</p>\n</blockquote>\n<blockquote>\n<p>  其中，选择1和2将使用FitAlgorithm类并且传入该参数来选择首次适应算法，或者最佳适应算法。选择3则使用RequestPage类进行请求调页方式模拟。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/55475d0b605c779c4904f5382947faf7.png\"></p>\n<h2 id=\"dynamic包下类实现\"><a href=\"#dynamic包下类实现\" class=\"headerlink\" title=\"dynamic包下类实现\"></a>dynamic包下类实现</h2><h3 id=\"Task类实现\"><a href=\"#Task类实现\" class=\"headerlink\" title=\"Task类实现\"></a>Task类实现</h3><blockquote>\n<p>  实体类，字段包含了作业名称，进行的操作（释放/申请），释放/申请的内存大小。并且重写了toString方法，使得展示更符合阅读规范。</p>\n</blockquote>\n<blockquote>\n<p>  该类有一个静态方法，getTask，将存储了一系列的任务列表封装成链表并返回。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/39f5702ea2f2f5b06f3762634a5de6ac.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/6072930d7d7c4d44c763e3039d6edb13.png\"></p>\n<h3 id=\"FreeItem类实现\"><a href=\"#FreeItem类实现\" class=\"headerlink\" title=\"FreeItem类实现\"></a>FreeItem类实现</h3><blockquote>\n<p>  该类也是实体类，有三个字段，分别是空闲分区的起始地址，长度，以及分配情况（未分配，或者分配给了哪一个作业）。同样重写了toString()方法，使得格式更加整齐。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/6c98c1f5062c26c75f7fc8e317746285.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/81019078308e9a96ee5c8e3352cf1f61.png\"></p>\n<h3 id=\"FitAlgorithm类实现\"><a href=\"#FitAlgorithm类实现\" class=\"headerlink\" title=\"FitAlgorithm类实现\"></a>FitAlgorithm类实现</h3><blockquote>\n<p>  该类负责实现动态分区分配的具体逻辑，并且通过传入参数选择FF或者BF算法进行内存分配。</p>\n</blockquote>\n<blockquote>\n<p>  首先，初始化空闲分区链，已分配分区链，并且从Task类中拿到具体的任务要求。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2fc55d3ae09686706127c470c8424bc9.png\"></p>\n<blockquote>\n<p>  然后每次从任务列表中取出第一条任务，根据该任务需要申请/释放内存进行相应操作（下面会讲），然后打印出空闲分区链及已分配分区链此时的情况。每间隔两秒循环一次，直到任务列表为空。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/b54aeb5a1851c9e0bf8a653ae19bb3cc.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/394e1dd3e381d7c937a5faacf8dc6991.png\"></p>\n<blockquote>\n<p>  任务如果进行的是释放操作，则首先从已分配分区表中得到该作业在内存中的起始地址以及大小，随后在空闲分区表中释放该区域内存。但是这样一共有四种情况：<br>  1.释放该作业内存后和后面的空闲分区相连,2.释放该作业内存后和前面的空闲分区相连,3.<br>  释放该作业内存后和前面以及后面的空闲分区连成一大块,4释放的该作业内存和前后空闲分区都不相连。(需要考虑是否存在前后空闲分区的情况)。</p>\n</blockquote>\n<blockquote>\n<p>  四种情况示意图如下：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9e0be407bff7128705dd54b2bdf0e8cd.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/87b03cf926c8a919f2f8b3aa5b225702.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1db0d7a3c1095736db718dfc17016277.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/addd2254cb6cad29ef4e555a38896bca.png\"></p>\n<blockquote>\n<p>  任务如果是申请操作，则根据之前在main函数选择的数字来采取对应的算法（FF或者BF）。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/a8e8cdfc194b64de62874f63a3e546c7.png\"></p>\n<h3 id=\"FF类实现\"><a href=\"#FF类实现\" class=\"headerlink\" title=\"FF类实现\"></a>FF类实现</h3><blockquote>\n<p>  采取首次适应算法进行内存分配，主要实现在静态函数ff中。根据空闲分区链中地址从低到高的顺序，从空闲分区链的第一个地址找起，把最先能够满足要求的空闲区分配给作业。如果满足要求的空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/6676b7082e5ff71f0c30d7993dc9de3a.png\"></p>\n<h3 id=\"BF类实现\"><a href=\"#BF类实现\" class=\"headerlink\" title=\"BF类实现\"></a>BF类实现</h3><blockquote>\n<p>  采取最佳适应算法进行内存分配，主要实现在静态函数bf中。从按地址递增的空闲分区链中,先筛选出符合条件的空闲分区,再从中找到最小的一个空闲分区，如果该空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1e9dcb8919ac79588d66666235616c24.png\"></p>\n<h2 id=\"request包下类实现\"><a href=\"#request包下类实现\" class=\"headerlink\" title=\"request包下类实现\"></a>request包下类实现</h2><h3 id=\"InstructionSequence类实现\"><a href=\"#InstructionSequence类实现\" class=\"headerlink\" title=\"InstructionSequence类实现\"></a>InstructionSequence类实现</h3><blockquote>\n<p>  主要作用是根据ppt的方式,得到指令序列.并且是通过伪随机数,每次都得到同样的一组随机数,便于测试与复现。</p>\n</blockquote>\n<blockquote>\n<p>  大致先随机选取作业中的一条指令，并且按顺序得到下一条指令，随后不断循环，重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直到得到320条指令（最后两条指令由于数组大小原因，选择了随机某条指令以及按顺序的下一条指令）。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e8f1c50bd23c6834f5ba6374ff13cf9d.png\"></p>\n<h3 id=\"PageItem类实现\"><a href=\"#PageItem类实现\" class=\"headerlink\" title=\"PageItem类实现\"></a>PageItem类实现</h3><blockquote>\n<p>  该类是实体类，代表了页表中的页表项，有四个字段：页号，内存块号（-1代表不在内存中），状态（true代表在内存中，false代表不在内存中），访问字段（记录上次访问时间，以实现LRU算法）。初始化中，所有页面都不在内存中，最久访问字段也设置为-1。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/11dd591286f905e60f7ed914a221b8f7.png\"></p>\n<h3 id=\"RequestPage类实现\"><a href=\"#RequestPage类实现\" class=\"headerlink\" title=\"RequestPage类实现\"></a>RequestPage类实现</h3><blockquote>\n<p>  该类实现请求调页的主要功能。首先定义了缺页次数字段，已经最近访问时间visitCount(初始化为0,每次访问页面后赋值到页面的访问字段并且+1)，并且初始化了该作业的32个页面。并且初始化分配给该作业的4个内存块（开始内存块中无页面）。随后通过之前的InstructionSequence类得到了指令序列。随后就对指令序列的每条指令进行执行（随后会说），最后打印缺页率。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2b74914710aa33e14622215e0e316eca.png\"></p>\n<blockquote>\n<p>  在每条指令的执行过程中，首先先找到该指令所属的页号。如果该页面在内存块中，则打印出指令的物理地址，并且将访问时间设为最近的（visitCount++）。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2174614935e27dc4d473a8fed6ce2c55.png\"></p>\n<blockquote>\n<p>  如果缺页了，但是内存块中还有空余位置，则将页面直接放入空闲的内存块中，并且让缺页次数+1，并且设置最近访问时间，而且不需要页面置换。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d287b0087981a986ced3ba6ff2c20bad.png\"></p>\n<blockquote>\n<p>  如果缺页了，并且4个内存块中都装满了作业，则使用LRU算法进行页面置换。首先查看内存块里面的四个页面，根据访问字段选取出最近最久未使用的页面，并且模拟调出内存，再把所需要的页面调入内存（实际上就是在对应的内存块数组中放入该页面的索引），并且把该页面访问时间改为最新的。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ef0b8793e707f6b75da6212d09e13e28.png\"></p>\n<blockquote>\n<p>  最后，展示页表目前的情况，但是由于作业的总页数太大，所以只展示了曾经放入内存块中的页面（通过判断访问时间是否&gt;=0实现）。并且还展示了4个内存块里面存储的页面号。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/db9b37208a2e0a329f104c5c30b21f78.png\"></p>\n<h1 id=\"项目界面展示\"><a href=\"#项目界面展示\" class=\"headerlink\" title=\"项目界面展示\"></a>项目界面展示</h1><h2 id=\"动态分区分配-FF算法界面展示\"><a href=\"#动态分区分配-FF算法界面展示\" class=\"headerlink\" title=\"动态分区分配-FF算法界面展示\"></a>动态分区分配-FF算法界面展示</h2><blockquote>\n<p>  处理作业1后的情况：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/df6a6335e312d038091dea6a3463e415.png\"></p>\n<blockquote>\n<p>  处理作业2，作业3情况也类似，只截处理完作业3的图:</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/10e2779fe65ed692275f26620b156f25.png\"></p>\n<blockquote>\n<p>  释放作业2内存：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/875cb49b31240357406074307c454a9e.png\"></p>\n<blockquote>\n<p>  作业4申请，作业3，作业1释放后：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4479c4ee520de74517d4932804c2757e.png\"></p>\n<blockquote>\n<p>  作业5申请，这里是FF和BF算法在该作业序列里不一样的地方，FF算法在这里按地址顺序寻找到前面的低地址空闲分区就分配了，但是BF会找到最后的那块容量最小的内存分区进行分配：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/425f09d23162c2d467be3f7d6aa17bfd.png\"></p>\n<blockquote>\n<p>  作业6，作业7申请后：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ee201abca741ee6466f5ea97ea66f686.png\"></p>\n<blockquote>\n<p>  最后一个序列，作业6释放内存：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/04e29ec16f986738cea51c9b16ecf785.png\"></p>\n<h2 id=\"动态分区分配-BF算法界面展示\"><a href=\"#动态分区分配-BF算法界面展示\" class=\"headerlink\" title=\"动态分区分配-BF算法界面展示\"></a>动态分区分配-BF算法界面展示</h2><blockquote>\n<p>  前面的都和FF算法一样，只是在作业5申请时有了变化，这里找到了容量较小的空闲分区进行分配：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/888b21728dd642ae54394740c7cfe12c.png\"></p>\n<blockquote>\n<p>  作业6，作业7申请：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7beb1dc31066e275047d7cf2635192f0.png\"></p>\n<blockquote>\n<p>  最后一条，作业6释放：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/833e9dc938bf5f2bc170ad8db8b5bf9a.png\"></p>\n<blockquote>\n<p>  5.3请求调页-LRU算法界面展示</p>\n</blockquote>\n<blockquote>\n<p>  执行第一条指令，116：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/386f3697478d202ba923225ba4dacea2.png\"></p>\n<blockquote>\n<p>  第二条，指令117（之后的指令两两基本同一个页面，所以每隔2条指令截图一次）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ab6e684d1f44ad3e0ad0aa044c5f50f4.png\"></p>\n<blockquote>\n<p>  第三条，指令80：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7777c3ef8f32aef7b3263f067500c3c8.png\"></p>\n<blockquote>\n<p>  第五条，指令250：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/80764683f5943b3fb58b0dd8a506f75c.png\"></p>\n<blockquote>\n<p>  第七条，指令160：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ea3a5a81d2039ab695d954e663f59cb8.png\"></p>\n<blockquote>\n<p>  第九条，指令259（没有缺页，但是更新了访问时间）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2273642bb1b7703abd15eb43cbb1943c.png\"></p>\n<blockquote>\n<p>  第十条，指令260（虽然和259相连，但是不在同一页上，所以缺页，并且发生页面置换。替换最近未访问的页号11，且页号11状态标志为不在内存块中）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/c3f8eaff0646ace444b67bb1ab793a22.png\"></p>\n<blockquote>\n<p>  第十一条，指令54（缺页，页面置换。替换最久未使用的页面8）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/bbfececf9d264f8072f05286d7e5b533.png\"></p>\n<blockquote>\n<p>  随后的指令基本类似，只截取最后两条指令：</p>\n</blockquote>\n<blockquote>\n<p>  指令81：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4553ca7dd481a10d6b5125f57225c080.png\"></p>\n<blockquote>\n<p>  指令82：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/b66e80ebebb962cd6a678cda6d10a7f8.png\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"内存管理源码-Github地址\"><a href=\"#内存管理源码-Github地址\" class=\"headerlink\" title=\"内存管理源码_Github地址\"></a><a href=\"https://github.com/tongji4m3/memoryProject\" target=\"_blank\" rel=\"noopener\">内存管理源码_Github地址</a></h1><h1 id=\"项目目的\"><a href=\"#项目目的\" class=\"headerlink\" title=\"项目目的\"></a>项目目的</h1><ul>\n<li><p>动态分区分配方式</p>\n<ul>\n<li><p>数据结构、分配算法</p>\n</li>\n<li><p>加深对动态分区存储管理方式及其实现过程的理解。</p>\n</li>\n</ul>\n</li>\n<li><p>请求分区分配方式</p>\n<ul>\n<li><p>页面、页表、地址转换</p>\n</li>\n<li><p>页面置换过程</p>\n</li>\n<li><p>加深对请求调页系统的原理和实现过程的理解</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"项目需求\"><a href=\"#项目需求\" class=\"headerlink\" title=\"项目需求\"></a>项目需求</h1><h2 id=\"动态分区分配方式的模拟\"><a href=\"#动态分区分配方式的模拟\" class=\"headerlink\" title=\"动态分区分配方式的模拟\"></a>动态分区分配方式的模拟</h2><ul>\n<li>要求:</li>\n</ul>\n<blockquote>\n<p>  假设初始态下，可用内存空间为640K，并有下列请求序列，请分别用首次适应算法和最佳适应算法进行内存块的分配和回收，并显示出每次分配和回收后的空闲分区链的情况来。</p>\n</blockquote>\n<ul>\n<li>请求序列:</li>\n</ul>\n<blockquote>\n<p>  作业1申请130K</p>\n</blockquote>\n<blockquote>\n<p>  作业2申请60K</p>\n</blockquote>\n<blockquote>\n<p>  作业3申请100k</p>\n</blockquote>\n<blockquote>\n<p>  作业2释放60K</p>\n</blockquote>\n<blockquote>\n<p>  作业4申请200K</p>\n</blockquote>\n<blockquote>\n<p>  作业3释放100K</p>\n</blockquote>\n<blockquote>\n<p>  作业1释放130K</p>\n</blockquote>\n<blockquote>\n<p>  作业5申请140K</p>\n</blockquote>\n<blockquote>\n<p>  作业6申请60K</p>\n</blockquote>\n<blockquote>\n<p>  作业7申请50K</p>\n</blockquote>\n<blockquote>\n<p>  作业6释放60K</p>\n</blockquote>\n<h2 id=\"请求调页存储管理方式模拟\"><a href=\"#请求调页存储管理方式模拟\" class=\"headerlink\" title=\"请求调页存储管理方式模拟\"></a>请求调页存储管理方式模拟</h2><ul>\n<li>内容</li>\n</ul>\n<blockquote>\n<p>  假设每个页面可存放10条指令，分配给一个作业的内存块为4。模拟一个作业的执行过程，该作业有320条指令，即它的地址空间为32页，目前所有页还没有调入内存。</p>\n</blockquote>\n<ul>\n<li><p>模拟过程</p>\n</li>\n<li><p>在模拟过程中，如果所访问指令在内存中，则显示其物理地址，并转到下一条指令；如果没有在内存中，则发生缺页，此时需要记录缺页次数，并将其调入内存。如果4个内存块中已装入作业，则需进行页面置换。</p>\n</li>\n<li><p>所有320条指令执行完成后，计算并显示作业执行过程中发生的缺页率。</p>\n</li>\n<li><p>置换算法可以选用FIFO或者LRU算法</p>\n</li>\n<li><p>作业中指令访问次序可以按照下面原则形成:50%的指令是顺序执行的，25%是均匀分布在前地址部分，25％是均匀分布在后地址部分</p>\n</li>\n<li><p>具体实施方法(参考):</p>\n</li>\n<li><p>在0－319条指令之间，随机选取一个起始执行指令，如序号为m</p>\n</li>\n<li><p>顺序执行下一条指令，即序号为m+1的指令</p>\n</li>\n<li><p>通过随机数，跳转到前地址部分0－m-1中的某个指令处，其序号为m1</p>\n</li>\n<li><p>顺序执行下一条指令，即序号为m1+1的指令</p>\n</li>\n<li><p>通过随机数，跳转到后地址部分m1+2~319中的某条指令处，其序号为m2</p>\n</li>\n<li><p>顺序执行下一条指令，即m2+1处的指令。</p>\n</li>\n<li><p>重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直到执行完320条指令。</p>\n</li>\n</ul>\n<h1 id=\"项目设计及算法\"><a href=\"#项目设计及算法\" class=\"headerlink\" title=\"项目设计及算法\"></a>项目设计及算法</h1><h2 id=\"项目整体结构\"><a href=\"#项目整体结构\" class=\"headerlink\" title=\"项目整体结构\"></a>项目整体结构</h2><p>本项目是采用java语言开发的，通过命令行互动的内存管理项目。主要分为2个包(dynamic,request)和一个主类MainTest。通过主类的main函数选择相应的算法进行模拟。</p>\n<p>其中的dynamic包主要是完成对动态分区分配的模拟，他有两个子包，一个是存储实体的domain包，里面包括了要执行的作业（Task类），以及空闲分区链中的每一项(FreeItem)。而另一个子包algorithm中，有一个类FitAlgorithm,抽取了FF和BF的整个流程里面重复的代码片段。并且他可以根据选择的参数，来决定调用首次适应算法（BF类）还是最佳适应算法（FF类）中的方法。</p>\n<p>而request包主要是完成请求调页方式的模拟，也有两个子包domain以及algorithm。在domain包中有两个类，PageItem类主要负责存储页表中的项，InstructionSequence则负责提供一组特定规则的随机序列，模拟指令。而algorithm包中，只有一个类requestPage，负责完成请求调页方式模拟的逻辑以及展示页面。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d0e3fe82479fd4fb3080a5a5e1c7d55b.png\"></p>\n<h2 id=\"首次适应算法\"><a href=\"#首次适应算法\" class=\"headerlink\" title=\"首次适应算法\"></a>首次适应算法</h2><ul>\n<li><p>实现：根据空闲分区链中地址从低到高的顺序，从空闲分区链的第一个地址找起，把最先能够满足要求的空闲区分配给作业。如果满足要求的空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。</p>\n</li>\n<li><p>优点:查找时间短，算法开销小，回收分区后不需要对空闲分区队列重新排序，综合性能最好。</p>\n</li>\n<li><p>缺点:低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销。</p>\n</li>\n</ul>\n<h2 id=\"最佳适应算法\"><a href=\"#最佳适应算法\" class=\"headerlink\" title=\"最佳适应算法\"></a>最佳适应算法</h2><ul>\n<li><p>实现：通常是采用空闲分区以容量递增的顺序排列，每次选择容量最小的能满足需求的空闲分区。但我的具体实现是从按地址递增的空闲分区链中,先筛选出符合条件的空闲分区,再从中找到最小的一个空闲分区，如果该空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。因为这样可以不用对空闲分区按照容量递增排序，可以复用FF中的分区回收算法。</p>\n</li>\n<li><p>优点:优先使用更小的分区，保留更多的大分区，所以会有更多的大分区保留下来，更能满足大进程的需求。</p>\n</li>\n<li><p>缺点:会留下许多难以利用的，很小的空闲分区，称为碎片碎片。每次都要找到最小的可用的空闲分区，算法的开销大。</p>\n</li>\n</ul>\n<h2 id=\"LRU置换算法\"><a href=\"#LRU置换算法\" class=\"headerlink\" title=\"LRU置换算法\"></a>LRU置换算法</h2><ul>\n<li><p>实现：在每一个页表项的访问字段中记录了上次访问时间（用一个不断递增的变量实现）。当内存块中已经满了，需要置换时，<br>就查看内存块里面的四个页面，根据访问字段选取出最近最久未使用的页面，并且模拟调出内存，再把所需要的页面调入内存（实际上就是在对应的内存块数组中放入该页面的索引），并且把该页面访问时间改为最新的。</p>\n</li>\n<li><p>优点:性能很好，缺页率较低，是局部性原理的合理近似，</p>\n</li>\n<li><p>缺点:算法开销较大，需要记录页面使用时间的先后关系，硬件开销太大。</p>\n</li>\n</ul>\n<h1 id=\"项目实现\"><a href=\"#项目实现\" class=\"headerlink\" title=\"项目实现\"></a>项目实现</h1><h2 id=\"MainTest类实现\"><a href=\"#MainTest类实现\" class=\"headerlink\" title=\"MainTest类实现\"></a>MainTest类实现</h2><blockquote>\n<p>  通过命令行输入的参数，选择对应的算法进行模拟。其中，1表示选择首次适应算法，2表示选择最佳适应算法，3表示进行请求调页存储管理方式模拟。</p>\n</blockquote>\n<blockquote>\n<p>  其中，选择1和2将使用FitAlgorithm类并且传入该参数来选择首次适应算法，或者最佳适应算法。选择3则使用RequestPage类进行请求调页方式模拟。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/55475d0b605c779c4904f5382947faf7.png\"></p>\n<h2 id=\"dynamic包下类实现\"><a href=\"#dynamic包下类实现\" class=\"headerlink\" title=\"dynamic包下类实现\"></a>dynamic包下类实现</h2><h3 id=\"Task类实现\"><a href=\"#Task类实现\" class=\"headerlink\" title=\"Task类实现\"></a>Task类实现</h3><blockquote>\n<p>  实体类，字段包含了作业名称，进行的操作（释放/申请），释放/申请的内存大小。并且重写了toString方法，使得展示更符合阅读规范。</p>\n</blockquote>\n<blockquote>\n<p>  该类有一个静态方法，getTask，将存储了一系列的任务列表封装成链表并返回。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/39f5702ea2f2f5b06f3762634a5de6ac.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/6072930d7d7c4d44c763e3039d6edb13.png\"></p>\n<h3 id=\"FreeItem类实现\"><a href=\"#FreeItem类实现\" class=\"headerlink\" title=\"FreeItem类实现\"></a>FreeItem类实现</h3><blockquote>\n<p>  该类也是实体类，有三个字段，分别是空闲分区的起始地址，长度，以及分配情况（未分配，或者分配给了哪一个作业）。同样重写了toString()方法，使得格式更加整齐。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/6c98c1f5062c26c75f7fc8e317746285.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/81019078308e9a96ee5c8e3352cf1f61.png\"></p>\n<h3 id=\"FitAlgorithm类实现\"><a href=\"#FitAlgorithm类实现\" class=\"headerlink\" title=\"FitAlgorithm类实现\"></a>FitAlgorithm类实现</h3><blockquote>\n<p>  该类负责实现动态分区分配的具体逻辑，并且通过传入参数选择FF或者BF算法进行内存分配。</p>\n</blockquote>\n<blockquote>\n<p>  首先，初始化空闲分区链，已分配分区链，并且从Task类中拿到具体的任务要求。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2fc55d3ae09686706127c470c8424bc9.png\"></p>\n<blockquote>\n<p>  然后每次从任务列表中取出第一条任务，根据该任务需要申请/释放内存进行相应操作（下面会讲），然后打印出空闲分区链及已分配分区链此时的情况。每间隔两秒循环一次，直到任务列表为空。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/b54aeb5a1851c9e0bf8a653ae19bb3cc.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/394e1dd3e381d7c937a5faacf8dc6991.png\"></p>\n<blockquote>\n<p>  任务如果进行的是释放操作，则首先从已分配分区表中得到该作业在内存中的起始地址以及大小，随后在空闲分区表中释放该区域内存。但是这样一共有四种情况：<br>  1.释放该作业内存后和后面的空闲分区相连,2.释放该作业内存后和前面的空闲分区相连,3.<br>  释放该作业内存后和前面以及后面的空闲分区连成一大块,4释放的该作业内存和前后空闲分区都不相连。(需要考虑是否存在前后空闲分区的情况)。</p>\n</blockquote>\n<blockquote>\n<p>  四种情况示意图如下：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9e0be407bff7128705dd54b2bdf0e8cd.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/87b03cf926c8a919f2f8b3aa5b225702.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1db0d7a3c1095736db718dfc17016277.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/addd2254cb6cad29ef4e555a38896bca.png\"></p>\n<blockquote>\n<p>  任务如果是申请操作，则根据之前在main函数选择的数字来采取对应的算法（FF或者BF）。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/a8e8cdfc194b64de62874f63a3e546c7.png\"></p>\n<h3 id=\"FF类实现\"><a href=\"#FF类实现\" class=\"headerlink\" title=\"FF类实现\"></a>FF类实现</h3><blockquote>\n<p>  采取首次适应算法进行内存分配，主要实现在静态函数ff中。根据空闲分区链中地址从低到高的顺序，从空闲分区链的第一个地址找起，把最先能够满足要求的空闲区分配给作业。如果满足要求的空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/6676b7082e5ff71f0c30d7993dc9de3a.png\"></p>\n<h3 id=\"BF类实现\"><a href=\"#BF类实现\" class=\"headerlink\" title=\"BF类实现\"></a>BF类实现</h3><blockquote>\n<p>  采取最佳适应算法进行内存分配，主要实现在静态函数bf中。从按地址递增的空闲分区链中,先筛选出符合条件的空闲分区,再从中找到最小的一个空闲分区，如果该空闲分区大小正好等于该任务所需内存大小，则需要在空闲分区链中删除该空闲分区，否则就改变该空闲分区的相应参数（始址，长度）。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1e9dcb8919ac79588d66666235616c24.png\"></p>\n<h2 id=\"request包下类实现\"><a href=\"#request包下类实现\" class=\"headerlink\" title=\"request包下类实现\"></a>request包下类实现</h2><h3 id=\"InstructionSequence类实现\"><a href=\"#InstructionSequence类实现\" class=\"headerlink\" title=\"InstructionSequence类实现\"></a>InstructionSequence类实现</h3><blockquote>\n<p>  主要作用是根据ppt的方式,得到指令序列.并且是通过伪随机数,每次都得到同样的一组随机数,便于测试与复现。</p>\n</blockquote>\n<blockquote>\n<p>  大致先随机选取作业中的一条指令，并且按顺序得到下一条指令，随后不断循环，重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直到得到320条指令（最后两条指令由于数组大小原因，选择了随机某条指令以及按顺序的下一条指令）。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e8f1c50bd23c6834f5ba6374ff13cf9d.png\"></p>\n<h3 id=\"PageItem类实现\"><a href=\"#PageItem类实现\" class=\"headerlink\" title=\"PageItem类实现\"></a>PageItem类实现</h3><blockquote>\n<p>  该类是实体类，代表了页表中的页表项，有四个字段：页号，内存块号（-1代表不在内存中），状态（true代表在内存中，false代表不在内存中），访问字段（记录上次访问时间，以实现LRU算法）。初始化中，所有页面都不在内存中，最久访问字段也设置为-1。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/11dd591286f905e60f7ed914a221b8f7.png\"></p>\n<h3 id=\"RequestPage类实现\"><a href=\"#RequestPage类实现\" class=\"headerlink\" title=\"RequestPage类实现\"></a>RequestPage类实现</h3><blockquote>\n<p>  该类实现请求调页的主要功能。首先定义了缺页次数字段，已经最近访问时间visitCount(初始化为0,每次访问页面后赋值到页面的访问字段并且+1)，并且初始化了该作业的32个页面。并且初始化分配给该作业的4个内存块（开始内存块中无页面）。随后通过之前的InstructionSequence类得到了指令序列。随后就对指令序列的每条指令进行执行（随后会说），最后打印缺页率。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2b74914710aa33e14622215e0e316eca.png\"></p>\n<blockquote>\n<p>  在每条指令的执行过程中，首先先找到该指令所属的页号。如果该页面在内存块中，则打印出指令的物理地址，并且将访问时间设为最近的（visitCount++）。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2174614935e27dc4d473a8fed6ce2c55.png\"></p>\n<blockquote>\n<p>  如果缺页了，但是内存块中还有空余位置，则将页面直接放入空闲的内存块中，并且让缺页次数+1，并且设置最近访问时间，而且不需要页面置换。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d287b0087981a986ced3ba6ff2c20bad.png\"></p>\n<blockquote>\n<p>  如果缺页了，并且4个内存块中都装满了作业，则使用LRU算法进行页面置换。首先查看内存块里面的四个页面，根据访问字段选取出最近最久未使用的页面，并且模拟调出内存，再把所需要的页面调入内存（实际上就是在对应的内存块数组中放入该页面的索引），并且把该页面访问时间改为最新的。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ef0b8793e707f6b75da6212d09e13e28.png\"></p>\n<blockquote>\n<p>  最后，展示页表目前的情况，但是由于作业的总页数太大，所以只展示了曾经放入内存块中的页面（通过判断访问时间是否&gt;=0实现）。并且还展示了4个内存块里面存储的页面号。</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/db9b37208a2e0a329f104c5c30b21f78.png\"></p>\n<h1 id=\"项目界面展示\"><a href=\"#项目界面展示\" class=\"headerlink\" title=\"项目界面展示\"></a>项目界面展示</h1><h2 id=\"动态分区分配-FF算法界面展示\"><a href=\"#动态分区分配-FF算法界面展示\" class=\"headerlink\" title=\"动态分区分配-FF算法界面展示\"></a>动态分区分配-FF算法界面展示</h2><blockquote>\n<p>  处理作业1后的情况：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/df6a6335e312d038091dea6a3463e415.png\"></p>\n<blockquote>\n<p>  处理作业2，作业3情况也类似，只截处理完作业3的图:</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/10e2779fe65ed692275f26620b156f25.png\"></p>\n<blockquote>\n<p>  释放作业2内存：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/875cb49b31240357406074307c454a9e.png\"></p>\n<blockquote>\n<p>  作业4申请，作业3，作业1释放后：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4479c4ee520de74517d4932804c2757e.png\"></p>\n<blockquote>\n<p>  作业5申请，这里是FF和BF算法在该作业序列里不一样的地方，FF算法在这里按地址顺序寻找到前面的低地址空闲分区就分配了，但是BF会找到最后的那块容量最小的内存分区进行分配：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/425f09d23162c2d467be3f7d6aa17bfd.png\"></p>\n<blockquote>\n<p>  作业6，作业7申请后：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ee201abca741ee6466f5ea97ea66f686.png\"></p>\n<blockquote>\n<p>  最后一个序列，作业6释放内存：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/04e29ec16f986738cea51c9b16ecf785.png\"></p>\n<h2 id=\"动态分区分配-BF算法界面展示\"><a href=\"#动态分区分配-BF算法界面展示\" class=\"headerlink\" title=\"动态分区分配-BF算法界面展示\"></a>动态分区分配-BF算法界面展示</h2><blockquote>\n<p>  前面的都和FF算法一样，只是在作业5申请时有了变化，这里找到了容量较小的空闲分区进行分配：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/888b21728dd642ae54394740c7cfe12c.png\"></p>\n<blockquote>\n<p>  作业6，作业7申请：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7beb1dc31066e275047d7cf2635192f0.png\"></p>\n<blockquote>\n<p>  最后一条，作业6释放：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/833e9dc938bf5f2bc170ad8db8b5bf9a.png\"></p>\n<blockquote>\n<p>  5.3请求调页-LRU算法界面展示</p>\n</blockquote>\n<blockquote>\n<p>  执行第一条指令，116：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/386f3697478d202ba923225ba4dacea2.png\"></p>\n<blockquote>\n<p>  第二条，指令117（之后的指令两两基本同一个页面，所以每隔2条指令截图一次）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ab6e684d1f44ad3e0ad0aa044c5f50f4.png\"></p>\n<blockquote>\n<p>  第三条，指令80：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7777c3ef8f32aef7b3263f067500c3c8.png\"></p>\n<blockquote>\n<p>  第五条，指令250：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/80764683f5943b3fb58b0dd8a506f75c.png\"></p>\n<blockquote>\n<p>  第七条，指令160：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ea3a5a81d2039ab695d954e663f59cb8.png\"></p>\n<blockquote>\n<p>  第九条，指令259（没有缺页，但是更新了访问时间）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2273642bb1b7703abd15eb43cbb1943c.png\"></p>\n<blockquote>\n<p>  第十条，指令260（虽然和259相连，但是不在同一页上，所以缺页，并且发生页面置换。替换最近未访问的页号11，且页号11状态标志为不在内存块中）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/c3f8eaff0646ace444b67bb1ab793a22.png\"></p>\n<blockquote>\n<p>  第十一条，指令54（缺页，页面置换。替换最久未使用的页面8）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/bbfececf9d264f8072f05286d7e5b533.png\"></p>\n<blockquote>\n<p>  随后的指令基本类似，只截取最后两条指令：</p>\n</blockquote>\n<blockquote>\n<p>  指令81：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4553ca7dd481a10d6b5125f57225c080.png\"></p>\n<blockquote>\n<p>  指令82：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/b66e80ebebb962cd6a678cda6d10a7f8.png\"></p>\n"},{"title":"项目------操作系统_文件管理项目","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"操作系统_文件管理项目。一个简单的Java项目，主要是模拟操作系统的文件管理过程。","abbrlink":"1c948532","date":"2020-05-24T16:00:00.000Z","_content":"\n#  [文件管理源码_Github地址](https://github.com/tongji4m3/fileSystem)\n>图片太多,上传之后有些位置错乱或者不显示,可以在源码地址查看word版本\n\n# 项目目的\n\n-   理解文件存储空间的管理；\n\n-   掌握文件的物理结构、目录结构和文件操作；\n\n-   实现简单文件系统管理；\n\n-   加深文件系统实现过程的理解；\n\n# 项目需求\n\n##  基本要求\n\n-   在内存中开辟一个空间作为文件存储器，在其上实现一个简单的文件系统;\n\n-   退出这个文件系统时，需要该文件系统的内容保存到磁盘上，以便下次可以将其回复到内存中来。\n\n## 具体要求\n\n-   文件存储空间管理可采取显式链接（如FAT）或者其他方法；\n\n-   空闲空间管理可采用位图或者其他方法；\n\n-   文件目录采用多级目录结构，目录项目中应包含：文件名、物理地址、长度等信息。\n\n## 文件系统提供的操作\n\n    -   格式化\n    \n    -   创建子目录\n    \n    -   删除子目录\n    \n    -   显示目录\n    \n    -   更改当前目录\n    \n    -   创建文件\n    \n    -   打开文件\n    \n    -   关闭文件\n    \n    -   写文件\n    \n    -   读文件\n    \n    -   删除文件\n\n#  项目设计及算法\n\n## 项目整体结构\n\n本项目是windows平台下,采用java语言开发的，通过命令行互动的文件管理项目。主要采用MVC架构模式,分为三个包(model,view,controller),和一个主类Main。通过主类调用view包下的View类开启命令行交互进行文件管理。\n\nmodel包下放置了一些实体类以及常量结合。其中的Const存放一些公共参数，例如物理块的大小，容量等等。FCB类则代表一个文件目录项的实体，存储一些文件名，文件属性，文件物理块地址等信息。Block类则充当了磁盘物理块实体，它存储了物理块地址和数据。\n\nview包下主要负责和用户进行命令行交互的全部内容，对于用户输入的指令进行判断，并且调用controller以及model包下的类完成功能。例如用户输入ls指令，在View类中，就会判断该指令，并且调用controller得到当前目录，然后得到该目录的所有子目录，再将之按照特定的格式打印并呈现给用户。\n\ncontroller包下包含了两个类：Controller，IOController。其中Controller负责对目录区，文件区，FAT，位示图，打开文件表等进行相应的管理，包括分配释放等操作。IOController负责读写文件，并且负责初始时从电脑本地磁盘回复内容到内存（即此虚拟文件管理系统中），还负责退出文件系统时，把文件系统内容保存在电脑本地磁盘中。\n\n\n\n## 项目实现思路\n\n首先，当退出程序时，将用来模拟物理块，PCB等数组存储在本地文件之中，而启动程序时，则从本地文件中读取相应的数据，以此达到备份的目的。\n\n然后，该文件系统主要分为目录位示图，文件位示图，FAT，目录区，文件区五部分组成。文件目录采用多级目录结构。文件存储空间管理采取显式链接管理（FAT），空闲空间管理采用位示图管理。\n\n目录区为FCB组成的数组。其中每个文件（目录或者文件）对应一个FCB，每个FCB都存储了文件名，文件类型，物理块号，父路径，子目录等信息。而目录区物理块分配与否通过目录的位示图标识。\n\n文件区为Block组成的数组，存储了物理块号以及实际的文件数据。分配文件时,则扫描位示图,找到N个0,并且计算出对应的盘块号,将之分配给文件。并且在FAT中，以静态链接的形式标识出分配的物理块顺序。\n\n程序一直会存储当前路径（即某个FCB）,并且初始化为根路径/，而进行操作时，可以有两种方式：绝对路径，相对路径。相对路径则根据当前路径进行操作。而绝对路径方式，则从目录区获取根路径/的PCB，然后按照层级进行操作。程序还存储一个打开文件表，当打开，读写文件时，就会将文件加入到打开文件表。\n\n## 文件系统可用指令\n\n其中，涉及fileName的指令，fileName都可以有两种写法，一种是从根路径开始的绝对路径写法，例如/usr/local；另外一种是从当前路径开始，例如，temp。\n\n从本地磁盘加载与保存文件是系统自动进行的。如果想要到初始环境，可以执行format指令。\n\n-   退出 exit\n\n-   查看帮助 –help\n\n-   格式化 format\n\n-   显示目录 pwd\n\n-   更改当前目录 cd fileName\n\n-   创建子目录 mkdir fileName\n\n-   删除子目录 rm fileName\n\n-   列出当前目录下所有文件 ls\n\n-   创建文件 touch fileName\n\n-   打开文件 open fileName\n\n-   关闭文件 close fileName\n\n-   写文件 vim fileName\n\n-   读文件 cat fileName\n\n-   删除文件 delete fileName\n\n-   查看目录区信息 dirBlock\n\n-   查看文件区信息 fileBlock\n\n-   查看打开文件表 openFiles\n\n# 项目实现\n\n## Main类实现\n\n>   Main类只是整个程序的入口，他通过new\n>   View（）调用View类执行文件系统主要的逻辑。\n\n##  model包下类的实现\n\n###  Const类的实现\n\n>   Const类存储了程序用到的所有常量,放在一起,便于程序的维护。首先，用DIR=1，FILE=0来标识文件类型，之后可以直接引用，不需要记住是0还是1。随后，记录了目录区物理块数量，以及目录区位示图的尺寸。最后，记录了文件区物理块数量，容量，以及文件区位示图的尺寸。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzZhYjJmOTAxZGFjMTU2MTZjMjZiNGM5ZmI4ZDlhNTEyLnBuZw?x-oss-process=image/format,png)\n\n### FCB的实现\n\n>   一个FCB代表了一个目录项。所以FCB包含以下属性：文件名称（即相对路径名称），文件路径（即绝对路径名称），文件类型（File或者Dir），文件物理块地址，文件物理块长度，文件的子目录（只有文件类型为Dir才有），文件的父路径。\n\n\n>   其中有以下实用函数：\n\n>   getChildren（String\n>   childName）:从该FCB的子目录中查找名称为childName的文件并返回，如果不存在则返回null。\n\n>   remove（String childName）:删除名称为childName的文件并返回删除结果。\n\n>   toString（）:通过使用String.format函数，按照阅读良好的格式输出该FCB。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzVhZWM1MTllYTcxMjE0NDE0MWUzYWQ0ZWM4OTAwNzBlLnBuZw?x-oss-process=image/format,png)\n\n###   Block类的实现\n\n>   Block主要是模拟文件区的物理块。有两个属性：id和data，id代表该块的编号，data为ByteBuffer类型，存储了文件实际的试卷。\n\n## view包下类的实现\n\n>   view包只有一个类View，但是里面有很多函数来实现和用户的交互功能。他有两个成员变量：controller以及ioController，负责调用Controller包下的两个类进行文件管理的具体操作。\n\n### 初始化函数View（）\n\n>   在初始化时，会先从本地磁盘加载上一次退出时文件系统的数据。随后不断接收用户输入的数据，并且根据用户的指令调用相应的函数进行文件管理。值得注意的是，指令有两种模式，一种是equals（），例如exit指令，只有仅仅输入exit时，才会执行相应操作。另外一种是startWith（）模式，会将所有以此开头的指令相匹配，例如mkdir\n>   /usr/local命令就用到这种模式。而且equals模式放在了startWith模式之前，防止一些匹配错误的问题。最后，还在每次输入指令时，显示了当前的用户和路径。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzU1YzU1ZjRjODIwNWIxNTI5YjZkOTY0NDVjOTQ5NjFiLnBuZw?x-oss-process=image/format,png)\n\n### 函数exit（）\n\n>   退出时，调用ioController.save()方法，将本次文件系统的内容保存在本地硬盘中。\n\n### 函数format（）\n\n>   其实就是另外一次初始化，且不加载磁盘中的文件。主要就是将controller，ioController重新初始化。\n\n### 函数help（）\n\n>   通过输入—help，进入该函数，打印本文件系统所支持的所有操作。\n\n###  getCurrentFCB(String command)\n\n>   一个重要的公共函数，负责从command中获取文件的FCB。例如指令mkdir\n>   /usr/local。首先，会将指令按照空格分隔，并且进行有效性检验。随后根据后者的路径是否以/开头进行不同的操作，如果是/开头，则从根目录开始不断查找到它，如果不是，则从当前路径的子目录进行查找。最后将之返回，如果不存在，则返回null。\n\n\n###  checkFileName(String fileName)\n\n>   检验文件名合法性的公共函数，通过正则表达式判断文件名是否合法。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzQ4NTFjNzU3NTQzOGRiMTY2NTY4YjU3YjY1YjQyZjg2LnBuZw?x-oss-process=image/format,png)\n\n###  create(String command, int type)\n\n>   该函数可根据指令创建文件或者命令。首先还是把命令拆分得到文件路径，并且根据是否以/开头执行不同操作，而之后又根据是文件或目录执行不同的创建操作。如果是以/开头，则还是先得到根路径，随后将路径按照/拆分。以/usr/local/temp.txt为例：将之拆分为usr，local，temp.txt。首先校验文件名是否合法。随后如果路径是存在的，则进入路径，例如如果原来存在usr文件夹，则进入，而local文件夹不存在，则创建文件夹（先通过目录位示图得到空闲目录块地址，再将目录磁盘块分配给他，还要新建FCB，并且在他的父路径的子目录中添加他）。随后，又发现temp.txt文件不存在，则创建他（在位示图中分配，在FAT中分配，新建该文件的FCB，另他父路径的子目录添加该FCB）。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Y3MGU5M2ZkNjE5NjZhZDA3MWJkZGE3ZmNhMTZkMjZmLnBuZw?x-oss-process=image/format,png)\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Q1NTNlY2IwNGNiN2RhMmJjZmFlYmIzZmNjODNhMWQwLnBuZw?x-oss-process=image/format,png)\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzllZjdlNGI0MmY5YjY5MmQ5MWYyYzViN2Y4MGUzMWIzLnBuZw?x-oss-process=image/format,png)\n\n###  delete(String command)\n\n>   通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。随后在打开文件表中删除，在位示图移除，在磁盘块删除，在FCB目录中移除，在FAT中回收。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzViNzUzY2RlYTg1YzhmNDQ5ZWVmZjM3NjgwMTg0ZjI4LnBuZw?x-oss-process=image/format,png)\n\n###  write(String command)\n\n>   负责写入文件内容，如果文件不存在会先创建一个。随后通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。然后首先加入打开文件表，之后将用户输入暂存与StringBuilder中，再调用ioController.write()将输入内容写入文件对应的物理磁盘块中。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzdmODEwYTQwZjRhNTYxZjU5ZmEzZmY5NDJkZjQxZjVhLnBuZw?x-oss-process=image/format,png)\n\n###  read(String command)\n\n>   负责读取文件内容。通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。然后首先加入打开文件表，通过ioController.read()将文件内容显示到屏幕上。\n\n###  open(),close()函数\n\n>   通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。将文件添加或者移除打开文件表。\n\n###  rm(String command)函数\n\n>   通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。并且调用rmRecursive（FCB\n>   fcb）将他的子目录以及文件都删除（如果还是目录，则继续调用自己，递归删除所有文件）。最后，再将他本身删除。（在FCB中删除，在目录的位示图中删除，在目录磁盘块中删除）。\n\n\n\n###  cd(String command)\n\n>   照例，先将命令拆分，得到路径。然后需要判断路径是否是.. ../ ./\n>   .等执行特殊操作。若不是，则通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对，或者不是目录则提示并且返回。然后将当前路径设为该FCB。\n\n\n###  ls（）函数\n\n>   首先得到当前路径的子目录，然后全部打印。因为前面说过重写了FCB的toString（）方法，所以格式良好。\n\n###  其他函数\n\n>   pwd（）函数得到controller的当前目录的路径名，并且打印。openFiles()获取controller的打开文件表，并且展示打开文件表中文件名以及占用的物理块号。fileBlock()，dirBlock()则根据文件/目录的位示图，判断出已经使用的磁盘块，并且展示。\n\n\n ##  controller包下类的实现\n\n ###   Controller类\n\n>   成员函数包括：当前的目录项，目录区磁盘块，文件区磁盘块，文件分配表FAT。目录的空闲分区位示图，文件的空闲分区位示图以及打开文件表。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzhkZWUyMTc3YzM2ZjdmNzQzYmIzYmEyYWFiNzJkMmJkLnBuZw?x-oss-process=image/format,png)\n\n####   初始化函数Controller（）：\n\n>   将上述的成员变量初始化。值得注意的是，在FAT中,-1代表结束,其他数字代表下一个物理块指向,所以初始化为-2。并且为根路径分配目录区的物理块0，并且设置为当前目录。\n\n\n####   allocFAT()与freeFAT()：\n\n>   负责FAT的分配与回收，根据之前分配给文件的物理块地址链表，在FAT中进行分配，且FAT的值为下一个物理块索引，最后一块值为-1。回收则是传入文件的起始物理块，随后一直根据FAT中的值寻找到下一个物理块，并且置为-2（未分配状态）。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2RlNGY3ZmNmY2Y4ZGQyNGIxNzlmNGQ2YzY0NWZmMGQ5LnBuZw?x-oss-process=image/format,png)\n\n####   getFreeDirBlock()与setFreeDirBlock(int dirIndex)：\n\n>   负责目录位示图的分配与回收操作。从位示图选取一个未分配的，通过数学转换成一维的目录块索引，并且标记为已分配。而回收则把目录磁盘块索引转为二维位示图坐标，标记为未分配。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4ODVjYjdkODRiMjAxNDM1ZTZjY2VlZjM1MDhkMDI2LnBuZw?x-oss-process=image/format,png)\n\n####  getFreeFileBlock(int size)与setFreeFileBlock(int dirIndex)：\n\n>   负责文件位示图的分配与回收操作。需要传入文件块的大小，以便分配足够的文件物理块。从位示图选取size个未分配的，通过数学转换成一维的文件块索引，并且标记为已分配，返回索引链表。而回收则把文件磁盘块索引转为二维位示图坐标，标记为未分配。\n\n####   addOpenFiles(String address,Integer blockIndex)\n>   负责加入与移除打开文件表。实现很简单，加入就往map中加入键值对（文件的地址，文件起始物理块号）。删除则根据文件地址删除键值对。\n\n\n ###    IOController类\n\nIOController类负责读写文件，并且负责初始时从电脑本地磁盘回复内容到内存（即此虚拟文件管理系统中），还负责退出文件系统时，把文件系统内容保存在电脑本地磁盘中。该类有一个成员变量controller，以获取Controller提供的一些功能。\n\n####  write（）与read（）函数：\n\n负责文件内容的读写，读写都需要传入要操作的文件的PCB，然后写还需要传入写入的文本。随后写则在文件区中寻找该PCB所对应的物理块，并且对他的data区域进行写操作。读操作也是找到对应的物理块进行读操作。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2FkNDQ0YmQ5NGIwMWE3Zjc0ZDVhMjg3Njg1Y2JiNWMzLnBuZw?x-oss-process=image/format,png)\n\n####  load（）与save（）函数：\n\n>   负责将文件系统加载与保存于本地磁盘中。他们是成对的。通过调用函数，他们保存与加载了文件系统中的目录位示图，文件位示图，FAT，目录物理块，文件物理块。基本的操作都是将当前文件系统中的数据按照约定格式写在磁盘中特定的文件中，然后下次启动时，则从这些文件中按之前的格式读取数据并且给他们赋值。\n\n\n\n#### saveBits（）与loadBits（）函数：\n\n>   首先在本地建立文件bits，随后将controller中的文件位示图一行行写入文件中。而恢复则从bits文件一行行赋值给初始的文件位示图bits。\n\n\n#### saveDirBits（）与loadDirBits（）函数：\n\n>   与文件位示图的保存恢复差不多。都是首先在本地建立文件dirBits，随后将controller中的目录位示图一行行写入文件中。而恢复则从dirBits文件一行行赋值给初始的目录位示图bits。\n\n#### saveDirArea（）与loadDirArea（）函数：\n\n也是创建一个文件dirArea来存储数据。策略是按照深度优先搜索算法递归的存储目录信息，并且存储文件所在层级（根目录的层级是0，它所有子目录下文件层级是1，以此类推）。而从已经存储好的目录数据中加载数据时，则一行行的加载目录数据，根据层级重建目录。并且根据层级的变化判断他的父目录。如果层级是递增的，那么文件的上一级目录就是他前面那个，否则则还要回头找到他的父目录。比如层级0,1,2,3,2,3,4\n则第二个2的父目录不是前面的3,而是前面的1。根据文件数据生成FCB后，还需要设置好他的父目录parent和他的子目录children（在他的子文件设置父目录时进行）。\n\n\n#### saveFileArea（）与loadFileArea（）函数：\n\n如果文件位示图中显示某个物理块被占用，则将在写入本地磁盘文件fileArea中，随之写入的还有他的物理块号。而加载时则按行扫描fileArea，并且从中读取文件数据以及对应的物理块号，写在本文件管理系统的特定物理块上。\n\n\n# 项目界面展示\n>这里的图片都混乱了,就删除了,可以运行源码,或者看word版查看效果\n## 目录操作\n\n##   创建文件夹\n\n\n##    删除文件夹\n\n\n##   更改路径\n\n\n## 文件操作\n\n##   创建删除文件\n\n\n##   读写文件\n\n##  文件系统查看操作\n\n## 保存与加载操作\n\n>   退出程序：\n>   重新启动程序：\n\n\n## 其他操作\n\n>   格式化：\n>   帮助文档：\n\n\n","source":"_posts/项目笔记/操作系统_文件系统管理项目.md","raw":"---\ntitle: 项目------操作系统_文件管理项目\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 操作系统_文件管理项目。一个简单的Java项目，主要是模拟操作系统的文件管理过程。\ncategories: 项目文档\ntags:\n  - Java\n  - 操作系统\n  - 文件管理\nabbrlink: 1c948532\ndate: 2020-05-25 00:00:00\n---\n\n#  [文件管理源码_Github地址](https://github.com/tongji4m3/fileSystem)\n>图片太多,上传之后有些位置错乱或者不显示,可以在源码地址查看word版本\n\n# 项目目的\n\n-   理解文件存储空间的管理；\n\n-   掌握文件的物理结构、目录结构和文件操作；\n\n-   实现简单文件系统管理；\n\n-   加深文件系统实现过程的理解；\n\n# 项目需求\n\n##  基本要求\n\n-   在内存中开辟一个空间作为文件存储器，在其上实现一个简单的文件系统;\n\n-   退出这个文件系统时，需要该文件系统的内容保存到磁盘上，以便下次可以将其回复到内存中来。\n\n## 具体要求\n\n-   文件存储空间管理可采取显式链接（如FAT）或者其他方法；\n\n-   空闲空间管理可采用位图或者其他方法；\n\n-   文件目录采用多级目录结构，目录项目中应包含：文件名、物理地址、长度等信息。\n\n## 文件系统提供的操作\n\n    -   格式化\n    \n    -   创建子目录\n    \n    -   删除子目录\n    \n    -   显示目录\n    \n    -   更改当前目录\n    \n    -   创建文件\n    \n    -   打开文件\n    \n    -   关闭文件\n    \n    -   写文件\n    \n    -   读文件\n    \n    -   删除文件\n\n#  项目设计及算法\n\n## 项目整体结构\n\n本项目是windows平台下,采用java语言开发的，通过命令行互动的文件管理项目。主要采用MVC架构模式,分为三个包(model,view,controller),和一个主类Main。通过主类调用view包下的View类开启命令行交互进行文件管理。\n\nmodel包下放置了一些实体类以及常量结合。其中的Const存放一些公共参数，例如物理块的大小，容量等等。FCB类则代表一个文件目录项的实体，存储一些文件名，文件属性，文件物理块地址等信息。Block类则充当了磁盘物理块实体，它存储了物理块地址和数据。\n\nview包下主要负责和用户进行命令行交互的全部内容，对于用户输入的指令进行判断，并且调用controller以及model包下的类完成功能。例如用户输入ls指令，在View类中，就会判断该指令，并且调用controller得到当前目录，然后得到该目录的所有子目录，再将之按照特定的格式打印并呈现给用户。\n\ncontroller包下包含了两个类：Controller，IOController。其中Controller负责对目录区，文件区，FAT，位示图，打开文件表等进行相应的管理，包括分配释放等操作。IOController负责读写文件，并且负责初始时从电脑本地磁盘回复内容到内存（即此虚拟文件管理系统中），还负责退出文件系统时，把文件系统内容保存在电脑本地磁盘中。\n\n\n\n## 项目实现思路\n\n首先，当退出程序时，将用来模拟物理块，PCB等数组存储在本地文件之中，而启动程序时，则从本地文件中读取相应的数据，以此达到备份的目的。\n\n然后，该文件系统主要分为目录位示图，文件位示图，FAT，目录区，文件区五部分组成。文件目录采用多级目录结构。文件存储空间管理采取显式链接管理（FAT），空闲空间管理采用位示图管理。\n\n目录区为FCB组成的数组。其中每个文件（目录或者文件）对应一个FCB，每个FCB都存储了文件名，文件类型，物理块号，父路径，子目录等信息。而目录区物理块分配与否通过目录的位示图标识。\n\n文件区为Block组成的数组，存储了物理块号以及实际的文件数据。分配文件时,则扫描位示图,找到N个0,并且计算出对应的盘块号,将之分配给文件。并且在FAT中，以静态链接的形式标识出分配的物理块顺序。\n\n程序一直会存储当前路径（即某个FCB）,并且初始化为根路径/，而进行操作时，可以有两种方式：绝对路径，相对路径。相对路径则根据当前路径进行操作。而绝对路径方式，则从目录区获取根路径/的PCB，然后按照层级进行操作。程序还存储一个打开文件表，当打开，读写文件时，就会将文件加入到打开文件表。\n\n## 文件系统可用指令\n\n其中，涉及fileName的指令，fileName都可以有两种写法，一种是从根路径开始的绝对路径写法，例如/usr/local；另外一种是从当前路径开始，例如，temp。\n\n从本地磁盘加载与保存文件是系统自动进行的。如果想要到初始环境，可以执行format指令。\n\n-   退出 exit\n\n-   查看帮助 –help\n\n-   格式化 format\n\n-   显示目录 pwd\n\n-   更改当前目录 cd fileName\n\n-   创建子目录 mkdir fileName\n\n-   删除子目录 rm fileName\n\n-   列出当前目录下所有文件 ls\n\n-   创建文件 touch fileName\n\n-   打开文件 open fileName\n\n-   关闭文件 close fileName\n\n-   写文件 vim fileName\n\n-   读文件 cat fileName\n\n-   删除文件 delete fileName\n\n-   查看目录区信息 dirBlock\n\n-   查看文件区信息 fileBlock\n\n-   查看打开文件表 openFiles\n\n# 项目实现\n\n## Main类实现\n\n>   Main类只是整个程序的入口，他通过new\n>   View（）调用View类执行文件系统主要的逻辑。\n\n##  model包下类的实现\n\n###  Const类的实现\n\n>   Const类存储了程序用到的所有常量,放在一起,便于程序的维护。首先，用DIR=1，FILE=0来标识文件类型，之后可以直接引用，不需要记住是0还是1。随后，记录了目录区物理块数量，以及目录区位示图的尺寸。最后，记录了文件区物理块数量，容量，以及文件区位示图的尺寸。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzZhYjJmOTAxZGFjMTU2MTZjMjZiNGM5ZmI4ZDlhNTEyLnBuZw?x-oss-process=image/format,png)\n\n### FCB的实现\n\n>   一个FCB代表了一个目录项。所以FCB包含以下属性：文件名称（即相对路径名称），文件路径（即绝对路径名称），文件类型（File或者Dir），文件物理块地址，文件物理块长度，文件的子目录（只有文件类型为Dir才有），文件的父路径。\n\n\n>   其中有以下实用函数：\n\n>   getChildren（String\n>   childName）:从该FCB的子目录中查找名称为childName的文件并返回，如果不存在则返回null。\n\n>   remove（String childName）:删除名称为childName的文件并返回删除结果。\n\n>   toString（）:通过使用String.format函数，按照阅读良好的格式输出该FCB。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzVhZWM1MTllYTcxMjE0NDE0MWUzYWQ0ZWM4OTAwNzBlLnBuZw?x-oss-process=image/format,png)\n\n###   Block类的实现\n\n>   Block主要是模拟文件区的物理块。有两个属性：id和data，id代表该块的编号，data为ByteBuffer类型，存储了文件实际的试卷。\n\n## view包下类的实现\n\n>   view包只有一个类View，但是里面有很多函数来实现和用户的交互功能。他有两个成员变量：controller以及ioController，负责调用Controller包下的两个类进行文件管理的具体操作。\n\n### 初始化函数View（）\n\n>   在初始化时，会先从本地磁盘加载上一次退出时文件系统的数据。随后不断接收用户输入的数据，并且根据用户的指令调用相应的函数进行文件管理。值得注意的是，指令有两种模式，一种是equals（），例如exit指令，只有仅仅输入exit时，才会执行相应操作。另外一种是startWith（）模式，会将所有以此开头的指令相匹配，例如mkdir\n>   /usr/local命令就用到这种模式。而且equals模式放在了startWith模式之前，防止一些匹配错误的问题。最后，还在每次输入指令时，显示了当前的用户和路径。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzU1YzU1ZjRjODIwNWIxNTI5YjZkOTY0NDVjOTQ5NjFiLnBuZw?x-oss-process=image/format,png)\n\n### 函数exit（）\n\n>   退出时，调用ioController.save()方法，将本次文件系统的内容保存在本地硬盘中。\n\n### 函数format（）\n\n>   其实就是另外一次初始化，且不加载磁盘中的文件。主要就是将controller，ioController重新初始化。\n\n### 函数help（）\n\n>   通过输入—help，进入该函数，打印本文件系统所支持的所有操作。\n\n###  getCurrentFCB(String command)\n\n>   一个重要的公共函数，负责从command中获取文件的FCB。例如指令mkdir\n>   /usr/local。首先，会将指令按照空格分隔，并且进行有效性检验。随后根据后者的路径是否以/开头进行不同的操作，如果是/开头，则从根目录开始不断查找到它，如果不是，则从当前路径的子目录进行查找。最后将之返回，如果不存在，则返回null。\n\n\n###  checkFileName(String fileName)\n\n>   检验文件名合法性的公共函数，通过正则表达式判断文件名是否合法。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzQ4NTFjNzU3NTQzOGRiMTY2NTY4YjU3YjY1YjQyZjg2LnBuZw?x-oss-process=image/format,png)\n\n###  create(String command, int type)\n\n>   该函数可根据指令创建文件或者命令。首先还是把命令拆分得到文件路径，并且根据是否以/开头执行不同操作，而之后又根据是文件或目录执行不同的创建操作。如果是以/开头，则还是先得到根路径，随后将路径按照/拆分。以/usr/local/temp.txt为例：将之拆分为usr，local，temp.txt。首先校验文件名是否合法。随后如果路径是存在的，则进入路径，例如如果原来存在usr文件夹，则进入，而local文件夹不存在，则创建文件夹（先通过目录位示图得到空闲目录块地址，再将目录磁盘块分配给他，还要新建FCB，并且在他的父路径的子目录中添加他）。随后，又发现temp.txt文件不存在，则创建他（在位示图中分配，在FAT中分配，新建该文件的FCB，另他父路径的子目录添加该FCB）。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Y3MGU5M2ZkNjE5NjZhZDA3MWJkZGE3ZmNhMTZkMjZmLnBuZw?x-oss-process=image/format,png)\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Q1NTNlY2IwNGNiN2RhMmJjZmFlYmIzZmNjODNhMWQwLnBuZw?x-oss-process=image/format,png)\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzllZjdlNGI0MmY5YjY5MmQ5MWYyYzViN2Y4MGUzMWIzLnBuZw?x-oss-process=image/format,png)\n\n###  delete(String command)\n\n>   通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。随后在打开文件表中删除，在位示图移除，在磁盘块删除，在FCB目录中移除，在FAT中回收。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzViNzUzY2RlYTg1YzhmNDQ5ZWVmZjM3NjgwMTg0ZjI4LnBuZw?x-oss-process=image/format,png)\n\n###  write(String command)\n\n>   负责写入文件内容，如果文件不存在会先创建一个。随后通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。然后首先加入打开文件表，之后将用户输入暂存与StringBuilder中，再调用ioController.write()将输入内容写入文件对应的物理磁盘块中。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzdmODEwYTQwZjRhNTYxZjU5ZmEzZmY5NDJkZjQxZjVhLnBuZw?x-oss-process=image/format,png)\n\n###  read(String command)\n\n>   负责读取文件内容。通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。然后首先加入打开文件表，通过ioController.read()将文件内容显示到屏幕上。\n\n###  open(),close()函数\n\n>   通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。将文件添加或者移除打开文件表。\n\n###  rm(String command)函数\n\n>   通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。并且调用rmRecursive（FCB\n>   fcb）将他的子目录以及文件都删除（如果还是目录，则继续调用自己，递归删除所有文件）。最后，再将他本身删除。（在FCB中删除，在目录的位示图中删除，在目录磁盘块中删除）。\n\n\n\n###  cd(String command)\n\n>   照例，先将命令拆分，得到路径。然后需要判断路径是否是.. ../ ./\n>   .等执行特殊操作。若不是，则通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对，或者不是目录则提示并且返回。然后将当前路径设为该FCB。\n\n\n###  ls（）函数\n\n>   首先得到当前路径的子目录，然后全部打印。因为前面说过重写了FCB的toString（）方法，所以格式良好。\n\n###  其他函数\n\n>   pwd（）函数得到controller的当前目录的路径名，并且打印。openFiles()获取controller的打开文件表，并且展示打开文件表中文件名以及占用的物理块号。fileBlock()，dirBlock()则根据文件/目录的位示图，判断出已经使用的磁盘块，并且展示。\n\n\n ##  controller包下类的实现\n\n ###   Controller类\n\n>   成员函数包括：当前的目录项，目录区磁盘块，文件区磁盘块，文件分配表FAT。目录的空闲分区位示图，文件的空闲分区位示图以及打开文件表。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzhkZWUyMTc3YzM2ZjdmNzQzYmIzYmEyYWFiNzJkMmJkLnBuZw?x-oss-process=image/format,png)\n\n####   初始化函数Controller（）：\n\n>   将上述的成员变量初始化。值得注意的是，在FAT中,-1代表结束,其他数字代表下一个物理块指向,所以初始化为-2。并且为根路径分配目录区的物理块0，并且设置为当前目录。\n\n\n####   allocFAT()与freeFAT()：\n\n>   负责FAT的分配与回收，根据之前分配给文件的物理块地址链表，在FAT中进行分配，且FAT的值为下一个物理块索引，最后一块值为-1。回收则是传入文件的起始物理块，随后一直根据FAT中的值寻找到下一个物理块，并且置为-2（未分配状态）。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2RlNGY3ZmNmY2Y4ZGQyNGIxNzlmNGQ2YzY0NWZmMGQ5LnBuZw?x-oss-process=image/format,png)\n\n####   getFreeDirBlock()与setFreeDirBlock(int dirIndex)：\n\n>   负责目录位示图的分配与回收操作。从位示图选取一个未分配的，通过数学转换成一维的目录块索引，并且标记为已分配。而回收则把目录磁盘块索引转为二维位示图坐标，标记为未分配。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4ODVjYjdkODRiMjAxNDM1ZTZjY2VlZjM1MDhkMDI2LnBuZw?x-oss-process=image/format,png)\n\n####  getFreeFileBlock(int size)与setFreeFileBlock(int dirIndex)：\n\n>   负责文件位示图的分配与回收操作。需要传入文件块的大小，以便分配足够的文件物理块。从位示图选取size个未分配的，通过数学转换成一维的文件块索引，并且标记为已分配，返回索引链表。而回收则把文件磁盘块索引转为二维位示图坐标，标记为未分配。\n\n####   addOpenFiles(String address,Integer blockIndex)\n>   负责加入与移除打开文件表。实现很简单，加入就往map中加入键值对（文件的地址，文件起始物理块号）。删除则根据文件地址删除键值对。\n\n\n ###    IOController类\n\nIOController类负责读写文件，并且负责初始时从电脑本地磁盘回复内容到内存（即此虚拟文件管理系统中），还负责退出文件系统时，把文件系统内容保存在电脑本地磁盘中。该类有一个成员变量controller，以获取Controller提供的一些功能。\n\n####  write（）与read（）函数：\n\n负责文件内容的读写，读写都需要传入要操作的文件的PCB，然后写还需要传入写入的文本。随后写则在文件区中寻找该PCB所对应的物理块，并且对他的data区域进行写操作。读操作也是找到对应的物理块进行读操作。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2FkNDQ0YmQ5NGIwMWE3Zjc0ZDVhMjg3Njg1Y2JiNWMzLnBuZw?x-oss-process=image/format,png)\n\n####  load（）与save（）函数：\n\n>   负责将文件系统加载与保存于本地磁盘中。他们是成对的。通过调用函数，他们保存与加载了文件系统中的目录位示图，文件位示图，FAT，目录物理块，文件物理块。基本的操作都是将当前文件系统中的数据按照约定格式写在磁盘中特定的文件中，然后下次启动时，则从这些文件中按之前的格式读取数据并且给他们赋值。\n\n\n\n#### saveBits（）与loadBits（）函数：\n\n>   首先在本地建立文件bits，随后将controller中的文件位示图一行行写入文件中。而恢复则从bits文件一行行赋值给初始的文件位示图bits。\n\n\n#### saveDirBits（）与loadDirBits（）函数：\n\n>   与文件位示图的保存恢复差不多。都是首先在本地建立文件dirBits，随后将controller中的目录位示图一行行写入文件中。而恢复则从dirBits文件一行行赋值给初始的目录位示图bits。\n\n#### saveDirArea（）与loadDirArea（）函数：\n\n也是创建一个文件dirArea来存储数据。策略是按照深度优先搜索算法递归的存储目录信息，并且存储文件所在层级（根目录的层级是0，它所有子目录下文件层级是1，以此类推）。而从已经存储好的目录数据中加载数据时，则一行行的加载目录数据，根据层级重建目录。并且根据层级的变化判断他的父目录。如果层级是递增的，那么文件的上一级目录就是他前面那个，否则则还要回头找到他的父目录。比如层级0,1,2,3,2,3,4\n则第二个2的父目录不是前面的3,而是前面的1。根据文件数据生成FCB后，还需要设置好他的父目录parent和他的子目录children（在他的子文件设置父目录时进行）。\n\n\n#### saveFileArea（）与loadFileArea（）函数：\n\n如果文件位示图中显示某个物理块被占用，则将在写入本地磁盘文件fileArea中，随之写入的还有他的物理块号。而加载时则按行扫描fileArea，并且从中读取文件数据以及对应的物理块号，写在本文件管理系统的特定物理块上。\n\n\n# 项目界面展示\n>这里的图片都混乱了,就删除了,可以运行源码,或者看word版查看效果\n## 目录操作\n\n##   创建文件夹\n\n\n##    删除文件夹\n\n\n##   更改路径\n\n\n## 文件操作\n\n##   创建删除文件\n\n\n##   读写文件\n\n##  文件系统查看操作\n\n## 保存与加载操作\n\n>   退出程序：\n>   重新启动程序：\n\n\n## 其他操作\n\n>   格式化：\n>   帮助文档：\n\n\n","slug":"项目笔记/操作系统_文件系统管理项目","published":1,"updated":"2020-11-12T11:57:30.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o6z70090jotpb7ee81fh","content":"<h1 id=\"文件管理源码-Github地址\"><a href=\"#文件管理源码-Github地址\" class=\"headerlink\" title=\"文件管理源码_Github地址\"></a><a href=\"https://github.com/tongji4m3/fileSystem\" target=\"_blank\" rel=\"noopener\">文件管理源码_Github地址</a></h1><blockquote>\n<p>图片太多,上传之后有些位置错乱或者不显示,可以在源码地址查看word版本</p>\n</blockquote>\n<h1 id=\"项目目的\"><a href=\"#项目目的\" class=\"headerlink\" title=\"项目目的\"></a>项目目的</h1><ul>\n<li><p>理解文件存储空间的管理；</p>\n</li>\n<li><p>掌握文件的物理结构、目录结构和文件操作；</p>\n</li>\n<li><p>实现简单文件系统管理；</p>\n</li>\n<li><p>加深文件系统实现过程的理解；</p>\n</li>\n</ul>\n<h1 id=\"项目需求\"><a href=\"#项目需求\" class=\"headerlink\" title=\"项目需求\"></a>项目需求</h1><h2 id=\"基本要求\"><a href=\"#基本要求\" class=\"headerlink\" title=\"基本要求\"></a>基本要求</h2><ul>\n<li><p>在内存中开辟一个空间作为文件存储器，在其上实现一个简单的文件系统;</p>\n</li>\n<li><p>退出这个文件系统时，需要该文件系统的内容保存到磁盘上，以便下次可以将其回复到内存中来。</p>\n</li>\n</ul>\n<h2 id=\"具体要求\"><a href=\"#具体要求\" class=\"headerlink\" title=\"具体要求\"></a>具体要求</h2><ul>\n<li><p>文件存储空间管理可采取显式链接（如FAT）或者其他方法；</p>\n</li>\n<li><p>空闲空间管理可采用位图或者其他方法；</p>\n</li>\n<li><p>文件目录采用多级目录结构，目录项目中应包含：文件名、物理地址、长度等信息。</p>\n</li>\n</ul>\n<h2 id=\"文件系统提供的操作\"><a href=\"#文件系统提供的操作\" class=\"headerlink\" title=\"文件系统提供的操作\"></a>文件系统提供的操作</h2><pre><code>-   格式化\n\n-   创建子目录\n\n-   删除子目录\n\n-   显示目录\n\n-   更改当前目录\n\n-   创建文件\n\n-   打开文件\n\n-   关闭文件\n\n-   写文件\n\n-   读文件\n\n-   删除文件</code></pre>\n<h1 id=\"项目设计及算法\"><a href=\"#项目设计及算法\" class=\"headerlink\" title=\"项目设计及算法\"></a>项目设计及算法</h1><h2 id=\"项目整体结构\"><a href=\"#项目整体结构\" class=\"headerlink\" title=\"项目整体结构\"></a>项目整体结构</h2><p>本项目是windows平台下,采用java语言开发的，通过命令行互动的文件管理项目。主要采用MVC架构模式,分为三个包(model,view,controller),和一个主类Main。通过主类调用view包下的View类开启命令行交互进行文件管理。</p>\n<p>model包下放置了一些实体类以及常量结合。其中的Const存放一些公共参数，例如物理块的大小，容量等等。FCB类则代表一个文件目录项的实体，存储一些文件名，文件属性，文件物理块地址等信息。Block类则充当了磁盘物理块实体，它存储了物理块地址和数据。</p>\n<p>view包下主要负责和用户进行命令行交互的全部内容，对于用户输入的指令进行判断，并且调用controller以及model包下的类完成功能。例如用户输入ls指令，在View类中，就会判断该指令，并且调用controller得到当前目录，然后得到该目录的所有子目录，再将之按照特定的格式打印并呈现给用户。</p>\n<p>controller包下包含了两个类：Controller，IOController。其中Controller负责对目录区，文件区，FAT，位示图，打开文件表等进行相应的管理，包括分配释放等操作。IOController负责读写文件，并且负责初始时从电脑本地磁盘回复内容到内存（即此虚拟文件管理系统中），还负责退出文件系统时，把文件系统内容保存在电脑本地磁盘中。</p>\n<h2 id=\"项目实现思路\"><a href=\"#项目实现思路\" class=\"headerlink\" title=\"项目实现思路\"></a>项目实现思路</h2><p>首先，当退出程序时，将用来模拟物理块，PCB等数组存储在本地文件之中，而启动程序时，则从本地文件中读取相应的数据，以此达到备份的目的。</p>\n<p>然后，该文件系统主要分为目录位示图，文件位示图，FAT，目录区，文件区五部分组成。文件目录采用多级目录结构。文件存储空间管理采取显式链接管理（FAT），空闲空间管理采用位示图管理。</p>\n<p>目录区为FCB组成的数组。其中每个文件（目录或者文件）对应一个FCB，每个FCB都存储了文件名，文件类型，物理块号，父路径，子目录等信息。而目录区物理块分配与否通过目录的位示图标识。</p>\n<p>文件区为Block组成的数组，存储了物理块号以及实际的文件数据。分配文件时,则扫描位示图,找到N个0,并且计算出对应的盘块号,将之分配给文件。并且在FAT中，以静态链接的形式标识出分配的物理块顺序。</p>\n<p>程序一直会存储当前路径（即某个FCB）,并且初始化为根路径/，而进行操作时，可以有两种方式：绝对路径，相对路径。相对路径则根据当前路径进行操作。而绝对路径方式，则从目录区获取根路径/的PCB，然后按照层级进行操作。程序还存储一个打开文件表，当打开，读写文件时，就会将文件加入到打开文件表。</p>\n<h2 id=\"文件系统可用指令\"><a href=\"#文件系统可用指令\" class=\"headerlink\" title=\"文件系统可用指令\"></a>文件系统可用指令</h2><p>其中，涉及fileName的指令，fileName都可以有两种写法，一种是从根路径开始的绝对路径写法，例如/usr/local；另外一种是从当前路径开始，例如，temp。</p>\n<p>从本地磁盘加载与保存文件是系统自动进行的。如果想要到初始环境，可以执行format指令。</p>\n<ul>\n<li><p>退出 exit</p>\n</li>\n<li><p>查看帮助 –help</p>\n</li>\n<li><p>格式化 format</p>\n</li>\n<li><p>显示目录 pwd</p>\n</li>\n<li><p>更改当前目录 cd fileName</p>\n</li>\n<li><p>创建子目录 mkdir fileName</p>\n</li>\n<li><p>删除子目录 rm fileName</p>\n</li>\n<li><p>列出当前目录下所有文件 ls</p>\n</li>\n<li><p>创建文件 touch fileName</p>\n</li>\n<li><p>打开文件 open fileName</p>\n</li>\n<li><p>关闭文件 close fileName</p>\n</li>\n<li><p>写文件 vim fileName</p>\n</li>\n<li><p>读文件 cat fileName</p>\n</li>\n<li><p>删除文件 delete fileName</p>\n</li>\n<li><p>查看目录区信息 dirBlock</p>\n</li>\n<li><p>查看文件区信息 fileBlock</p>\n</li>\n<li><p>查看打开文件表 openFiles</p>\n</li>\n</ul>\n<h1 id=\"项目实现\"><a href=\"#项目实现\" class=\"headerlink\" title=\"项目实现\"></a>项目实现</h1><h2 id=\"Main类实现\"><a href=\"#Main类实现\" class=\"headerlink\" title=\"Main类实现\"></a>Main类实现</h2><blockquote>\n<p>  Main类只是整个程序的入口，他通过new<br>  View（）调用View类执行文件系统主要的逻辑。</p>\n</blockquote>\n<h2 id=\"model包下类的实现\"><a href=\"#model包下类的实现\" class=\"headerlink\" title=\"model包下类的实现\"></a>model包下类的实现</h2><h3 id=\"Const类的实现\"><a href=\"#Const类的实现\" class=\"headerlink\" title=\"Const类的实现\"></a>Const类的实现</h3><blockquote>\n<p>  Const类存储了程序用到的所有常量,放在一起,便于程序的维护。首先，用DIR=1，FILE=0来标识文件类型，之后可以直接引用，不需要记住是0还是1。随后，记录了目录区物理块数量，以及目录区位示图的尺寸。最后，记录了文件区物理块数量，容量，以及文件区位示图的尺寸。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzZhYjJmOTAxZGFjMTU2MTZjMjZiNGM5ZmI4ZDlhNTEyLnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"FCB的实现\"><a href=\"#FCB的实现\" class=\"headerlink\" title=\"FCB的实现\"></a>FCB的实现</h3><blockquote>\n<p>  一个FCB代表了一个目录项。所以FCB包含以下属性：文件名称（即相对路径名称），文件路径（即绝对路径名称），文件类型（File或者Dir），文件物理块地址，文件物理块长度，文件的子目录（只有文件类型为Dir才有），文件的父路径。</p>\n</blockquote>\n<blockquote>\n<p>  其中有以下实用函数：</p>\n</blockquote>\n<blockquote>\n<p>  getChildren（String<br>  childName）:从该FCB的子目录中查找名称为childName的文件并返回，如果不存在则返回null。</p>\n</blockquote>\n<blockquote>\n<p>  remove（String childName）:删除名称为childName的文件并返回删除结果。</p>\n</blockquote>\n<blockquote>\n<p>  toString（）:通过使用String.format函数，按照阅读良好的格式输出该FCB。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzVhZWM1MTllYTcxMjE0NDE0MWUzYWQ0ZWM4OTAwNzBlLnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"Block类的实现\"><a href=\"#Block类的实现\" class=\"headerlink\" title=\"Block类的实现\"></a>Block类的实现</h3><blockquote>\n<p>  Block主要是模拟文件区的物理块。有两个属性：id和data，id代表该块的编号，data为ByteBuffer类型，存储了文件实际的试卷。</p>\n</blockquote>\n<h2 id=\"view包下类的实现\"><a href=\"#view包下类的实现\" class=\"headerlink\" title=\"view包下类的实现\"></a>view包下类的实现</h2><blockquote>\n<p>  view包只有一个类View，但是里面有很多函数来实现和用户的交互功能。他有两个成员变量：controller以及ioController，负责调用Controller包下的两个类进行文件管理的具体操作。</p>\n</blockquote>\n<h3 id=\"初始化函数View（）\"><a href=\"#初始化函数View（）\" class=\"headerlink\" title=\"初始化函数View（）\"></a>初始化函数View（）</h3><blockquote>\n<p>  在初始化时，会先从本地磁盘加载上一次退出时文件系统的数据。随后不断接收用户输入的数据，并且根据用户的指令调用相应的函数进行文件管理。值得注意的是，指令有两种模式，一种是equals（），例如exit指令，只有仅仅输入exit时，才会执行相应操作。另外一种是startWith（）模式，会将所有以此开头的指令相匹配，例如mkdir<br>  /usr/local命令就用到这种模式。而且equals模式放在了startWith模式之前，防止一些匹配错误的问题。最后，还在每次输入指令时，显示了当前的用户和路径。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzU1YzU1ZjRjODIwNWIxNTI5YjZkOTY0NDVjOTQ5NjFiLnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"函数exit（）\"><a href=\"#函数exit（）\" class=\"headerlink\" title=\"函数exit（）\"></a>函数exit（）</h3><blockquote>\n<p>  退出时，调用ioController.save()方法，将本次文件系统的内容保存在本地硬盘中。</p>\n</blockquote>\n<h3 id=\"函数format（）\"><a href=\"#函数format（）\" class=\"headerlink\" title=\"函数format（）\"></a>函数format（）</h3><blockquote>\n<p>  其实就是另外一次初始化，且不加载磁盘中的文件。主要就是将controller，ioController重新初始化。</p>\n</blockquote>\n<h3 id=\"函数help（）\"><a href=\"#函数help（）\" class=\"headerlink\" title=\"函数help（）\"></a>函数help（）</h3><blockquote>\n<p>  通过输入—help，进入该函数，打印本文件系统所支持的所有操作。</p>\n</blockquote>\n<h3 id=\"getCurrentFCB-String-command\"><a href=\"#getCurrentFCB-String-command\" class=\"headerlink\" title=\"getCurrentFCB(String command)\"></a>getCurrentFCB(String command)</h3><blockquote>\n<p>  一个重要的公共函数，负责从command中获取文件的FCB。例如指令mkdir<br>  /usr/local。首先，会将指令按照空格分隔，并且进行有效性检验。随后根据后者的路径是否以/开头进行不同的操作，如果是/开头，则从根目录开始不断查找到它，如果不是，则从当前路径的子目录进行查找。最后将之返回，如果不存在，则返回null。</p>\n</blockquote>\n<h3 id=\"checkFileName-String-fileName\"><a href=\"#checkFileName-String-fileName\" class=\"headerlink\" title=\"checkFileName(String fileName)\"></a>checkFileName(String fileName)</h3><blockquote>\n<p>  检验文件名合法性的公共函数，通过正则表达式判断文件名是否合法。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzQ4NTFjNzU3NTQzOGRiMTY2NTY4YjU3YjY1YjQyZjg2LnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"create-String-command-int-type\"><a href=\"#create-String-command-int-type\" class=\"headerlink\" title=\"create(String command, int type)\"></a>create(String command, int type)</h3><blockquote>\n<p>  该函数可根据指令创建文件或者命令。首先还是把命令拆分得到文件路径，并且根据是否以/开头执行不同操作，而之后又根据是文件或目录执行不同的创建操作。如果是以/开头，则还是先得到根路径，随后将路径按照/拆分。以/usr/local/temp.txt为例：将之拆分为usr，local，temp.txt。首先校验文件名是否合法。随后如果路径是存在的，则进入路径，例如如果原来存在usr文件夹，则进入，而local文件夹不存在，则创建文件夹（先通过目录位示图得到空闲目录块地址，再将目录磁盘块分配给他，还要新建FCB，并且在他的父路径的子目录中添加他）。随后，又发现temp.txt文件不存在，则创建他（在位示图中分配，在FAT中分配，新建该文件的FCB，另他父路径的子目录添加该FCB）。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Y3MGU5M2ZkNjE5NjZhZDA3MWJkZGE3ZmNhMTZkMjZmLnBuZw?x-oss-process=image/format,png\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Q1NTNlY2IwNGNiN2RhMmJjZmFlYmIzZmNjODNhMWQwLnBuZw?x-oss-process=image/format,png\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzllZjdlNGI0MmY5YjY5MmQ5MWYyYzViN2Y4MGUzMWIzLnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"delete-String-command\"><a href=\"#delete-String-command\" class=\"headerlink\" title=\"delete(String command)\"></a>delete(String command)</h3><blockquote>\n<p>  通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。随后在打开文件表中删除，在位示图移除，在磁盘块删除，在FCB目录中移除，在FAT中回收。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzViNzUzY2RlYTg1YzhmNDQ5ZWVmZjM3NjgwMTg0ZjI4LnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"write-String-command\"><a href=\"#write-String-command\" class=\"headerlink\" title=\"write(String command)\"></a>write(String command)</h3><blockquote>\n<p>  负责写入文件内容，如果文件不存在会先创建一个。随后通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。然后首先加入打开文件表，之后将用户输入暂存与StringBuilder中，再调用ioController.write()将输入内容写入文件对应的物理磁盘块中。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzdmODEwYTQwZjRhNTYxZjU5ZmEzZmY5NDJkZjQxZjVhLnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"read-String-command\"><a href=\"#read-String-command\" class=\"headerlink\" title=\"read(String command)\"></a>read(String command)</h3><blockquote>\n<p>  负责读取文件内容。通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。然后首先加入打开文件表，通过ioController.read()将文件内容显示到屏幕上。</p>\n</blockquote>\n<h3 id=\"open-close-函数\"><a href=\"#open-close-函数\" class=\"headerlink\" title=\"open(),close()函数\"></a>open(),close()函数</h3><blockquote>\n<p>  通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。将文件添加或者移除打开文件表。</p>\n</blockquote>\n<h3 id=\"rm-String-command-函数\"><a href=\"#rm-String-command-函数\" class=\"headerlink\" title=\"rm(String command)函数\"></a>rm(String command)函数</h3><blockquote>\n<p>  通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。并且调用rmRecursive（FCB<br>  fcb）将他的子目录以及文件都删除（如果还是目录，则继续调用自己，递归删除所有文件）。最后，再将他本身删除。（在FCB中删除，在目录的位示图中删除，在目录磁盘块中删除）。</p>\n</blockquote>\n<h3 id=\"cd-String-command\"><a href=\"#cd-String-command\" class=\"headerlink\" title=\"cd(String command)\"></a>cd(String command)</h3><blockquote>\n<p>  照例，先将命令拆分，得到路径。然后需要判断路径是否是.. ../ ./<br>  .等执行特殊操作。若不是，则通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对，或者不是目录则提示并且返回。然后将当前路径设为该FCB。</p>\n</blockquote>\n<h3 id=\"ls（）函数\"><a href=\"#ls（）函数\" class=\"headerlink\" title=\"ls（）函数\"></a>ls（）函数</h3><blockquote>\n<p>  首先得到当前路径的子目录，然后全部打印。因为前面说过重写了FCB的toString（）方法，所以格式良好。</p>\n</blockquote>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><blockquote>\n<p>  pwd（）函数得到controller的当前目录的路径名，并且打印。openFiles()获取controller的打开文件表，并且展示打开文件表中文件名以及占用的物理块号。fileBlock()，dirBlock()则根据文件/目录的位示图，判断出已经使用的磁盘块，并且展示。</p>\n</blockquote>\n<h2 id=\"controller包下类的实现\"><a href=\"#controller包下类的实现\" class=\"headerlink\" title=\"controller包下类的实现\"></a>controller包下类的实现</h2><h3 id=\"Controller类\"><a href=\"#Controller类\" class=\"headerlink\" title=\"Controller类\"></a>Controller类</h3><blockquote>\n<p>  成员函数包括：当前的目录项，目录区磁盘块，文件区磁盘块，文件分配表FAT。目录的空闲分区位示图，文件的空闲分区位示图以及打开文件表。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzhkZWUyMTc3YzM2ZjdmNzQzYmIzYmEyYWFiNzJkMmJkLnBuZw?x-oss-process=image/format,png\"></p>\n<h4 id=\"初始化函数Controller（）：\"><a href=\"#初始化函数Controller（）：\" class=\"headerlink\" title=\"初始化函数Controller（）：\"></a>初始化函数Controller（）：</h4><blockquote>\n<p>  将上述的成员变量初始化。值得注意的是，在FAT中,-1代表结束,其他数字代表下一个物理块指向,所以初始化为-2。并且为根路径分配目录区的物理块0，并且设置为当前目录。</p>\n</blockquote>\n<h4 id=\"allocFAT-与freeFAT-：\"><a href=\"#allocFAT-与freeFAT-：\" class=\"headerlink\" title=\"allocFAT()与freeFAT()：\"></a>allocFAT()与freeFAT()：</h4><blockquote>\n<p>  负责FAT的分配与回收，根据之前分配给文件的物理块地址链表，在FAT中进行分配，且FAT的值为下一个物理块索引，最后一块值为-1。回收则是传入文件的起始物理块，随后一直根据FAT中的值寻找到下一个物理块，并且置为-2（未分配状态）。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2RlNGY3ZmNmY2Y4ZGQyNGIxNzlmNGQ2YzY0NWZmMGQ5LnBuZw?x-oss-process=image/format,png\"></p>\n<h4 id=\"getFreeDirBlock-与setFreeDirBlock-int-dirIndex-：\"><a href=\"#getFreeDirBlock-与setFreeDirBlock-int-dirIndex-：\" class=\"headerlink\" title=\"getFreeDirBlock()与setFreeDirBlock(int dirIndex)：\"></a>getFreeDirBlock()与setFreeDirBlock(int dirIndex)：</h4><blockquote>\n<p>  负责目录位示图的分配与回收操作。从位示图选取一个未分配的，通过数学转换成一维的目录块索引，并且标记为已分配。而回收则把目录磁盘块索引转为二维位示图坐标，标记为未分配。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4ODVjYjdkODRiMjAxNDM1ZTZjY2VlZjM1MDhkMDI2LnBuZw?x-oss-process=image/format,png\"></p>\n<h4 id=\"getFreeFileBlock-int-size-与setFreeFileBlock-int-dirIndex-：\"><a href=\"#getFreeFileBlock-int-size-与setFreeFileBlock-int-dirIndex-：\" class=\"headerlink\" title=\"getFreeFileBlock(int size)与setFreeFileBlock(int dirIndex)：\"></a>getFreeFileBlock(int size)与setFreeFileBlock(int dirIndex)：</h4><blockquote>\n<p>  负责文件位示图的分配与回收操作。需要传入文件块的大小，以便分配足够的文件物理块。从位示图选取size个未分配的，通过数学转换成一维的文件块索引，并且标记为已分配，返回索引链表。而回收则把文件磁盘块索引转为二维位示图坐标，标记为未分配。</p>\n</blockquote>\n<h4 id=\"addOpenFiles-String-address-Integer-blockIndex\"><a href=\"#addOpenFiles-String-address-Integer-blockIndex\" class=\"headerlink\" title=\"addOpenFiles(String address,Integer blockIndex)\"></a>addOpenFiles(String address,Integer blockIndex)</h4><blockquote>\n<p>  负责加入与移除打开文件表。实现很简单，加入就往map中加入键值对（文件的地址，文件起始物理块号）。删除则根据文件地址删除键值对。</p>\n</blockquote>\n<h3 id=\"IOController类\"><a href=\"#IOController类\" class=\"headerlink\" title=\"IOController类\"></a>IOController类</h3><p>IOController类负责读写文件，并且负责初始时从电脑本地磁盘回复内容到内存（即此虚拟文件管理系统中），还负责退出文件系统时，把文件系统内容保存在电脑本地磁盘中。该类有一个成员变量controller，以获取Controller提供的一些功能。</p>\n<h4 id=\"write（）与read（）函数：\"><a href=\"#write（）与read（）函数：\" class=\"headerlink\" title=\"write（）与read（）函数：\"></a>write（）与read（）函数：</h4><p>负责文件内容的读写，读写都需要传入要操作的文件的PCB，然后写还需要传入写入的文本。随后写则在文件区中寻找该PCB所对应的物理块，并且对他的data区域进行写操作。读操作也是找到对应的物理块进行读操作。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2FkNDQ0YmQ5NGIwMWE3Zjc0ZDVhMjg3Njg1Y2JiNWMzLnBuZw?x-oss-process=image/format,png\"></p>\n<h4 id=\"load（）与save（）函数：\"><a href=\"#load（）与save（）函数：\" class=\"headerlink\" title=\"load（）与save（）函数：\"></a>load（）与save（）函数：</h4><blockquote>\n<p>  负责将文件系统加载与保存于本地磁盘中。他们是成对的。通过调用函数，他们保存与加载了文件系统中的目录位示图，文件位示图，FAT，目录物理块，文件物理块。基本的操作都是将当前文件系统中的数据按照约定格式写在磁盘中特定的文件中，然后下次启动时，则从这些文件中按之前的格式读取数据并且给他们赋值。</p>\n</blockquote>\n<h4 id=\"saveBits（）与loadBits（）函数：\"><a href=\"#saveBits（）与loadBits（）函数：\" class=\"headerlink\" title=\"saveBits（）与loadBits（）函数：\"></a>saveBits（）与loadBits（）函数：</h4><blockquote>\n<p>  首先在本地建立文件bits，随后将controller中的文件位示图一行行写入文件中。而恢复则从bits文件一行行赋值给初始的文件位示图bits。</p>\n</blockquote>\n<h4 id=\"saveDirBits（）与loadDirBits（）函数：\"><a href=\"#saveDirBits（）与loadDirBits（）函数：\" class=\"headerlink\" title=\"saveDirBits（）与loadDirBits（）函数：\"></a>saveDirBits（）与loadDirBits（）函数：</h4><blockquote>\n<p>  与文件位示图的保存恢复差不多。都是首先在本地建立文件dirBits，随后将controller中的目录位示图一行行写入文件中。而恢复则从dirBits文件一行行赋值给初始的目录位示图bits。</p>\n</blockquote>\n<h4 id=\"saveDirArea（）与loadDirArea（）函数：\"><a href=\"#saveDirArea（）与loadDirArea（）函数：\" class=\"headerlink\" title=\"saveDirArea（）与loadDirArea（）函数：\"></a>saveDirArea（）与loadDirArea（）函数：</h4><p>也是创建一个文件dirArea来存储数据。策略是按照深度优先搜索算法递归的存储目录信息，并且存储文件所在层级（根目录的层级是0，它所有子目录下文件层级是1，以此类推）。而从已经存储好的目录数据中加载数据时，则一行行的加载目录数据，根据层级重建目录。并且根据层级的变化判断他的父目录。如果层级是递增的，那么文件的上一级目录就是他前面那个，否则则还要回头找到他的父目录。比如层级0,1,2,3,2,3,4<br>则第二个2的父目录不是前面的3,而是前面的1。根据文件数据生成FCB后，还需要设置好他的父目录parent和他的子目录children（在他的子文件设置父目录时进行）。</p>\n<h4 id=\"saveFileArea（）与loadFileArea（）函数：\"><a href=\"#saveFileArea（）与loadFileArea（）函数：\" class=\"headerlink\" title=\"saveFileArea（）与loadFileArea（）函数：\"></a>saveFileArea（）与loadFileArea（）函数：</h4><p>如果文件位示图中显示某个物理块被占用，则将在写入本地磁盘文件fileArea中，随之写入的还有他的物理块号。而加载时则按行扫描fileArea，并且从中读取文件数据以及对应的物理块号，写在本文件管理系统的特定物理块上。</p>\n<h1 id=\"项目界面展示\"><a href=\"#项目界面展示\" class=\"headerlink\" title=\"项目界面展示\"></a>项目界面展示</h1><blockquote>\n<p>这里的图片都混乱了,就删除了,可以运行源码,或者看word版查看效果</p>\n</blockquote>\n<h2 id=\"目录操作\"><a href=\"#目录操作\" class=\"headerlink\" title=\"目录操作\"></a>目录操作</h2><h2 id=\"创建文件夹\"><a href=\"#创建文件夹\" class=\"headerlink\" title=\"创建文件夹\"></a>创建文件夹</h2><h2 id=\"删除文件夹\"><a href=\"#删除文件夹\" class=\"headerlink\" title=\"删除文件夹\"></a>删除文件夹</h2><h2 id=\"更改路径\"><a href=\"#更改路径\" class=\"headerlink\" title=\"更改路径\"></a>更改路径</h2><h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><h2 id=\"创建删除文件\"><a href=\"#创建删除文件\" class=\"headerlink\" title=\"创建删除文件\"></a>创建删除文件</h2><h2 id=\"读写文件\"><a href=\"#读写文件\" class=\"headerlink\" title=\"读写文件\"></a>读写文件</h2><h2 id=\"文件系统查看操作\"><a href=\"#文件系统查看操作\" class=\"headerlink\" title=\"文件系统查看操作\"></a>文件系统查看操作</h2><h2 id=\"保存与加载操作\"><a href=\"#保存与加载操作\" class=\"headerlink\" title=\"保存与加载操作\"></a>保存与加载操作</h2><blockquote>\n<p>  退出程序：<br>  重新启动程序：</p>\n</blockquote>\n<h2 id=\"其他操作\"><a href=\"#其他操作\" class=\"headerlink\" title=\"其他操作\"></a>其他操作</h2><blockquote>\n<p>  格式化：<br>  帮助文档：</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"文件管理源码-Github地址\"><a href=\"#文件管理源码-Github地址\" class=\"headerlink\" title=\"文件管理源码_Github地址\"></a><a href=\"https://github.com/tongji4m3/fileSystem\" target=\"_blank\" rel=\"noopener\">文件管理源码_Github地址</a></h1><blockquote>\n<p>图片太多,上传之后有些位置错乱或者不显示,可以在源码地址查看word版本</p>\n</blockquote>\n<h1 id=\"项目目的\"><a href=\"#项目目的\" class=\"headerlink\" title=\"项目目的\"></a>项目目的</h1><ul>\n<li><p>理解文件存储空间的管理；</p>\n</li>\n<li><p>掌握文件的物理结构、目录结构和文件操作；</p>\n</li>\n<li><p>实现简单文件系统管理；</p>\n</li>\n<li><p>加深文件系统实现过程的理解；</p>\n</li>\n</ul>\n<h1 id=\"项目需求\"><a href=\"#项目需求\" class=\"headerlink\" title=\"项目需求\"></a>项目需求</h1><h2 id=\"基本要求\"><a href=\"#基本要求\" class=\"headerlink\" title=\"基本要求\"></a>基本要求</h2><ul>\n<li><p>在内存中开辟一个空间作为文件存储器，在其上实现一个简单的文件系统;</p>\n</li>\n<li><p>退出这个文件系统时，需要该文件系统的内容保存到磁盘上，以便下次可以将其回复到内存中来。</p>\n</li>\n</ul>\n<h2 id=\"具体要求\"><a href=\"#具体要求\" class=\"headerlink\" title=\"具体要求\"></a>具体要求</h2><ul>\n<li><p>文件存储空间管理可采取显式链接（如FAT）或者其他方法；</p>\n</li>\n<li><p>空闲空间管理可采用位图或者其他方法；</p>\n</li>\n<li><p>文件目录采用多级目录结构，目录项目中应包含：文件名、物理地址、长度等信息。</p>\n</li>\n</ul>\n<h2 id=\"文件系统提供的操作\"><a href=\"#文件系统提供的操作\" class=\"headerlink\" title=\"文件系统提供的操作\"></a>文件系统提供的操作</h2><pre><code>-   格式化\n\n-   创建子目录\n\n-   删除子目录\n\n-   显示目录\n\n-   更改当前目录\n\n-   创建文件\n\n-   打开文件\n\n-   关闭文件\n\n-   写文件\n\n-   读文件\n\n-   删除文件</code></pre>\n<h1 id=\"项目设计及算法\"><a href=\"#项目设计及算法\" class=\"headerlink\" title=\"项目设计及算法\"></a>项目设计及算法</h1><h2 id=\"项目整体结构\"><a href=\"#项目整体结构\" class=\"headerlink\" title=\"项目整体结构\"></a>项目整体结构</h2><p>本项目是windows平台下,采用java语言开发的，通过命令行互动的文件管理项目。主要采用MVC架构模式,分为三个包(model,view,controller),和一个主类Main。通过主类调用view包下的View类开启命令行交互进行文件管理。</p>\n<p>model包下放置了一些实体类以及常量结合。其中的Const存放一些公共参数，例如物理块的大小，容量等等。FCB类则代表一个文件目录项的实体，存储一些文件名，文件属性，文件物理块地址等信息。Block类则充当了磁盘物理块实体，它存储了物理块地址和数据。</p>\n<p>view包下主要负责和用户进行命令行交互的全部内容，对于用户输入的指令进行判断，并且调用controller以及model包下的类完成功能。例如用户输入ls指令，在View类中，就会判断该指令，并且调用controller得到当前目录，然后得到该目录的所有子目录，再将之按照特定的格式打印并呈现给用户。</p>\n<p>controller包下包含了两个类：Controller，IOController。其中Controller负责对目录区，文件区，FAT，位示图，打开文件表等进行相应的管理，包括分配释放等操作。IOController负责读写文件，并且负责初始时从电脑本地磁盘回复内容到内存（即此虚拟文件管理系统中），还负责退出文件系统时，把文件系统内容保存在电脑本地磁盘中。</p>\n<h2 id=\"项目实现思路\"><a href=\"#项目实现思路\" class=\"headerlink\" title=\"项目实现思路\"></a>项目实现思路</h2><p>首先，当退出程序时，将用来模拟物理块，PCB等数组存储在本地文件之中，而启动程序时，则从本地文件中读取相应的数据，以此达到备份的目的。</p>\n<p>然后，该文件系统主要分为目录位示图，文件位示图，FAT，目录区，文件区五部分组成。文件目录采用多级目录结构。文件存储空间管理采取显式链接管理（FAT），空闲空间管理采用位示图管理。</p>\n<p>目录区为FCB组成的数组。其中每个文件（目录或者文件）对应一个FCB，每个FCB都存储了文件名，文件类型，物理块号，父路径，子目录等信息。而目录区物理块分配与否通过目录的位示图标识。</p>\n<p>文件区为Block组成的数组，存储了物理块号以及实际的文件数据。分配文件时,则扫描位示图,找到N个0,并且计算出对应的盘块号,将之分配给文件。并且在FAT中，以静态链接的形式标识出分配的物理块顺序。</p>\n<p>程序一直会存储当前路径（即某个FCB）,并且初始化为根路径/，而进行操作时，可以有两种方式：绝对路径，相对路径。相对路径则根据当前路径进行操作。而绝对路径方式，则从目录区获取根路径/的PCB，然后按照层级进行操作。程序还存储一个打开文件表，当打开，读写文件时，就会将文件加入到打开文件表。</p>\n<h2 id=\"文件系统可用指令\"><a href=\"#文件系统可用指令\" class=\"headerlink\" title=\"文件系统可用指令\"></a>文件系统可用指令</h2><p>其中，涉及fileName的指令，fileName都可以有两种写法，一种是从根路径开始的绝对路径写法，例如/usr/local；另外一种是从当前路径开始，例如，temp。</p>\n<p>从本地磁盘加载与保存文件是系统自动进行的。如果想要到初始环境，可以执行format指令。</p>\n<ul>\n<li><p>退出 exit</p>\n</li>\n<li><p>查看帮助 –help</p>\n</li>\n<li><p>格式化 format</p>\n</li>\n<li><p>显示目录 pwd</p>\n</li>\n<li><p>更改当前目录 cd fileName</p>\n</li>\n<li><p>创建子目录 mkdir fileName</p>\n</li>\n<li><p>删除子目录 rm fileName</p>\n</li>\n<li><p>列出当前目录下所有文件 ls</p>\n</li>\n<li><p>创建文件 touch fileName</p>\n</li>\n<li><p>打开文件 open fileName</p>\n</li>\n<li><p>关闭文件 close fileName</p>\n</li>\n<li><p>写文件 vim fileName</p>\n</li>\n<li><p>读文件 cat fileName</p>\n</li>\n<li><p>删除文件 delete fileName</p>\n</li>\n<li><p>查看目录区信息 dirBlock</p>\n</li>\n<li><p>查看文件区信息 fileBlock</p>\n</li>\n<li><p>查看打开文件表 openFiles</p>\n</li>\n</ul>\n<h1 id=\"项目实现\"><a href=\"#项目实现\" class=\"headerlink\" title=\"项目实现\"></a>项目实现</h1><h2 id=\"Main类实现\"><a href=\"#Main类实现\" class=\"headerlink\" title=\"Main类实现\"></a>Main类实现</h2><blockquote>\n<p>  Main类只是整个程序的入口，他通过new<br>  View（）调用View类执行文件系统主要的逻辑。</p>\n</blockquote>\n<h2 id=\"model包下类的实现\"><a href=\"#model包下类的实现\" class=\"headerlink\" title=\"model包下类的实现\"></a>model包下类的实现</h2><h3 id=\"Const类的实现\"><a href=\"#Const类的实现\" class=\"headerlink\" title=\"Const类的实现\"></a>Const类的实现</h3><blockquote>\n<p>  Const类存储了程序用到的所有常量,放在一起,便于程序的维护。首先，用DIR=1，FILE=0来标识文件类型，之后可以直接引用，不需要记住是0还是1。随后，记录了目录区物理块数量，以及目录区位示图的尺寸。最后，记录了文件区物理块数量，容量，以及文件区位示图的尺寸。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzZhYjJmOTAxZGFjMTU2MTZjMjZiNGM5ZmI4ZDlhNTEyLnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"FCB的实现\"><a href=\"#FCB的实现\" class=\"headerlink\" title=\"FCB的实现\"></a>FCB的实现</h3><blockquote>\n<p>  一个FCB代表了一个目录项。所以FCB包含以下属性：文件名称（即相对路径名称），文件路径（即绝对路径名称），文件类型（File或者Dir），文件物理块地址，文件物理块长度，文件的子目录（只有文件类型为Dir才有），文件的父路径。</p>\n</blockquote>\n<blockquote>\n<p>  其中有以下实用函数：</p>\n</blockquote>\n<blockquote>\n<p>  getChildren（String<br>  childName）:从该FCB的子目录中查找名称为childName的文件并返回，如果不存在则返回null。</p>\n</blockquote>\n<blockquote>\n<p>  remove（String childName）:删除名称为childName的文件并返回删除结果。</p>\n</blockquote>\n<blockquote>\n<p>  toString（）:通过使用String.format函数，按照阅读良好的格式输出该FCB。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzVhZWM1MTllYTcxMjE0NDE0MWUzYWQ0ZWM4OTAwNzBlLnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"Block类的实现\"><a href=\"#Block类的实现\" class=\"headerlink\" title=\"Block类的实现\"></a>Block类的实现</h3><blockquote>\n<p>  Block主要是模拟文件区的物理块。有两个属性：id和data，id代表该块的编号，data为ByteBuffer类型，存储了文件实际的试卷。</p>\n</blockquote>\n<h2 id=\"view包下类的实现\"><a href=\"#view包下类的实现\" class=\"headerlink\" title=\"view包下类的实现\"></a>view包下类的实现</h2><blockquote>\n<p>  view包只有一个类View，但是里面有很多函数来实现和用户的交互功能。他有两个成员变量：controller以及ioController，负责调用Controller包下的两个类进行文件管理的具体操作。</p>\n</blockquote>\n<h3 id=\"初始化函数View（）\"><a href=\"#初始化函数View（）\" class=\"headerlink\" title=\"初始化函数View（）\"></a>初始化函数View（）</h3><blockquote>\n<p>  在初始化时，会先从本地磁盘加载上一次退出时文件系统的数据。随后不断接收用户输入的数据，并且根据用户的指令调用相应的函数进行文件管理。值得注意的是，指令有两种模式，一种是equals（），例如exit指令，只有仅仅输入exit时，才会执行相应操作。另外一种是startWith（）模式，会将所有以此开头的指令相匹配，例如mkdir<br>  /usr/local命令就用到这种模式。而且equals模式放在了startWith模式之前，防止一些匹配错误的问题。最后，还在每次输入指令时，显示了当前的用户和路径。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzU1YzU1ZjRjODIwNWIxNTI5YjZkOTY0NDVjOTQ5NjFiLnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"函数exit（）\"><a href=\"#函数exit（）\" class=\"headerlink\" title=\"函数exit（）\"></a>函数exit（）</h3><blockquote>\n<p>  退出时，调用ioController.save()方法，将本次文件系统的内容保存在本地硬盘中。</p>\n</blockquote>\n<h3 id=\"函数format（）\"><a href=\"#函数format（）\" class=\"headerlink\" title=\"函数format（）\"></a>函数format（）</h3><blockquote>\n<p>  其实就是另外一次初始化，且不加载磁盘中的文件。主要就是将controller，ioController重新初始化。</p>\n</blockquote>\n<h3 id=\"函数help（）\"><a href=\"#函数help（）\" class=\"headerlink\" title=\"函数help（）\"></a>函数help（）</h3><blockquote>\n<p>  通过输入—help，进入该函数，打印本文件系统所支持的所有操作。</p>\n</blockquote>\n<h3 id=\"getCurrentFCB-String-command\"><a href=\"#getCurrentFCB-String-command\" class=\"headerlink\" title=\"getCurrentFCB(String command)\"></a>getCurrentFCB(String command)</h3><blockquote>\n<p>  一个重要的公共函数，负责从command中获取文件的FCB。例如指令mkdir<br>  /usr/local。首先，会将指令按照空格分隔，并且进行有效性检验。随后根据后者的路径是否以/开头进行不同的操作，如果是/开头，则从根目录开始不断查找到它，如果不是，则从当前路径的子目录进行查找。最后将之返回，如果不存在，则返回null。</p>\n</blockquote>\n<h3 id=\"checkFileName-String-fileName\"><a href=\"#checkFileName-String-fileName\" class=\"headerlink\" title=\"checkFileName(String fileName)\"></a>checkFileName(String fileName)</h3><blockquote>\n<p>  检验文件名合法性的公共函数，通过正则表达式判断文件名是否合法。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzQ4NTFjNzU3NTQzOGRiMTY2NTY4YjU3YjY1YjQyZjg2LnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"create-String-command-int-type\"><a href=\"#create-String-command-int-type\" class=\"headerlink\" title=\"create(String command, int type)\"></a>create(String command, int type)</h3><blockquote>\n<p>  该函数可根据指令创建文件或者命令。首先还是把命令拆分得到文件路径，并且根据是否以/开头执行不同操作，而之后又根据是文件或目录执行不同的创建操作。如果是以/开头，则还是先得到根路径，随后将路径按照/拆分。以/usr/local/temp.txt为例：将之拆分为usr，local，temp.txt。首先校验文件名是否合法。随后如果路径是存在的，则进入路径，例如如果原来存在usr文件夹，则进入，而local文件夹不存在，则创建文件夹（先通过目录位示图得到空闲目录块地址，再将目录磁盘块分配给他，还要新建FCB，并且在他的父路径的子目录中添加他）。随后，又发现temp.txt文件不存在，则创建他（在位示图中分配，在FAT中分配，新建该文件的FCB，另他父路径的子目录添加该FCB）。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Y3MGU5M2ZkNjE5NjZhZDA3MWJkZGE3ZmNhMTZkMjZmLnBuZw?x-oss-process=image/format,png\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2Q1NTNlY2IwNGNiN2RhMmJjZmFlYmIzZmNjODNhMWQwLnBuZw?x-oss-process=image/format,png\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzllZjdlNGI0MmY5YjY5MmQ5MWYyYzViN2Y4MGUzMWIzLnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"delete-String-command\"><a href=\"#delete-String-command\" class=\"headerlink\" title=\"delete(String command)\"></a>delete(String command)</h3><blockquote>\n<p>  通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。随后在打开文件表中删除，在位示图移除，在磁盘块删除，在FCB目录中移除，在FAT中回收。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzViNzUzY2RlYTg1YzhmNDQ5ZWVmZjM3NjgwMTg0ZjI4LnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"write-String-command\"><a href=\"#write-String-command\" class=\"headerlink\" title=\"write(String command)\"></a>write(String command)</h3><blockquote>\n<p>  负责写入文件内容，如果文件不存在会先创建一个。随后通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。然后首先加入打开文件表，之后将用户输入暂存与StringBuilder中，再调用ioController.write()将输入内容写入文件对应的物理磁盘块中。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzdmODEwYTQwZjRhNTYxZjU5ZmEzZmY5NDJkZjQxZjVhLnBuZw?x-oss-process=image/format,png\"></p>\n<h3 id=\"read-String-command\"><a href=\"#read-String-command\" class=\"headerlink\" title=\"read(String command)\"></a>read(String command)</h3><blockquote>\n<p>  负责读取文件内容。通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。然后首先加入打开文件表，通过ioController.read()将文件内容显示到屏幕上。</p>\n</blockquote>\n<h3 id=\"open-close-函数\"><a href=\"#open-close-函数\" class=\"headerlink\" title=\"open(),close()函数\"></a>open(),close()函数</h3><blockquote>\n<p>  通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。将文件添加或者移除打开文件表。</p>\n</blockquote>\n<h3 id=\"rm-String-command-函数\"><a href=\"#rm-String-command-函数\" class=\"headerlink\" title=\"rm(String command)函数\"></a>rm(String command)函数</h3><blockquote>\n<p>  通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对则提示并且返回。并且调用rmRecursive（FCB<br>  fcb）将他的子目录以及文件都删除（如果还是目录，则继续调用自己，递归删除所有文件）。最后，再将他本身删除。（在FCB中删除，在目录的位示图中删除，在目录磁盘块中删除）。</p>\n</blockquote>\n<h3 id=\"cd-String-command\"><a href=\"#cd-String-command\" class=\"headerlink\" title=\"cd(String command)\"></a>cd(String command)</h3><blockquote>\n<p>  照例，先将命令拆分，得到路径。然后需要判断路径是否是.. ../ ./<br>  .等执行特殊操作。若不是，则通过调用getCurrentFCB(command)指令得到该指令里的文件的FCB，如果文件名不对，或者不是目录则提示并且返回。然后将当前路径设为该FCB。</p>\n</blockquote>\n<h3 id=\"ls（）函数\"><a href=\"#ls（）函数\" class=\"headerlink\" title=\"ls（）函数\"></a>ls（）函数</h3><blockquote>\n<p>  首先得到当前路径的子目录，然后全部打印。因为前面说过重写了FCB的toString（）方法，所以格式良好。</p>\n</blockquote>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><blockquote>\n<p>  pwd（）函数得到controller的当前目录的路径名，并且打印。openFiles()获取controller的打开文件表，并且展示打开文件表中文件名以及占用的物理块号。fileBlock()，dirBlock()则根据文件/目录的位示图，判断出已经使用的磁盘块，并且展示。</p>\n</blockquote>\n<h2 id=\"controller包下类的实现\"><a href=\"#controller包下类的实现\" class=\"headerlink\" title=\"controller包下类的实现\"></a>controller包下类的实现</h2><h3 id=\"Controller类\"><a href=\"#Controller类\" class=\"headerlink\" title=\"Controller类\"></a>Controller类</h3><blockquote>\n<p>  成员函数包括：当前的目录项，目录区磁盘块，文件区磁盘块，文件分配表FAT。目录的空闲分区位示图，文件的空闲分区位示图以及打开文件表。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzhkZWUyMTc3YzM2ZjdmNzQzYmIzYmEyYWFiNzJkMmJkLnBuZw?x-oss-process=image/format,png\"></p>\n<h4 id=\"初始化函数Controller（）：\"><a href=\"#初始化函数Controller（）：\" class=\"headerlink\" title=\"初始化函数Controller（）：\"></a>初始化函数Controller（）：</h4><blockquote>\n<p>  将上述的成员变量初始化。值得注意的是，在FAT中,-1代表结束,其他数字代表下一个物理块指向,所以初始化为-2。并且为根路径分配目录区的物理块0，并且设置为当前目录。</p>\n</blockquote>\n<h4 id=\"allocFAT-与freeFAT-：\"><a href=\"#allocFAT-与freeFAT-：\" class=\"headerlink\" title=\"allocFAT()与freeFAT()：\"></a>allocFAT()与freeFAT()：</h4><blockquote>\n<p>  负责FAT的分配与回收，根据之前分配给文件的物理块地址链表，在FAT中进行分配，且FAT的值为下一个物理块索引，最后一块值为-1。回收则是传入文件的起始物理块，随后一直根据FAT中的值寻找到下一个物理块，并且置为-2（未分配状态）。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2RlNGY3ZmNmY2Y4ZGQyNGIxNzlmNGQ2YzY0NWZmMGQ5LnBuZw?x-oss-process=image/format,png\"></p>\n<h4 id=\"getFreeDirBlock-与setFreeDirBlock-int-dirIndex-：\"><a href=\"#getFreeDirBlock-与setFreeDirBlock-int-dirIndex-：\" class=\"headerlink\" title=\"getFreeDirBlock()与setFreeDirBlock(int dirIndex)：\"></a>getFreeDirBlock()与setFreeDirBlock(int dirIndex)：</h4><blockquote>\n<p>  负责目录位示图的分配与回收操作。从位示图选取一个未分配的，通过数学转换成一维的目录块索引，并且标记为已分配。而回收则把目录磁盘块索引转为二维位示图坐标，标记为未分配。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4ODVjYjdkODRiMjAxNDM1ZTZjY2VlZjM1MDhkMDI2LnBuZw?x-oss-process=image/format,png\"></p>\n<h4 id=\"getFreeFileBlock-int-size-与setFreeFileBlock-int-dirIndex-：\"><a href=\"#getFreeFileBlock-int-size-与setFreeFileBlock-int-dirIndex-：\" class=\"headerlink\" title=\"getFreeFileBlock(int size)与setFreeFileBlock(int dirIndex)：\"></a>getFreeFileBlock(int size)与setFreeFileBlock(int dirIndex)：</h4><blockquote>\n<p>  负责文件位示图的分配与回收操作。需要传入文件块的大小，以便分配足够的文件物理块。从位示图选取size个未分配的，通过数学转换成一维的文件块索引，并且标记为已分配，返回索引链表。而回收则把文件磁盘块索引转为二维位示图坐标，标记为未分配。</p>\n</blockquote>\n<h4 id=\"addOpenFiles-String-address-Integer-blockIndex\"><a href=\"#addOpenFiles-String-address-Integer-blockIndex\" class=\"headerlink\" title=\"addOpenFiles(String address,Integer blockIndex)\"></a>addOpenFiles(String address,Integer blockIndex)</h4><blockquote>\n<p>  负责加入与移除打开文件表。实现很简单，加入就往map中加入键值对（文件的地址，文件起始物理块号）。删除则根据文件地址删除键值对。</p>\n</blockquote>\n<h3 id=\"IOController类\"><a href=\"#IOController类\" class=\"headerlink\" title=\"IOController类\"></a>IOController类</h3><p>IOController类负责读写文件，并且负责初始时从电脑本地磁盘回复内容到内存（即此虚拟文件管理系统中），还负责退出文件系统时，把文件系统内容保存在电脑本地磁盘中。该类有一个成员变量controller，以获取Controller提供的一些功能。</p>\n<h4 id=\"write（）与read（）函数：\"><a href=\"#write（）与read（）函数：\" class=\"headerlink\" title=\"write（）与read（）函数：\"></a>write（）与read（）函数：</h4><p>负责文件内容的读写，读写都需要传入要操作的文件的PCB，然后写还需要传入写入的文本。随后写则在文件区中寻找该PCB所对应的物理块，并且对他的data区域进行写操作。读操作也是找到对应的物理块进行读操作。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90b25namk0bTMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL2FkNDQ0YmQ5NGIwMWE3Zjc0ZDVhMjg3Njg1Y2JiNWMzLnBuZw?x-oss-process=image/format,png\"></p>\n<h4 id=\"load（）与save（）函数：\"><a href=\"#load（）与save（）函数：\" class=\"headerlink\" title=\"load（）与save（）函数：\"></a>load（）与save（）函数：</h4><blockquote>\n<p>  负责将文件系统加载与保存于本地磁盘中。他们是成对的。通过调用函数，他们保存与加载了文件系统中的目录位示图，文件位示图，FAT，目录物理块，文件物理块。基本的操作都是将当前文件系统中的数据按照约定格式写在磁盘中特定的文件中，然后下次启动时，则从这些文件中按之前的格式读取数据并且给他们赋值。</p>\n</blockquote>\n<h4 id=\"saveBits（）与loadBits（）函数：\"><a href=\"#saveBits（）与loadBits（）函数：\" class=\"headerlink\" title=\"saveBits（）与loadBits（）函数：\"></a>saveBits（）与loadBits（）函数：</h4><blockquote>\n<p>  首先在本地建立文件bits，随后将controller中的文件位示图一行行写入文件中。而恢复则从bits文件一行行赋值给初始的文件位示图bits。</p>\n</blockquote>\n<h4 id=\"saveDirBits（）与loadDirBits（）函数：\"><a href=\"#saveDirBits（）与loadDirBits（）函数：\" class=\"headerlink\" title=\"saveDirBits（）与loadDirBits（）函数：\"></a>saveDirBits（）与loadDirBits（）函数：</h4><blockquote>\n<p>  与文件位示图的保存恢复差不多。都是首先在本地建立文件dirBits，随后将controller中的目录位示图一行行写入文件中。而恢复则从dirBits文件一行行赋值给初始的目录位示图bits。</p>\n</blockquote>\n<h4 id=\"saveDirArea（）与loadDirArea（）函数：\"><a href=\"#saveDirArea（）与loadDirArea（）函数：\" class=\"headerlink\" title=\"saveDirArea（）与loadDirArea（）函数：\"></a>saveDirArea（）与loadDirArea（）函数：</h4><p>也是创建一个文件dirArea来存储数据。策略是按照深度优先搜索算法递归的存储目录信息，并且存储文件所在层级（根目录的层级是0，它所有子目录下文件层级是1，以此类推）。而从已经存储好的目录数据中加载数据时，则一行行的加载目录数据，根据层级重建目录。并且根据层级的变化判断他的父目录。如果层级是递增的，那么文件的上一级目录就是他前面那个，否则则还要回头找到他的父目录。比如层级0,1,2,3,2,3,4<br>则第二个2的父目录不是前面的3,而是前面的1。根据文件数据生成FCB后，还需要设置好他的父目录parent和他的子目录children（在他的子文件设置父目录时进行）。</p>\n<h4 id=\"saveFileArea（）与loadFileArea（）函数：\"><a href=\"#saveFileArea（）与loadFileArea（）函数：\" class=\"headerlink\" title=\"saveFileArea（）与loadFileArea（）函数：\"></a>saveFileArea（）与loadFileArea（）函数：</h4><p>如果文件位示图中显示某个物理块被占用，则将在写入本地磁盘文件fileArea中，随之写入的还有他的物理块号。而加载时则按行扫描fileArea，并且从中读取文件数据以及对应的物理块号，写在本文件管理系统的特定物理块上。</p>\n<h1 id=\"项目界面展示\"><a href=\"#项目界面展示\" class=\"headerlink\" title=\"项目界面展示\"></a>项目界面展示</h1><blockquote>\n<p>这里的图片都混乱了,就删除了,可以运行源码,或者看word版查看效果</p>\n</blockquote>\n<h2 id=\"目录操作\"><a href=\"#目录操作\" class=\"headerlink\" title=\"目录操作\"></a>目录操作</h2><h2 id=\"创建文件夹\"><a href=\"#创建文件夹\" class=\"headerlink\" title=\"创建文件夹\"></a>创建文件夹</h2><h2 id=\"删除文件夹\"><a href=\"#删除文件夹\" class=\"headerlink\" title=\"删除文件夹\"></a>删除文件夹</h2><h2 id=\"更改路径\"><a href=\"#更改路径\" class=\"headerlink\" title=\"更改路径\"></a>更改路径</h2><h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><h2 id=\"创建删除文件\"><a href=\"#创建删除文件\" class=\"headerlink\" title=\"创建删除文件\"></a>创建删除文件</h2><h2 id=\"读写文件\"><a href=\"#读写文件\" class=\"headerlink\" title=\"读写文件\"></a>读写文件</h2><h2 id=\"文件系统查看操作\"><a href=\"#文件系统查看操作\" class=\"headerlink\" title=\"文件系统查看操作\"></a>文件系统查看操作</h2><h2 id=\"保存与加载操作\"><a href=\"#保存与加载操作\" class=\"headerlink\" title=\"保存与加载操作\"></a>保存与加载操作</h2><blockquote>\n<p>  退出程序：<br>  重新启动程序：</p>\n</blockquote>\n<h2 id=\"其他操作\"><a href=\"#其他操作\" class=\"headerlink\" title=\"其他操作\"></a>其他操作</h2><blockquote>\n<p>  格式化：<br>  帮助文档：</p>\n</blockquote>\n"},{"title":"第三章--操作符","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第三章--操作符。位运算等","abbrlink":"5631a281","date":"2020-10-16T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n# 细节\n\n+ 操作符作用于操作数,生成一个新值.有些操作符可能会改变操作数自身的值,称为副作用.\n+ `String`后面跟着`+`与非`String`对象,则会把后面对象转为`String`\n+ 基本数据类型存储了实际的数值,是直接把一个地方的内容复制到了另一个地方\n+ 在为对象赋值时,实际上是将引用从一个地方复制到另一个地方,他们都会指向原先引用所指向的对象,指向相同的对象\n+ 方法中对象传递的是引用,因此可以改变`f()`范围之外的对象\n+ `==`与`!=`比较的是对象的引用,要比较内容,则应该使用`equals()`方法,但是基本类型使用`==`即可\n+ `equals()`方法底层默认用`==`比较,自定义的类如果要比较值,则要自己实现`equals()`方法\n\n# 直接常量\n\n后缀标识标志了他们的类型\n\n+ 大写的`L`代表`long`\n+ 大写的`F`代表`float`\n\n前缀标识\n\n+ `0X`标识十六进制\n+ `0b`标识二进制\n\n如果编译器能正确识别类型,则不必在数值后附加字符,例如`long n=200`\n\n而对于指数标记法,例如`1e-43`,通常作为双精度数处理.如果没有`f`,则会有错误提示.`float x = 1e-43f;`\n\n# 移位操作符\n\n+ 左移位操作符:`<<`,右边补0\n+ 有符号右移位操作符:`>>`,使用符号扩展,若符号为正,则在高位插入0,否则插入1\n+ 无符号右移位操作符:`>>>`,无论正负,都在高位插入0\n\n# 类型转换\n\n+ 窄化转换:将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型.面临信息丢失的危险.编译器此时就会强制要求我们进行类型转换\n+ 扩展转换:不必显式进行类型转换,因为新类型肯定能容纳原来类型的信息\n+ 如果对基本数据类型执行算术运算或移位运算,`char`,`byte`,`short`在运算前自动转换成`int`,最终生成的类型就是`int`类型\n+ 表达式中出现的最大数据类型决定了表达式最终结果的数据类型\n+ 不能对布尔值进行其他任何运算\n\n# 标签\n\n+ 带标签的`continue`会到达标签的位置,并重新进入紧接在那个标签后面的循环\n+ 带标签的`break`会中断并跳出标签所指的循环\n+ 在`Java`中使用标签的唯一理由是因为有嵌套循环存在,而且想从多层嵌套中`break`或`continue`\n\n```java\nTEST:\nfor(char ch:\"ABC\".toCharArray())\n{\n    for (int i = 0; i < 1000; i++)\n    {\n        System.out.print(ch);\n        if(i==10)\n        {\n            break TEST;\n        }\n    }\n}\n//AAAAAAAAAAA\n```\n\n```java\nTEST:\nfor(char ch:\"ABC\".toCharArray())\n{\n    for (int i = 0; i < 1000; i++)\n    {\n        System.out.print(ch);\n        if(i==10)\n        {\n            continue TEST;\n        }\n    }\n}\n//AAAAAAAAAAABBBBBBBBBBBCCCCCCCCCCC\n```","source":"_posts/Java笔记/Java编程思想/03_操作符.md","raw":"---\ntitle: 第三章--操作符\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第三章--操作符。位运算等'\ncategories: Java编程思想\ntags:\n  - Java基础\n  - 操作符\nabbrlink: 5631a281\ndate: 2020-10-17 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n# 细节\n\n+ 操作符作用于操作数,生成一个新值.有些操作符可能会改变操作数自身的值,称为副作用.\n+ `String`后面跟着`+`与非`String`对象,则会把后面对象转为`String`\n+ 基本数据类型存储了实际的数值,是直接把一个地方的内容复制到了另一个地方\n+ 在为对象赋值时,实际上是将引用从一个地方复制到另一个地方,他们都会指向原先引用所指向的对象,指向相同的对象\n+ 方法中对象传递的是引用,因此可以改变`f()`范围之外的对象\n+ `==`与`!=`比较的是对象的引用,要比较内容,则应该使用`equals()`方法,但是基本类型使用`==`即可\n+ `equals()`方法底层默认用`==`比较,自定义的类如果要比较值,则要自己实现`equals()`方法\n\n# 直接常量\n\n后缀标识标志了他们的类型\n\n+ 大写的`L`代表`long`\n+ 大写的`F`代表`float`\n\n前缀标识\n\n+ `0X`标识十六进制\n+ `0b`标识二进制\n\n如果编译器能正确识别类型,则不必在数值后附加字符,例如`long n=200`\n\n而对于指数标记法,例如`1e-43`,通常作为双精度数处理.如果没有`f`,则会有错误提示.`float x = 1e-43f;`\n\n# 移位操作符\n\n+ 左移位操作符:`<<`,右边补0\n+ 有符号右移位操作符:`>>`,使用符号扩展,若符号为正,则在高位插入0,否则插入1\n+ 无符号右移位操作符:`>>>`,无论正负,都在高位插入0\n\n# 类型转换\n\n+ 窄化转换:将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型.面临信息丢失的危险.编译器此时就会强制要求我们进行类型转换\n+ 扩展转换:不必显式进行类型转换,因为新类型肯定能容纳原来类型的信息\n+ 如果对基本数据类型执行算术运算或移位运算,`char`,`byte`,`short`在运算前自动转换成`int`,最终生成的类型就是`int`类型\n+ 表达式中出现的最大数据类型决定了表达式最终结果的数据类型\n+ 不能对布尔值进行其他任何运算\n\n# 标签\n\n+ 带标签的`continue`会到达标签的位置,并重新进入紧接在那个标签后面的循环\n+ 带标签的`break`会中断并跳出标签所指的循环\n+ 在`Java`中使用标签的唯一理由是因为有嵌套循环存在,而且想从多层嵌套中`break`或`continue`\n\n```java\nTEST:\nfor(char ch:\"ABC\".toCharArray())\n{\n    for (int i = 0; i < 1000; i++)\n    {\n        System.out.print(ch);\n        if(i==10)\n        {\n            break TEST;\n        }\n    }\n}\n//AAAAAAAAAAA\n```\n\n```java\nTEST:\nfor(char ch:\"ABC\".toCharArray())\n{\n    for (int i = 0; i < 1000; i++)\n    {\n        System.out.print(ch);\n        if(i==10)\n        {\n            continue TEST;\n        }\n    }\n}\n//AAAAAAAAAAABBBBBBBBBBBCCCCCCCCCCC\n```","slug":"Java笔记/Java编程思想/03_操作符","published":1,"updated":"2021-02-04T00:43:43.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o72y00mdjotpdxcggkhv","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ul>\n<li>操作符作用于操作数,生成一个新值.有些操作符可能会改变操作数自身的值,称为副作用.</li>\n<li><code>String</code>后面跟着<code>+</code>与非<code>String</code>对象,则会把后面对象转为<code>String</code></li>\n<li>基本数据类型存储了实际的数值,是直接把一个地方的内容复制到了另一个地方</li>\n<li>在为对象赋值时,实际上是将引用从一个地方复制到另一个地方,他们都会指向原先引用所指向的对象,指向相同的对象</li>\n<li>方法中对象传递的是引用,因此可以改变<code>f()</code>范围之外的对象</li>\n<li><code>==</code>与<code>!=</code>比较的是对象的引用,要比较内容,则应该使用<code>equals()</code>方法,但是基本类型使用<code>==</code>即可</li>\n<li><code>equals()</code>方法底层默认用<code>==</code>比较,自定义的类如果要比较值,则要自己实现<code>equals()</code>方法</li>\n</ul>\n<h1 id=\"直接常量\"><a href=\"#直接常量\" class=\"headerlink\" title=\"直接常量\"></a>直接常量</h1><p>后缀标识标志了他们的类型</p>\n<ul>\n<li>大写的<code>L</code>代表<code>long</code></li>\n<li>大写的<code>F</code>代表<code>float</code></li>\n</ul>\n<p>前缀标识</p>\n<ul>\n<li><code>0X</code>标识十六进制</li>\n<li><code>0b</code>标识二进制</li>\n</ul>\n<p>如果编译器能正确识别类型,则不必在数值后附加字符,例如<code>long n=200</code></p>\n<p>而对于指数标记法,例如<code>1e-43</code>,通常作为双精度数处理.如果没有<code>f</code>,则会有错误提示.<code>float x = 1e-43f;</code></p>\n<h1 id=\"移位操作符\"><a href=\"#移位操作符\" class=\"headerlink\" title=\"移位操作符\"></a>移位操作符</h1><ul>\n<li>左移位操作符:<code>&lt;&lt;</code>,右边补0</li>\n<li>有符号右移位操作符:<code>&gt;&gt;</code>,使用符号扩展,若符号为正,则在高位插入0,否则插入1</li>\n<li>无符号右移位操作符:<code>&gt;&gt;&gt;</code>,无论正负,都在高位插入0</li>\n</ul>\n<h1 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h1><ul>\n<li>窄化转换:将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型.面临信息丢失的危险.编译器此时就会强制要求我们进行类型转换</li>\n<li>扩展转换:不必显式进行类型转换,因为新类型肯定能容纳原来类型的信息</li>\n<li>如果对基本数据类型执行算术运算或移位运算,<code>char</code>,<code>byte</code>,<code>short</code>在运算前自动转换成<code>int</code>,最终生成的类型就是<code>int</code>类型</li>\n<li>表达式中出现的最大数据类型决定了表达式最终结果的数据类型</li>\n<li>不能对布尔值进行其他任何运算</li>\n</ul>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><ul>\n<li>带标签的<code>continue</code>会到达标签的位置,并重新进入紧接在那个标签后面的循环</li>\n<li>带标签的<code>break</code>会中断并跳出标签所指的循环</li>\n<li>在<code>Java</code>中使用标签的唯一理由是因为有嵌套循环存在,而且想从多层嵌套中<code>break</code>或<code>continue</code></li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\">TEST<span class=\"token operator\">:</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> ch<span class=\"token operator\">:</span><span class=\"token string\">\"ABC\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">==</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">break</span> TEST<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//AAAAAAAAAAA</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">TEST<span class=\"token operator\">:</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> ch<span class=\"token operator\">:</span><span class=\"token string\">\"ABC\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">==</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">continue</span> TEST<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//AAAAAAAAAAABBBBBBBBBBBCCCCCCCCCCC</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1><ul>\n<li>操作符作用于操作数,生成一个新值.有些操作符可能会改变操作数自身的值,称为副作用.</li>\n<li><code>String</code>后面跟着<code>+</code>与非<code>String</code>对象,则会把后面对象转为<code>String</code></li>\n<li>基本数据类型存储了实际的数值,是直接把一个地方的内容复制到了另一个地方</li>\n<li>在为对象赋值时,实际上是将引用从一个地方复制到另一个地方,他们都会指向原先引用所指向的对象,指向相同的对象</li>\n<li>方法中对象传递的是引用,因此可以改变<code>f()</code>范围之外的对象</li>\n<li><code>==</code>与<code>!=</code>比较的是对象的引用,要比较内容,则应该使用<code>equals()</code>方法,但是基本类型使用<code>==</code>即可</li>\n<li><code>equals()</code>方法底层默认用<code>==</code>比较,自定义的类如果要比较值,则要自己实现<code>equals()</code>方法</li>\n</ul>\n<h1 id=\"直接常量\"><a href=\"#直接常量\" class=\"headerlink\" title=\"直接常量\"></a>直接常量</h1><p>后缀标识标志了他们的类型</p>\n<ul>\n<li>大写的<code>L</code>代表<code>long</code></li>\n<li>大写的<code>F</code>代表<code>float</code></li>\n</ul>\n<p>前缀标识</p>\n<ul>\n<li><code>0X</code>标识十六进制</li>\n<li><code>0b</code>标识二进制</li>\n</ul>\n<p>如果编译器能正确识别类型,则不必在数值后附加字符,例如<code>long n=200</code></p>\n<p>而对于指数标记法,例如<code>1e-43</code>,通常作为双精度数处理.如果没有<code>f</code>,则会有错误提示.<code>float x = 1e-43f;</code></p>\n<h1 id=\"移位操作符\"><a href=\"#移位操作符\" class=\"headerlink\" title=\"移位操作符\"></a>移位操作符</h1><ul>\n<li>左移位操作符:<code>&lt;&lt;</code>,右边补0</li>\n<li>有符号右移位操作符:<code>&gt;&gt;</code>,使用符号扩展,若符号为正,则在高位插入0,否则插入1</li>\n<li>无符号右移位操作符:<code>&gt;&gt;&gt;</code>,无论正负,都在高位插入0</li>\n</ul>\n<h1 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h1><ul>\n<li>窄化转换:将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型.面临信息丢失的危险.编译器此时就会强制要求我们进行类型转换</li>\n<li>扩展转换:不必显式进行类型转换,因为新类型肯定能容纳原来类型的信息</li>\n<li>如果对基本数据类型执行算术运算或移位运算,<code>char</code>,<code>byte</code>,<code>short</code>在运算前自动转换成<code>int</code>,最终生成的类型就是<code>int</code>类型</li>\n<li>表达式中出现的最大数据类型决定了表达式最终结果的数据类型</li>\n<li>不能对布尔值进行其他任何运算</li>\n</ul>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><ul>\n<li>带标签的<code>continue</code>会到达标签的位置,并重新进入紧接在那个标签后面的循环</li>\n<li>带标签的<code>break</code>会中断并跳出标签所指的循环</li>\n<li>在<code>Java</code>中使用标签的唯一理由是因为有嵌套循环存在,而且想从多层嵌套中<code>break</code>或<code>continue</code></li>\n</ul>\n<pre><code class=\"java\">TEST:\nfor(char ch:&quot;ABC&quot;.toCharArray())\n{\n    for (int i = 0; i &lt; 1000; i++)\n    {\n        System.out.print(ch);\n        if(i==10)\n        {\n            break TEST;\n        }\n    }\n}\n//AAAAAAAAAAA</code></pre>\n<pre><code class=\"java\">TEST:\nfor(char ch:&quot;ABC&quot;.toCharArray())\n{\n    for (int i = 0; i &lt; 1000; i++)\n    {\n        System.out.print(ch);\n        if(i==10)\n        {\n            continue TEST;\n        }\n    }\n}\n//AAAAAAAAAAABBBBBBBBBBBCCCCCCCCCCC</code></pre>\n"},{"title":"第二章--一切皆是对象","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第二章--一切皆是对象。","abbrlink":"256ce7dc","date":"2020-10-16T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n# 对象\n\n## 数据类型\n\n创建一个并非是引用的自动变量,直接存储值,并放在堆栈中\n\n所有数值类型都有正负号\n\n> int 4字节 (-2的31次方)~(2的31次方-1) 超过20亿\n>\n> short 2字节\n>\n> long 8字节\n>\n> byte 1字节 [-128,127]\n>\n> float 四字节\n>\n> double 8字节\n>\n> char 2字节     因为Java采用16位的Unicode字符集 [0,65535]\n>\n> boolean 只有两个值,但是大小没精确定义，一般一字节\n\n### 高精度数字\n\n+ `BigInteger`支持任意精度的整数\n+ `BigDecimal`支持任意精度的定点数\n\n## 数组\n\n当创建一个数组对象时,实际上就是创建了一个引用数组,并且每个引用都会自动被初始化为一个特定值,该值拥有自己的关键字`null`,说明没有指向某个对象。\n\n在使用任何引用前，必须为其指定一个对象，如果试图使用一个还是`null`的引用，在运行时将会报错。\n\n创建用来存放基本数据类型的数组时，会将这种数组所占内存全部置为零\n\nJava确保数组会被初始化，而且不能在它的范围之外被访问（null与零都代表是初始化后的，不会像C++一样得到一个很奇怪的东西）\n\n# 类\n\n## 字段\n\n若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保他获得一个默认值（对于`boolean`是`false`,其他是0）。但是不适用与局部变量，他们可能会是任意值，而不会被自动初始化为0。\n\n## 方法\n\n方法名和参数列表唯一标识出某个方法\n\n方法传递参数实际上是传递参数的引用\n\n## import\n\n`java.lang`包会自动导入到每一个`java`文件中\n\n其他要导包,即加入一个类库,例如:`import java.util.*`\n\n## javadoc\n\n+ @see 引用其他类\n+ @author 作者\n+ @param paramname 描述信息\n+ @return 描述信息\n+ @throws Exception 异常说明\n+ @deprecated 声明该方法不建议使用","source":"_posts/Java笔记/Java编程思想/02_一切皆是对象.md","raw":"---\ntitle: 第二章--一切皆是对象\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第二章--一切皆是对象。'\ncategories: Java编程思想\ntags:\n  - Java基础\n  - 类\n  - 数据类型\nabbrlink: 256ce7dc\ndate: 2020-10-17 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n# 对象\n\n## 数据类型\n\n创建一个并非是引用的自动变量,直接存储值,并放在堆栈中\n\n所有数值类型都有正负号\n\n> int 4字节 (-2的31次方)~(2的31次方-1) 超过20亿\n>\n> short 2字节\n>\n> long 8字节\n>\n> byte 1字节 [-128,127]\n>\n> float 四字节\n>\n> double 8字节\n>\n> char 2字节     因为Java采用16位的Unicode字符集 [0,65535]\n>\n> boolean 只有两个值,但是大小没精确定义，一般一字节\n\n### 高精度数字\n\n+ `BigInteger`支持任意精度的整数\n+ `BigDecimal`支持任意精度的定点数\n\n## 数组\n\n当创建一个数组对象时,实际上就是创建了一个引用数组,并且每个引用都会自动被初始化为一个特定值,该值拥有自己的关键字`null`,说明没有指向某个对象。\n\n在使用任何引用前，必须为其指定一个对象，如果试图使用一个还是`null`的引用，在运行时将会报错。\n\n创建用来存放基本数据类型的数组时，会将这种数组所占内存全部置为零\n\nJava确保数组会被初始化，而且不能在它的范围之外被访问（null与零都代表是初始化后的，不会像C++一样得到一个很奇怪的东西）\n\n# 类\n\n## 字段\n\n若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保他获得一个默认值（对于`boolean`是`false`,其他是0）。但是不适用与局部变量，他们可能会是任意值，而不会被自动初始化为0。\n\n## 方法\n\n方法名和参数列表唯一标识出某个方法\n\n方法传递参数实际上是传递参数的引用\n\n## import\n\n`java.lang`包会自动导入到每一个`java`文件中\n\n其他要导包,即加入一个类库,例如:`import java.util.*`\n\n## javadoc\n\n+ @see 引用其他类\n+ @author 作者\n+ @param paramname 描述信息\n+ @return 描述信息\n+ @throws Exception 异常说明\n+ @deprecated 声明该方法不建议使用","slug":"Java笔记/Java编程思想/02_一切皆是对象","published":1,"updated":"2021-02-04T00:39:46.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o72z00mejotpbqpe7ocu","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>创建一个并非是引用的自动变量,直接存储值,并放在堆栈中</p>\n<p>所有数值类型都有正负号</p>\n<blockquote>\n<p>int 4字节 (-2的31次方)~(2的31次方-1) 超过20亿</p>\n<p>short 2字节</p>\n<p>long 8字节</p>\n<p>byte 1字节 [-128,127]</p>\n<p>float 四字节</p>\n<p>double 8字节</p>\n<p>char 2字节     因为Java采用16位的Unicode字符集 [0,65535]</p>\n<p>boolean 只有两个值,但是大小没精确定义，一般一字节</p>\n</blockquote>\n<h3 id=\"高精度数字\"><a href=\"#高精度数字\" class=\"headerlink\" title=\"高精度数字\"></a>高精度数字</h3><ul>\n<li><code>BigInteger</code>支持任意精度的整数</li>\n<li><code>BigDecimal</code>支持任意精度的定点数</li>\n</ul>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>当创建一个数组对象时,实际上就是创建了一个引用数组,并且每个引用都会自动被初始化为一个特定值,该值拥有自己的关键字<code>null</code>,说明没有指向某个对象。</p>\n<p>在使用任何引用前，必须为其指定一个对象，如果试图使用一个还是<code>null</code>的引用，在运行时将会报错。</p>\n<p>创建用来存放基本数据类型的数组时，会将这种数组所占内存全部置为零</p>\n<p>Java确保数组会被初始化，而且不能在它的范围之外被访问（null与零都代表是初始化后的，不会像C++一样得到一个很奇怪的东西）</p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"字段\"><a href=\"#字段\" class=\"headerlink\" title=\"字段\"></a>字段</h2><p>若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保他获得一个默认值（对于<code>boolean</code>是<code>false</code>,其他是0）。但是不适用与局部变量，他们可能会是任意值，而不会被自动初始化为0。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法名和参数列表唯一标识出某个方法</p>\n<p>方法传递参数实际上是传递参数的引用</p>\n<h2 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h2><p><code>java.lang</code>包会自动导入到每一个<code>java</code>文件中</p>\n<p>其他要导包,即加入一个类库,例如:<code>import java.util.*</code></p>\n<h2 id=\"javadoc\"><a href=\"#javadoc\" class=\"headerlink\" title=\"javadoc\"></a>javadoc</h2><ul>\n<li>@see 引用其他类</li>\n<li>@author 作者</li>\n<li>@param paramname 描述信息</li>\n<li>@return 描述信息</li>\n<li>@throws Exception 异常说明</li>\n<li>@deprecated 声明该方法不建议使用</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>创建一个并非是引用的自动变量,直接存储值,并放在堆栈中</p>\n<p>所有数值类型都有正负号</p>\n<blockquote>\n<p>int 4字节 (-2的31次方)~(2的31次方-1) 超过20亿</p>\n<p>short 2字节</p>\n<p>long 8字节</p>\n<p>byte 1字节 [-128,127]</p>\n<p>float 四字节</p>\n<p>double 8字节</p>\n<p>char 2字节     因为Java采用16位的Unicode字符集 [0,65535]</p>\n<p>boolean 只有两个值,但是大小没精确定义，一般一字节</p>\n</blockquote>\n<h3 id=\"高精度数字\"><a href=\"#高精度数字\" class=\"headerlink\" title=\"高精度数字\"></a>高精度数字</h3><ul>\n<li><code>BigInteger</code>支持任意精度的整数</li>\n<li><code>BigDecimal</code>支持任意精度的定点数</li>\n</ul>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>当创建一个数组对象时,实际上就是创建了一个引用数组,并且每个引用都会自动被初始化为一个特定值,该值拥有自己的关键字<code>null</code>,说明没有指向某个对象。</p>\n<p>在使用任何引用前，必须为其指定一个对象，如果试图使用一个还是<code>null</code>的引用，在运行时将会报错。</p>\n<p>创建用来存放基本数据类型的数组时，会将这种数组所占内存全部置为零</p>\n<p>Java确保数组会被初始化，而且不能在它的范围之外被访问（null与零都代表是初始化后的，不会像C++一样得到一个很奇怪的东西）</p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"字段\"><a href=\"#字段\" class=\"headerlink\" title=\"字段\"></a>字段</h2><p>若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保他获得一个默认值（对于<code>boolean</code>是<code>false</code>,其他是0）。但是不适用与局部变量，他们可能会是任意值，而不会被自动初始化为0。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法名和参数列表唯一标识出某个方法</p>\n<p>方法传递参数实际上是传递参数的引用</p>\n<h2 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h2><p><code>java.lang</code>包会自动导入到每一个<code>java</code>文件中</p>\n<p>其他要导包,即加入一个类库,例如:<code>import java.util.*</code></p>\n<h2 id=\"javadoc\"><a href=\"#javadoc\" class=\"headerlink\" title=\"javadoc\"></a>javadoc</h2><ul>\n<li>@see 引用其他类</li>\n<li>@author 作者</li>\n<li>@param paramname 描述信息</li>\n<li>@return 描述信息</li>\n<li>@throws Exception 异常说明</li>\n<li>@deprecated 声明该方法不建议使用</li>\n</ul>\n"},{"title":"第八章--多态","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第八章--多态。构造器行为","abbrlink":"1ae46459","date":"2020-10-24T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n## 后期绑定\n\n在运行时根据对象的类型进行绑定,也叫做动态绑定,运行时绑定\n\n编译器一直不知道对象的类型,但是方法调用机制能找到正确的方法体\n\n除了`static`和`final`方法,其他都是后期绑定的方法\n\n## 构造器\n\n基类的构造器总是在导出类的构造过程中被调用,导出类只能访问它自己的成员,不能访问基类的成员(因为通常是`private`),只有基类构造器才比较恰当的对自己元素进行初始化,因此必须令所有构造器得到调用\n\n如果没有明确指定调用某个基类构造器,他就会默默调用默认构造器\n\n## 构造器内部的多态方法行为\n\n+ 在任何构造器内部,整个对象可能只是部分形成的,只知道基类对象已经初始化\n+ 如果调用一个动态绑定方法,则可能调用到了导出类的方法,该方法操纵的成员可能未初始化\n+ 所以在构造器内唯一能够安全调用的那些方法是基类中的`private`和`final`方法,因为他们不能被覆盖\n\n```java\nclass Graph\n{\n    public Graph()\n    {\n        System.out.println(\"----before----\");\n        draw();\n        System.out.println(\"----after----\");\n    }\n\n    void draw()\n    {\n        System.out.println(\"Graph.draw\");\n    }\n}\n\nclass RoundGlyph extends Graph\n{\n    private int i = 1;\n\n    public RoundGlyph(int i)\n    {\n        this.i = i;\n        System.out.println(\"RoundGlyph.draw:\" + i);\n    }\n\n    void draw()\n    {\n        System.out.println(\"RoundGlyph.draw:\" + i);\n    }\n}\n\n\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        new RoundGlyph(5);\n    }\n}\n\n/*\n----before----\nRoundGlyph.draw:0\n----after----\nRoundGlyph.draw:5\n */\n```\n\n+ 在最开始,分配给对象的存储空间初始化未二进制的零\n+ 调用基类构造器,此时会调用覆盖后的`draw()`方法,由于第一步,此时`i=0`\n+ 初始化成员变量调用导出类的构造器主体","source":"_posts/Java笔记/Java编程思想/08_多态.md","raw":"---\ntitle: 第八章--多态\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第八章--多态。构造器行为'\ncategories: Java编程思想\ntags:\n  - Java基础\n  - 继承\n  - 多态\nabbrlink: 1ae46459\ndate: 2020-10-25 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n## 后期绑定\n\n在运行时根据对象的类型进行绑定,也叫做动态绑定,运行时绑定\n\n编译器一直不知道对象的类型,但是方法调用机制能找到正确的方法体\n\n除了`static`和`final`方法,其他都是后期绑定的方法\n\n## 构造器\n\n基类的构造器总是在导出类的构造过程中被调用,导出类只能访问它自己的成员,不能访问基类的成员(因为通常是`private`),只有基类构造器才比较恰当的对自己元素进行初始化,因此必须令所有构造器得到调用\n\n如果没有明确指定调用某个基类构造器,他就会默默调用默认构造器\n\n## 构造器内部的多态方法行为\n\n+ 在任何构造器内部,整个对象可能只是部分形成的,只知道基类对象已经初始化\n+ 如果调用一个动态绑定方法,则可能调用到了导出类的方法,该方法操纵的成员可能未初始化\n+ 所以在构造器内唯一能够安全调用的那些方法是基类中的`private`和`final`方法,因为他们不能被覆盖\n\n```java\nclass Graph\n{\n    public Graph()\n    {\n        System.out.println(\"----before----\");\n        draw();\n        System.out.println(\"----after----\");\n    }\n\n    void draw()\n    {\n        System.out.println(\"Graph.draw\");\n    }\n}\n\nclass RoundGlyph extends Graph\n{\n    private int i = 1;\n\n    public RoundGlyph(int i)\n    {\n        this.i = i;\n        System.out.println(\"RoundGlyph.draw:\" + i);\n    }\n\n    void draw()\n    {\n        System.out.println(\"RoundGlyph.draw:\" + i);\n    }\n}\n\n\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        new RoundGlyph(5);\n    }\n}\n\n/*\n----before----\nRoundGlyph.draw:0\n----after----\nRoundGlyph.draw:5\n */\n```\n\n+ 在最开始,分配给对象的存储空间初始化未二进制的零\n+ 调用基类构造器,此时会调用覆盖后的`draw()`方法,由于第一步,此时`i=0`\n+ 初始化成员变量调用导出类的构造器主体","slug":"Java笔记/Java编程思想/08_多态","published":1,"updated":"2021-02-04T00:42:28.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73100mhjotpg2yg08in","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h2 id=\"后期绑定\"><a href=\"#后期绑定\" class=\"headerlink\" title=\"后期绑定\"></a>后期绑定</h2><p>在运行时根据对象的类型进行绑定,也叫做动态绑定,运行时绑定</p>\n<p>编译器一直不知道对象的类型,但是方法调用机制能找到正确的方法体</p>\n<p>除了<code>static</code>和<code>final</code>方法,其他都是后期绑定的方法</p>\n<h2 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h2><p>基类的构造器总是在导出类的构造过程中被调用,导出类只能访问它自己的成员,不能访问基类的成员(因为通常是<code>private</code>),只有基类构造器才比较恰当的对自己元素进行初始化,因此必须令所有构造器得到调用</p>\n<p>如果没有明确指定调用某个基类构造器,他就会默默调用默认构造器</p>\n<h2 id=\"构造器内部的多态方法行为\"><a href=\"#构造器内部的多态方法行为\" class=\"headerlink\" title=\"构造器内部的多态方法行为\"></a>构造器内部的多态方法行为</h2><ul>\n<li>在任何构造器内部,整个对象可能只是部分形成的,只知道基类对象已经初始化</li>\n<li>如果调用一个动态绑定方法,则可能调用到了导出类的方法,该方法操纵的成员可能未初始化</li>\n<li>所以在构造器内唯一能够安全调用的那些方法是基类中的<code>private</code>和<code>final</code>方法,因为他们不能被覆盖</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Graph</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Graph</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"----before----\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"----after----\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Graph.draw\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">RoundGlyph</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Graph</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">RoundGlyph</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"RoundGlyph.draw:\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"RoundGlyph.draw:\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">RoundGlyph</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/*\n----before----\nRoundGlyph.draw:0\n----after----\nRoundGlyph.draw:5\n */</span></code></pre>\n<ul>\n<li>在最开始,分配给对象的存储空间初始化未二进制的零</li>\n<li>调用基类构造器,此时会调用覆盖后的<code>draw()</code>方法,由于第一步,此时<code>i=0</code></li>\n<li>初始化成员变量调用导出类的构造器主体</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h2 id=\"后期绑定\"><a href=\"#后期绑定\" class=\"headerlink\" title=\"后期绑定\"></a>后期绑定</h2><p>在运行时根据对象的类型进行绑定,也叫做动态绑定,运行时绑定</p>\n<p>编译器一直不知道对象的类型,但是方法调用机制能找到正确的方法体</p>\n<p>除了<code>static</code>和<code>final</code>方法,其他都是后期绑定的方法</p>\n<h2 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h2><p>基类的构造器总是在导出类的构造过程中被调用,导出类只能访问它自己的成员,不能访问基类的成员(因为通常是<code>private</code>),只有基类构造器才比较恰当的对自己元素进行初始化,因此必须令所有构造器得到调用</p>\n<p>如果没有明确指定调用某个基类构造器,他就会默默调用默认构造器</p>\n<h2 id=\"构造器内部的多态方法行为\"><a href=\"#构造器内部的多态方法行为\" class=\"headerlink\" title=\"构造器内部的多态方法行为\"></a>构造器内部的多态方法行为</h2><ul>\n<li>在任何构造器内部,整个对象可能只是部分形成的,只知道基类对象已经初始化</li>\n<li>如果调用一个动态绑定方法,则可能调用到了导出类的方法,该方法操纵的成员可能未初始化</li>\n<li>所以在构造器内唯一能够安全调用的那些方法是基类中的<code>private</code>和<code>final</code>方法,因为他们不能被覆盖</li>\n</ul>\n<pre><code class=\"java\">class Graph\n{\n    public Graph()\n    {\n        System.out.println(&quot;----before----&quot;);\n        draw();\n        System.out.println(&quot;----after----&quot;);\n    }\n\n    void draw()\n    {\n        System.out.println(&quot;Graph.draw&quot;);\n    }\n}\n\nclass RoundGlyph extends Graph\n{\n    private int i = 1;\n\n    public RoundGlyph(int i)\n    {\n        this.i = i;\n        System.out.println(&quot;RoundGlyph.draw:&quot; + i);\n    }\n\n    void draw()\n    {\n        System.out.println(&quot;RoundGlyph.draw:&quot; + i);\n    }\n}\n\n\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        new RoundGlyph(5);\n    }\n}\n\n/*\n----before----\nRoundGlyph.draw:0\n----after----\nRoundGlyph.draw:5\n */</code></pre>\n<ul>\n<li>在最开始,分配给对象的存储空间初始化未二进制的零</li>\n<li>调用基类构造器,此时会调用覆盖后的<code>draw()</code>方法,由于第一步,此时<code>i=0</code></li>\n<li>初始化成员变量调用导出类的构造器主体</li>\n</ul>\n"},{"title":"第五章--初始化与清理","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第五章--初始化与清理。","abbrlink":"4f7140bc","date":"2020-10-19T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n# 构造器\n\n+ 不能以返回值重载方法是因为有时不关心方法的返回值,只是要他的执行效果.就会这样调用方法:`f()`.\n+ 如果没有写构造器,编译器会自动创建默认构造器;如果已经定义了构造器,则不会默认自动创建\n+ 执行类似`x.f(1)`方法时,编译器把所操作对象的引用作为第一个参数传递给了`f()`,实际上就形如`X.f(x,1)`.\n+ 所以在方法内部,如果想获得对调用方法的那个对象的引用,则用`this`\n+ 在方法内部调用同一个类的另一个方法,不必用`this`,因为当前方法的`this`引用会自动应用于同一类中的所有方法\n+ 构造器中可以用`this`来调用另一个构造器,但是只能置于最起始处,而且只能调用一次\n\n# 成员初始化\n\n+ 方法中的局部变量,`Java`以编译错误的形式来保证所有变量在使用前都能得到恰当的初始化\n+ 在类中定义一个对象引用,若没有初始化,则会获得特殊值--`null`\n+ 无法阻止自动初始化的进行,他将会在构造器被调用前发生\n+ 变量定义会在任何方法(包括构造器)被调用之前得到初始化\n+ 静态初始化只在必要时刻才会进行,且不会再次被初始化\n\n```java\nprivate int i;\n\npublic MainTest()\n{\n    i = 7;\n}\n//i首先会置为0,然后变成7\n```\n\n# 过程\n\n+ 当静态方法/静态域首次被访问时，`java`解释器必须查找类路径,单位`Dog.class`\n+ 载入`Dog.class`,执行且只执行静态初始化操作一次\n+ 当使用`new Dog()`创建对象时,在堆上为该对象分配足够的存储空间\n+ 存储空间清零,就自动的把所有基本类型数据设为默认值,引用设置为`null`\n+ 执行字段定义处的初始化动作\n+ 执行构造器\n\n# 枚举\n\n```java\npublic enum Spiciness\n{\n    NOT,MILD,MEDIUM,HOT,FLAMING\n}\n```\n\n\n\n```java\nSpiciness hot = Spiciness.HOT;\nSystem.out.println(hot);\n//HOT\n\nfor (Spiciness s : Spiciness.values())\n{\n    System.out.println(s + \" ordinal \" + s.ordinal());\n}\n//NOT ordinal 0\n//MILD ordinal 1\n//MEDIUM ordinal 2\n//HOT ordinal 3\n//FLAMING ordinal 4\n```","source":"_posts/Java笔记/Java编程思想/05_初始化与清理.md","raw":"---\ntitle: 第五章--初始化与清理\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第五章--初始化与清理。'\ncategories: Java编程思想\ntags:\n  - Java基础\n  - 构造函数\n  - 初始化\nabbrlink: 4f7140bc\ndate: 2020-10-20 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n# 构造器\n\n+ 不能以返回值重载方法是因为有时不关心方法的返回值,只是要他的执行效果.就会这样调用方法:`f()`.\n+ 如果没有写构造器,编译器会自动创建默认构造器;如果已经定义了构造器,则不会默认自动创建\n+ 执行类似`x.f(1)`方法时,编译器把所操作对象的引用作为第一个参数传递给了`f()`,实际上就形如`X.f(x,1)`.\n+ 所以在方法内部,如果想获得对调用方法的那个对象的引用,则用`this`\n+ 在方法内部调用同一个类的另一个方法,不必用`this`,因为当前方法的`this`引用会自动应用于同一类中的所有方法\n+ 构造器中可以用`this`来调用另一个构造器,但是只能置于最起始处,而且只能调用一次\n\n# 成员初始化\n\n+ 方法中的局部变量,`Java`以编译错误的形式来保证所有变量在使用前都能得到恰当的初始化\n+ 在类中定义一个对象引用,若没有初始化,则会获得特殊值--`null`\n+ 无法阻止自动初始化的进行,他将会在构造器被调用前发生\n+ 变量定义会在任何方法(包括构造器)被调用之前得到初始化\n+ 静态初始化只在必要时刻才会进行,且不会再次被初始化\n\n```java\nprivate int i;\n\npublic MainTest()\n{\n    i = 7;\n}\n//i首先会置为0,然后变成7\n```\n\n# 过程\n\n+ 当静态方法/静态域首次被访问时，`java`解释器必须查找类路径,单位`Dog.class`\n+ 载入`Dog.class`,执行且只执行静态初始化操作一次\n+ 当使用`new Dog()`创建对象时,在堆上为该对象分配足够的存储空间\n+ 存储空间清零,就自动的把所有基本类型数据设为默认值,引用设置为`null`\n+ 执行字段定义处的初始化动作\n+ 执行构造器\n\n# 枚举\n\n```java\npublic enum Spiciness\n{\n    NOT,MILD,MEDIUM,HOT,FLAMING\n}\n```\n\n\n\n```java\nSpiciness hot = Spiciness.HOT;\nSystem.out.println(hot);\n//HOT\n\nfor (Spiciness s : Spiciness.values())\n{\n    System.out.println(s + \" ordinal \" + s.ordinal());\n}\n//NOT ordinal 0\n//MILD ordinal 1\n//MEDIUM ordinal 2\n//HOT ordinal 3\n//FLAMING ordinal 4\n```","slug":"Java笔记/Java编程思想/05_初始化与清理","published":1,"updated":"2021-02-04T00:40:19.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73400mijotpcz6p19si","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h1><ul>\n<li>不能以返回值重载方法是因为有时不关心方法的返回值,只是要他的执行效果.就会这样调用方法:<code>f()</code>.</li>\n<li>如果没有写构造器,编译器会自动创建默认构造器;如果已经定义了构造器,则不会默认自动创建</li>\n<li>执行类似<code>x.f(1)</code>方法时,编译器把所操作对象的引用作为第一个参数传递给了<code>f()</code>,实际上就形如<code>X.f(x,1)</code>.</li>\n<li>所以在方法内部,如果想获得对调用方法的那个对象的引用,则用<code>this</code></li>\n<li>在方法内部调用同一个类的另一个方法,不必用<code>this</code>,因为当前方法的<code>this</code>引用会自动应用于同一类中的所有方法</li>\n<li>构造器中可以用<code>this</code>来调用另一个构造器,但是只能置于最起始处,而且只能调用一次</li>\n</ul>\n<h1 id=\"成员初始化\"><a href=\"#成员初始化\" class=\"headerlink\" title=\"成员初始化\"></a>成员初始化</h1><ul>\n<li>方法中的局部变量,<code>Java</code>以编译错误的形式来保证所有变量在使用前都能得到恰当的初始化</li>\n<li>在类中定义一个对象引用,若没有初始化,则会获得特殊值–<code>null</code></li>\n<li>无法阻止自动初始化的进行,他将会在构造器被调用前发生</li>\n<li>变量定义会在任何方法(包括构造器)被调用之前得到初始化</li>\n<li>静态初始化只在必要时刻才会进行,且不会再次被初始化</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token function\">MainTest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    i <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//i首先会置为0,然后变成7</span></code></pre>\n<h1 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h1><ul>\n<li>当静态方法/静态域首次被访问时，<code>java</code>解释器必须查找类路径,单位<code>Dog.class</code></li>\n<li>载入<code>Dog.class</code>,执行且只执行静态初始化操作一次</li>\n<li>当使用<code>new Dog()</code>创建对象时,在堆上为该对象分配足够的存储空间</li>\n<li>存储空间清零,就自动的把所有基本类型数据设为默认值,引用设置为<code>null</code></li>\n<li>执行字段定义处的初始化动作</li>\n<li>执行构造器</li>\n</ul>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> Spiciness\n<span class=\"token punctuation\">{</span>\n    NOT<span class=\"token punctuation\">,</span>MILD<span class=\"token punctuation\">,</span>MEDIUM<span class=\"token punctuation\">,</span>HOT<span class=\"token punctuation\">,</span>FLAMING\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">Spiciness hot <span class=\"token operator\">=</span> Spiciness<span class=\"token punctuation\">.</span>HOT<span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>hot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//HOT</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Spiciness s <span class=\"token operator\">:</span> Spiciness<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s <span class=\"token operator\">+</span> <span class=\"token string\">\" ordinal \"</span> <span class=\"token operator\">+</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">ordinal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//NOT ordinal 0</span>\n<span class=\"token comment\" spellcheck=\"true\">//MILD ordinal 1</span>\n<span class=\"token comment\" spellcheck=\"true\">//MEDIUM ordinal 2</span>\n<span class=\"token comment\" spellcheck=\"true\">//HOT ordinal 3</span>\n<span class=\"token comment\" spellcheck=\"true\">//FLAMING ordinal 4</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h1><ul>\n<li>不能以返回值重载方法是因为有时不关心方法的返回值,只是要他的执行效果.就会这样调用方法:<code>f()</code>.</li>\n<li>如果没有写构造器,编译器会自动创建默认构造器;如果已经定义了构造器,则不会默认自动创建</li>\n<li>执行类似<code>x.f(1)</code>方法时,编译器把所操作对象的引用作为第一个参数传递给了<code>f()</code>,实际上就形如<code>X.f(x,1)</code>.</li>\n<li>所以在方法内部,如果想获得对调用方法的那个对象的引用,则用<code>this</code></li>\n<li>在方法内部调用同一个类的另一个方法,不必用<code>this</code>,因为当前方法的<code>this</code>引用会自动应用于同一类中的所有方法</li>\n<li>构造器中可以用<code>this</code>来调用另一个构造器,但是只能置于最起始处,而且只能调用一次</li>\n</ul>\n<h1 id=\"成员初始化\"><a href=\"#成员初始化\" class=\"headerlink\" title=\"成员初始化\"></a>成员初始化</h1><ul>\n<li>方法中的局部变量,<code>Java</code>以编译错误的形式来保证所有变量在使用前都能得到恰当的初始化</li>\n<li>在类中定义一个对象引用,若没有初始化,则会获得特殊值–<code>null</code></li>\n<li>无法阻止自动初始化的进行,他将会在构造器被调用前发生</li>\n<li>变量定义会在任何方法(包括构造器)被调用之前得到初始化</li>\n<li>静态初始化只在必要时刻才会进行,且不会再次被初始化</li>\n</ul>\n<pre><code class=\"java\">private int i;\n\npublic MainTest()\n{\n    i = 7;\n}\n//i首先会置为0,然后变成7</code></pre>\n<h1 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h1><ul>\n<li>当静态方法/静态域首次被访问时，<code>java</code>解释器必须查找类路径,单位<code>Dog.class</code></li>\n<li>载入<code>Dog.class</code>,执行且只执行静态初始化操作一次</li>\n<li>当使用<code>new Dog()</code>创建对象时,在堆上为该对象分配足够的存储空间</li>\n<li>存储空间清零,就自动的把所有基本类型数据设为默认值,引用设置为<code>null</code></li>\n<li>执行字段定义处的初始化动作</li>\n<li>执行构造器</li>\n</ul>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><pre><code class=\"java\">public enum Spiciness\n{\n    NOT,MILD,MEDIUM,HOT,FLAMING\n}</code></pre>\n<pre><code class=\"java\">Spiciness hot = Spiciness.HOT;\nSystem.out.println(hot);\n//HOT\n\nfor (Spiciness s : Spiciness.values())\n{\n    System.out.println(s + &quot; ordinal &quot; + s.ordinal());\n}\n//NOT ordinal 0\n//MILD ordinal 1\n//MEDIUM ordinal 2\n//HOT ordinal 3\n//FLAMING ordinal 4</code></pre>\n"},{"title":"第七章--复用类","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第七章--复用类。final相关","abbrlink":"2edde9de","date":"2020-10-22T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n\n\n# 继承\n\n+ 子类会自动得到基类中所有的域和方法\n+ 一般为了继承,会将所有的数据成员指定为`private`,所有方法指定为`public`\n+ 当创建了一个导出类的对象时,该对象包含了一个基类的子对象\n+ `Java`会自动在导出类的构造器中插入对基类构造器的调用\n+ 如果没有默认的基类构造器,或者想要调用一个带参数的基类构造器,则必须用关键词`super`\n\n## \t名称屏蔽\t\n\n+ 子类可以进行重载或重写,而且重载不会屏蔽父类的重载方法\n+ `@Override`注解可以防止你在不想重载时而意外地进行了重载\n\n## protected\n\n就类用户而言,他是`private`的,但是对于任何继承于此类的导出类或者同一个包的类,他是可访问的(也提供包访问权限)\n\n## 向上转型\n\n导出类是基类的一个超集,他可能比基类含有更多的方法,但他必须至少具备基类中所含有的方法\n\n向上转型唯一可能发生的事情就是丢失方法\n\n如果必须向上转型,则继承是必须的\n\n## toString()\n\n当编译器需要一个`String`而只有一个对象时,该方法就会被调用\n\n# final\n\n+ 常量代表了永不改变的编译时常量或运行时被初始化后不希望他改变的值,这类常量必须是基本数据类型,并且以关键字`final`标识,定义时必须赋值\n+ 一个既是`static`,又是`final`的域只占据一段不能改变的存储空间\n\n+ 对应对象引用,`final`使引用恒定不变,一旦引用被初始化指向一个对象,就无法再把它改为指向另一个对象.但是对象自身是可以修改的\n\n## 空白final\n\n指被声明为`final`但又未给定初值的域\n\n必须在域的定义处或者每个构造器中对`final`赋值\n\n## final参数\n\n类似`void test(final Date g)`,无法在方法中更改参数引用所指向的对象\n\n## final方法\n\n把方法锁定,防止任何继承类修改他的含义\n\n类中所有`private`方法都是`final`的\n\n## final类\n\n禁止继承该类,所有方法隐式指定为`final`\n\n# 类加载\n\n类的代码在初次使用时才加载\n\n通常指加载发生于创建类的第一个对象时,或者访问`static`域或方法时\n\n+ 访问`Beetle.main()`\n\n+ 开始找到`Beetle`类的编译代码,发现他有基类,于是他继续加载`Beetle`的基类\n\n+ 根基类的`static`初始化\n\n+ 所有类加载完毕后,即可以创建对象了\n\n+ 创建一个对象时,所有基本对象设为默认值,对象引用设为`null`\n\n+ 基类构造器被调用\n\n\t","source":"_posts/Java笔记/Java编程思想/07_复用类.md","raw":"---\ntitle: 第七章--复用类\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第七章--复用类。final相关'\ncategories: Java编程思想\ntags:\n  - Java基础\n  - 继承\n  - 类加载\nabbrlink: 2edde9de\ndate: 2020-10-23 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n\n\n# 继承\n\n+ 子类会自动得到基类中所有的域和方法\n+ 一般为了继承,会将所有的数据成员指定为`private`,所有方法指定为`public`\n+ 当创建了一个导出类的对象时,该对象包含了一个基类的子对象\n+ `Java`会自动在导出类的构造器中插入对基类构造器的调用\n+ 如果没有默认的基类构造器,或者想要调用一个带参数的基类构造器,则必须用关键词`super`\n\n## \t名称屏蔽\t\n\n+ 子类可以进行重载或重写,而且重载不会屏蔽父类的重载方法\n+ `@Override`注解可以防止你在不想重载时而意外地进行了重载\n\n## protected\n\n就类用户而言,他是`private`的,但是对于任何继承于此类的导出类或者同一个包的类,他是可访问的(也提供包访问权限)\n\n## 向上转型\n\n导出类是基类的一个超集,他可能比基类含有更多的方法,但他必须至少具备基类中所含有的方法\n\n向上转型唯一可能发生的事情就是丢失方法\n\n如果必须向上转型,则继承是必须的\n\n## toString()\n\n当编译器需要一个`String`而只有一个对象时,该方法就会被调用\n\n# final\n\n+ 常量代表了永不改变的编译时常量或运行时被初始化后不希望他改变的值,这类常量必须是基本数据类型,并且以关键字`final`标识,定义时必须赋值\n+ 一个既是`static`,又是`final`的域只占据一段不能改变的存储空间\n\n+ 对应对象引用,`final`使引用恒定不变,一旦引用被初始化指向一个对象,就无法再把它改为指向另一个对象.但是对象自身是可以修改的\n\n## 空白final\n\n指被声明为`final`但又未给定初值的域\n\n必须在域的定义处或者每个构造器中对`final`赋值\n\n## final参数\n\n类似`void test(final Date g)`,无法在方法中更改参数引用所指向的对象\n\n## final方法\n\n把方法锁定,防止任何继承类修改他的含义\n\n类中所有`private`方法都是`final`的\n\n## final类\n\n禁止继承该类,所有方法隐式指定为`final`\n\n# 类加载\n\n类的代码在初次使用时才加载\n\n通常指加载发生于创建类的第一个对象时,或者访问`static`域或方法时\n\n+ 访问`Beetle.main()`\n\n+ 开始找到`Beetle`类的编译代码,发现他有基类,于是他继续加载`Beetle`的基类\n\n+ 根基类的`static`初始化\n\n+ 所有类加载完毕后,即可以创建对象了\n\n+ 创建一个对象时,所有基本对象设为默认值,对象引用设为`null`\n\n+ 基类构造器被调用\n\n\t","slug":"Java笔记/Java编程思想/07_复用类","published":1,"updated":"2021-02-04T00:42:12.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73500mjjotp7a3r6hl2","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><ul>\n<li>子类会自动得到基类中所有的域和方法</li>\n<li>一般为了继承,会将所有的数据成员指定为<code>private</code>,所有方法指定为<code>public</code></li>\n<li>当创建了一个导出类的对象时,该对象包含了一个基类的子对象</li>\n<li><code>Java</code>会自动在导出类的构造器中插入对基类构造器的调用</li>\n<li>如果没有默认的基类构造器,或者想要调用一个带参数的基类构造器,则必须用关键词<code>super</code></li>\n</ul>\n<h2 id=\"名称屏蔽\"><a href=\"#名称屏蔽\" class=\"headerlink\" title=\"名称屏蔽\"></a>名称屏蔽</h2><ul>\n<li>子类可以进行重载或重写,而且重载不会屏蔽父类的重载方法</li>\n<li><code>@Override</code>注解可以防止你在不想重载时而意外地进行了重载</li>\n</ul>\n<h2 id=\"protected\"><a href=\"#protected\" class=\"headerlink\" title=\"protected\"></a>protected</h2><p>就类用户而言,他是<code>private</code>的,但是对于任何继承于此类的导出类或者同一个包的类,他是可访问的(也提供包访问权限)</p>\n<h2 id=\"向上转型\"><a href=\"#向上转型\" class=\"headerlink\" title=\"向上转型\"></a>向上转型</h2><p>导出类是基类的一个超集,他可能比基类含有更多的方法,但他必须至少具备基类中所含有的方法</p>\n<p>向上转型唯一可能发生的事情就是丢失方法</p>\n<p>如果必须向上转型,则继承是必须的</p>\n<h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h2><p>当编译器需要一个<code>String</code>而只有一个对象时,该方法就会被调用</p>\n<h1 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h1><ul>\n<li><p>常量代表了永不改变的编译时常量或运行时被初始化后不希望他改变的值,这类常量必须是基本数据类型,并且以关键字<code>final</code>标识,定义时必须赋值</p>\n</li>\n<li><p>一个既是<code>static</code>,又是<code>final</code>的域只占据一段不能改变的存储空间</p>\n</li>\n<li><p>对应对象引用,<code>final</code>使引用恒定不变,一旦引用被初始化指向一个对象,就无法再把它改为指向另一个对象.但是对象自身是可以修改的</p>\n</li>\n</ul>\n<h2 id=\"空白final\"><a href=\"#空白final\" class=\"headerlink\" title=\"空白final\"></a>空白final</h2><p>指被声明为<code>final</code>但又未给定初值的域</p>\n<p>必须在域的定义处或者每个构造器中对<code>final</code>赋值</p>\n<h2 id=\"final参数\"><a href=\"#final参数\" class=\"headerlink\" title=\"final参数\"></a>final参数</h2><p>类似<code>void test(final Date g)</code>,无法在方法中更改参数引用所指向的对象</p>\n<h2 id=\"final方法\"><a href=\"#final方法\" class=\"headerlink\" title=\"final方法\"></a>final方法</h2><p>把方法锁定,防止任何继承类修改他的含义</p>\n<p>类中所有<code>private</code>方法都是<code>final</code>的</p>\n<h2 id=\"final类\"><a href=\"#final类\" class=\"headerlink\" title=\"final类\"></a>final类</h2><p>禁止继承该类,所有方法隐式指定为<code>final</code></p>\n<h1 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h1><p>类的代码在初次使用时才加载</p>\n<p>通常指加载发生于创建类的第一个对象时,或者访问<code>static</code>域或方法时</p>\n<ul>\n<li><p>访问<code>Beetle.main()</code></p>\n</li>\n<li><p>开始找到<code>Beetle</code>类的编译代码,发现他有基类,于是他继续加载<code>Beetle</code>的基类</p>\n</li>\n<li><p>根基类的<code>static</code>初始化</p>\n</li>\n<li><p>所有类加载完毕后,即可以创建对象了</p>\n</li>\n<li><p>创建一个对象时,所有基本对象设为默认值,对象引用设为<code>null</code></p>\n</li>\n<li><p>基类构造器被调用</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><ul>\n<li>子类会自动得到基类中所有的域和方法</li>\n<li>一般为了继承,会将所有的数据成员指定为<code>private</code>,所有方法指定为<code>public</code></li>\n<li>当创建了一个导出类的对象时,该对象包含了一个基类的子对象</li>\n<li><code>Java</code>会自动在导出类的构造器中插入对基类构造器的调用</li>\n<li>如果没有默认的基类构造器,或者想要调用一个带参数的基类构造器,则必须用关键词<code>super</code></li>\n</ul>\n<h2 id=\"名称屏蔽\"><a href=\"#名称屏蔽\" class=\"headerlink\" title=\"名称屏蔽\"></a>名称屏蔽</h2><ul>\n<li>子类可以进行重载或重写,而且重载不会屏蔽父类的重载方法</li>\n<li><code>@Override</code>注解可以防止你在不想重载时而意外地进行了重载</li>\n</ul>\n<h2 id=\"protected\"><a href=\"#protected\" class=\"headerlink\" title=\"protected\"></a>protected</h2><p>就类用户而言,他是<code>private</code>的,但是对于任何继承于此类的导出类或者同一个包的类,他是可访问的(也提供包访问权限)</p>\n<h2 id=\"向上转型\"><a href=\"#向上转型\" class=\"headerlink\" title=\"向上转型\"></a>向上转型</h2><p>导出类是基类的一个超集,他可能比基类含有更多的方法,但他必须至少具备基类中所含有的方法</p>\n<p>向上转型唯一可能发生的事情就是丢失方法</p>\n<p>如果必须向上转型,则继承是必须的</p>\n<h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h2><p>当编译器需要一个<code>String</code>而只有一个对象时,该方法就会被调用</p>\n<h1 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h1><ul>\n<li><p>常量代表了永不改变的编译时常量或运行时被初始化后不希望他改变的值,这类常量必须是基本数据类型,并且以关键字<code>final</code>标识,定义时必须赋值</p>\n</li>\n<li><p>一个既是<code>static</code>,又是<code>final</code>的域只占据一段不能改变的存储空间</p>\n</li>\n<li><p>对应对象引用,<code>final</code>使引用恒定不变,一旦引用被初始化指向一个对象,就无法再把它改为指向另一个对象.但是对象自身是可以修改的</p>\n</li>\n</ul>\n<h2 id=\"空白final\"><a href=\"#空白final\" class=\"headerlink\" title=\"空白final\"></a>空白final</h2><p>指被声明为<code>final</code>但又未给定初值的域</p>\n<p>必须在域的定义处或者每个构造器中对<code>final</code>赋值</p>\n<h2 id=\"final参数\"><a href=\"#final参数\" class=\"headerlink\" title=\"final参数\"></a>final参数</h2><p>类似<code>void test(final Date g)</code>,无法在方法中更改参数引用所指向的对象</p>\n<h2 id=\"final方法\"><a href=\"#final方法\" class=\"headerlink\" title=\"final方法\"></a>final方法</h2><p>把方法锁定,防止任何继承类修改他的含义</p>\n<p>类中所有<code>private</code>方法都是<code>final</code>的</p>\n<h2 id=\"final类\"><a href=\"#final类\" class=\"headerlink\" title=\"final类\"></a>final类</h2><p>禁止继承该类,所有方法隐式指定为<code>final</code></p>\n<h1 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h1><p>类的代码在初次使用时才加载</p>\n<p>通常指加载发生于创建类的第一个对象时,或者访问<code>static</code>域或方法时</p>\n<ul>\n<li><p>访问<code>Beetle.main()</code></p>\n</li>\n<li><p>开始找到<code>Beetle</code>类的编译代码,发现他有基类,于是他继续加载<code>Beetle</code>的基类</p>\n</li>\n<li><p>根基类的<code>static</code>初始化</p>\n</li>\n<li><p>所有类加载完毕后,即可以创建对象了</p>\n</li>\n<li><p>创建一个对象时,所有基本对象设为默认值,对象引用设为<code>null</code></p>\n</li>\n<li><p>基类构造器被调用</p>\n</li>\n</ul>\n"},{"title":"第六章--访问权限控制","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第六章--访问权限控制。","abbrlink":"73458eba","date":"2020-10-21T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n\n\n如何把变动的事物与保持不变的事物区分开\n\n# 包\n\n## 代码组织\n\n+ 当编写一个`Java`源代码文件时,此文件称为编译单元,他们必须有一个后缀名`.java`\n+ 编译单元内只能有一个`public`类,而且必须与文件名一致\n+ 如果有其他类,则包外是看不见的, 他们只是为主`public`类提供支持\n+ 当编译一个`.java`文件时,文件中每个类都会有一个输出文件\n+ `Java`可运行程序是一组可以打包并压缩为一个`java`文档文件的`.class`文件(**JAR**)\n\n## 包名\n\n把`package`名称分解为你机器上的一个目录,当`Java`程序运行并需要加载`.class`文件的时候,他就可以确定`.class`文件在目录所处的位置\n\n### Java解释器的运行过程\n\n+ 找出环境变量`CLASSPATH`,它包括了多个可供选择的查询路径\n+ 将包的名称由.换成/ 例如:`com.tongji.test`换成`com/tongji/test`\n+ 把`CLASSPATH`的路径当作根目录寻找相关的`.class`文件\n\n### 忠告\n\n+ 无论何时创建包,都已经在给定包名称时隐含的指定了目录结构\n+ 这个包必须位于其名称所指定的目录之中,而该命令必须是以`CLASSPATH`开始的目录中可以查询到的\n+ 如果`CLASSPATH`中缺乏`.`作为路径之一,则当前目录就不是查找行为的起点之一\n+ 创建类可以把`public`成员置于开头,后面跟着`protected`,包访问权限,`private`成员\n\n# 访问权限修饰符\n\n默认是包访问权限,意味着当前的包中所有其他类对那个成员都有访问权限,但对应这个包之外的所有类,这个成员是`private`的\n\n`protected`也提供包访问权限\n\n## 其他包访问\n\n1. 使要访问的成员变为`public`\n2. 置于同一个包中\n3. 继承可以访问`public`和`protected`的,但只有同一个包内,才能访问包访问权限的\n4. `get/set`方法\n\n## 类访问权限\n\n类只能是包访问权限或`public`的","source":"_posts/Java笔记/Java编程思想/06_访问权限控制.md","raw":"---\ntitle: 第六章--访问权限控制\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第六章--访问权限控制。'\ncategories: Java编程思想\ntags:\n  - Java基础\n  - 修饰符\n  - 访问权限\nabbrlink: 73458eba\ndate: 2020-10-22 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n\n\n如何把变动的事物与保持不变的事物区分开\n\n# 包\n\n## 代码组织\n\n+ 当编写一个`Java`源代码文件时,此文件称为编译单元,他们必须有一个后缀名`.java`\n+ 编译单元内只能有一个`public`类,而且必须与文件名一致\n+ 如果有其他类,则包外是看不见的, 他们只是为主`public`类提供支持\n+ 当编译一个`.java`文件时,文件中每个类都会有一个输出文件\n+ `Java`可运行程序是一组可以打包并压缩为一个`java`文档文件的`.class`文件(**JAR**)\n\n## 包名\n\n把`package`名称分解为你机器上的一个目录,当`Java`程序运行并需要加载`.class`文件的时候,他就可以确定`.class`文件在目录所处的位置\n\n### Java解释器的运行过程\n\n+ 找出环境变量`CLASSPATH`,它包括了多个可供选择的查询路径\n+ 将包的名称由.换成/ 例如:`com.tongji.test`换成`com/tongji/test`\n+ 把`CLASSPATH`的路径当作根目录寻找相关的`.class`文件\n\n### 忠告\n\n+ 无论何时创建包,都已经在给定包名称时隐含的指定了目录结构\n+ 这个包必须位于其名称所指定的目录之中,而该命令必须是以`CLASSPATH`开始的目录中可以查询到的\n+ 如果`CLASSPATH`中缺乏`.`作为路径之一,则当前目录就不是查找行为的起点之一\n+ 创建类可以把`public`成员置于开头,后面跟着`protected`,包访问权限,`private`成员\n\n# 访问权限修饰符\n\n默认是包访问权限,意味着当前的包中所有其他类对那个成员都有访问权限,但对应这个包之外的所有类,这个成员是`private`的\n\n`protected`也提供包访问权限\n\n## 其他包访问\n\n1. 使要访问的成员变为`public`\n2. 置于同一个包中\n3. 继承可以访问`public`和`protected`的,但只有同一个包内,才能访问包访问权限的\n4. `get/set`方法\n\n## 类访问权限\n\n类只能是包访问权限或`public`的","slug":"Java笔记/Java编程思想/06_访问权限控制","published":1,"updated":"2021-02-04T00:40:26.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73700mnjotp1h2u9dlh","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<p>如何把变动的事物与保持不变的事物区分开</p>\n<h1 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h1><h2 id=\"代码组织\"><a href=\"#代码组织\" class=\"headerlink\" title=\"代码组织\"></a>代码组织</h2><ul>\n<li>当编写一个<code>Java</code>源代码文件时,此文件称为编译单元,他们必须有一个后缀名<code>.java</code></li>\n<li>编译单元内只能有一个<code>public</code>类,而且必须与文件名一致</li>\n<li>如果有其他类,则包外是看不见的, 他们只是为主<code>public</code>类提供支持</li>\n<li>当编译一个<code>.java</code>文件时,文件中每个类都会有一个输出文件</li>\n<li><code>Java</code>可运行程序是一组可以打包并压缩为一个<code>java</code>文档文件的<code>.class</code>文件(<strong>JAR</strong>)</li>\n</ul>\n<h2 id=\"包名\"><a href=\"#包名\" class=\"headerlink\" title=\"包名\"></a>包名</h2><p>把<code>package</code>名称分解为你机器上的一个目录,当<code>Java</code>程序运行并需要加载<code>.class</code>文件的时候,他就可以确定<code>.class</code>文件在目录所处的位置</p>\n<h3 id=\"Java解释器的运行过程\"><a href=\"#Java解释器的运行过程\" class=\"headerlink\" title=\"Java解释器的运行过程\"></a>Java解释器的运行过程</h3><ul>\n<li>找出环境变量<code>CLASSPATH</code>,它包括了多个可供选择的查询路径</li>\n<li>将包的名称由.换成/ 例如:<code>com.tongji.test</code>换成<code>com/tongji/test</code></li>\n<li>把<code>CLASSPATH</code>的路径当作根目录寻找相关的<code>.class</code>文件</li>\n</ul>\n<h3 id=\"忠告\"><a href=\"#忠告\" class=\"headerlink\" title=\"忠告\"></a>忠告</h3><ul>\n<li>无论何时创建包,都已经在给定包名称时隐含的指定了目录结构</li>\n<li>这个包必须位于其名称所指定的目录之中,而该命令必须是以<code>CLASSPATH</code>开始的目录中可以查询到的</li>\n<li>如果<code>CLASSPATH</code>中缺乏<code>.</code>作为路径之一,则当前目录就不是查找行为的起点之一</li>\n<li>创建类可以把<code>public</code>成员置于开头,后面跟着<code>protected</code>,包访问权限,<code>private</code>成员</li>\n</ul>\n<h1 id=\"访问权限修饰符\"><a href=\"#访问权限修饰符\" class=\"headerlink\" title=\"访问权限修饰符\"></a>访问权限修饰符</h1><p>默认是包访问权限,意味着当前的包中所有其他类对那个成员都有访问权限,但对应这个包之外的所有类,这个成员是<code>private</code>的</p>\n<p><code>protected</code>也提供包访问权限</p>\n<h2 id=\"其他包访问\"><a href=\"#其他包访问\" class=\"headerlink\" title=\"其他包访问\"></a>其他包访问</h2><ol>\n<li>使要访问的成员变为<code>public</code></li>\n<li>置于同一个包中</li>\n<li>继承可以访问<code>public</code>和<code>protected</code>的,但只有同一个包内,才能访问包访问权限的</li>\n<li><code>get/set</code>方法</li>\n</ol>\n<h2 id=\"类访问权限\"><a href=\"#类访问权限\" class=\"headerlink\" title=\"类访问权限\"></a>类访问权限</h2><p>类只能是包访问权限或<code>public</code>的</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<p>如何把变动的事物与保持不变的事物区分开</p>\n<h1 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h1><h2 id=\"代码组织\"><a href=\"#代码组织\" class=\"headerlink\" title=\"代码组织\"></a>代码组织</h2><ul>\n<li>当编写一个<code>Java</code>源代码文件时,此文件称为编译单元,他们必须有一个后缀名<code>.java</code></li>\n<li>编译单元内只能有一个<code>public</code>类,而且必须与文件名一致</li>\n<li>如果有其他类,则包外是看不见的, 他们只是为主<code>public</code>类提供支持</li>\n<li>当编译一个<code>.java</code>文件时,文件中每个类都会有一个输出文件</li>\n<li><code>Java</code>可运行程序是一组可以打包并压缩为一个<code>java</code>文档文件的<code>.class</code>文件(<strong>JAR</strong>)</li>\n</ul>\n<h2 id=\"包名\"><a href=\"#包名\" class=\"headerlink\" title=\"包名\"></a>包名</h2><p>把<code>package</code>名称分解为你机器上的一个目录,当<code>Java</code>程序运行并需要加载<code>.class</code>文件的时候,他就可以确定<code>.class</code>文件在目录所处的位置</p>\n<h3 id=\"Java解释器的运行过程\"><a href=\"#Java解释器的运行过程\" class=\"headerlink\" title=\"Java解释器的运行过程\"></a>Java解释器的运行过程</h3><ul>\n<li>找出环境变量<code>CLASSPATH</code>,它包括了多个可供选择的查询路径</li>\n<li>将包的名称由.换成/ 例如:<code>com.tongji.test</code>换成<code>com/tongji/test</code></li>\n<li>把<code>CLASSPATH</code>的路径当作根目录寻找相关的<code>.class</code>文件</li>\n</ul>\n<h3 id=\"忠告\"><a href=\"#忠告\" class=\"headerlink\" title=\"忠告\"></a>忠告</h3><ul>\n<li>无论何时创建包,都已经在给定包名称时隐含的指定了目录结构</li>\n<li>这个包必须位于其名称所指定的目录之中,而该命令必须是以<code>CLASSPATH</code>开始的目录中可以查询到的</li>\n<li>如果<code>CLASSPATH</code>中缺乏<code>.</code>作为路径之一,则当前目录就不是查找行为的起点之一</li>\n<li>创建类可以把<code>public</code>成员置于开头,后面跟着<code>protected</code>,包访问权限,<code>private</code>成员</li>\n</ul>\n<h1 id=\"访问权限修饰符\"><a href=\"#访问权限修饰符\" class=\"headerlink\" title=\"访问权限修饰符\"></a>访问权限修饰符</h1><p>默认是包访问权限,意味着当前的包中所有其他类对那个成员都有访问权限,但对应这个包之外的所有类,这个成员是<code>private</code>的</p>\n<p><code>protected</code>也提供包访问权限</p>\n<h2 id=\"其他包访问\"><a href=\"#其他包访问\" class=\"headerlink\" title=\"其他包访问\"></a>其他包访问</h2><ol>\n<li>使要访问的成员变为<code>public</code></li>\n<li>置于同一个包中</li>\n<li>继承可以访问<code>public</code>和<code>protected</code>的,但只有同一个包内,才能访问包访问权限的</li>\n<li><code>get/set</code>方法</li>\n</ol>\n<h2 id=\"类访问权限\"><a href=\"#类访问权限\" class=\"headerlink\" title=\"类访问权限\"></a>类访问权限</h2><p>类只能是包访问权限或<code>public</code>的</p>\n"},{"title":"第十章--内部类","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第十章--内部类。匿名内部类","abbrlink":"eaca0a57","date":"2020-10-25T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n\n\n# 创建内部类\n\n```java\npublic class Parcel\n{\n    public class Contents\n    {\n        public Parcel outer()\n        {\n            return Parcel.this;\n        }\n    }\n\n    public Contents contents()\n    {\n        return new Contents();\n    }\n}\n```\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        Parcel parcel = new Parcel();\n        Parcel.Contents contents = parcel.contents();\n        //引用外部类对象\n        Parcel outer = contents.outer();\n        //使用外部类的对象来创建内部类对象\n        Parcel.Contents contents1 = parcel.new Contents();\n    }\n}\n```\n\n# 链接到外部类\n\n1. 内部类能访问其外部对象的所有成员,而不需要任何特殊条件\n2. 它秘密捕获一个指向外部类对象的引用\n3. 在拥有外部类对象之前是不可能创建内部类对象的,因为内部类有指向外部类对象的引用\n4. 创建静态内部类则不需要先创建外部类对象\n\n# 匿名内部类\n\n## 使用带参数构造器\n\n`i`被传递给匿名类的基类的构造器\n\n```java\npublic class Wrapping\n{\n    private int i;\n\n    public Wrapping(int i)\n    {\n        this.i = i;\n    }\n\n    public int value()\n    {\n        return i;\n    }\n}\n```\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        Wrapping wrapping = wrapping(2);\n        System.out.println(wrapping.value());//94\n    }\n\n    public static Wrapping wrapping(int x)\n    {\n        return new Wrapping(x)\n        {\n          public int value()\n          {\n              return super.value() * 47;\n          }\n        };\n    }\n}\n```\n\n**在JDK8中如果我们在匿名内部类中需要访问局部变量，那么这个局部变量不需要用final修饰符修饰。**看似是一种编译机制的改变，实际上就是一个语法糖（底层还是帮你加了final）。但通过反编译没有看到底层为我们加上final，但我们无法改变这个局部变量的引用值，如果改变就会编译报错。\n\n# 嵌套类\n\n1. 如果不需要内部类对象与其外围类对象之间有联系,那么可以将内部类声明为`static`,称为嵌套类\n2. 要创建嵌套类的对象,不需要其外围类的对象\n3. 不能从嵌套类的对象中访问其非静态的外围类对象\n4. 普通类不能有`static`数据和字段\n\n# 为什么需要内部类\n\n+ 每个内部类都能独立地继承自一个接口的实现,所以无论外围类是否已经继承了某个接口的实现,对于内部类都没有影响\n+ 内部类可以有多个实例,每个实例都有自己的状态信息,并且与其外部类对象的信息相互独立\n+ 在单个外围类中,可以让多个内部类以不同的方法实现同一个接口","source":"_posts/Java笔记/Java编程思想/10_内部类.md","raw":"---\ntitle: 第十章--内部类\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第十章--内部类。匿名内部类'\ncategories: Java编程思想\ntags:\n  - Java基础\n  - 内部类\nabbrlink: eaca0a57\ndate: 2020-10-26 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n\n\n# 创建内部类\n\n```java\npublic class Parcel\n{\n    public class Contents\n    {\n        public Parcel outer()\n        {\n            return Parcel.this;\n        }\n    }\n\n    public Contents contents()\n    {\n        return new Contents();\n    }\n}\n```\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        Parcel parcel = new Parcel();\n        Parcel.Contents contents = parcel.contents();\n        //引用外部类对象\n        Parcel outer = contents.outer();\n        //使用外部类的对象来创建内部类对象\n        Parcel.Contents contents1 = parcel.new Contents();\n    }\n}\n```\n\n# 链接到外部类\n\n1. 内部类能访问其外部对象的所有成员,而不需要任何特殊条件\n2. 它秘密捕获一个指向外部类对象的引用\n3. 在拥有外部类对象之前是不可能创建内部类对象的,因为内部类有指向外部类对象的引用\n4. 创建静态内部类则不需要先创建外部类对象\n\n# 匿名内部类\n\n## 使用带参数构造器\n\n`i`被传递给匿名类的基类的构造器\n\n```java\npublic class Wrapping\n{\n    private int i;\n\n    public Wrapping(int i)\n    {\n        this.i = i;\n    }\n\n    public int value()\n    {\n        return i;\n    }\n}\n```\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        Wrapping wrapping = wrapping(2);\n        System.out.println(wrapping.value());//94\n    }\n\n    public static Wrapping wrapping(int x)\n    {\n        return new Wrapping(x)\n        {\n          public int value()\n          {\n              return super.value() * 47;\n          }\n        };\n    }\n}\n```\n\n**在JDK8中如果我们在匿名内部类中需要访问局部变量，那么这个局部变量不需要用final修饰符修饰。**看似是一种编译机制的改变，实际上就是一个语法糖（底层还是帮你加了final）。但通过反编译没有看到底层为我们加上final，但我们无法改变这个局部变量的引用值，如果改变就会编译报错。\n\n# 嵌套类\n\n1. 如果不需要内部类对象与其外围类对象之间有联系,那么可以将内部类声明为`static`,称为嵌套类\n2. 要创建嵌套类的对象,不需要其外围类的对象\n3. 不能从嵌套类的对象中访问其非静态的外围类对象\n4. 普通类不能有`static`数据和字段\n\n# 为什么需要内部类\n\n+ 每个内部类都能独立地继承自一个接口的实现,所以无论外围类是否已经继承了某个接口的实现,对于内部类都没有影响\n+ 内部类可以有多个实例,每个实例都有自己的状态信息,并且与其外部类对象的信息相互独立\n+ 在单个外围类中,可以让多个内部类以不同的方法实现同一个接口","slug":"Java笔记/Java编程思想/10_内部类","published":1,"updated":"2021-02-04T00:43:21.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73800mpjotp3rjncnys","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"创建内部类\"><a href=\"#创建内部类\" class=\"headerlink\" title=\"创建内部类\"></a>创建内部类</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Parcel</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Contents</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">public</span> Parcel <span class=\"token function\">outer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> Parcel<span class=\"token punctuation\">.</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> Contents <span class=\"token function\">contents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Contents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Parcel parcel <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Parcel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Parcel<span class=\"token punctuation\">.</span>Contents contents <span class=\"token operator\">=</span> parcel<span class=\"token punctuation\">.</span><span class=\"token function\">contents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//引用外部类对象</span>\n        Parcel outer <span class=\"token operator\">=</span> contents<span class=\"token punctuation\">.</span><span class=\"token function\">outer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//使用外部类的对象来创建内部类对象</span>\n        Parcel<span class=\"token punctuation\">.</span>Contents contents1 <span class=\"token operator\">=</span> parcel<span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Contents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"链接到外部类\"><a href=\"#链接到外部类\" class=\"headerlink\" title=\"链接到外部类\"></a>链接到外部类</h1><ol>\n<li>内部类能访问其外部对象的所有成员,而不需要任何特殊条件</li>\n<li>它秘密捕获一个指向外部类对象的引用</li>\n<li>在拥有外部类对象之前是不可能创建内部类对象的,因为内部类有指向外部类对象的引用</li>\n<li>创建静态内部类则不需要先创建外部类对象</li>\n</ol>\n<h1 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h1><h2 id=\"使用带参数构造器\"><a href=\"#使用带参数构造器\" class=\"headerlink\" title=\"使用带参数构造器\"></a>使用带参数构造器</h2><p><code>i</code>被传递给匿名类的基类的构造器</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Wrapping</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Wrapping</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Wrapping wrapping <span class=\"token operator\">=</span> <span class=\"token function\">wrapping</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>wrapping<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//94</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Wrapping <span class=\"token function\">wrapping</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Wrapping</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">47</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>在JDK8中如果我们在匿名内部类中需要访问局部变量，那么这个局部变量不需要用final修饰符修饰。</strong>看似是一种编译机制的改变，实际上就是一个语法糖（底层还是帮你加了final）。但通过反编译没有看到底层为我们加上final，但我们无法改变这个局部变量的引用值，如果改变就会编译报错。</p>\n<h1 id=\"嵌套类\"><a href=\"#嵌套类\" class=\"headerlink\" title=\"嵌套类\"></a>嵌套类</h1><ol>\n<li>如果不需要内部类对象与其外围类对象之间有联系,那么可以将内部类声明为<code>static</code>,称为嵌套类</li>\n<li>要创建嵌套类的对象,不需要其外围类的对象</li>\n<li>不能从嵌套类的对象中访问其非静态的外围类对象</li>\n<li>普通类不能有<code>static</code>数据和字段</li>\n</ol>\n<h1 id=\"为什么需要内部类\"><a href=\"#为什么需要内部类\" class=\"headerlink\" title=\"为什么需要内部类\"></a>为什么需要内部类</h1><ul>\n<li>每个内部类都能独立地继承自一个接口的实现,所以无论外围类是否已经继承了某个接口的实现,对于内部类都没有影响</li>\n<li>内部类可以有多个实例,每个实例都有自己的状态信息,并且与其外部类对象的信息相互独立</li>\n<li>在单个外围类中,可以让多个内部类以不同的方法实现同一个接口</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"创建内部类\"><a href=\"#创建内部类\" class=\"headerlink\" title=\"创建内部类\"></a>创建内部类</h1><pre><code class=\"java\">public class Parcel\n{\n    public class Contents\n    {\n        public Parcel outer()\n        {\n            return Parcel.this;\n        }\n    }\n\n    public Contents contents()\n    {\n        return new Contents();\n    }\n}</code></pre>\n<pre><code class=\"java\">public class MainTest\n{\n    public static void main(String[] args)\n    {\n        Parcel parcel = new Parcel();\n        Parcel.Contents contents = parcel.contents();\n        //引用外部类对象\n        Parcel outer = contents.outer();\n        //使用外部类的对象来创建内部类对象\n        Parcel.Contents contents1 = parcel.new Contents();\n    }\n}</code></pre>\n<h1 id=\"链接到外部类\"><a href=\"#链接到外部类\" class=\"headerlink\" title=\"链接到外部类\"></a>链接到外部类</h1><ol>\n<li>内部类能访问其外部对象的所有成员,而不需要任何特殊条件</li>\n<li>它秘密捕获一个指向外部类对象的引用</li>\n<li>在拥有外部类对象之前是不可能创建内部类对象的,因为内部类有指向外部类对象的引用</li>\n<li>创建静态内部类则不需要先创建外部类对象</li>\n</ol>\n<h1 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h1><h2 id=\"使用带参数构造器\"><a href=\"#使用带参数构造器\" class=\"headerlink\" title=\"使用带参数构造器\"></a>使用带参数构造器</h2><p><code>i</code>被传递给匿名类的基类的构造器</p>\n<pre><code class=\"java\">public class Wrapping\n{\n    private int i;\n\n    public Wrapping(int i)\n    {\n        this.i = i;\n    }\n\n    public int value()\n    {\n        return i;\n    }\n}</code></pre>\n<pre><code class=\"java\">public class MainTest\n{\n    public static void main(String[] args)\n    {\n        Wrapping wrapping = wrapping(2);\n        System.out.println(wrapping.value());//94\n    }\n\n    public static Wrapping wrapping(int x)\n    {\n        return new Wrapping(x)\n        {\n          public int value()\n          {\n              return super.value() * 47;\n          }\n        };\n    }\n}</code></pre>\n<p><strong>在JDK8中如果我们在匿名内部类中需要访问局部变量，那么这个局部变量不需要用final修饰符修饰。</strong>看似是一种编译机制的改变，实际上就是一个语法糖（底层还是帮你加了final）。但通过反编译没有看到底层为我们加上final，但我们无法改变这个局部变量的引用值，如果改变就会编译报错。</p>\n<h1 id=\"嵌套类\"><a href=\"#嵌套类\" class=\"headerlink\" title=\"嵌套类\"></a>嵌套类</h1><ol>\n<li>如果不需要内部类对象与其外围类对象之间有联系,那么可以将内部类声明为<code>static</code>,称为嵌套类</li>\n<li>要创建嵌套类的对象,不需要其外围类的对象</li>\n<li>不能从嵌套类的对象中访问其非静态的外围类对象</li>\n<li>普通类不能有<code>static</code>数据和字段</li>\n</ol>\n<h1 id=\"为什么需要内部类\"><a href=\"#为什么需要内部类\" class=\"headerlink\" title=\"为什么需要内部类\"></a>为什么需要内部类</h1><ul>\n<li>每个内部类都能独立地继承自一个接口的实现,所以无论外围类是否已经继承了某个接口的实现,对于内部类都没有影响</li>\n<li>内部类可以有多个实例,每个实例都有自己的状态信息,并且与其外部类对象的信息相互独立</li>\n<li>在单个外围类中,可以让多个内部类以不同的方法实现同一个接口</li>\n</ul>\n"},{"title":"第十一章--持有对象","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第十一章--持有对象。","abbrlink":"49e32910","date":"2020-10-27T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n# Collections与Arrays\n\n```java\n//集合构造器可以接收另一个集合来将自己初始化\n//Arrays.asList()产生的是第一个元素的类型,可能不匹配\n//使用Collections.addAll就不会产生这样的问题\n\nList<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));\nInteger[] integers = {6, 7, 8, 9, 10};\nlist.addAll(Arrays.asList(integers));\nCollections.addAll(list, 11, 12);\n```\n\n# 各个集合对比\n\n+ `ArrayList`,`LinkedList`按照被插入的顺序保存元素,使用`LinkedList`来实现`queue`,`stack`\n+ `HashSet`快,`TreeSet`按比较结果升序排列,`LinkedHashSet`按照被添加顺序保存对象\n+ `HashMap`快,`TreeMap`按照比较结果的升序保存键,`LinkedHashMap`按照插入顺序保存键,还保留了`HashMap`的查询速度\n\n# 迭代器\n\n+ 用迭代器来表示容器之间的共性,实现`Collection`就意味着需要提供`iterator()`方法,因为`Collection`继承了`Iterable`接口\n+ 创建了任何实现`Iterable`接口的类,都可以用于`foreach`语句中\n+ 数组也能使用`foreach`,但是不存在任何从数组到`Iterable`的自动转换\n\n# 集合总览\n\n![2243690-9cd9c896e0d512ed](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2243690-9cd9c896e0d512ed.gif)","source":"_posts/Java笔记/Java编程思想/11_持有对象.md","raw":"---\ntitle: 第十一章--持有对象\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第十一章--持有对象。'\ncategories: Java编程思想\ntags:\n  - Collection\n  - 集合\n  - Map\nabbrlink: '49e32910'\ndate: 2020-10-28 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n# Collections与Arrays\n\n```java\n//集合构造器可以接收另一个集合来将自己初始化\n//Arrays.asList()产生的是第一个元素的类型,可能不匹配\n//使用Collections.addAll就不会产生这样的问题\n\nList<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));\nInteger[] integers = {6, 7, 8, 9, 10};\nlist.addAll(Arrays.asList(integers));\nCollections.addAll(list, 11, 12);\n```\n\n# 各个集合对比\n\n+ `ArrayList`,`LinkedList`按照被插入的顺序保存元素,使用`LinkedList`来实现`queue`,`stack`\n+ `HashSet`快,`TreeSet`按比较结果升序排列,`LinkedHashSet`按照被添加顺序保存对象\n+ `HashMap`快,`TreeMap`按照比较结果的升序保存键,`LinkedHashMap`按照插入顺序保存键,还保留了`HashMap`的查询速度\n\n# 迭代器\n\n+ 用迭代器来表示容器之间的共性,实现`Collection`就意味着需要提供`iterator()`方法,因为`Collection`继承了`Iterable`接口\n+ 创建了任何实现`Iterable`接口的类,都可以用于`foreach`语句中\n+ 数组也能使用`foreach`,但是不存在任何从数组到`Iterable`的自动转换\n\n# 集合总览\n\n![2243690-9cd9c896e0d512ed](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2243690-9cd9c896e0d512ed.gif)","slug":"Java笔记/Java编程思想/11_持有对象","published":1,"updated":"2021-02-04T00:40:52.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73900mtjotpdk7z0k5n","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"Collections与Arrays\"><a href=\"#Collections与Arrays\" class=\"headerlink\" title=\"Collections与Arrays\"></a>Collections与Arrays</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//集合构造器可以接收另一个集合来将自己初始化</span>\n<span class=\"token comment\" spellcheck=\"true\">//Arrays.asList()产生的是第一个元素的类型,可能不匹配</span>\n<span class=\"token comment\" spellcheck=\"true\">//使用Collections.addAll就不会产生这样的问题</span>\n\nList<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nInteger<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> integers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>integers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nCollections<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h1 id=\"各个集合对比\"><a href=\"#各个集合对比\" class=\"headerlink\" title=\"各个集合对比\"></a>各个集合对比</h1><ul>\n<li><code>ArrayList</code>,<code>LinkedList</code>按照被插入的顺序保存元素,使用<code>LinkedList</code>来实现<code>queue</code>,<code>stack</code></li>\n<li><code>HashSet</code>快,<code>TreeSet</code>按比较结果升序排列,<code>LinkedHashSet</code>按照被添加顺序保存对象</li>\n<li><code>HashMap</code>快,<code>TreeMap</code>按照比较结果的升序保存键,<code>LinkedHashMap</code>按照插入顺序保存键,还保留了<code>HashMap</code>的查询速度</li>\n</ul>\n<h1 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h1><ul>\n<li>用迭代器来表示容器之间的共性,实现<code>Collection</code>就意味着需要提供<code>iterator()</code>方法,因为<code>Collection</code>继承了<code>Iterable</code>接口</li>\n<li>创建了任何实现<code>Iterable</code>接口的类,都可以用于<code>foreach</code>语句中</li>\n<li>数组也能使用<code>foreach</code>,但是不存在任何从数组到<code>Iterable</code>的自动转换</li>\n</ul>\n<h1 id=\"集合总览\"><a href=\"#集合总览\" class=\"headerlink\" title=\"集合总览\"></a>集合总览</h1><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2243690-9cd9c896e0d512ed.gif\" alt=\"2243690-9cd9c896e0d512ed\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"Collections与Arrays\"><a href=\"#Collections与Arrays\" class=\"headerlink\" title=\"Collections与Arrays\"></a>Collections与Arrays</h1><pre><code class=\"java\">//集合构造器可以接收另一个集合来将自己初始化\n//Arrays.asList()产生的是第一个元素的类型,可能不匹配\n//使用Collections.addAll就不会产生这样的问题\n\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));\nInteger[] integers = {6, 7, 8, 9, 10};\nlist.addAll(Arrays.asList(integers));\nCollections.addAll(list, 11, 12);</code></pre>\n<h1 id=\"各个集合对比\"><a href=\"#各个集合对比\" class=\"headerlink\" title=\"各个集合对比\"></a>各个集合对比</h1><ul>\n<li><code>ArrayList</code>,<code>LinkedList</code>按照被插入的顺序保存元素,使用<code>LinkedList</code>来实现<code>queue</code>,<code>stack</code></li>\n<li><code>HashSet</code>快,<code>TreeSet</code>按比较结果升序排列,<code>LinkedHashSet</code>按照被添加顺序保存对象</li>\n<li><code>HashMap</code>快,<code>TreeMap</code>按照比较结果的升序保存键,<code>LinkedHashMap</code>按照插入顺序保存键,还保留了<code>HashMap</code>的查询速度</li>\n</ul>\n<h1 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h1><ul>\n<li>用迭代器来表示容器之间的共性,实现<code>Collection</code>就意味着需要提供<code>iterator()</code>方法,因为<code>Collection</code>继承了<code>Iterable</code>接口</li>\n<li>创建了任何实现<code>Iterable</code>接口的类,都可以用于<code>foreach</code>语句中</li>\n<li>数组也能使用<code>foreach</code>,但是不存在任何从数组到<code>Iterable</code>的自动转换</li>\n</ul>\n<h1 id=\"集合总览\"><a href=\"#集合总览\" class=\"headerlink\" title=\"集合总览\"></a>集合总览</h1><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2243690-9cd9c896e0d512ed.gif\" alt=\"2243690-9cd9c896e0d512ed\"></p>\n"},{"title":"第十三章--字符串","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第十三章--字符串。","abbrlink":"6c3751ad","date":"2020-10-30T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n# 不可变String\n\n+ `String`对象是不可变的,任何一个操纵都是创建了一个全新的`String`对象以包含修改后的字符串内容\n+ 每当把`String`对象作为方法的参数时,都会复制一份引用,而该引用所指的对象其实一直待在单一的物理位置上\n+ 所有指向`String`的任何引用都不可能改变他的值\n+ 如果字符串操作比较简单,直接相信编译器会合理的构造,否则还是自己创建一个`StringBuilder`\n+ 在`toString`方法中,如果要打印出对象的内存地址,应该调用`Object.toString()`,所以应该调用的是`super.toString()`,而不能调用`this.toString()`(会递归)\n+ `String`的操作中,如果需要改变字符串的内容,则会返回一个新的`String`对象.如果内容没有改变,则返回原对象的引用\n\n# printf\n\n`String.format`效果一样\n\n```java\npublic static void main(String[] args)\n{\n    Random random = new Random(12);\n    for (int i = 0; i < 10; i++)\n    {\n        double price = random.nextDouble();\n        String description = \"ABCDEFGHIJKLMNOPQ\".substring(random.nextInt(10));\n        System.out.printf(\"%-15.15s,%5.2f\\n\",description,price);\n    }\n}\n/*\nGHIJKLMNOPQ    , 0.73\nBCDEFGHIJKLMNOP, 0.22\nGHIJKLMNOPQ    , 0.94\nCDEFGHIJKLMNOPQ, 0.93\nFGHIJKLMNOPQ   , 0.33\nBCDEFGHIJKLMNOP, 0.84\nABCDEFGHIJKLMNO, 0.89\nHIJKLMNOPQ     , 0.53\nHIJKLMNOPQ     , 0.92\nHIJKLMNOPQ     , 0.36\n*/\n```\n\n# 正则表达式\n\n## String\n\n```java\n    public static void main(String[] args)\n    {\n        if(\"12-\".matches(\"\\\\d+-?\"))\n        {\n            System.out.println(true);\n        }\n\n        String s = \"test a hello world test\";\n        System.out.println(Arrays.toString(s.split(\" \")));\n\n        //me a hello world me\n        System.out.println(s.replaceAll(\"test\", \"me\"));\n    }\n```\n\n## 规则\n\n+ `.`匹配任意字符\n+ `[abc]`三个字符之间\n+ `[^abc]`除了abc\n+ `\\s`空白符\n+ `\\d`数字\n+ `\\w`单词字符`[a-zA-Z0-9]`\n+ `XY`X跟在Y后面\n+ `X|Y`X或Y\n+ `^$`开始和结束\n+ `?`一个或零个\n+ `*`零个或多个\n+ `+`一个或多个\n+ `X{n}`,恰好n次\n\n\n\n# Pattern\n\n```java\nPattern compile = Pattern.compile(\"\\\\w+\");\nMatcher matcher = compile.matcher(\"12,3A\");\n//matches()判断整个输入字符串是否匹配\n//lookingAt()判断字符串的开始部分是否匹配\n//find()可以查找多个匹配,也能接收一个整数作为字符串搜索的起点位置\nif(matcher.find(3))\n{\n    System.out.println(matcher.start()+\",\"+matcher.end());\n    //3,5\n}\n```\n\n```java\n//Pattern.CASE_INSENSITIVE忽略大小写\n//Pattern.MULTILINE 正则表达式中出现了^或者$, 默认只会匹配第一行. 设置了Pattern.MULTILINE模式,会匹配所有行。\nPattern compile = Pattern.compile(\"^java\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);\nMatcher matcher = compile.matcher(\"java has regex \\nJava has regex \\nJAVA\");\nwhile(matcher.find())\n{\n    System.out.println(matcher.group());\n    /*\n    java\n    Java\n    JAVA\n     */\n}\n```\n\n# Scanner\n\n+ `Scanner`构造器接收任何类型的输入对象\n+ 普通的`next()`方法返回下一个`String`\n+ 所有`next()`方法只有找到一个完整的分词后才会返回\n+ `Scanner`假设在输入结束时抛出`IOException`\n+ 默认以空白字符对输入进行分词","source":"_posts/Java笔记/Java编程思想/13_字符串.md","raw":"---\ntitle: 第十三章--字符串\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第十三章--字符串。'\ncategories: Java编程思想\ntags:\n  - Java基础\n  - 字符串\n  - 正则表达式\nabbrlink: 6c3751ad\ndate: 2020-10-31 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n# 不可变String\n\n+ `String`对象是不可变的,任何一个操纵都是创建了一个全新的`String`对象以包含修改后的字符串内容\n+ 每当把`String`对象作为方法的参数时,都会复制一份引用,而该引用所指的对象其实一直待在单一的物理位置上\n+ 所有指向`String`的任何引用都不可能改变他的值\n+ 如果字符串操作比较简单,直接相信编译器会合理的构造,否则还是自己创建一个`StringBuilder`\n+ 在`toString`方法中,如果要打印出对象的内存地址,应该调用`Object.toString()`,所以应该调用的是`super.toString()`,而不能调用`this.toString()`(会递归)\n+ `String`的操作中,如果需要改变字符串的内容,则会返回一个新的`String`对象.如果内容没有改变,则返回原对象的引用\n\n# printf\n\n`String.format`效果一样\n\n```java\npublic static void main(String[] args)\n{\n    Random random = new Random(12);\n    for (int i = 0; i < 10; i++)\n    {\n        double price = random.nextDouble();\n        String description = \"ABCDEFGHIJKLMNOPQ\".substring(random.nextInt(10));\n        System.out.printf(\"%-15.15s,%5.2f\\n\",description,price);\n    }\n}\n/*\nGHIJKLMNOPQ    , 0.73\nBCDEFGHIJKLMNOP, 0.22\nGHIJKLMNOPQ    , 0.94\nCDEFGHIJKLMNOPQ, 0.93\nFGHIJKLMNOPQ   , 0.33\nBCDEFGHIJKLMNOP, 0.84\nABCDEFGHIJKLMNO, 0.89\nHIJKLMNOPQ     , 0.53\nHIJKLMNOPQ     , 0.92\nHIJKLMNOPQ     , 0.36\n*/\n```\n\n# 正则表达式\n\n## String\n\n```java\n    public static void main(String[] args)\n    {\n        if(\"12-\".matches(\"\\\\d+-?\"))\n        {\n            System.out.println(true);\n        }\n\n        String s = \"test a hello world test\";\n        System.out.println(Arrays.toString(s.split(\" \")));\n\n        //me a hello world me\n        System.out.println(s.replaceAll(\"test\", \"me\"));\n    }\n```\n\n## 规则\n\n+ `.`匹配任意字符\n+ `[abc]`三个字符之间\n+ `[^abc]`除了abc\n+ `\\s`空白符\n+ `\\d`数字\n+ `\\w`单词字符`[a-zA-Z0-9]`\n+ `XY`X跟在Y后面\n+ `X|Y`X或Y\n+ `^$`开始和结束\n+ `?`一个或零个\n+ `*`零个或多个\n+ `+`一个或多个\n+ `X{n}`,恰好n次\n\n\n\n# Pattern\n\n```java\nPattern compile = Pattern.compile(\"\\\\w+\");\nMatcher matcher = compile.matcher(\"12,3A\");\n//matches()判断整个输入字符串是否匹配\n//lookingAt()判断字符串的开始部分是否匹配\n//find()可以查找多个匹配,也能接收一个整数作为字符串搜索的起点位置\nif(matcher.find(3))\n{\n    System.out.println(matcher.start()+\",\"+matcher.end());\n    //3,5\n}\n```\n\n```java\n//Pattern.CASE_INSENSITIVE忽略大小写\n//Pattern.MULTILINE 正则表达式中出现了^或者$, 默认只会匹配第一行. 设置了Pattern.MULTILINE模式,会匹配所有行。\nPattern compile = Pattern.compile(\"^java\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);\nMatcher matcher = compile.matcher(\"java has regex \\nJava has regex \\nJAVA\");\nwhile(matcher.find())\n{\n    System.out.println(matcher.group());\n    /*\n    java\n    Java\n    JAVA\n     */\n}\n```\n\n# Scanner\n\n+ `Scanner`构造器接收任何类型的输入对象\n+ 普通的`next()`方法返回下一个`String`\n+ 所有`next()`方法只有找到一个完整的分词后才会返回\n+ `Scanner`假设在输入结束时抛出`IOException`\n+ 默认以空白字符对输入进行分词","slug":"Java笔记/Java编程思想/13_字符串","published":1,"updated":"2021-02-04T00:41:06.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73a00mvjotpesyx1h1p","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"不可变String\"><a href=\"#不可变String\" class=\"headerlink\" title=\"不可变String\"></a>不可变String</h1><ul>\n<li><code>String</code>对象是不可变的,任何一个操纵都是创建了一个全新的<code>String</code>对象以包含修改后的字符串内容</li>\n<li>每当把<code>String</code>对象作为方法的参数时,都会复制一份引用,而该引用所指的对象其实一直待在单一的物理位置上</li>\n<li>所有指向<code>String</code>的任何引用都不可能改变他的值</li>\n<li>如果字符串操作比较简单,直接相信编译器会合理的构造,否则还是自己创建一个<code>StringBuilder</code></li>\n<li>在<code>toString</code>方法中,如果要打印出对象的内存地址,应该调用<code>Object.toString()</code>,所以应该调用的是<code>super.toString()</code>,而不能调用<code>this.toString()</code>(会递归)</li>\n<li><code>String</code>的操作中,如果需要改变字符串的内容,则会返回一个新的<code>String</code>对象.如果内容没有改变,则返回原对象的引用</li>\n</ul>\n<h1 id=\"printf\"><a href=\"#printf\" class=\"headerlink\" title=\"printf\"></a>printf</h1><p><code>String.format</code>效果一样</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Random random <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">double</span> price <span class=\"token operator\">=</span> random<span class=\"token punctuation\">.</span><span class=\"token function\">nextDouble</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        String description <span class=\"token operator\">=</span> <span class=\"token string\">\"ABCDEFGHIJKLMNOPQ\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>random<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%-15.15s,%5.2f\\n\"</span><span class=\"token punctuation\">,</span>description<span class=\"token punctuation\">,</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/*\nGHIJKLMNOPQ    , 0.73\nBCDEFGHIJKLMNOP, 0.22\nGHIJKLMNOPQ    , 0.94\nCDEFGHIJKLMNOPQ, 0.93\nFGHIJKLMNOPQ   , 0.33\nBCDEFGHIJKLMNOP, 0.84\nABCDEFGHIJKLMNO, 0.89\nHIJKLMNOPQ     , 0.53\nHIJKLMNOPQ     , 0.92\nHIJKLMNOPQ     , 0.36\n*/</span></code></pre>\n<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"12-\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">matches</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\\\d+-?\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        String s <span class=\"token operator\">=</span> <span class=\"token string\">\"test a hello world test\"</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//me a hello world me</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">replaceAll</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"me\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h2><ul>\n<li><code>.</code>匹配任意字符</li>\n<li><code>[abc]</code>三个字符之间</li>\n<li><code>[^abc]</code>除了abc</li>\n<li><code>\\s</code>空白符</li>\n<li><code>\\d</code>数字</li>\n<li><code>\\w</code>单词字符<code>[a-zA-Z0-9]</code></li>\n<li><code>XY</code>X跟在Y后面</li>\n<li><code>X|Y</code>X或Y</li>\n<li><code>^$</code>开始和结束</li>\n<li><code>?</code>一个或零个</li>\n<li><code>*</code>零个或多个</li>\n<li><code>+</code>一个或多个</li>\n<li><code>X{n}</code>,恰好n次</li>\n</ul>\n<h1 id=\"Pattern\"><a href=\"#Pattern\" class=\"headerlink\" title=\"Pattern\"></a>Pattern</h1><pre class=\" language-java\"><code class=\"language-java\">Pattern compile <span class=\"token operator\">=</span> Pattern<span class=\"token punctuation\">.</span><span class=\"token function\">compile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\\\w+\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nMatcher matcher <span class=\"token operator\">=</span> compile<span class=\"token punctuation\">.</span><span class=\"token function\">matcher</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"12,3A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//matches()判断整个输入字符串是否匹配</span>\n<span class=\"token comment\" spellcheck=\"true\">//lookingAt()判断字符串的开始部分是否匹配</span>\n<span class=\"token comment\" spellcheck=\"true\">//find()可以查找多个匹配,也能接收一个整数作为字符串搜索的起点位置</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>matcher<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>matcher<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\",\"</span><span class=\"token operator\">+</span>matcher<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//3,5</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//Pattern.CASE_INSENSITIVE忽略大小写</span>\n<span class=\"token comment\" spellcheck=\"true\">//Pattern.MULTILINE 正则表达式中出现了^或者$, 默认只会匹配第一行. 设置了Pattern.MULTILINE模式,会匹配所有行。</span>\nPattern compile <span class=\"token operator\">=</span> Pattern<span class=\"token punctuation\">.</span><span class=\"token function\">compile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"^java\"</span><span class=\"token punctuation\">,</span> Pattern<span class=\"token punctuation\">.</span>CASE_INSENSITIVE <span class=\"token operator\">|</span> Pattern<span class=\"token punctuation\">.</span>MULTILINE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nMatcher matcher <span class=\"token operator\">=</span> compile<span class=\"token punctuation\">.</span><span class=\"token function\">matcher</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"java has regex \\nJava has regex \\nJAVA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>matcher<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>matcher<span class=\"token punctuation\">.</span><span class=\"token function\">group</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    java\n    Java\n    JAVA\n     */</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"Scanner\"><a href=\"#Scanner\" class=\"headerlink\" title=\"Scanner\"></a>Scanner</h1><ul>\n<li><code>Scanner</code>构造器接收任何类型的输入对象</li>\n<li>普通的<code>next()</code>方法返回下一个<code>String</code></li>\n<li>所有<code>next()</code>方法只有找到一个完整的分词后才会返回</li>\n<li><code>Scanner</code>假设在输入结束时抛出<code>IOException</code></li>\n<li>默认以空白字符对输入进行分词</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"不可变String\"><a href=\"#不可变String\" class=\"headerlink\" title=\"不可变String\"></a>不可变String</h1><ul>\n<li><code>String</code>对象是不可变的,任何一个操纵都是创建了一个全新的<code>String</code>对象以包含修改后的字符串内容</li>\n<li>每当把<code>String</code>对象作为方法的参数时,都会复制一份引用,而该引用所指的对象其实一直待在单一的物理位置上</li>\n<li>所有指向<code>String</code>的任何引用都不可能改变他的值</li>\n<li>如果字符串操作比较简单,直接相信编译器会合理的构造,否则还是自己创建一个<code>StringBuilder</code></li>\n<li>在<code>toString</code>方法中,如果要打印出对象的内存地址,应该调用<code>Object.toString()</code>,所以应该调用的是<code>super.toString()</code>,而不能调用<code>this.toString()</code>(会递归)</li>\n<li><code>String</code>的操作中,如果需要改变字符串的内容,则会返回一个新的<code>String</code>对象.如果内容没有改变,则返回原对象的引用</li>\n</ul>\n<h1 id=\"printf\"><a href=\"#printf\" class=\"headerlink\" title=\"printf\"></a>printf</h1><p><code>String.format</code>效果一样</p>\n<pre><code class=\"java\">public static void main(String[] args)\n{\n    Random random = new Random(12);\n    for (int i = 0; i &lt; 10; i++)\n    {\n        double price = random.nextDouble();\n        String description = &quot;ABCDEFGHIJKLMNOPQ&quot;.substring(random.nextInt(10));\n        System.out.printf(&quot;%-15.15s,%5.2f\\n&quot;,description,price);\n    }\n}\n/*\nGHIJKLMNOPQ    , 0.73\nBCDEFGHIJKLMNOP, 0.22\nGHIJKLMNOPQ    , 0.94\nCDEFGHIJKLMNOPQ, 0.93\nFGHIJKLMNOPQ   , 0.33\nBCDEFGHIJKLMNOP, 0.84\nABCDEFGHIJKLMNO, 0.89\nHIJKLMNOPQ     , 0.53\nHIJKLMNOPQ     , 0.92\nHIJKLMNOPQ     , 0.36\n*/</code></pre>\n<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><pre><code class=\"java\">    public static void main(String[] args)\n    {\n        if(&quot;12-&quot;.matches(&quot;\\\\d+-?&quot;))\n        {\n            System.out.println(true);\n        }\n\n        String s = &quot;test a hello world test&quot;;\n        System.out.println(Arrays.toString(s.split(&quot; &quot;)));\n\n        //me a hello world me\n        System.out.println(s.replaceAll(&quot;test&quot;, &quot;me&quot;));\n    }</code></pre>\n<h2 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h2><ul>\n<li><code>.</code>匹配任意字符</li>\n<li><code>[abc]</code>三个字符之间</li>\n<li><code>[^abc]</code>除了abc</li>\n<li><code>\\s</code>空白符</li>\n<li><code>\\d</code>数字</li>\n<li><code>\\w</code>单词字符<code>[a-zA-Z0-9]</code></li>\n<li><code>XY</code>X跟在Y后面</li>\n<li><code>X|Y</code>X或Y</li>\n<li><code>^$</code>开始和结束</li>\n<li><code>?</code>一个或零个</li>\n<li><code>*</code>零个或多个</li>\n<li><code>+</code>一个或多个</li>\n<li><code>X{n}</code>,恰好n次</li>\n</ul>\n<h1 id=\"Pattern\"><a href=\"#Pattern\" class=\"headerlink\" title=\"Pattern\"></a>Pattern</h1><pre><code class=\"java\">Pattern compile = Pattern.compile(&quot;\\\\w+&quot;);\nMatcher matcher = compile.matcher(&quot;12,3A&quot;);\n//matches()判断整个输入字符串是否匹配\n//lookingAt()判断字符串的开始部分是否匹配\n//find()可以查找多个匹配,也能接收一个整数作为字符串搜索的起点位置\nif(matcher.find(3))\n{\n    System.out.println(matcher.start()+&quot;,&quot;+matcher.end());\n    //3,5\n}</code></pre>\n<pre><code class=\"java\">//Pattern.CASE_INSENSITIVE忽略大小写\n//Pattern.MULTILINE 正则表达式中出现了^或者$, 默认只会匹配第一行. 设置了Pattern.MULTILINE模式,会匹配所有行。\nPattern compile = Pattern.compile(&quot;^java&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);\nMatcher matcher = compile.matcher(&quot;java has regex \\nJava has regex \\nJAVA&quot;);\nwhile(matcher.find())\n{\n    System.out.println(matcher.group());\n    /*\n    java\n    Java\n    JAVA\n     */\n}</code></pre>\n<h1 id=\"Scanner\"><a href=\"#Scanner\" class=\"headerlink\" title=\"Scanner\"></a>Scanner</h1><ul>\n<li><code>Scanner</code>构造器接收任何类型的输入对象</li>\n<li>普通的<code>next()</code>方法返回下一个<code>String</code></li>\n<li>所有<code>next()</code>方法只有找到一个完整的分词后才会返回</li>\n<li><code>Scanner</code>假设在输入结束时抛出<code>IOException</code></li>\n<li>默认以空白字符对输入进行分词</li>\n</ul>\n"},{"title":"第十二章--通过异常处理错误","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第十二章--通过异常处理错误。","abbrlink":"bf34118e","date":"2020-10-28T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n# 概念\n\n+ 异常通过编译器强制执行的\n+ 它往往能够降低错误处理代码的复杂度\n\n## 基本异常\n\n使用`new`在堆上创建异常对象,然后当前的执行路径被终止,并且从当前环境中弹出对异常对象的引用,此时异常处理机制接管程序,将程序从错误状态中恢复,使程序继续运行下去\n\n异常运行我们强制程序停止运行,并告诉我们出现了什么问题,或者强制程序处理问题,并返回到稳定状态\n\n`Throwable`对象是异常类型的跟类\n\n# 捕获异常\n\n+ 如果在方法内部抛出异常,它将在抛出异常的过程中结束\n+ 异常可以写入标准错误流`System.err`,他不会被重定向\n+ `e.printStackTrace()`打印从方法调用处直到异常抛出处的方法调用序列,默认是被输出到标准错误流\n+ `printStackTrace`返回一个由栈轨迹中的元素构成的数组,栈顶是调用序列中的最后一个方法调用\n\n```java\n    public static void main(String[] args)\n    {\n        try\n        {\n            test();\n        }\n        catch (Throwable throwable)\n        {\n            throwable.printStackTrace(System.out);\n        }\n    }\n\n    public static void test() throws Throwable\n    {\n        throw new Throwable();\n    }\n    /*\n    java.lang.Throwable\n\tat com.tongji.MainTest.test(MainTest.java:22)\n\tat com.tongji.MainTest.main(MainTest.java:12)\n     */\n```\n\n# 异常声明\n\n+ 如果方法里的代码产生了异常却没有进行处理,编译器会发现这个问题并提醒你:要么处理,要么在异常说明中表明该方法将产生异常\n+ 可以声明方法将抛出异常,而实际上不抛出\n+ 可以定义接口时预先声明异常,这样接口实现就可以抛出这些预先声明的异常\n+ 在编译器被强制检查的异常称为被检查的异常\n\n# Java标准异常\n\n`Throwable`用来表示任何可以作为异常抛出的类,`Error`用来表示编译时和系统错误,`Exception`是可以被抛出的基本类型\n\n## RuntimeException\n\n+ 是Java标准运行时检测的一部分,会自动被虚拟机抛出,不必要声明方法将抛出`RuntimeException`类型的异常\n+ 它称为不受检查异常,属于错误,将被自动捕获\n+ 该异常通常会穿越所有执行路径直达`main`方法,并在程序退出前调用异常的`printStackTrace`方法\n+ `RuntimeException`代表的其实是编程错误,要么是无法预料的错误(如传入`null`引用),程序员应该在代码中检查的错误(数组越界)\n\n# 异常的限制\n\n+ 当覆盖方法时,子类只能抛出在基类方法的异常说明中列出的那些异常,保证了对象的可替换性\n+ 异常限制对构造器不起作用,然而因为基类构造器必须被调用,所有派生类构造器的异常说明必须包含基类构造器的异常说明\n+ 派生类可以不抛出任何异常,即使它是基类定义的异常\n+ 不能基于异常说明来重载方法\n+ 一个出现在基类方法的异常说明中的异常,不一定会出现在派生类的异常说明里,即某个特定方法的异常说明的接口变小了,和继承相反\n\n# 构造器\n\n+ 构造器会把对象置为安全的初始状态,但是构造器内部抛出异常,就难受了\n+ 对于在构造阶段可能会抛出的异常,并且要求清理的类,最安全的使用方式是嵌套`try`语句\n+ 基本规则是,在创建需要清理的对象后,立即进入一个`try-finally`语句块\n\n# 异常匹配\n\n+ 异常在找到匹配的处理程序后,就认为异常得到处理,不再继续查找\n+ 只有在你知道如何处理的情况下才捕获异常\n+ `main`方法也可以有异常说明,如果使用``Exception``,就传递给了控制台,不需要写`try-catch`语句了\n\n","source":"_posts/Java笔记/Java编程思想/12_通过异常处理错误.md","raw":"---\ntitle: 第十二章--通过异常处理错误\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第十二章--通过异常处理错误。'\ncategories: Java编程思想\ntags:\n  - Java基础\n  - 异常\n  - Exception\nabbrlink: bf34118e\ndate: 2020-10-29 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n# 概念\n\n+ 异常通过编译器强制执行的\n+ 它往往能够降低错误处理代码的复杂度\n\n## 基本异常\n\n使用`new`在堆上创建异常对象,然后当前的执行路径被终止,并且从当前环境中弹出对异常对象的引用,此时异常处理机制接管程序,将程序从错误状态中恢复,使程序继续运行下去\n\n异常运行我们强制程序停止运行,并告诉我们出现了什么问题,或者强制程序处理问题,并返回到稳定状态\n\n`Throwable`对象是异常类型的跟类\n\n# 捕获异常\n\n+ 如果在方法内部抛出异常,它将在抛出异常的过程中结束\n+ 异常可以写入标准错误流`System.err`,他不会被重定向\n+ `e.printStackTrace()`打印从方法调用处直到异常抛出处的方法调用序列,默认是被输出到标准错误流\n+ `printStackTrace`返回一个由栈轨迹中的元素构成的数组,栈顶是调用序列中的最后一个方法调用\n\n```java\n    public static void main(String[] args)\n    {\n        try\n        {\n            test();\n        }\n        catch (Throwable throwable)\n        {\n            throwable.printStackTrace(System.out);\n        }\n    }\n\n    public static void test() throws Throwable\n    {\n        throw new Throwable();\n    }\n    /*\n    java.lang.Throwable\n\tat com.tongji.MainTest.test(MainTest.java:22)\n\tat com.tongji.MainTest.main(MainTest.java:12)\n     */\n```\n\n# 异常声明\n\n+ 如果方法里的代码产生了异常却没有进行处理,编译器会发现这个问题并提醒你:要么处理,要么在异常说明中表明该方法将产生异常\n+ 可以声明方法将抛出异常,而实际上不抛出\n+ 可以定义接口时预先声明异常,这样接口实现就可以抛出这些预先声明的异常\n+ 在编译器被强制检查的异常称为被检查的异常\n\n# Java标准异常\n\n`Throwable`用来表示任何可以作为异常抛出的类,`Error`用来表示编译时和系统错误,`Exception`是可以被抛出的基本类型\n\n## RuntimeException\n\n+ 是Java标准运行时检测的一部分,会自动被虚拟机抛出,不必要声明方法将抛出`RuntimeException`类型的异常\n+ 它称为不受检查异常,属于错误,将被自动捕获\n+ 该异常通常会穿越所有执行路径直达`main`方法,并在程序退出前调用异常的`printStackTrace`方法\n+ `RuntimeException`代表的其实是编程错误,要么是无法预料的错误(如传入`null`引用),程序员应该在代码中检查的错误(数组越界)\n\n# 异常的限制\n\n+ 当覆盖方法时,子类只能抛出在基类方法的异常说明中列出的那些异常,保证了对象的可替换性\n+ 异常限制对构造器不起作用,然而因为基类构造器必须被调用,所有派生类构造器的异常说明必须包含基类构造器的异常说明\n+ 派生类可以不抛出任何异常,即使它是基类定义的异常\n+ 不能基于异常说明来重载方法\n+ 一个出现在基类方法的异常说明中的异常,不一定会出现在派生类的异常说明里,即某个特定方法的异常说明的接口变小了,和继承相反\n\n# 构造器\n\n+ 构造器会把对象置为安全的初始状态,但是构造器内部抛出异常,就难受了\n+ 对于在构造阶段可能会抛出的异常,并且要求清理的类,最安全的使用方式是嵌套`try`语句\n+ 基本规则是,在创建需要清理的对象后,立即进入一个`try-finally`语句块\n\n# 异常匹配\n\n+ 异常在找到匹配的处理程序后,就认为异常得到处理,不再继续查找\n+ 只有在你知道如何处理的情况下才捕获异常\n+ `main`方法也可以有异常说明,如果使用``Exception``,就传递给了控制台,不需要写`try-catch`语句了\n\n","slug":"Java笔记/Java编程思想/12_通过异常处理错误","published":1,"updated":"2021-02-04T00:41:00.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73b00myjotp8fq25z6u","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><ul>\n<li>异常通过编译器强制执行的</li>\n<li>它往往能够降低错误处理代码的复杂度</li>\n</ul>\n<h2 id=\"基本异常\"><a href=\"#基本异常\" class=\"headerlink\" title=\"基本异常\"></a>基本异常</h2><p>使用<code>new</code>在堆上创建异常对象,然后当前的执行路径被终止,并且从当前环境中弹出对异常对象的引用,此时异常处理机制接管程序,将程序从错误状态中恢复,使程序继续运行下去</p>\n<p>异常运行我们强制程序停止运行,并告诉我们出现了什么问题,或者强制程序处理问题,并返回到稳定状态</p>\n<p><code>Throwable</code>对象是异常类型的跟类</p>\n<h1 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h1><ul>\n<li>如果在方法内部抛出异常,它将在抛出异常的过程中结束</li>\n<li>异常可以写入标准错误流<code>System.err</code>,他不会被重定向</li>\n<li><code>e.printStackTrace()</code>打印从方法调用处直到异常抛出处的方法调用序列,默认是被输出到标准错误流</li>\n<li><code>printStackTrace</code>返回一个由栈轨迹中的元素构成的数组,栈顶是调用序列中的最后一个方法调用</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> throwable<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            throwable<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Throwable\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Throwable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    java.lang.Throwable\n    at com.tongji.MainTest.test(MainTest.java:22)\n    at com.tongji.MainTest.main(MainTest.java:12)\n     */</span></code></pre>\n<h1 id=\"异常声明\"><a href=\"#异常声明\" class=\"headerlink\" title=\"异常声明\"></a>异常声明</h1><ul>\n<li>如果方法里的代码产生了异常却没有进行处理,编译器会发现这个问题并提醒你:要么处理,要么在异常说明中表明该方法将产生异常</li>\n<li>可以声明方法将抛出异常,而实际上不抛出</li>\n<li>可以定义接口时预先声明异常,这样接口实现就可以抛出这些预先声明的异常</li>\n<li>在编译器被强制检查的异常称为被检查的异常</li>\n</ul>\n<h1 id=\"Java标准异常\"><a href=\"#Java标准异常\" class=\"headerlink\" title=\"Java标准异常\"></a>Java标准异常</h1><p><code>Throwable</code>用来表示任何可以作为异常抛出的类,<code>Error</code>用来表示编译时和系统错误,<code>Exception</code>是可以被抛出的基本类型</p>\n<h2 id=\"RuntimeException\"><a href=\"#RuntimeException\" class=\"headerlink\" title=\"RuntimeException\"></a>RuntimeException</h2><ul>\n<li>是Java标准运行时检测的一部分,会自动被虚拟机抛出,不必要声明方法将抛出<code>RuntimeException</code>类型的异常</li>\n<li>它称为不受检查异常,属于错误,将被自动捕获</li>\n<li>该异常通常会穿越所有执行路径直达<code>main</code>方法,并在程序退出前调用异常的<code>printStackTrace</code>方法</li>\n<li><code>RuntimeException</code>代表的其实是编程错误,要么是无法预料的错误(如传入<code>null</code>引用),程序员应该在代码中检查的错误(数组越界)</li>\n</ul>\n<h1 id=\"异常的限制\"><a href=\"#异常的限制\" class=\"headerlink\" title=\"异常的限制\"></a>异常的限制</h1><ul>\n<li>当覆盖方法时,子类只能抛出在基类方法的异常说明中列出的那些异常,保证了对象的可替换性</li>\n<li>异常限制对构造器不起作用,然而因为基类构造器必须被调用,所有派生类构造器的异常说明必须包含基类构造器的异常说明</li>\n<li>派生类可以不抛出任何异常,即使它是基类定义的异常</li>\n<li>不能基于异常说明来重载方法</li>\n<li>一个出现在基类方法的异常说明中的异常,不一定会出现在派生类的异常说明里,即某个特定方法的异常说明的接口变小了,和继承相反</li>\n</ul>\n<h1 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h1><ul>\n<li>构造器会把对象置为安全的初始状态,但是构造器内部抛出异常,就难受了</li>\n<li>对于在构造阶段可能会抛出的异常,并且要求清理的类,最安全的使用方式是嵌套<code>try</code>语句</li>\n<li>基本规则是,在创建需要清理的对象后,立即进入一个<code>try-finally</code>语句块</li>\n</ul>\n<h1 id=\"异常匹配\"><a href=\"#异常匹配\" class=\"headerlink\" title=\"异常匹配\"></a>异常匹配</h1><ul>\n<li>异常在找到匹配的处理程序后,就认为异常得到处理,不再继续查找</li>\n<li>只有在你知道如何处理的情况下才捕获异常</li>\n<li><code>main</code>方法也可以有异常说明,如果使用<code>Exception</code>,就传递给了控制台,不需要写<code>try-catch</code>语句了</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><ul>\n<li>异常通过编译器强制执行的</li>\n<li>它往往能够降低错误处理代码的复杂度</li>\n</ul>\n<h2 id=\"基本异常\"><a href=\"#基本异常\" class=\"headerlink\" title=\"基本异常\"></a>基本异常</h2><p>使用<code>new</code>在堆上创建异常对象,然后当前的执行路径被终止,并且从当前环境中弹出对异常对象的引用,此时异常处理机制接管程序,将程序从错误状态中恢复,使程序继续运行下去</p>\n<p>异常运行我们强制程序停止运行,并告诉我们出现了什么问题,或者强制程序处理问题,并返回到稳定状态</p>\n<p><code>Throwable</code>对象是异常类型的跟类</p>\n<h1 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h1><ul>\n<li>如果在方法内部抛出异常,它将在抛出异常的过程中结束</li>\n<li>异常可以写入标准错误流<code>System.err</code>,他不会被重定向</li>\n<li><code>e.printStackTrace()</code>打印从方法调用处直到异常抛出处的方法调用序列,默认是被输出到标准错误流</li>\n<li><code>printStackTrace</code>返回一个由栈轨迹中的元素构成的数组,栈顶是调用序列中的最后一个方法调用</li>\n</ul>\n<pre><code class=\"java\">    public static void main(String[] args)\n    {\n        try\n        {\n            test();\n        }\n        catch (Throwable throwable)\n        {\n            throwable.printStackTrace(System.out);\n        }\n    }\n\n    public static void test() throws Throwable\n    {\n        throw new Throwable();\n    }\n    /*\n    java.lang.Throwable\n    at com.tongji.MainTest.test(MainTest.java:22)\n    at com.tongji.MainTest.main(MainTest.java:12)\n     */</code></pre>\n<h1 id=\"异常声明\"><a href=\"#异常声明\" class=\"headerlink\" title=\"异常声明\"></a>异常声明</h1><ul>\n<li>如果方法里的代码产生了异常却没有进行处理,编译器会发现这个问题并提醒你:要么处理,要么在异常说明中表明该方法将产生异常</li>\n<li>可以声明方法将抛出异常,而实际上不抛出</li>\n<li>可以定义接口时预先声明异常,这样接口实现就可以抛出这些预先声明的异常</li>\n<li>在编译器被强制检查的异常称为被检查的异常</li>\n</ul>\n<h1 id=\"Java标准异常\"><a href=\"#Java标准异常\" class=\"headerlink\" title=\"Java标准异常\"></a>Java标准异常</h1><p><code>Throwable</code>用来表示任何可以作为异常抛出的类,<code>Error</code>用来表示编译时和系统错误,<code>Exception</code>是可以被抛出的基本类型</p>\n<h2 id=\"RuntimeException\"><a href=\"#RuntimeException\" class=\"headerlink\" title=\"RuntimeException\"></a>RuntimeException</h2><ul>\n<li>是Java标准运行时检测的一部分,会自动被虚拟机抛出,不必要声明方法将抛出<code>RuntimeException</code>类型的异常</li>\n<li>它称为不受检查异常,属于错误,将被自动捕获</li>\n<li>该异常通常会穿越所有执行路径直达<code>main</code>方法,并在程序退出前调用异常的<code>printStackTrace</code>方法</li>\n<li><code>RuntimeException</code>代表的其实是编程错误,要么是无法预料的错误(如传入<code>null</code>引用),程序员应该在代码中检查的错误(数组越界)</li>\n</ul>\n<h1 id=\"异常的限制\"><a href=\"#异常的限制\" class=\"headerlink\" title=\"异常的限制\"></a>异常的限制</h1><ul>\n<li>当覆盖方法时,子类只能抛出在基类方法的异常说明中列出的那些异常,保证了对象的可替换性</li>\n<li>异常限制对构造器不起作用,然而因为基类构造器必须被调用,所有派生类构造器的异常说明必须包含基类构造器的异常说明</li>\n<li>派生类可以不抛出任何异常,即使它是基类定义的异常</li>\n<li>不能基于异常说明来重载方法</li>\n<li>一个出现在基类方法的异常说明中的异常,不一定会出现在派生类的异常说明里,即某个特定方法的异常说明的接口变小了,和继承相反</li>\n</ul>\n<h1 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h1><ul>\n<li>构造器会把对象置为安全的初始状态,但是构造器内部抛出异常,就难受了</li>\n<li>对于在构造阶段可能会抛出的异常,并且要求清理的类,最安全的使用方式是嵌套<code>try</code>语句</li>\n<li>基本规则是,在创建需要清理的对象后,立即进入一个<code>try-finally</code>语句块</li>\n</ul>\n<h1 id=\"异常匹配\"><a href=\"#异常匹配\" class=\"headerlink\" title=\"异常匹配\"></a>异常匹配</h1><ul>\n<li>异常在找到匹配的处理程序后,就认为异常得到处理,不再继续查找</li>\n<li>只有在你知道如何处理的情况下才捕获异常</li>\n<li><code>main</code>方法也可以有异常说明,如果使用<code>Exception</code>,就传递给了控制台,不需要写<code>try-catch</code>语句了</li>\n</ul>\n"},{"title":"第十四章--类型信息","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第十四章--类型信息。Class对象","abbrlink":"9deeb220","date":"2020-11-01T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n# Class对象\n\n```java\npublic static void main(String[] args)\n{\n    try\n    {\n\n        //使用全限定名\n        Class<?> clazz = Class.forName(\"com.tongji.Wrapping\");\n\n        Wrapping wrapping = new Wrapping(1);\n        clazz=wrapping.getClass();\n\n        //使用.class创建对Class对象的引用时,不会自动地初始化该Clas对象\n        clazz = Wrapping.class;\n\n        //clazz = int.class; 也可用于基本数据类型\n\n        System.out.println(Arrays.toString(clazz.getConstructors()));\n\n        //使用newInstance()则必须具有默认构造器\n        //newInstance()返回的只是Object类型\n        Object object = clazz.newInstance();\n    }\n    catch (ClassNotFoundException | IllegalAccessException | InstantiationException e)\n    {\n        e.printStackTrace();\n    }\n}\n```\n\n\n\n\n\n+ `Class`对象包含了与类有关的信息,用来创建类的所有常规对象的\n+ 每个类都有有个`Class`对象,保存在同名的`.class`文件中\n+ 想要在运行时获得类型信息,就必须首先获取对`Class`对象的引用\n+ 访问的`static`域不是`final`时,总是要链接和初始化\n+ 这个类型必须在编译时已知,才能用`RTTI`来识别\n+ `RTTI`与反射的区别是,`RTTI`在编译时打开和检查`.class`文件,而对于反射机制,`.class`在编译时不可获取,所以是在运行时打开和检查`.class`文件\n\n## 步骤\n\n+ 加载:查找字节码,创建Class对象\n+ 链接:为静态域分配存储空间\n+ 初始化:对超类初始化,执行静态初始化块.(延迟到了对静态方法的首次引用时)\n\n## 泛化的Class\n\n+ `Class<?>`优于平凡的`Class`,虽然是等价的\n+ `Class<? extend Number>`限定了Class引用为某种类型或他的任何子类型\n\n# 反射\n\n+ 能够创建有个编译时完全未知的对象,并调用此对象的方法","source":"_posts/Java笔记/Java编程思想/14_类型信息.md","raw":"---\ntitle: 第十四章--类型信息\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第十四章--类型信息。Class对象'\ncategories: Java编程思想\ntags:\n  - Java基础\n  - 反射\n  - Class\nabbrlink: 9deeb220\ndate: 2020-11-02 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n# Class对象\n\n```java\npublic static void main(String[] args)\n{\n    try\n    {\n\n        //使用全限定名\n        Class<?> clazz = Class.forName(\"com.tongji.Wrapping\");\n\n        Wrapping wrapping = new Wrapping(1);\n        clazz=wrapping.getClass();\n\n        //使用.class创建对Class对象的引用时,不会自动地初始化该Clas对象\n        clazz = Wrapping.class;\n\n        //clazz = int.class; 也可用于基本数据类型\n\n        System.out.println(Arrays.toString(clazz.getConstructors()));\n\n        //使用newInstance()则必须具有默认构造器\n        //newInstance()返回的只是Object类型\n        Object object = clazz.newInstance();\n    }\n    catch (ClassNotFoundException | IllegalAccessException | InstantiationException e)\n    {\n        e.printStackTrace();\n    }\n}\n```\n\n\n\n\n\n+ `Class`对象包含了与类有关的信息,用来创建类的所有常规对象的\n+ 每个类都有有个`Class`对象,保存在同名的`.class`文件中\n+ 想要在运行时获得类型信息,就必须首先获取对`Class`对象的引用\n+ 访问的`static`域不是`final`时,总是要链接和初始化\n+ 这个类型必须在编译时已知,才能用`RTTI`来识别\n+ `RTTI`与反射的区别是,`RTTI`在编译时打开和检查`.class`文件,而对于反射机制,`.class`在编译时不可获取,所以是在运行时打开和检查`.class`文件\n\n## 步骤\n\n+ 加载:查找字节码,创建Class对象\n+ 链接:为静态域分配存储空间\n+ 初始化:对超类初始化,执行静态初始化块.(延迟到了对静态方法的首次引用时)\n\n## 泛化的Class\n\n+ `Class<?>`优于平凡的`Class`,虽然是等价的\n+ `Class<? extend Number>`限定了Class引用为某种类型或他的任何子类型\n\n# 反射\n\n+ 能够创建有个编译时完全未知的对象,并调用此对象的方法","slug":"Java笔记/Java编程思想/14_类型信息","published":1,"updated":"2021-02-04T00:42:59.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73c00n1jotpb0hudkdj","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"Class对象\"><a href=\"#Class对象\" class=\"headerlink\" title=\"Class对象\"></a>Class对象</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span>\n    <span class=\"token punctuation\">{</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//使用全限定名</span>\n        Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> clazz <span class=\"token operator\">=</span> Class<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.tongji.Wrapping\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        Wrapping wrapping <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Wrapping</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        clazz<span class=\"token operator\">=</span>wrapping<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//使用.class创建对Class对象的引用时,不会自动地初始化该Clas对象</span>\n        clazz <span class=\"token operator\">=</span> Wrapping<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//clazz = int.class; 也可用于基本数据类型</span>\n\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getConstructors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//使用newInstance()则必须具有默认构造器</span>\n        <span class=\"token comment\" spellcheck=\"true\">//newInstance()返回的只是Object类型</span>\n        Object object <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassNotFoundException</span> <span class=\"token operator\">|</span> IllegalAccessException <span class=\"token operator\">|</span> InstantiationException e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li><code>Class</code>对象包含了与类有关的信息,用来创建类的所有常规对象的</li>\n<li>每个类都有有个<code>Class</code>对象,保存在同名的<code>.class</code>文件中</li>\n<li>想要在运行时获得类型信息,就必须首先获取对<code>Class</code>对象的引用</li>\n<li>访问的<code>static</code>域不是<code>final</code>时,总是要链接和初始化</li>\n<li>这个类型必须在编译时已知,才能用<code>RTTI</code>来识别</li>\n<li><code>RTTI</code>与反射的区别是,<code>RTTI</code>在编译时打开和检查<code>.class</code>文件,而对于反射机制,<code>.class</code>在编译时不可获取,所以是在运行时打开和检查<code>.class</code>文件</li>\n</ul>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ul>\n<li>加载:查找字节码,创建Class对象</li>\n<li>链接:为静态域分配存储空间</li>\n<li>初始化:对超类初始化,执行静态初始化块.(延迟到了对静态方法的首次引用时)</li>\n</ul>\n<h2 id=\"泛化的Class\"><a href=\"#泛化的Class\" class=\"headerlink\" title=\"泛化的Class\"></a>泛化的Class</h2><ul>\n<li><code>Class&lt;?&gt;</code>优于平凡的<code>Class</code>,虽然是等价的</li>\n<li><code>Class&lt;? extend Number&gt;</code>限定了Class引用为某种类型或他的任何子类型</li>\n</ul>\n<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><ul>\n<li>能够创建有个编译时完全未知的对象,并调用此对象的方法</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"Class对象\"><a href=\"#Class对象\" class=\"headerlink\" title=\"Class对象\"></a>Class对象</h1><pre><code class=\"java\">public static void main(String[] args)\n{\n    try\n    {\n\n        //使用全限定名\n        Class&lt;?&gt; clazz = Class.forName(&quot;com.tongji.Wrapping&quot;);\n\n        Wrapping wrapping = new Wrapping(1);\n        clazz=wrapping.getClass();\n\n        //使用.class创建对Class对象的引用时,不会自动地初始化该Clas对象\n        clazz = Wrapping.class;\n\n        //clazz = int.class; 也可用于基本数据类型\n\n        System.out.println(Arrays.toString(clazz.getConstructors()));\n\n        //使用newInstance()则必须具有默认构造器\n        //newInstance()返回的只是Object类型\n        Object object = clazz.newInstance();\n    }\n    catch (ClassNotFoundException | IllegalAccessException | InstantiationException e)\n    {\n        e.printStackTrace();\n    }\n}</code></pre>\n<ul>\n<li><code>Class</code>对象包含了与类有关的信息,用来创建类的所有常规对象的</li>\n<li>每个类都有有个<code>Class</code>对象,保存在同名的<code>.class</code>文件中</li>\n<li>想要在运行时获得类型信息,就必须首先获取对<code>Class</code>对象的引用</li>\n<li>访问的<code>static</code>域不是<code>final</code>时,总是要链接和初始化</li>\n<li>这个类型必须在编译时已知,才能用<code>RTTI</code>来识别</li>\n<li><code>RTTI</code>与反射的区别是,<code>RTTI</code>在编译时打开和检查<code>.class</code>文件,而对于反射机制,<code>.class</code>在编译时不可获取,所以是在运行时打开和检查<code>.class</code>文件</li>\n</ul>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ul>\n<li>加载:查找字节码,创建Class对象</li>\n<li>链接:为静态域分配存储空间</li>\n<li>初始化:对超类初始化,执行静态初始化块.(延迟到了对静态方法的首次引用时)</li>\n</ul>\n<h2 id=\"泛化的Class\"><a href=\"#泛化的Class\" class=\"headerlink\" title=\"泛化的Class\"></a>泛化的Class</h2><ul>\n<li><code>Class&lt;?&gt;</code>优于平凡的<code>Class</code>,虽然是等价的</li>\n<li><code>Class&lt;? extend Number&gt;</code>限定了Class引用为某种类型或他的任何子类型</li>\n</ul>\n<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><ul>\n<li>能够创建有个编译时完全未知的对象,并调用此对象的方法</li>\n</ul>\n"},{"title":"第十五章--泛型","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"<< Java编程思想 >>读书笔记,第十五章--泛型。泛型的相关问题","abbrlink":"d2c6f132","date":"2020-11-02T16:00:00.000Z","_content":"\n> <<Java编程思想>>读书笔记\n\n# 元组\n\n```java\npublic class TwoTuple<A,B>\n{\n    public final A first;\n    public final A second;\n\n    public TwoTuple(A first, A second)\n    {\n        this.first = first;\n        this.second = second;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"TwoTuple{\" +\n                \"first=\" + first +\n                \", second=\" + second +\n                '}';\n    }\n}\n```\n\n# 泛型方法\n\n+ 尽量使用泛型方法\n+ `static`方法无法访问泛型类的类型信息,要使用泛型能力,则必须成为泛型方法\n+ 泛型方法会使用类型参数推断\n+ 如果传入基本类型,则会自动装箱\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n\n        MainTest mainTest = new MainTest();\n        mainTest.test(1);\n        mainTest.test(\"ABC\");\n        //java.lang.Integer\n        //java.lang.String\n    }\n\n    public <T> void test(T x)\n    {\n        System.out.println(x.getClass().getName());\n    }\n}\n```\n\n# 擦除\n\n+ 在泛型代码内部,无法获得任何有关泛型参数类型的信息\n+ `List<String>`与`List<Integer> `都被擦除成他们原生的类型,即`List`\n+ 泛型类型参数将擦除到他的第一个边界\n+ 泛型类型只有在静态类型检查期间才出现,之后会擦除替换为他们的非泛型上界\n+ 如`List<T>`擦除为`List`,未指定边界的将擦除为`Object`\n+ 任何在运行时需要知道确切类型信息的操作都无法继续工作\n\n## 泛型数组\n\n```java\nList<String>[] array = (List<String>[]) new Object[10];\n//java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.util.List\n```\n\n\n\n+ 数组将跟踪他们的实际类型,而这个类型是数组在创建时确定的,因此,尽管`array`被转型成了`List<String>[]`,这个信息也只存在于编译期,在运行时,它仍然是一个`Object`数组\n+ 唯一方式是创建一个被擦除类型的新数组,然后对他转型\n+ 因为有了擦除,数组的运行时类型只能是`Object[]`,如果立即转型为`T[]`,那么编译期数组的实际类型就丢失,所以最好在集合内部使用`Object[]`,使用数组类型时,才转型为`T[]`\n\n# 问题\n\n1. 不能创建类似`ArrayList<int>`等,只能改成包装类`ArrayList<Integer>`\n2. 一个类不能实现同一个泛型接口的两种变体\n3. 使用带有泛型类型参数的转型不会有任何其他效果,还是会警告\n\n```java\n@SuppressWarnings(\"unchecked\")\npublic T test()\n{\n    Object[] objects = new Object[10];\n    objects[0] = t;\n    return (T) objects[0];//不抑制就有警告\n}\n```\n\n4. 不能使用泛型来区分重载方法\n5. `catch`不能捕获泛型类型的异常,因为在编译期和运行时都必须知道异常的确切类型","source":"_posts/Java笔记/Java编程思想/15_泛型.md","raw":"---\ntitle: 第十五章--泛型\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '<< Java编程思想 >>读书笔记,第十五章--泛型。泛型的相关问题'\ncategories: Java编程思想\ntags:\n  - Java基础\n  - 泛型\n  - 多态\nabbrlink: d2c6f132\ndate: 2020-11-03 00:00:00\n---\n\n> <<Java编程思想>>读书笔记\n\n# 元组\n\n```java\npublic class TwoTuple<A,B>\n{\n    public final A first;\n    public final A second;\n\n    public TwoTuple(A first, A second)\n    {\n        this.first = first;\n        this.second = second;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"TwoTuple{\" +\n                \"first=\" + first +\n                \", second=\" + second +\n                '}';\n    }\n}\n```\n\n# 泛型方法\n\n+ 尽量使用泛型方法\n+ `static`方法无法访问泛型类的类型信息,要使用泛型能力,则必须成为泛型方法\n+ 泛型方法会使用类型参数推断\n+ 如果传入基本类型,则会自动装箱\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n\n        MainTest mainTest = new MainTest();\n        mainTest.test(1);\n        mainTest.test(\"ABC\");\n        //java.lang.Integer\n        //java.lang.String\n    }\n\n    public <T> void test(T x)\n    {\n        System.out.println(x.getClass().getName());\n    }\n}\n```\n\n# 擦除\n\n+ 在泛型代码内部,无法获得任何有关泛型参数类型的信息\n+ `List<String>`与`List<Integer> `都被擦除成他们原生的类型,即`List`\n+ 泛型类型参数将擦除到他的第一个边界\n+ 泛型类型只有在静态类型检查期间才出现,之后会擦除替换为他们的非泛型上界\n+ 如`List<T>`擦除为`List`,未指定边界的将擦除为`Object`\n+ 任何在运行时需要知道确切类型信息的操作都无法继续工作\n\n## 泛型数组\n\n```java\nList<String>[] array = (List<String>[]) new Object[10];\n//java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.util.List\n```\n\n\n\n+ 数组将跟踪他们的实际类型,而这个类型是数组在创建时确定的,因此,尽管`array`被转型成了`List<String>[]`,这个信息也只存在于编译期,在运行时,它仍然是一个`Object`数组\n+ 唯一方式是创建一个被擦除类型的新数组,然后对他转型\n+ 因为有了擦除,数组的运行时类型只能是`Object[]`,如果立即转型为`T[]`,那么编译期数组的实际类型就丢失,所以最好在集合内部使用`Object[]`,使用数组类型时,才转型为`T[]`\n\n# 问题\n\n1. 不能创建类似`ArrayList<int>`等,只能改成包装类`ArrayList<Integer>`\n2. 一个类不能实现同一个泛型接口的两种变体\n3. 使用带有泛型类型参数的转型不会有任何其他效果,还是会警告\n\n```java\n@SuppressWarnings(\"unchecked\")\npublic T test()\n{\n    Object[] objects = new Object[10];\n    objects[0] = t;\n    return (T) objects[0];//不抑制就有警告\n}\n```\n\n4. 不能使用泛型来区分重载方法\n5. `catch`不能捕获泛型类型的异常,因为在编译期和运行时都必须知道异常的确切类型","slug":"Java笔记/Java编程思想/15_泛型","published":1,"updated":"2021-02-04T00:42:48.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73c00n5jotpbx3r5flq","content":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TwoTuple</span><span class=\"token operator\">&lt;</span>A<span class=\"token punctuation\">,</span>B<span class=\"token operator\">></span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> A first<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> A second<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">TwoTuple</span><span class=\"token punctuation\">(</span>A first<span class=\"token punctuation\">,</span> A second<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>first <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>second <span class=\"token operator\">=</span> second<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"TwoTuple{\"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"first=\"</span> <span class=\"token operator\">+</span> first <span class=\"token operator\">+</span>\n                <span class=\"token string\">\", second=\"</span> <span class=\"token operator\">+</span> second <span class=\"token operator\">+</span>\n                <span class=\"token string\">'}'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h1><ul>\n<li>尽量使用泛型方法</li>\n<li><code>static</code>方法无法访问泛型类的类型信息,要使用泛型能力,则必须成为泛型方法</li>\n<li>泛型方法会使用类型参数推断</li>\n<li>如果传入基本类型,则会自动装箱</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n\n        MainTest mainTest <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MainTest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mainTest<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mainTest<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ABC\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//java.lang.Integer</span>\n        <span class=\"token comment\" spellcheck=\"true\">//java.lang.String</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>T x<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"擦除\"><a href=\"#擦除\" class=\"headerlink\" title=\"擦除\"></a>擦除</h1><ul>\n<li>在泛型代码内部,无法获得任何有关泛型参数类型的信息</li>\n<li><code>List&lt;String&gt;</code>与<code>List&lt;Integer&gt; </code>都被擦除成他们原生的类型,即<code>List</code></li>\n<li>泛型类型参数将擦除到他的第一个边界</li>\n<li>泛型类型只有在静态类型检查期间才出现,之后会擦除替换为他们的非泛型上界</li>\n<li>如<code>List&lt;T&gt;</code>擦除为<code>List</code>,未指定边界的将擦除为<code>Object</code></li>\n<li>任何在运行时需要知道确切类型信息的操作都无法继续工作</li>\n</ul>\n<h2 id=\"泛型数组\"><a href=\"#泛型数组\" class=\"headerlink\" title=\"泛型数组\"></a>泛型数组</h2><pre class=\" language-java\"><code class=\"language-java\">List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.util.List</span></code></pre>\n<ul>\n<li>数组将跟踪他们的实际类型,而这个类型是数组在创建时确定的,因此,尽管<code>array</code>被转型成了<code>List&lt;String&gt;[]</code>,这个信息也只存在于编译期,在运行时,它仍然是一个<code>Object</code>数组</li>\n<li>唯一方式是创建一个被擦除类型的新数组,然后对他转型</li>\n<li>因为有了擦除,数组的运行时类型只能是<code>Object[]</code>,如果立即转型为<code>T[]</code>,那么编译期数组的实际类型就丢失,所以最好在集合内部使用<code>Object[]</code>,使用数组类型时,才转型为<code>T[]</code></li>\n</ul>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>不能创建类似<code>ArrayList&lt;int&gt;</code>等,只能改成包装类<code>ArrayList&lt;Integer&gt;</code></li>\n<li>一个类不能实现同一个泛型接口的两种变体</li>\n<li>使用带有泛型类型参数的转型不会有任何其他效果,还是会警告</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@SuppressWarnings</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unchecked\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> T <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> objects <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    objects<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span> objects<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//不抑制就有警告</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ol start=\"4\">\n<li>不能使用泛型来区分重载方法</li>\n<li><code>catch</code>不能捕获泛型类型的异常,因为在编译期和运行时都必须知道异常的确切类型</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>&lt;&lt;Java编程思想&gt;&gt;读书笔记</p>\n</blockquote>\n<h1 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h1><pre><code class=\"java\">public class TwoTuple&lt;A,B&gt;\n{\n    public final A first;\n    public final A second;\n\n    public TwoTuple(A first, A second)\n    {\n        this.first = first;\n        this.second = second;\n    }\n\n    @Override\n    public String toString()\n    {\n        return &quot;TwoTuple{&quot; +\n                &quot;first=&quot; + first +\n                &quot;, second=&quot; + second +\n                &#39;}&#39;;\n    }\n}</code></pre>\n<h1 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h1><ul>\n<li>尽量使用泛型方法</li>\n<li><code>static</code>方法无法访问泛型类的类型信息,要使用泛型能力,则必须成为泛型方法</li>\n<li>泛型方法会使用类型参数推断</li>\n<li>如果传入基本类型,则会自动装箱</li>\n</ul>\n<pre><code class=\"java\">public class MainTest\n{\n    public static void main(String[] args)\n    {\n\n        MainTest mainTest = new MainTest();\n        mainTest.test(1);\n        mainTest.test(&quot;ABC&quot;);\n        //java.lang.Integer\n        //java.lang.String\n    }\n\n    public &lt;T&gt; void test(T x)\n    {\n        System.out.println(x.getClass().getName());\n    }\n}</code></pre>\n<h1 id=\"擦除\"><a href=\"#擦除\" class=\"headerlink\" title=\"擦除\"></a>擦除</h1><ul>\n<li>在泛型代码内部,无法获得任何有关泛型参数类型的信息</li>\n<li><code>List&lt;String&gt;</code>与<code>List&lt;Integer&gt; </code>都被擦除成他们原生的类型,即<code>List</code></li>\n<li>泛型类型参数将擦除到他的第一个边界</li>\n<li>泛型类型只有在静态类型检查期间才出现,之后会擦除替换为他们的非泛型上界</li>\n<li>如<code>List&lt;T&gt;</code>擦除为<code>List</code>,未指定边界的将擦除为<code>Object</code></li>\n<li>任何在运行时需要知道确切类型信息的操作都无法继续工作</li>\n</ul>\n<h2 id=\"泛型数组\"><a href=\"#泛型数组\" class=\"headerlink\" title=\"泛型数组\"></a>泛型数组</h2><pre><code class=\"java\">List&lt;String&gt;[] array = (List&lt;String&gt;[]) new Object[10];\n//java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.util.List</code></pre>\n<ul>\n<li>数组将跟踪他们的实际类型,而这个类型是数组在创建时确定的,因此,尽管<code>array</code>被转型成了<code>List&lt;String&gt;[]</code>,这个信息也只存在于编译期,在运行时,它仍然是一个<code>Object</code>数组</li>\n<li>唯一方式是创建一个被擦除类型的新数组,然后对他转型</li>\n<li>因为有了擦除,数组的运行时类型只能是<code>Object[]</code>,如果立即转型为<code>T[]</code>,那么编译期数组的实际类型就丢失,所以最好在集合内部使用<code>Object[]</code>,使用数组类型时,才转型为<code>T[]</code></li>\n</ul>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>不能创建类似<code>ArrayList&lt;int&gt;</code>等,只能改成包装类<code>ArrayList&lt;Integer&gt;</code></li>\n<li>一个类不能实现同一个泛型接口的两种变体</li>\n<li>使用带有泛型类型参数的转型不会有任何其他效果,还是会警告</li>\n</ol>\n<pre><code class=\"java\">@SuppressWarnings(&quot;unchecked&quot;)\npublic T test()\n{\n    Object[] objects = new Object[10];\n    objects[0] = t;\n    return (T) objects[0];//不抑制就有警告\n}</code></pre>\n<ol start=\"4\">\n<li>不能使用泛型来区分重载方法</li>\n<li><code>catch</code>不能捕获泛型类型的异常,因为在编译期和运行时都必须知道异常的确切类型</li>\n</ol>\n"},{"title":"设计模式--命令模式","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Head Frist 设计模式》所做的笔记,主要介绍了命令模式的原则,类图,代码实现。","abbrlink":"e41403a7","date":"2020-10-05T16:00:00.000Z","_content":"\n# 命令模式\n\n## 定义\n\n命令模式将请求封装成对象,以便使用不同的请求,队列或者日志来参数化其他对象。命令模式也支持可撤销的操作\n\n## 细节\n\n+ 可将动作的请求者和动作的执行者对象中解耦\n+ 一个命令对象通过在特定接收者上绑定一组对象来封装一个请求，它将动作和接收者包进对象中。\n+ 使用栈存储操作过程的每一个命令，即可不断地实现撤销功能\n+ 可支持宏命令，即将一系列命令封装到一个命令对象中执行\n\n## 类图\n\n![命令模式类图](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201004105520644.png)\n\n# 简单遥控器实现\n\n## Command\n\n```java\npublic interface Command\n{\n    void execute();\n}\n```\n\n```java\npublic class LightOnCommand implements Command\n{\n    Light light;\n\n    public LightOnCommand(Light light)\n    {\n        this.light = light;\n    }\n\n    @Override\n    public void execute()\n    {\n        light.on();\n    }\n}\n```\n\n## Light\n\n```java\npublic class Light\n{\n    public void on()\n    {\n        System.out.println(\"light on\");\n    }\n\n    public void off()\n    {\n        System.out.println(\"light off\");\n    }\n}\n```\n\n## SimpleRemoteControl\n\n```java\npublic class SimpleRemoteControl\n{\n    Command slot;\n\n    public SimpleRemoteControl()\n    {\n    }\n\n    public void setCommand(Command command)\n    {\n        slot = command;\n    }\n    public void buttonWasPressed()\n    {\n        slot.execute();\n    }\n}\n```\n## RemoteControlTest\n```java\npublic class RemoteControlTest\n{\n    public static void main(String[] args)\n    {\n        SimpleRemoteControl remote = new SimpleRemoteControl();\n        Light light = new Light();\n        LightOnCommand lightOnCommand = new LightOnCommand(light);\n        remote.setCommand(lightOnCommand);\n        remote.buttonWasPressed();\n    }\n}\n```\n\n# 真正的遥控器\n\n## Light\n\n```java\npublic class Light\n{\n    private String name;\n\n    public Light()\n    {\n    }\n\n    public Light(String name)\n    {\n        this.name = name;\n    }\n\n    public void on()\n    {\n        System.out.println(\"light on \" + this.name);\n    }\n\n    public void off()\n    {\n        System.out.println(\"light off \" + this.name);\n    }\n}\n```\n\n## command\n\n```java\npublic interface Command\n{\n    void execute();\n\n    void undo();\n}\n```\n\n```java\npublic class LightOnCommand implements Command\n{\n    Light light;\n\n    public LightOnCommand(Light light)\n    {\n        this.light = light;\n    }\n\n    @Override\n    public void execute()\n    {\n        light.on();\n    }\n\n    public void undo()\n    {\n        light.off();\n    }\n}\n```\n\n```java\npublic class LightOffCommand implements Command\n{\n    Light light;\n\n    public LightOffCommand(Light light)\n    {\n        this.light = light;\n    }\n\n    @Override\n    public void execute()\n    {\n        light.off();\n    }\n\n    public void undo()\n    {\n        light.on();\n    }\n}\n```\n\n```java\npublic class NoCommand implements Command\n{\n    @Override\n    public void execute()\n    {\n        System.out.println(\"No Command\");\n    }\n\n    @Override\n    public void undo()\n    {\n        System.out.println(\"No Command\");\n    }\n}\n```\n\n## RemoteControl\n\n```java\npublic class RemoteControl\n{\n    private Command[] onCommands;\n    private Command[] offCommands;\n    private Command undoCommand;//用于实现撤销操作\n\n    public RemoteControl()\n    {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n\n        Command noCommand = new NoCommand();\n        for (int i = 0; i < 7; i++)\n        {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n        undoCommand = noCommand;\n    }\n\n    //留待以后扩展指令\n    public void setCommand(int slot,Command onCommand,Command offCommand)\n    {\n        onCommands[slot] = onCommand;\n        offCommands[slot] = offCommand;\n    }\n\n    public void onButtonWasPushed(int slot)\n    {\n        onCommands[slot].execute();\n        undoCommand = onCommands[slot];\n    }\n    public void offButtonWasPushed(int slot)\n    {\n        offCommands[slot].execute();\n        undoCommand = offCommands[slot];\n    }\n\n    public void undoButtonWasPushed()\n    {\n        undoCommand.undo();\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"RemoteControl{\" +\n                \"onCommands=\" + Arrays.toString(onCommands) +\n                \", offCommands=\" + Arrays.toString(offCommands) +\n                '}';\n    }\n}\n```\n\n## RemoteLoader\n\n```java\npublic class RemoteLoader\n{\n    public static void main(String[] args)\n    {\n        RemoteControl remoteControl = new RemoteControl();\n        Light livingRoomLight = new Light(\"Living Room\");\n        Light kitchenLight = new Light(\"Kitchen\");\n\n        LightOnCommand livingOnCommand = new LightOnCommand(livingRoomLight);\n        LightOffCommand livingOffCommand = new LightOffCommand(livingRoomLight);\n        LightOnCommand kitchenOnCommand = new LightOnCommand(kitchenLight);\n        LightOffCommand kitchenOffCommand = new LightOffCommand(kitchenLight);\n\n        remoteControl.setCommand(0, livingOnCommand, livingOffCommand);\n        remoteControl.setCommand(1, kitchenOnCommand, kitchenOffCommand);\n\n        remoteControl.onButtonWasPushed(0);\n        remoteControl.offButtonWasPushed(0);\n        remoteControl.undoButtonWasPushed();\n\n        System.out.println(\"------------------------\");\n        remoteControl.onButtonWasPushed(1);\n        remoteControl.offButtonWasPushed(1);\n        remoteControl.undoButtonWasPushed();\n\n        /*\n        light on Living Room\n        light off Living Room\n        light on Living Room\n        ------------------------\n        light on Kitchen\n        light off Kitchen\n        light on Kitchen\n         */\n\n    }\n}\n```\n\n","source":"_posts/设计模式笔记/命令模式/命令模式.md","raw":"---\ntitle: 设计模式--命令模式\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了命令模式的原则,类图,代码实现。'\ncategories: 设计模式笔记\ntags:\n  - 设计模式\n  - Java\n  - UML\nabbrlink: e41403a7\ndate: 2020-10-06 00:00:00\n---\n\n# 命令模式\n\n## 定义\n\n命令模式将请求封装成对象,以便使用不同的请求,队列或者日志来参数化其他对象。命令模式也支持可撤销的操作\n\n## 细节\n\n+ 可将动作的请求者和动作的执行者对象中解耦\n+ 一个命令对象通过在特定接收者上绑定一组对象来封装一个请求，它将动作和接收者包进对象中。\n+ 使用栈存储操作过程的每一个命令，即可不断地实现撤销功能\n+ 可支持宏命令，即将一系列命令封装到一个命令对象中执行\n\n## 类图\n\n![命令模式类图](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201004105520644.png)\n\n# 简单遥控器实现\n\n## Command\n\n```java\npublic interface Command\n{\n    void execute();\n}\n```\n\n```java\npublic class LightOnCommand implements Command\n{\n    Light light;\n\n    public LightOnCommand(Light light)\n    {\n        this.light = light;\n    }\n\n    @Override\n    public void execute()\n    {\n        light.on();\n    }\n}\n```\n\n## Light\n\n```java\npublic class Light\n{\n    public void on()\n    {\n        System.out.println(\"light on\");\n    }\n\n    public void off()\n    {\n        System.out.println(\"light off\");\n    }\n}\n```\n\n## SimpleRemoteControl\n\n```java\npublic class SimpleRemoteControl\n{\n    Command slot;\n\n    public SimpleRemoteControl()\n    {\n    }\n\n    public void setCommand(Command command)\n    {\n        slot = command;\n    }\n    public void buttonWasPressed()\n    {\n        slot.execute();\n    }\n}\n```\n## RemoteControlTest\n```java\npublic class RemoteControlTest\n{\n    public static void main(String[] args)\n    {\n        SimpleRemoteControl remote = new SimpleRemoteControl();\n        Light light = new Light();\n        LightOnCommand lightOnCommand = new LightOnCommand(light);\n        remote.setCommand(lightOnCommand);\n        remote.buttonWasPressed();\n    }\n}\n```\n\n# 真正的遥控器\n\n## Light\n\n```java\npublic class Light\n{\n    private String name;\n\n    public Light()\n    {\n    }\n\n    public Light(String name)\n    {\n        this.name = name;\n    }\n\n    public void on()\n    {\n        System.out.println(\"light on \" + this.name);\n    }\n\n    public void off()\n    {\n        System.out.println(\"light off \" + this.name);\n    }\n}\n```\n\n## command\n\n```java\npublic interface Command\n{\n    void execute();\n\n    void undo();\n}\n```\n\n```java\npublic class LightOnCommand implements Command\n{\n    Light light;\n\n    public LightOnCommand(Light light)\n    {\n        this.light = light;\n    }\n\n    @Override\n    public void execute()\n    {\n        light.on();\n    }\n\n    public void undo()\n    {\n        light.off();\n    }\n}\n```\n\n```java\npublic class LightOffCommand implements Command\n{\n    Light light;\n\n    public LightOffCommand(Light light)\n    {\n        this.light = light;\n    }\n\n    @Override\n    public void execute()\n    {\n        light.off();\n    }\n\n    public void undo()\n    {\n        light.on();\n    }\n}\n```\n\n```java\npublic class NoCommand implements Command\n{\n    @Override\n    public void execute()\n    {\n        System.out.println(\"No Command\");\n    }\n\n    @Override\n    public void undo()\n    {\n        System.out.println(\"No Command\");\n    }\n}\n```\n\n## RemoteControl\n\n```java\npublic class RemoteControl\n{\n    private Command[] onCommands;\n    private Command[] offCommands;\n    private Command undoCommand;//用于实现撤销操作\n\n    public RemoteControl()\n    {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n\n        Command noCommand = new NoCommand();\n        for (int i = 0; i < 7; i++)\n        {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n        undoCommand = noCommand;\n    }\n\n    //留待以后扩展指令\n    public void setCommand(int slot,Command onCommand,Command offCommand)\n    {\n        onCommands[slot] = onCommand;\n        offCommands[slot] = offCommand;\n    }\n\n    public void onButtonWasPushed(int slot)\n    {\n        onCommands[slot].execute();\n        undoCommand = onCommands[slot];\n    }\n    public void offButtonWasPushed(int slot)\n    {\n        offCommands[slot].execute();\n        undoCommand = offCommands[slot];\n    }\n\n    public void undoButtonWasPushed()\n    {\n        undoCommand.undo();\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"RemoteControl{\" +\n                \"onCommands=\" + Arrays.toString(onCommands) +\n                \", offCommands=\" + Arrays.toString(offCommands) +\n                '}';\n    }\n}\n```\n\n## RemoteLoader\n\n```java\npublic class RemoteLoader\n{\n    public static void main(String[] args)\n    {\n        RemoteControl remoteControl = new RemoteControl();\n        Light livingRoomLight = new Light(\"Living Room\");\n        Light kitchenLight = new Light(\"Kitchen\");\n\n        LightOnCommand livingOnCommand = new LightOnCommand(livingRoomLight);\n        LightOffCommand livingOffCommand = new LightOffCommand(livingRoomLight);\n        LightOnCommand kitchenOnCommand = new LightOnCommand(kitchenLight);\n        LightOffCommand kitchenOffCommand = new LightOffCommand(kitchenLight);\n\n        remoteControl.setCommand(0, livingOnCommand, livingOffCommand);\n        remoteControl.setCommand(1, kitchenOnCommand, kitchenOffCommand);\n\n        remoteControl.onButtonWasPushed(0);\n        remoteControl.offButtonWasPushed(0);\n        remoteControl.undoButtonWasPushed();\n\n        System.out.println(\"------------------------\");\n        remoteControl.onButtonWasPushed(1);\n        remoteControl.offButtonWasPushed(1);\n        remoteControl.undoButtonWasPushed();\n\n        /*\n        light on Living Room\n        light off Living Room\n        light on Living Room\n        ------------------------\n        light on Kitchen\n        light off Kitchen\n        light on Kitchen\n         */\n\n    }\n}\n```\n\n","slug":"设计模式笔记/命令模式/命令模式","published":1,"updated":"2020-11-12T11:57:30.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73d00n8jotp1e0g1aju","content":"<h1 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>命令模式将请求封装成对象,以便使用不同的请求,队列或者日志来参数化其他对象。命令模式也支持可撤销的操作</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ul>\n<li>可将动作的请求者和动作的执行者对象中解耦</li>\n<li>一个命令对象通过在特定接收者上绑定一组对象来封装一个请求，它将动作和接收者包进对象中。</li>\n<li>使用栈存储操作过程的每一个命令，即可不断地实现撤销功能</li>\n<li>可支持宏命令，即将一系列命令封装到一个命令对象中执行</li>\n</ul>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201004105520644.png\" alt=\"命令模式类图\"></p>\n<h1 id=\"简单遥控器实现\"><a href=\"#简单遥控器实现\" class=\"headerlink\" title=\"简单遥控器实现\"></a>简单遥控器实现</h1><h2 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Command</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LightOnCommand</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Command</span>\n<span class=\"token punctuation\">{</span>\n    Light light<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">LightOnCommand</span><span class=\"token punctuation\">(</span>Light light<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>light <span class=\"token operator\">=</span> light<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        light<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"Light\"><a href=\"#Light\" class=\"headerlink\" title=\"Light\"></a>Light</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Light</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light on\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">off</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light off\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"SimpleRemoteControl\"><a href=\"#SimpleRemoteControl\" class=\"headerlink\" title=\"SimpleRemoteControl\"></a>SimpleRemoteControl</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleRemoteControl</span>\n<span class=\"token punctuation\">{</span>\n    Command slot<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">SimpleRemoteControl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setCommand</span><span class=\"token punctuation\">(</span>Command command<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        slot <span class=\"token operator\">=</span> command<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">buttonWasPressed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        slot<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"RemoteControlTest\"><a href=\"#RemoteControlTest\" class=\"headerlink\" title=\"RemoteControlTest\"></a>RemoteControlTest</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RemoteControlTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        SimpleRemoteControl remote <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleRemoteControl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Light light <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Light</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        LightOnCommand lightOnCommand <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LightOnCommand</span><span class=\"token punctuation\">(</span>light<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        remote<span class=\"token punctuation\">.</span><span class=\"token function\">setCommand</span><span class=\"token punctuation\">(</span>lightOnCommand<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        remote<span class=\"token punctuation\">.</span><span class=\"token function\">buttonWasPressed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"真正的遥控器\"><a href=\"#真正的遥控器\" class=\"headerlink\" title=\"真正的遥控器\"></a>真正的遥控器</h1><h2 id=\"Light-1\"><a href=\"#Light-1\" class=\"headerlink\" title=\"Light\"></a>Light</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Light</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> String name<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Light</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Light</span><span class=\"token punctuation\">(</span>String name<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light on \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">off</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light off \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a>command</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Command</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">undo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LightOnCommand</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Command</span>\n<span class=\"token punctuation\">{</span>\n    Light light<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">LightOnCommand</span><span class=\"token punctuation\">(</span>Light light<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>light <span class=\"token operator\">=</span> light<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        light<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">undo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        light<span class=\"token punctuation\">.</span><span class=\"token function\">off</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LightOffCommand</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Command</span>\n<span class=\"token punctuation\">{</span>\n    Light light<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">LightOffCommand</span><span class=\"token punctuation\">(</span>Light light<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>light <span class=\"token operator\">=</span> light<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        light<span class=\"token punctuation\">.</span><span class=\"token function\">off</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">undo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        light<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NoCommand</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Command</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"No Command\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">undo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"No Command\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"RemoteControl\"><a href=\"#RemoteControl\" class=\"headerlink\" title=\"RemoteControl\"></a>RemoteControl</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RemoteControl</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Command<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> onCommands<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> Command<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> offCommands<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> Command undoCommand<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//用于实现撤销操作</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">RemoteControl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        onCommands <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Command</span><span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        offCommands <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Command</span><span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        Command noCommand <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NoCommand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            onCommands<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> noCommand<span class=\"token punctuation\">;</span>\n            offCommands<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> noCommand<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        undoCommand <span class=\"token operator\">=</span> noCommand<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//留待以后扩展指令</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setCommand</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> slot<span class=\"token punctuation\">,</span>Command onCommand<span class=\"token punctuation\">,</span>Command offCommand<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        onCommands<span class=\"token punctuation\">[</span>slot<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> onCommand<span class=\"token punctuation\">;</span>\n        offCommands<span class=\"token punctuation\">[</span>slot<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> offCommand<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onButtonWasPushed</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> slot<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        onCommands<span class=\"token punctuation\">[</span>slot<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        undoCommand <span class=\"token operator\">=</span> onCommands<span class=\"token punctuation\">[</span>slot<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">offButtonWasPushed</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> slot<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        offCommands<span class=\"token punctuation\">[</span>slot<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        undoCommand <span class=\"token operator\">=</span> offCommands<span class=\"token punctuation\">[</span>slot<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">undoButtonWasPushed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        undoCommand<span class=\"token punctuation\">.</span><span class=\"token function\">undo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"RemoteControl{\"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"onCommands=\"</span> <span class=\"token operator\">+</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>onCommands<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\", offCommands=\"</span> <span class=\"token operator\">+</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>offCommands<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">'}'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"RemoteLoader\"><a href=\"#RemoteLoader\" class=\"headerlink\" title=\"RemoteLoader\"></a>RemoteLoader</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RemoteLoader</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        RemoteControl remoteControl <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RemoteControl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Light livingRoomLight <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Light</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Living Room\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Light kitchenLight <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Light</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Kitchen\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        LightOnCommand livingOnCommand <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LightOnCommand</span><span class=\"token punctuation\">(</span>livingRoomLight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        LightOffCommand livingOffCommand <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LightOffCommand</span><span class=\"token punctuation\">(</span>livingRoomLight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        LightOnCommand kitchenOnCommand <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LightOnCommand</span><span class=\"token punctuation\">(</span>kitchenLight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        LightOffCommand kitchenOffCommand <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LightOffCommand</span><span class=\"token punctuation\">(</span>kitchenLight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        remoteControl<span class=\"token punctuation\">.</span><span class=\"token function\">setCommand</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> livingOnCommand<span class=\"token punctuation\">,</span> livingOffCommand<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        remoteControl<span class=\"token punctuation\">.</span><span class=\"token function\">setCommand</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> kitchenOnCommand<span class=\"token punctuation\">,</span> kitchenOffCommand<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        remoteControl<span class=\"token punctuation\">.</span><span class=\"token function\">onButtonWasPushed</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        remoteControl<span class=\"token punctuation\">.</span><span class=\"token function\">offButtonWasPushed</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        remoteControl<span class=\"token punctuation\">.</span><span class=\"token function\">undoButtonWasPushed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"------------------------\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        remoteControl<span class=\"token punctuation\">.</span><span class=\"token function\">onButtonWasPushed</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        remoteControl<span class=\"token punctuation\">.</span><span class=\"token function\">offButtonWasPushed</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        remoteControl<span class=\"token punctuation\">.</span><span class=\"token function\">undoButtonWasPushed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/*\n        light on Living Room\n        light off Living Room\n        light on Living Room\n        ------------------------\n        light on Kitchen\n        light off Kitchen\n        light on Kitchen\n         */</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>命令模式将请求封装成对象,以便使用不同的请求,队列或者日志来参数化其他对象。命令模式也支持可撤销的操作</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ul>\n<li>可将动作的请求者和动作的执行者对象中解耦</li>\n<li>一个命令对象通过在特定接收者上绑定一组对象来封装一个请求，它将动作和接收者包进对象中。</li>\n<li>使用栈存储操作过程的每一个命令，即可不断地实现撤销功能</li>\n<li>可支持宏命令，即将一系列命令封装到一个命令对象中执行</li>\n</ul>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201004105520644.png\" alt=\"命令模式类图\"></p>\n<h1 id=\"简单遥控器实现\"><a href=\"#简单遥控器实现\" class=\"headerlink\" title=\"简单遥控器实现\"></a>简单遥控器实现</h1><h2 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h2><pre><code class=\"java\">public interface Command\n{\n    void execute();\n}</code></pre>\n<pre><code class=\"java\">public class LightOnCommand implements Command\n{\n    Light light;\n\n    public LightOnCommand(Light light)\n    {\n        this.light = light;\n    }\n\n    @Override\n    public void execute()\n    {\n        light.on();\n    }\n}</code></pre>\n<h2 id=\"Light\"><a href=\"#Light\" class=\"headerlink\" title=\"Light\"></a>Light</h2><pre><code class=\"java\">public class Light\n{\n    public void on()\n    {\n        System.out.println(&quot;light on&quot;);\n    }\n\n    public void off()\n    {\n        System.out.println(&quot;light off&quot;);\n    }\n}</code></pre>\n<h2 id=\"SimpleRemoteControl\"><a href=\"#SimpleRemoteControl\" class=\"headerlink\" title=\"SimpleRemoteControl\"></a>SimpleRemoteControl</h2><pre><code class=\"java\">public class SimpleRemoteControl\n{\n    Command slot;\n\n    public SimpleRemoteControl()\n    {\n    }\n\n    public void setCommand(Command command)\n    {\n        slot = command;\n    }\n    public void buttonWasPressed()\n    {\n        slot.execute();\n    }\n}</code></pre>\n<h2 id=\"RemoteControlTest\"><a href=\"#RemoteControlTest\" class=\"headerlink\" title=\"RemoteControlTest\"></a>RemoteControlTest</h2><pre><code class=\"java\">public class RemoteControlTest\n{\n    public static void main(String[] args)\n    {\n        SimpleRemoteControl remote = new SimpleRemoteControl();\n        Light light = new Light();\n        LightOnCommand lightOnCommand = new LightOnCommand(light);\n        remote.setCommand(lightOnCommand);\n        remote.buttonWasPressed();\n    }\n}</code></pre>\n<h1 id=\"真正的遥控器\"><a href=\"#真正的遥控器\" class=\"headerlink\" title=\"真正的遥控器\"></a>真正的遥控器</h1><h2 id=\"Light-1\"><a href=\"#Light-1\" class=\"headerlink\" title=\"Light\"></a>Light</h2><pre><code class=\"java\">public class Light\n{\n    private String name;\n\n    public Light()\n    {\n    }\n\n    public Light(String name)\n    {\n        this.name = name;\n    }\n\n    public void on()\n    {\n        System.out.println(&quot;light on &quot; + this.name);\n    }\n\n    public void off()\n    {\n        System.out.println(&quot;light off &quot; + this.name);\n    }\n}</code></pre>\n<h2 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a>command</h2><pre><code class=\"java\">public interface Command\n{\n    void execute();\n\n    void undo();\n}</code></pre>\n<pre><code class=\"java\">public class LightOnCommand implements Command\n{\n    Light light;\n\n    public LightOnCommand(Light light)\n    {\n        this.light = light;\n    }\n\n    @Override\n    public void execute()\n    {\n        light.on();\n    }\n\n    public void undo()\n    {\n        light.off();\n    }\n}</code></pre>\n<pre><code class=\"java\">public class LightOffCommand implements Command\n{\n    Light light;\n\n    public LightOffCommand(Light light)\n    {\n        this.light = light;\n    }\n\n    @Override\n    public void execute()\n    {\n        light.off();\n    }\n\n    public void undo()\n    {\n        light.on();\n    }\n}</code></pre>\n<pre><code class=\"java\">public class NoCommand implements Command\n{\n    @Override\n    public void execute()\n    {\n        System.out.println(&quot;No Command&quot;);\n    }\n\n    @Override\n    public void undo()\n    {\n        System.out.println(&quot;No Command&quot;);\n    }\n}</code></pre>\n<h2 id=\"RemoteControl\"><a href=\"#RemoteControl\" class=\"headerlink\" title=\"RemoteControl\"></a>RemoteControl</h2><pre><code class=\"java\">public class RemoteControl\n{\n    private Command[] onCommands;\n    private Command[] offCommands;\n    private Command undoCommand;//用于实现撤销操作\n\n    public RemoteControl()\n    {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n\n        Command noCommand = new NoCommand();\n        for (int i = 0; i &lt; 7; i++)\n        {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n        undoCommand = noCommand;\n    }\n\n    //留待以后扩展指令\n    public void setCommand(int slot,Command onCommand,Command offCommand)\n    {\n        onCommands[slot] = onCommand;\n        offCommands[slot] = offCommand;\n    }\n\n    public void onButtonWasPushed(int slot)\n    {\n        onCommands[slot].execute();\n        undoCommand = onCommands[slot];\n    }\n    public void offButtonWasPushed(int slot)\n    {\n        offCommands[slot].execute();\n        undoCommand = offCommands[slot];\n    }\n\n    public void undoButtonWasPushed()\n    {\n        undoCommand.undo();\n    }\n\n    @Override\n    public String toString()\n    {\n        return &quot;RemoteControl{&quot; +\n                &quot;onCommands=&quot; + Arrays.toString(onCommands) +\n                &quot;, offCommands=&quot; + Arrays.toString(offCommands) +\n                &#39;}&#39;;\n    }\n}</code></pre>\n<h2 id=\"RemoteLoader\"><a href=\"#RemoteLoader\" class=\"headerlink\" title=\"RemoteLoader\"></a>RemoteLoader</h2><pre><code class=\"java\">public class RemoteLoader\n{\n    public static void main(String[] args)\n    {\n        RemoteControl remoteControl = new RemoteControl();\n        Light livingRoomLight = new Light(&quot;Living Room&quot;);\n        Light kitchenLight = new Light(&quot;Kitchen&quot;);\n\n        LightOnCommand livingOnCommand = new LightOnCommand(livingRoomLight);\n        LightOffCommand livingOffCommand = new LightOffCommand(livingRoomLight);\n        LightOnCommand kitchenOnCommand = new LightOnCommand(kitchenLight);\n        LightOffCommand kitchenOffCommand = new LightOffCommand(kitchenLight);\n\n        remoteControl.setCommand(0, livingOnCommand, livingOffCommand);\n        remoteControl.setCommand(1, kitchenOnCommand, kitchenOffCommand);\n\n        remoteControl.onButtonWasPushed(0);\n        remoteControl.offButtonWasPushed(0);\n        remoteControl.undoButtonWasPushed();\n\n        System.out.println(&quot;------------------------&quot;);\n        remoteControl.onButtonWasPushed(1);\n        remoteControl.offButtonWasPushed(1);\n        remoteControl.undoButtonWasPushed();\n\n        /*\n        light on Living Room\n        light off Living Room\n        light on Living Room\n        ------------------------\n        light on Kitchen\n        light off Kitchen\n        light on Kitchen\n         */\n\n    }\n}</code></pre>\n"},{"title":"设计模式--外观模式","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Head Frist 设计模式》所做的笔记,主要介绍了外观模式的原则,类图,代码实现。","abbrlink":"6bd9c708","date":"2020-10-09T16:00:00.000Z","_content":"\n# 外观模式\n\n## 定义\n\n外观模式提供了一个统一的接口,用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。\n\n## 设计原则\n\n最少知识原则：只和你的密友谈话。不要让太多的类耦合在一起\n\n就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：\n\n+ 该对象本身\n+ 被当作方法参数而传递进来的对象\n+ 此方法所创建或实例化的任何对象\n+ 被实例变量所引用的任何对象\n\n## 细节\n\n+ 通过实现一个提供更合理的接口的外观类,你可以将一个复杂的子系统变得容易使用\n+ 外观模式没有封装子系统的类,只是提供了简化的接口\n+ 外观模式将客户从组件的子系统中解耦\n+ 外观的意图是提供子系统的一个简化接口\n\n# 代码\n\n## component\n\n```java\npublic class CdPlayer\n{\n    public void on()\n    {\n        System.out.println(\"CdPlayer on\");\n    }\n\n    public void off()\n    {\n        System.out.println(\"CdPlayer off\");\n    }\n}\n```\n\n```java\npublic class DvdPlayer\n{\n    public void on()\n    {\n        System.out.println(\"DvdPlayer on\");\n    }\n\n    public void off()\n    {\n        System.out.println(\"DvdPlayer off\");\n    }\n}\n```\n\n## HomeTheaterFacade\n```java\npublic class HomeTheaterFacade\n{\n    CdPlayer cdPlayer;\n    DvdPlayer dvdPlayer;\n\n    public HomeTheaterFacade(CdPlayer cdPlayer, DvdPlayer dvdPlayer)\n    {\n        this.cdPlayer = cdPlayer;\n        this.dvdPlayer = dvdPlayer;\n    }\n\n    public void watchMovie(String movie)\n    {\n        System.out.println(\"Ready to play \"+movie);\n        cdPlayer.on();\n        dvdPlayer.on();\n    }\n\n\n    public void closeMovie()\n    {\n        System.out.println(\"Ready to close \");\n        cdPlayer.off();\n        dvdPlayer.off();\n    }\n}\n```\n\n## MainTest\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        //一般来说,外观是直接委派,不需要用户自己创建\n        HomeTheaterFacade theaterFacade = new HomeTheaterFacade(new CdPlayer(), new DvdPlayer());\n        theaterFacade.watchMovie(\"I am\");\n        theaterFacade.closeMovie();\n    }\n}\n```","source":"_posts/设计模式笔记/外观模式/外观模式.md","raw":"---\ntitle: 设计模式--外观模式\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了外观模式的原则,类图,代码实现。'\ncategories: 设计模式笔记\ntags:\n  - 设计模式\n  - Java\n  - UML\nabbrlink: 6bd9c708\ndate: 2020-10-10 00:00:00\n---\n\n# 外观模式\n\n## 定义\n\n外观模式提供了一个统一的接口,用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。\n\n## 设计原则\n\n最少知识原则：只和你的密友谈话。不要让太多的类耦合在一起\n\n就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：\n\n+ 该对象本身\n+ 被当作方法参数而传递进来的对象\n+ 此方法所创建或实例化的任何对象\n+ 被实例变量所引用的任何对象\n\n## 细节\n\n+ 通过实现一个提供更合理的接口的外观类,你可以将一个复杂的子系统变得容易使用\n+ 外观模式没有封装子系统的类,只是提供了简化的接口\n+ 外观模式将客户从组件的子系统中解耦\n+ 外观的意图是提供子系统的一个简化接口\n\n# 代码\n\n## component\n\n```java\npublic class CdPlayer\n{\n    public void on()\n    {\n        System.out.println(\"CdPlayer on\");\n    }\n\n    public void off()\n    {\n        System.out.println(\"CdPlayer off\");\n    }\n}\n```\n\n```java\npublic class DvdPlayer\n{\n    public void on()\n    {\n        System.out.println(\"DvdPlayer on\");\n    }\n\n    public void off()\n    {\n        System.out.println(\"DvdPlayer off\");\n    }\n}\n```\n\n## HomeTheaterFacade\n```java\npublic class HomeTheaterFacade\n{\n    CdPlayer cdPlayer;\n    DvdPlayer dvdPlayer;\n\n    public HomeTheaterFacade(CdPlayer cdPlayer, DvdPlayer dvdPlayer)\n    {\n        this.cdPlayer = cdPlayer;\n        this.dvdPlayer = dvdPlayer;\n    }\n\n    public void watchMovie(String movie)\n    {\n        System.out.println(\"Ready to play \"+movie);\n        cdPlayer.on();\n        dvdPlayer.on();\n    }\n\n\n    public void closeMovie()\n    {\n        System.out.println(\"Ready to close \");\n        cdPlayer.off();\n        dvdPlayer.off();\n    }\n}\n```\n\n## MainTest\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        //一般来说,外观是直接委派,不需要用户自己创建\n        HomeTheaterFacade theaterFacade = new HomeTheaterFacade(new CdPlayer(), new DvdPlayer());\n        theaterFacade.watchMovie(\"I am\");\n        theaterFacade.closeMovie();\n    }\n}\n```","slug":"设计模式笔记/外观模式/外观模式","published":1,"updated":"2020-11-12T11:57:30.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73e00najotp93wq69e1","content":"<h1 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>外观模式提供了一个统一的接口,用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><p>最少知识原则：只和你的密友谈话。不要让太多的类耦合在一起</p>\n<p>就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：</p>\n<ul>\n<li>该对象本身</li>\n<li>被当作方法参数而传递进来的对象</li>\n<li>此方法所创建或实例化的任何对象</li>\n<li>被实例变量所引用的任何对象</li>\n</ul>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ul>\n<li>通过实现一个提供更合理的接口的外观类,你可以将一个复杂的子系统变得容易使用</li>\n<li>外观模式没有封装子系统的类,只是提供了简化的接口</li>\n<li>外观模式将客户从组件的子系统中解耦</li>\n<li>外观的意图是提供子系统的一个简化接口</li>\n</ul>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><h2 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CdPlayer</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"CdPlayer on\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">off</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"CdPlayer off\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DvdPlayer</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"DvdPlayer on\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">off</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"DvdPlayer off\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"HomeTheaterFacade\"><a href=\"#HomeTheaterFacade\" class=\"headerlink\" title=\"HomeTheaterFacade\"></a>HomeTheaterFacade</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HomeTheaterFacade</span>\n<span class=\"token punctuation\">{</span>\n    CdPlayer cdPlayer<span class=\"token punctuation\">;</span>\n    DvdPlayer dvdPlayer<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">HomeTheaterFacade</span><span class=\"token punctuation\">(</span>CdPlayer cdPlayer<span class=\"token punctuation\">,</span> DvdPlayer dvdPlayer<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>cdPlayer <span class=\"token operator\">=</span> cdPlayer<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dvdPlayer <span class=\"token operator\">=</span> dvdPlayer<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">watchMovie</span><span class=\"token punctuation\">(</span>String movie<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Ready to play \"</span><span class=\"token operator\">+</span>movie<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cdPlayer<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        dvdPlayer<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">closeMovie</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Ready to close \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cdPlayer<span class=\"token punctuation\">.</span><span class=\"token function\">off</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        dvdPlayer<span class=\"token punctuation\">.</span><span class=\"token function\">off</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//一般来说,外观是直接委派,不需要用户自己创建</span>\n        HomeTheaterFacade theaterFacade <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HomeTheaterFacade</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">CdPlayer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DvdPlayer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        theaterFacade<span class=\"token punctuation\">.</span><span class=\"token function\">watchMovie</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I am\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        theaterFacade<span class=\"token punctuation\">.</span><span class=\"token function\">closeMovie</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>外观模式提供了一个统一的接口,用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><p>最少知识原则：只和你的密友谈话。不要让太多的类耦合在一起</p>\n<p>就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：</p>\n<ul>\n<li>该对象本身</li>\n<li>被当作方法参数而传递进来的对象</li>\n<li>此方法所创建或实例化的任何对象</li>\n<li>被实例变量所引用的任何对象</li>\n</ul>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ul>\n<li>通过实现一个提供更合理的接口的外观类,你可以将一个复杂的子系统变得容易使用</li>\n<li>外观模式没有封装子系统的类,只是提供了简化的接口</li>\n<li>外观模式将客户从组件的子系统中解耦</li>\n<li>外观的意图是提供子系统的一个简化接口</li>\n</ul>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><h2 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h2><pre><code class=\"java\">public class CdPlayer\n{\n    public void on()\n    {\n        System.out.println(&quot;CdPlayer on&quot;);\n    }\n\n    public void off()\n    {\n        System.out.println(&quot;CdPlayer off&quot;);\n    }\n}</code></pre>\n<pre><code class=\"java\">public class DvdPlayer\n{\n    public void on()\n    {\n        System.out.println(&quot;DvdPlayer on&quot;);\n    }\n\n    public void off()\n    {\n        System.out.println(&quot;DvdPlayer off&quot;);\n    }\n}</code></pre>\n<h2 id=\"HomeTheaterFacade\"><a href=\"#HomeTheaterFacade\" class=\"headerlink\" title=\"HomeTheaterFacade\"></a>HomeTheaterFacade</h2><pre><code class=\"java\">public class HomeTheaterFacade\n{\n    CdPlayer cdPlayer;\n    DvdPlayer dvdPlayer;\n\n    public HomeTheaterFacade(CdPlayer cdPlayer, DvdPlayer dvdPlayer)\n    {\n        this.cdPlayer = cdPlayer;\n        this.dvdPlayer = dvdPlayer;\n    }\n\n    public void watchMovie(String movie)\n    {\n        System.out.println(&quot;Ready to play &quot;+movie);\n        cdPlayer.on();\n        dvdPlayer.on();\n    }\n\n\n    public void closeMovie()\n    {\n        System.out.println(&quot;Ready to close &quot;);\n        cdPlayer.off();\n        dvdPlayer.off();\n    }\n}</code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre><code class=\"java\">public class MainTest\n{\n    public static void main(String[] args)\n    {\n        //一般来说,外观是直接委派,不需要用户自己创建\n        HomeTheaterFacade theaterFacade = new HomeTheaterFacade(new CdPlayer(), new DvdPlayer());\n        theaterFacade.watchMovie(&quot;I am&quot;);\n        theaterFacade.closeMovie();\n    }\n}</code></pre>\n"},{"title":"设计模式--模板方法模式","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Head Frist 设计模式》所做的笔记,主要介绍了模板方法模式的原则,类图,代码实现。","abbrlink":"3c67b570","date":"2020-10-12T16:00:00.000Z","_content":"\n# 模板方法模式\n## 模板方法模式定义\n\n模板方法模式在一个方法中定义一个算法的骨架,而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。\n\n## 细节\n\n+ 模板就是一个方法，将算法定义成一组步骤，其中任何步骤都可以是抽象的，由子类负责实现。这可以确保算法的结构保持不变，同时由子类提供部分实现。\n+ 钩子是一种被声明在抽象类中的方法，只有空或者默认的实现，他可以让子类有能力对算法的不同点进行挂钩。如果算法的某部分是可选的，就用钩子\n+ 与策略模式的区别是策略模式组合的类中实现了整个算法，而模板方法模式可能只实现了算法中的部分步骤。\n+ 为了防止子类改变模板方法中的算法，可以将模板方法声明为final\n\n\n## 设计原则\n\n+ 好莱坞原则：别调用我们，我们会调用你。即低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。例如模板方法中`CaffeineBeverageWithHook`为高层组件，只有在需要子类实现某个方法时，才调用子类。\n\n## 用途\n\n+ Java排序，需要实现`Comparable接口`，实现`compareTo()`方法进行两个元素大小的比较。\n+ Swing窗口中，通过继承`JFrame`，再覆盖父类中不做事的`paint()`方法来在窗口绘制。\n+ Applet是能在网页上运行的小程序，它提供了很多个钩子方法。通过继承`Applet`，再覆盖他的几个接口可以方便进行开发,例如：\n\n```java\npublic class MyApplet extends Applet\n{\n    private String message;\n\n    //init钩子用来进行applet初始化动作,他会在applet一开始被调用一次\n    public void init()\n    {\n        message = \"init\";\n        //通知上层组件重绘该applet\n        repaint();\n    }\n\n    //stop钩子在用户跳转到别的网页时调用\n    public void stop()\n    {\n        message = \"stop\";\n        //通知上层组件重绘该applet\n        repaint();\n    }\n\n    public void paint(Graphics graphics)\n    {\n        graphics.drawString(message, 5, 15);\n    }\n}\n```\n\n# 类图\n\n ![1603594324(https://tongji4m3.oss-cn-beijing.aliyuncs.com/1603594324(1).jpg)](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1603594324(1).jpg)\n\n\n\n# 实现 \n\n## CaffeineBeverageWithHook\n\n```java\npublic abstract class CaffeineBeverageWithHook\n{\n    void prepareRecipe()\n    {\n        boilWater();\n        brew();\n        pourInCup();\n        //钩子方法改变的行为\n        if(customerWantsCondiments())\n        {\n            addCondiments();\n        }\n    }\n\n    abstract void brew();\n\n    abstract void addCondiments();\n\n    void boilWater()\n    {\n        System.out.println(\"boilWater\");\n    }\n\n    void pourInCup()\n    {\n        System.out.println(\"pourInCup\");\n    }\n\n    //一个钩子方法,子类可以通过他改变模板的行为\n    boolean customerWantsCondiments()\n    {\n        return true;\n    }\n}\n```\n\n## CoffeeWithHook\n\n```java\npackage TemplatePattern;\n\npublic class CoffeeWithHook extends CaffeineBeverageWithHook\n{\n    @Override\n    void brew()\n    {\n        System.out.println(\"CoffeeWithHook brew\");\n    }\n\n    @Override\n    void addCondiments()\n    {\n        System.out.println(\"CoffeeWithHook addCondiments\");\n    }\n\n    @Override\n    boolean customerWantsCondiments()\n    {\n        //这里可以用一些逻辑来控制该钩子,此处省略\n        return true;\n    }\n}\n```\n\n## MainTest\n\n```java\npackage TemplatePattern;\n\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        CoffeeWithHook coffeeWithHook = new CoffeeWithHook();\n        coffeeWithHook.prepareRecipe();\n        //boilWater\n        //CoffeeWithHook brew\n        //pourInCup\n        //CoffeeWithHook addCondiments\n    }\n}\n```","source":"_posts/设计模式笔记/模板方法模式/模板方法模式.md","raw":"---\ntitle: 设计模式--模板方法模式\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了模板方法模式的原则,类图,代码实现。'\ncategories: 设计模式笔记\ntags:\n  - 设计模式\n  - Java\n  - UML\nabbrlink: 3c67b570\ndate: 2020-10-13 00:00:00\n---\n\n# 模板方法模式\n## 模板方法模式定义\n\n模板方法模式在一个方法中定义一个算法的骨架,而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。\n\n## 细节\n\n+ 模板就是一个方法，将算法定义成一组步骤，其中任何步骤都可以是抽象的，由子类负责实现。这可以确保算法的结构保持不变，同时由子类提供部分实现。\n+ 钩子是一种被声明在抽象类中的方法，只有空或者默认的实现，他可以让子类有能力对算法的不同点进行挂钩。如果算法的某部分是可选的，就用钩子\n+ 与策略模式的区别是策略模式组合的类中实现了整个算法，而模板方法模式可能只实现了算法中的部分步骤。\n+ 为了防止子类改变模板方法中的算法，可以将模板方法声明为final\n\n\n## 设计原则\n\n+ 好莱坞原则：别调用我们，我们会调用你。即低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。例如模板方法中`CaffeineBeverageWithHook`为高层组件，只有在需要子类实现某个方法时，才调用子类。\n\n## 用途\n\n+ Java排序，需要实现`Comparable接口`，实现`compareTo()`方法进行两个元素大小的比较。\n+ Swing窗口中，通过继承`JFrame`，再覆盖父类中不做事的`paint()`方法来在窗口绘制。\n+ Applet是能在网页上运行的小程序，它提供了很多个钩子方法。通过继承`Applet`，再覆盖他的几个接口可以方便进行开发,例如：\n\n```java\npublic class MyApplet extends Applet\n{\n    private String message;\n\n    //init钩子用来进行applet初始化动作,他会在applet一开始被调用一次\n    public void init()\n    {\n        message = \"init\";\n        //通知上层组件重绘该applet\n        repaint();\n    }\n\n    //stop钩子在用户跳转到别的网页时调用\n    public void stop()\n    {\n        message = \"stop\";\n        //通知上层组件重绘该applet\n        repaint();\n    }\n\n    public void paint(Graphics graphics)\n    {\n        graphics.drawString(message, 5, 15);\n    }\n}\n```\n\n# 类图\n\n ![1603594324(https://tongji4m3.oss-cn-beijing.aliyuncs.com/1603594324(1).jpg)](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1603594324(1).jpg)\n\n\n\n# 实现 \n\n## CaffeineBeverageWithHook\n\n```java\npublic abstract class CaffeineBeverageWithHook\n{\n    void prepareRecipe()\n    {\n        boilWater();\n        brew();\n        pourInCup();\n        //钩子方法改变的行为\n        if(customerWantsCondiments())\n        {\n            addCondiments();\n        }\n    }\n\n    abstract void brew();\n\n    abstract void addCondiments();\n\n    void boilWater()\n    {\n        System.out.println(\"boilWater\");\n    }\n\n    void pourInCup()\n    {\n        System.out.println(\"pourInCup\");\n    }\n\n    //一个钩子方法,子类可以通过他改变模板的行为\n    boolean customerWantsCondiments()\n    {\n        return true;\n    }\n}\n```\n\n## CoffeeWithHook\n\n```java\npackage TemplatePattern;\n\npublic class CoffeeWithHook extends CaffeineBeverageWithHook\n{\n    @Override\n    void brew()\n    {\n        System.out.println(\"CoffeeWithHook brew\");\n    }\n\n    @Override\n    void addCondiments()\n    {\n        System.out.println(\"CoffeeWithHook addCondiments\");\n    }\n\n    @Override\n    boolean customerWantsCondiments()\n    {\n        //这里可以用一些逻辑来控制该钩子,此处省略\n        return true;\n    }\n}\n```\n\n## MainTest\n\n```java\npackage TemplatePattern;\n\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        CoffeeWithHook coffeeWithHook = new CoffeeWithHook();\n        coffeeWithHook.prepareRecipe();\n        //boilWater\n        //CoffeeWithHook brew\n        //pourInCup\n        //CoffeeWithHook addCondiments\n    }\n}\n```","slug":"设计模式笔记/模板方法模式/模板方法模式","published":1,"updated":"2020-11-12T11:57:30.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73f00nfjotp460o4440","content":"<h1 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h1><h2 id=\"模板方法模式定义\"><a href=\"#模板方法模式定义\" class=\"headerlink\" title=\"模板方法模式定义\"></a>模板方法模式定义</h2><p>模板方法模式在一个方法中定义一个算法的骨架,而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ul>\n<li>模板就是一个方法，将算法定义成一组步骤，其中任何步骤都可以是抽象的，由子类负责实现。这可以确保算法的结构保持不变，同时由子类提供部分实现。</li>\n<li>钩子是一种被声明在抽象类中的方法，只有空或者默认的实现，他可以让子类有能力对算法的不同点进行挂钩。如果算法的某部分是可选的，就用钩子</li>\n<li>与策略模式的区别是策略模式组合的类中实现了整个算法，而模板方法模式可能只实现了算法中的部分步骤。</li>\n<li>为了防止子类改变模板方法中的算法，可以将模板方法声明为final</li>\n</ul>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><ul>\n<li>好莱坞原则：别调用我们，我们会调用你。即低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。例如模板方法中<code>CaffeineBeverageWithHook</code>为高层组件，只有在需要子类实现某个方法时，才调用子类。</li>\n</ul>\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><ul>\n<li>Java排序，需要实现<code>Comparable接口</code>，实现<code>compareTo()</code>方法进行两个元素大小的比较。</li>\n<li>Swing窗口中，通过继承<code>JFrame</code>，再覆盖父类中不做事的<code>paint()</code>方法来在窗口绘制。</li>\n<li>Applet是能在网页上运行的小程序，它提供了很多个钩子方法。通过继承<code>Applet</code>，再覆盖他的几个接口可以方便进行开发,例如：</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyApplet</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Applet</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> String message<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//init钩子用来进行applet初始化动作,他会在applet一开始被调用一次</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        message <span class=\"token operator\">=</span> <span class=\"token string\">\"init\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//通知上层组件重绘该applet</span>\n        <span class=\"token function\">repaint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//stop钩子在用户跳转到别的网页时调用</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        message <span class=\"token operator\">=</span> <span class=\"token string\">\"stop\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//通知上层组件重绘该applet</span>\n        <span class=\"token function\">repaint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">paint</span><span class=\"token punctuation\">(</span>Graphics graphics<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        graphics<span class=\"token punctuation\">.</span><span class=\"token function\">drawString</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">15</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h1><p> <img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1603594324(1).jpg\" alt=\"1603594324(https://tongji4m3.oss-cn-beijing.aliyuncs.com/1603594324(1).jpg)\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"CaffeineBeverageWithHook\"><a href=\"#CaffeineBeverageWithHook\" class=\"headerlink\" title=\"CaffeineBeverageWithHook\"></a>CaffeineBeverageWithHook</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CaffeineBeverageWithHook</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">prepareRecipe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">boilWater</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">brew</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">pourInCup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//钩子方法改变的行为</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">customerWantsCondiments</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">addCondiments</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">brew</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addCondiments</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">boilWater</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"boilWater\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">pourInCup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pourInCup\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//一个钩子方法,子类可以通过他改变模板的行为</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">customerWantsCondiments</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"CoffeeWithHook\"><a href=\"#CoffeeWithHook\" class=\"headerlink\" title=\"CoffeeWithHook\"></a>CoffeeWithHook</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> TemplatePattern<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CoffeeWithHook</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">CaffeineBeverageWithHook</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">brew</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"CoffeeWithHook brew\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">addCondiments</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"CoffeeWithHook addCondiments\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">customerWantsCondiments</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//这里可以用一些逻辑来控制该钩子,此处省略</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> TemplatePattern<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        CoffeeWithHook coffeeWithHook <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CoffeeWithHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        coffeeWithHook<span class=\"token punctuation\">.</span><span class=\"token function\">prepareRecipe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//boilWater</span>\n        <span class=\"token comment\" spellcheck=\"true\">//CoffeeWithHook brew</span>\n        <span class=\"token comment\" spellcheck=\"true\">//pourInCup</span>\n        <span class=\"token comment\" spellcheck=\"true\">//CoffeeWithHook addCondiments</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h1><h2 id=\"模板方法模式定义\"><a href=\"#模板方法模式定义\" class=\"headerlink\" title=\"模板方法模式定义\"></a>模板方法模式定义</h2><p>模板方法模式在一个方法中定义一个算法的骨架,而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ul>\n<li>模板就是一个方法，将算法定义成一组步骤，其中任何步骤都可以是抽象的，由子类负责实现。这可以确保算法的结构保持不变，同时由子类提供部分实现。</li>\n<li>钩子是一种被声明在抽象类中的方法，只有空或者默认的实现，他可以让子类有能力对算法的不同点进行挂钩。如果算法的某部分是可选的，就用钩子</li>\n<li>与策略模式的区别是策略模式组合的类中实现了整个算法，而模板方法模式可能只实现了算法中的部分步骤。</li>\n<li>为了防止子类改变模板方法中的算法，可以将模板方法声明为final</li>\n</ul>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><ul>\n<li>好莱坞原则：别调用我们，我们会调用你。即低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。例如模板方法中<code>CaffeineBeverageWithHook</code>为高层组件，只有在需要子类实现某个方法时，才调用子类。</li>\n</ul>\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><ul>\n<li>Java排序，需要实现<code>Comparable接口</code>，实现<code>compareTo()</code>方法进行两个元素大小的比较。</li>\n<li>Swing窗口中，通过继承<code>JFrame</code>，再覆盖父类中不做事的<code>paint()</code>方法来在窗口绘制。</li>\n<li>Applet是能在网页上运行的小程序，它提供了很多个钩子方法。通过继承<code>Applet</code>，再覆盖他的几个接口可以方便进行开发,例如：</li>\n</ul>\n<pre><code class=\"java\">public class MyApplet extends Applet\n{\n    private String message;\n\n    //init钩子用来进行applet初始化动作,他会在applet一开始被调用一次\n    public void init()\n    {\n        message = &quot;init&quot;;\n        //通知上层组件重绘该applet\n        repaint();\n    }\n\n    //stop钩子在用户跳转到别的网页时调用\n    public void stop()\n    {\n        message = &quot;stop&quot;;\n        //通知上层组件重绘该applet\n        repaint();\n    }\n\n    public void paint(Graphics graphics)\n    {\n        graphics.drawString(message, 5, 15);\n    }\n}</code></pre>\n<h1 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h1><p> <img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1603594324(1).jpg\" alt=\"1603594324(https://tongji4m3.oss-cn-beijing.aliyuncs.com/1603594324(1).jpg)\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"CaffeineBeverageWithHook\"><a href=\"#CaffeineBeverageWithHook\" class=\"headerlink\" title=\"CaffeineBeverageWithHook\"></a>CaffeineBeverageWithHook</h2><pre><code class=\"java\">public abstract class CaffeineBeverageWithHook\n{\n    void prepareRecipe()\n    {\n        boilWater();\n        brew();\n        pourInCup();\n        //钩子方法改变的行为\n        if(customerWantsCondiments())\n        {\n            addCondiments();\n        }\n    }\n\n    abstract void brew();\n\n    abstract void addCondiments();\n\n    void boilWater()\n    {\n        System.out.println(&quot;boilWater&quot;);\n    }\n\n    void pourInCup()\n    {\n        System.out.println(&quot;pourInCup&quot;);\n    }\n\n    //一个钩子方法,子类可以通过他改变模板的行为\n    boolean customerWantsCondiments()\n    {\n        return true;\n    }\n}</code></pre>\n<h2 id=\"CoffeeWithHook\"><a href=\"#CoffeeWithHook\" class=\"headerlink\" title=\"CoffeeWithHook\"></a>CoffeeWithHook</h2><pre><code class=\"java\">package TemplatePattern;\n\npublic class CoffeeWithHook extends CaffeineBeverageWithHook\n{\n    @Override\n    void brew()\n    {\n        System.out.println(&quot;CoffeeWithHook brew&quot;);\n    }\n\n    @Override\n    void addCondiments()\n    {\n        System.out.println(&quot;CoffeeWithHook addCondiments&quot;);\n    }\n\n    @Override\n    boolean customerWantsCondiments()\n    {\n        //这里可以用一些逻辑来控制该钩子,此处省略\n        return true;\n    }\n}</code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre><code class=\"java\">package TemplatePattern;\n\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        CoffeeWithHook coffeeWithHook = new CoffeeWithHook();\n        coffeeWithHook.prepareRecipe();\n        //boilWater\n        //CoffeeWithHook brew\n        //pourInCup\n        //CoffeeWithHook addCondiments\n    }\n}</code></pre>\n"},{"title":"设计模式--单件模式","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Head Frist 设计模式》所做的笔记,主要介绍了单件模式的原则,类图,代码实现。","abbrlink":"ec339b68","date":"2020-10-03T16:00:00.000Z","_content":"\n# 单件模式\n\n## 作用\n\n+ 可用于线程池,缓存,日志对象等只能有一个实例的地方\n+ 单件模式可以确保只有一个实例被创建\n+ 利用单件模式,我们可以确保只有**在需要的时候**才会创建对象\n\n## 定义\n\n单件模式确保一个类只有一个实例,并提供一个全局访问点\n\n\n\n# 实现\n\n## 第一版\n\n+ 实现了延迟初始化\n+ 多线程不安全\n\n```java\npublic class Singleton\n{\n    private static Singleton uniqueInstance;\n\n    private Singleton()\n    {\n\n    }\n\n    public static Singleton getInstance()\n    {\n        if(uniqueInstance==null)\n        {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n}\n```\n\n## 第二版\n\n+ 保证了线程安全\n+ 效率低下,只有第一次执行此方法才需要同步。一旦设置好了`uniqueInstance`变量，就不需要同步该方法了，`synchronized`就变成了累赘\n\n```java\npublic class Singleton\n{\n    private static Singleton uniqueInstance;\n\n    private Singleton()\n    {\n\n    }\n\n    public static synchronized Singleton getInstance()\n    {\n        if(uniqueInstance==null)\n        {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n}\n```\n\n## 第三版\n\n+ 饿汉式\n\n+ `JVM`在加载这个类时马上创建此唯一的单价实例\n\n```java\npublic class Singleton\n{\n    private static Singleton uniqueInstance = new Singleton();\n\n    private Singleton()\n    {\n\n    }\n\n    public static Singleton getInstance()\n    {\n    \treturn uniqueInstance;\n    }\n}\t\n```\n\n## 第四版\n+ 双重检查加锁\n+ 在`getInstance()`中减少使用同步，只有第一次会同步\n\n```java\npublic class Singleton\n{\n    //保证线程的可见性\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton()\n    {\n\n    }\n\n    public static Singleton getInstance()\n    {\n        if(uniqueInstance==null)\n        {\n            //估计只有几个线程会进到这里\n            synchronized (Singleton.class)\n            {\n                //这些线程逐个进来,但是只有第一个线程会进入到下面的if\n                //其他的线程进来时,已经初始化完毕了,就不好初始化多个实例\n                if(uniqueInstance==null)\n                {\n                    //第一个线程进来,初始化\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n```\n\n","source":"_posts/设计模式笔记/单件模式/单件模式.md","raw":"---\ntitle: 设计模式--单件模式\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了单件模式的原则,类图,代码实现。'\ncategories: 设计模式笔记\ntags:\n  - 设计模式\n  - Java\n  - UML\nabbrlink: ec339b68\ndate: 2020-10-04 00:00:00\n---\n\n# 单件模式\n\n## 作用\n\n+ 可用于线程池,缓存,日志对象等只能有一个实例的地方\n+ 单件模式可以确保只有一个实例被创建\n+ 利用单件模式,我们可以确保只有**在需要的时候**才会创建对象\n\n## 定义\n\n单件模式确保一个类只有一个实例,并提供一个全局访问点\n\n\n\n# 实现\n\n## 第一版\n\n+ 实现了延迟初始化\n+ 多线程不安全\n\n```java\npublic class Singleton\n{\n    private static Singleton uniqueInstance;\n\n    private Singleton()\n    {\n\n    }\n\n    public static Singleton getInstance()\n    {\n        if(uniqueInstance==null)\n        {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n}\n```\n\n## 第二版\n\n+ 保证了线程安全\n+ 效率低下,只有第一次执行此方法才需要同步。一旦设置好了`uniqueInstance`变量，就不需要同步该方法了，`synchronized`就变成了累赘\n\n```java\npublic class Singleton\n{\n    private static Singleton uniqueInstance;\n\n    private Singleton()\n    {\n\n    }\n\n    public static synchronized Singleton getInstance()\n    {\n        if(uniqueInstance==null)\n        {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n}\n```\n\n## 第三版\n\n+ 饿汉式\n\n+ `JVM`在加载这个类时马上创建此唯一的单价实例\n\n```java\npublic class Singleton\n{\n    private static Singleton uniqueInstance = new Singleton();\n\n    private Singleton()\n    {\n\n    }\n\n    public static Singleton getInstance()\n    {\n    \treturn uniqueInstance;\n    }\n}\t\n```\n\n## 第四版\n+ 双重检查加锁\n+ 在`getInstance()`中减少使用同步，只有第一次会同步\n\n```java\npublic class Singleton\n{\n    //保证线程的可见性\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton()\n    {\n\n    }\n\n    public static Singleton getInstance()\n    {\n        if(uniqueInstance==null)\n        {\n            //估计只有几个线程会进到这里\n            synchronized (Singleton.class)\n            {\n                //这些线程逐个进来,但是只有第一个线程会进入到下面的if\n                //其他的线程进来时,已经初始化完毕了,就不好初始化多个实例\n                if(uniqueInstance==null)\n                {\n                    //第一个线程进来,初始化\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n```\n\n","slug":"设计模式笔记/单件模式/单件模式","published":1,"updated":"2020-11-12T11:57:30.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73g00nijotp6rk52xms","content":"<h1 id=\"单件模式\"><a href=\"#单件模式\" class=\"headerlink\" title=\"单件模式\"></a>单件模式</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><ul>\n<li>可用于线程池,缓存,日志对象等只能有一个实例的地方</li>\n<li>单件模式可以确保只有一个实例被创建</li>\n<li>利用单件模式,我们可以确保只有<strong>在需要的时候</strong>才会创建对象</li>\n</ul>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>单件模式确保一个类只有一个实例,并提供一个全局访问点</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"第一版\"><a href=\"#第一版\" class=\"headerlink\" title=\"第一版\"></a>第一版</h2><ul>\n<li>实现了延迟初始化</li>\n<li>多线程不安全</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Singleton uniqueInstance<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>uniqueInstance<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            uniqueInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> uniqueInstance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"第二版\"><a href=\"#第二版\" class=\"headerlink\" title=\"第二版\"></a>第二版</h2><ul>\n<li>保证了线程安全</li>\n<li>效率低下,只有第一次执行此方法才需要同步。一旦设置好了<code>uniqueInstance</code>变量，就不需要同步该方法了，<code>synchronized</code>就变成了累赘</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Singleton uniqueInstance<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>uniqueInstance<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            uniqueInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> uniqueInstance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"第三版\"><a href=\"#第三版\" class=\"headerlink\" title=\"第三版\"></a>第三版</h2><ul>\n<li><p>饿汉式</p>\n</li>\n<li><p><code>JVM</code>在加载这个类时马上创建此唯一的单价实例</p>\n</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Singleton uniqueInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> uniqueInstance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>    </code></pre>\n<h2 id=\"第四版\"><a href=\"#第四版\" class=\"headerlink\" title=\"第四版\"></a>第四版</h2><ul>\n<li>双重检查加锁</li>\n<li>在<code>getInstance()</code>中减少使用同步，只有第一次会同步</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//保证线程的可见性</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">static</span> Singleton uniqueInstance<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>uniqueInstance<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//估计只有几个线程会进到这里</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>Singleton<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//这些线程逐个进来,但是只有第一个线程会进入到下面的if</span>\n                <span class=\"token comment\" spellcheck=\"true\">//其他的线程进来时,已经初始化完毕了,就不好初始化多个实例</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>uniqueInstance<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//第一个线程进来,初始化</span>\n                    uniqueInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> uniqueInstance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"单件模式\"><a href=\"#单件模式\" class=\"headerlink\" title=\"单件模式\"></a>单件模式</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><ul>\n<li>可用于线程池,缓存,日志对象等只能有一个实例的地方</li>\n<li>单件模式可以确保只有一个实例被创建</li>\n<li>利用单件模式,我们可以确保只有<strong>在需要的时候</strong>才会创建对象</li>\n</ul>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>单件模式确保一个类只有一个实例,并提供一个全局访问点</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"第一版\"><a href=\"#第一版\" class=\"headerlink\" title=\"第一版\"></a>第一版</h2><ul>\n<li>实现了延迟初始化</li>\n<li>多线程不安全</li>\n</ul>\n<pre><code class=\"java\">public class Singleton\n{\n    private static Singleton uniqueInstance;\n\n    private Singleton()\n    {\n\n    }\n\n    public static Singleton getInstance()\n    {\n        if(uniqueInstance==null)\n        {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n}</code></pre>\n<h2 id=\"第二版\"><a href=\"#第二版\" class=\"headerlink\" title=\"第二版\"></a>第二版</h2><ul>\n<li>保证了线程安全</li>\n<li>效率低下,只有第一次执行此方法才需要同步。一旦设置好了<code>uniqueInstance</code>变量，就不需要同步该方法了，<code>synchronized</code>就变成了累赘</li>\n</ul>\n<pre><code class=\"java\">public class Singleton\n{\n    private static Singleton uniqueInstance;\n\n    private Singleton()\n    {\n\n    }\n\n    public static synchronized Singleton getInstance()\n    {\n        if(uniqueInstance==null)\n        {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n}</code></pre>\n<h2 id=\"第三版\"><a href=\"#第三版\" class=\"headerlink\" title=\"第三版\"></a>第三版</h2><ul>\n<li><p>饿汉式</p>\n</li>\n<li><p><code>JVM</code>在加载这个类时马上创建此唯一的单价实例</p>\n</li>\n</ul>\n<pre><code class=\"java\">public class Singleton\n{\n    private static Singleton uniqueInstance = new Singleton();\n\n    private Singleton()\n    {\n\n    }\n\n    public static Singleton getInstance()\n    {\n        return uniqueInstance;\n    }\n}    </code></pre>\n<h2 id=\"第四版\"><a href=\"#第四版\" class=\"headerlink\" title=\"第四版\"></a>第四版</h2><ul>\n<li>双重检查加锁</li>\n<li>在<code>getInstance()</code>中减少使用同步，只有第一次会同步</li>\n</ul>\n<pre><code class=\"java\">public class Singleton\n{\n    //保证线程的可见性\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton()\n    {\n\n    }\n\n    public static Singleton getInstance()\n    {\n        if(uniqueInstance==null)\n        {\n            //估计只有几个线程会进到这里\n            synchronized (Singleton.class)\n            {\n                //这些线程逐个进来,但是只有第一个线程会进入到下面的if\n                //其他的线程进来时,已经初始化完毕了,就不好初始化多个实例\n                if(uniqueInstance==null)\n                {\n                    //第一个线程进来,初始化\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}</code></pre>\n"},{"title":"设计模式--抽象工厂模式","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Head Frist 设计模式》所做的笔记,主要介绍了抽象工厂模式的原则,类图,代码实现。","abbrlink":"4bdc9a59","date":"2020-09-28T16:00:00.000Z","_content":"# 抽象工厂模式\n## 定义\n\n抽象工厂模式提供一个接口,用于创建相关或依赖对象的家族,而不需要明确指定具体类。\n\n## 细节\n\n1. 工厂方法模式使用继承,抽象工厂模式使用组合\n2. 依赖抽象,不要依赖具体类\n3. 对象的创建被实现再工厂接口所暴露出来的方法中\n\n## 类图\n\n![image-20201001163131160](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201001162740771.png)\n\n# 实现\n\n## Dough\n\n```java\npublic interface Dough\n{\n}\n```\n\n```java\npublic class ThickCrustDough implements Dough\n{\n}\n```\n\n```java\npublic class ThinCrustDough implements Dough\n{\n}\n```\n\n## Sauce\n\n```java\npublic interface Sauce\n{\n}\n```\n\n```java\npublic class PlumTomatoSauce implements Sauce\n{\n}\n```\n\n```java\npublic class MarinaraSauce implements Sauce\n{\n}\n```\n\n## factory\n\n```java\npublic interface PizzaIngredientFactory\n{\n    Dough createDough();\n\n    Sauce createSauce();\n}\n```\n\n```java\npublic class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory\n{\n    @Override\n    public Dough createDough()\n    {\n        return new ThickCrustDough();\n    }\n\n    @Override\n    public Sauce createSauce()\n    {\n        return new PlumTomatoSauce();\n    }\n}\n```\n\n```java\npublic class NYPizzaIngredientFactory implements PizzaIngredientFactory\n{\n    @Override\n    public Dough createDough()\n    {\n        return new ThickCrustDough();\n    }\n\n    @Override\n    public Sauce createSauce()\n    {\n        return new MarinaraSauce();\n    }\n}\n```\n\n## Pizza\n\n```java\npublic abstract class Pizza\n{\n    String name;\n    Dough dough;\n    Sauce sauce;\n   \n\n    abstract void prepare();\n\n\n    public void bake()\n    {\n        System.out.println(\"bake\");\n    }\n\n    public void cut()\n    {\n        System.out.println(\"cut\");\n    }\n\n    public void box()\n    {\n        System.out.println(\"box\");\n    }\n\n    public String getName()\n    {\n        return name;\n    }\n\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n}\n```\n\n```java\npublic class CheesePizza extends Pizza\n{\n    PizzaIngredientFactory ingredientFactory;\n\n    public CheesePizza(PizzaIngredientFactory ingredientFactory)\n    {\n        this.ingredientFactory = ingredientFactory;\n    }\n\n    @Override\n    void prepare()\n    {\n        System.out.println(\"Prepare---\"+name);\n        dough = ingredientFactory.createDough();\n        sauce = ingredientFactory.createSauce();\n    }\n}\n```\n\n## store\n\n```java\npublic abstract class PizzaStore\n{\n    public Pizza orderPizza(String type)\n    {\n        Pizza pizza;\n        pizza = createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    protected abstract Pizza createPizza(String type);\n}\n```\n\n```java\npublic class NYPizzaStore extends PizzaStore\n{\n    @Override\n    protected Pizza createPizza(String type)\n    {\n        Pizza pizza = null;\n        PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory();\n        pizza = new CheesePizza(ingredientFactory);\n        return pizza;\n    }\n}\n```\n\n## MainTest\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        PizzaStore nyPizzaStore = new NYPizzaStore();\n        nyPizzaStore.orderPizza(\"cheese\");\n    }\n}\n```","source":"_posts/设计模式笔记/工厂模式/抽象工厂模式.md","raw":"---\ntitle: 设计模式--抽象工厂模式\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了抽象工厂模式的原则,类图,代码实现。'\ncategories: 设计模式笔记\ntags:\n  - 设计模式\n  - Java\n  - UML\nabbrlink: 4bdc9a59\ndate: 2020-09-29 00:00:00\n---\n# 抽象工厂模式\n## 定义\n\n抽象工厂模式提供一个接口,用于创建相关或依赖对象的家族,而不需要明确指定具体类。\n\n## 细节\n\n1. 工厂方法模式使用继承,抽象工厂模式使用组合\n2. 依赖抽象,不要依赖具体类\n3. 对象的创建被实现再工厂接口所暴露出来的方法中\n\n## 类图\n\n![image-20201001163131160](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201001162740771.png)\n\n# 实现\n\n## Dough\n\n```java\npublic interface Dough\n{\n}\n```\n\n```java\npublic class ThickCrustDough implements Dough\n{\n}\n```\n\n```java\npublic class ThinCrustDough implements Dough\n{\n}\n```\n\n## Sauce\n\n```java\npublic interface Sauce\n{\n}\n```\n\n```java\npublic class PlumTomatoSauce implements Sauce\n{\n}\n```\n\n```java\npublic class MarinaraSauce implements Sauce\n{\n}\n```\n\n## factory\n\n```java\npublic interface PizzaIngredientFactory\n{\n    Dough createDough();\n\n    Sauce createSauce();\n}\n```\n\n```java\npublic class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory\n{\n    @Override\n    public Dough createDough()\n    {\n        return new ThickCrustDough();\n    }\n\n    @Override\n    public Sauce createSauce()\n    {\n        return new PlumTomatoSauce();\n    }\n}\n```\n\n```java\npublic class NYPizzaIngredientFactory implements PizzaIngredientFactory\n{\n    @Override\n    public Dough createDough()\n    {\n        return new ThickCrustDough();\n    }\n\n    @Override\n    public Sauce createSauce()\n    {\n        return new MarinaraSauce();\n    }\n}\n```\n\n## Pizza\n\n```java\npublic abstract class Pizza\n{\n    String name;\n    Dough dough;\n    Sauce sauce;\n   \n\n    abstract void prepare();\n\n\n    public void bake()\n    {\n        System.out.println(\"bake\");\n    }\n\n    public void cut()\n    {\n        System.out.println(\"cut\");\n    }\n\n    public void box()\n    {\n        System.out.println(\"box\");\n    }\n\n    public String getName()\n    {\n        return name;\n    }\n\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n}\n```\n\n```java\npublic class CheesePizza extends Pizza\n{\n    PizzaIngredientFactory ingredientFactory;\n\n    public CheesePizza(PizzaIngredientFactory ingredientFactory)\n    {\n        this.ingredientFactory = ingredientFactory;\n    }\n\n    @Override\n    void prepare()\n    {\n        System.out.println(\"Prepare---\"+name);\n        dough = ingredientFactory.createDough();\n        sauce = ingredientFactory.createSauce();\n    }\n}\n```\n\n## store\n\n```java\npublic abstract class PizzaStore\n{\n    public Pizza orderPizza(String type)\n    {\n        Pizza pizza;\n        pizza = createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    protected abstract Pizza createPizza(String type);\n}\n```\n\n```java\npublic class NYPizzaStore extends PizzaStore\n{\n    @Override\n    protected Pizza createPizza(String type)\n    {\n        Pizza pizza = null;\n        PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory();\n        pizza = new CheesePizza(ingredientFactory);\n        return pizza;\n    }\n}\n```\n\n## MainTest\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        PizzaStore nyPizzaStore = new NYPizzaStore();\n        nyPizzaStore.orderPizza(\"cheese\");\n    }\n}\n```","slug":"设计模式笔记/工厂模式/抽象工厂模式","published":1,"updated":"2020-11-12T11:57:30.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73h00nmjotp7cpwger0","content":"<h1 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>抽象工厂模式提供一个接口,用于创建相关或依赖对象的家族,而不需要明确指定具体类。</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ol>\n<li>工厂方法模式使用继承,抽象工厂模式使用组合</li>\n<li>依赖抽象,不要依赖具体类</li>\n<li>对象的创建被实现再工厂接口所暴露出来的方法中</li>\n</ol>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201001162740771.png\" alt=\"image-20201001163131160\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"Dough\"><a href=\"#Dough\" class=\"headerlink\" title=\"Dough\"></a>Dough</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Dough</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThickCrustDough</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Dough</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThinCrustDough</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Dough</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"Sauce\"><a href=\"#Sauce\" class=\"headerlink\" title=\"Sauce\"></a>Sauce</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Sauce</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PlumTomatoSauce</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Sauce</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MarinaraSauce</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Sauce</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"factory\"><a href=\"#factory\" class=\"headerlink\" title=\"factory\"></a>factory</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">PizzaIngredientFactory</span>\n<span class=\"token punctuation\">{</span>\n    Dough <span class=\"token function\">createDough</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    Sauce <span class=\"token function\">createSauce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ChicagoPizzaIngredientFactory</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">PizzaIngredientFactory</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Dough <span class=\"token function\">createDough</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThickCrustDough</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Sauce <span class=\"token function\">createSauce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PlumTomatoSauce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NYPizzaIngredientFactory</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">PizzaIngredientFactory</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Dough <span class=\"token function\">createDough</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThickCrustDough</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Sauce <span class=\"token function\">createSauce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MarinaraSauce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"Pizza\"><a href=\"#Pizza\" class=\"headerlink\" title=\"Pizza\"></a>Pizza</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Pizza</span>\n<span class=\"token punctuation\">{</span>\n    String name<span class=\"token punctuation\">;</span>\n    Dough dough<span class=\"token punctuation\">;</span>\n    Sauce sauce<span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">prepare</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">bake</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bake\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">cut</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cut\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">box</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"box\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span>String name<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CheesePizza</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Pizza</span>\n<span class=\"token punctuation\">{</span>\n    PizzaIngredientFactory ingredientFactory<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">CheesePizza</span><span class=\"token punctuation\">(</span>PizzaIngredientFactory ingredientFactory<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ingredientFactory <span class=\"token operator\">=</span> ingredientFactory<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">prepare</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Prepare---\"</span><span class=\"token operator\">+</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        dough <span class=\"token operator\">=</span> ingredientFactory<span class=\"token punctuation\">.</span><span class=\"token function\">createDough</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sauce <span class=\"token operator\">=</span> ingredientFactory<span class=\"token punctuation\">.</span><span class=\"token function\">createSauce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"store\"></a>store</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PizzaStore</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> Pizza <span class=\"token function\">orderPizza</span><span class=\"token punctuation\">(</span>String type<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Pizza pizza<span class=\"token punctuation\">;</span>\n        pizza <span class=\"token operator\">=</span> <span class=\"token function\">createPizza</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        pizza<span class=\"token punctuation\">.</span><span class=\"token function\">prepare</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        pizza<span class=\"token punctuation\">.</span><span class=\"token function\">bake</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        pizza<span class=\"token punctuation\">.</span><span class=\"token function\">cut</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        pizza<span class=\"token punctuation\">.</span><span class=\"token function\">box</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> pizza<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> Pizza <span class=\"token function\">createPizza</span><span class=\"token punctuation\">(</span>String type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NYPizzaStore</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">PizzaStore</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> Pizza <span class=\"token function\">createPizza</span><span class=\"token punctuation\">(</span>String type<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Pizza pizza <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        PizzaIngredientFactory ingredientFactory <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NYPizzaIngredientFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        pizza <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CheesePizza</span><span class=\"token punctuation\">(</span>ingredientFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> pizza<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        PizzaStore nyPizzaStore <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NYPizzaStore</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        nyPizzaStore<span class=\"token punctuation\">.</span><span class=\"token function\">orderPizza</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cheese\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>抽象工厂模式提供一个接口,用于创建相关或依赖对象的家族,而不需要明确指定具体类。</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ol>\n<li>工厂方法模式使用继承,抽象工厂模式使用组合</li>\n<li>依赖抽象,不要依赖具体类</li>\n<li>对象的创建被实现再工厂接口所暴露出来的方法中</li>\n</ol>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201001162740771.png\" alt=\"image-20201001163131160\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"Dough\"><a href=\"#Dough\" class=\"headerlink\" title=\"Dough\"></a>Dough</h2><pre><code class=\"java\">public interface Dough\n{\n}</code></pre>\n<pre><code class=\"java\">public class ThickCrustDough implements Dough\n{\n}</code></pre>\n<pre><code class=\"java\">public class ThinCrustDough implements Dough\n{\n}</code></pre>\n<h2 id=\"Sauce\"><a href=\"#Sauce\" class=\"headerlink\" title=\"Sauce\"></a>Sauce</h2><pre><code class=\"java\">public interface Sauce\n{\n}</code></pre>\n<pre><code class=\"java\">public class PlumTomatoSauce implements Sauce\n{\n}</code></pre>\n<pre><code class=\"java\">public class MarinaraSauce implements Sauce\n{\n}</code></pre>\n<h2 id=\"factory\"><a href=\"#factory\" class=\"headerlink\" title=\"factory\"></a>factory</h2><pre><code class=\"java\">public interface PizzaIngredientFactory\n{\n    Dough createDough();\n\n    Sauce createSauce();\n}</code></pre>\n<pre><code class=\"java\">public class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory\n{\n    @Override\n    public Dough createDough()\n    {\n        return new ThickCrustDough();\n    }\n\n    @Override\n    public Sauce createSauce()\n    {\n        return new PlumTomatoSauce();\n    }\n}</code></pre>\n<pre><code class=\"java\">public class NYPizzaIngredientFactory implements PizzaIngredientFactory\n{\n    @Override\n    public Dough createDough()\n    {\n        return new ThickCrustDough();\n    }\n\n    @Override\n    public Sauce createSauce()\n    {\n        return new MarinaraSauce();\n    }\n}</code></pre>\n<h2 id=\"Pizza\"><a href=\"#Pizza\" class=\"headerlink\" title=\"Pizza\"></a>Pizza</h2><pre><code class=\"java\">public abstract class Pizza\n{\n    String name;\n    Dough dough;\n    Sauce sauce;\n\n\n    abstract void prepare();\n\n\n    public void bake()\n    {\n        System.out.println(&quot;bake&quot;);\n    }\n\n    public void cut()\n    {\n        System.out.println(&quot;cut&quot;);\n    }\n\n    public void box()\n    {\n        System.out.println(&quot;box&quot;);\n    }\n\n    public String getName()\n    {\n        return name;\n    }\n\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n}</code></pre>\n<pre><code class=\"java\">public class CheesePizza extends Pizza\n{\n    PizzaIngredientFactory ingredientFactory;\n\n    public CheesePizza(PizzaIngredientFactory ingredientFactory)\n    {\n        this.ingredientFactory = ingredientFactory;\n    }\n\n    @Override\n    void prepare()\n    {\n        System.out.println(&quot;Prepare---&quot;+name);\n        dough = ingredientFactory.createDough();\n        sauce = ingredientFactory.createSauce();\n    }\n}</code></pre>\n<h2 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"store\"></a>store</h2><pre><code class=\"java\">public abstract class PizzaStore\n{\n    public Pizza orderPizza(String type)\n    {\n        Pizza pizza;\n        pizza = createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    protected abstract Pizza createPizza(String type);\n}</code></pre>\n<pre><code class=\"java\">public class NYPizzaStore extends PizzaStore\n{\n    @Override\n    protected Pizza createPizza(String type)\n    {\n        Pizza pizza = null;\n        PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory();\n        pizza = new CheesePizza(ingredientFactory);\n        return pizza;\n    }\n}</code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre><code class=\"java\">public class MainTest\n{\n    public static void main(String[] args)\n    {\n        PizzaStore nyPizzaStore = new NYPizzaStore();\n        nyPizzaStore.orderPizza(&quot;cheese&quot;);\n    }\n}</code></pre>\n"},{"title":"设计模式--装饰者模式","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Head Frist 设计模式》所做的笔记,主要介绍了装饰者模式的原则,类图,代码实现。","abbrlink":"a5c35f1a","date":"2020-09-22T16:00:00.000Z","_content":"\n# 装饰者模式\n## 装饰者模式定义\n\n动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案\n\n## 设计原则\n\n类应该对扩展开放,对修改关闭.\n\n## 细节\n\n1. 利用继承设计子类的行为,是在编译时静态决定的,而且所有子类都会继承到相同的行为.如果利用组合扩展对象的行为,就能在运行时动态地进行扩展.\n2. 装饰者和被装饰者有相同的超类型\n3. 可以用一个或多个装饰者包装一个对象\n4. 在任何需要原始对象的地方,都可以用装饰过的对象代替它\n5. Java.io类就用到了装饰者模式，倒是用来包装InputStream的\n6. 装饰者模式意味着一群装饰者类，用来包装具体的组件\n7. 可以用无数的装饰者包装一个组件\n\n## 类图\n\n![image-20200926170529749](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png)\n\n# 实现\n\n## Beverage\n\n```java\npublic abstract class Beverage\n{\n    protected String description = \"Unknown Beverage\";\n\n    public String getDescription()\n    {\n        return description;\n    }\n\n    public abstract double cost();\n}\n```\n\n## 咖啡组件\n\n```java\npublic class DarkRoast extends Beverage\n{\n    public DarkRoast()\n    {\n        description = \"DarkRoast\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 1.59;\n    }\n}\n```\n\n```java\npublic class Espresso extends Beverage\n{\n    public Espresso()\n    {\n        description = \"Espresso\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 1.99;\n    }\n}\n```\n\n```java\npublic class HouseBlend extends Beverage\n{\n    public HouseBlend()\n    {\n        description = \"HouseBlend\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.99;\n    }\n}\n```\n\n## 装饰者相关组件\n\n```java\n//调料装饰者\npublic abstract class CondimentDecorator extends Beverage\n{\n    //所有调料装饰者必须重新实现该方法\n    public abstract String getDescription();\n}\n```\n\n```java\n//这样得到的是装饰者,即被Milk这个配料装饰后得到的一杯新咖啡\n//它不管之前的咖啡是什么种类,也不管之前之后是否被装饰过\npublic class Milk extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Milk(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+\",Milk\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.50+beverage.cost();\n    }\n}\n```\n\n```java\npublic class Mocha extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Mocha(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+\",Mocha\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.20+beverage.cost();\n    }\n}\n```\n\n```java\npublic class Soy extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Soy(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+\",Soy\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.80+beverage.cost();\n    }\n}\n```\n\n```java\npublic class Whip extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Whip(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+\",Whip\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.10+beverage.cost();\n    }\n}\n```\n\n## MainTest\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        Beverage beverage = new Espresso();\n        System.out.println(beverage.getDescription()+\" $\"+beverage.cost());\n\n        System.out.println(\"---------------------\");\n\n        Beverage beverage1 = new DarkRoast();\n        beverage1 = new Mocha(beverage1);\n        beverage1 = new Mocha(beverage1);\n        beverage1 = new Whip(beverage1);\n        System.out.println(beverage1.getDescription()+\" $\"+beverage1.cost());\n    }\n}\n```","source":"_posts/设计模式笔记/装饰者模式/装饰者模式.md","raw":"---\ntitle: 设计模式--装饰者模式\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了装饰者模式的原则,类图,代码实现。'\ncategories: 设计模式笔记\ntags:\n  - 设计模式\n  - Java\n  - UML\nabbrlink: a5c35f1a\ndate: 2020-09-23 00:00:00\n---\n\n# 装饰者模式\n## 装饰者模式定义\n\n动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案\n\n## 设计原则\n\n类应该对扩展开放,对修改关闭.\n\n## 细节\n\n1. 利用继承设计子类的行为,是在编译时静态决定的,而且所有子类都会继承到相同的行为.如果利用组合扩展对象的行为,就能在运行时动态地进行扩展.\n2. 装饰者和被装饰者有相同的超类型\n3. 可以用一个或多个装饰者包装一个对象\n4. 在任何需要原始对象的地方,都可以用装饰过的对象代替它\n5. Java.io类就用到了装饰者模式，倒是用来包装InputStream的\n6. 装饰者模式意味着一群装饰者类，用来包装具体的组件\n7. 可以用无数的装饰者包装一个组件\n\n## 类图\n\n![image-20200926170529749](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png)\n\n# 实现\n\n## Beverage\n\n```java\npublic abstract class Beverage\n{\n    protected String description = \"Unknown Beverage\";\n\n    public String getDescription()\n    {\n        return description;\n    }\n\n    public abstract double cost();\n}\n```\n\n## 咖啡组件\n\n```java\npublic class DarkRoast extends Beverage\n{\n    public DarkRoast()\n    {\n        description = \"DarkRoast\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 1.59;\n    }\n}\n```\n\n```java\npublic class Espresso extends Beverage\n{\n    public Espresso()\n    {\n        description = \"Espresso\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 1.99;\n    }\n}\n```\n\n```java\npublic class HouseBlend extends Beverage\n{\n    public HouseBlend()\n    {\n        description = \"HouseBlend\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.99;\n    }\n}\n```\n\n## 装饰者相关组件\n\n```java\n//调料装饰者\npublic abstract class CondimentDecorator extends Beverage\n{\n    //所有调料装饰者必须重新实现该方法\n    public abstract String getDescription();\n}\n```\n\n```java\n//这样得到的是装饰者,即被Milk这个配料装饰后得到的一杯新咖啡\n//它不管之前的咖啡是什么种类,也不管之前之后是否被装饰过\npublic class Milk extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Milk(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+\",Milk\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.50+beverage.cost();\n    }\n}\n```\n\n```java\npublic class Mocha extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Mocha(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+\",Mocha\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.20+beverage.cost();\n    }\n}\n```\n\n```java\npublic class Soy extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Soy(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+\",Soy\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.80+beverage.cost();\n    }\n}\n```\n\n```java\npublic class Whip extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Whip(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+\",Whip\";\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.10+beverage.cost();\n    }\n}\n```\n\n## MainTest\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        Beverage beverage = new Espresso();\n        System.out.println(beverage.getDescription()+\" $\"+beverage.cost());\n\n        System.out.println(\"---------------------\");\n\n        Beverage beverage1 = new DarkRoast();\n        beverage1 = new Mocha(beverage1);\n        beverage1 = new Mocha(beverage1);\n        beverage1 = new Whip(beverage1);\n        System.out.println(beverage1.getDescription()+\" $\"+beverage1.cost());\n    }\n}\n```","slug":"设计模式笔记/装饰者模式/装饰者模式","published":1,"updated":"2020-11-12T11:57:30.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73k00npjotpblek9rmi","content":"<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><h2 id=\"装饰者模式定义\"><a href=\"#装饰者模式定义\" class=\"headerlink\" title=\"装饰者模式定义\"></a>装饰者模式定义</h2><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案</p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><p>类应该对扩展开放,对修改关闭.</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ol>\n<li>利用继承设计子类的行为,是在编译时静态决定的,而且所有子类都会继承到相同的行为.如果利用组合扩展对象的行为,就能在运行时动态地进行扩展.</li>\n<li>装饰者和被装饰者有相同的超类型</li>\n<li>可以用一个或多个装饰者包装一个对象</li>\n<li>在任何需要原始对象的地方,都可以用装饰过的对象代替它</li>\n<li>Java.io类就用到了装饰者模式，倒是用来包装InputStream的</li>\n<li>装饰者模式意味着一群装饰者类，用来包装具体的组件</li>\n<li>可以用无数的装饰者包装一个组件</li>\n</ol>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png\" alt=\"image-20200926170529749\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"Beverage\"><a href=\"#Beverage\" class=\"headerlink\" title=\"Beverage\"></a>Beverage</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Beverage</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">protected</span> String description <span class=\"token operator\">=</span> <span class=\"token string\">\"Unknown Beverage\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> description<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">double</span> <span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"咖啡组件\"><a href=\"#咖啡组件\" class=\"headerlink\" title=\"咖啡组件\"></a>咖啡组件</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DarkRoast</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Beverage</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">DarkRoast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        description <span class=\"token operator\">=</span> <span class=\"token string\">\"DarkRoast\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1.59</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Espresso</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Beverage</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Espresso</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        description <span class=\"token operator\">=</span> <span class=\"token string\">\"Espresso\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1.99</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HouseBlend</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Beverage</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">HouseBlend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        description <span class=\"token operator\">=</span> <span class=\"token string\">\"HouseBlend\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0.99</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"装饰者相关组件\"><a href=\"#装饰者相关组件\" class=\"headerlink\" title=\"装饰者相关组件\"></a>装饰者相关组件</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//调料装饰者</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CondimentDecorator</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Beverage</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//所有调料装饰者必须重新实现该方法</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> String <span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//这样得到的是装饰者,即被Milk这个配料装饰后得到的一杯新咖啡</span>\n<span class=\"token comment\" spellcheck=\"true\">//它不管之前的咖啡是什么种类,也不管之前之后是否被装饰过</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Milk</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">CondimentDecorator</span>\n<span class=\"token punctuation\">{</span>\n    Beverage beverage<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Milk</span><span class=\"token punctuation\">(</span>Beverage beverage<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>beverage <span class=\"token operator\">=</span> beverage<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> beverage<span class=\"token punctuation\">.</span><span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\",Milk\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0.50</span><span class=\"token operator\">+</span>beverage<span class=\"token punctuation\">.</span><span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Mocha</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">CondimentDecorator</span>\n<span class=\"token punctuation\">{</span>\n    Beverage beverage<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Mocha</span><span class=\"token punctuation\">(</span>Beverage beverage<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>beverage <span class=\"token operator\">=</span> beverage<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> beverage<span class=\"token punctuation\">.</span><span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\",Mocha\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0.20</span><span class=\"token operator\">+</span>beverage<span class=\"token punctuation\">.</span><span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Soy</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">CondimentDecorator</span>\n<span class=\"token punctuation\">{</span>\n    Beverage beverage<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Soy</span><span class=\"token punctuation\">(</span>Beverage beverage<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>beverage <span class=\"token operator\">=</span> beverage<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> beverage<span class=\"token punctuation\">.</span><span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\",Soy\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0.80</span><span class=\"token operator\">+</span>beverage<span class=\"token punctuation\">.</span><span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Whip</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">CondimentDecorator</span>\n<span class=\"token punctuation\">{</span>\n    Beverage beverage<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Whip</span><span class=\"token punctuation\">(</span>Beverage beverage<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>beverage <span class=\"token operator\">=</span> beverage<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> beverage<span class=\"token punctuation\">.</span><span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\",Whip\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0.10</span><span class=\"token operator\">+</span>beverage<span class=\"token punctuation\">.</span><span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Beverage beverage <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Espresso</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>beverage<span class=\"token punctuation\">.</span><span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" $\"</span><span class=\"token operator\">+</span>beverage<span class=\"token punctuation\">.</span><span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"---------------------\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        Beverage beverage1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DarkRoast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        beverage1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Mocha</span><span class=\"token punctuation\">(</span>beverage1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        beverage1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Mocha</span><span class=\"token punctuation\">(</span>beverage1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        beverage1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Whip</span><span class=\"token punctuation\">(</span>beverage1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>beverage1<span class=\"token punctuation\">.</span><span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" $\"</span><span class=\"token operator\">+</span>beverage1<span class=\"token punctuation\">.</span><span class=\"token function\">cost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><h2 id=\"装饰者模式定义\"><a href=\"#装饰者模式定义\" class=\"headerlink\" title=\"装饰者模式定义\"></a>装饰者模式定义</h2><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案</p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><p>类应该对扩展开放,对修改关闭.</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ol>\n<li>利用继承设计子类的行为,是在编译时静态决定的,而且所有子类都会继承到相同的行为.如果利用组合扩展对象的行为,就能在运行时动态地进行扩展.</li>\n<li>装饰者和被装饰者有相同的超类型</li>\n<li>可以用一个或多个装饰者包装一个对象</li>\n<li>在任何需要原始对象的地方,都可以用装饰过的对象代替它</li>\n<li>Java.io类就用到了装饰者模式，倒是用来包装InputStream的</li>\n<li>装饰者模式意味着一群装饰者类，用来包装具体的组件</li>\n<li>可以用无数的装饰者包装一个组件</li>\n</ol>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png\" alt=\"image-20200926170529749\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"Beverage\"><a href=\"#Beverage\" class=\"headerlink\" title=\"Beverage\"></a>Beverage</h2><pre><code class=\"java\">public abstract class Beverage\n{\n    protected String description = &quot;Unknown Beverage&quot;;\n\n    public String getDescription()\n    {\n        return description;\n    }\n\n    public abstract double cost();\n}</code></pre>\n<h2 id=\"咖啡组件\"><a href=\"#咖啡组件\" class=\"headerlink\" title=\"咖啡组件\"></a>咖啡组件</h2><pre><code class=\"java\">public class DarkRoast extends Beverage\n{\n    public DarkRoast()\n    {\n        description = &quot;DarkRoast&quot;;\n    }\n\n    @Override\n    public double cost()\n    {\n        return 1.59;\n    }\n}</code></pre>\n<pre><code class=\"java\">public class Espresso extends Beverage\n{\n    public Espresso()\n    {\n        description = &quot;Espresso&quot;;\n    }\n\n    @Override\n    public double cost()\n    {\n        return 1.99;\n    }\n}</code></pre>\n<pre><code class=\"java\">public class HouseBlend extends Beverage\n{\n    public HouseBlend()\n    {\n        description = &quot;HouseBlend&quot;;\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.99;\n    }\n}</code></pre>\n<h2 id=\"装饰者相关组件\"><a href=\"#装饰者相关组件\" class=\"headerlink\" title=\"装饰者相关组件\"></a>装饰者相关组件</h2><pre><code class=\"java\">//调料装饰者\npublic abstract class CondimentDecorator extends Beverage\n{\n    //所有调料装饰者必须重新实现该方法\n    public abstract String getDescription();\n}</code></pre>\n<pre><code class=\"java\">//这样得到的是装饰者,即被Milk这个配料装饰后得到的一杯新咖啡\n//它不管之前的咖啡是什么种类,也不管之前之后是否被装饰过\npublic class Milk extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Milk(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+&quot;,Milk&quot;;\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.50+beverage.cost();\n    }\n}</code></pre>\n<pre><code class=\"java\">public class Mocha extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Mocha(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+&quot;,Mocha&quot;;\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.20+beverage.cost();\n    }\n}</code></pre>\n<pre><code class=\"java\">public class Soy extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Soy(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+&quot;,Soy&quot;;\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.80+beverage.cost();\n    }\n}</code></pre>\n<pre><code class=\"java\">public class Whip extends CondimentDecorator\n{\n    Beverage beverage;\n\n    public Whip(Beverage beverage)\n    {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return beverage.getDescription()+&quot;,Whip&quot;;\n    }\n\n    @Override\n    public double cost()\n    {\n        return 0.10+beverage.cost();\n    }\n}</code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre><code class=\"java\">public class MainTest\n{\n    public static void main(String[] args)\n    {\n        Beverage beverage = new Espresso();\n        System.out.println(beverage.getDescription()+&quot; $&quot;+beverage.cost());\n\n        System.out.println(&quot;---------------------&quot;);\n\n        Beverage beverage1 = new DarkRoast();\n        beverage1 = new Mocha(beverage1);\n        beverage1 = new Mocha(beverage1);\n        beverage1 = new Whip(beverage1);\n        System.out.println(beverage1.getDescription()+&quot; $&quot;+beverage1.cost());\n    }\n}</code></pre>\n"},{"title":"设计模式--策略模式","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Head Frist 设计模式》所做的笔记,主要介绍了策略模式的原则,类图,代码实现。","abbrlink":"eee4fbd1","date":"2020-09-14T16:00:00.000Z","_content":"\n# 策略模式\n## 策略模式定义\n定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化**独立**于使用算法的客户。\n\n## 设计原则\n\n1. 找出应用可能需要变化之处,把他们独立出来,不要和那些不需要变化的代码混在一起。封装变化。\n2. 针对接口编程，而不是针对实现编程。\n3. 多用组合，少用继承。\n\n\n## 针对接口编程\n\n利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为。更明确的说是变量的声明类型应该是超类型\n\n\n\n# 类图\n\n用接口代表每个行为，而行为的每个实现都将实现其中一个接口\n\n![image-20200923193518271](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200923193518271.png)\n\n# 实现\n\n## FlyBehavior接口相关\n\n```java\npublic interface FlyBehavior\n{\n    void fly();\n}\n```\n\n```java\npublic class FlyWithWings implements FlyBehavior\n{\n    @Override\n    public void fly()\n    {\n        System.out.println(\"I am flying!\");\n    }\n}\n```\n\n```java\npublic class FlyNoWay implements FlyBehavior\n{\n    @Override\n    public void fly()\n    {\n        System.out.println(\"I can't flying!\");\n    }\n}\n```\n\n```java\npublic class FlyRocketPowered implements FlyBehavior\n{\n    @Override\n    public void fly()\n    {\n        System.out.println(\"I FlyRocketPowered!\");\n    }\n}\n```\n\n## QuackBehavior接口相关\n\n```java\npublic interface QuackBehavior\n{\n    void quack();\n}\n```\n\n```java\npublic class Quack implements QuackBehavior\n{\n    @Override\n    public void quack()\n    {\n        System.out.println(\"Quack\");\n    }\n}\n```\n\n```java\npublic class MuteQuack implements QuackBehavior\n{\n    @Override\n    public void quack()\n    {\n        System.out.println(\"Silence\");\n    }\n}\n```\n\n## Duck相关\n\n```java\npublic class Duck\n{\n    FlyBehavior flyBehavior;\n    QuackBehavior quackBehavior;\n\n    public void setFlyBehavior(FlyBehavior flyBehavior)\n    {\n        this.flyBehavior = flyBehavior;\n    }\n\n    public void setQuackBehavior(QuackBehavior quackBehavior)\n    {\n        this.quackBehavior = quackBehavior;\n    }\n\n    public void performFly()\n    {\n        flyBehavior.fly();\n    }\n\n    public void performQuack()\n    {\n        quackBehavior.quack();\n    }\n\n    public void swim()\n    {\n        System.out.println(\"All ducks float\");\n    }\n\n    public void display()\n    {\n        System.out.println(\"display duck\");\n    }\n}\n```\n\n```java\npublic class ModelDuck extends Duck\n{\n    public ModelDuck()\n    {\n        flyBehavior = new FlyNoWay();\n        quackBehavior = new Quack();\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(\"I am model Duck\");\n    }\n}\n```\n\n## MainTest\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        Duck model = new ModelDuck();\n        model.performFly();\n        model.setFlyBehavior(new FlyRocketPowered());\n        model.performFly();\n        /*\n        输出:\n        I can't flying!\n        I FlyRocketPowered!\n         */\n    }\n}\n```","source":"_posts/设计模式笔记/策略模式/策略模式.md","raw":"---\ntitle: 设计模式--策略模式\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了策略模式的原则,类图,代码实现。'\ncategories: 设计模式笔记\ntags:\n  - 设计模式\n  - Java\n  - UML\nabbrlink: eee4fbd1\ndate: 2020-09-15 00:00:00\n---\n\n# 策略模式\n## 策略模式定义\n定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化**独立**于使用算法的客户。\n\n## 设计原则\n\n1. 找出应用可能需要变化之处,把他们独立出来,不要和那些不需要变化的代码混在一起。封装变化。\n2. 针对接口编程，而不是针对实现编程。\n3. 多用组合，少用继承。\n\n\n## 针对接口编程\n\n利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为。更明确的说是变量的声明类型应该是超类型\n\n\n\n# 类图\n\n用接口代表每个行为，而行为的每个实现都将实现其中一个接口\n\n![image-20200923193518271](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200923193518271.png)\n\n# 实现\n\n## FlyBehavior接口相关\n\n```java\npublic interface FlyBehavior\n{\n    void fly();\n}\n```\n\n```java\npublic class FlyWithWings implements FlyBehavior\n{\n    @Override\n    public void fly()\n    {\n        System.out.println(\"I am flying!\");\n    }\n}\n```\n\n```java\npublic class FlyNoWay implements FlyBehavior\n{\n    @Override\n    public void fly()\n    {\n        System.out.println(\"I can't flying!\");\n    }\n}\n```\n\n```java\npublic class FlyRocketPowered implements FlyBehavior\n{\n    @Override\n    public void fly()\n    {\n        System.out.println(\"I FlyRocketPowered!\");\n    }\n}\n```\n\n## QuackBehavior接口相关\n\n```java\npublic interface QuackBehavior\n{\n    void quack();\n}\n```\n\n```java\npublic class Quack implements QuackBehavior\n{\n    @Override\n    public void quack()\n    {\n        System.out.println(\"Quack\");\n    }\n}\n```\n\n```java\npublic class MuteQuack implements QuackBehavior\n{\n    @Override\n    public void quack()\n    {\n        System.out.println(\"Silence\");\n    }\n}\n```\n\n## Duck相关\n\n```java\npublic class Duck\n{\n    FlyBehavior flyBehavior;\n    QuackBehavior quackBehavior;\n\n    public void setFlyBehavior(FlyBehavior flyBehavior)\n    {\n        this.flyBehavior = flyBehavior;\n    }\n\n    public void setQuackBehavior(QuackBehavior quackBehavior)\n    {\n        this.quackBehavior = quackBehavior;\n    }\n\n    public void performFly()\n    {\n        flyBehavior.fly();\n    }\n\n    public void performQuack()\n    {\n        quackBehavior.quack();\n    }\n\n    public void swim()\n    {\n        System.out.println(\"All ducks float\");\n    }\n\n    public void display()\n    {\n        System.out.println(\"display duck\");\n    }\n}\n```\n\n```java\npublic class ModelDuck extends Duck\n{\n    public ModelDuck()\n    {\n        flyBehavior = new FlyNoWay();\n        quackBehavior = new Quack();\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(\"I am model Duck\");\n    }\n}\n```\n\n## MainTest\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        Duck model = new ModelDuck();\n        model.performFly();\n        model.setFlyBehavior(new FlyRocketPowered());\n        model.performFly();\n        /*\n        输出:\n        I can't flying!\n        I FlyRocketPowered!\n         */\n    }\n}\n```","slug":"设计模式笔记/策略模式/策略模式","published":1,"updated":"2020-11-12T11:57:30.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73l00nsjotp6exmhabz","content":"<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><h2 id=\"策略模式定义\"><a href=\"#策略模式定义\" class=\"headerlink\" title=\"策略模式定义\"></a>策略模式定义</h2><p>定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化<strong>独立</strong>于使用算法的客户。</p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><ol>\n<li>找出应用可能需要变化之处,把他们独立出来,不要和那些不需要变化的代码混在一起。封装变化。</li>\n<li>针对接口编程，而不是针对实现编程。</li>\n<li>多用组合，少用继承。</li>\n</ol>\n<h2 id=\"针对接口编程\"><a href=\"#针对接口编程\" class=\"headerlink\" title=\"针对接口编程\"></a>针对接口编程</h2><p>利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为。更明确的说是变量的声明类型应该是超类型</p>\n<h1 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h1><p>用接口代表每个行为，而行为的每个实现都将实现其中一个接口</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200923193518271.png\" alt=\"image-20200923193518271\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"FlyBehavior接口相关\"><a href=\"#FlyBehavior接口相关\" class=\"headerlink\" title=\"FlyBehavior接口相关\"></a>FlyBehavior接口相关</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">FlyBehavior</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FlyWithWings</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">FlyBehavior</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I am flying!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FlyNoWay</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">FlyBehavior</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I can't flying!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FlyRocketPowered</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">FlyBehavior</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I FlyRocketPowered!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"QuackBehavior接口相关\"><a href=\"#QuackBehavior接口相关\" class=\"headerlink\" title=\"QuackBehavior接口相关\"></a>QuackBehavior接口相关</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">QuackBehavior</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">quack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Quack</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">QuackBehavior</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">quack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Quack\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MuteQuack</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">QuackBehavior</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">quack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Silence\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"Duck相关\"><a href=\"#Duck相关\" class=\"headerlink\" title=\"Duck相关\"></a>Duck相关</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Duck</span>\n<span class=\"token punctuation\">{</span>\n    FlyBehavior flyBehavior<span class=\"token punctuation\">;</span>\n    QuackBehavior quackBehavior<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setFlyBehavior</span><span class=\"token punctuation\">(</span>FlyBehavior flyBehavior<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>flyBehavior <span class=\"token operator\">=</span> flyBehavior<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setQuackBehavior</span><span class=\"token punctuation\">(</span>QuackBehavior quackBehavior<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>quackBehavior <span class=\"token operator\">=</span> quackBehavior<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">performFly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        flyBehavior<span class=\"token punctuation\">.</span><span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">performQuack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        quackBehavior<span class=\"token punctuation\">.</span><span class=\"token function\">quack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">swim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"All ducks float\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"display duck\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ModelDuck</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Duck</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ModelDuck</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        flyBehavior <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FlyNoWay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        quackBehavior <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Quack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I am model Duck\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Duck model <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ModelDuck</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        model<span class=\"token punctuation\">.</span><span class=\"token function\">performFly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        model<span class=\"token punctuation\">.</span><span class=\"token function\">setFlyBehavior</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FlyRocketPowered</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        model<span class=\"token punctuation\">.</span><span class=\"token function\">performFly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n        输出:\n        I can't flying!\n        I FlyRocketPowered!\n         */</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><h2 id=\"策略模式定义\"><a href=\"#策略模式定义\" class=\"headerlink\" title=\"策略模式定义\"></a>策略模式定义</h2><p>定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化<strong>独立</strong>于使用算法的客户。</p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><ol>\n<li>找出应用可能需要变化之处,把他们独立出来,不要和那些不需要变化的代码混在一起。封装变化。</li>\n<li>针对接口编程，而不是针对实现编程。</li>\n<li>多用组合，少用继承。</li>\n</ol>\n<h2 id=\"针对接口编程\"><a href=\"#针对接口编程\" class=\"headerlink\" title=\"针对接口编程\"></a>针对接口编程</h2><p>利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为。更明确的说是变量的声明类型应该是超类型</p>\n<h1 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h1><p>用接口代表每个行为，而行为的每个实现都将实现其中一个接口</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200923193518271.png\" alt=\"image-20200923193518271\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"FlyBehavior接口相关\"><a href=\"#FlyBehavior接口相关\" class=\"headerlink\" title=\"FlyBehavior接口相关\"></a>FlyBehavior接口相关</h2><pre><code class=\"java\">public interface FlyBehavior\n{\n    void fly();\n}</code></pre>\n<pre><code class=\"java\">public class FlyWithWings implements FlyBehavior\n{\n    @Override\n    public void fly()\n    {\n        System.out.println(&quot;I am flying!&quot;);\n    }\n}</code></pre>\n<pre><code class=\"java\">public class FlyNoWay implements FlyBehavior\n{\n    @Override\n    public void fly()\n    {\n        System.out.println(&quot;I can&#39;t flying!&quot;);\n    }\n}</code></pre>\n<pre><code class=\"java\">public class FlyRocketPowered implements FlyBehavior\n{\n    @Override\n    public void fly()\n    {\n        System.out.println(&quot;I FlyRocketPowered!&quot;);\n    }\n}</code></pre>\n<h2 id=\"QuackBehavior接口相关\"><a href=\"#QuackBehavior接口相关\" class=\"headerlink\" title=\"QuackBehavior接口相关\"></a>QuackBehavior接口相关</h2><pre><code class=\"java\">public interface QuackBehavior\n{\n    void quack();\n}</code></pre>\n<pre><code class=\"java\">public class Quack implements QuackBehavior\n{\n    @Override\n    public void quack()\n    {\n        System.out.println(&quot;Quack&quot;);\n    }\n}</code></pre>\n<pre><code class=\"java\">public class MuteQuack implements QuackBehavior\n{\n    @Override\n    public void quack()\n    {\n        System.out.println(&quot;Silence&quot;);\n    }\n}</code></pre>\n<h2 id=\"Duck相关\"><a href=\"#Duck相关\" class=\"headerlink\" title=\"Duck相关\"></a>Duck相关</h2><pre><code class=\"java\">public class Duck\n{\n    FlyBehavior flyBehavior;\n    QuackBehavior quackBehavior;\n\n    public void setFlyBehavior(FlyBehavior flyBehavior)\n    {\n        this.flyBehavior = flyBehavior;\n    }\n\n    public void setQuackBehavior(QuackBehavior quackBehavior)\n    {\n        this.quackBehavior = quackBehavior;\n    }\n\n    public void performFly()\n    {\n        flyBehavior.fly();\n    }\n\n    public void performQuack()\n    {\n        quackBehavior.quack();\n    }\n\n    public void swim()\n    {\n        System.out.println(&quot;All ducks float&quot;);\n    }\n\n    public void display()\n    {\n        System.out.println(&quot;display duck&quot;);\n    }\n}</code></pre>\n<pre><code class=\"java\">public class ModelDuck extends Duck\n{\n    public ModelDuck()\n    {\n        flyBehavior = new FlyNoWay();\n        quackBehavior = new Quack();\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(&quot;I am model Duck&quot;);\n    }\n}</code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre><code class=\"java\">public class MainTest\n{\n    public static void main(String[] args)\n    {\n        Duck model = new ModelDuck();\n        model.performFly();\n        model.setFlyBehavior(new FlyRocketPowered());\n        model.performFly();\n        /*\n        输出:\n        I can&#39;t flying!\n        I FlyRocketPowered!\n         */\n    }\n}</code></pre>\n"},{"title":"设计模式--工厂方法模式","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":false,"mathjax":false,"summary":"学习《Head Frist 设计模式》所做的笔记,主要介绍了工厂方法模式的原则,类图,代码实现。","abbrlink":"98f870a2","date":"2020-09-26T16:00:00.000Z","_content":"# 工厂方法模式\n## 定义\n\n工厂方法模式定义了一个创建对象的接口,但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。\n\n## 设计原则\n\n要依赖抽象，不要依赖具体类。\n\n即不能让高级组件依赖低层组件。\n\n## 指导方针\n\n1. 变量不可以持有具体类的引用（改用工厂模式）\n2. 不要让类派生自具体类（用接口创建）\n3. 不要覆盖基类中已实现方法\n\n\n\n## 工厂方法模式类图\n\n![image-20200928104712021](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200928104712021.png)\n\n\n\n# 实现\n\n## creator相关\n\n```java\npublic abstract class PizzaStore\n{\n    public Pizza orderPizza(String type)\n    {\n        Pizza pizza;\n        pizza = createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    protected abstract Pizza createPizza(String type);\n}\n```\n\n```java\npublic class NYPizzaStore extends PizzaStore\n{\n    @Override\n    protected Pizza createPizza(String type)\n    {\n        return new NYStyleCheesePizza();\n    }\n}\n```\n\n```java\npublic class ChicagoPizzaStore extends PizzaStore\n{\n    @Override\n    protected Pizza createPizza(String type)\n    {\n        return new ChicagoStyleCheesePizza();\n    }\n}\n```\n\n## product相关\n\n```java\npublic class Pizza\n{\n    String name;\n    String dough;\n    String sauce;\n    ArrayList<String> toppings = new ArrayList<>();\n\n    public void prepare()\n    {\n        System.out.println(\"Preparing--\"+name);\n        System.out.println(\"dough--\"+dough);\n        System.out.println(\"sauce--\"+sauce);\n        for (String topping : toppings)\n        {\n            System.out.println(topping);\n        }\n        System.out.println(\"---------------\");\n    }\n\n    public void bake()\n    {\n        System.out.println(\"bake\");\n    }\n\n    public void cut()\n    {\n        System.out.println(\"cut\");\n    }\n\n    public void box()\n    {\n        System.out.println(\"box\");\n    }\n\n    public String getName()\n    {\n        return name;\n    }\n}\n```\n\n```java\npublic class NYStyleCheesePizza extends Pizza\n{\n    public NYStyleCheesePizza()\n    {\n        name = \"NYStyleCheesePizza\";\n        dough = \"NYStyleCheesePizza\";\n        sauce = \"NYStyleCheesePizza\";\n        toppings.add(\"NYStyleCheesePizza\");\n    }\n}\n```\n\n```java\npublic class ChicagoStyleCheesePizza extends Pizza\n{\n    public ChicagoStyleCheesePizza()\n    {\n        name = \"ChicagoStyleCheesePizza\";\n        dough = \"ChicagoStyleCheesePizza\";\n        sauce = \"ChicagoStyleCheesePizza\";\n        toppings.add(\"ChicagoStyleCheesePizza\");\n    }\n}\n```\n\n## MainTest\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        PizzaStore nyStore = new NYPizzaStore();\n        PizzaStore chicagoStore = new ChicagoPizzaStore();\n\n        Pizza pizza = nyStore.orderPizza(\"cheese\");\n        Pizza pizza2 = chicagoStore.orderPizza(\"cheese\");\n\n    }\n}\n```","source":"_posts/设计模式笔记/工厂模式/工厂方法模式.md","raw":"---\ntitle: 设计模式--工厂方法模式\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: false\nmathjax: false\nsummary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了工厂方法模式的原则,类图,代码实现。'\ncategories: 设计模式笔记\ntags:\n  - 设计模式\n  - Java\n  - UML\nabbrlink: 98f870a2\ndate: 2020-09-27 00:00:00\n---\n# 工厂方法模式\n## 定义\n\n工厂方法模式定义了一个创建对象的接口,但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。\n\n## 设计原则\n\n要依赖抽象，不要依赖具体类。\n\n即不能让高级组件依赖低层组件。\n\n## 指导方针\n\n1. 变量不可以持有具体类的引用（改用工厂模式）\n2. 不要让类派生自具体类（用接口创建）\n3. 不要覆盖基类中已实现方法\n\n\n\n## 工厂方法模式类图\n\n![image-20200928104712021](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200928104712021.png)\n\n\n\n# 实现\n\n## creator相关\n\n```java\npublic abstract class PizzaStore\n{\n    public Pizza orderPizza(String type)\n    {\n        Pizza pizza;\n        pizza = createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    protected abstract Pizza createPizza(String type);\n}\n```\n\n```java\npublic class NYPizzaStore extends PizzaStore\n{\n    @Override\n    protected Pizza createPizza(String type)\n    {\n        return new NYStyleCheesePizza();\n    }\n}\n```\n\n```java\npublic class ChicagoPizzaStore extends PizzaStore\n{\n    @Override\n    protected Pizza createPizza(String type)\n    {\n        return new ChicagoStyleCheesePizza();\n    }\n}\n```\n\n## product相关\n\n```java\npublic class Pizza\n{\n    String name;\n    String dough;\n    String sauce;\n    ArrayList<String> toppings = new ArrayList<>();\n\n    public void prepare()\n    {\n        System.out.println(\"Preparing--\"+name);\n        System.out.println(\"dough--\"+dough);\n        System.out.println(\"sauce--\"+sauce);\n        for (String topping : toppings)\n        {\n            System.out.println(topping);\n        }\n        System.out.println(\"---------------\");\n    }\n\n    public void bake()\n    {\n        System.out.println(\"bake\");\n    }\n\n    public void cut()\n    {\n        System.out.println(\"cut\");\n    }\n\n    public void box()\n    {\n        System.out.println(\"box\");\n    }\n\n    public String getName()\n    {\n        return name;\n    }\n}\n```\n\n```java\npublic class NYStyleCheesePizza extends Pizza\n{\n    public NYStyleCheesePizza()\n    {\n        name = \"NYStyleCheesePizza\";\n        dough = \"NYStyleCheesePizza\";\n        sauce = \"NYStyleCheesePizza\";\n        toppings.add(\"NYStyleCheesePizza\");\n    }\n}\n```\n\n```java\npublic class ChicagoStyleCheesePizza extends Pizza\n{\n    public ChicagoStyleCheesePizza()\n    {\n        name = \"ChicagoStyleCheesePizza\";\n        dough = \"ChicagoStyleCheesePizza\";\n        sauce = \"ChicagoStyleCheesePizza\";\n        toppings.add(\"ChicagoStyleCheesePizza\");\n    }\n}\n```\n\n## MainTest\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        PizzaStore nyStore = new NYPizzaStore();\n        PizzaStore chicagoStore = new ChicagoPizzaStore();\n\n        Pizza pizza = nyStore.orderPizza(\"cheese\");\n        Pizza pizza2 = chicagoStore.orderPizza(\"cheese\");\n\n    }\n}\n```","slug":"设计模式笔记/工厂模式/工厂方法模式","published":1,"updated":"2021-02-04T00:35:45.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73n00nwjotp0qvw6jdz","content":"<h1 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>工厂方法模式定义了一个创建对象的接口,但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><p>要依赖抽象，不要依赖具体类。</p>\n<p>即不能让高级组件依赖低层组件。</p>\n<h2 id=\"指导方针\"><a href=\"#指导方针\" class=\"headerlink\" title=\"指导方针\"></a>指导方针</h2><ol>\n<li>变量不可以持有具体类的引用（改用工厂模式）</li>\n<li>不要让类派生自具体类（用接口创建）</li>\n<li>不要覆盖基类中已实现方法</li>\n</ol>\n<h2 id=\"工厂方法模式类图\"><a href=\"#工厂方法模式类图\" class=\"headerlink\" title=\"工厂方法模式类图\"></a>工厂方法模式类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200928104712021.png\" alt=\"image-20200928104712021\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"creator相关\"><a href=\"#creator相关\" class=\"headerlink\" title=\"creator相关\"></a>creator相关</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PizzaStore</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> Pizza <span class=\"token function\">orderPizza</span><span class=\"token punctuation\">(</span>String type<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Pizza pizza<span class=\"token punctuation\">;</span>\n        pizza <span class=\"token operator\">=</span> <span class=\"token function\">createPizza</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        pizza<span class=\"token punctuation\">.</span><span class=\"token function\">prepare</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        pizza<span class=\"token punctuation\">.</span><span class=\"token function\">bake</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        pizza<span class=\"token punctuation\">.</span><span class=\"token function\">cut</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        pizza<span class=\"token punctuation\">.</span><span class=\"token function\">box</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> pizza<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> Pizza <span class=\"token function\">createPizza</span><span class=\"token punctuation\">(</span>String type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NYPizzaStore</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">PizzaStore</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> Pizza <span class=\"token function\">createPizza</span><span class=\"token punctuation\">(</span>String type<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NYStyleCheesePizza</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ChicagoPizzaStore</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">PizzaStore</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> Pizza <span class=\"token function\">createPizza</span><span class=\"token punctuation\">(</span>String type<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ChicagoStyleCheesePizza</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"product相关\"><a href=\"#product相关\" class=\"headerlink\" title=\"product相关\"></a>product相关</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Pizza</span>\n<span class=\"token punctuation\">{</span>\n    String name<span class=\"token punctuation\">;</span>\n    String dough<span class=\"token punctuation\">;</span>\n    String sauce<span class=\"token punctuation\">;</span>\n    ArrayList<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> toppings <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">prepare</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Preparing--\"</span><span class=\"token operator\">+</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"dough--\"</span><span class=\"token operator\">+</span>dough<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sauce--\"</span><span class=\"token operator\">+</span>sauce<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>String topping <span class=\"token operator\">:</span> toppings<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>topping<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"---------------\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">bake</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bake\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">cut</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cut\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">box</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"box\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NYStyleCheesePizza</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Pizza</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">NYStyleCheesePizza</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        name <span class=\"token operator\">=</span> <span class=\"token string\">\"NYStyleCheesePizza\"</span><span class=\"token punctuation\">;</span>\n        dough <span class=\"token operator\">=</span> <span class=\"token string\">\"NYStyleCheesePizza\"</span><span class=\"token punctuation\">;</span>\n        sauce <span class=\"token operator\">=</span> <span class=\"token string\">\"NYStyleCheesePizza\"</span><span class=\"token punctuation\">;</span>\n        toppings<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"NYStyleCheesePizza\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ChicagoStyleCheesePizza</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Pizza</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ChicagoStyleCheesePizza</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        name <span class=\"token operator\">=</span> <span class=\"token string\">\"ChicagoStyleCheesePizza\"</span><span class=\"token punctuation\">;</span>\n        dough <span class=\"token operator\">=</span> <span class=\"token string\">\"ChicagoStyleCheesePizza\"</span><span class=\"token punctuation\">;</span>\n        sauce <span class=\"token operator\">=</span> <span class=\"token string\">\"ChicagoStyleCheesePizza\"</span><span class=\"token punctuation\">;</span>\n        toppings<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ChicagoStyleCheesePizza\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        PizzaStore nyStore <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NYPizzaStore</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        PizzaStore chicagoStore <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ChicagoPizzaStore</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        Pizza pizza <span class=\"token operator\">=</span> nyStore<span class=\"token punctuation\">.</span><span class=\"token function\">orderPizza</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cheese\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Pizza pizza2 <span class=\"token operator\">=</span> chicagoStore<span class=\"token punctuation\">.</span><span class=\"token function\">orderPizza</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cheese\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>工厂方法模式定义了一个创建对象的接口,但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><p>要依赖抽象，不要依赖具体类。</p>\n<p>即不能让高级组件依赖低层组件。</p>\n<h2 id=\"指导方针\"><a href=\"#指导方针\" class=\"headerlink\" title=\"指导方针\"></a>指导方针</h2><ol>\n<li>变量不可以持有具体类的引用（改用工厂模式）</li>\n<li>不要让类派生自具体类（用接口创建）</li>\n<li>不要覆盖基类中已实现方法</li>\n</ol>\n<h2 id=\"工厂方法模式类图\"><a href=\"#工厂方法模式类图\" class=\"headerlink\" title=\"工厂方法模式类图\"></a>工厂方法模式类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200928104712021.png\" alt=\"image-20200928104712021\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"creator相关\"><a href=\"#creator相关\" class=\"headerlink\" title=\"creator相关\"></a>creator相关</h2><pre><code class=\"java\">public abstract class PizzaStore\n{\n    public Pizza orderPizza(String type)\n    {\n        Pizza pizza;\n        pizza = createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    protected abstract Pizza createPizza(String type);\n}</code></pre>\n<pre><code class=\"java\">public class NYPizzaStore extends PizzaStore\n{\n    @Override\n    protected Pizza createPizza(String type)\n    {\n        return new NYStyleCheesePizza();\n    }\n}</code></pre>\n<pre><code class=\"java\">public class ChicagoPizzaStore extends PizzaStore\n{\n    @Override\n    protected Pizza createPizza(String type)\n    {\n        return new ChicagoStyleCheesePizza();\n    }\n}</code></pre>\n<h2 id=\"product相关\"><a href=\"#product相关\" class=\"headerlink\" title=\"product相关\"></a>product相关</h2><pre><code class=\"java\">public class Pizza\n{\n    String name;\n    String dough;\n    String sauce;\n    ArrayList&lt;String&gt; toppings = new ArrayList&lt;&gt;();\n\n    public void prepare()\n    {\n        System.out.println(&quot;Preparing--&quot;+name);\n        System.out.println(&quot;dough--&quot;+dough);\n        System.out.println(&quot;sauce--&quot;+sauce);\n        for (String topping : toppings)\n        {\n            System.out.println(topping);\n        }\n        System.out.println(&quot;---------------&quot;);\n    }\n\n    public void bake()\n    {\n        System.out.println(&quot;bake&quot;);\n    }\n\n    public void cut()\n    {\n        System.out.println(&quot;cut&quot;);\n    }\n\n    public void box()\n    {\n        System.out.println(&quot;box&quot;);\n    }\n\n    public String getName()\n    {\n        return name;\n    }\n}</code></pre>\n<pre><code class=\"java\">public class NYStyleCheesePizza extends Pizza\n{\n    public NYStyleCheesePizza()\n    {\n        name = &quot;NYStyleCheesePizza&quot;;\n        dough = &quot;NYStyleCheesePizza&quot;;\n        sauce = &quot;NYStyleCheesePizza&quot;;\n        toppings.add(&quot;NYStyleCheesePizza&quot;);\n    }\n}</code></pre>\n<pre><code class=\"java\">public class ChicagoStyleCheesePizza extends Pizza\n{\n    public ChicagoStyleCheesePizza()\n    {\n        name = &quot;ChicagoStyleCheesePizza&quot;;\n        dough = &quot;ChicagoStyleCheesePizza&quot;;\n        sauce = &quot;ChicagoStyleCheesePizza&quot;;\n        toppings.add(&quot;ChicagoStyleCheesePizza&quot;);\n    }\n}</code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre><code class=\"java\">public class MainTest\n{\n    public static void main(String[] args)\n    {\n        PizzaStore nyStore = new NYPizzaStore();\n        PizzaStore chicagoStore = new ChicagoPizzaStore();\n\n        Pizza pizza = nyStore.orderPizza(&quot;cheese&quot;);\n        Pizza pizza2 = chicagoStore.orderPizza(&quot;cheese&quot;);\n\n    }\n}</code></pre>\n"},{"title":"设计模式--观察者模式","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Head Frist 设计模式》所做的笔记,主要介绍了观察者模式的原则,类图,代码实现。","abbrlink":"98ef9b01","date":"2020-09-17T16:00:00.000Z","_content":"\n# 观察者模式\n## 定义\n\n观察者模式定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,他的所有依赖者都会收到通知并自动更新。\n\n## 细节\n\n主题只知道观察者实现了Observer接口。在任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现了Observer接口的对象列表。\n\n有新类型观察者出现时，只需要实现观察者接口，再注册成为观察者即可。\n\n## 设计原则\n\n为了交互对象之间的松耦合设计而努力\n\n## 类图\n\n![image-20200924112457998](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200924112457998.png)\n\n# 实现\n\n## Subject接口相关\n\n```java\npublic interface Subject\n{\n    void registerObserver(Observer observer);\n\n    void removeObserver(Observer observer);\n\n    void notifyObservers();\n}\n```\n\n```java\npublic class WeatherData implements Subject\n{\n    private final List<Observer> observers;\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public WeatherData()\n    {\n        observers = new ArrayList<>();\n    }\n\n    @Override\n    public void registerObserver(Observer observer)\n    {\n        observers.add(observer);\n    }\n\n    @Override\n    public void removeObserver(Observer observer)\n    {\n        observers.remove(observer);\n    }\n\n    @Override\n    public void notifyObservers()\n    {\n        for (Observer observer : observers)\n        {\n            observer.update(temperature,humidity,pressure);\n        }\n    }\n\n    public void measurementsChanged()\n    {\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature,float humidity,float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n}\n```\n\n## Observer接口相关\n\n```java\npublic interface Observer\n{\n    void update(float temp, float humidity, float pressure);\n}\n```\n\n```java\npublic interface DisplayElement\n{\n    void display();\n}\n```\n\n```java\npublic class CurrentConditionsDisplay implements Observer, DisplayElement\n{\n    private float temperature;\n    private float humidity;\n    private Subject weatherData;\n\n    public CurrentConditionsDisplay(Subject weatherData)\n    {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(\"CurrentConditionsDisplay:\"+temperature+\",\"+humidity);\n    }\n\n    @Override\n    public void update(float temperature, float humidity, float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        display();\n    }\n}\n```\n\n```java\npublic class ForecastDisplay implements Observer, DisplayElement\n{\n    private float temperature;\n    private float humidity;\n    private float pressure;\n    private Subject weatherData;\n\n    public ForecastDisplay(Subject weatherData)\n    {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(\"ForecastDisplay:\"+temperature+\",\"+humidity+\",\"+pressure);\n    }\n\n    @Override\n    public void update(float temperature, float humidity, float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        display();\n    }\n}\n```\n\n```java\npublic class StatisticsDisplay implements Observer, DisplayElement\n{\n    private float temperature;\n    private float humidity;\n    private float pressure;\n    private Subject weatherData;\n\n    public StatisticsDisplay(Subject weatherData)\n    {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(\"StatisticsDisplay:\"+temperature+\",\"+humidity+\",\"+pressure);\n    }\n\n    @Override\n    public void update(float temperature, float humidity, float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        display();\n    }\n}\n```\n\n## MainTest\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        WeatherData weatherData = new WeatherData();\n        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);\n        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);\n        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);\n        weatherData.setMeasurements(80,65,30.4f);\n        /*\n        输出:\n        CurrentConditionsDisplay:80.0,65.0\n        ForecastDisplay:80.0,65.0,30.4\n        StatisticsDisplay:80.0,65.0,30.4\n         */\n    }\n}\n```","source":"_posts/设计模式笔记/观察者模式/观察者模式.md","raw":"---\ntitle: 设计模式--观察者模式\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了观察者模式的原则,类图,代码实现。'\ncategories: 设计模式笔记\ntags:\n  - 设计模式\n  - Java\n  - UML\nabbrlink: 98ef9b01\ndate: 2020-09-18 00:00:00\n---\n\n# 观察者模式\n## 定义\n\n观察者模式定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,他的所有依赖者都会收到通知并自动更新。\n\n## 细节\n\n主题只知道观察者实现了Observer接口。在任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现了Observer接口的对象列表。\n\n有新类型观察者出现时，只需要实现观察者接口，再注册成为观察者即可。\n\n## 设计原则\n\n为了交互对象之间的松耦合设计而努力\n\n## 类图\n\n![image-20200924112457998](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200924112457998.png)\n\n# 实现\n\n## Subject接口相关\n\n```java\npublic interface Subject\n{\n    void registerObserver(Observer observer);\n\n    void removeObserver(Observer observer);\n\n    void notifyObservers();\n}\n```\n\n```java\npublic class WeatherData implements Subject\n{\n    private final List<Observer> observers;\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public WeatherData()\n    {\n        observers = new ArrayList<>();\n    }\n\n    @Override\n    public void registerObserver(Observer observer)\n    {\n        observers.add(observer);\n    }\n\n    @Override\n    public void removeObserver(Observer observer)\n    {\n        observers.remove(observer);\n    }\n\n    @Override\n    public void notifyObservers()\n    {\n        for (Observer observer : observers)\n        {\n            observer.update(temperature,humidity,pressure);\n        }\n    }\n\n    public void measurementsChanged()\n    {\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature,float humidity,float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n}\n```\n\n## Observer接口相关\n\n```java\npublic interface Observer\n{\n    void update(float temp, float humidity, float pressure);\n}\n```\n\n```java\npublic interface DisplayElement\n{\n    void display();\n}\n```\n\n```java\npublic class CurrentConditionsDisplay implements Observer, DisplayElement\n{\n    private float temperature;\n    private float humidity;\n    private Subject weatherData;\n\n    public CurrentConditionsDisplay(Subject weatherData)\n    {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(\"CurrentConditionsDisplay:\"+temperature+\",\"+humidity);\n    }\n\n    @Override\n    public void update(float temperature, float humidity, float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        display();\n    }\n}\n```\n\n```java\npublic class ForecastDisplay implements Observer, DisplayElement\n{\n    private float temperature;\n    private float humidity;\n    private float pressure;\n    private Subject weatherData;\n\n    public ForecastDisplay(Subject weatherData)\n    {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(\"ForecastDisplay:\"+temperature+\",\"+humidity+\",\"+pressure);\n    }\n\n    @Override\n    public void update(float temperature, float humidity, float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        display();\n    }\n}\n```\n\n```java\npublic class StatisticsDisplay implements Observer, DisplayElement\n{\n    private float temperature;\n    private float humidity;\n    private float pressure;\n    private Subject weatherData;\n\n    public StatisticsDisplay(Subject weatherData)\n    {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(\"StatisticsDisplay:\"+temperature+\",\"+humidity+\",\"+pressure);\n    }\n\n    @Override\n    public void update(float temperature, float humidity, float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        display();\n    }\n}\n```\n\n## MainTest\n\n```java\npublic class MainTest\n{\n    public static void main(String[] args)\n    {\n        WeatherData weatherData = new WeatherData();\n        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);\n        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);\n        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);\n        weatherData.setMeasurements(80,65,30.4f);\n        /*\n        输出:\n        CurrentConditionsDisplay:80.0,65.0\n        ForecastDisplay:80.0,65.0,30.4\n        StatisticsDisplay:80.0,65.0,30.4\n         */\n    }\n}\n```","slug":"设计模式笔记/观察者模式/观察者模式","published":1,"updated":"2020-11-12T11:57:30.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73o00o0jotp3yla6zdx","content":"<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>观察者模式定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,他的所有依赖者都会收到通知并自动更新。</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><p>主题只知道观察者实现了Observer接口。在任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现了Observer接口的对象列表。</p>\n<p>有新类型观察者出现时，只需要实现观察者接口，再注册成为观察者即可。</p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><p>为了交互对象之间的松耦合设计而努力</p>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200924112457998.png\" alt=\"image-20200924112457998\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"Subject接口相关\"><a href=\"#Subject接口相关\" class=\"headerlink\" title=\"Subject接口相关\"></a>Subject接口相关</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Subject</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">registerObserver</span><span class=\"token punctuation\">(</span>Observer observer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">removeObserver</span><span class=\"token punctuation\">(</span>Observer observer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">notifyObservers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WeatherData</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Subject</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> List<span class=\"token operator\">&lt;</span>Observer<span class=\"token operator\">></span> observers<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">float</span> temperature<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">float</span> humidity<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">float</span> pressure<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">WeatherData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        observers <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">registerObserver</span><span class=\"token punctuation\">(</span>Observer observer<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        observers<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">removeObserver</span><span class=\"token punctuation\">(</span>Observer observer<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        observers<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">notifyObservers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Observer observer <span class=\"token operator\">:</span> observers<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            observer<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>temperature<span class=\"token punctuation\">,</span>humidity<span class=\"token punctuation\">,</span>pressure<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">measurementsChanged</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">notifyObservers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setMeasurements</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> temperature<span class=\"token punctuation\">,</span><span class=\"token keyword\">float</span> humidity<span class=\"token punctuation\">,</span><span class=\"token keyword\">float</span> pressure<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>temperature <span class=\"token operator\">=</span> temperature<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>humidity <span class=\"token operator\">=</span> humidity<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>pressure <span class=\"token operator\">=</span> pressure<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">measurementsChanged</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"Observer接口相关\"><a href=\"#Observer接口相关\" class=\"headerlink\" title=\"Observer接口相关\"></a>Observer接口相关</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Observer</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> temp<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> humidity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> pressure<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">DisplayElement</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CurrentConditionsDisplay</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Observer</span><span class=\"token punctuation\">,</span> DisplayElement\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">float</span> temperature<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">float</span> humidity<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> Subject weatherData<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">CurrentConditionsDisplay</span><span class=\"token punctuation\">(</span>Subject weatherData<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>weatherData <span class=\"token operator\">=</span> weatherData<span class=\"token punctuation\">;</span>\n        weatherData<span class=\"token punctuation\">.</span><span class=\"token function\">registerObserver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"CurrentConditionsDisplay:\"</span><span class=\"token operator\">+</span>temperature<span class=\"token operator\">+</span><span class=\"token string\">\",\"</span><span class=\"token operator\">+</span>humidity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> temperature<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> humidity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> pressure<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>temperature <span class=\"token operator\">=</span> temperature<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>humidity <span class=\"token operator\">=</span> humidity<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ForecastDisplay</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Observer</span><span class=\"token punctuation\">,</span> DisplayElement\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">float</span> temperature<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">float</span> humidity<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">float</span> pressure<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> Subject weatherData<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ForecastDisplay</span><span class=\"token punctuation\">(</span>Subject weatherData<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>weatherData <span class=\"token operator\">=</span> weatherData<span class=\"token punctuation\">;</span>\n        weatherData<span class=\"token punctuation\">.</span><span class=\"token function\">registerObserver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ForecastDisplay:\"</span><span class=\"token operator\">+</span>temperature<span class=\"token operator\">+</span><span class=\"token string\">\",\"</span><span class=\"token operator\">+</span>humidity<span class=\"token operator\">+</span><span class=\"token string\">\",\"</span><span class=\"token operator\">+</span>pressure<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> temperature<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> humidity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> pressure<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>temperature <span class=\"token operator\">=</span> temperature<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>humidity <span class=\"token operator\">=</span> humidity<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>pressure <span class=\"token operator\">=</span> pressure<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StatisticsDisplay</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Observer</span><span class=\"token punctuation\">,</span> DisplayElement\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">float</span> temperature<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">float</span> humidity<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">float</span> pressure<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> Subject weatherData<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">StatisticsDisplay</span><span class=\"token punctuation\">(</span>Subject weatherData<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>weatherData <span class=\"token operator\">=</span> weatherData<span class=\"token punctuation\">;</span>\n        weatherData<span class=\"token punctuation\">.</span><span class=\"token function\">registerObserver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"StatisticsDisplay:\"</span><span class=\"token operator\">+</span>temperature<span class=\"token operator\">+</span><span class=\"token string\">\",\"</span><span class=\"token operator\">+</span>humidity<span class=\"token operator\">+</span><span class=\"token string\">\",\"</span><span class=\"token operator\">+</span>pressure<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> temperature<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> humidity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> pressure<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>temperature <span class=\"token operator\">=</span> temperature<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>humidity <span class=\"token operator\">=</span> humidity<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>pressure <span class=\"token operator\">=</span> pressure<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        WeatherData weatherData <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeatherData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        CurrentConditionsDisplay currentConditionsDisplay <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CurrentConditionsDisplay</span><span class=\"token punctuation\">(</span>weatherData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ForecastDisplay forecastDisplay <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForecastDisplay</span><span class=\"token punctuation\">(</span>weatherData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        StatisticsDisplay statisticsDisplay <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StatisticsDisplay</span><span class=\"token punctuation\">(</span>weatherData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        weatherData<span class=\"token punctuation\">.</span><span class=\"token function\">setMeasurements</span><span class=\"token punctuation\">(</span><span class=\"token number\">80</span><span class=\"token punctuation\">,</span><span class=\"token number\">65</span><span class=\"token punctuation\">,</span><span class=\"token number\">30.4f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n        输出:\n        CurrentConditionsDisplay:80.0,65.0\n        ForecastDisplay:80.0,65.0,30.4\n        StatisticsDisplay:80.0,65.0,30.4\n         */</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>观察者模式定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,他的所有依赖者都会收到通知并自动更新。</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><p>主题只知道观察者实现了Observer接口。在任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现了Observer接口的对象列表。</p>\n<p>有新类型观察者出现时，只需要实现观察者接口，再注册成为观察者即可。</p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><p>为了交互对象之间的松耦合设计而努力</p>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200924112457998.png\" alt=\"image-20200924112457998\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"Subject接口相关\"><a href=\"#Subject接口相关\" class=\"headerlink\" title=\"Subject接口相关\"></a>Subject接口相关</h2><pre><code class=\"java\">public interface Subject\n{\n    void registerObserver(Observer observer);\n\n    void removeObserver(Observer observer);\n\n    void notifyObservers();\n}</code></pre>\n<pre><code class=\"java\">public class WeatherData implements Subject\n{\n    private final List&lt;Observer&gt; observers;\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public WeatherData()\n    {\n        observers = new ArrayList&lt;&gt;();\n    }\n\n    @Override\n    public void registerObserver(Observer observer)\n    {\n        observers.add(observer);\n    }\n\n    @Override\n    public void removeObserver(Observer observer)\n    {\n        observers.remove(observer);\n    }\n\n    @Override\n    public void notifyObservers()\n    {\n        for (Observer observer : observers)\n        {\n            observer.update(temperature,humidity,pressure);\n        }\n    }\n\n    public void measurementsChanged()\n    {\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature,float humidity,float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n}</code></pre>\n<h2 id=\"Observer接口相关\"><a href=\"#Observer接口相关\" class=\"headerlink\" title=\"Observer接口相关\"></a>Observer接口相关</h2><pre><code class=\"java\">public interface Observer\n{\n    void update(float temp, float humidity, float pressure);\n}</code></pre>\n<pre><code class=\"java\">public interface DisplayElement\n{\n    void display();\n}</code></pre>\n<pre><code class=\"java\">public class CurrentConditionsDisplay implements Observer, DisplayElement\n{\n    private float temperature;\n    private float humidity;\n    private Subject weatherData;\n\n    public CurrentConditionsDisplay(Subject weatherData)\n    {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(&quot;CurrentConditionsDisplay:&quot;+temperature+&quot;,&quot;+humidity);\n    }\n\n    @Override\n    public void update(float temperature, float humidity, float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        display();\n    }\n}</code></pre>\n<pre><code class=\"java\">public class ForecastDisplay implements Observer, DisplayElement\n{\n    private float temperature;\n    private float humidity;\n    private float pressure;\n    private Subject weatherData;\n\n    public ForecastDisplay(Subject weatherData)\n    {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(&quot;ForecastDisplay:&quot;+temperature+&quot;,&quot;+humidity+&quot;,&quot;+pressure);\n    }\n\n    @Override\n    public void update(float temperature, float humidity, float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        display();\n    }\n}</code></pre>\n<pre><code class=\"java\">public class StatisticsDisplay implements Observer, DisplayElement\n{\n    private float temperature;\n    private float humidity;\n    private float pressure;\n    private Subject weatherData;\n\n    public StatisticsDisplay(Subject weatherData)\n    {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void display()\n    {\n        System.out.println(&quot;StatisticsDisplay:&quot;+temperature+&quot;,&quot;+humidity+&quot;,&quot;+pressure);\n    }\n\n    @Override\n    public void update(float temperature, float humidity, float pressure)\n    {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        display();\n    }\n}</code></pre>\n<h2 id=\"MainTest\"><a href=\"#MainTest\" class=\"headerlink\" title=\"MainTest\"></a>MainTest</h2><pre><code class=\"java\">public class MainTest\n{\n    public static void main(String[] args)\n    {\n        WeatherData weatherData = new WeatherData();\n        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);\n        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);\n        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);\n        weatherData.setMeasurements(80,65,30.4f);\n        /*\n        输出:\n        CurrentConditionsDisplay:80.0,65.0\n        ForecastDisplay:80.0,65.0,30.4\n        StatisticsDisplay:80.0,65.0,30.4\n         */\n    }\n}</code></pre>\n"},{"title":"设计模式--适配器模式","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习《Head Frist 设计模式》所做的笔记,主要介绍了适配器模式的原则,类图,代码实现。","abbrlink":"f70eccfd","date":"2020-10-07T16:00:00.000Z","_content":"\n# 适配器模式\n\n## 定义\n\n适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。\n\n## 细节\n\n+ 作用是将一个接口转换成另一个接口,以符合用户的期望。\n\n## 类图\n\n![image-20201005103843452](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201005103843452.png)\n\n# 实现\n\n## animal\n\n```java\npublic interface Duck\n{\n    void quack();\n\n    void fly();\n}\n```\n\n```java\npublic class MallardDuck implements Duck\n{\n    @Override\n    public void quack()\n    {\n        System.out.println(\"Quack\");\n    }\n\n    @Override\n    public void fly()\n    {\n        System.out.println(\"fly\");\n    }\n}\n```\n\n```java\npublic interface Turkey\n{\n    void gobble();\n\n    void fly();\n}\n```\n\n```java\npublic class WildTurkey implements Turkey\n{\n    @Override\n    public void gobble()\n    {\n        System.out.println(\"Gobble\");\n    }\n\n    @Override\n    public void fly()\n    {\n        System.out.println(\"fly short\");\n    }\n}\n```\n\n## 适配器\n\n```java\n//将火鸡适配成鸭子\npublic class TurkeyAdapter implements Duck\n{\n    Turkey turkey;\n\n    public TurkeyAdapter(Turkey turkey)\n    {\n        this.turkey = turkey;\n    }\n\n    @Override\n    public void quack()\n    {\n        turkey.gobble();\n    }\n\n    @Override\n    public void fly()\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            turkey.fly();\n        }\n    }\n}\n```\n\n## Client\n\n```java\npublic class DuckTestDrive\n{\n    public static void main(String[] args)\n    {\n        WildTurkey wildTurkey = new WildTurkey();\n        TurkeyAdapter turkeyAdapter = new TurkeyAdapter(wildTurkey);\n        testDuck(turkeyAdapter);\n    }\n\n    public static void testDuck(Duck duck)\n    {\n        duck.quack();\n        duck.fly();\n    }\n}\n```\n\n# 迭代器适配器\n\n```java\npublic class EnumeratorIterator implements Iterator\n{\n    Enumeration enumeration;\n\n    public EnumeratorIterator(Enumeration enumeration)\n    {\n        this.enumeration = enumeration;\n    }\n\n    @Override\n    public boolean hasNext()\n    {\n        return enumeration.hasMoreElements();\n    }\n\n    @Override\n    public Object next()\n    {\n        return enumeration.nextElement();\n    }\n\n    @Override\n    public void remove()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n}\n```\n\n","source":"_posts/设计模式笔记/适配器模式/适配器模式.md","raw":"---\ntitle: 设计模式--适配器模式\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了适配器模式的原则,类图,代码实现。'\ncategories: 设计模式笔记\ntags:\n  - 设计模式\n  - Java\n  - UML\nabbrlink: f70eccfd\ndate: 2020-10-08 00:00:00\n---\n\n# 适配器模式\n\n## 定义\n\n适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。\n\n## 细节\n\n+ 作用是将一个接口转换成另一个接口,以符合用户的期望。\n\n## 类图\n\n![image-20201005103843452](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201005103843452.png)\n\n# 实现\n\n## animal\n\n```java\npublic interface Duck\n{\n    void quack();\n\n    void fly();\n}\n```\n\n```java\npublic class MallardDuck implements Duck\n{\n    @Override\n    public void quack()\n    {\n        System.out.println(\"Quack\");\n    }\n\n    @Override\n    public void fly()\n    {\n        System.out.println(\"fly\");\n    }\n}\n```\n\n```java\npublic interface Turkey\n{\n    void gobble();\n\n    void fly();\n}\n```\n\n```java\npublic class WildTurkey implements Turkey\n{\n    @Override\n    public void gobble()\n    {\n        System.out.println(\"Gobble\");\n    }\n\n    @Override\n    public void fly()\n    {\n        System.out.println(\"fly short\");\n    }\n}\n```\n\n## 适配器\n\n```java\n//将火鸡适配成鸭子\npublic class TurkeyAdapter implements Duck\n{\n    Turkey turkey;\n\n    public TurkeyAdapter(Turkey turkey)\n    {\n        this.turkey = turkey;\n    }\n\n    @Override\n    public void quack()\n    {\n        turkey.gobble();\n    }\n\n    @Override\n    public void fly()\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            turkey.fly();\n        }\n    }\n}\n```\n\n## Client\n\n```java\npublic class DuckTestDrive\n{\n    public static void main(String[] args)\n    {\n        WildTurkey wildTurkey = new WildTurkey();\n        TurkeyAdapter turkeyAdapter = new TurkeyAdapter(wildTurkey);\n        testDuck(turkeyAdapter);\n    }\n\n    public static void testDuck(Duck duck)\n    {\n        duck.quack();\n        duck.fly();\n    }\n}\n```\n\n# 迭代器适配器\n\n```java\npublic class EnumeratorIterator implements Iterator\n{\n    Enumeration enumeration;\n\n    public EnumeratorIterator(Enumeration enumeration)\n    {\n        this.enumeration = enumeration;\n    }\n\n    @Override\n    public boolean hasNext()\n    {\n        return enumeration.hasMoreElements();\n    }\n\n    @Override\n    public Object next()\n    {\n        return enumeration.nextElement();\n    }\n\n    @Override\n    public void remove()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n}\n```\n\n","slug":"设计模式笔记/适配器模式/适配器模式","published":1,"updated":"2020-11-12T11:57:30.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73p00o3jotp73hb91nl","content":"<h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ul>\n<li>作用是将一个接口转换成另一个接口,以符合用户的期望。</li>\n</ul>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201005103843452.png\" alt=\"image-20201005103843452\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"animal\"><a href=\"#animal\" class=\"headerlink\" title=\"animal\"></a>animal</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Duck</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">quack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MallardDuck</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Duck</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">quack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Quack\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fly\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Turkey</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">gobble</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WildTurkey</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Turkey</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">gobble</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Gobble\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fly short\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"适配器\"><a href=\"#适配器\" class=\"headerlink\" title=\"适配器\"></a>适配器</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//将火鸡适配成鸭子</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TurkeyAdapter</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Duck</span>\n<span class=\"token punctuation\">{</span>\n    Turkey turkey<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">TurkeyAdapter</span><span class=\"token punctuation\">(</span>Turkey turkey<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>turkey <span class=\"token operator\">=</span> turkey<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">quack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        turkey<span class=\"token punctuation\">.</span><span class=\"token function\">gobble</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            turkey<span class=\"token punctuation\">.</span><span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client\"></a>Client</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DuckTestDrive</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        WildTurkey wildTurkey <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WildTurkey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TurkeyAdapter turkeyAdapter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TurkeyAdapter</span><span class=\"token punctuation\">(</span>wildTurkey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">testDuck</span><span class=\"token punctuation\">(</span>turkeyAdapter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testDuck</span><span class=\"token punctuation\">(</span>Duck duck<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        duck<span class=\"token punctuation\">.</span><span class=\"token function\">quack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        duck<span class=\"token punctuation\">.</span><span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"迭代器适配器\"><a href=\"#迭代器适配器\" class=\"headerlink\" title=\"迭代器适配器\"></a>迭代器适配器</h1><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">EnumeratorIterator</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Iterator</span>\n<span class=\"token punctuation\">{</span>\n    Enumeration enumeration<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">EnumeratorIterator</span><span class=\"token punctuation\">(</span>Enumeration enumeration<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>enumeration <span class=\"token operator\">=</span> enumeration<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> enumeration<span class=\"token punctuation\">.</span><span class=\"token function\">hasMoreElements</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Object <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> enumeration<span class=\"token punctuation\">.</span><span class=\"token function\">nextElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UnsupportedOperationException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。</p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ul>\n<li>作用是将一个接口转换成另一个接口,以符合用户的期望。</li>\n</ul>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201005103843452.png\" alt=\"image-20201005103843452\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"animal\"><a href=\"#animal\" class=\"headerlink\" title=\"animal\"></a>animal</h2><pre><code class=\"java\">public interface Duck\n{\n    void quack();\n\n    void fly();\n}</code></pre>\n<pre><code class=\"java\">public class MallardDuck implements Duck\n{\n    @Override\n    public void quack()\n    {\n        System.out.println(&quot;Quack&quot;);\n    }\n\n    @Override\n    public void fly()\n    {\n        System.out.println(&quot;fly&quot;);\n    }\n}</code></pre>\n<pre><code class=\"java\">public interface Turkey\n{\n    void gobble();\n\n    void fly();\n}</code></pre>\n<pre><code class=\"java\">public class WildTurkey implements Turkey\n{\n    @Override\n    public void gobble()\n    {\n        System.out.println(&quot;Gobble&quot;);\n    }\n\n    @Override\n    public void fly()\n    {\n        System.out.println(&quot;fly short&quot;);\n    }\n}</code></pre>\n<h2 id=\"适配器\"><a href=\"#适配器\" class=\"headerlink\" title=\"适配器\"></a>适配器</h2><pre><code class=\"java\">//将火鸡适配成鸭子\npublic class TurkeyAdapter implements Duck\n{\n    Turkey turkey;\n\n    public TurkeyAdapter(Turkey turkey)\n    {\n        this.turkey = turkey;\n    }\n\n    @Override\n    public void quack()\n    {\n        turkey.gobble();\n    }\n\n    @Override\n    public void fly()\n    {\n        for (int i = 0; i &lt; 5; i++)\n        {\n            turkey.fly();\n        }\n    }\n}</code></pre>\n<h2 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client\"></a>Client</h2><pre><code class=\"java\">public class DuckTestDrive\n{\n    public static void main(String[] args)\n    {\n        WildTurkey wildTurkey = new WildTurkey();\n        TurkeyAdapter turkeyAdapter = new TurkeyAdapter(wildTurkey);\n        testDuck(turkeyAdapter);\n    }\n\n    public static void testDuck(Duck duck)\n    {\n        duck.quack();\n        duck.fly();\n    }\n}</code></pre>\n<h1 id=\"迭代器适配器\"><a href=\"#迭代器适配器\" class=\"headerlink\" title=\"迭代器适配器\"></a>迭代器适配器</h1><pre><code class=\"java\">public class EnumeratorIterator implements Iterator\n{\n    Enumeration enumeration;\n\n    public EnumeratorIterator(Enumeration enumeration)\n    {\n        this.enumeration = enumeration;\n    }\n\n    @Override\n    public boolean hasNext()\n    {\n        return enumeration.hasMoreElements();\n    }\n\n    @Override\n    public Object next()\n    {\n        return enumeration.nextElement();\n    }\n\n    @Override\n    public void remove()\n    {\n        throw new UnsupportedOperationException();\n    }\n\n}</code></pre>\n"},{"title":"数据结构项目-------两个有序链表序列的交集","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习数据结构项目--两个有序链表序列的交集所写的文档","abbrlink":"26a57fef","date":"2020-01-02T16:00:00.000Z","_content":"\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n>   两个有序链表序列的交集\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1功能要求\n\n>   已知两个非降序链表序列S1和S2，设计函数构造出S1和S2的交集新链表S3。\n\n1.  输入说明：输入分2行，分别在每行给出由若干个正整数构成的非降序序列，用-1表示序列的结尾（-1不属于这个序列）。数字用空格间隔。\n\n2.  输出说明：在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。\n\n3.  测试用例：\n\n| 序号 | 输入                      | 输出      | 说明                           |\n|------|---------------------------|-----------|--------------------------------|\n| 1    | 1 2 5 -1 2 4 5 8 10 -1    | 2 5       | 一般情况                       |\n| 2    | 1 3 5 -1 2 4 6 8 10 -1    | NULL      | 交集为空的情况                 |\n| 3    | 1 2 3 4 5 -1 1 2 3 4 5 -1 | 1 2 3 4 5 | 完全相交的情况                 |\n| 4    | 3 5 7 -1 2 3 4 5 6 7 8 -1 | 3 5 7     | 其中一个序列完全属于交集的情况 |\n| 5    | \\-1 10 100 1000 -1        | NULL      | 其中一个序列为空的情况         |\n\n## 1.2 功能分析\n\n首先需要构造两条链表分别存储所给的两列信息，然后从链表头开始逐渐对比，并且把相同的元素打印显示，直到走到其中一个链表的尽头。\n\n# 2 设计与实现\n\n## 2.1 Node类设计与实现\n\nNode类为LinkedList的基础节点，是一个模板类。它能够存储一个T类型的值以及一个指向下一Node节点的next成员变量。\n\ntemplate \\<class T\\> class Node  \n{  \npublic:  \n\nNode(const T & value, Node\\<T\\> \\*next= nullptr) : value(value), next(next) {}  \nNode(Node\\<T\\> \\*next= nullptr) : next(next) {}  \n\nT value;  \nNode\\<T\\> \\*next;  \n};\n\n## 2.2 LinkedList类设计与实现\n\n模板类，有两个Node类型的成员变量first以及last，分别指向链表头和末尾。\n\n只有一个add（）函数，负责将数据加入链表中。添加的过程是：如果头尾指针都为空的话，就让头尾指针指向这个元素，否则就在尾指针之后添加这个元素，并且让尾指针指向它。（而且如果first-\\>next为空，得让它指向last，不这样的话first只是一个单独的节点，和后续节点没有产生联系）。\n\ntemplate\\<class T\\>class LinkedList  \n{  \npublic:  \nLinkedList():first(nullptr),last(nullptr)  \n{  \n\n}  \nvoid add(T t)  \n{  \nif(first== nullptr && last== nullptr)  \n{  \nfirst = new Node\\<T\\>(t, nullptr);  \nlast = new Node\\<T\\>(t, nullptr);  \n}  \nelse  \n{  \nNode\\<T\\> \\*temp = new Node\\<T\\>(t, nullptr);  \nlast-\\>next = temp;  \nlast=last-\\>next;  \nif(first-\\>next== nullptr)  \n{  \nfirst-\\>next = last;  \n}  \n}  \n}  \n\nNode\\<T\\> \\* first;  \nNode\\<T\\> \\* last;  \n};\n\n## 2.3 主函数设计与实现\n\n首先使用LinkedList类创建两个链表，然后让用户输入两行数字。一开始让用户输入的数字通过LinkedList的add函数加入到第一个链表里面，如果输入的数字中遇到了-1，那么通过一个bool类型的变量控制使得之后输入的数字放入第二个链表中，直到输入结束。（-1不管是哪个链表都不存）\n\n之后用cur1，cur2分别指向两个链表的开头，并且通过一个bool类型的hasPrint控制如果他们没有相同的元素（即没有进入打印的那个if语句）就打印一个NULL。因为是两个非降序的链表，所以我们只需要不断的比较两个链表的头节点（这里即是cur1，cur2），如果他们值相等，就打印出来，并且让任意一个链表头节点指向他的下一个节点即可（这里是cur1）。如果他们不等，那么就让较小的那个节点指向他的下一个节点，然后通过循环判断他们两个是否为空，并且开始下一轮的比较。因为每一次比较之前都会判断他们是否为空，且每一次比较不管是相等还是不等，都会有且仅有一个链表的指针向下移动一位，且之后又会判断他们两个链表是否为空，所以这样比较是安全的且时间复杂度最低的。直到其中一条链表为空后，退出循环，并且由用户决定是否退出。\n\nint main()  \n{  \nLinkedList\\<int\\> list1, list2;  \ncout\\<\\<\"输入两行数字:\";  \nint index;  \nbool goFirst = true;  \nwhile(cin\\>\\>index)  \n{  \nif(index==-1)  \n{  \ngoFirst=false;  \n}  \nelse if(goFirst)//-1都不需要  \n{  \nlist1.add(index);  \n}  \nelse if(!goFirst)  \n{  \nlist2.add(index);  \n}  \n}  \nNode\\<int\\> \\* cur1 = list1.first;  \nNode\\<int\\> \\* cur2 = list2.first;  \nbool hasPrint = false;  \nwhile(cur1 && cur2)  \n{  \nif(cur1-\\>value\\<cur2-\\>value)  \n{  \ncur1 = cur1-\\>next;  \n}  \nelse if(cur1-\\>value\\>cur2-\\>value)  \n{  \ncur2 = cur2-\\>next;  \n}  \nelse  \n{  \nhasPrint=true;  \ncout \\<\\< cur1-\\>value \\<\\< \" \";  \ncur1 = cur1-\\>next;  \n}  \n}  \nif(!hasPrint)  \n{  \ncout \\<\\< \"NULL\";  \n}  \ncout \\<\\<endl\\<\\< \"退出请右上角关闭\";  \nwhile (true)  \n{  \n}  \nreturn 0;  \n}\n\n# 3 测试\n\n## 3.1 功能测试\n\n### 3.1.1 测试1\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/df3992008c5716e731013e43a769fb81.png)\n\n### 3.1.2 测试2\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/317c26eae9e859ef02ee442ccf8b2a71.png)\n\n### 3.1.3 测试3\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2c8202f66b12a866a87f652e3c7a4b4e.png)\n\n### 3.1.4 测试4\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ff9b9e261ef518b1227f0402db4f382f.png)\n\n## 3.2 边界测试\n\n### 3.2.1 其中一个链表为空\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/c37fe287c385b262cf8f3a28cfcb2c5e.png)\n\n### 3.2.2 两个链表为空\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/317c079ca88e74d0d4b5d8bace94889b.png)\n","source":"_posts/项目笔记/dataStructureProjects/两个有序链表序列的交集.md","raw":"---\ntitle: 数据结构项目-------两个有序链表序列的交集\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 学习数据结构项目--两个有序链表序列的交集所写的文档\ncategories: 项目文档\ntags:\n  - 数据结构\n  - 链表\n  - c++\nabbrlink: 26a57fef\ndate: 2020-01-03 00:00:00\n---\n\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n>   两个有序链表序列的交集\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1功能要求\n\n>   已知两个非降序链表序列S1和S2，设计函数构造出S1和S2的交集新链表S3。\n\n1.  输入说明：输入分2行，分别在每行给出由若干个正整数构成的非降序序列，用-1表示序列的结尾（-1不属于这个序列）。数字用空格间隔。\n\n2.  输出说明：在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。\n\n3.  测试用例：\n\n| 序号 | 输入                      | 输出      | 说明                           |\n|------|---------------------------|-----------|--------------------------------|\n| 1    | 1 2 5 -1 2 4 5 8 10 -1    | 2 5       | 一般情况                       |\n| 2    | 1 3 5 -1 2 4 6 8 10 -1    | NULL      | 交集为空的情况                 |\n| 3    | 1 2 3 4 5 -1 1 2 3 4 5 -1 | 1 2 3 4 5 | 完全相交的情况                 |\n| 4    | 3 5 7 -1 2 3 4 5 6 7 8 -1 | 3 5 7     | 其中一个序列完全属于交集的情况 |\n| 5    | \\-1 10 100 1000 -1        | NULL      | 其中一个序列为空的情况         |\n\n## 1.2 功能分析\n\n首先需要构造两条链表分别存储所给的两列信息，然后从链表头开始逐渐对比，并且把相同的元素打印显示，直到走到其中一个链表的尽头。\n\n# 2 设计与实现\n\n## 2.1 Node类设计与实现\n\nNode类为LinkedList的基础节点，是一个模板类。它能够存储一个T类型的值以及一个指向下一Node节点的next成员变量。\n\ntemplate \\<class T\\> class Node  \n{  \npublic:  \n\nNode(const T & value, Node\\<T\\> \\*next= nullptr) : value(value), next(next) {}  \nNode(Node\\<T\\> \\*next= nullptr) : next(next) {}  \n\nT value;  \nNode\\<T\\> \\*next;  \n};\n\n## 2.2 LinkedList类设计与实现\n\n模板类，有两个Node类型的成员变量first以及last，分别指向链表头和末尾。\n\n只有一个add（）函数，负责将数据加入链表中。添加的过程是：如果头尾指针都为空的话，就让头尾指针指向这个元素，否则就在尾指针之后添加这个元素，并且让尾指针指向它。（而且如果first-\\>next为空，得让它指向last，不这样的话first只是一个单独的节点，和后续节点没有产生联系）。\n\ntemplate\\<class T\\>class LinkedList  \n{  \npublic:  \nLinkedList():first(nullptr),last(nullptr)  \n{  \n\n}  \nvoid add(T t)  \n{  \nif(first== nullptr && last== nullptr)  \n{  \nfirst = new Node\\<T\\>(t, nullptr);  \nlast = new Node\\<T\\>(t, nullptr);  \n}  \nelse  \n{  \nNode\\<T\\> \\*temp = new Node\\<T\\>(t, nullptr);  \nlast-\\>next = temp;  \nlast=last-\\>next;  \nif(first-\\>next== nullptr)  \n{  \nfirst-\\>next = last;  \n}  \n}  \n}  \n\nNode\\<T\\> \\* first;  \nNode\\<T\\> \\* last;  \n};\n\n## 2.3 主函数设计与实现\n\n首先使用LinkedList类创建两个链表，然后让用户输入两行数字。一开始让用户输入的数字通过LinkedList的add函数加入到第一个链表里面，如果输入的数字中遇到了-1，那么通过一个bool类型的变量控制使得之后输入的数字放入第二个链表中，直到输入结束。（-1不管是哪个链表都不存）\n\n之后用cur1，cur2分别指向两个链表的开头，并且通过一个bool类型的hasPrint控制如果他们没有相同的元素（即没有进入打印的那个if语句）就打印一个NULL。因为是两个非降序的链表，所以我们只需要不断的比较两个链表的头节点（这里即是cur1，cur2），如果他们值相等，就打印出来，并且让任意一个链表头节点指向他的下一个节点即可（这里是cur1）。如果他们不等，那么就让较小的那个节点指向他的下一个节点，然后通过循环判断他们两个是否为空，并且开始下一轮的比较。因为每一次比较之前都会判断他们是否为空，且每一次比较不管是相等还是不等，都会有且仅有一个链表的指针向下移动一位，且之后又会判断他们两个链表是否为空，所以这样比较是安全的且时间复杂度最低的。直到其中一条链表为空后，退出循环，并且由用户决定是否退出。\n\nint main()  \n{  \nLinkedList\\<int\\> list1, list2;  \ncout\\<\\<\"输入两行数字:\";  \nint index;  \nbool goFirst = true;  \nwhile(cin\\>\\>index)  \n{  \nif(index==-1)  \n{  \ngoFirst=false;  \n}  \nelse if(goFirst)//-1都不需要  \n{  \nlist1.add(index);  \n}  \nelse if(!goFirst)  \n{  \nlist2.add(index);  \n}  \n}  \nNode\\<int\\> \\* cur1 = list1.first;  \nNode\\<int\\> \\* cur2 = list2.first;  \nbool hasPrint = false;  \nwhile(cur1 && cur2)  \n{  \nif(cur1-\\>value\\<cur2-\\>value)  \n{  \ncur1 = cur1-\\>next;  \n}  \nelse if(cur1-\\>value\\>cur2-\\>value)  \n{  \ncur2 = cur2-\\>next;  \n}  \nelse  \n{  \nhasPrint=true;  \ncout \\<\\< cur1-\\>value \\<\\< \" \";  \ncur1 = cur1-\\>next;  \n}  \n}  \nif(!hasPrint)  \n{  \ncout \\<\\< \"NULL\";  \n}  \ncout \\<\\<endl\\<\\< \"退出请右上角关闭\";  \nwhile (true)  \n{  \n}  \nreturn 0;  \n}\n\n# 3 测试\n\n## 3.1 功能测试\n\n### 3.1.1 测试1\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/df3992008c5716e731013e43a769fb81.png)\n\n### 3.1.2 测试2\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/317c26eae9e859ef02ee442ccf8b2a71.png)\n\n### 3.1.3 测试3\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2c8202f66b12a866a87f652e3c7a4b4e.png)\n\n### 3.1.4 测试4\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ff9b9e261ef518b1227f0402db4f382f.png)\n\n## 3.2 边界测试\n\n### 3.2.1 其中一个链表为空\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/c37fe287c385b262cf8f3a28cfcb2c5e.png)\n\n### 3.2.2 两个链表为空\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/317c079ca88e74d0d4b5d8bace94889b.png)\n","slug":"项目笔记/dataStructureProjects/两个有序链表序列的交集","published":1,"updated":"2020-11-12T11:57:30.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73q00o6jotp7dh82wgv","content":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  两个有序链表序列的交集</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1功能要求\"><a href=\"#1-1功能要求\" class=\"headerlink\" title=\"1.1功能要求\"></a>1.1功能要求</h2><blockquote>\n<p>  已知两个非降序链表序列S1和S2，设计函数构造出S1和S2的交集新链表S3。</p>\n</blockquote>\n<ol>\n<li><p>输入说明：输入分2行，分别在每行给出由若干个正整数构成的非降序序列，用-1表示序列的结尾（-1不属于这个序列）。数字用空格间隔。</p>\n</li>\n<li><p>输出说明：在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p>\n</li>\n<li><p>测试用例：</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>输入</th>\n<th>输出</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>1 2 5 -1 2 4 5 8 10 -1</td>\n<td>2 5</td>\n<td>一般情况</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1 3 5 -1 2 4 6 8 10 -1</td>\n<td>NULL</td>\n<td>交集为空的情况</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1 2 3 4 5 -1 1 2 3 4 5 -1</td>\n<td>1 2 3 4 5</td>\n<td>完全相交的情况</td>\n</tr>\n<tr>\n<td>4</td>\n<td>3 5 7 -1 2 3 4 5 6 7 8 -1</td>\n<td>3 5 7</td>\n<td>其中一个序列完全属于交集的情况</td>\n</tr>\n<tr>\n<td>5</td>\n<td>-1 10 100 1000 -1</td>\n<td>NULL</td>\n<td>其中一个序列为空的情况</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-2-功能分析\"><a href=\"#1-2-功能分析\" class=\"headerlink\" title=\"1.2 功能分析\"></a>1.2 功能分析</h2><p>首先需要构造两条链表分别存储所给的两列信息，然后从链表头开始逐渐对比，并且把相同的元素打印显示，直到走到其中一个链表的尽头。</p>\n<h1 id=\"2-设计与实现\"><a href=\"#2-设计与实现\" class=\"headerlink\" title=\"2 设计与实现\"></a>2 设计与实现</h1><h2 id=\"2-1-Node类设计与实现\"><a href=\"#2-1-Node类设计与实现\" class=\"headerlink\" title=\"2.1 Node类设计与实现\"></a>2.1 Node类设计与实现</h2><p>Node类为LinkedList的基础节点，是一个模板类。它能够存储一个T类型的值以及一个指向下一Node节点的next成员变量。</p>\n<p>template &lt;class T&gt; class Node<br>{<br>public:  </p>\n<p>Node(const T &amp; value, Node&lt;T&gt; *next= nullptr) : value(value), next(next) {}<br>Node(Node&lt;T&gt; *next= nullptr) : next(next) {}  </p>\n<p>T value;<br>Node&lt;T&gt; *next;<br>};</p>\n<h2 id=\"2-2-LinkedList类设计与实现\"><a href=\"#2-2-LinkedList类设计与实现\" class=\"headerlink\" title=\"2.2 LinkedList类设计与实现\"></a>2.2 LinkedList类设计与实现</h2><p>模板类，有两个Node类型的成员变量first以及last，分别指向链表头和末尾。</p>\n<p>只有一个add（）函数，负责将数据加入链表中。添加的过程是：如果头尾指针都为空的话，就让头尾指针指向这个元素，否则就在尾指针之后添加这个元素，并且让尾指针指向它。（而且如果first-&gt;next为空，得让它指向last，不这样的话first只是一个单独的节点，和后续节点没有产生联系）。</p>\n<p>template&lt;class T&gt;class LinkedList<br>{<br>public:<br>LinkedList():first(nullptr),last(nullptr)<br>{  </p>\n<p>}<br>void add(T t)<br>{<br>if(first== nullptr &amp;&amp; last== nullptr)<br>{<br>first = new Node&lt;T&gt;(t, nullptr);<br>last = new Node&lt;T&gt;(t, nullptr);<br>}<br>else<br>{<br>Node&lt;T&gt; *temp = new Node&lt;T&gt;(t, nullptr);<br>last-&gt;next = temp;<br>last=last-&gt;next;<br>if(first-&gt;next== nullptr)<br>{<br>first-&gt;next = last;<br>}<br>}<br>}  </p>\n<p>Node&lt;T&gt; * first;<br>Node&lt;T&gt; * last;<br>};</p>\n<h2 id=\"2-3-主函数设计与实现\"><a href=\"#2-3-主函数设计与实现\" class=\"headerlink\" title=\"2.3 主函数设计与实现\"></a>2.3 主函数设计与实现</h2><p>首先使用LinkedList类创建两个链表，然后让用户输入两行数字。一开始让用户输入的数字通过LinkedList的add函数加入到第一个链表里面，如果输入的数字中遇到了-1，那么通过一个bool类型的变量控制使得之后输入的数字放入第二个链表中，直到输入结束。（-1不管是哪个链表都不存）</p>\n<p>之后用cur1，cur2分别指向两个链表的开头，并且通过一个bool类型的hasPrint控制如果他们没有相同的元素（即没有进入打印的那个if语句）就打印一个NULL。因为是两个非降序的链表，所以我们只需要不断的比较两个链表的头节点（这里即是cur1，cur2），如果他们值相等，就打印出来，并且让任意一个链表头节点指向他的下一个节点即可（这里是cur1）。如果他们不等，那么就让较小的那个节点指向他的下一个节点，然后通过循环判断他们两个是否为空，并且开始下一轮的比较。因为每一次比较之前都会判断他们是否为空，且每一次比较不管是相等还是不等，都会有且仅有一个链表的指针向下移动一位，且之后又会判断他们两个链表是否为空，所以这样比较是安全的且时间复杂度最低的。直到其中一条链表为空后，退出循环，并且由用户决定是否退出。</p>\n<p>int main()<br>{<br>LinkedList&lt;int&gt; list1, list2;<br>cout&lt;&lt;“输入两行数字:”;<br>int index;<br>bool goFirst = true;<br>while(cin&gt;&gt;index)<br>{<br>if(index==-1)<br>{<br>goFirst=false;<br>}<br>else if(goFirst)//-1都不需要<br>{<br>list1.add(index);<br>}<br>else if(!goFirst)<br>{<br>list2.add(index);<br>}<br>}<br>Node&lt;int&gt; * cur1 = list1.first;<br>Node&lt;int&gt; * cur2 = list2.first;<br>bool hasPrint = false;<br>while(cur1 &amp;&amp; cur2)<br>{<br>if(cur1-&gt;value&lt;cur2-&gt;value)<br>{<br>cur1 = cur1-&gt;next;<br>}<br>else if(cur1-&gt;value&gt;cur2-&gt;value)<br>{<br>cur2 = cur2-&gt;next;<br>}<br>else<br>{<br>hasPrint=true;<br>cout &lt;&lt; cur1-&gt;value &lt;&lt; “ “;<br>cur1 = cur1-&gt;next;<br>}<br>}<br>if(!hasPrint)<br>{<br>cout &lt;&lt; “NULL”;<br>}<br>cout &lt;&lt;endl&lt;&lt; “退出请右上角关闭”;<br>while (true)<br>{<br>}<br>return 0;<br>}</p>\n<h1 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3 测试\"></a>3 测试</h1><h2 id=\"3-1-功能测试\"><a href=\"#3-1-功能测试\" class=\"headerlink\" title=\"3.1 功能测试\"></a>3.1 功能测试</h2><h3 id=\"3-1-1-测试1\"><a href=\"#3-1-1-测试1\" class=\"headerlink\" title=\"3.1.1 测试1\"></a>3.1.1 测试1</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/df3992008c5716e731013e43a769fb81.png\"></p>\n<h3 id=\"3-1-2-测试2\"><a href=\"#3-1-2-测试2\" class=\"headerlink\" title=\"3.1.2 测试2\"></a>3.1.2 测试2</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/317c26eae9e859ef02ee442ccf8b2a71.png\"></p>\n<h3 id=\"3-1-3-测试3\"><a href=\"#3-1-3-测试3\" class=\"headerlink\" title=\"3.1.3 测试3\"></a>3.1.3 测试3</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2c8202f66b12a866a87f652e3c7a4b4e.png\"></p>\n<h3 id=\"3-1-4-测试4\"><a href=\"#3-1-4-测试4\" class=\"headerlink\" title=\"3.1.4 测试4\"></a>3.1.4 测试4</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ff9b9e261ef518b1227f0402db4f382f.png\"></p>\n<h2 id=\"3-2-边界测试\"><a href=\"#3-2-边界测试\" class=\"headerlink\" title=\"3.2 边界测试\"></a>3.2 边界测试</h2><h3 id=\"3-2-1-其中一个链表为空\"><a href=\"#3-2-1-其中一个链表为空\" class=\"headerlink\" title=\"3.2.1 其中一个链表为空\"></a>3.2.1 其中一个链表为空</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/c37fe287c385b262cf8f3a28cfcb2c5e.png\"></p>\n<h3 id=\"3-2-2-两个链表为空\"><a href=\"#3-2-2-两个链表为空\" class=\"headerlink\" title=\"3.2.2 两个链表为空\"></a>3.2.2 两个链表为空</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/317c079ca88e74d0d4b5d8bace94889b.png\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  两个有序链表序列的交集</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1功能要求\"><a href=\"#1-1功能要求\" class=\"headerlink\" title=\"1.1功能要求\"></a>1.1功能要求</h2><blockquote>\n<p>  已知两个非降序链表序列S1和S2，设计函数构造出S1和S2的交集新链表S3。</p>\n</blockquote>\n<ol>\n<li><p>输入说明：输入分2行，分别在每行给出由若干个正整数构成的非降序序列，用-1表示序列的结尾（-1不属于这个序列）。数字用空格间隔。</p>\n</li>\n<li><p>输出说明：在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p>\n</li>\n<li><p>测试用例：</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>输入</th>\n<th>输出</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>1 2 5 -1 2 4 5 8 10 -1</td>\n<td>2 5</td>\n<td>一般情况</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1 3 5 -1 2 4 6 8 10 -1</td>\n<td>NULL</td>\n<td>交集为空的情况</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1 2 3 4 5 -1 1 2 3 4 5 -1</td>\n<td>1 2 3 4 5</td>\n<td>完全相交的情况</td>\n</tr>\n<tr>\n<td>4</td>\n<td>3 5 7 -1 2 3 4 5 6 7 8 -1</td>\n<td>3 5 7</td>\n<td>其中一个序列完全属于交集的情况</td>\n</tr>\n<tr>\n<td>5</td>\n<td>-1 10 100 1000 -1</td>\n<td>NULL</td>\n<td>其中一个序列为空的情况</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-2-功能分析\"><a href=\"#1-2-功能分析\" class=\"headerlink\" title=\"1.2 功能分析\"></a>1.2 功能分析</h2><p>首先需要构造两条链表分别存储所给的两列信息，然后从链表头开始逐渐对比，并且把相同的元素打印显示，直到走到其中一个链表的尽头。</p>\n<h1 id=\"2-设计与实现\"><a href=\"#2-设计与实现\" class=\"headerlink\" title=\"2 设计与实现\"></a>2 设计与实现</h1><h2 id=\"2-1-Node类设计与实现\"><a href=\"#2-1-Node类设计与实现\" class=\"headerlink\" title=\"2.1 Node类设计与实现\"></a>2.1 Node类设计与实现</h2><p>Node类为LinkedList的基础节点，是一个模板类。它能够存储一个T类型的值以及一个指向下一Node节点的next成员变量。</p>\n<p>template &lt;class T&gt; class Node<br>{<br>public:  </p>\n<p>Node(const T &amp; value, Node&lt;T&gt; *next= nullptr) : value(value), next(next) {}<br>Node(Node&lt;T&gt; *next= nullptr) : next(next) {}  </p>\n<p>T value;<br>Node&lt;T&gt; *next;<br>};</p>\n<h2 id=\"2-2-LinkedList类设计与实现\"><a href=\"#2-2-LinkedList类设计与实现\" class=\"headerlink\" title=\"2.2 LinkedList类设计与实现\"></a>2.2 LinkedList类设计与实现</h2><p>模板类，有两个Node类型的成员变量first以及last，分别指向链表头和末尾。</p>\n<p>只有一个add（）函数，负责将数据加入链表中。添加的过程是：如果头尾指针都为空的话，就让头尾指针指向这个元素，否则就在尾指针之后添加这个元素，并且让尾指针指向它。（而且如果first-&gt;next为空，得让它指向last，不这样的话first只是一个单独的节点，和后续节点没有产生联系）。</p>\n<p>template&lt;class T&gt;class LinkedList<br>{<br>public:<br>LinkedList():first(nullptr),last(nullptr)<br>{  </p>\n<p>}<br>void add(T t)<br>{<br>if(first== nullptr &amp;&amp; last== nullptr)<br>{<br>first = new Node&lt;T&gt;(t, nullptr);<br>last = new Node&lt;T&gt;(t, nullptr);<br>}<br>else<br>{<br>Node&lt;T&gt; *temp = new Node&lt;T&gt;(t, nullptr);<br>last-&gt;next = temp;<br>last=last-&gt;next;<br>if(first-&gt;next== nullptr)<br>{<br>first-&gt;next = last;<br>}<br>}<br>}  </p>\n<p>Node&lt;T&gt; * first;<br>Node&lt;T&gt; * last;<br>};</p>\n<h2 id=\"2-3-主函数设计与实现\"><a href=\"#2-3-主函数设计与实现\" class=\"headerlink\" title=\"2.3 主函数设计与实现\"></a>2.3 主函数设计与实现</h2><p>首先使用LinkedList类创建两个链表，然后让用户输入两行数字。一开始让用户输入的数字通过LinkedList的add函数加入到第一个链表里面，如果输入的数字中遇到了-1，那么通过一个bool类型的变量控制使得之后输入的数字放入第二个链表中，直到输入结束。（-1不管是哪个链表都不存）</p>\n<p>之后用cur1，cur2分别指向两个链表的开头，并且通过一个bool类型的hasPrint控制如果他们没有相同的元素（即没有进入打印的那个if语句）就打印一个NULL。因为是两个非降序的链表，所以我们只需要不断的比较两个链表的头节点（这里即是cur1，cur2），如果他们值相等，就打印出来，并且让任意一个链表头节点指向他的下一个节点即可（这里是cur1）。如果他们不等，那么就让较小的那个节点指向他的下一个节点，然后通过循环判断他们两个是否为空，并且开始下一轮的比较。因为每一次比较之前都会判断他们是否为空，且每一次比较不管是相等还是不等，都会有且仅有一个链表的指针向下移动一位，且之后又会判断他们两个链表是否为空，所以这样比较是安全的且时间复杂度最低的。直到其中一条链表为空后，退出循环，并且由用户决定是否退出。</p>\n<p>int main()<br>{<br>LinkedList&lt;int&gt; list1, list2;<br>cout&lt;&lt;“输入两行数字:”;<br>int index;<br>bool goFirst = true;<br>while(cin&gt;&gt;index)<br>{<br>if(index==-1)<br>{<br>goFirst=false;<br>}<br>else if(goFirst)//-1都不需要<br>{<br>list1.add(index);<br>}<br>else if(!goFirst)<br>{<br>list2.add(index);<br>}<br>}<br>Node&lt;int&gt; * cur1 = list1.first;<br>Node&lt;int&gt; * cur2 = list2.first;<br>bool hasPrint = false;<br>while(cur1 &amp;&amp; cur2)<br>{<br>if(cur1-&gt;value&lt;cur2-&gt;value)<br>{<br>cur1 = cur1-&gt;next;<br>}<br>else if(cur1-&gt;value&gt;cur2-&gt;value)<br>{<br>cur2 = cur2-&gt;next;<br>}<br>else<br>{<br>hasPrint=true;<br>cout &lt;&lt; cur1-&gt;value &lt;&lt; “ “;<br>cur1 = cur1-&gt;next;<br>}<br>}<br>if(!hasPrint)<br>{<br>cout &lt;&lt; “NULL”;<br>}<br>cout &lt;&lt;endl&lt;&lt; “退出请右上角关闭”;<br>while (true)<br>{<br>}<br>return 0;<br>}</p>\n<h1 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3 测试\"></a>3 测试</h1><h2 id=\"3-1-功能测试\"><a href=\"#3-1-功能测试\" class=\"headerlink\" title=\"3.1 功能测试\"></a>3.1 功能测试</h2><h3 id=\"3-1-1-测试1\"><a href=\"#3-1-1-测试1\" class=\"headerlink\" title=\"3.1.1 测试1\"></a>3.1.1 测试1</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/df3992008c5716e731013e43a769fb81.png\"></p>\n<h3 id=\"3-1-2-测试2\"><a href=\"#3-1-2-测试2\" class=\"headerlink\" title=\"3.1.2 测试2\"></a>3.1.2 测试2</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/317c26eae9e859ef02ee442ccf8b2a71.png\"></p>\n<h3 id=\"3-1-3-测试3\"><a href=\"#3-1-3-测试3\" class=\"headerlink\" title=\"3.1.3 测试3\"></a>3.1.3 测试3</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2c8202f66b12a866a87f652e3c7a4b4e.png\"></p>\n<h3 id=\"3-1-4-测试4\"><a href=\"#3-1-4-测试4\" class=\"headerlink\" title=\"3.1.4 测试4\"></a>3.1.4 测试4</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ff9b9e261ef518b1227f0402db4f382f.png\"></p>\n<h2 id=\"3-2-边界测试\"><a href=\"#3-2-边界测试\" class=\"headerlink\" title=\"3.2 边界测试\"></a>3.2 边界测试</h2><h3 id=\"3-2-1-其中一个链表为空\"><a href=\"#3-2-1-其中一个链表为空\" class=\"headerlink\" title=\"3.2.1 其中一个链表为空\"></a>3.2.1 其中一个链表为空</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/c37fe287c385b262cf8f3a28cfcb2c5e.png\"></p>\n<h3 id=\"3-2-2-两个链表为空\"><a href=\"#3-2-2-两个链表为空\" class=\"headerlink\" title=\"3.2.2 两个链表为空\"></a>3.2.2 两个链表为空</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/317c079ca88e74d0d4b5d8bace94889b.png\"></p>\n"},{"title":"数据结构项目-------8种排序算法的比较案例","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习数据结构项目--8种排序算法的比较案例所写的文档。","abbrlink":"8768c3df","date":"2020-01-25T16:00:00.000Z","_content":"\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n\n>   8种排序算法的比较案例\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目简介\n\n随机函数产生一百，一千，一万和十万个随机数，用快速排序，直接插入排序，冒泡排序，选择排序的排序方法排序，并统计每种排序所花费的排序时间和交换次数。其中，随机数的个数由用户定义，系统产生随机数。并且显示他们的比较次数。\n\n请在文档中记录上述数据量下，各种排序的计算时间和存储开销，并且根据实验结果说明这些方法的优缺点。\n\n## 1.2 功能分析\n\n首先,得在程序中实现了**八种排序算法**,其次,要有两个辅助函数,分别计算排序前后所花费的**时间**与排序的**比较次数**.\n\n最后,在主程序中,给用户提供界面,选择某种排序算法后,展示排序所需要的时间和比较次数.用户可以不断选择排序算法直到退出.用户也可以任意选择想排序的规模.\n\n# 2 设计\n\n## 2.1 排序算法设计\n\n八种排序算法之中,都会传入一个引用参数`exchangeTime`代表交换次数,当交换时让exchangeTime值+1.每个排序算法都会将原来的随机数组复制一遍,以免把原有的随机数组更改了.\n\n同时为了规范,数组在进行交换数据时,都会调用同一个辅助函数exch进行交换,控制了变量.为了确保已经排序,也会调用`isSorted`确保已经排序.\n\n## 2.2 辅助函数设计\n\n首先,在`SortCompare`类中,构造函数将会为它的成员变量`vec`赋予N个随机数,然后在test类中,根据用户输入的参数,选择适当的算法进行排序.且在排序的前后计时,两者相减,得到了该排序算法的用时.\n\n然后,`exch()`通过传入数组与要交换的两个位置把元素交换,`isSorted()`通过一次循环比较后方元素是否大于前方元素来确保排序,否则返回false.\n\n## 2.3 主程序设计\n\n首先,用一个数组将数字与排序算法的名字关联起来,便于查看.输出窗口打印出表格以给用户进行提示,让用户输入排序的`规模N`.随后进入循环,直到用户按9退出程序.循环中,根据用户输入,调用相应的函数,执行相应的操作,\n完成排序,并打印排序的时间与交换次数.将交换次数清零,进行下一次选择,直到用户退出.\n\n# 3 实现\n\n## 3.1 八个排序方法的实现\n\n### 3.1.1 冒泡排序\n\n两遍循环,外层循环每次将最小的元素排定,直到整个数组有序。内层循环从数组最后一个元素分别与前一个元素对比，如果小于前一个元素，将两者交换，并且使交换次数+1，一直对比到排定的元素之前，因为排定的元素一定是小于后面的所有的元素的。\n\n值得注意的是，每个排序都通过将原数组复制，并将复制后的数组temp进行排序来进行测试，并且每次排序完，都调用测试函数isSorted测试是否排序，所有排序都用了这个模式，所以之后不再赘述。\n\n```c++\noid bubbleSort(long long &exchangeTime)  \n{  \n    vector<int> temp(vec);  \n    //每次都把最小的排定  \n    for (int i = 1; i < temp.size(); ++i)  \n    {  \n        for (int j = temp.size() - 1; j >= i; --j)  \n        {  \n            if (temp[j - 1] > temp[j])  \n            {  \n                exch(temp, j, j - 1);  \n                ++exchangeTime;  \n            }  \n        }  \n    }  \n    if (!isSorted(temp))  \n    {  \n    \tcout << \"没排序!\" << endl;  \n    }  \n}\n```\n\n\n\n\n\n### 3.1.2 选择排序\n\n同样是两层循环，外层循环先让i做为最小的元素，并且通过右层循环找出数组右边最小元素的索引，然后再交换i与内层循环找到的最小元素min，并且让交换次数+1。\n\n```c++\nvoid chooseSort(long long &exchangeTime)  \n{  \n    vector<int> temp(vec);  \n    for (int i = 0; i < temp.size() - 1; ++i)  \n    {  \n        int min = i;  \n        for (int j = i + 1; j < temp.size(); ++j)  \n        {  \n            if (temp[min] > temp[j])  \n            {  \n            \tmin = j;  \n            }  \n        }  \n        exch(temp, min, i);  \n        ++exchangeTime;  \n    }  \n    if (!isSorted(temp))  \n    {  \n    \tcout << \"没排序!\" << endl;  \n    }  \n}\n```\n\n\n\n### 3.1.3 插入排序\n\n两层循环，外层循环从一开始到数组末尾。内层循环不断的将该元素j与它前面的一个元素j-1的值进行对比，如果小与索引j-1的值则交换，直到j-1\\<0了或者它的值大于索引j-1的值。算法本质就是左边一开始是一个元素，然后不断的让数组后面的元素插入到合适的位置，直到所有元素都插入，而它们也就是一个有序的数组了。\n\nvoid insertSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \nfor (int i = 1; i \\< temp.size(); ++i)  \n{  \nfor (int j = i; j - 1 \\>= 0 && temp[j] \\< temp[j - 1]; --j)  \n{  \nexch(temp, j - 1, j);  \n++exchangeTime;  \n}  \n}  \nif (!isSorted(temp))  \n{  \ncout \\<\\< \"没排序!\" \\<\\< endl;  \n}  \n}\n\n### 3.1.4 希尔排序\n\n本质上希尔排序就是插入排序的改进。先用h不断\\*3+1，直到到数组大小的三分之一，然后和插入排序的循环类似，只不过外层循环是从h开始，且内层循环每一次对比的都是j和j-h的元素，这样一次排序就形成了h有序数组，即每相隔h位置的元素形成了一个有序数组，然后最外面的循环负责不断的缩小h的值，使得形成的h越来越小，而当h=1时，即为插入排序，并且此次排序结束后循环终止。\n\n之所以要这么麻烦，是为了刚刚开始时，h大概是数组的三分之一左右，然后每一次交换都能让相对很小的元素放在很前面，不必像是插入排序一样，如果碰到最小的元素，就要一个个的比较交换，直到它到最左边的位置。\n\nvoid shellSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \n\n\nint h = 1;  \nwhile (h \\< temp.size() / 3)  \n{  \nh = 3 \\* h + 1;  \n}  \n\nwhile (h \\>= 1)  \n{  \nfor (int i = h; i \\< temp.size(); ++i)  \n{  \nfor (int j = i; j - h \\>= 0 && temp[j] \\< temp[j - h]; j -= h)  \n{  \nexch(temp, j - h, j);  \n++exchangeTime;  \n}  \n}  \nh /= 3;  \n}\n\n### 3.1.5 快速排序\n\n用了额外的两个辅助函数，每次排序，先调用辅助函数partition，它将返回一个索引j，且保证了j的左边元素都小于它，而它的右边元素都大于或等于它。然后继续递归地将左边的数组排序，将右边的数组排序，直到只有一个元素时返回。因为每次调用，j的位置都是排定的，所以通过归纳法可知最后数组一定排序好了。\n\nPartition函数具体实现则是：先将传入的第一个元素（传入的元素不一定就是数组的首元素，而是要排序的子数组的第一个元素，用lo标定）定为v，用i，j指向该要排序的数组，然后i不断的向右扫描，j不断的向左扫描，如果i找到了大于等于v的元素，j找到了小于等于它的元素，则将他们两个交换。重复扫描直到i\\>=j或者i到了数组末尾，或者j到达数组开头。此时可知索引j的元素肯定是小于v的，而i一定是大于v的，此时只要交换索引j和首元素，再返回索引j，即实现了j左边都是小于它的而右边都是大于等于它的。\n\nvoid quickSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \n\n//因为本来就是乱的,所以不用打乱了  \nquickSort(temp, 0, temp.size() - 1, exchangeTime);  \n\nif (!isSorted(temp))  \n{  \ncout \\<\\< \"没排序!\" \\<\\< endl;  \n}  \n}\n\nvoid quickSort(vector\\<int\\> &temp, int lo, int hi, long long &exchangeTime)  \n{  \nif (hi \\<= lo)  \n{  \nreturn;  \n}  \nint j = partition(temp, lo, hi, exchangeTime);  \nquickSort(temp, lo, j - 1, exchangeTime);  \nquickSort(temp, j + 1, hi, exchangeTime);  \n}\n\nint partition(vector\\<int\\> &temp, int lo, int hi, long long &exchangeTime)  \n{  \nint i = lo, j = hi + 1;  \nint v = temp[lo];  \nwhile (true)  \n{  \nwhile (temp[++i] \\< v) if (i == hi) break;  \nwhile (v \\< temp[--j]) if (j == lo) break;  \nif (i \\>= j)  \nbreak;  \nexch(temp, i, j);  \n++exchangeTime;  \n}  \nexch(temp, lo, j);  \n++exchangeTime;  \nreturn j;  \n}\n\n### 3.1.6 堆排序\n\n首先构造一个堆，从数组长度/2的位置直到第一个元素进行构建，因为数组长度/2到数组末尾的可以直接作为堆底，不用构建了，所谓构建，就是对每一个索引i调用sink函数，直觉上来说就是把大的元素放上面，小的放下面。然后排序阶段，将数组最后一个元素与第一个交换，即将堆最大的元素放再数组末端，然后对数组首元素进行sink操作，来保证堆的有序性。N--，不断这样操作直到N==1，意味着数组已经排序。\n\nSink函数主要是将元素下沉，即通过对比该元素k与它的下一层2\\*k与2\\*k+1中较大的一个，如果k小于它的下一层，则交换，且让它等于2\\*k或者2\\*k+1，不断比较交换，直到到堆末尾或者它大于它下一层的较大的元素。\n\nvoid heapSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \nint N = temp.size();  \ntemp.insert(temp.begin(), -1);//temp[0]不用  \n//构造堆  \nfor (int k = N/2; k \\>= 1 ; --k)  \n{  \nsink(temp, k, N,exchangeTime);  \n}  \n//排序  \nwhile(N\\>1)  \n{  \nexch(temp, 1, N--);  \n++exchangeTime;  \nsink(temp, 1, N,exchangeTime);  \n}  \n\n\nif (!isSorted(temp))  \n{  \ncout \\<\\< \"没排序!\" \\<\\< endl;  \n}  \n}\n\nvoid sink(vector\\<int\\> &temp, int k, int N, long long &exchangeTime)  \n{  \nwhile(2\\*k\\<=N)  \n{  \nint j = 2 \\* k;  \nif(j+1\\<=N && temp[j+1]\\>temp[j])  \n{  \n++j;  \n}  \nif(temp[k]\\>temp[j])  \n{  \nbreak;  \n}  \nexch(temp, k, j);  \nk = j;  \n++exchangeTime;  \n}  \n}\n\n### 3.1.7 归并排序\n\n总的来说，是用了分治法的思路，即，首先将左边一半数组排序，右一半数组排序。然后将两个排序的数组进行归并。而将左右两边数组排序是采用递归的思路，例如将左边的一半数组排序，则为将左边的数组的左一半数组排序，右一半数组排序，再将之合并。归并到最后的结果就是，如果有一个子数组只有一个或者没有元素就返回，这时算是已经排序了的。然后将之不断合并。一直到整个数组合并为一个有序数组。\n\n合并两个有序算法调用了一个辅助函数merge，思路很简单，即为用两个索引分别指向他们两个数组的开头，然后比较这两个索引的元素，存储结果的数组存储较小的那个元素，然后对于的索引+1，一直对比到其中的一个索引指向了那个数组的尽头。此时，结果数组直接全部存储剩余那个数组的剩余元素即可。\n\nvoid mergeSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \n\nvector\\<int\\> aux(vec.size());//辅助数组  \n\nmergeSort(temp, aux, 0, temp.size() - 1, exchangeTime);  \n\nif (!isSorted(temp))  \n{  \ncout \\<\\< \"没排序!\" \\<\\< endl;  \n}  \n}\n\nvoid mergeSort(vector\\<int\\> &temp, vector\\<int\\> &aux, int lo, int hi, long\nlong &exchangeTime)  \n{  \nif (hi \\<= lo)  \n{  \nreturn;  \n}  \nint mid = lo + (hi - lo) / 2;  \nmergeSort(temp, aux, lo, mid, exchangeTime);  \nmergeSort(temp, aux, mid + 1, hi, exchangeTime);  \n\nmerge(temp, aux, lo, mid, hi, exchangeTime);  \n}\n\nvoid merge(vector\\<int\\> &temp, vector\\<int\\> &aux, int lo, int mid, int hi,\nlong long &exchangeTime)  \n{  \n//mid左右两边已经拍好了序  \nint i = lo, j = mid + 1;  \nfor (int k = lo; k \\<= hi; ++k)  \n{  \naux[k] = temp[k];  \n}  \nfor (int k = lo; k \\<= hi; ++k)  \n{  \n//上面两个不进行比较  \nif (i \\> mid) temp[k] = aux[j++];  \nelse if (j \\> hi) temp[k] = aux[i++];  \nelse if (aux[j] \\< aux[i])  \n{  \ntemp[k] = aux[j++];  \n++exchangeTime;  \n}  \nelse  \n{  \ntemp[k] = aux[i++];  \n++exchangeTime;  \n}  \n}  \n}\n\n### 3.1.8 基数排序\n\n本质上是低位优先的字符串排序，所以首先得到数组的元素中最大元素的位数。然后对每一位进行一次排序，因为如果前一位的不同，则它们肯定能排序，而前一位的相同，它是稳定的放入，而后一位已经排序好了，所以可以直到从低位往高位不断排序直到最后一定能排序好。\n\n外层循环对每一位进行排序，而排序具体实现是：首先统计每个元素在这一位中0-9出现的个数，然后通过刚刚统计的元素个数，计算得到每一个元素放入辅助数组的开始的索引，然后对于每一个元素放入辅助数组相应的位置，就是通过查看元素这一位的值，在辅助数组找到相应的索引位置放入，并让该索引位置+1。直到把所有元素放入，即为将这一位的所有元素进行排序了。\n\nvoid radixSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \nvector\\<int\\> aux(temp);  \n\nint N = temp.size();  \nint R = 10;//一共只有0-9  \nint digit = getDigit(temp);  \nint base = 1;//目的是得到一个数的某一位的数,如得到123中的2  \n//0表示个位  \nfor (int d = 0; d \\< digit; ++d)  \n{  \nvector\\<int\\> count(R + 1);//计算出现的频率  \nfor (int i = 0; i \\< N; ++i)  \n{  \n//就算有一些的位数不够也没有关系,因为这样会是0,还是会排序  \nint index = temp[i] / base % 10;//第一次得到是个位,第二次是十位..  \ncount[index + 1]++;  \n}  \nfor (int r = 0; r \\< R; ++r)//将频率转换为索引  \n{  \ncount[r + 1] += count[r];  \n}  \nfor (int i = 0; i \\< N; ++i)//将元素分类  \n{  \nint index = temp[i] / base % 10;  \naux[count[index]++] = temp[i];  \n}  \nfor (int i = 0; i \\< N; ++i)//回写  \n{  \ntemp[i] = aux[i];  \n}  \nbase \\*= 10;//不断处理高位  \n}  \nif (!isSorted(temp))  \n{  \ncout \\<\\< \"没排序!\" \\<\\< endl;  \n}  \n}\n\nint getDigit(const vector\\<int\\> & temp)  \n{  \nint digit = 1;  \nint base = 10;  \nfor (int i = 0; i \\< temp.size(); ++i)  \n{  \nwhile(base\\<=temp[i])  \n{  \nbase \\*= 10;  \n++digit;  \n}  \n}  \nreturn digit;  \n}\n\n## 3.2 辅助函数功能的实现\n\n### 3.2.1 exch函数\n\nvoid exch(vector\\<int\\> &cur, int i, int j)  \n{  \nint temp = cur[i];  \ncur[i] = cur[j];  \ncur[j] = temp;  \n}\n\n### 3.2.2 isSorted函数\n\nbool isSorted(vector\\<int\\> &cur)  \n{  \nfor (int i = 0; i \\< cur.size() - 1; ++i)  \nif (cur[i + 1] \\< cur[i])  \nreturn false;  \nreturn true;  \n}\n\n## 3.3 总体系统的实现\n\n进入一个循环,根据用户输入,调用不同的排序算法进行排序测试,并且打印测试时间与比较次数,随后重置排序时间并且进行下一次比较。\n\n核心代码：\n\nwhile(true)  \n{  \ncout \\<\\< \"请选择排序算法:\";  \ncin \\>\\> whichSort;  \nif(whichSort==9)  \n{  \nbreak;  \n}  \nsortCompare.test(whichSort, sortTime, exchangeTime);  \ncout\\<\\<changeIndex[whichSort]\\<\\<\"所用时间:\"\\<\\<sortTime\\<\\<\"s\"\\<\\<endl;  \n//归并排序不进行两两交换,所以看比较次数  \nif(whichSort==7)  \ncout\\<\\<changeIndex[whichSort]\\<\\<\"比较次数：\"\\<\\<exchangeTime\\<\\<endl;  \nelse  \ncout\\<\\<changeIndex[whichSort]\\<\\<\"交换次数：\"\\<\\<exchangeTime\\<\\<endl;  \n//重置  \nsortTime = 0.0;  \nexchangeTime = 0;  \n}\n\n# 4 测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/614ad45ef223ce1115095cf56364944c.png)\n","source":"_posts/项目笔记/dataStructureProjects/8种排序算法的比较案例.md","raw":"---\ntitle: 数据结构项目-------8种排序算法的比较案例\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 学习数据结构项目--8种排序算法的比较案例所写的文档。\ncategories: 项目文档\ntags:\n  - 数据结构\n  - 排序算法\n  - 快速排序\nabbrlink: 8768c3df\ndate: 2020-01-26 00:00:00\n---\n\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n\n>   8种排序算法的比较案例\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目简介\n\n随机函数产生一百，一千，一万和十万个随机数，用快速排序，直接插入排序，冒泡排序，选择排序的排序方法排序，并统计每种排序所花费的排序时间和交换次数。其中，随机数的个数由用户定义，系统产生随机数。并且显示他们的比较次数。\n\n请在文档中记录上述数据量下，各种排序的计算时间和存储开销，并且根据实验结果说明这些方法的优缺点。\n\n## 1.2 功能分析\n\n首先,得在程序中实现了**八种排序算法**,其次,要有两个辅助函数,分别计算排序前后所花费的**时间**与排序的**比较次数**.\n\n最后,在主程序中,给用户提供界面,选择某种排序算法后,展示排序所需要的时间和比较次数.用户可以不断选择排序算法直到退出.用户也可以任意选择想排序的规模.\n\n# 2 设计\n\n## 2.1 排序算法设计\n\n八种排序算法之中,都会传入一个引用参数`exchangeTime`代表交换次数,当交换时让exchangeTime值+1.每个排序算法都会将原来的随机数组复制一遍,以免把原有的随机数组更改了.\n\n同时为了规范,数组在进行交换数据时,都会调用同一个辅助函数exch进行交换,控制了变量.为了确保已经排序,也会调用`isSorted`确保已经排序.\n\n## 2.2 辅助函数设计\n\n首先,在`SortCompare`类中,构造函数将会为它的成员变量`vec`赋予N个随机数,然后在test类中,根据用户输入的参数,选择适当的算法进行排序.且在排序的前后计时,两者相减,得到了该排序算法的用时.\n\n然后,`exch()`通过传入数组与要交换的两个位置把元素交换,`isSorted()`通过一次循环比较后方元素是否大于前方元素来确保排序,否则返回false.\n\n## 2.3 主程序设计\n\n首先,用一个数组将数字与排序算法的名字关联起来,便于查看.输出窗口打印出表格以给用户进行提示,让用户输入排序的`规模N`.随后进入循环,直到用户按9退出程序.循环中,根据用户输入,调用相应的函数,执行相应的操作,\n完成排序,并打印排序的时间与交换次数.将交换次数清零,进行下一次选择,直到用户退出.\n\n# 3 实现\n\n## 3.1 八个排序方法的实现\n\n### 3.1.1 冒泡排序\n\n两遍循环,外层循环每次将最小的元素排定,直到整个数组有序。内层循环从数组最后一个元素分别与前一个元素对比，如果小于前一个元素，将两者交换，并且使交换次数+1，一直对比到排定的元素之前，因为排定的元素一定是小于后面的所有的元素的。\n\n值得注意的是，每个排序都通过将原数组复制，并将复制后的数组temp进行排序来进行测试，并且每次排序完，都调用测试函数isSorted测试是否排序，所有排序都用了这个模式，所以之后不再赘述。\n\n```c++\noid bubbleSort(long long &exchangeTime)  \n{  \n    vector<int> temp(vec);  \n    //每次都把最小的排定  \n    for (int i = 1; i < temp.size(); ++i)  \n    {  \n        for (int j = temp.size() - 1; j >= i; --j)  \n        {  \n            if (temp[j - 1] > temp[j])  \n            {  \n                exch(temp, j, j - 1);  \n                ++exchangeTime;  \n            }  \n        }  \n    }  \n    if (!isSorted(temp))  \n    {  \n    \tcout << \"没排序!\" << endl;  \n    }  \n}\n```\n\n\n\n\n\n### 3.1.2 选择排序\n\n同样是两层循环，外层循环先让i做为最小的元素，并且通过右层循环找出数组右边最小元素的索引，然后再交换i与内层循环找到的最小元素min，并且让交换次数+1。\n\n```c++\nvoid chooseSort(long long &exchangeTime)  \n{  \n    vector<int> temp(vec);  \n    for (int i = 0; i < temp.size() - 1; ++i)  \n    {  \n        int min = i;  \n        for (int j = i + 1; j < temp.size(); ++j)  \n        {  \n            if (temp[min] > temp[j])  \n            {  \n            \tmin = j;  \n            }  \n        }  \n        exch(temp, min, i);  \n        ++exchangeTime;  \n    }  \n    if (!isSorted(temp))  \n    {  \n    \tcout << \"没排序!\" << endl;  \n    }  \n}\n```\n\n\n\n### 3.1.3 插入排序\n\n两层循环，外层循环从一开始到数组末尾。内层循环不断的将该元素j与它前面的一个元素j-1的值进行对比，如果小与索引j-1的值则交换，直到j-1\\<0了或者它的值大于索引j-1的值。算法本质就是左边一开始是一个元素，然后不断的让数组后面的元素插入到合适的位置，直到所有元素都插入，而它们也就是一个有序的数组了。\n\nvoid insertSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \nfor (int i = 1; i \\< temp.size(); ++i)  \n{  \nfor (int j = i; j - 1 \\>= 0 && temp[j] \\< temp[j - 1]; --j)  \n{  \nexch(temp, j - 1, j);  \n++exchangeTime;  \n}  \n}  \nif (!isSorted(temp))  \n{  \ncout \\<\\< \"没排序!\" \\<\\< endl;  \n}  \n}\n\n### 3.1.4 希尔排序\n\n本质上希尔排序就是插入排序的改进。先用h不断\\*3+1，直到到数组大小的三分之一，然后和插入排序的循环类似，只不过外层循环是从h开始，且内层循环每一次对比的都是j和j-h的元素，这样一次排序就形成了h有序数组，即每相隔h位置的元素形成了一个有序数组，然后最外面的循环负责不断的缩小h的值，使得形成的h越来越小，而当h=1时，即为插入排序，并且此次排序结束后循环终止。\n\n之所以要这么麻烦，是为了刚刚开始时，h大概是数组的三分之一左右，然后每一次交换都能让相对很小的元素放在很前面，不必像是插入排序一样，如果碰到最小的元素，就要一个个的比较交换，直到它到最左边的位置。\n\nvoid shellSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \n\n\nint h = 1;  \nwhile (h \\< temp.size() / 3)  \n{  \nh = 3 \\* h + 1;  \n}  \n\nwhile (h \\>= 1)  \n{  \nfor (int i = h; i \\< temp.size(); ++i)  \n{  \nfor (int j = i; j - h \\>= 0 && temp[j] \\< temp[j - h]; j -= h)  \n{  \nexch(temp, j - h, j);  \n++exchangeTime;  \n}  \n}  \nh /= 3;  \n}\n\n### 3.1.5 快速排序\n\n用了额外的两个辅助函数，每次排序，先调用辅助函数partition，它将返回一个索引j，且保证了j的左边元素都小于它，而它的右边元素都大于或等于它。然后继续递归地将左边的数组排序，将右边的数组排序，直到只有一个元素时返回。因为每次调用，j的位置都是排定的，所以通过归纳法可知最后数组一定排序好了。\n\nPartition函数具体实现则是：先将传入的第一个元素（传入的元素不一定就是数组的首元素，而是要排序的子数组的第一个元素，用lo标定）定为v，用i，j指向该要排序的数组，然后i不断的向右扫描，j不断的向左扫描，如果i找到了大于等于v的元素，j找到了小于等于它的元素，则将他们两个交换。重复扫描直到i\\>=j或者i到了数组末尾，或者j到达数组开头。此时可知索引j的元素肯定是小于v的，而i一定是大于v的，此时只要交换索引j和首元素，再返回索引j，即实现了j左边都是小于它的而右边都是大于等于它的。\n\nvoid quickSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \n\n//因为本来就是乱的,所以不用打乱了  \nquickSort(temp, 0, temp.size() - 1, exchangeTime);  \n\nif (!isSorted(temp))  \n{  \ncout \\<\\< \"没排序!\" \\<\\< endl;  \n}  \n}\n\nvoid quickSort(vector\\<int\\> &temp, int lo, int hi, long long &exchangeTime)  \n{  \nif (hi \\<= lo)  \n{  \nreturn;  \n}  \nint j = partition(temp, lo, hi, exchangeTime);  \nquickSort(temp, lo, j - 1, exchangeTime);  \nquickSort(temp, j + 1, hi, exchangeTime);  \n}\n\nint partition(vector\\<int\\> &temp, int lo, int hi, long long &exchangeTime)  \n{  \nint i = lo, j = hi + 1;  \nint v = temp[lo];  \nwhile (true)  \n{  \nwhile (temp[++i] \\< v) if (i == hi) break;  \nwhile (v \\< temp[--j]) if (j == lo) break;  \nif (i \\>= j)  \nbreak;  \nexch(temp, i, j);  \n++exchangeTime;  \n}  \nexch(temp, lo, j);  \n++exchangeTime;  \nreturn j;  \n}\n\n### 3.1.6 堆排序\n\n首先构造一个堆，从数组长度/2的位置直到第一个元素进行构建，因为数组长度/2到数组末尾的可以直接作为堆底，不用构建了，所谓构建，就是对每一个索引i调用sink函数，直觉上来说就是把大的元素放上面，小的放下面。然后排序阶段，将数组最后一个元素与第一个交换，即将堆最大的元素放再数组末端，然后对数组首元素进行sink操作，来保证堆的有序性。N--，不断这样操作直到N==1，意味着数组已经排序。\n\nSink函数主要是将元素下沉，即通过对比该元素k与它的下一层2\\*k与2\\*k+1中较大的一个，如果k小于它的下一层，则交换，且让它等于2\\*k或者2\\*k+1，不断比较交换，直到到堆末尾或者它大于它下一层的较大的元素。\n\nvoid heapSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \nint N = temp.size();  \ntemp.insert(temp.begin(), -1);//temp[0]不用  \n//构造堆  \nfor (int k = N/2; k \\>= 1 ; --k)  \n{  \nsink(temp, k, N,exchangeTime);  \n}  \n//排序  \nwhile(N\\>1)  \n{  \nexch(temp, 1, N--);  \n++exchangeTime;  \nsink(temp, 1, N,exchangeTime);  \n}  \n\n\nif (!isSorted(temp))  \n{  \ncout \\<\\< \"没排序!\" \\<\\< endl;  \n}  \n}\n\nvoid sink(vector\\<int\\> &temp, int k, int N, long long &exchangeTime)  \n{  \nwhile(2\\*k\\<=N)  \n{  \nint j = 2 \\* k;  \nif(j+1\\<=N && temp[j+1]\\>temp[j])  \n{  \n++j;  \n}  \nif(temp[k]\\>temp[j])  \n{  \nbreak;  \n}  \nexch(temp, k, j);  \nk = j;  \n++exchangeTime;  \n}  \n}\n\n### 3.1.7 归并排序\n\n总的来说，是用了分治法的思路，即，首先将左边一半数组排序，右一半数组排序。然后将两个排序的数组进行归并。而将左右两边数组排序是采用递归的思路，例如将左边的一半数组排序，则为将左边的数组的左一半数组排序，右一半数组排序，再将之合并。归并到最后的结果就是，如果有一个子数组只有一个或者没有元素就返回，这时算是已经排序了的。然后将之不断合并。一直到整个数组合并为一个有序数组。\n\n合并两个有序算法调用了一个辅助函数merge，思路很简单，即为用两个索引分别指向他们两个数组的开头，然后比较这两个索引的元素，存储结果的数组存储较小的那个元素，然后对于的索引+1，一直对比到其中的一个索引指向了那个数组的尽头。此时，结果数组直接全部存储剩余那个数组的剩余元素即可。\n\nvoid mergeSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \n\nvector\\<int\\> aux(vec.size());//辅助数组  \n\nmergeSort(temp, aux, 0, temp.size() - 1, exchangeTime);  \n\nif (!isSorted(temp))  \n{  \ncout \\<\\< \"没排序!\" \\<\\< endl;  \n}  \n}\n\nvoid mergeSort(vector\\<int\\> &temp, vector\\<int\\> &aux, int lo, int hi, long\nlong &exchangeTime)  \n{  \nif (hi \\<= lo)  \n{  \nreturn;  \n}  \nint mid = lo + (hi - lo) / 2;  \nmergeSort(temp, aux, lo, mid, exchangeTime);  \nmergeSort(temp, aux, mid + 1, hi, exchangeTime);  \n\nmerge(temp, aux, lo, mid, hi, exchangeTime);  \n}\n\nvoid merge(vector\\<int\\> &temp, vector\\<int\\> &aux, int lo, int mid, int hi,\nlong long &exchangeTime)  \n{  \n//mid左右两边已经拍好了序  \nint i = lo, j = mid + 1;  \nfor (int k = lo; k \\<= hi; ++k)  \n{  \naux[k] = temp[k];  \n}  \nfor (int k = lo; k \\<= hi; ++k)  \n{  \n//上面两个不进行比较  \nif (i \\> mid) temp[k] = aux[j++];  \nelse if (j \\> hi) temp[k] = aux[i++];  \nelse if (aux[j] \\< aux[i])  \n{  \ntemp[k] = aux[j++];  \n++exchangeTime;  \n}  \nelse  \n{  \ntemp[k] = aux[i++];  \n++exchangeTime;  \n}  \n}  \n}\n\n### 3.1.8 基数排序\n\n本质上是低位优先的字符串排序，所以首先得到数组的元素中最大元素的位数。然后对每一位进行一次排序，因为如果前一位的不同，则它们肯定能排序，而前一位的相同，它是稳定的放入，而后一位已经排序好了，所以可以直到从低位往高位不断排序直到最后一定能排序好。\n\n外层循环对每一位进行排序，而排序具体实现是：首先统计每个元素在这一位中0-9出现的个数，然后通过刚刚统计的元素个数，计算得到每一个元素放入辅助数组的开始的索引，然后对于每一个元素放入辅助数组相应的位置，就是通过查看元素这一位的值，在辅助数组找到相应的索引位置放入，并让该索引位置+1。直到把所有元素放入，即为将这一位的所有元素进行排序了。\n\nvoid radixSort(long long &exchangeTime)  \n{  \nvector\\<int\\> temp(vec);  \nvector\\<int\\> aux(temp);  \n\nint N = temp.size();  \nint R = 10;//一共只有0-9  \nint digit = getDigit(temp);  \nint base = 1;//目的是得到一个数的某一位的数,如得到123中的2  \n//0表示个位  \nfor (int d = 0; d \\< digit; ++d)  \n{  \nvector\\<int\\> count(R + 1);//计算出现的频率  \nfor (int i = 0; i \\< N; ++i)  \n{  \n//就算有一些的位数不够也没有关系,因为这样会是0,还是会排序  \nint index = temp[i] / base % 10;//第一次得到是个位,第二次是十位..  \ncount[index + 1]++;  \n}  \nfor (int r = 0; r \\< R; ++r)//将频率转换为索引  \n{  \ncount[r + 1] += count[r];  \n}  \nfor (int i = 0; i \\< N; ++i)//将元素分类  \n{  \nint index = temp[i] / base % 10;  \naux[count[index]++] = temp[i];  \n}  \nfor (int i = 0; i \\< N; ++i)//回写  \n{  \ntemp[i] = aux[i];  \n}  \nbase \\*= 10;//不断处理高位  \n}  \nif (!isSorted(temp))  \n{  \ncout \\<\\< \"没排序!\" \\<\\< endl;  \n}  \n}\n\nint getDigit(const vector\\<int\\> & temp)  \n{  \nint digit = 1;  \nint base = 10;  \nfor (int i = 0; i \\< temp.size(); ++i)  \n{  \nwhile(base\\<=temp[i])  \n{  \nbase \\*= 10;  \n++digit;  \n}  \n}  \nreturn digit;  \n}\n\n## 3.2 辅助函数功能的实现\n\n### 3.2.1 exch函数\n\nvoid exch(vector\\<int\\> &cur, int i, int j)  \n{  \nint temp = cur[i];  \ncur[i] = cur[j];  \ncur[j] = temp;  \n}\n\n### 3.2.2 isSorted函数\n\nbool isSorted(vector\\<int\\> &cur)  \n{  \nfor (int i = 0; i \\< cur.size() - 1; ++i)  \nif (cur[i + 1] \\< cur[i])  \nreturn false;  \nreturn true;  \n}\n\n## 3.3 总体系统的实现\n\n进入一个循环,根据用户输入,调用不同的排序算法进行排序测试,并且打印测试时间与比较次数,随后重置排序时间并且进行下一次比较。\n\n核心代码：\n\nwhile(true)  \n{  \ncout \\<\\< \"请选择排序算法:\";  \ncin \\>\\> whichSort;  \nif(whichSort==9)  \n{  \nbreak;  \n}  \nsortCompare.test(whichSort, sortTime, exchangeTime);  \ncout\\<\\<changeIndex[whichSort]\\<\\<\"所用时间:\"\\<\\<sortTime\\<\\<\"s\"\\<\\<endl;  \n//归并排序不进行两两交换,所以看比较次数  \nif(whichSort==7)  \ncout\\<\\<changeIndex[whichSort]\\<\\<\"比较次数：\"\\<\\<exchangeTime\\<\\<endl;  \nelse  \ncout\\<\\<changeIndex[whichSort]\\<\\<\"交换次数：\"\\<\\<exchangeTime\\<\\<endl;  \n//重置  \nsortTime = 0.0;  \nexchangeTime = 0;  \n}\n\n# 4 测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/614ad45ef223ce1115095cf56364944c.png)\n","slug":"项目笔记/dataStructureProjects/8种排序算法的比较案例","published":1,"updated":"2020-11-12T11:57:30.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73r00o9jotphcowauhb","content":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  8种排序算法的比较案例</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目简介\"><a href=\"#1-1-项目简介\" class=\"headerlink\" title=\"1.1 项目简介\"></a>1.1 项目简介</h2><p>随机函数产生一百，一千，一万和十万个随机数，用快速排序，直接插入排序，冒泡排序，选择排序的排序方法排序，并统计每种排序所花费的排序时间和交换次数。其中，随机数的个数由用户定义，系统产生随机数。并且显示他们的比较次数。</p>\n<p>请在文档中记录上述数据量下，各种排序的计算时间和存储开销，并且根据实验结果说明这些方法的优缺点。</p>\n<h2 id=\"1-2-功能分析\"><a href=\"#1-2-功能分析\" class=\"headerlink\" title=\"1.2 功能分析\"></a>1.2 功能分析</h2><p>首先,得在程序中实现了<strong>八种排序算法</strong>,其次,要有两个辅助函数,分别计算排序前后所花费的<strong>时间</strong>与排序的<strong>比较次数</strong>.</p>\n<p>最后,在主程序中,给用户提供界面,选择某种排序算法后,展示排序所需要的时间和比较次数.用户可以不断选择排序算法直到退出.用户也可以任意选择想排序的规模.</p>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-排序算法设计\"><a href=\"#2-1-排序算法设计\" class=\"headerlink\" title=\"2.1 排序算法设计\"></a>2.1 排序算法设计</h2><p>八种排序算法之中,都会传入一个引用参数<code>exchangeTime</code>代表交换次数,当交换时让exchangeTime值+1.每个排序算法都会将原来的随机数组复制一遍,以免把原有的随机数组更改了.</p>\n<p>同时为了规范,数组在进行交换数据时,都会调用同一个辅助函数exch进行交换,控制了变量.为了确保已经排序,也会调用<code>isSorted</code>确保已经排序.</p>\n<h2 id=\"2-2-辅助函数设计\"><a href=\"#2-2-辅助函数设计\" class=\"headerlink\" title=\"2.2 辅助函数设计\"></a>2.2 辅助函数设计</h2><p>首先,在<code>SortCompare</code>类中,构造函数将会为它的成员变量<code>vec</code>赋予N个随机数,然后在test类中,根据用户输入的参数,选择适当的算法进行排序.且在排序的前后计时,两者相减,得到了该排序算法的用时.</p>\n<p>然后,<code>exch()</code>通过传入数组与要交换的两个位置把元素交换,<code>isSorted()</code>通过一次循环比较后方元素是否大于前方元素来确保排序,否则返回false.</p>\n<h2 id=\"2-3-主程序设计\"><a href=\"#2-3-主程序设计\" class=\"headerlink\" title=\"2.3 主程序设计\"></a>2.3 主程序设计</h2><p>首先,用一个数组将数字与排序算法的名字关联起来,便于查看.输出窗口打印出表格以给用户进行提示,让用户输入排序的<code>规模N</code>.随后进入循环,直到用户按9退出程序.循环中,根据用户输入,调用相应的函数,执行相应的操作,<br>完成排序,并打印排序的时间与交换次数.将交换次数清零,进行下一次选择,直到用户退出.</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-八个排序方法的实现\"><a href=\"#3-1-八个排序方法的实现\" class=\"headerlink\" title=\"3.1 八个排序方法的实现\"></a>3.1 八个排序方法的实现</h2><h3 id=\"3-1-1-冒泡排序\"><a href=\"#3-1-1-冒泡排序\" class=\"headerlink\" title=\"3.1.1 冒泡排序\"></a>3.1.1 冒泡排序</h3><p>两遍循环,外层循环每次将最小的元素排定,直到整个数组有序。内层循环从数组最后一个元素分别与前一个元素对比，如果小于前一个元素，将两者交换，并且使交换次数+1，一直对比到排定的元素之前，因为排定的元素一定是小于后面的所有的元素的。</p>\n<p>值得注意的是，每个排序都通过将原数组复制，并将复制后的数组temp进行排序来进行测试，并且每次排序完，都调用测试函数isSorted测试是否排序，所有排序都用了这个模式，所以之后不再赘述。</p>\n<pre class=\" language-c++\"><code class=\"language-c++\">oid bubbleSort(long long &exchangeTime)  \n{  \n    vector<int> temp(vec);  \n    //每次都把最小的排定  \n    for (int i = 1; i < temp.size(); ++i)  \n    {  \n        for (int j = temp.size() - 1; j >= i; --j)  \n        {  \n            if (temp[j - 1] > temp[j])  \n            {  \n                exch(temp, j, j - 1);  \n                ++exchangeTime;  \n            }  \n        }  \n    }  \n    if (!isSorted(temp))  \n    {  \n        cout << \"没排序!\" << endl;  \n    }  \n}</code></pre>\n<h3 id=\"3-1-2-选择排序\"><a href=\"#3-1-2-选择排序\" class=\"headerlink\" title=\"3.1.2 选择排序\"></a>3.1.2 选择排序</h3><p>同样是两层循环，外层循环先让i做为最小的元素，并且通过右层循环找出数组右边最小元素的索引，然后再交换i与内层循环找到的最小元素min，并且让交换次数+1。</p>\n<pre class=\" language-c++\"><code class=\"language-c++\">void chooseSort(long long &exchangeTime)  \n{  \n    vector<int> temp(vec);  \n    for (int i = 0; i < temp.size() - 1; ++i)  \n    {  \n        int min = i;  \n        for (int j = i + 1; j < temp.size(); ++j)  \n        {  \n            if (temp[min] > temp[j])  \n            {  \n                min = j;  \n            }  \n        }  \n        exch(temp, min, i);  \n        ++exchangeTime;  \n    }  \n    if (!isSorted(temp))  \n    {  \n        cout << \"没排序!\" << endl;  \n    }  \n}</code></pre>\n<h3 id=\"3-1-3-插入排序\"><a href=\"#3-1-3-插入排序\" class=\"headerlink\" title=\"3.1.3 插入排序\"></a>3.1.3 插入排序</h3><p>两层循环，外层循环从一开始到数组末尾。内层循环不断的将该元素j与它前面的一个元素j-1的值进行对比，如果小与索引j-1的值则交换，直到j-1&lt;0了或者它的值大于索引j-1的值。算法本质就是左边一开始是一个元素，然后不断的让数组后面的元素插入到合适的位置，直到所有元素都插入，而它们也就是一个有序的数组了。</p>\n<p>void insertSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);<br>for (int i = 1; i &lt; temp.size(); ++i)<br>{<br>for (int j = i; j - 1 &gt;= 0 &amp;&amp; temp[j] &lt; temp[j - 1]; –j)<br>{<br>exch(temp, j - 1, j);<br>++exchangeTime;<br>}<br>}<br>if (!isSorted(temp))<br>{<br>cout &lt;&lt; “没排序!” &lt;&lt; endl;<br>}<br>}</p>\n<h3 id=\"3-1-4-希尔排序\"><a href=\"#3-1-4-希尔排序\" class=\"headerlink\" title=\"3.1.4 希尔排序\"></a>3.1.4 希尔排序</h3><p>本质上希尔排序就是插入排序的改进。先用h不断*3+1，直到到数组大小的三分之一，然后和插入排序的循环类似，只不过外层循环是从h开始，且内层循环每一次对比的都是j和j-h的元素，这样一次排序就形成了h有序数组，即每相隔h位置的元素形成了一个有序数组，然后最外面的循环负责不断的缩小h的值，使得形成的h越来越小，而当h=1时，即为插入排序，并且此次排序结束后循环终止。</p>\n<p>之所以要这么麻烦，是为了刚刚开始时，h大概是数组的三分之一左右，然后每一次交换都能让相对很小的元素放在很前面，不必像是插入排序一样，如果碰到最小的元素，就要一个个的比较交换，直到它到最左边的位置。</p>\n<p>void shellSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);  </p>\n<p>int h = 1;<br>while (h &lt; temp.size() / 3)<br>{<br>h = 3 * h + 1;<br>}  </p>\n<p>while (h &gt;= 1)<br>{<br>for (int i = h; i &lt; temp.size(); ++i)<br>{<br>for (int j = i; j - h &gt;= 0 &amp;&amp; temp[j] &lt; temp[j - h]; j -= h)<br>{<br>exch(temp, j - h, j);<br>++exchangeTime;<br>}<br>}<br>h /= 3;<br>}</p>\n<h3 id=\"3-1-5-快速排序\"><a href=\"#3-1-5-快速排序\" class=\"headerlink\" title=\"3.1.5 快速排序\"></a>3.1.5 快速排序</h3><p>用了额外的两个辅助函数，每次排序，先调用辅助函数partition，它将返回一个索引j，且保证了j的左边元素都小于它，而它的右边元素都大于或等于它。然后继续递归地将左边的数组排序，将右边的数组排序，直到只有一个元素时返回。因为每次调用，j的位置都是排定的，所以通过归纳法可知最后数组一定排序好了。</p>\n<p>Partition函数具体实现则是：先将传入的第一个元素（传入的元素不一定就是数组的首元素，而是要排序的子数组的第一个元素，用lo标定）定为v，用i，j指向该要排序的数组，然后i不断的向右扫描，j不断的向左扫描，如果i找到了大于等于v的元素，j找到了小于等于它的元素，则将他们两个交换。重复扫描直到i&gt;=j或者i到了数组末尾，或者j到达数组开头。此时可知索引j的元素肯定是小于v的，而i一定是大于v的，此时只要交换索引j和首元素，再返回索引j，即实现了j左边都是小于它的而右边都是大于等于它的。</p>\n<p>void quickSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);  </p>\n<p>//因为本来就是乱的,所以不用打乱了<br>quickSort(temp, 0, temp.size() - 1, exchangeTime);  </p>\n<p>if (!isSorted(temp))<br>{<br>cout &lt;&lt; “没排序!” &lt;&lt; endl;<br>}<br>}</p>\n<p>void quickSort(vector&lt;int&gt; &amp;temp, int lo, int hi, long long &amp;exchangeTime)<br>{<br>if (hi &lt;= lo)<br>{<br>return;<br>}<br>int j = partition(temp, lo, hi, exchangeTime);<br>quickSort(temp, lo, j - 1, exchangeTime);<br>quickSort(temp, j + 1, hi, exchangeTime);<br>}</p>\n<p>int partition(vector&lt;int&gt; &amp;temp, int lo, int hi, long long &amp;exchangeTime)<br>{<br>int i = lo, j = hi + 1;<br>int v = temp[lo];<br>while (true)<br>{<br>while (temp[++i] &lt; v) if (i == hi) break;<br>while (v &lt; temp[–j]) if (j == lo) break;<br>if (i &gt;= j)<br>break;<br>exch(temp, i, j);<br>++exchangeTime;<br>}<br>exch(temp, lo, j);<br>++exchangeTime;<br>return j;<br>}</p>\n<h3 id=\"3-1-6-堆排序\"><a href=\"#3-1-6-堆排序\" class=\"headerlink\" title=\"3.1.6 堆排序\"></a>3.1.6 堆排序</h3><p>首先构造一个堆，从数组长度/2的位置直到第一个元素进行构建，因为数组长度/2到数组末尾的可以直接作为堆底，不用构建了，所谓构建，就是对每一个索引i调用sink函数，直觉上来说就是把大的元素放上面，小的放下面。然后排序阶段，将数组最后一个元素与第一个交换，即将堆最大的元素放再数组末端，然后对数组首元素进行sink操作，来保证堆的有序性。N–，不断这样操作直到N==1，意味着数组已经排序。</p>\n<p>Sink函数主要是将元素下沉，即通过对比该元素k与它的下一层2*k与2*k+1中较大的一个，如果k小于它的下一层，则交换，且让它等于2*k或者2*k+1，不断比较交换，直到到堆末尾或者它大于它下一层的较大的元素。</p>\n<p>void heapSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);<br>int N = temp.size();<br>temp.insert(temp.begin(), -1);//temp[0]不用<br>//构造堆<br>for (int k = N/2; k &gt;= 1 ; –k)<br>{<br>sink(temp, k, N,exchangeTime);<br>}<br>//排序<br>while(N&gt;1)<br>{<br>exch(temp, 1, N–);<br>++exchangeTime;<br>sink(temp, 1, N,exchangeTime);<br>}  </p>\n<p>if (!isSorted(temp))<br>{<br>cout &lt;&lt; “没排序!” &lt;&lt; endl;<br>}<br>}</p>\n<p>void sink(vector&lt;int&gt; &amp;temp, int k, int N, long long &amp;exchangeTime)<br>{<br>while(2*k&lt;=N)<br>{<br>int j = 2 * k;<br>if(j+1&lt;=N &amp;&amp; temp[j+1]&gt;temp[j])<br>{<br>++j;<br>}<br>if(temp[k]&gt;temp[j])<br>{<br>break;<br>}<br>exch(temp, k, j);<br>k = j;<br>++exchangeTime;<br>}<br>}</p>\n<h3 id=\"3-1-7-归并排序\"><a href=\"#3-1-7-归并排序\" class=\"headerlink\" title=\"3.1.7 归并排序\"></a>3.1.7 归并排序</h3><p>总的来说，是用了分治法的思路，即，首先将左边一半数组排序，右一半数组排序。然后将两个排序的数组进行归并。而将左右两边数组排序是采用递归的思路，例如将左边的一半数组排序，则为将左边的数组的左一半数组排序，右一半数组排序，再将之合并。归并到最后的结果就是，如果有一个子数组只有一个或者没有元素就返回，这时算是已经排序了的。然后将之不断合并。一直到整个数组合并为一个有序数组。</p>\n<p>合并两个有序算法调用了一个辅助函数merge，思路很简单，即为用两个索引分别指向他们两个数组的开头，然后比较这两个索引的元素，存储结果的数组存储较小的那个元素，然后对于的索引+1，一直对比到其中的一个索引指向了那个数组的尽头。此时，结果数组直接全部存储剩余那个数组的剩余元素即可。</p>\n<p>void mergeSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);  </p>\n<p>vector&lt;int&gt; aux(vec.size());//辅助数组  </p>\n<p>mergeSort(temp, aux, 0, temp.size() - 1, exchangeTime);  </p>\n<p>if (!isSorted(temp))<br>{<br>cout &lt;&lt; “没排序!” &lt;&lt; endl;<br>}<br>}</p>\n<p>void mergeSort(vector&lt;int&gt; &amp;temp, vector&lt;int&gt; &amp;aux, int lo, int hi, long<br>long &amp;exchangeTime)<br>{<br>if (hi &lt;= lo)<br>{<br>return;<br>}<br>int mid = lo + (hi - lo) / 2;<br>mergeSort(temp, aux, lo, mid, exchangeTime);<br>mergeSort(temp, aux, mid + 1, hi, exchangeTime);  </p>\n<p>merge(temp, aux, lo, mid, hi, exchangeTime);<br>}</p>\n<p>void merge(vector&lt;int&gt; &amp;temp, vector&lt;int&gt; &amp;aux, int lo, int mid, int hi,<br>long long &amp;exchangeTime)<br>{<br>//mid左右两边已经拍好了序<br>int i = lo, j = mid + 1;<br>for (int k = lo; k &lt;= hi; ++k)<br>{<br>aux[k] = temp[k];<br>}<br>for (int k = lo; k &lt;= hi; ++k)<br>{<br>//上面两个不进行比较<br>if (i &gt; mid) temp[k] = aux[j++];<br>else if (j &gt; hi) temp[k] = aux[i++];<br>else if (aux[j] &lt; aux[i])<br>{<br>temp[k] = aux[j++];<br>++exchangeTime;<br>}<br>else<br>{<br>temp[k] = aux[i++];<br>++exchangeTime;<br>}<br>}<br>}</p>\n<h3 id=\"3-1-8-基数排序\"><a href=\"#3-1-8-基数排序\" class=\"headerlink\" title=\"3.1.8 基数排序\"></a>3.1.8 基数排序</h3><p>本质上是低位优先的字符串排序，所以首先得到数组的元素中最大元素的位数。然后对每一位进行一次排序，因为如果前一位的不同，则它们肯定能排序，而前一位的相同，它是稳定的放入，而后一位已经排序好了，所以可以直到从低位往高位不断排序直到最后一定能排序好。</p>\n<p>外层循环对每一位进行排序，而排序具体实现是：首先统计每个元素在这一位中0-9出现的个数，然后通过刚刚统计的元素个数，计算得到每一个元素放入辅助数组的开始的索引，然后对于每一个元素放入辅助数组相应的位置，就是通过查看元素这一位的值，在辅助数组找到相应的索引位置放入，并让该索引位置+1。直到把所有元素放入，即为将这一位的所有元素进行排序了。</p>\n<p>void radixSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);<br>vector&lt;int&gt; aux(temp);  </p>\n<p>int N = temp.size();<br>int R = 10;//一共只有0-9<br>int digit = getDigit(temp);<br>int base = 1;//目的是得到一个数的某一位的数,如得到123中的2<br>//0表示个位<br>for (int d = 0; d &lt; digit; ++d)<br>{<br>vector&lt;int&gt; count(R + 1);//计算出现的频率<br>for (int i = 0; i &lt; N; ++i)<br>{<br>//就算有一些的位数不够也没有关系,因为这样会是0,还是会排序<br>int index = temp[i] / base % 10;//第一次得到是个位,第二次是十位..<br>count[index + 1]++;<br>}<br>for (int r = 0; r &lt; R; ++r)//将频率转换为索引<br>{<br>count[r + 1] += count[r];<br>}<br>for (int i = 0; i &lt; N; ++i)//将元素分类<br>{<br>int index = temp[i] / base % 10;<br>aux[count[index]++] = temp[i];<br>}<br>for (int i = 0; i &lt; N; ++i)//回写<br>{<br>temp[i] = aux[i];<br>}<br>base *= 10;//不断处理高位<br>}<br>if (!isSorted(temp))<br>{<br>cout &lt;&lt; “没排序!” &lt;&lt; endl;<br>}<br>}</p>\n<p>int getDigit(const vector&lt;int&gt; &amp; temp)<br>{<br>int digit = 1;<br>int base = 10;<br>for (int i = 0; i &lt; temp.size(); ++i)<br>{<br>while(base&lt;=temp[i])<br>{<br>base *= 10;<br>++digit;<br>}<br>}<br>return digit;<br>}</p>\n<h2 id=\"3-2-辅助函数功能的实现\"><a href=\"#3-2-辅助函数功能的实现\" class=\"headerlink\" title=\"3.2 辅助函数功能的实现\"></a>3.2 辅助函数功能的实现</h2><h3 id=\"3-2-1-exch函数\"><a href=\"#3-2-1-exch函数\" class=\"headerlink\" title=\"3.2.1 exch函数\"></a>3.2.1 exch函数</h3><p>void exch(vector&lt;int&gt; &amp;cur, int i, int j)<br>{<br>int temp = cur[i];<br>cur[i] = cur[j];<br>cur[j] = temp;<br>}</p>\n<h3 id=\"3-2-2-isSorted函数\"><a href=\"#3-2-2-isSorted函数\" class=\"headerlink\" title=\"3.2.2 isSorted函数\"></a>3.2.2 isSorted函数</h3><p>bool isSorted(vector&lt;int&gt; &amp;cur)<br>{<br>for (int i = 0; i &lt; cur.size() - 1; ++i)<br>if (cur[i + 1] &lt; cur[i])<br>return false;<br>return true;<br>}</p>\n<h2 id=\"3-3-总体系统的实现\"><a href=\"#3-3-总体系统的实现\" class=\"headerlink\" title=\"3.3 总体系统的实现\"></a>3.3 总体系统的实现</h2><p>进入一个循环,根据用户输入,调用不同的排序算法进行排序测试,并且打印测试时间与比较次数,随后重置排序时间并且进行下一次比较。</p>\n<p>核心代码：</p>\n<p>while(true)<br>{<br>cout &lt;&lt; “请选择排序算法:”;<br>cin &gt;&gt; whichSort;<br>if(whichSort==9)<br>{<br>break;<br>}<br>sortCompare.test(whichSort, sortTime, exchangeTime);<br>cout&lt;&lt;changeIndex[whichSort]&lt;&lt;“所用时间:”&lt;&lt;sortTime&lt;&lt;“s”&lt;&lt;endl;<br>//归并排序不进行两两交换,所以看比较次数<br>if(whichSort==7)<br>cout&lt;&lt;changeIndex[whichSort]&lt;&lt;“比较次数：”&lt;&lt;exchangeTime&lt;&lt;endl;<br>else<br>cout&lt;&lt;changeIndex[whichSort]&lt;&lt;“交换次数：”&lt;&lt;exchangeTime&lt;&lt;endl;<br>//重置<br>sortTime = 0.0;<br>exchangeTime = 0;<br>}</p>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/614ad45ef223ce1115095cf56364944c.png\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  8种排序算法的比较案例</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目简介\"><a href=\"#1-1-项目简介\" class=\"headerlink\" title=\"1.1 项目简介\"></a>1.1 项目简介</h2><p>随机函数产生一百，一千，一万和十万个随机数，用快速排序，直接插入排序，冒泡排序，选择排序的排序方法排序，并统计每种排序所花费的排序时间和交换次数。其中，随机数的个数由用户定义，系统产生随机数。并且显示他们的比较次数。</p>\n<p>请在文档中记录上述数据量下，各种排序的计算时间和存储开销，并且根据实验结果说明这些方法的优缺点。</p>\n<h2 id=\"1-2-功能分析\"><a href=\"#1-2-功能分析\" class=\"headerlink\" title=\"1.2 功能分析\"></a>1.2 功能分析</h2><p>首先,得在程序中实现了<strong>八种排序算法</strong>,其次,要有两个辅助函数,分别计算排序前后所花费的<strong>时间</strong>与排序的<strong>比较次数</strong>.</p>\n<p>最后,在主程序中,给用户提供界面,选择某种排序算法后,展示排序所需要的时间和比较次数.用户可以不断选择排序算法直到退出.用户也可以任意选择想排序的规模.</p>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-排序算法设计\"><a href=\"#2-1-排序算法设计\" class=\"headerlink\" title=\"2.1 排序算法设计\"></a>2.1 排序算法设计</h2><p>八种排序算法之中,都会传入一个引用参数<code>exchangeTime</code>代表交换次数,当交换时让exchangeTime值+1.每个排序算法都会将原来的随机数组复制一遍,以免把原有的随机数组更改了.</p>\n<p>同时为了规范,数组在进行交换数据时,都会调用同一个辅助函数exch进行交换,控制了变量.为了确保已经排序,也会调用<code>isSorted</code>确保已经排序.</p>\n<h2 id=\"2-2-辅助函数设计\"><a href=\"#2-2-辅助函数设计\" class=\"headerlink\" title=\"2.2 辅助函数设计\"></a>2.2 辅助函数设计</h2><p>首先,在<code>SortCompare</code>类中,构造函数将会为它的成员变量<code>vec</code>赋予N个随机数,然后在test类中,根据用户输入的参数,选择适当的算法进行排序.且在排序的前后计时,两者相减,得到了该排序算法的用时.</p>\n<p>然后,<code>exch()</code>通过传入数组与要交换的两个位置把元素交换,<code>isSorted()</code>通过一次循环比较后方元素是否大于前方元素来确保排序,否则返回false.</p>\n<h2 id=\"2-3-主程序设计\"><a href=\"#2-3-主程序设计\" class=\"headerlink\" title=\"2.3 主程序设计\"></a>2.3 主程序设计</h2><p>首先,用一个数组将数字与排序算法的名字关联起来,便于查看.输出窗口打印出表格以给用户进行提示,让用户输入排序的<code>规模N</code>.随后进入循环,直到用户按9退出程序.循环中,根据用户输入,调用相应的函数,执行相应的操作,<br>完成排序,并打印排序的时间与交换次数.将交换次数清零,进行下一次选择,直到用户退出.</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-八个排序方法的实现\"><a href=\"#3-1-八个排序方法的实现\" class=\"headerlink\" title=\"3.1 八个排序方法的实现\"></a>3.1 八个排序方法的实现</h2><h3 id=\"3-1-1-冒泡排序\"><a href=\"#3-1-1-冒泡排序\" class=\"headerlink\" title=\"3.1.1 冒泡排序\"></a>3.1.1 冒泡排序</h3><p>两遍循环,外层循环每次将最小的元素排定,直到整个数组有序。内层循环从数组最后一个元素分别与前一个元素对比，如果小于前一个元素，将两者交换，并且使交换次数+1，一直对比到排定的元素之前，因为排定的元素一定是小于后面的所有的元素的。</p>\n<p>值得注意的是，每个排序都通过将原数组复制，并将复制后的数组temp进行排序来进行测试，并且每次排序完，都调用测试函数isSorted测试是否排序，所有排序都用了这个模式，所以之后不再赘述。</p>\n<pre><code class=\"c++\">oid bubbleSort(long long &amp;exchangeTime)  \n{  \n    vector&lt;int&gt; temp(vec);  \n    //每次都把最小的排定  \n    for (int i = 1; i &lt; temp.size(); ++i)  \n    {  \n        for (int j = temp.size() - 1; j &gt;= i; --j)  \n        {  \n            if (temp[j - 1] &gt; temp[j])  \n            {  \n                exch(temp, j, j - 1);  \n                ++exchangeTime;  \n            }  \n        }  \n    }  \n    if (!isSorted(temp))  \n    {  \n        cout &lt;&lt; &quot;没排序!&quot; &lt;&lt; endl;  \n    }  \n}</code></pre>\n<h3 id=\"3-1-2-选择排序\"><a href=\"#3-1-2-选择排序\" class=\"headerlink\" title=\"3.1.2 选择排序\"></a>3.1.2 选择排序</h3><p>同样是两层循环，外层循环先让i做为最小的元素，并且通过右层循环找出数组右边最小元素的索引，然后再交换i与内层循环找到的最小元素min，并且让交换次数+1。</p>\n<pre><code class=\"c++\">void chooseSort(long long &amp;exchangeTime)  \n{  \n    vector&lt;int&gt; temp(vec);  \n    for (int i = 0; i &lt; temp.size() - 1; ++i)  \n    {  \n        int min = i;  \n        for (int j = i + 1; j &lt; temp.size(); ++j)  \n        {  \n            if (temp[min] &gt; temp[j])  \n            {  \n                min = j;  \n            }  \n        }  \n        exch(temp, min, i);  \n        ++exchangeTime;  \n    }  \n    if (!isSorted(temp))  \n    {  \n        cout &lt;&lt; &quot;没排序!&quot; &lt;&lt; endl;  \n    }  \n}</code></pre>\n<h3 id=\"3-1-3-插入排序\"><a href=\"#3-1-3-插入排序\" class=\"headerlink\" title=\"3.1.3 插入排序\"></a>3.1.3 插入排序</h3><p>两层循环，外层循环从一开始到数组末尾。内层循环不断的将该元素j与它前面的一个元素j-1的值进行对比，如果小与索引j-1的值则交换，直到j-1&lt;0了或者它的值大于索引j-1的值。算法本质就是左边一开始是一个元素，然后不断的让数组后面的元素插入到合适的位置，直到所有元素都插入，而它们也就是一个有序的数组了。</p>\n<p>void insertSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);<br>for (int i = 1; i &lt; temp.size(); ++i)<br>{<br>for (int j = i; j - 1 &gt;= 0 &amp;&amp; temp[j] &lt; temp[j - 1]; –j)<br>{<br>exch(temp, j - 1, j);<br>++exchangeTime;<br>}<br>}<br>if (!isSorted(temp))<br>{<br>cout &lt;&lt; “没排序!” &lt;&lt; endl;<br>}<br>}</p>\n<h3 id=\"3-1-4-希尔排序\"><a href=\"#3-1-4-希尔排序\" class=\"headerlink\" title=\"3.1.4 希尔排序\"></a>3.1.4 希尔排序</h3><p>本质上希尔排序就是插入排序的改进。先用h不断*3+1，直到到数组大小的三分之一，然后和插入排序的循环类似，只不过外层循环是从h开始，且内层循环每一次对比的都是j和j-h的元素，这样一次排序就形成了h有序数组，即每相隔h位置的元素形成了一个有序数组，然后最外面的循环负责不断的缩小h的值，使得形成的h越来越小，而当h=1时，即为插入排序，并且此次排序结束后循环终止。</p>\n<p>之所以要这么麻烦，是为了刚刚开始时，h大概是数组的三分之一左右，然后每一次交换都能让相对很小的元素放在很前面，不必像是插入排序一样，如果碰到最小的元素，就要一个个的比较交换，直到它到最左边的位置。</p>\n<p>void shellSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);  </p>\n<p>int h = 1;<br>while (h &lt; temp.size() / 3)<br>{<br>h = 3 * h + 1;<br>}  </p>\n<p>while (h &gt;= 1)<br>{<br>for (int i = h; i &lt; temp.size(); ++i)<br>{<br>for (int j = i; j - h &gt;= 0 &amp;&amp; temp[j] &lt; temp[j - h]; j -= h)<br>{<br>exch(temp, j - h, j);<br>++exchangeTime;<br>}<br>}<br>h /= 3;<br>}</p>\n<h3 id=\"3-1-5-快速排序\"><a href=\"#3-1-5-快速排序\" class=\"headerlink\" title=\"3.1.5 快速排序\"></a>3.1.5 快速排序</h3><p>用了额外的两个辅助函数，每次排序，先调用辅助函数partition，它将返回一个索引j，且保证了j的左边元素都小于它，而它的右边元素都大于或等于它。然后继续递归地将左边的数组排序，将右边的数组排序，直到只有一个元素时返回。因为每次调用，j的位置都是排定的，所以通过归纳法可知最后数组一定排序好了。</p>\n<p>Partition函数具体实现则是：先将传入的第一个元素（传入的元素不一定就是数组的首元素，而是要排序的子数组的第一个元素，用lo标定）定为v，用i，j指向该要排序的数组，然后i不断的向右扫描，j不断的向左扫描，如果i找到了大于等于v的元素，j找到了小于等于它的元素，则将他们两个交换。重复扫描直到i&gt;=j或者i到了数组末尾，或者j到达数组开头。此时可知索引j的元素肯定是小于v的，而i一定是大于v的，此时只要交换索引j和首元素，再返回索引j，即实现了j左边都是小于它的而右边都是大于等于它的。</p>\n<p>void quickSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);  </p>\n<p>//因为本来就是乱的,所以不用打乱了<br>quickSort(temp, 0, temp.size() - 1, exchangeTime);  </p>\n<p>if (!isSorted(temp))<br>{<br>cout &lt;&lt; “没排序!” &lt;&lt; endl;<br>}<br>}</p>\n<p>void quickSort(vector&lt;int&gt; &amp;temp, int lo, int hi, long long &amp;exchangeTime)<br>{<br>if (hi &lt;= lo)<br>{<br>return;<br>}<br>int j = partition(temp, lo, hi, exchangeTime);<br>quickSort(temp, lo, j - 1, exchangeTime);<br>quickSort(temp, j + 1, hi, exchangeTime);<br>}</p>\n<p>int partition(vector&lt;int&gt; &amp;temp, int lo, int hi, long long &amp;exchangeTime)<br>{<br>int i = lo, j = hi + 1;<br>int v = temp[lo];<br>while (true)<br>{<br>while (temp[++i] &lt; v) if (i == hi) break;<br>while (v &lt; temp[–j]) if (j == lo) break;<br>if (i &gt;= j)<br>break;<br>exch(temp, i, j);<br>++exchangeTime;<br>}<br>exch(temp, lo, j);<br>++exchangeTime;<br>return j;<br>}</p>\n<h3 id=\"3-1-6-堆排序\"><a href=\"#3-1-6-堆排序\" class=\"headerlink\" title=\"3.1.6 堆排序\"></a>3.1.6 堆排序</h3><p>首先构造一个堆，从数组长度/2的位置直到第一个元素进行构建，因为数组长度/2到数组末尾的可以直接作为堆底，不用构建了，所谓构建，就是对每一个索引i调用sink函数，直觉上来说就是把大的元素放上面，小的放下面。然后排序阶段，将数组最后一个元素与第一个交换，即将堆最大的元素放再数组末端，然后对数组首元素进行sink操作，来保证堆的有序性。N–，不断这样操作直到N==1，意味着数组已经排序。</p>\n<p>Sink函数主要是将元素下沉，即通过对比该元素k与它的下一层2*k与2*k+1中较大的一个，如果k小于它的下一层，则交换，且让它等于2*k或者2*k+1，不断比较交换，直到到堆末尾或者它大于它下一层的较大的元素。</p>\n<p>void heapSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);<br>int N = temp.size();<br>temp.insert(temp.begin(), -1);//temp[0]不用<br>//构造堆<br>for (int k = N/2; k &gt;= 1 ; –k)<br>{<br>sink(temp, k, N,exchangeTime);<br>}<br>//排序<br>while(N&gt;1)<br>{<br>exch(temp, 1, N–);<br>++exchangeTime;<br>sink(temp, 1, N,exchangeTime);<br>}  </p>\n<p>if (!isSorted(temp))<br>{<br>cout &lt;&lt; “没排序!” &lt;&lt; endl;<br>}<br>}</p>\n<p>void sink(vector&lt;int&gt; &amp;temp, int k, int N, long long &amp;exchangeTime)<br>{<br>while(2*k&lt;=N)<br>{<br>int j = 2 * k;<br>if(j+1&lt;=N &amp;&amp; temp[j+1]&gt;temp[j])<br>{<br>++j;<br>}<br>if(temp[k]&gt;temp[j])<br>{<br>break;<br>}<br>exch(temp, k, j);<br>k = j;<br>++exchangeTime;<br>}<br>}</p>\n<h3 id=\"3-1-7-归并排序\"><a href=\"#3-1-7-归并排序\" class=\"headerlink\" title=\"3.1.7 归并排序\"></a>3.1.7 归并排序</h3><p>总的来说，是用了分治法的思路，即，首先将左边一半数组排序，右一半数组排序。然后将两个排序的数组进行归并。而将左右两边数组排序是采用递归的思路，例如将左边的一半数组排序，则为将左边的数组的左一半数组排序，右一半数组排序，再将之合并。归并到最后的结果就是，如果有一个子数组只有一个或者没有元素就返回，这时算是已经排序了的。然后将之不断合并。一直到整个数组合并为一个有序数组。</p>\n<p>合并两个有序算法调用了一个辅助函数merge，思路很简单，即为用两个索引分别指向他们两个数组的开头，然后比较这两个索引的元素，存储结果的数组存储较小的那个元素，然后对于的索引+1，一直对比到其中的一个索引指向了那个数组的尽头。此时，结果数组直接全部存储剩余那个数组的剩余元素即可。</p>\n<p>void mergeSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);  </p>\n<p>vector&lt;int&gt; aux(vec.size());//辅助数组  </p>\n<p>mergeSort(temp, aux, 0, temp.size() - 1, exchangeTime);  </p>\n<p>if (!isSorted(temp))<br>{<br>cout &lt;&lt; “没排序!” &lt;&lt; endl;<br>}<br>}</p>\n<p>void mergeSort(vector&lt;int&gt; &amp;temp, vector&lt;int&gt; &amp;aux, int lo, int hi, long<br>long &amp;exchangeTime)<br>{<br>if (hi &lt;= lo)<br>{<br>return;<br>}<br>int mid = lo + (hi - lo) / 2;<br>mergeSort(temp, aux, lo, mid, exchangeTime);<br>mergeSort(temp, aux, mid + 1, hi, exchangeTime);  </p>\n<p>merge(temp, aux, lo, mid, hi, exchangeTime);<br>}</p>\n<p>void merge(vector&lt;int&gt; &amp;temp, vector&lt;int&gt; &amp;aux, int lo, int mid, int hi,<br>long long &amp;exchangeTime)<br>{<br>//mid左右两边已经拍好了序<br>int i = lo, j = mid + 1;<br>for (int k = lo; k &lt;= hi; ++k)<br>{<br>aux[k] = temp[k];<br>}<br>for (int k = lo; k &lt;= hi; ++k)<br>{<br>//上面两个不进行比较<br>if (i &gt; mid) temp[k] = aux[j++];<br>else if (j &gt; hi) temp[k] = aux[i++];<br>else if (aux[j] &lt; aux[i])<br>{<br>temp[k] = aux[j++];<br>++exchangeTime;<br>}<br>else<br>{<br>temp[k] = aux[i++];<br>++exchangeTime;<br>}<br>}<br>}</p>\n<h3 id=\"3-1-8-基数排序\"><a href=\"#3-1-8-基数排序\" class=\"headerlink\" title=\"3.1.8 基数排序\"></a>3.1.8 基数排序</h3><p>本质上是低位优先的字符串排序，所以首先得到数组的元素中最大元素的位数。然后对每一位进行一次排序，因为如果前一位的不同，则它们肯定能排序，而前一位的相同，它是稳定的放入，而后一位已经排序好了，所以可以直到从低位往高位不断排序直到最后一定能排序好。</p>\n<p>外层循环对每一位进行排序，而排序具体实现是：首先统计每个元素在这一位中0-9出现的个数，然后通过刚刚统计的元素个数，计算得到每一个元素放入辅助数组的开始的索引，然后对于每一个元素放入辅助数组相应的位置，就是通过查看元素这一位的值，在辅助数组找到相应的索引位置放入，并让该索引位置+1。直到把所有元素放入，即为将这一位的所有元素进行排序了。</p>\n<p>void radixSort(long long &amp;exchangeTime)<br>{<br>vector&lt;int&gt; temp(vec);<br>vector&lt;int&gt; aux(temp);  </p>\n<p>int N = temp.size();<br>int R = 10;//一共只有0-9<br>int digit = getDigit(temp);<br>int base = 1;//目的是得到一个数的某一位的数,如得到123中的2<br>//0表示个位<br>for (int d = 0; d &lt; digit; ++d)<br>{<br>vector&lt;int&gt; count(R + 1);//计算出现的频率<br>for (int i = 0; i &lt; N; ++i)<br>{<br>//就算有一些的位数不够也没有关系,因为这样会是0,还是会排序<br>int index = temp[i] / base % 10;//第一次得到是个位,第二次是十位..<br>count[index + 1]++;<br>}<br>for (int r = 0; r &lt; R; ++r)//将频率转换为索引<br>{<br>count[r + 1] += count[r];<br>}<br>for (int i = 0; i &lt; N; ++i)//将元素分类<br>{<br>int index = temp[i] / base % 10;<br>aux[count[index]++] = temp[i];<br>}<br>for (int i = 0; i &lt; N; ++i)//回写<br>{<br>temp[i] = aux[i];<br>}<br>base *= 10;//不断处理高位<br>}<br>if (!isSorted(temp))<br>{<br>cout &lt;&lt; “没排序!” &lt;&lt; endl;<br>}<br>}</p>\n<p>int getDigit(const vector&lt;int&gt; &amp; temp)<br>{<br>int digit = 1;<br>int base = 10;<br>for (int i = 0; i &lt; temp.size(); ++i)<br>{<br>while(base&lt;=temp[i])<br>{<br>base *= 10;<br>++digit;<br>}<br>}<br>return digit;<br>}</p>\n<h2 id=\"3-2-辅助函数功能的实现\"><a href=\"#3-2-辅助函数功能的实现\" class=\"headerlink\" title=\"3.2 辅助函数功能的实现\"></a>3.2 辅助函数功能的实现</h2><h3 id=\"3-2-1-exch函数\"><a href=\"#3-2-1-exch函数\" class=\"headerlink\" title=\"3.2.1 exch函数\"></a>3.2.1 exch函数</h3><p>void exch(vector&lt;int&gt; &amp;cur, int i, int j)<br>{<br>int temp = cur[i];<br>cur[i] = cur[j];<br>cur[j] = temp;<br>}</p>\n<h3 id=\"3-2-2-isSorted函数\"><a href=\"#3-2-2-isSorted函数\" class=\"headerlink\" title=\"3.2.2 isSorted函数\"></a>3.2.2 isSorted函数</h3><p>bool isSorted(vector&lt;int&gt; &amp;cur)<br>{<br>for (int i = 0; i &lt; cur.size() - 1; ++i)<br>if (cur[i + 1] &lt; cur[i])<br>return false;<br>return true;<br>}</p>\n<h2 id=\"3-3-总体系统的实现\"><a href=\"#3-3-总体系统的实现\" class=\"headerlink\" title=\"3.3 总体系统的实现\"></a>3.3 总体系统的实现</h2><p>进入一个循环,根据用户输入,调用不同的排序算法进行排序测试,并且打印测试时间与比较次数,随后重置排序时间并且进行下一次比较。</p>\n<p>核心代码：</p>\n<p>while(true)<br>{<br>cout &lt;&lt; “请选择排序算法:”;<br>cin &gt;&gt; whichSort;<br>if(whichSort==9)<br>{<br>break;<br>}<br>sortCompare.test(whichSort, sortTime, exchangeTime);<br>cout&lt;&lt;changeIndex[whichSort]&lt;&lt;“所用时间:”&lt;&lt;sortTime&lt;&lt;“s”&lt;&lt;endl;<br>//归并排序不进行两两交换,所以看比较次数<br>if(whichSort==7)<br>cout&lt;&lt;changeIndex[whichSort]&lt;&lt;“比较次数：”&lt;&lt;exchangeTime&lt;&lt;endl;<br>else<br>cout&lt;&lt;changeIndex[whichSort]&lt;&lt;“交换次数：”&lt;&lt;exchangeTime&lt;&lt;endl;<br>//重置<br>sortTime = 0.0;<br>exchangeTime = 0;<br>}</p>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/614ad45ef223ce1115095cf56364944c.png\"></p>\n"},{"title":"字符串排序算法的调研与实现","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习数据结构式的小论文---字符串排序算法的调研与实现","abbrlink":"80898847","date":"2020-01-27T16:00:00.000Z","_content":"\n>\t参考<<算法-第四版>>写的数据结构小论文(已修改格式)\n>\t用C++代码实现了LSD算法,MSD算法以及三向快速排序算法来对字符串进行排序\n\n\n\n# [Github地址](https://github.com/tongji4m3/DataStructureDesign)\n\n# 摘要\n对于许多的排序,决定顺序的键值都是字符串,于是就想利用字符串的特殊性质来设定专门针对字符串的排序算法,使得排序效率更高。我调研并用C++代码实现了LSD算法,MSD算法以及三向快速排序算法来对字符串进行排序,\n\t\t并且对这些算法增加了一些改进。之后通过运行程序来比较了几个算法所需要的排序时间,\n最后通过查找资料分析归纳了这些算法的特性。\n\n# 前言\n\n\n在学习多种排序算法时，发现主要是通过比较int类型或者是一些可比较的值进行排序。而字符串排序很常用，并且字符串很有特点，于是我就对字符串排序产生了兴趣。\n\n首先，学习基数排序时，课本介绍了实现多关键码排序有两种常用的方法：最高位优先MSD与最低位优先LSD。我发现与字符串排序非常符合，于是上网查了相关的资料并且借阅了网上推荐的数据结构书籍《算法4》。\n\n在《算法4》中，发现里面的第五章对字符串排序有非常详细的描述，只不过是用Java语言实现的。于是我就学习研究了里面的内容，并且将之转化位C++版本的代码。\n\n学习历程大概是先学习了最低位优先LSD排序算法,\n而上课所学的基数排序是典型的LSD排序方法，这里只是针对字符串做了相应的改变而已，所以掌握很快。之后再学习了最高位优先MSD排序算法，学习中，我发现其实和LSD算法差距不大，只是从左往右排序罢了。\n\n之后，通过它的后续章节意识到了，MSD算法其实就是专门针对字符串的快速排序，而之前老师也提过的三向快排，其实也可以用在这里，于是又学习了三向字符串快速排序算法，至此，学完了《算法4》的理论知识。\n\n随后，我用C++代码重新实现了这三个代码，并且参照《算法4》中提出的改进建议给代码做了一些优化改进。之后又受到之前所写的数据结构课程设计习题，写了个小程序来比较几个算法排序所用的时间。最后，参照《算法4》，根据自己的理解，分析归纳这几个字符串排序算法的一些特性。\n\n# LSD算法实现\n\n## LSD算法描述\n\n首先,用LSD算法对字符串数组进行排序需要保证字符串数组中的字符串长度是相等的。它从右向左以每个位置的字符作为键，以键值索引法的思想将字符串排序W遍（W为字符串的长度）。\n\n每一次排序都针对字符串的第d个字符进行排序，大致分为一下四个步骤：\n\n1.计算字符串的第d个字符出现的频率\n\n2.将频率转为索引\n\n3.将字符串按照对应组的位置放入aux中\n\n4.将排序好的字符串从aux回写到strings中\n\n排序流程：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/10fce372462e169cb3887794e93f8c9f.png)\n\n## LSD算法代码实现\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/241d7552a0c23aaba2986db42ac8ed71.jpg)\n\n# MSD算法实现\n## MSD算法描述\n\n用MSD算法排序字符串数组，实际上是从高位即从左到右对字符串不断排序，它不要求字符串数组中的字符串长度都相同，适用范围更加广。它也以键值索引法为基础进行排序。\n\nMSD的核心思想是分治算法，即将大问题分为小问题来解决，其思想与快速排序类似，具体做法是：先对最高位的字符（即string[0]）进行排序，将排序后的字符串进行分组——最高位相同的在一组；之后递归的对同一组继续进行MSD排序，不过此时以第二位字符进行排序，直到排完最低位，算法结束。\n\n需要注意的是，因为不要求字符串的长度必须一致，那么就要讨论递归到了字符串结尾的情况。一般来说，当一个字符串的所有字符都已经被检查了之后，它应该排在其他字符串的前面。例如abc，abcd，当检查完了c，那么abc肯定要排在abcd的前面。所以需要设置检查完所有字符的字符串放在第一组。\n\n排序的其中一部分：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/18240d4543d8b39326e438fd7b1fe51d.jpg)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/70af344d9808b75013c6a47acf6a08d3.png)\n\n## MSD算法代码实现\n\n###  charAt函数\n\n因为高位排序不一定都是同样长度的字符串，所以必须有个函数处理字符串访问越界问题。所有字符都已经被检查过的字符串所在的子数组应该排在子数组的前面。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/cafcbecf53f71070fce9efe69dbe4406.png)\n\n### exch函数\n\n一个交换字符串数组中两个元素的函数。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d8626989db2b4a7e32341b4b29682dbb.png)\n\n### 核心函数\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/926e0d743318180c57b872200d41e775.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/c56d3b0ed3edeb28150f567b0f3c9ebc.png)\n\n## MSD算法改进\n\n### 切换插入排序\n\n因为是一种递归算法，所以递归到后面将要处理大量微型数组。如果是当hi\\<=lo时才返回，那么要递归到只剩下一个字符串的子数组时才会返回，显然会对性能影响很大。\n\n所以，设置一个转换阈值M，当子数组中的元素小于这个阈值时，切换为插入排序。我设置M为15，因为插入排序在数组较小时表现比较好，所以能节约时间。\n\n还需要注意的是，切换为插入排序时，应该排序的是从lo到hi的子数组，且排序完就应该返回了，因为此时已经是有序的了。且插入排序比较的是剩余子字符串。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8c5fcd8900a07e9e72af7235ad975d16.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cd477dc4f3f8a90d252cba067016faa.png)\n\n### 随机化\n\n和快速排序一样，为了避免出现最坏情况，可以将数组打乱后再排序。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/c34b36fad4fafd37f9c596d41e745338.png)\n\n# 三向快速排序算法实现\n\n## 三向快速排序算法描述\n\nMSD算法在处理含有大量公共前缀的字符串数组时表现不太好。于是针对这个情况改进成字符串三向快速排序算法。其实这个算法和普通的三向快排很像。\n\n大致是根据字符串的首字母将字符串数组分为三个子数组，然后递归地将这三个子数组排序：一个含有所有首字母小于切分字符的字符串子数组，一个含有所有首字母等于切分字符的字符串子数组（接下来的排序将忽略他们当前这个首字符），还有一个含有所有首字符大于切分字符的子字符串数组。\n\n三向字符串快速排序示意图：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/794d594ad20409d271e73a6b796486d9.jpg)\n\n## 三向快速排序算法代码实现\n\n有一些和MSD相同的辅助函数就不列出来了\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/299173f782890294bfb087bbb98f53e7.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8897dd834f0aea0c6f3bbbb869ec5c10.png)\n\n## 三向快速排序算法改进\n\n###  切换为插入排序\n\n和MSD算法一样，在处理小子数组时，需要切换位插入排序以提高速度。hi\\<=lo+M时切换。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cd477dc4f3f8a90d252cba067016faa.png)\n\n###  随机打乱数组\n\n和快速排序一样，最好在排序之前将数组打乱或者将第一个元素和一个随机位置的元素交换以得到一个随机的切分元素，这样就可以预防数组已经有序或是接近有序的最坏情况。\n\n我在这里的随机化算法和MSD采用的不一样，我是在递归排序子数组的函数中，将数组中的lo与lo-hi之间某一元素交换。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/57054e652bc09202eac6f5c5db2abd06.png)\n\n#  三种算法排序时间比较\n\n## 比较程序说明与实现\n\n### 生成随机字符串数组并存储\n\n字符串排序需要给定数据，于是通过程序生成一个随机的存储字符串的数组，并且把它存储在txt文件中，以供后续实验能用同一个随机字符串数组，重现之前的实验结果。并且可以控制变量N与d来控制数组中字符串的个数以及每个字符串的长度。\n\n生成随机字符串数组具体实现为下图：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/02168787d572e215fb9a9538f1ee1bde.png)\n\n生成有较长公共前缀的字符串数组：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3350a847f97a6faa88c4560d88efe737.png)\n\n将生成的字符串数组存储在txt文件中实现：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/c8f72bdc446f16c6d4a97754ac8e5c50.png)\n\n### 判断字符串数组是否排序\n\n比较排序算法性能的前提是算法能正确将数组排序，但是当输入很大的时候，很难看出是否排序，于是通过程序判断，遍历排序之后的数组，如果后面的元素小于前面的元素，那么就没有排序，就给出提示并且返回。\n\n### 比较字符串数组排序时间函数实现\n\n大致实现就是在排序之前计时，然后调用相关算法排序，之后再停止计时，这样就可以查看排序所用的时间了。\n\n需要注意的是，比较不同算法的时候，传入的待排序字符串数组要相同，所以不能传引用，不然之后传入的就是已经排序的数组了，显然不对。\n\n核心代码如下：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/a9562d6f3e9d0dab931ab2d5729a7a9e.png)\n\nswitch中执行某个算法（以MSD为例）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e16e32b8398f2d8efd045f0855678fc4.png)\n\n##  不同输入下三种算法运行时间比较\n\n### 随机字符串数组 N=150000 d=5\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/703fe925fa06c578ac36916242d5e587.png)\n\n由此看出,当字符串宽带比较小的时候LSD算法所用时间显著比较短,而三向快排所用时间最长。\n\n### 随机字符串数组 N=150000 d=50\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7622834a0ac220d2cd12a0ffe3a9e8ff.png)\n\n可以看出，当字符串宽带比较长的时候，MSD算法优势比较大，所用时间最短，而三向快排还是比其他两个算法时间长很多。\n\n### 大量重复字符串数组 N=150000 d=50\n\n说明：这里给出的字符串不一定是定长的，而且有很长的公共前缀。所以不能用LSD算法进行排序，主要比较MSD算法和三向字符串快速排序算法的排序时间。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/752cf4b3a8819dafc956a9af9941c479.jpg)\n\n由此可以看出，对于有较长公共前缀的字符串组成的数组中，三向字符串快速排序算法的排序时间显著低于MSD算法。\n\n# 三种字符串排序算法的特性\n\n## 排序性能理论分析\n\n### LSD字符串排序算法性能\n\nLSD算法是稳定排序算法，因为在将他们的最后i个字符作为键进行排序之后,在对i-1字符排序时,\n\n要么因为它们的倒数第i个字符不同，所以排序算法已经将他们的顺序摆放正确,要么它们的倒数第i个字符相同，所以由于排序的稳定性它们仍然有序。排序的稳定性证明：在对最后i个字符作为键进行排序时,因为是不断遍历字符串数组放入,所以键相同的元素在排序之后会聚集在一起,但相对顺序没有变化，所以是稳定的。\n\n访问数组次数：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/560c7496c293622a796726df9fb59d96.jpg)\n\n程序运行时间：NW（N为数组大小，W为字符串长度）\n\n排序所需要的额外空间：N(N为数组大小)\n\n### MSD字符串排序算法性能\n\n如果不将之随机化，那么MSD算法也是稳定的，原因于LSD算法一致。\n\n比较次数：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3a7c10a617afc83431cf487c7aa2ba0d.jpg)\n\n程序运行时间：N到Nw之间（N为数组大小，w为字符串平均长度）\n\n排序所需要的额外空间：N+WR（N为数组大小，W为字符串最大长度,R为字母表大小，本文中是ascii码表码表的大小）\n\n### 三向字符串快速排序算法性能\n\n三向字符串快速排序不是稳定排序算法。\n\n比较次数：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d0e87d8bfe21c3b14574a5d1b2df070.png)\n\n程序运行时间：N到Nw之间（N为数组大小，w为字符串平均长度）\n\n排序所需要的额外空间：W+log N（N为数组大小，W为字符串最大长度）\n\n## 三种算法简单归纳\n\nLSD字符串算法与MSD字符串算法都是以键值索引法为基础，只不过LSD算法从右往左排序N次，而MSD算法从左往右排序。\n\nLSD算法与MSD算法都是稳定排序算法，但不是原地排序算法。而三向字符串快速排序算法不是稳定排序算法，但是是原地排序的。\n\nLSD算法只适用于定长字符串，而MSD算法于三向字符串快速排序算法对于任意长度的字符串组成的数组都适用。\n\nLSD算法适用于较短的定长字符串，MSD算法适用于随机字符串，而三向字符串快速排序算法适用于含有较长公共前缀的字符串。\n\n这三种字符串排序算法都各有优缺点，我们要根据实际情况选择适合的算法，而不是认定了只使用一种算法。\n\n# 参考文献：\n\n[1] Robert Sedgewick,Kevin Wayne 著,谢路云 译.算法（第4版）[M].\n北京:人民邮电出版社,2012年10月第一版\n","source":"_posts/项目笔记/dataStructureProjects/字符串排序算法的调研与实现.md","raw":"---\ntitle: 字符串排序算法的调研与实现\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 学习数据结构式的小论文---字符串排序算法的调研与实现\ncategories: 项目文档\ntags:\n  - 数据结构\n  - 排序\n  - 算法\nabbrlink: '80898847'\ndate: 2020-01-28 00:00:00\n---\n\n>\t参考<<算法-第四版>>写的数据结构小论文(已修改格式)\n>\t用C++代码实现了LSD算法,MSD算法以及三向快速排序算法来对字符串进行排序\n\n\n\n# [Github地址](https://github.com/tongji4m3/DataStructureDesign)\n\n# 摘要\n对于许多的排序,决定顺序的键值都是字符串,于是就想利用字符串的特殊性质来设定专门针对字符串的排序算法,使得排序效率更高。我调研并用C++代码实现了LSD算法,MSD算法以及三向快速排序算法来对字符串进行排序,\n\t\t并且对这些算法增加了一些改进。之后通过运行程序来比较了几个算法所需要的排序时间,\n最后通过查找资料分析归纳了这些算法的特性。\n\n# 前言\n\n\n在学习多种排序算法时，发现主要是通过比较int类型或者是一些可比较的值进行排序。而字符串排序很常用，并且字符串很有特点，于是我就对字符串排序产生了兴趣。\n\n首先，学习基数排序时，课本介绍了实现多关键码排序有两种常用的方法：最高位优先MSD与最低位优先LSD。我发现与字符串排序非常符合，于是上网查了相关的资料并且借阅了网上推荐的数据结构书籍《算法4》。\n\n在《算法4》中，发现里面的第五章对字符串排序有非常详细的描述，只不过是用Java语言实现的。于是我就学习研究了里面的内容，并且将之转化位C++版本的代码。\n\n学习历程大概是先学习了最低位优先LSD排序算法,\n而上课所学的基数排序是典型的LSD排序方法，这里只是针对字符串做了相应的改变而已，所以掌握很快。之后再学习了最高位优先MSD排序算法，学习中，我发现其实和LSD算法差距不大，只是从左往右排序罢了。\n\n之后，通过它的后续章节意识到了，MSD算法其实就是专门针对字符串的快速排序，而之前老师也提过的三向快排，其实也可以用在这里，于是又学习了三向字符串快速排序算法，至此，学完了《算法4》的理论知识。\n\n随后，我用C++代码重新实现了这三个代码，并且参照《算法4》中提出的改进建议给代码做了一些优化改进。之后又受到之前所写的数据结构课程设计习题，写了个小程序来比较几个算法排序所用的时间。最后，参照《算法4》，根据自己的理解，分析归纳这几个字符串排序算法的一些特性。\n\n# LSD算法实现\n\n## LSD算法描述\n\n首先,用LSD算法对字符串数组进行排序需要保证字符串数组中的字符串长度是相等的。它从右向左以每个位置的字符作为键，以键值索引法的思想将字符串排序W遍（W为字符串的长度）。\n\n每一次排序都针对字符串的第d个字符进行排序，大致分为一下四个步骤：\n\n1.计算字符串的第d个字符出现的频率\n\n2.将频率转为索引\n\n3.将字符串按照对应组的位置放入aux中\n\n4.将排序好的字符串从aux回写到strings中\n\n排序流程：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/10fce372462e169cb3887794e93f8c9f.png)\n\n## LSD算法代码实现\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/241d7552a0c23aaba2986db42ac8ed71.jpg)\n\n# MSD算法实现\n## MSD算法描述\n\n用MSD算法排序字符串数组，实际上是从高位即从左到右对字符串不断排序，它不要求字符串数组中的字符串长度都相同，适用范围更加广。它也以键值索引法为基础进行排序。\n\nMSD的核心思想是分治算法，即将大问题分为小问题来解决，其思想与快速排序类似，具体做法是：先对最高位的字符（即string[0]）进行排序，将排序后的字符串进行分组——最高位相同的在一组；之后递归的对同一组继续进行MSD排序，不过此时以第二位字符进行排序，直到排完最低位，算法结束。\n\n需要注意的是，因为不要求字符串的长度必须一致，那么就要讨论递归到了字符串结尾的情况。一般来说，当一个字符串的所有字符都已经被检查了之后，它应该排在其他字符串的前面。例如abc，abcd，当检查完了c，那么abc肯定要排在abcd的前面。所以需要设置检查完所有字符的字符串放在第一组。\n\n排序的其中一部分：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/18240d4543d8b39326e438fd7b1fe51d.jpg)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/70af344d9808b75013c6a47acf6a08d3.png)\n\n## MSD算法代码实现\n\n###  charAt函数\n\n因为高位排序不一定都是同样长度的字符串，所以必须有个函数处理字符串访问越界问题。所有字符都已经被检查过的字符串所在的子数组应该排在子数组的前面。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/cafcbecf53f71070fce9efe69dbe4406.png)\n\n### exch函数\n\n一个交换字符串数组中两个元素的函数。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d8626989db2b4a7e32341b4b29682dbb.png)\n\n### 核心函数\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/926e0d743318180c57b872200d41e775.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/c56d3b0ed3edeb28150f567b0f3c9ebc.png)\n\n## MSD算法改进\n\n### 切换插入排序\n\n因为是一种递归算法，所以递归到后面将要处理大量微型数组。如果是当hi\\<=lo时才返回，那么要递归到只剩下一个字符串的子数组时才会返回，显然会对性能影响很大。\n\n所以，设置一个转换阈值M，当子数组中的元素小于这个阈值时，切换为插入排序。我设置M为15，因为插入排序在数组较小时表现比较好，所以能节约时间。\n\n还需要注意的是，切换为插入排序时，应该排序的是从lo到hi的子数组，且排序完就应该返回了，因为此时已经是有序的了。且插入排序比较的是剩余子字符串。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8c5fcd8900a07e9e72af7235ad975d16.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cd477dc4f3f8a90d252cba067016faa.png)\n\n### 随机化\n\n和快速排序一样，为了避免出现最坏情况，可以将数组打乱后再排序。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/c34b36fad4fafd37f9c596d41e745338.png)\n\n# 三向快速排序算法实现\n\n## 三向快速排序算法描述\n\nMSD算法在处理含有大量公共前缀的字符串数组时表现不太好。于是针对这个情况改进成字符串三向快速排序算法。其实这个算法和普通的三向快排很像。\n\n大致是根据字符串的首字母将字符串数组分为三个子数组，然后递归地将这三个子数组排序：一个含有所有首字母小于切分字符的字符串子数组，一个含有所有首字母等于切分字符的字符串子数组（接下来的排序将忽略他们当前这个首字符），还有一个含有所有首字符大于切分字符的子字符串数组。\n\n三向字符串快速排序示意图：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/794d594ad20409d271e73a6b796486d9.jpg)\n\n## 三向快速排序算法代码实现\n\n有一些和MSD相同的辅助函数就不列出来了\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/299173f782890294bfb087bbb98f53e7.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8897dd834f0aea0c6f3bbbb869ec5c10.png)\n\n## 三向快速排序算法改进\n\n###  切换为插入排序\n\n和MSD算法一样，在处理小子数组时，需要切换位插入排序以提高速度。hi\\<=lo+M时切换。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cd477dc4f3f8a90d252cba067016faa.png)\n\n###  随机打乱数组\n\n和快速排序一样，最好在排序之前将数组打乱或者将第一个元素和一个随机位置的元素交换以得到一个随机的切分元素，这样就可以预防数组已经有序或是接近有序的最坏情况。\n\n我在这里的随机化算法和MSD采用的不一样，我是在递归排序子数组的函数中，将数组中的lo与lo-hi之间某一元素交换。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/57054e652bc09202eac6f5c5db2abd06.png)\n\n#  三种算法排序时间比较\n\n## 比较程序说明与实现\n\n### 生成随机字符串数组并存储\n\n字符串排序需要给定数据，于是通过程序生成一个随机的存储字符串的数组，并且把它存储在txt文件中，以供后续实验能用同一个随机字符串数组，重现之前的实验结果。并且可以控制变量N与d来控制数组中字符串的个数以及每个字符串的长度。\n\n生成随机字符串数组具体实现为下图：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/02168787d572e215fb9a9538f1ee1bde.png)\n\n生成有较长公共前缀的字符串数组：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3350a847f97a6faa88c4560d88efe737.png)\n\n将生成的字符串数组存储在txt文件中实现：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/c8f72bdc446f16c6d4a97754ac8e5c50.png)\n\n### 判断字符串数组是否排序\n\n比较排序算法性能的前提是算法能正确将数组排序，但是当输入很大的时候，很难看出是否排序，于是通过程序判断，遍历排序之后的数组，如果后面的元素小于前面的元素，那么就没有排序，就给出提示并且返回。\n\n### 比较字符串数组排序时间函数实现\n\n大致实现就是在排序之前计时，然后调用相关算法排序，之后再停止计时，这样就可以查看排序所用的时间了。\n\n需要注意的是，比较不同算法的时候，传入的待排序字符串数组要相同，所以不能传引用，不然之后传入的就是已经排序的数组了，显然不对。\n\n核心代码如下：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/a9562d6f3e9d0dab931ab2d5729a7a9e.png)\n\nswitch中执行某个算法（以MSD为例）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e16e32b8398f2d8efd045f0855678fc4.png)\n\n##  不同输入下三种算法运行时间比较\n\n### 随机字符串数组 N=150000 d=5\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/703fe925fa06c578ac36916242d5e587.png)\n\n由此看出,当字符串宽带比较小的时候LSD算法所用时间显著比较短,而三向快排所用时间最长。\n\n### 随机字符串数组 N=150000 d=50\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7622834a0ac220d2cd12a0ffe3a9e8ff.png)\n\n可以看出，当字符串宽带比较长的时候，MSD算法优势比较大，所用时间最短，而三向快排还是比其他两个算法时间长很多。\n\n### 大量重复字符串数组 N=150000 d=50\n\n说明：这里给出的字符串不一定是定长的，而且有很长的公共前缀。所以不能用LSD算法进行排序，主要比较MSD算法和三向字符串快速排序算法的排序时间。\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/752cf4b3a8819dafc956a9af9941c479.jpg)\n\n由此可以看出，对于有较长公共前缀的字符串组成的数组中，三向字符串快速排序算法的排序时间显著低于MSD算法。\n\n# 三种字符串排序算法的特性\n\n## 排序性能理论分析\n\n### LSD字符串排序算法性能\n\nLSD算法是稳定排序算法，因为在将他们的最后i个字符作为键进行排序之后,在对i-1字符排序时,\n\n要么因为它们的倒数第i个字符不同，所以排序算法已经将他们的顺序摆放正确,要么它们的倒数第i个字符相同，所以由于排序的稳定性它们仍然有序。排序的稳定性证明：在对最后i个字符作为键进行排序时,因为是不断遍历字符串数组放入,所以键相同的元素在排序之后会聚集在一起,但相对顺序没有变化，所以是稳定的。\n\n访问数组次数：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/560c7496c293622a796726df9fb59d96.jpg)\n\n程序运行时间：NW（N为数组大小，W为字符串长度）\n\n排序所需要的额外空间：N(N为数组大小)\n\n### MSD字符串排序算法性能\n\n如果不将之随机化，那么MSD算法也是稳定的，原因于LSD算法一致。\n\n比较次数：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3a7c10a617afc83431cf487c7aa2ba0d.jpg)\n\n程序运行时间：N到Nw之间（N为数组大小，w为字符串平均长度）\n\n排序所需要的额外空间：N+WR（N为数组大小，W为字符串最大长度,R为字母表大小，本文中是ascii码表码表的大小）\n\n### 三向字符串快速排序算法性能\n\n三向字符串快速排序不是稳定排序算法。\n\n比较次数：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d0e87d8bfe21c3b14574a5d1b2df070.png)\n\n程序运行时间：N到Nw之间（N为数组大小，w为字符串平均长度）\n\n排序所需要的额外空间：W+log N（N为数组大小，W为字符串最大长度）\n\n## 三种算法简单归纳\n\nLSD字符串算法与MSD字符串算法都是以键值索引法为基础，只不过LSD算法从右往左排序N次，而MSD算法从左往右排序。\n\nLSD算法与MSD算法都是稳定排序算法，但不是原地排序算法。而三向字符串快速排序算法不是稳定排序算法，但是是原地排序的。\n\nLSD算法只适用于定长字符串，而MSD算法于三向字符串快速排序算法对于任意长度的字符串组成的数组都适用。\n\nLSD算法适用于较短的定长字符串，MSD算法适用于随机字符串，而三向字符串快速排序算法适用于含有较长公共前缀的字符串。\n\n这三种字符串排序算法都各有优缺点，我们要根据实际情况选择适合的算法，而不是认定了只使用一种算法。\n\n# 参考文献：\n\n[1] Robert Sedgewick,Kevin Wayne 著,谢路云 译.算法（第4版）[M].\n北京:人民邮电出版社,2012年10月第一版\n","slug":"项目笔记/dataStructureProjects/字符串排序算法的调研与实现","published":1,"updated":"2020-11-12T11:57:30.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73r00ocjotp4ui20yv5","content":"<blockquote>\n<p>   参考&lt;&lt;算法-第四版&gt;&gt;写的数据结构小论文(已修改格式)<br>   用C++代码实现了LSD算法,MSD算法以及三向快速排序算法来对字符串进行排序</p>\n</blockquote>\n<h1 id=\"Github地址\"><a href=\"#Github地址\" class=\"headerlink\" title=\"Github地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">Github地址</a></h1><h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>对于许多的排序,决定顺序的键值都是字符串,于是就想利用字符串的特殊性质来设定专门针对字符串的排序算法,使得排序效率更高。我调研并用C++代码实现了LSD算法,MSD算法以及三向快速排序算法来对字符串进行排序,<br>        并且对这些算法增加了一些改进。之后通过运行程序来比较了几个算法所需要的排序时间,<br>最后通过查找资料分析归纳了这些算法的特性。</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在学习多种排序算法时，发现主要是通过比较int类型或者是一些可比较的值进行排序。而字符串排序很常用，并且字符串很有特点，于是我就对字符串排序产生了兴趣。</p>\n<p>首先，学习基数排序时，课本介绍了实现多关键码排序有两种常用的方法：最高位优先MSD与最低位优先LSD。我发现与字符串排序非常符合，于是上网查了相关的资料并且借阅了网上推荐的数据结构书籍《算法4》。</p>\n<p>在《算法4》中，发现里面的第五章对字符串排序有非常详细的描述，只不过是用Java语言实现的。于是我就学习研究了里面的内容，并且将之转化位C++版本的代码。</p>\n<p>学习历程大概是先学习了最低位优先LSD排序算法,<br>而上课所学的基数排序是典型的LSD排序方法，这里只是针对字符串做了相应的改变而已，所以掌握很快。之后再学习了最高位优先MSD排序算法，学习中，我发现其实和LSD算法差距不大，只是从左往右排序罢了。</p>\n<p>之后，通过它的后续章节意识到了，MSD算法其实就是专门针对字符串的快速排序，而之前老师也提过的三向快排，其实也可以用在这里，于是又学习了三向字符串快速排序算法，至此，学完了《算法4》的理论知识。</p>\n<p>随后，我用C++代码重新实现了这三个代码，并且参照《算法4》中提出的改进建议给代码做了一些优化改进。之后又受到之前所写的数据结构课程设计习题，写了个小程序来比较几个算法排序所用的时间。最后，参照《算法4》，根据自己的理解，分析归纳这几个字符串排序算法的一些特性。</p>\n<h1 id=\"LSD算法实现\"><a href=\"#LSD算法实现\" class=\"headerlink\" title=\"LSD算法实现\"></a>LSD算法实现</h1><h2 id=\"LSD算法描述\"><a href=\"#LSD算法描述\" class=\"headerlink\" title=\"LSD算法描述\"></a>LSD算法描述</h2><p>首先,用LSD算法对字符串数组进行排序需要保证字符串数组中的字符串长度是相等的。它从右向左以每个位置的字符作为键，以键值索引法的思想将字符串排序W遍（W为字符串的长度）。</p>\n<p>每一次排序都针对字符串的第d个字符进行排序，大致分为一下四个步骤：</p>\n<p>1.计算字符串的第d个字符出现的频率</p>\n<p>2.将频率转为索引</p>\n<p>3.将字符串按照对应组的位置放入aux中</p>\n<p>4.将排序好的字符串从aux回写到strings中</p>\n<p>排序流程：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/10fce372462e169cb3887794e93f8c9f.png\"></p>\n<h2 id=\"LSD算法代码实现\"><a href=\"#LSD算法代码实现\" class=\"headerlink\" title=\"LSD算法代码实现\"></a>LSD算法代码实现</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/241d7552a0c23aaba2986db42ac8ed71.jpg\"></p>\n<h1 id=\"MSD算法实现\"><a href=\"#MSD算法实现\" class=\"headerlink\" title=\"MSD算法实现\"></a>MSD算法实现</h1><h2 id=\"MSD算法描述\"><a href=\"#MSD算法描述\" class=\"headerlink\" title=\"MSD算法描述\"></a>MSD算法描述</h2><p>用MSD算法排序字符串数组，实际上是从高位即从左到右对字符串不断排序，它不要求字符串数组中的字符串长度都相同，适用范围更加广。它也以键值索引法为基础进行排序。</p>\n<p>MSD的核心思想是分治算法，即将大问题分为小问题来解决，其思想与快速排序类似，具体做法是：先对最高位的字符（即string[0]）进行排序，将排序后的字符串进行分组——最高位相同的在一组；之后递归的对同一组继续进行MSD排序，不过此时以第二位字符进行排序，直到排完最低位，算法结束。</p>\n<p>需要注意的是，因为不要求字符串的长度必须一致，那么就要讨论递归到了字符串结尾的情况。一般来说，当一个字符串的所有字符都已经被检查了之后，它应该排在其他字符串的前面。例如abc，abcd，当检查完了c，那么abc肯定要排在abcd的前面。所以需要设置检查完所有字符的字符串放在第一组。</p>\n<p>排序的其中一部分：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/18240d4543d8b39326e438fd7b1fe51d.jpg\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/70af344d9808b75013c6a47acf6a08d3.png\"></p>\n<h2 id=\"MSD算法代码实现\"><a href=\"#MSD算法代码实现\" class=\"headerlink\" title=\"MSD算法代码实现\"></a>MSD算法代码实现</h2><h3 id=\"charAt函数\"><a href=\"#charAt函数\" class=\"headerlink\" title=\"charAt函数\"></a>charAt函数</h3><p>因为高位排序不一定都是同样长度的字符串，所以必须有个函数处理字符串访问越界问题。所有字符都已经被检查过的字符串所在的子数组应该排在子数组的前面。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/cafcbecf53f71070fce9efe69dbe4406.png\"></p>\n<h3 id=\"exch函数\"><a href=\"#exch函数\" class=\"headerlink\" title=\"exch函数\"></a>exch函数</h3><p>一个交换字符串数组中两个元素的函数。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d8626989db2b4a7e32341b4b29682dbb.png\"></p>\n<h3 id=\"核心函数\"><a href=\"#核心函数\" class=\"headerlink\" title=\"核心函数\"></a>核心函数</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/926e0d743318180c57b872200d41e775.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/c56d3b0ed3edeb28150f567b0f3c9ebc.png\"></p>\n<h2 id=\"MSD算法改进\"><a href=\"#MSD算法改进\" class=\"headerlink\" title=\"MSD算法改进\"></a>MSD算法改进</h2><h3 id=\"切换插入排序\"><a href=\"#切换插入排序\" class=\"headerlink\" title=\"切换插入排序\"></a>切换插入排序</h3><p>因为是一种递归算法，所以递归到后面将要处理大量微型数组。如果是当hi&lt;=lo时才返回，那么要递归到只剩下一个字符串的子数组时才会返回，显然会对性能影响很大。</p>\n<p>所以，设置一个转换阈值M，当子数组中的元素小于这个阈值时，切换为插入排序。我设置M为15，因为插入排序在数组较小时表现比较好，所以能节约时间。</p>\n<p>还需要注意的是，切换为插入排序时，应该排序的是从lo到hi的子数组，且排序完就应该返回了，因为此时已经是有序的了。且插入排序比较的是剩余子字符串。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8c5fcd8900a07e9e72af7235ad975d16.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cd477dc4f3f8a90d252cba067016faa.png\"></p>\n<h3 id=\"随机化\"><a href=\"#随机化\" class=\"headerlink\" title=\"随机化\"></a>随机化</h3><p>和快速排序一样，为了避免出现最坏情况，可以将数组打乱后再排序。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/c34b36fad4fafd37f9c596d41e745338.png\"></p>\n<h1 id=\"三向快速排序算法实现\"><a href=\"#三向快速排序算法实现\" class=\"headerlink\" title=\"三向快速排序算法实现\"></a>三向快速排序算法实现</h1><h2 id=\"三向快速排序算法描述\"><a href=\"#三向快速排序算法描述\" class=\"headerlink\" title=\"三向快速排序算法描述\"></a>三向快速排序算法描述</h2><p>MSD算法在处理含有大量公共前缀的字符串数组时表现不太好。于是针对这个情况改进成字符串三向快速排序算法。其实这个算法和普通的三向快排很像。</p>\n<p>大致是根据字符串的首字母将字符串数组分为三个子数组，然后递归地将这三个子数组排序：一个含有所有首字母小于切分字符的字符串子数组，一个含有所有首字母等于切分字符的字符串子数组（接下来的排序将忽略他们当前这个首字符），还有一个含有所有首字符大于切分字符的子字符串数组。</p>\n<p>三向字符串快速排序示意图：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/794d594ad20409d271e73a6b796486d9.jpg\"></p>\n<h2 id=\"三向快速排序算法代码实现\"><a href=\"#三向快速排序算法代码实现\" class=\"headerlink\" title=\"三向快速排序算法代码实现\"></a>三向快速排序算法代码实现</h2><p>有一些和MSD相同的辅助函数就不列出来了</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/299173f782890294bfb087bbb98f53e7.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8897dd834f0aea0c6f3bbbb869ec5c10.png\"></p>\n<h2 id=\"三向快速排序算法改进\"><a href=\"#三向快速排序算法改进\" class=\"headerlink\" title=\"三向快速排序算法改进\"></a>三向快速排序算法改进</h2><h3 id=\"切换为插入排序\"><a href=\"#切换为插入排序\" class=\"headerlink\" title=\"切换为插入排序\"></a>切换为插入排序</h3><p>和MSD算法一样，在处理小子数组时，需要切换位插入排序以提高速度。hi&lt;=lo+M时切换。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cd477dc4f3f8a90d252cba067016faa.png\"></p>\n<h3 id=\"随机打乱数组\"><a href=\"#随机打乱数组\" class=\"headerlink\" title=\"随机打乱数组\"></a>随机打乱数组</h3><p>和快速排序一样，最好在排序之前将数组打乱或者将第一个元素和一个随机位置的元素交换以得到一个随机的切分元素，这样就可以预防数组已经有序或是接近有序的最坏情况。</p>\n<p>我在这里的随机化算法和MSD采用的不一样，我是在递归排序子数组的函数中，将数组中的lo与lo-hi之间某一元素交换。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/57054e652bc09202eac6f5c5db2abd06.png\"></p>\n<h1 id=\"三种算法排序时间比较\"><a href=\"#三种算法排序时间比较\" class=\"headerlink\" title=\"三种算法排序时间比较\"></a>三种算法排序时间比较</h1><h2 id=\"比较程序说明与实现\"><a href=\"#比较程序说明与实现\" class=\"headerlink\" title=\"比较程序说明与实现\"></a>比较程序说明与实现</h2><h3 id=\"生成随机字符串数组并存储\"><a href=\"#生成随机字符串数组并存储\" class=\"headerlink\" title=\"生成随机字符串数组并存储\"></a>生成随机字符串数组并存储</h3><p>字符串排序需要给定数据，于是通过程序生成一个随机的存储字符串的数组，并且把它存储在txt文件中，以供后续实验能用同一个随机字符串数组，重现之前的实验结果。并且可以控制变量N与d来控制数组中字符串的个数以及每个字符串的长度。</p>\n<p>生成随机字符串数组具体实现为下图：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/02168787d572e215fb9a9538f1ee1bde.png\"></p>\n<p>生成有较长公共前缀的字符串数组：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3350a847f97a6faa88c4560d88efe737.png\"></p>\n<p>将生成的字符串数组存储在txt文件中实现：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/c8f72bdc446f16c6d4a97754ac8e5c50.png\"></p>\n<h3 id=\"判断字符串数组是否排序\"><a href=\"#判断字符串数组是否排序\" class=\"headerlink\" title=\"判断字符串数组是否排序\"></a>判断字符串数组是否排序</h3><p>比较排序算法性能的前提是算法能正确将数组排序，但是当输入很大的时候，很难看出是否排序，于是通过程序判断，遍历排序之后的数组，如果后面的元素小于前面的元素，那么就没有排序，就给出提示并且返回。</p>\n<h3 id=\"比较字符串数组排序时间函数实现\"><a href=\"#比较字符串数组排序时间函数实现\" class=\"headerlink\" title=\"比较字符串数组排序时间函数实现\"></a>比较字符串数组排序时间函数实现</h3><p>大致实现就是在排序之前计时，然后调用相关算法排序，之后再停止计时，这样就可以查看排序所用的时间了。</p>\n<p>需要注意的是，比较不同算法的时候，传入的待排序字符串数组要相同，所以不能传引用，不然之后传入的就是已经排序的数组了，显然不对。</p>\n<p>核心代码如下：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/a9562d6f3e9d0dab931ab2d5729a7a9e.png\"></p>\n<p>switch中执行某个算法（以MSD为例）：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e16e32b8398f2d8efd045f0855678fc4.png\"></p>\n<h2 id=\"不同输入下三种算法运行时间比较\"><a href=\"#不同输入下三种算法运行时间比较\" class=\"headerlink\" title=\"不同输入下三种算法运行时间比较\"></a>不同输入下三种算法运行时间比较</h2><h3 id=\"随机字符串数组-N-150000-d-5\"><a href=\"#随机字符串数组-N-150000-d-5\" class=\"headerlink\" title=\"随机字符串数组 N=150000 d=5\"></a>随机字符串数组 N=150000 d=5</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/703fe925fa06c578ac36916242d5e587.png\"></p>\n<p>由此看出,当字符串宽带比较小的时候LSD算法所用时间显著比较短,而三向快排所用时间最长。</p>\n<h3 id=\"随机字符串数组-N-150000-d-50\"><a href=\"#随机字符串数组-N-150000-d-50\" class=\"headerlink\" title=\"随机字符串数组 N=150000 d=50\"></a>随机字符串数组 N=150000 d=50</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7622834a0ac220d2cd12a0ffe3a9e8ff.png\"></p>\n<p>可以看出，当字符串宽带比较长的时候，MSD算法优势比较大，所用时间最短，而三向快排还是比其他两个算法时间长很多。</p>\n<h3 id=\"大量重复字符串数组-N-150000-d-50\"><a href=\"#大量重复字符串数组-N-150000-d-50\" class=\"headerlink\" title=\"大量重复字符串数组 N=150000 d=50\"></a>大量重复字符串数组 N=150000 d=50</h3><p>说明：这里给出的字符串不一定是定长的，而且有很长的公共前缀。所以不能用LSD算法进行排序，主要比较MSD算法和三向字符串快速排序算法的排序时间。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/752cf4b3a8819dafc956a9af9941c479.jpg\"></p>\n<p>由此可以看出，对于有较长公共前缀的字符串组成的数组中，三向字符串快速排序算法的排序时间显著低于MSD算法。</p>\n<h1 id=\"三种字符串排序算法的特性\"><a href=\"#三种字符串排序算法的特性\" class=\"headerlink\" title=\"三种字符串排序算法的特性\"></a>三种字符串排序算法的特性</h1><h2 id=\"排序性能理论分析\"><a href=\"#排序性能理论分析\" class=\"headerlink\" title=\"排序性能理论分析\"></a>排序性能理论分析</h2><h3 id=\"LSD字符串排序算法性能\"><a href=\"#LSD字符串排序算法性能\" class=\"headerlink\" title=\"LSD字符串排序算法性能\"></a>LSD字符串排序算法性能</h3><p>LSD算法是稳定排序算法，因为在将他们的最后i个字符作为键进行排序之后,在对i-1字符排序时,</p>\n<p>要么因为它们的倒数第i个字符不同，所以排序算法已经将他们的顺序摆放正确,要么它们的倒数第i个字符相同，所以由于排序的稳定性它们仍然有序。排序的稳定性证明：在对最后i个字符作为键进行排序时,因为是不断遍历字符串数组放入,所以键相同的元素在排序之后会聚集在一起,但相对顺序没有变化，所以是稳定的。</p>\n<p>访问数组次数：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/560c7496c293622a796726df9fb59d96.jpg\"></p>\n<p>程序运行时间：NW（N为数组大小，W为字符串长度）</p>\n<p>排序所需要的额外空间：N(N为数组大小)</p>\n<h3 id=\"MSD字符串排序算法性能\"><a href=\"#MSD字符串排序算法性能\" class=\"headerlink\" title=\"MSD字符串排序算法性能\"></a>MSD字符串排序算法性能</h3><p>如果不将之随机化，那么MSD算法也是稳定的，原因于LSD算法一致。</p>\n<p>比较次数：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3a7c10a617afc83431cf487c7aa2ba0d.jpg\"></p>\n<p>程序运行时间：N到Nw之间（N为数组大小，w为字符串平均长度）</p>\n<p>排序所需要的额外空间：N+WR（N为数组大小，W为字符串最大长度,R为字母表大小，本文中是ascii码表码表的大小）</p>\n<h3 id=\"三向字符串快速排序算法性能\"><a href=\"#三向字符串快速排序算法性能\" class=\"headerlink\" title=\"三向字符串快速排序算法性能\"></a>三向字符串快速排序算法性能</h3><p>三向字符串快速排序不是稳定排序算法。</p>\n<p>比较次数：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d0e87d8bfe21c3b14574a5d1b2df070.png\"></p>\n<p>程序运行时间：N到Nw之间（N为数组大小，w为字符串平均长度）</p>\n<p>排序所需要的额外空间：W+log N（N为数组大小，W为字符串最大长度）</p>\n<h2 id=\"三种算法简单归纳\"><a href=\"#三种算法简单归纳\" class=\"headerlink\" title=\"三种算法简单归纳\"></a>三种算法简单归纳</h2><p>LSD字符串算法与MSD字符串算法都是以键值索引法为基础，只不过LSD算法从右往左排序N次，而MSD算法从左往右排序。</p>\n<p>LSD算法与MSD算法都是稳定排序算法，但不是原地排序算法。而三向字符串快速排序算法不是稳定排序算法，但是是原地排序的。</p>\n<p>LSD算法只适用于定长字符串，而MSD算法于三向字符串快速排序算法对于任意长度的字符串组成的数组都适用。</p>\n<p>LSD算法适用于较短的定长字符串，MSD算法适用于随机字符串，而三向字符串快速排序算法适用于含有较长公共前缀的字符串。</p>\n<p>这三种字符串排序算法都各有优缺点，我们要根据实际情况选择适合的算法，而不是认定了只使用一种算法。</p>\n<h1 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h1><p>[1] Robert Sedgewick,Kevin Wayne 著,谢路云 译.算法（第4版）[M].<br>北京:人民邮电出版社,2012年10月第一版</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<blockquote>\n<p>   参考&lt;&lt;算法-第四版&gt;&gt;写的数据结构小论文(已修改格式)<br>   用C++代码实现了LSD算法,MSD算法以及三向快速排序算法来对字符串进行排序</p>\n</blockquote>\n<h1 id=\"Github地址\"><a href=\"#Github地址\" class=\"headerlink\" title=\"Github地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">Github地址</a></h1><h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>对于许多的排序,决定顺序的键值都是字符串,于是就想利用字符串的特殊性质来设定专门针对字符串的排序算法,使得排序效率更高。我调研并用C++代码实现了LSD算法,MSD算法以及三向快速排序算法来对字符串进行排序,<br>        并且对这些算法增加了一些改进。之后通过运行程序来比较了几个算法所需要的排序时间,<br>最后通过查找资料分析归纳了这些算法的特性。</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在学习多种排序算法时，发现主要是通过比较int类型或者是一些可比较的值进行排序。而字符串排序很常用，并且字符串很有特点，于是我就对字符串排序产生了兴趣。</p>\n<p>首先，学习基数排序时，课本介绍了实现多关键码排序有两种常用的方法：最高位优先MSD与最低位优先LSD。我发现与字符串排序非常符合，于是上网查了相关的资料并且借阅了网上推荐的数据结构书籍《算法4》。</p>\n<p>在《算法4》中，发现里面的第五章对字符串排序有非常详细的描述，只不过是用Java语言实现的。于是我就学习研究了里面的内容，并且将之转化位C++版本的代码。</p>\n<p>学习历程大概是先学习了最低位优先LSD排序算法,<br>而上课所学的基数排序是典型的LSD排序方法，这里只是针对字符串做了相应的改变而已，所以掌握很快。之后再学习了最高位优先MSD排序算法，学习中，我发现其实和LSD算法差距不大，只是从左往右排序罢了。</p>\n<p>之后，通过它的后续章节意识到了，MSD算法其实就是专门针对字符串的快速排序，而之前老师也提过的三向快排，其实也可以用在这里，于是又学习了三向字符串快速排序算法，至此，学完了《算法4》的理论知识。</p>\n<p>随后，我用C++代码重新实现了这三个代码，并且参照《算法4》中提出的改进建议给代码做了一些优化改进。之后又受到之前所写的数据结构课程设计习题，写了个小程序来比较几个算法排序所用的时间。最后，参照《算法4》，根据自己的理解，分析归纳这几个字符串排序算法的一些特性。</p>\n<h1 id=\"LSD算法实现\"><a href=\"#LSD算法实现\" class=\"headerlink\" title=\"LSD算法实现\"></a>LSD算法实现</h1><h2 id=\"LSD算法描述\"><a href=\"#LSD算法描述\" class=\"headerlink\" title=\"LSD算法描述\"></a>LSD算法描述</h2><p>首先,用LSD算法对字符串数组进行排序需要保证字符串数组中的字符串长度是相等的。它从右向左以每个位置的字符作为键，以键值索引法的思想将字符串排序W遍（W为字符串的长度）。</p>\n<p>每一次排序都针对字符串的第d个字符进行排序，大致分为一下四个步骤：</p>\n<p>1.计算字符串的第d个字符出现的频率</p>\n<p>2.将频率转为索引</p>\n<p>3.将字符串按照对应组的位置放入aux中</p>\n<p>4.将排序好的字符串从aux回写到strings中</p>\n<p>排序流程：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/10fce372462e169cb3887794e93f8c9f.png\"></p>\n<h2 id=\"LSD算法代码实现\"><a href=\"#LSD算法代码实现\" class=\"headerlink\" title=\"LSD算法代码实现\"></a>LSD算法代码实现</h2><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/241d7552a0c23aaba2986db42ac8ed71.jpg\"></p>\n<h1 id=\"MSD算法实现\"><a href=\"#MSD算法实现\" class=\"headerlink\" title=\"MSD算法实现\"></a>MSD算法实现</h1><h2 id=\"MSD算法描述\"><a href=\"#MSD算法描述\" class=\"headerlink\" title=\"MSD算法描述\"></a>MSD算法描述</h2><p>用MSD算法排序字符串数组，实际上是从高位即从左到右对字符串不断排序，它不要求字符串数组中的字符串长度都相同，适用范围更加广。它也以键值索引法为基础进行排序。</p>\n<p>MSD的核心思想是分治算法，即将大问题分为小问题来解决，其思想与快速排序类似，具体做法是：先对最高位的字符（即string[0]）进行排序，将排序后的字符串进行分组——最高位相同的在一组；之后递归的对同一组继续进行MSD排序，不过此时以第二位字符进行排序，直到排完最低位，算法结束。</p>\n<p>需要注意的是，因为不要求字符串的长度必须一致，那么就要讨论递归到了字符串结尾的情况。一般来说，当一个字符串的所有字符都已经被检查了之后，它应该排在其他字符串的前面。例如abc，abcd，当检查完了c，那么abc肯定要排在abcd的前面。所以需要设置检查完所有字符的字符串放在第一组。</p>\n<p>排序的其中一部分：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/18240d4543d8b39326e438fd7b1fe51d.jpg\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/70af344d9808b75013c6a47acf6a08d3.png\"></p>\n<h2 id=\"MSD算法代码实现\"><a href=\"#MSD算法代码实现\" class=\"headerlink\" title=\"MSD算法代码实现\"></a>MSD算法代码实现</h2><h3 id=\"charAt函数\"><a href=\"#charAt函数\" class=\"headerlink\" title=\"charAt函数\"></a>charAt函数</h3><p>因为高位排序不一定都是同样长度的字符串，所以必须有个函数处理字符串访问越界问题。所有字符都已经被检查过的字符串所在的子数组应该排在子数组的前面。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/cafcbecf53f71070fce9efe69dbe4406.png\"></p>\n<h3 id=\"exch函数\"><a href=\"#exch函数\" class=\"headerlink\" title=\"exch函数\"></a>exch函数</h3><p>一个交换字符串数组中两个元素的函数。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d8626989db2b4a7e32341b4b29682dbb.png\"></p>\n<h3 id=\"核心函数\"><a href=\"#核心函数\" class=\"headerlink\" title=\"核心函数\"></a>核心函数</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/926e0d743318180c57b872200d41e775.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/c56d3b0ed3edeb28150f567b0f3c9ebc.png\"></p>\n<h2 id=\"MSD算法改进\"><a href=\"#MSD算法改进\" class=\"headerlink\" title=\"MSD算法改进\"></a>MSD算法改进</h2><h3 id=\"切换插入排序\"><a href=\"#切换插入排序\" class=\"headerlink\" title=\"切换插入排序\"></a>切换插入排序</h3><p>因为是一种递归算法，所以递归到后面将要处理大量微型数组。如果是当hi&lt;=lo时才返回，那么要递归到只剩下一个字符串的子数组时才会返回，显然会对性能影响很大。</p>\n<p>所以，设置一个转换阈值M，当子数组中的元素小于这个阈值时，切换为插入排序。我设置M为15，因为插入排序在数组较小时表现比较好，所以能节约时间。</p>\n<p>还需要注意的是，切换为插入排序时，应该排序的是从lo到hi的子数组，且排序完就应该返回了，因为此时已经是有序的了。且插入排序比较的是剩余子字符串。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8c5fcd8900a07e9e72af7235ad975d16.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cd477dc4f3f8a90d252cba067016faa.png\"></p>\n<h3 id=\"随机化\"><a href=\"#随机化\" class=\"headerlink\" title=\"随机化\"></a>随机化</h3><p>和快速排序一样，为了避免出现最坏情况，可以将数组打乱后再排序。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/c34b36fad4fafd37f9c596d41e745338.png\"></p>\n<h1 id=\"三向快速排序算法实现\"><a href=\"#三向快速排序算法实现\" class=\"headerlink\" title=\"三向快速排序算法实现\"></a>三向快速排序算法实现</h1><h2 id=\"三向快速排序算法描述\"><a href=\"#三向快速排序算法描述\" class=\"headerlink\" title=\"三向快速排序算法描述\"></a>三向快速排序算法描述</h2><p>MSD算法在处理含有大量公共前缀的字符串数组时表现不太好。于是针对这个情况改进成字符串三向快速排序算法。其实这个算法和普通的三向快排很像。</p>\n<p>大致是根据字符串的首字母将字符串数组分为三个子数组，然后递归地将这三个子数组排序：一个含有所有首字母小于切分字符的字符串子数组，一个含有所有首字母等于切分字符的字符串子数组（接下来的排序将忽略他们当前这个首字符），还有一个含有所有首字符大于切分字符的子字符串数组。</p>\n<p>三向字符串快速排序示意图：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/794d594ad20409d271e73a6b796486d9.jpg\"></p>\n<h2 id=\"三向快速排序算法代码实现\"><a href=\"#三向快速排序算法代码实现\" class=\"headerlink\" title=\"三向快速排序算法代码实现\"></a>三向快速排序算法代码实现</h2><p>有一些和MSD相同的辅助函数就不列出来了</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/299173f782890294bfb087bbb98f53e7.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8897dd834f0aea0c6f3bbbb869ec5c10.png\"></p>\n<h2 id=\"三向快速排序算法改进\"><a href=\"#三向快速排序算法改进\" class=\"headerlink\" title=\"三向快速排序算法改进\"></a>三向快速排序算法改进</h2><h3 id=\"切换为插入排序\"><a href=\"#切换为插入排序\" class=\"headerlink\" title=\"切换为插入排序\"></a>切换为插入排序</h3><p>和MSD算法一样，在处理小子数组时，需要切换位插入排序以提高速度。hi&lt;=lo+M时切换。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cd477dc4f3f8a90d252cba067016faa.png\"></p>\n<h3 id=\"随机打乱数组\"><a href=\"#随机打乱数组\" class=\"headerlink\" title=\"随机打乱数组\"></a>随机打乱数组</h3><p>和快速排序一样，最好在排序之前将数组打乱或者将第一个元素和一个随机位置的元素交换以得到一个随机的切分元素，这样就可以预防数组已经有序或是接近有序的最坏情况。</p>\n<p>我在这里的随机化算法和MSD采用的不一样，我是在递归排序子数组的函数中，将数组中的lo与lo-hi之间某一元素交换。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/57054e652bc09202eac6f5c5db2abd06.png\"></p>\n<h1 id=\"三种算法排序时间比较\"><a href=\"#三种算法排序时间比较\" class=\"headerlink\" title=\"三种算法排序时间比较\"></a>三种算法排序时间比较</h1><h2 id=\"比较程序说明与实现\"><a href=\"#比较程序说明与实现\" class=\"headerlink\" title=\"比较程序说明与实现\"></a>比较程序说明与实现</h2><h3 id=\"生成随机字符串数组并存储\"><a href=\"#生成随机字符串数组并存储\" class=\"headerlink\" title=\"生成随机字符串数组并存储\"></a>生成随机字符串数组并存储</h3><p>字符串排序需要给定数据，于是通过程序生成一个随机的存储字符串的数组，并且把它存储在txt文件中，以供后续实验能用同一个随机字符串数组，重现之前的实验结果。并且可以控制变量N与d来控制数组中字符串的个数以及每个字符串的长度。</p>\n<p>生成随机字符串数组具体实现为下图：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/02168787d572e215fb9a9538f1ee1bde.png\"></p>\n<p>生成有较长公共前缀的字符串数组：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3350a847f97a6faa88c4560d88efe737.png\"></p>\n<p>将生成的字符串数组存储在txt文件中实现：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/c8f72bdc446f16c6d4a97754ac8e5c50.png\"></p>\n<h3 id=\"判断字符串数组是否排序\"><a href=\"#判断字符串数组是否排序\" class=\"headerlink\" title=\"判断字符串数组是否排序\"></a>判断字符串数组是否排序</h3><p>比较排序算法性能的前提是算法能正确将数组排序，但是当输入很大的时候，很难看出是否排序，于是通过程序判断，遍历排序之后的数组，如果后面的元素小于前面的元素，那么就没有排序，就给出提示并且返回。</p>\n<h3 id=\"比较字符串数组排序时间函数实现\"><a href=\"#比较字符串数组排序时间函数实现\" class=\"headerlink\" title=\"比较字符串数组排序时间函数实现\"></a>比较字符串数组排序时间函数实现</h3><p>大致实现就是在排序之前计时，然后调用相关算法排序，之后再停止计时，这样就可以查看排序所用的时间了。</p>\n<p>需要注意的是，比较不同算法的时候，传入的待排序字符串数组要相同，所以不能传引用，不然之后传入的就是已经排序的数组了，显然不对。</p>\n<p>核心代码如下：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/a9562d6f3e9d0dab931ab2d5729a7a9e.png\"></p>\n<p>switch中执行某个算法（以MSD为例）：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e16e32b8398f2d8efd045f0855678fc4.png\"></p>\n<h2 id=\"不同输入下三种算法运行时间比较\"><a href=\"#不同输入下三种算法运行时间比较\" class=\"headerlink\" title=\"不同输入下三种算法运行时间比较\"></a>不同输入下三种算法运行时间比较</h2><h3 id=\"随机字符串数组-N-150000-d-5\"><a href=\"#随机字符串数组-N-150000-d-5\" class=\"headerlink\" title=\"随机字符串数组 N=150000 d=5\"></a>随机字符串数组 N=150000 d=5</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/703fe925fa06c578ac36916242d5e587.png\"></p>\n<p>由此看出,当字符串宽带比较小的时候LSD算法所用时间显著比较短,而三向快排所用时间最长。</p>\n<h3 id=\"随机字符串数组-N-150000-d-50\"><a href=\"#随机字符串数组-N-150000-d-50\" class=\"headerlink\" title=\"随机字符串数组 N=150000 d=50\"></a>随机字符串数组 N=150000 d=50</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7622834a0ac220d2cd12a0ffe3a9e8ff.png\"></p>\n<p>可以看出，当字符串宽带比较长的时候，MSD算法优势比较大，所用时间最短，而三向快排还是比其他两个算法时间长很多。</p>\n<h3 id=\"大量重复字符串数组-N-150000-d-50\"><a href=\"#大量重复字符串数组-N-150000-d-50\" class=\"headerlink\" title=\"大量重复字符串数组 N=150000 d=50\"></a>大量重复字符串数组 N=150000 d=50</h3><p>说明：这里给出的字符串不一定是定长的，而且有很长的公共前缀。所以不能用LSD算法进行排序，主要比较MSD算法和三向字符串快速排序算法的排序时间。</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/752cf4b3a8819dafc956a9af9941c479.jpg\"></p>\n<p>由此可以看出，对于有较长公共前缀的字符串组成的数组中，三向字符串快速排序算法的排序时间显著低于MSD算法。</p>\n<h1 id=\"三种字符串排序算法的特性\"><a href=\"#三种字符串排序算法的特性\" class=\"headerlink\" title=\"三种字符串排序算法的特性\"></a>三种字符串排序算法的特性</h1><h2 id=\"排序性能理论分析\"><a href=\"#排序性能理论分析\" class=\"headerlink\" title=\"排序性能理论分析\"></a>排序性能理论分析</h2><h3 id=\"LSD字符串排序算法性能\"><a href=\"#LSD字符串排序算法性能\" class=\"headerlink\" title=\"LSD字符串排序算法性能\"></a>LSD字符串排序算法性能</h3><p>LSD算法是稳定排序算法，因为在将他们的最后i个字符作为键进行排序之后,在对i-1字符排序时,</p>\n<p>要么因为它们的倒数第i个字符不同，所以排序算法已经将他们的顺序摆放正确,要么它们的倒数第i个字符相同，所以由于排序的稳定性它们仍然有序。排序的稳定性证明：在对最后i个字符作为键进行排序时,因为是不断遍历字符串数组放入,所以键相同的元素在排序之后会聚集在一起,但相对顺序没有变化，所以是稳定的。</p>\n<p>访问数组次数：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/560c7496c293622a796726df9fb59d96.jpg\"></p>\n<p>程序运行时间：NW（N为数组大小，W为字符串长度）</p>\n<p>排序所需要的额外空间：N(N为数组大小)</p>\n<h3 id=\"MSD字符串排序算法性能\"><a href=\"#MSD字符串排序算法性能\" class=\"headerlink\" title=\"MSD字符串排序算法性能\"></a>MSD字符串排序算法性能</h3><p>如果不将之随机化，那么MSD算法也是稳定的，原因于LSD算法一致。</p>\n<p>比较次数：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3a7c10a617afc83431cf487c7aa2ba0d.jpg\"></p>\n<p>程序运行时间：N到Nw之间（N为数组大小，w为字符串平均长度）</p>\n<p>排序所需要的额外空间：N+WR（N为数组大小，W为字符串最大长度,R为字母表大小，本文中是ascii码表码表的大小）</p>\n<h3 id=\"三向字符串快速排序算法性能\"><a href=\"#三向字符串快速排序算法性能\" class=\"headerlink\" title=\"三向字符串快速排序算法性能\"></a>三向字符串快速排序算法性能</h3><p>三向字符串快速排序不是稳定排序算法。</p>\n<p>比较次数：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d0e87d8bfe21c3b14574a5d1b2df070.png\"></p>\n<p>程序运行时间：N到Nw之间（N为数组大小，w为字符串平均长度）</p>\n<p>排序所需要的额外空间：W+log N（N为数组大小，W为字符串最大长度）</p>\n<h2 id=\"三种算法简单归纳\"><a href=\"#三种算法简单归纳\" class=\"headerlink\" title=\"三种算法简单归纳\"></a>三种算法简单归纳</h2><p>LSD字符串算法与MSD字符串算法都是以键值索引法为基础，只不过LSD算法从右往左排序N次，而MSD算法从左往右排序。</p>\n<p>LSD算法与MSD算法都是稳定排序算法，但不是原地排序算法。而三向字符串快速排序算法不是稳定排序算法，但是是原地排序的。</p>\n<p>LSD算法只适用于定长字符串，而MSD算法于三向字符串快速排序算法对于任意长度的字符串组成的数组都适用。</p>\n<p>LSD算法适用于较短的定长字符串，MSD算法适用于随机字符串，而三向字符串快速排序算法适用于含有较长公共前缀的字符串。</p>\n<p>这三种字符串排序算法都各有优缺点，我们要根据实际情况选择适合的算法，而不是认定了只使用一种算法。</p>\n<h1 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h1><p>[1] Robert Sedgewick,Kevin Wayne 著,谢路云 译.算法（第4版）[M].<br>北京:人民邮电出版社,2012年10月第一版</p>\n"},{"title":"数据结构项目-------模拟银行业务","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习数据结构项目--模拟银行业务所写的文档,主要就是对两个链表合并.","abbrlink":"649c347b","date":"2020-01-10T16:00:00.000Z","_content":"\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n\n>   银行业务\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目内容\n\n设某银行有A，B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍----即当A窗口每处理完2个顾客是，B窗口处理完1个顾客。给定到达银行的顾客序列，请按照业务完成的顺序输出顾客序列。假定不考虑顾客信后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口的顾客优先输出。\n\n## 1.2 功能要求\n\n1.  输入说明：输入为一行正整数，其中第一数字N（N\\<=1000）为顾客总数，后面跟着N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，为偶数的顾客则去B窗口。数字间以空格分隔。\n\n2.  输出说明：按照业务处理完成的顺序输出顾客的编号。数字键以空格分隔，但是最后一个编号不能有多余的空格。\n\n3.  测试用例：\n\n| 序号 | 输入                 | 输出               | 说明                |\n|------|----------------------|--------------------|---------------------|\n| 1    | 8 2 1 3 9 4 11 13 15 | 1 3 2 9 11 4 13 15 | 正常测试，A窗口人多 |\n| 2    | 8 2 1 3 9 4 11 12 16 | 1 3 2 9 11 4 12 16 | 正常测试，B窗口人多 |\n| 3    | 1 6                  | 6                  | 最小N               |\n\n# 2 设计与实现\n\n## 2.1 Node类设计与实现\n\nNode类为LinkedList的基础节点，是一个模板类。它能够存储一个T类型的值以及一个指向下一Node节点的next成员变量。\n\ntemplate \\<class T\\> class Node  \n{  \npublic:  \n\nNode(const T & value, Node\\<T\\> \\*next= nullptr) : value(value), next(next) {}  \nNode(Node\\<T\\> \\*next= nullptr) : next(next) {}  \n\nT value;  \nNode\\<T\\> \\*next;  \n};\n\n## 2.2 LinkedList类设计与实现\n\n模板类，有两个Node类型的成员变量first以及last，分别指向链表头和末尾。这个类当作一个队列,其中有enqueue(),dequeue(),empty()函数。\n\nempty()：只要简单的判断first是否为空即可简单的判断队列是否为空。\n\nenqueue()：因为是队列，所以这个函数负责将数据加入链表的末尾。添加的过程是：如果头尾指针都为空的话，就让头尾指针指向这个元素，否则就在尾指针之后添加这个元素，并且让尾指针指向它。（而且如果first-\\>next为空，得让它指向last，不这样的话first只是一个单独的节点，和后续节点没有产生联系）。\n\ndequeue()：如果队列为空，返回。否则返回队列头元素（first的元素），并且让first指向它的下一个元素，如果first为空则也让last为空。\n\ntemplate\\<class T\\>class LinkedList  \n{  \npublic:  \nLinkedList():first(nullptr),last(nullptr)  \n{  \n\n}  \nbool empty()  \n{  \nreturn first == nullptr;  \n}  \nvoid enqueue(T t)  \n{  \nif(first== nullptr && last== nullptr)  \n{  \nfirst = new Node\\<T\\>(t, nullptr);  \nlast = new Node\\<T\\>(t, nullptr);  \n}  \nelse  \n{  \nNode\\<T\\> \\*temp = new Node\\<T\\>(t, nullptr);  \nlast-\\>next = temp;  \nlast=last-\\>next;  \nif(first-\\>next== nullptr)  \n{  \nfirst-\\>next = last;  \n}  \n}  \n}  \n\nT dequeue()  \n{  \nif (first == nullptr)  \n{  \nreturn nullptr;  \n}  \nT t = first-\\>value;  \nfirst = first-\\>next;  \n\nif(first== nullptr)  \n{  \nlast = nullptr;  \n}  \nreturn t;  \n}  \n\nNode\\<T\\> \\* first;  \nNode\\<T\\> \\* last;  \n};\n\n## 2.3 主函数设计与实现\n\n首先，先用一个数组存储用户输入的N个正整数，并且创建两个LinkedList链表队列，代表了A，B两个柜台。然后，根据编号为奇数还是偶数让他们分别进入两个队列（即代表了他们在A，B两个柜台上排队）。\n\n然后进入循环，循环中，如果队列A不为空，则打印此队列的头节点，并且让头节点指向下一个节点，重复一次，判断A队列是否为空，不为空则打印当前的子节点。接着判断B队列是否为空，不为空打印它的头节点，并且让他指向他的下一个节点。（其实这就是在模拟题目中的情形：当A窗口每处理完2个顾客是，B窗口处理完1个顾客。并且当不同窗口同时处理完2个顾客时，A窗口的顾客优先输出。）然后继续进入循环判断条件，如果两个队列都为空则退出循环，否则继续循环。值得注意的是,如果其中一个队列为空的话,那么就会把另一个队列的所有元素都输出了。\n\nint main()  \n{  \ncout \\<\\< \"Please Enter the total number of customers N, and the number of N\ncustomers:\";  \nint N;  \ncin \\>\\> N;  \nvector\\<int\\> customers;  \n\nLinkedList\\<int\\> listA, listB;  \n\nfor (int i = 0; i \\< N; ++i)  \n{  \nint customer;  \ncin \\>\\> customer;  \ncustomers.push_back(customer);  \n}  \nfor (int i = 0; i \\<N ; ++i)  \n{  \nif(customers[i]%2==1)//去1  \n{  \nlistA.enqueue(customers[i]);  \n}  \nelse  \n{  \nlistB.enqueue(customers[i]);  \n}  \n}  \n\nwhile(!listA.empty() \\|\\| !listB.empty())  \n{  \nif(!listA.empty())  \n{  \ncout \\<\\< listA.first-\\>value\\<\\<\" \";  \nlistA.first = listA.first-\\>next;  \n}  \nif(!listA.empty())  \n{  \ncout \\<\\< listA.first-\\>value\\<\\<\" \";  \nlistA.first = listA.first-\\>next;  \n}  \nif(!listB.empty())  \n{  \ncout \\<\\< listB.first-\\>value\\<\\<\" \";  \nlistB.first = listB.first-\\>next;  \n}  \n}  \nreturn 0;  \n}\n\n# 3 测试\n\n## 3.1 功能测试\n\n### 3.1.1 测试1\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f20d81a46ef0d048d25a26525b125288.png)\n\n### 3.1.2 测试2\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/78264740c15987c4470b339dc7a1a479.png)\n\n### 3.1.3 测试3\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7d42d39b91663ddd95e4e139ee54371c.png)\n\n### 3.1.4 测试4\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ec975646393e3460582234b996105749.png)\n\n### 3.1.5 测试5\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cf7a4eb9493bc429723d8689c38a485.png)\n\n### 3.1.6 测试6\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1af7481af6f7b5b8236c357602e5e2c2.png)\n","source":"_posts/项目笔记/dataStructureProjects/模拟银行业务.md","raw":"---\ntitle: 数据结构项目-------模拟银行业务\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习数据结构项目--模拟银行业务所写的文档,主要就是对两个链表合并.'\ncategories: 项目文档\ntags:\n  - 数据结构\n  - 指针\n  - c++\nabbrlink: 649c347b\ndate: 2020-01-11 00:00:00\n---\n\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n\n>   银行业务\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目内容\n\n设某银行有A，B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍----即当A窗口每处理完2个顾客是，B窗口处理完1个顾客。给定到达银行的顾客序列，请按照业务完成的顺序输出顾客序列。假定不考虑顾客信后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口的顾客优先输出。\n\n## 1.2 功能要求\n\n1.  输入说明：输入为一行正整数，其中第一数字N（N\\<=1000）为顾客总数，后面跟着N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，为偶数的顾客则去B窗口。数字间以空格分隔。\n\n2.  输出说明：按照业务处理完成的顺序输出顾客的编号。数字键以空格分隔，但是最后一个编号不能有多余的空格。\n\n3.  测试用例：\n\n| 序号 | 输入                 | 输出               | 说明                |\n|------|----------------------|--------------------|---------------------|\n| 1    | 8 2 1 3 9 4 11 13 15 | 1 3 2 9 11 4 13 15 | 正常测试，A窗口人多 |\n| 2    | 8 2 1 3 9 4 11 12 16 | 1 3 2 9 11 4 12 16 | 正常测试，B窗口人多 |\n| 3    | 1 6                  | 6                  | 最小N               |\n\n# 2 设计与实现\n\n## 2.1 Node类设计与实现\n\nNode类为LinkedList的基础节点，是一个模板类。它能够存储一个T类型的值以及一个指向下一Node节点的next成员变量。\n\ntemplate \\<class T\\> class Node  \n{  \npublic:  \n\nNode(const T & value, Node\\<T\\> \\*next= nullptr) : value(value), next(next) {}  \nNode(Node\\<T\\> \\*next= nullptr) : next(next) {}  \n\nT value;  \nNode\\<T\\> \\*next;  \n};\n\n## 2.2 LinkedList类设计与实现\n\n模板类，有两个Node类型的成员变量first以及last，分别指向链表头和末尾。这个类当作一个队列,其中有enqueue(),dequeue(),empty()函数。\n\nempty()：只要简单的判断first是否为空即可简单的判断队列是否为空。\n\nenqueue()：因为是队列，所以这个函数负责将数据加入链表的末尾。添加的过程是：如果头尾指针都为空的话，就让头尾指针指向这个元素，否则就在尾指针之后添加这个元素，并且让尾指针指向它。（而且如果first-\\>next为空，得让它指向last，不这样的话first只是一个单独的节点，和后续节点没有产生联系）。\n\ndequeue()：如果队列为空，返回。否则返回队列头元素（first的元素），并且让first指向它的下一个元素，如果first为空则也让last为空。\n\ntemplate\\<class T\\>class LinkedList  \n{  \npublic:  \nLinkedList():first(nullptr),last(nullptr)  \n{  \n\n}  \nbool empty()  \n{  \nreturn first == nullptr;  \n}  \nvoid enqueue(T t)  \n{  \nif(first== nullptr && last== nullptr)  \n{  \nfirst = new Node\\<T\\>(t, nullptr);  \nlast = new Node\\<T\\>(t, nullptr);  \n}  \nelse  \n{  \nNode\\<T\\> \\*temp = new Node\\<T\\>(t, nullptr);  \nlast-\\>next = temp;  \nlast=last-\\>next;  \nif(first-\\>next== nullptr)  \n{  \nfirst-\\>next = last;  \n}  \n}  \n}  \n\nT dequeue()  \n{  \nif (first == nullptr)  \n{  \nreturn nullptr;  \n}  \nT t = first-\\>value;  \nfirst = first-\\>next;  \n\nif(first== nullptr)  \n{  \nlast = nullptr;  \n}  \nreturn t;  \n}  \n\nNode\\<T\\> \\* first;  \nNode\\<T\\> \\* last;  \n};\n\n## 2.3 主函数设计与实现\n\n首先，先用一个数组存储用户输入的N个正整数，并且创建两个LinkedList链表队列，代表了A，B两个柜台。然后，根据编号为奇数还是偶数让他们分别进入两个队列（即代表了他们在A，B两个柜台上排队）。\n\n然后进入循环，循环中，如果队列A不为空，则打印此队列的头节点，并且让头节点指向下一个节点，重复一次，判断A队列是否为空，不为空则打印当前的子节点。接着判断B队列是否为空，不为空打印它的头节点，并且让他指向他的下一个节点。（其实这就是在模拟题目中的情形：当A窗口每处理完2个顾客是，B窗口处理完1个顾客。并且当不同窗口同时处理完2个顾客时，A窗口的顾客优先输出。）然后继续进入循环判断条件，如果两个队列都为空则退出循环，否则继续循环。值得注意的是,如果其中一个队列为空的话,那么就会把另一个队列的所有元素都输出了。\n\nint main()  \n{  \ncout \\<\\< \"Please Enter the total number of customers N, and the number of N\ncustomers:\";  \nint N;  \ncin \\>\\> N;  \nvector\\<int\\> customers;  \n\nLinkedList\\<int\\> listA, listB;  \n\nfor (int i = 0; i \\< N; ++i)  \n{  \nint customer;  \ncin \\>\\> customer;  \ncustomers.push_back(customer);  \n}  \nfor (int i = 0; i \\<N ; ++i)  \n{  \nif(customers[i]%2==1)//去1  \n{  \nlistA.enqueue(customers[i]);  \n}  \nelse  \n{  \nlistB.enqueue(customers[i]);  \n}  \n}  \n\nwhile(!listA.empty() \\|\\| !listB.empty())  \n{  \nif(!listA.empty())  \n{  \ncout \\<\\< listA.first-\\>value\\<\\<\" \";  \nlistA.first = listA.first-\\>next;  \n}  \nif(!listA.empty())  \n{  \ncout \\<\\< listA.first-\\>value\\<\\<\" \";  \nlistA.first = listA.first-\\>next;  \n}  \nif(!listB.empty())  \n{  \ncout \\<\\< listB.first-\\>value\\<\\<\" \";  \nlistB.first = listB.first-\\>next;  \n}  \n}  \nreturn 0;  \n}\n\n# 3 测试\n\n## 3.1 功能测试\n\n### 3.1.1 测试1\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f20d81a46ef0d048d25a26525b125288.png)\n\n### 3.1.2 测试2\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/78264740c15987c4470b339dc7a1a479.png)\n\n### 3.1.3 测试3\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7d42d39b91663ddd95e4e139ee54371c.png)\n\n### 3.1.4 测试4\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ec975646393e3460582234b996105749.png)\n\n### 3.1.5 测试5\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cf7a4eb9493bc429723d8689c38a485.png)\n\n### 3.1.6 测试6\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1af7481af6f7b5b8236c357602e5e2c2.png)\n","slug":"项目笔记/dataStructureProjects/模拟银行业务","published":1,"updated":"2020-11-12T11:57:30.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73s00ogjotp0kb3gkef","content":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  银行业务</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目内容\"><a href=\"#1-1-项目内容\" class=\"headerlink\" title=\"1.1 项目内容\"></a>1.1 项目内容</h2><p>设某银行有A，B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍—-即当A窗口每处理完2个顾客是，B窗口处理完1个顾客。给定到达银行的顾客序列，请按照业务完成的顺序输出顾客序列。假定不考虑顾客信后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口的顾客优先输出。</p>\n<h2 id=\"1-2-功能要求\"><a href=\"#1-2-功能要求\" class=\"headerlink\" title=\"1.2 功能要求\"></a>1.2 功能要求</h2><ol>\n<li><p>输入说明：输入为一行正整数，其中第一数字N（N&lt;=1000）为顾客总数，后面跟着N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，为偶数的顾客则去B窗口。数字间以空格分隔。</p>\n</li>\n<li><p>输出说明：按照业务处理完成的顺序输出顾客的编号。数字键以空格分隔，但是最后一个编号不能有多余的空格。</p>\n</li>\n<li><p>测试用例：</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>输入</th>\n<th>输出</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>8 2 1 3 9 4 11 13 15</td>\n<td>1 3 2 9 11 4 13 15</td>\n<td>正常测试，A窗口人多</td>\n</tr>\n<tr>\n<td>2</td>\n<td>8 2 1 3 9 4 11 12 16</td>\n<td>1 3 2 9 11 4 12 16</td>\n<td>正常测试，B窗口人多</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1 6</td>\n<td>6</td>\n<td>最小N</td>\n</tr>\n</tbody></table>\n<h1 id=\"2-设计与实现\"><a href=\"#2-设计与实现\" class=\"headerlink\" title=\"2 设计与实现\"></a>2 设计与实现</h1><h2 id=\"2-1-Node类设计与实现\"><a href=\"#2-1-Node类设计与实现\" class=\"headerlink\" title=\"2.1 Node类设计与实现\"></a>2.1 Node类设计与实现</h2><p>Node类为LinkedList的基础节点，是一个模板类。它能够存储一个T类型的值以及一个指向下一Node节点的next成员变量。</p>\n<p>template &lt;class T&gt; class Node<br>{<br>public:  </p>\n<p>Node(const T &amp; value, Node&lt;T&gt; *next= nullptr) : value(value), next(next) {}<br>Node(Node&lt;T&gt; *next= nullptr) : next(next) {}  </p>\n<p>T value;<br>Node&lt;T&gt; *next;<br>};</p>\n<h2 id=\"2-2-LinkedList类设计与实现\"><a href=\"#2-2-LinkedList类设计与实现\" class=\"headerlink\" title=\"2.2 LinkedList类设计与实现\"></a>2.2 LinkedList类设计与实现</h2><p>模板类，有两个Node类型的成员变量first以及last，分别指向链表头和末尾。这个类当作一个队列,其中有enqueue(),dequeue(),empty()函数。</p>\n<p>empty()：只要简单的判断first是否为空即可简单的判断队列是否为空。</p>\n<p>enqueue()：因为是队列，所以这个函数负责将数据加入链表的末尾。添加的过程是：如果头尾指针都为空的话，就让头尾指针指向这个元素，否则就在尾指针之后添加这个元素，并且让尾指针指向它。（而且如果first-&gt;next为空，得让它指向last，不这样的话first只是一个单独的节点，和后续节点没有产生联系）。</p>\n<p>dequeue()：如果队列为空，返回。否则返回队列头元素（first的元素），并且让first指向它的下一个元素，如果first为空则也让last为空。</p>\n<p>template&lt;class T&gt;class LinkedList<br>{<br>public:<br>LinkedList():first(nullptr),last(nullptr)<br>{  </p>\n<p>}<br>bool empty()<br>{<br>return first == nullptr;<br>}<br>void enqueue(T t)<br>{<br>if(first== nullptr &amp;&amp; last== nullptr)<br>{<br>first = new Node&lt;T&gt;(t, nullptr);<br>last = new Node&lt;T&gt;(t, nullptr);<br>}<br>else<br>{<br>Node&lt;T&gt; *temp = new Node&lt;T&gt;(t, nullptr);<br>last-&gt;next = temp;<br>last=last-&gt;next;<br>if(first-&gt;next== nullptr)<br>{<br>first-&gt;next = last;<br>}<br>}<br>}  </p>\n<p>T dequeue()<br>{<br>if (first == nullptr)<br>{<br>return nullptr;<br>}<br>T t = first-&gt;value;<br>first = first-&gt;next;  </p>\n<p>if(first== nullptr)<br>{<br>last = nullptr;<br>}<br>return t;<br>}  </p>\n<p>Node&lt;T&gt; * first;<br>Node&lt;T&gt; * last;<br>};</p>\n<h2 id=\"2-3-主函数设计与实现\"><a href=\"#2-3-主函数设计与实现\" class=\"headerlink\" title=\"2.3 主函数设计与实现\"></a>2.3 主函数设计与实现</h2><p>首先，先用一个数组存储用户输入的N个正整数，并且创建两个LinkedList链表队列，代表了A，B两个柜台。然后，根据编号为奇数还是偶数让他们分别进入两个队列（即代表了他们在A，B两个柜台上排队）。</p>\n<p>然后进入循环，循环中，如果队列A不为空，则打印此队列的头节点，并且让头节点指向下一个节点，重复一次，判断A队列是否为空，不为空则打印当前的子节点。接着判断B队列是否为空，不为空打印它的头节点，并且让他指向他的下一个节点。（其实这就是在模拟题目中的情形：当A窗口每处理完2个顾客是，B窗口处理完1个顾客。并且当不同窗口同时处理完2个顾客时，A窗口的顾客优先输出。）然后继续进入循环判断条件，如果两个队列都为空则退出循环，否则继续循环。值得注意的是,如果其中一个队列为空的话,那么就会把另一个队列的所有元素都输出了。</p>\n<p>int main()<br>{<br>cout &lt;&lt; “Please Enter the total number of customers N, and the number of N<br>customers:”;<br>int N;<br>cin &gt;&gt; N;<br>vector&lt;int&gt; customers;  </p>\n<p>LinkedList&lt;int&gt; listA, listB;  </p>\n<p>for (int i = 0; i &lt; N; ++i)<br>{<br>int customer;<br>cin &gt;&gt; customer;<br>customers.push_back(customer);<br>}<br>for (int i = 0; i &lt;N ; ++i)<br>{<br>if(customers[i]%2==1)//去1<br>{<br>listA.enqueue(customers[i]);<br>}<br>else<br>{<br>listB.enqueue(customers[i]);<br>}<br>}  </p>\n<p>while(!listA.empty() || !listB.empty())<br>{<br>if(!listA.empty())<br>{<br>cout &lt;&lt; listA.first-&gt;value&lt;&lt;“ “;<br>listA.first = listA.first-&gt;next;<br>}<br>if(!listA.empty())<br>{<br>cout &lt;&lt; listA.first-&gt;value&lt;&lt;“ “;<br>listA.first = listA.first-&gt;next;<br>}<br>if(!listB.empty())<br>{<br>cout &lt;&lt; listB.first-&gt;value&lt;&lt;“ “;<br>listB.first = listB.first-&gt;next;<br>}<br>}<br>return 0;<br>}</p>\n<h1 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3 测试\"></a>3 测试</h1><h2 id=\"3-1-功能测试\"><a href=\"#3-1-功能测试\" class=\"headerlink\" title=\"3.1 功能测试\"></a>3.1 功能测试</h2><h3 id=\"3-1-1-测试1\"><a href=\"#3-1-1-测试1\" class=\"headerlink\" title=\"3.1.1 测试1\"></a>3.1.1 测试1</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f20d81a46ef0d048d25a26525b125288.png\"></p>\n<h3 id=\"3-1-2-测试2\"><a href=\"#3-1-2-测试2\" class=\"headerlink\" title=\"3.1.2 测试2\"></a>3.1.2 测试2</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/78264740c15987c4470b339dc7a1a479.png\"></p>\n<h3 id=\"3-1-3-测试3\"><a href=\"#3-1-3-测试3\" class=\"headerlink\" title=\"3.1.3 测试3\"></a>3.1.3 测试3</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7d42d39b91663ddd95e4e139ee54371c.png\"></p>\n<h3 id=\"3-1-4-测试4\"><a href=\"#3-1-4-测试4\" class=\"headerlink\" title=\"3.1.4 测试4\"></a>3.1.4 测试4</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ec975646393e3460582234b996105749.png\"></p>\n<h3 id=\"3-1-5-测试5\"><a href=\"#3-1-5-测试5\" class=\"headerlink\" title=\"3.1.5 测试5\"></a>3.1.5 测试5</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cf7a4eb9493bc429723d8689c38a485.png\"></p>\n<h3 id=\"3-1-6-测试6\"><a href=\"#3-1-6-测试6\" class=\"headerlink\" title=\"3.1.6 测试6\"></a>3.1.6 测试6</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1af7481af6f7b5b8236c357602e5e2c2.png\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  银行业务</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目内容\"><a href=\"#1-1-项目内容\" class=\"headerlink\" title=\"1.1 项目内容\"></a>1.1 项目内容</h2><p>设某银行有A，B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍—-即当A窗口每处理完2个顾客是，B窗口处理完1个顾客。给定到达银行的顾客序列，请按照业务完成的顺序输出顾客序列。假定不考虑顾客信后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口的顾客优先输出。</p>\n<h2 id=\"1-2-功能要求\"><a href=\"#1-2-功能要求\" class=\"headerlink\" title=\"1.2 功能要求\"></a>1.2 功能要求</h2><ol>\n<li><p>输入说明：输入为一行正整数，其中第一数字N（N&lt;=1000）为顾客总数，后面跟着N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，为偶数的顾客则去B窗口。数字间以空格分隔。</p>\n</li>\n<li><p>输出说明：按照业务处理完成的顺序输出顾客的编号。数字键以空格分隔，但是最后一个编号不能有多余的空格。</p>\n</li>\n<li><p>测试用例：</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>输入</th>\n<th>输出</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>8 2 1 3 9 4 11 13 15</td>\n<td>1 3 2 9 11 4 13 15</td>\n<td>正常测试，A窗口人多</td>\n</tr>\n<tr>\n<td>2</td>\n<td>8 2 1 3 9 4 11 12 16</td>\n<td>1 3 2 9 11 4 12 16</td>\n<td>正常测试，B窗口人多</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1 6</td>\n<td>6</td>\n<td>最小N</td>\n</tr>\n</tbody></table>\n<h1 id=\"2-设计与实现\"><a href=\"#2-设计与实现\" class=\"headerlink\" title=\"2 设计与实现\"></a>2 设计与实现</h1><h2 id=\"2-1-Node类设计与实现\"><a href=\"#2-1-Node类设计与实现\" class=\"headerlink\" title=\"2.1 Node类设计与实现\"></a>2.1 Node类设计与实现</h2><p>Node类为LinkedList的基础节点，是一个模板类。它能够存储一个T类型的值以及一个指向下一Node节点的next成员变量。</p>\n<p>template &lt;class T&gt; class Node<br>{<br>public:  </p>\n<p>Node(const T &amp; value, Node&lt;T&gt; *next= nullptr) : value(value), next(next) {}<br>Node(Node&lt;T&gt; *next= nullptr) : next(next) {}  </p>\n<p>T value;<br>Node&lt;T&gt; *next;<br>};</p>\n<h2 id=\"2-2-LinkedList类设计与实现\"><a href=\"#2-2-LinkedList类设计与实现\" class=\"headerlink\" title=\"2.2 LinkedList类设计与实现\"></a>2.2 LinkedList类设计与实现</h2><p>模板类，有两个Node类型的成员变量first以及last，分别指向链表头和末尾。这个类当作一个队列,其中有enqueue(),dequeue(),empty()函数。</p>\n<p>empty()：只要简单的判断first是否为空即可简单的判断队列是否为空。</p>\n<p>enqueue()：因为是队列，所以这个函数负责将数据加入链表的末尾。添加的过程是：如果头尾指针都为空的话，就让头尾指针指向这个元素，否则就在尾指针之后添加这个元素，并且让尾指针指向它。（而且如果first-&gt;next为空，得让它指向last，不这样的话first只是一个单独的节点，和后续节点没有产生联系）。</p>\n<p>dequeue()：如果队列为空，返回。否则返回队列头元素（first的元素），并且让first指向它的下一个元素，如果first为空则也让last为空。</p>\n<p>template&lt;class T&gt;class LinkedList<br>{<br>public:<br>LinkedList():first(nullptr),last(nullptr)<br>{  </p>\n<p>}<br>bool empty()<br>{<br>return first == nullptr;<br>}<br>void enqueue(T t)<br>{<br>if(first== nullptr &amp;&amp; last== nullptr)<br>{<br>first = new Node&lt;T&gt;(t, nullptr);<br>last = new Node&lt;T&gt;(t, nullptr);<br>}<br>else<br>{<br>Node&lt;T&gt; *temp = new Node&lt;T&gt;(t, nullptr);<br>last-&gt;next = temp;<br>last=last-&gt;next;<br>if(first-&gt;next== nullptr)<br>{<br>first-&gt;next = last;<br>}<br>}<br>}  </p>\n<p>T dequeue()<br>{<br>if (first == nullptr)<br>{<br>return nullptr;<br>}<br>T t = first-&gt;value;<br>first = first-&gt;next;  </p>\n<p>if(first== nullptr)<br>{<br>last = nullptr;<br>}<br>return t;<br>}  </p>\n<p>Node&lt;T&gt; * first;<br>Node&lt;T&gt; * last;<br>};</p>\n<h2 id=\"2-3-主函数设计与实现\"><a href=\"#2-3-主函数设计与实现\" class=\"headerlink\" title=\"2.3 主函数设计与实现\"></a>2.3 主函数设计与实现</h2><p>首先，先用一个数组存储用户输入的N个正整数，并且创建两个LinkedList链表队列，代表了A，B两个柜台。然后，根据编号为奇数还是偶数让他们分别进入两个队列（即代表了他们在A，B两个柜台上排队）。</p>\n<p>然后进入循环，循环中，如果队列A不为空，则打印此队列的头节点，并且让头节点指向下一个节点，重复一次，判断A队列是否为空，不为空则打印当前的子节点。接着判断B队列是否为空，不为空打印它的头节点，并且让他指向他的下一个节点。（其实这就是在模拟题目中的情形：当A窗口每处理完2个顾客是，B窗口处理完1个顾客。并且当不同窗口同时处理完2个顾客时，A窗口的顾客优先输出。）然后继续进入循环判断条件，如果两个队列都为空则退出循环，否则继续循环。值得注意的是,如果其中一个队列为空的话,那么就会把另一个队列的所有元素都输出了。</p>\n<p>int main()<br>{<br>cout &lt;&lt; “Please Enter the total number of customers N, and the number of N<br>customers:”;<br>int N;<br>cin &gt;&gt; N;<br>vector&lt;int&gt; customers;  </p>\n<p>LinkedList&lt;int&gt; listA, listB;  </p>\n<p>for (int i = 0; i &lt; N; ++i)<br>{<br>int customer;<br>cin &gt;&gt; customer;<br>customers.push_back(customer);<br>}<br>for (int i = 0; i &lt;N ; ++i)<br>{<br>if(customers[i]%2==1)//去1<br>{<br>listA.enqueue(customers[i]);<br>}<br>else<br>{<br>listB.enqueue(customers[i]);<br>}<br>}  </p>\n<p>while(!listA.empty() || !listB.empty())<br>{<br>if(!listA.empty())<br>{<br>cout &lt;&lt; listA.first-&gt;value&lt;&lt;“ “;<br>listA.first = listA.first-&gt;next;<br>}<br>if(!listA.empty())<br>{<br>cout &lt;&lt; listA.first-&gt;value&lt;&lt;“ “;<br>listA.first = listA.first-&gt;next;<br>}<br>if(!listB.empty())<br>{<br>cout &lt;&lt; listB.first-&gt;value&lt;&lt;“ “;<br>listB.first = listB.first-&gt;next;<br>}<br>}<br>return 0;<br>}</p>\n<h1 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3 测试\"></a>3 测试</h1><h2 id=\"3-1-功能测试\"><a href=\"#3-1-功能测试\" class=\"headerlink\" title=\"3.1 功能测试\"></a>3.1 功能测试</h2><h3 id=\"3-1-1-测试1\"><a href=\"#3-1-1-测试1\" class=\"headerlink\" title=\"3.1.1 测试1\"></a>3.1.1 测试1</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f20d81a46ef0d048d25a26525b125288.png\"></p>\n<h3 id=\"3-1-2-测试2\"><a href=\"#3-1-2-测试2\" class=\"headerlink\" title=\"3.1.2 测试2\"></a>3.1.2 测试2</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/78264740c15987c4470b339dc7a1a479.png\"></p>\n<h3 id=\"3-1-3-测试3\"><a href=\"#3-1-3-测试3\" class=\"headerlink\" title=\"3.1.3 测试3\"></a>3.1.3 测试3</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7d42d39b91663ddd95e4e139ee54371c.png\"></p>\n<h3 id=\"3-1-4-测试4\"><a href=\"#3-1-4-测试4\" class=\"headerlink\" title=\"3.1.4 测试4\"></a>3.1.4 测试4</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ec975646393e3460582234b996105749.png\"></p>\n<h3 id=\"3-1-5-测试5\"><a href=\"#3-1-5-测试5\" class=\"headerlink\" title=\"3.1.5 测试5\"></a>3.1.5 测试5</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1cf7a4eb9493bc429723d8689c38a485.png\"></p>\n<h3 id=\"3-1-6-测试6\"><a href=\"#3-1-6-测试6\" class=\"headerlink\" title=\"3.1.6 测试6\"></a>3.1.6 测试6</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1af7481af6f7b5b8236c357602e5e2c2.png\"></p>\n"},{"title":"数据结构项目-------修理牧场","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习数据结构项目--修理牧场所写的文档,主要是用霍夫曼树的思想","abbrlink":"e550d2e","date":"2020-01-22T16:00:00.000Z","_content":"\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n\n>   修理牧场\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目简介\n\n农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数*Li*个长度单位，于是他购买了一个很长的，能锯成N块的木头，即该木头的长度是*Li*的总和。\n\n但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8，7和5的三段，第一次锯木头将木头锯成12和8，花费20；第二次锯木头将长度为12的木头锯成7和5花费12，总花费32元。如果第一次将木头锯成15和5，则第二次将木头锯成7和8，那么总的花费是35（大于32）.\n\n输入格式：输入第一行给出正整数N（N\\<104），表示要将木头锯成N块。第二行给出N个正整数，表示每块木头的长度。\n\n输出格式：输出一个整数，即将木头锯成N块的最小花费。\n\n## 1.2 解题分析\n\n给了要将木头锯成N块,与每块木头的长度。最后需要输出最小的花费。\n\n刚开始时，我的思路是因为是从一块木头开始分割的，且每次都将木块分割为两块，无非是大小不同而已。所有这道题等价与用n个元素构建一个二叉树,n个元素在树的最底层，并且使得除了root外,其他节点相加最小。但是到这里就卡住了，就不懂怎么继续进行。于是上网查了文档，它提供了另外一种思路：通过反向思考,如果每次对半分的时候,最后结果最小，那么,在只有碎片的时候,每一次都拿出最小的两个进行拼凑，就是对半分的逆过程了，\n所以只需要有一个每次都能取出最小元素的优先队列即可，所有就只要构建一个优先队列就能解决问题了。\n\n# 2 设计\n\n## 2.1 优先队列设计\n\n设计一个每次都能取出最小元素的优先队列即可。总体思路是，每一次往优先队列加入元素时，把元素放在尾部，然后让这个元素“上浮”到合适的位置,构成一个堆,堆顶为最小元素。每次取出元素时，取出堆顶元素，然后让堆顶元素与最后一个元素交换，并且让堆的数量减一，堆顶元素“下沉”。这样，不管是取出元素还是加入元素，都构成了一个堆。\n\n## 2.2 主程序设计\n\n首先利用输入的N个正整数逐个放入堆中，然后不断循环直到堆只剩下一个元素。在循环中，每次都从堆中取出最小的两个元素，让总的花费sum+=他们两个的值。并且把他们两个加起来的值继续放入堆中。\n\n直观上来说，就是在一堆木块碎片中，每次都把最小的两块碎片拼成一块，不断的拼，直到最后就只剩下最初的完整的木块了。\n\n# 3 实现\n\n## 3.1 优先队列的实现\n\n### 3.1.1 堆构造函数的实现\n\n当构造一个堆时，需要输入一个堆中应该存的元素数量最大值len，令堆中的成员变量数组的长度为len+1，（因为不用数组的vec[0]），堆的这个类还有一个N记录当前堆的元素数量。\n\n```c++\nMinPQ(int len):pq(len+1)  \n{  \n\n}\n\nprivate:  \n\tvector<int> pq;  \n\tint N;//元素个数,从1开始\n```\n\n\n\n\n\n### 3.1.2 添加元素入堆\n\n令N+1,并且在N处添加元素，然后将这个元素swim，使得还是一个堆。\n\n```c++\nvoid push(int i)  \n{  \n    pq[++N] = i;  \n    swim(N);  \n}\n```\n\n\n\n### 3.1.3 删除堆中最小元素\n\n最小元素在堆顶，先用一个变量存储堆顶的值，将堆顶与堆中最后一个元素交换，令N-1，此时不是一个堆，需要将堆顶sink到合适的位置，最后返回之前存的堆顶元素的值。\n\n```c++\nint delMin()  \n{  \n    int max = pq[1];  \n    exch(1, N--);  \n    sink(1);  \n    return max;  \n}\n```\n\n\n\n### 3.1.4 sink函数的实现\n\nSink的思路是将这个元素与他的子节点做对比，并且将较小的放上面，一直对比到这个元素小于他的两个子节点为止。\n\n具体实现是，假如要下沉k，则先找它的子节点2\\*k与2\\*k+1中最小的一个（当然得判断是否存在），如果小于他的子节点的值，那么就交换他们的值，并且让k=2\\*k或2\\*k+1（＝最小的那个），这是为了继续追踪原本的k，继续和他此时的两个子节点做对比。不断的循环，直到他没有子节点或者他小于了子节点。\n\n```c++\nvoid sink(int k)  \n{  \n    while(2 * k <=N)  \n    {  \n        int j = 2 * k;  \n        if(j+1<=N && pq[j]>pq[j+1])  \n        {  \n        \t++j;  \n        }  \n        if(pq[k]<=pq[j])  \n        {  \n       \t \tbreak;  \n        }  \n        exch(k, j);  \n        k = j;  \n    }  \n}\n```\n\n\n\n\n\n### 3.1.5 swim函数实现\n\n直观看就是一个元素比较轻，然后它要不断上浮，直到它重与他的父节点。而代码的实现就是，查看他的父节点k/2的值是否小于它，如果不小于它，则交换它和它父节点的值，并且让k=k/2，即继续追踪这个元素，让它继续与它当前的父节点做对比。直到它本身为数组的第一个元素或者它不小于它的父节点。\n\nvoid swim(int k)  \n{  \nwhile(k\\>1 && pq[k] \\< pq[k/2])  \n{  \nexch(k, k / 2);  \nk /= 2;  \n}  \n}\n\n## 3.2 主函数的实现\n\n基本和之前的设计描述差不多，就是构造堆，不断的删除两个最小元素，并且把他们的和继续加入堆中，不断循环，只剩下一个元素的时候终止。\n\n>   int main()  \n>   {  \n>   cout \\<\\< \"输入正整数N(分成N块,N\\<1024),及N个正整数(每块长度):\";  \n>   int N;  \n>   cin \\>\\> N;  \n>   int sum = 0;  \n>   MinPQ minPQ(N);  \n>   for (int i = 0; i \\< N; ++i)  \n>   {  \n>   int len;  \n>   cin \\>\\> len;  \n>   minPQ.push(len);  \n>    \n>   }  \n>   while(minPQ.size()\\>=2)  \n>   {  \n>   int min1=minPQ.delMin();  \n>   int min2=minPQ.delMin();  \n>   sum += min1 + min2;  \n>   minPQ.push(min1 + min2);  \n>   }  \n>   cout \\<\\< sum;  \n>   return 0;  \n>   }\n\n# 4 测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9f2bcd918fc4218b47f01700bd307993.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/58da745d01a35ace45bcf8246685b78d.png)\n","source":"_posts/项目笔记/dataStructureProjects/修理牧场.md","raw":"---\ntitle: 数据结构项目-------修理牧场\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习数据结构项目--修理牧场所写的文档,主要是用霍夫曼树的思想'\ncategories: 项目文档\ntags:\n  - 数据结构\n  - 堆\n  - 算法\nabbrlink: e550d2e\ndate: 2020-01-23 00:00:00\n---\n\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n\n>   修理牧场\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目简介\n\n农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数*Li*个长度单位，于是他购买了一个很长的，能锯成N块的木头，即该木头的长度是*Li*的总和。\n\n但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8，7和5的三段，第一次锯木头将木头锯成12和8，花费20；第二次锯木头将长度为12的木头锯成7和5花费12，总花费32元。如果第一次将木头锯成15和5，则第二次将木头锯成7和8，那么总的花费是35（大于32）.\n\n输入格式：输入第一行给出正整数N（N\\<104），表示要将木头锯成N块。第二行给出N个正整数，表示每块木头的长度。\n\n输出格式：输出一个整数，即将木头锯成N块的最小花费。\n\n## 1.2 解题分析\n\n给了要将木头锯成N块,与每块木头的长度。最后需要输出最小的花费。\n\n刚开始时，我的思路是因为是从一块木头开始分割的，且每次都将木块分割为两块，无非是大小不同而已。所有这道题等价与用n个元素构建一个二叉树,n个元素在树的最底层，并且使得除了root外,其他节点相加最小。但是到这里就卡住了，就不懂怎么继续进行。于是上网查了文档，它提供了另外一种思路：通过反向思考,如果每次对半分的时候,最后结果最小，那么,在只有碎片的时候,每一次都拿出最小的两个进行拼凑，就是对半分的逆过程了，\n所以只需要有一个每次都能取出最小元素的优先队列即可，所有就只要构建一个优先队列就能解决问题了。\n\n# 2 设计\n\n## 2.1 优先队列设计\n\n设计一个每次都能取出最小元素的优先队列即可。总体思路是，每一次往优先队列加入元素时，把元素放在尾部，然后让这个元素“上浮”到合适的位置,构成一个堆,堆顶为最小元素。每次取出元素时，取出堆顶元素，然后让堆顶元素与最后一个元素交换，并且让堆的数量减一，堆顶元素“下沉”。这样，不管是取出元素还是加入元素，都构成了一个堆。\n\n## 2.2 主程序设计\n\n首先利用输入的N个正整数逐个放入堆中，然后不断循环直到堆只剩下一个元素。在循环中，每次都从堆中取出最小的两个元素，让总的花费sum+=他们两个的值。并且把他们两个加起来的值继续放入堆中。\n\n直观上来说，就是在一堆木块碎片中，每次都把最小的两块碎片拼成一块，不断的拼，直到最后就只剩下最初的完整的木块了。\n\n# 3 实现\n\n## 3.1 优先队列的实现\n\n### 3.1.1 堆构造函数的实现\n\n当构造一个堆时，需要输入一个堆中应该存的元素数量最大值len，令堆中的成员变量数组的长度为len+1，（因为不用数组的vec[0]），堆的这个类还有一个N记录当前堆的元素数量。\n\n```c++\nMinPQ(int len):pq(len+1)  \n{  \n\n}\n\nprivate:  \n\tvector<int> pq;  \n\tint N;//元素个数,从1开始\n```\n\n\n\n\n\n### 3.1.2 添加元素入堆\n\n令N+1,并且在N处添加元素，然后将这个元素swim，使得还是一个堆。\n\n```c++\nvoid push(int i)  \n{  \n    pq[++N] = i;  \n    swim(N);  \n}\n```\n\n\n\n### 3.1.3 删除堆中最小元素\n\n最小元素在堆顶，先用一个变量存储堆顶的值，将堆顶与堆中最后一个元素交换，令N-1，此时不是一个堆，需要将堆顶sink到合适的位置，最后返回之前存的堆顶元素的值。\n\n```c++\nint delMin()  \n{  \n    int max = pq[1];  \n    exch(1, N--);  \n    sink(1);  \n    return max;  \n}\n```\n\n\n\n### 3.1.4 sink函数的实现\n\nSink的思路是将这个元素与他的子节点做对比，并且将较小的放上面，一直对比到这个元素小于他的两个子节点为止。\n\n具体实现是，假如要下沉k，则先找它的子节点2\\*k与2\\*k+1中最小的一个（当然得判断是否存在），如果小于他的子节点的值，那么就交换他们的值，并且让k=2\\*k或2\\*k+1（＝最小的那个），这是为了继续追踪原本的k，继续和他此时的两个子节点做对比。不断的循环，直到他没有子节点或者他小于了子节点。\n\n```c++\nvoid sink(int k)  \n{  \n    while(2 * k <=N)  \n    {  \n        int j = 2 * k;  \n        if(j+1<=N && pq[j]>pq[j+1])  \n        {  \n        \t++j;  \n        }  \n        if(pq[k]<=pq[j])  \n        {  \n       \t \tbreak;  \n        }  \n        exch(k, j);  \n        k = j;  \n    }  \n}\n```\n\n\n\n\n\n### 3.1.5 swim函数实现\n\n直观看就是一个元素比较轻，然后它要不断上浮，直到它重与他的父节点。而代码的实现就是，查看他的父节点k/2的值是否小于它，如果不小于它，则交换它和它父节点的值，并且让k=k/2，即继续追踪这个元素，让它继续与它当前的父节点做对比。直到它本身为数组的第一个元素或者它不小于它的父节点。\n\nvoid swim(int k)  \n{  \nwhile(k\\>1 && pq[k] \\< pq[k/2])  \n{  \nexch(k, k / 2);  \nk /= 2;  \n}  \n}\n\n## 3.2 主函数的实现\n\n基本和之前的设计描述差不多，就是构造堆，不断的删除两个最小元素，并且把他们的和继续加入堆中，不断循环，只剩下一个元素的时候终止。\n\n>   int main()  \n>   {  \n>   cout \\<\\< \"输入正整数N(分成N块,N\\<1024),及N个正整数(每块长度):\";  \n>   int N;  \n>   cin \\>\\> N;  \n>   int sum = 0;  \n>   MinPQ minPQ(N);  \n>   for (int i = 0; i \\< N; ++i)  \n>   {  \n>   int len;  \n>   cin \\>\\> len;  \n>   minPQ.push(len);  \n>    \n>   }  \n>   while(minPQ.size()\\>=2)  \n>   {  \n>   int min1=minPQ.delMin();  \n>   int min2=minPQ.delMin();  \n>   sum += min1 + min2;  \n>   minPQ.push(min1 + min2);  \n>   }  \n>   cout \\<\\< sum;  \n>   return 0;  \n>   }\n\n# 4 测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9f2bcd918fc4218b47f01700bd307993.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/58da745d01a35ace45bcf8246685b78d.png)\n","slug":"项目笔记/dataStructureProjects/修理牧场","published":1,"updated":"2020-11-12T11:57:30.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73t00ojjotp69hz6cfc","content":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  修理牧场</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目简介\"><a href=\"#1-1-项目简介\" class=\"headerlink\" title=\"1.1 项目简介\"></a>1.1 项目简介</h2><p>农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数<em>Li</em>个长度单位，于是他购买了一个很长的，能锯成N块的木头，即该木头的长度是<em>Li</em>的总和。</p>\n<p>但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8，7和5的三段，第一次锯木头将木头锯成12和8，花费20；第二次锯木头将长度为12的木头锯成7和5花费12，总花费32元。如果第一次将木头锯成15和5，则第二次将木头锯成7和8，那么总的花费是35（大于32）.</p>\n<p>输入格式：输入第一行给出正整数N（N&lt;104），表示要将木头锯成N块。第二行给出N个正整数，表示每块木头的长度。</p>\n<p>输出格式：输出一个整数，即将木头锯成N块的最小花费。</p>\n<h2 id=\"1-2-解题分析\"><a href=\"#1-2-解题分析\" class=\"headerlink\" title=\"1.2 解题分析\"></a>1.2 解题分析</h2><p>给了要将木头锯成N块,与每块木头的长度。最后需要输出最小的花费。</p>\n<p>刚开始时，我的思路是因为是从一块木头开始分割的，且每次都将木块分割为两块，无非是大小不同而已。所有这道题等价与用n个元素构建一个二叉树,n个元素在树的最底层，并且使得除了root外,其他节点相加最小。但是到这里就卡住了，就不懂怎么继续进行。于是上网查了文档，它提供了另外一种思路：通过反向思考,如果每次对半分的时候,最后结果最小，那么,在只有碎片的时候,每一次都拿出最小的两个进行拼凑，就是对半分的逆过程了，<br>所以只需要有一个每次都能取出最小元素的优先队列即可，所有就只要构建一个优先队列就能解决问题了。</p>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-优先队列设计\"><a href=\"#2-1-优先队列设计\" class=\"headerlink\" title=\"2.1 优先队列设计\"></a>2.1 优先队列设计</h2><p>设计一个每次都能取出最小元素的优先队列即可。总体思路是，每一次往优先队列加入元素时，把元素放在尾部，然后让这个元素“上浮”到合适的位置,构成一个堆,堆顶为最小元素。每次取出元素时，取出堆顶元素，然后让堆顶元素与最后一个元素交换，并且让堆的数量减一，堆顶元素“下沉”。这样，不管是取出元素还是加入元素，都构成了一个堆。</p>\n<h2 id=\"2-2-主程序设计\"><a href=\"#2-2-主程序设计\" class=\"headerlink\" title=\"2.2 主程序设计\"></a>2.2 主程序设计</h2><p>首先利用输入的N个正整数逐个放入堆中，然后不断循环直到堆只剩下一个元素。在循环中，每次都从堆中取出最小的两个元素，让总的花费sum+=他们两个的值。并且把他们两个加起来的值继续放入堆中。</p>\n<p>直观上来说，就是在一堆木块碎片中，每次都把最小的两块碎片拼成一块，不断的拼，直到最后就只剩下最初的完整的木块了。</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-优先队列的实现\"><a href=\"#3-1-优先队列的实现\" class=\"headerlink\" title=\"3.1 优先队列的实现\"></a>3.1 优先队列的实现</h2><h3 id=\"3-1-1-堆构造函数的实现\"><a href=\"#3-1-1-堆构造函数的实现\" class=\"headerlink\" title=\"3.1.1 堆构造函数的实现\"></a>3.1.1 堆构造函数的实现</h3><p>当构造一个堆时，需要输入一个堆中应该存的元素数量最大值len，令堆中的成员变量数组的长度为len+1，（因为不用数组的vec[0]），堆的这个类还有一个N记录当前堆的元素数量。</p>\n<pre class=\" language-c++\"><code class=\"language-c++\">MinPQ(int len):pq(len+1)  \n{  \n\n}\n\nprivate:  \n    vector<int> pq;  \n    int N;//元素个数,从1开始</code></pre>\n<h3 id=\"3-1-2-添加元素入堆\"><a href=\"#3-1-2-添加元素入堆\" class=\"headerlink\" title=\"3.1.2 添加元素入堆\"></a>3.1.2 添加元素入堆</h3><p>令N+1,并且在N处添加元素，然后将这个元素swim，使得还是一个堆。</p>\n<pre class=\" language-c++\"><code class=\"language-c++\">void push(int i)  \n{  \n    pq[++N] = i;  \n    swim(N);  \n}</code></pre>\n<h3 id=\"3-1-3-删除堆中最小元素\"><a href=\"#3-1-3-删除堆中最小元素\" class=\"headerlink\" title=\"3.1.3 删除堆中最小元素\"></a>3.1.3 删除堆中最小元素</h3><p>最小元素在堆顶，先用一个变量存储堆顶的值，将堆顶与堆中最后一个元素交换，令N-1，此时不是一个堆，需要将堆顶sink到合适的位置，最后返回之前存的堆顶元素的值。</p>\n<pre class=\" language-c++\"><code class=\"language-c++\">int delMin()  \n{  \n    int max = pq[1];  \n    exch(1, N--);  \n    sink(1);  \n    return max;  \n}</code></pre>\n<h3 id=\"3-1-4-sink函数的实现\"><a href=\"#3-1-4-sink函数的实现\" class=\"headerlink\" title=\"3.1.4 sink函数的实现\"></a>3.1.4 sink函数的实现</h3><p>Sink的思路是将这个元素与他的子节点做对比，并且将较小的放上面，一直对比到这个元素小于他的两个子节点为止。</p>\n<p>具体实现是，假如要下沉k，则先找它的子节点2*k与2*k+1中最小的一个（当然得判断是否存在），如果小于他的子节点的值，那么就交换他们的值，并且让k=2*k或2*k+1（＝最小的那个），这是为了继续追踪原本的k，继续和他此时的两个子节点做对比。不断的循环，直到他没有子节点或者他小于了子节点。</p>\n<pre class=\" language-c++\"><code class=\"language-c++\">void sink(int k)  \n{  \n    while(2 * k <=N)  \n    {  \n        int j = 2 * k;  \n        if(j+1<=N && pq[j]>pq[j+1])  \n        {  \n            ++j;  \n        }  \n        if(pq[k]<=pq[j])  \n        {  \n                break;  \n        }  \n        exch(k, j);  \n        k = j;  \n    }  \n}</code></pre>\n<h3 id=\"3-1-5-swim函数实现\"><a href=\"#3-1-5-swim函数实现\" class=\"headerlink\" title=\"3.1.5 swim函数实现\"></a>3.1.5 swim函数实现</h3><p>直观看就是一个元素比较轻，然后它要不断上浮，直到它重与他的父节点。而代码的实现就是，查看他的父节点k/2的值是否小于它，如果不小于它，则交换它和它父节点的值，并且让k=k/2，即继续追踪这个元素，让它继续与它当前的父节点做对比。直到它本身为数组的第一个元素或者它不小于它的父节点。</p>\n<p>void swim(int k)<br>{<br>while(k&gt;1 &amp;&amp; pq[k] &lt; pq[k/2])<br>{<br>exch(k, k / 2);<br>k /= 2;<br>}<br>}</p>\n<h2 id=\"3-2-主函数的实现\"><a href=\"#3-2-主函数的实现\" class=\"headerlink\" title=\"3.2 主函数的实现\"></a>3.2 主函数的实现</h2><p>基本和之前的设计描述差不多，就是构造堆，不断的删除两个最小元素，并且把他们的和继续加入堆中，不断循环，只剩下一个元素的时候终止。</p>\n<blockquote>\n<p>  int main()<br>  {<br>  cout &lt;&lt; “输入正整数N(分成N块,N&lt;1024),及N个正整数(每块长度):”;<br>  int N;<br>  cin &gt;&gt; N;<br>  int sum = 0;<br>  MinPQ minPQ(N);<br>  for (int i = 0; i &lt; N; ++i)<br>  {<br>  int len;<br>  cin &gt;&gt; len;<br>  minPQ.push(len);  </p>\n<p>  }<br>  while(minPQ.size()&gt;=2)<br>  {<br>  int min1=minPQ.delMin();<br>  int min2=minPQ.delMin();<br>  sum += min1 + min2;<br>  minPQ.push(min1 + min2);<br>  }<br>  cout &lt;&lt; sum;<br>  return 0;<br>  }</p>\n</blockquote>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9f2bcd918fc4218b47f01700bd307993.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/58da745d01a35ace45bcf8246685b78d.png\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  修理牧场</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目简介\"><a href=\"#1-1-项目简介\" class=\"headerlink\" title=\"1.1 项目简介\"></a>1.1 项目简介</h2><p>农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数<em>Li</em>个长度单位，于是他购买了一个很长的，能锯成N块的木头，即该木头的长度是<em>Li</em>的总和。</p>\n<p>但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8，7和5的三段，第一次锯木头将木头锯成12和8，花费20；第二次锯木头将长度为12的木头锯成7和5花费12，总花费32元。如果第一次将木头锯成15和5，则第二次将木头锯成7和8，那么总的花费是35（大于32）.</p>\n<p>输入格式：输入第一行给出正整数N（N&lt;104），表示要将木头锯成N块。第二行给出N个正整数，表示每块木头的长度。</p>\n<p>输出格式：输出一个整数，即将木头锯成N块的最小花费。</p>\n<h2 id=\"1-2-解题分析\"><a href=\"#1-2-解题分析\" class=\"headerlink\" title=\"1.2 解题分析\"></a>1.2 解题分析</h2><p>给了要将木头锯成N块,与每块木头的长度。最后需要输出最小的花费。</p>\n<p>刚开始时，我的思路是因为是从一块木头开始分割的，且每次都将木块分割为两块，无非是大小不同而已。所有这道题等价与用n个元素构建一个二叉树,n个元素在树的最底层，并且使得除了root外,其他节点相加最小。但是到这里就卡住了，就不懂怎么继续进行。于是上网查了文档，它提供了另外一种思路：通过反向思考,如果每次对半分的时候,最后结果最小，那么,在只有碎片的时候,每一次都拿出最小的两个进行拼凑，就是对半分的逆过程了，<br>所以只需要有一个每次都能取出最小元素的优先队列即可，所有就只要构建一个优先队列就能解决问题了。</p>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-优先队列设计\"><a href=\"#2-1-优先队列设计\" class=\"headerlink\" title=\"2.1 优先队列设计\"></a>2.1 优先队列设计</h2><p>设计一个每次都能取出最小元素的优先队列即可。总体思路是，每一次往优先队列加入元素时，把元素放在尾部，然后让这个元素“上浮”到合适的位置,构成一个堆,堆顶为最小元素。每次取出元素时，取出堆顶元素，然后让堆顶元素与最后一个元素交换，并且让堆的数量减一，堆顶元素“下沉”。这样，不管是取出元素还是加入元素，都构成了一个堆。</p>\n<h2 id=\"2-2-主程序设计\"><a href=\"#2-2-主程序设计\" class=\"headerlink\" title=\"2.2 主程序设计\"></a>2.2 主程序设计</h2><p>首先利用输入的N个正整数逐个放入堆中，然后不断循环直到堆只剩下一个元素。在循环中，每次都从堆中取出最小的两个元素，让总的花费sum+=他们两个的值。并且把他们两个加起来的值继续放入堆中。</p>\n<p>直观上来说，就是在一堆木块碎片中，每次都把最小的两块碎片拼成一块，不断的拼，直到最后就只剩下最初的完整的木块了。</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-优先队列的实现\"><a href=\"#3-1-优先队列的实现\" class=\"headerlink\" title=\"3.1 优先队列的实现\"></a>3.1 优先队列的实现</h2><h3 id=\"3-1-1-堆构造函数的实现\"><a href=\"#3-1-1-堆构造函数的实现\" class=\"headerlink\" title=\"3.1.1 堆构造函数的实现\"></a>3.1.1 堆构造函数的实现</h3><p>当构造一个堆时，需要输入一个堆中应该存的元素数量最大值len，令堆中的成员变量数组的长度为len+1，（因为不用数组的vec[0]），堆的这个类还有一个N记录当前堆的元素数量。</p>\n<pre><code class=\"c++\">MinPQ(int len):pq(len+1)  \n{  \n\n}\n\nprivate:  \n    vector&lt;int&gt; pq;  \n    int N;//元素个数,从1开始</code></pre>\n<h3 id=\"3-1-2-添加元素入堆\"><a href=\"#3-1-2-添加元素入堆\" class=\"headerlink\" title=\"3.1.2 添加元素入堆\"></a>3.1.2 添加元素入堆</h3><p>令N+1,并且在N处添加元素，然后将这个元素swim，使得还是一个堆。</p>\n<pre><code class=\"c++\">void push(int i)  \n{  \n    pq[++N] = i;  \n    swim(N);  \n}</code></pre>\n<h3 id=\"3-1-3-删除堆中最小元素\"><a href=\"#3-1-3-删除堆中最小元素\" class=\"headerlink\" title=\"3.1.3 删除堆中最小元素\"></a>3.1.3 删除堆中最小元素</h3><p>最小元素在堆顶，先用一个变量存储堆顶的值，将堆顶与堆中最后一个元素交换，令N-1，此时不是一个堆，需要将堆顶sink到合适的位置，最后返回之前存的堆顶元素的值。</p>\n<pre><code class=\"c++\">int delMin()  \n{  \n    int max = pq[1];  \n    exch(1, N--);  \n    sink(1);  \n    return max;  \n}</code></pre>\n<h3 id=\"3-1-4-sink函数的实现\"><a href=\"#3-1-4-sink函数的实现\" class=\"headerlink\" title=\"3.1.4 sink函数的实现\"></a>3.1.4 sink函数的实现</h3><p>Sink的思路是将这个元素与他的子节点做对比，并且将较小的放上面，一直对比到这个元素小于他的两个子节点为止。</p>\n<p>具体实现是，假如要下沉k，则先找它的子节点2*k与2*k+1中最小的一个（当然得判断是否存在），如果小于他的子节点的值，那么就交换他们的值，并且让k=2*k或2*k+1（＝最小的那个），这是为了继续追踪原本的k，继续和他此时的两个子节点做对比。不断的循环，直到他没有子节点或者他小于了子节点。</p>\n<pre><code class=\"c++\">void sink(int k)  \n{  \n    while(2 * k &lt;=N)  \n    {  \n        int j = 2 * k;  \n        if(j+1&lt;=N &amp;&amp; pq[j]&gt;pq[j+1])  \n        {  \n            ++j;  \n        }  \n        if(pq[k]&lt;=pq[j])  \n        {  \n                break;  \n        }  \n        exch(k, j);  \n        k = j;  \n    }  \n}</code></pre>\n<h3 id=\"3-1-5-swim函数实现\"><a href=\"#3-1-5-swim函数实现\" class=\"headerlink\" title=\"3.1.5 swim函数实现\"></a>3.1.5 swim函数实现</h3><p>直观看就是一个元素比较轻，然后它要不断上浮，直到它重与他的父节点。而代码的实现就是，查看他的父节点k/2的值是否小于它，如果不小于它，则交换它和它父节点的值，并且让k=k/2，即继续追踪这个元素，让它继续与它当前的父节点做对比。直到它本身为数组的第一个元素或者它不小于它的父节点。</p>\n<p>void swim(int k)<br>{<br>while(k&gt;1 &amp;&amp; pq[k] &lt; pq[k/2])<br>{<br>exch(k, k / 2);<br>k /= 2;<br>}<br>}</p>\n<h2 id=\"3-2-主函数的实现\"><a href=\"#3-2-主函数的实现\" class=\"headerlink\" title=\"3.2 主函数的实现\"></a>3.2 主函数的实现</h2><p>基本和之前的设计描述差不多，就是构造堆，不断的删除两个最小元素，并且把他们的和继续加入堆中，不断循环，只剩下一个元素的时候终止。</p>\n<blockquote>\n<p>  int main()<br>  {<br>  cout &lt;&lt; “输入正整数N(分成N块,N&lt;1024),及N个正整数(每块长度):”;<br>  int N;<br>  cin &gt;&gt; N;<br>  int sum = 0;<br>  MinPQ minPQ(N);<br>  for (int i = 0; i &lt; N; ++i)<br>  {<br>  int len;<br>  cin &gt;&gt; len;<br>  minPQ.push(len);  </p>\n<p>  }<br>  while(minPQ.size()&gt;=2)<br>  {<br>  int min1=minPQ.delMin();<br>  int min2=minPQ.delMin();<br>  sum += min1 + min2;<br>  minPQ.push(min1 + min2);<br>  }<br>  cout &lt;&lt; sum;<br>  return 0;<br>  }</p>\n</blockquote>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9f2bcd918fc4218b47f01700bd307993.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/58da745d01a35ace45bcf8246685b78d.png\"></p>\n"},{"title":"数据结构项目-------电网建设造价模拟系统","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习数据结构项目--电网建设造价模拟系统所写的文档,主要是最小生成树","abbrlink":"ada3a5c8","date":"2020-01-15T16:00:00.000Z","_content":"\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n\n>   电网建设造价模拟系统\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目简介\n\n假设一个城市有n个小区，要实现n个小区之间的电网都能够相互接通，构造这个城市n个小区之间的电网，使总工程造价最低。请设计一个能够满足要求的造价方案。\n\n在每个小区之间都可以设置一条电网线路，都要付出相应的经济代价。n个小区之间最多可以有n（n-1）/2条线路，选择其中的n-1条使总的耗费最少。\n\n## 1.2 功能分析\n\n首先,每个小区当作一个顶点,那么就有n个顶点。两个小区之间设置一条电网线路相互联通且有相应的经济代价。所以可以抽取为一个加权无向图的模型。\n\n所以问题就成了求一个加权无向图的最小生成树。所以首先需要用户输入小区即顶点数，并且给每个小区进行命名以方便查看。然后用户将添加若干个电网线路以及他们之间的花费。而程序就负责找出这个加权无向图的最小生成树，并且显示出来。\n\n我用了Kruskal算法,所以需要许多类来辅助。大致架构是，MainTest类与用户交互，负责接受用户输入，并且用EdgeWeightedGraph类构造加权无向图，并且通过KruskalMST类得到一个存储边（Edge类）的队列（Queue类）（存储了最小生成树的边），然后再将这些边显示出来。而KruskalMST类还需要最小堆（MinPQ类）找最小的边与UF类辨认连通分量。所以总的来说有八个类以及一个input.txt存储一些测试数据。\n\n# 2 设计与实现\n\n## 2.1 Edge.h设计与实现\n\nEdge类代表了图中的边，它有三个成员变量：边的两个顶点v，w与double类型的权值weight。\n\n构造函数就将这三个参数传入；还有三个函数分别得到v，w，weight的值，不过有些不同的是other函数是根据传入的边传出另外一条边，更加的灵活（如other（v）传回w）。最后重载了小于运算符\\<,根据weight进行比较。\n\nclass Edge  \n{  \npublic:  \nEdge(){}  \nEdge(int v, int w, double weight) : v(v), w(w), weight(weight) {}  \n\nint either() const  \n{  \nreturn v;  \n}  \n\nint other(int vertex) const  \n{  \nif(vertex==v)  \nreturn w;  \nelse if(vertex==w)  \nreturn v;  \n}  \n\ndouble getWeight() const  \n{  \nreturn weight;  \n}  \n\nbool operator \\< (const Edge & that) const  \n{  \nif (weight \\< that.weight)  \nreturn true;  \nelse  \nreturn false;  \n}  \n\nprivate:  \nint v;  \nint w;  \ndouble weight;  \n};\n\n## 2.2 EdgeWeightedGraph.h设计与实现\n\n代表了图。三个成员变量，分别是顶点的数量V，边的数量E以及邻接表adj。其中邻接表存储了每个顶点所含有的边（类型为vector\\<vector\\<Edge\\>\\>）。\n\n构造函数将给定顶点数量N，并且让边为0，而且为邻接表adj开辟N个空间，使得每个顶点i都能使用adj[i]。\n\n函数有返回V和E数量的函数，以及添加边的函数addEdge（）：传入一条边，并且让边的两个顶点的邻接表分别加入这条边，最后让边数量+1。还有一个返回所以边的函数edges（）：很简单，就是遍历邻接表，对于每个顶点的每条边，将边放入队列中，需要注意的是，因为是无向图，所以如果所有顶点的边都加入就重复了，所以只加入v\\<w\n\n的边，防止重复。\n\nclass EdgeWeightedGraph  \n{  \npublic:  \nEdgeWeightedGraph(int v) : V(v),E(0)  \n{  \nvector\\<vector\\<Edge\\>\\> temp(V);  \nadj=temp;  \n}  \n\n\nvoid addEdge(Edge e)  \n{  \nint v = e.either();  \nint w = e.other(v);  \nadj[v].push_back(e);//往邻接表中添加  \nadj[w].push_back(e);  \n++E;  \n}  \n\nQueue\\<Edge\\> edges()//返回所有边  \n{  \nQueue\\<Edge\\> queue;  \nfor (int v = 0; v \\< V; ++v)  \n{  \nfor(Edge e:adj[v])  \n{  \nif(e.other(v)\\>v)  \n{  \nqueue.enqueue(e);  \n}  \n}  \n}  \nreturn queue;  \n}  \n\nint getV()  \n{  \nreturn V;  \n}  \n\nint getE()  \n{  \nreturn E;  \n}  \n\nprivate:  \nint V;  \nint E;  \nvector\\<vector\\<Edge\\>\\> adj;//邻接表  \n\n};\n\n## 2.3 Queue.h与Node.h设计与实现\n\n因为很多地方用到队列，所以又自己实现了一遍。队列需要用到Node.h之前说过很多此就不说了。\n\n队列为模板类，存储T类型。成员变量是指向队首的first指针以及指向队尾的last指针，还有一个存储元素个数的N。\n\n队列主要就是enqueue，dequeue以及empty和size四个函数。empty只要判断N==0即可，size也只要返回N即可。enqueue就是在队尾加入元素，具体操作为：如果队列为空，让头尾指针同时指向加入的元素，让计数N++。如果不为空，让当前的last-\\>next指向新加入元素，再让last指向当前的最后元素，让计数N++。dequeue就将队首弹出，让first指向下一个元素，让计数N--，再稍微处理异常情况，比如弹出队首后让last也为空。\n\ntemplate \\<class T\\> class Node  \n{  \npublic:  \n\nNode(const T & value, Node\\<T\\> \\*next= nullptr) : value(value), next(next) {}  \nNode(Node\\<T\\> \\*next= nullptr) : next(next) {}  \n\nT value;  \nNode\\<T\\> \\*next;  \n};\n\ntemplate \\<class T\\> class Queue  \n{  \npublic:  \nvoid enqueue(T t)  \n{  \nif(empty())//为空指向同一个  \n{  \nfirst=new Node\\<T\\>(t, nullptr);  \nlast=first;  \n}  \nelse  \n{  \nNode\\<T\\> \\* temp = new Node\\<T\\>(t, nullptr);  \nlast-\\>next=temp;  \nlast=temp;  \n}  \n++N;  \n}  \nT dequeue()  \n{  \nif (empty())  \nthrow \"队列为空\";  \nT value=first-\\>value;  \nfirst=first-\\>next;  \n--N;  \nif(empty())  \nlast= nullptr;  \nreturn value;  \n}  \n\nbool empty()  \n{  \nreturn N==0;  \n}  \n\nint size()  \n{  \nreturn N;  \n}  \n\nprivate:  \nNode\\<T\\> \\* first;  \nNode\\<T\\> \\* last;  \nint N = 0;  \n};\n\n## 2.4 MinPQ.h设计与实现\n\n当构造一个堆时，需要输入一个堆中应该存的元素数量最大值len，令堆中的成员变量数组的长度为len+1，（因为不用数组的vec[0]），堆的这个类还有一个N记录当前堆的元素数量。\n\n公有函数：\n\n>   1.isEmpty函数及size函数：因为N记录当前堆的元素数量,所以isEmpty函数返回N==0，\n>   size函数返回N即可。\n\n>   2.push函数：令N+1,并且在N处添加元素，然后将这个元素swim，使得还是一个堆。\n\n>   3.delMin函数：最小元素在堆顶，先用一个变量存储堆顶的值，将堆顶与堆中最后一个元素交换，令N-1，此时不是一个堆，需要将堆顶sink到合适的位置，最后返回之前存的堆顶元素的值。\n\n私有函数：\n\n>   1.sink函数：sink的思路是将这个元素与他的子节点做对比，并且将较小的放上面，一直对比到这个元素小于他的两个子节点为止。具体实现是，假如要下沉k，则先找它的子节点2\\*k与2\\*k+1中最小的一个（当然得判断是否存在），如果小于他的子节点的值，那么就交换他们的值，并且让k=2\\*k或2\\*k+1（＝最小的那个），这是为了继续追踪原本的k，继续和他此时的两个子节点做对比。不断的循环，直到他没有子节点或者他小于了子节点。\n\n2.swim函数：直观看就是一个元素比较轻，然后它要不断上浮，直到它重与他的父节点。而代码的实现就是，查看他的父节点k/2的值是否小于它，如果不小于它，则交换它和它父节点的值，并且让k=k/2，即继续追踪这个元素，让它继续与它当前的父节点做对比。直到它本身为数组的第一个元素或者它不小于它的父节点。\n\ntemplate \\<class T\\> class MinPQ  \n{  \npublic:  \nMinPQ(int N):pq(N+1)  \n{  \n\n}  \n\nbool isEmpty()  \n{  \nreturn size()==0;  \n}  \n\nint size()  \n{  \nreturn N;  \n}  \n\nT delMin()  \n{  \nT min = pq[1];  \nexch(1, N--);  \nsink(1);  \nreturn min;  \n}  \n\nvoid push(T t)  \n{  \npq[++N] = t;  \nswim(N);  \n}  \n\nprivate:  \nvector\\<T\\> pq;  \nint N=0;//元素个数,从1开始  \n\nvoid swim(int k)  \n{  \nwhile(k\\>1 && pq[k] \\< pq[k/2])  \n{  \nexch(k, k / 2);  \nk /= 2;  \n}  \n}  \n\nvoid sink(int k)  \n{  \nwhile(2 \\* k \\<=N)  \n{  \nint j = 2 \\* k;  \nif(j+1\\<=N && pq[j+1]\\<pq[j])  \n{  \n++j;  \n}  \nif(pq[k]\\<pq[j])  \n{  \nbreak;  \n}  \nexch(k, j);  \nk = j;  \n}  \n}  \n\nvoid exch(int i,int j)  \n{  \nT temp = pq[i];  \npq[i] = pq[j];  \npq[j] = temp;  \n}  \n};\n\n## 2.5 UF.h设计与实现\n\n该类负责构造连通分量。他有三个成员变量，id存储每个顶点的父节点，sz存储每个顶点所属于的那个连通分量的规模（想象如果将规模大的根节点链接到规模小的,那么就会使得节点平均访问到根节点的时间增加,所以需要将规模大的作为根节点），以及当前连通分量数量count。\n\n构造函数将当前所以节点的父节点赋值为他们本身并且每个节点的size都是1，并且让当前连通分量数量count等于顶点总数N。这代表了当前有N个连通分量，每两个顶点之间都互不连通。\n\n主要有这几个函数：getCount()返回当前连通分量数量count；connected(int p, int\nq)检测两个顶点是否是连通的，这通过调用find(int\np)来判断，如果find（p）==find(q),他们就是同一个连通分量；find(int\np)则找到p的根节点，即顶点p所属于的连通分量。unionPQ(int p, int\nq)则将两个不连通的节点连通。\n\n详细说明find（int\np）：因为每次查找id[p],如果id[p]=p，代表p是p的根节点，代表这就是一个连通分量。而如果id[p]不等于p，则代表p是某个连通分量的子节点，而id[p]就是它的父节点，所以让p=\nid[p]使得p到了他的父节点，继续查找，直到找到这个连通分量的根节点，对应的就是最终的p=\nid[p]。\n\nunionPQ(int p, int\nq)：先找到传入的p，q的根节点i，j，如果根节点相同，那么他们是同一个连通分量直接返回。接着，判断这两个根节点的规模sz[i],sz[j]。然后将规模小的链接到规模大的上面(也就是以规模大的这个根节点作为这两棵树合起来的根节点)，这样找某个节点的根节点更快。然后将该根节点的规模再加上规模小的那个节点的规模,这样才使得规模有意义。\n\nclass UF  \n{  \npublic:  \nUF(int N)  \n{  \nfor (int i = 0; i \\< N; ++i)  \n{  \nid.push_back(i);  \nsz.push_back(1);  \n}  \ncount=N;  \n}  \n\nint getCount()  \n{  \nreturn count;  \n}  \n\nbool connected(int p,int q)  \n{  \nreturn find(p) == find(q);//检测是不是在同一颗树上  \n}  \n\nint find(int p)  \n{  \nwhile(p!=id[p])  \n{  \np = id[p];  \n}  \nreturn p;  \n}  \n\nvoid unionPQ(int p,int q)  \n{  \nint i = find(p);  \nint j = find(q);  \nif(i==j)  \n{  \nreturn;  \n}  \nif(sz[i]\\<sz[j])  \n{  \nid[i] = j;  \nsz[j] += sz[i];  \n}  \nelse  \n{  \nid[j] = i;  \nsz[i] += sz[j];  \n}  \ncount--;  \n}  \n\nprivate:  \nvector\\<int\\> id;//父链接数组  \nvector\\<int\\> sz;//没颗树高度  \nint count;//连通分量数量  \n};\n\n## 2.6 KruskalMST.h设计与实现\n\n该类就负责计算最小生成树。需要传入构造好的加权无向图，它有个成员变量mst将负责返回存有最小生成树的所有边的队列。\n\n主要就两个函数，getMST返回mst，即返回存有最小生成树的所有边的队列；构造函数传入加权无向图，调用MinPQ类，并且把树中所有的边都放入最小堆中。还调用了UF类，传入了图中的顶点数，代表了初试有V个连通分量。紧接着，当最小生成树中边的数量小于V-1并且最小堆中还有边的时候，就一直循环。在循环之中，不断的弹出最小堆中最小的边，而如果这条边的两个顶点是两个不同的连通分量，说明这条边是最小生成树中的边，于是将之加入到存有最小生成树的所有边的队列mst中，并且将这两个顶点连接起来，成为同一个连通分量。而如果弹出最小堆中最小的边的两个顶点是同一个连通分量，则这条边不是最小生成树中的边，则忽略它，继续循环。\n\nclass KruskalMST  \n{  \npublic:  \nKruskalMST(EdgeWeightedGraph G)  \n{  \nMinPQ\\<Edge\\> pq(G.getE());  \nQueue\\<Edge\\> edges = G.edges();  \nwhile(!edges.empty())  \n{  \npq.push(edges.dequeue());  \n}  \nUF uf(G.getV());  \n\nwhile(!pq.isEmpty() && mst.size()\\<G.getV()-1)  \n{  \nEdge e = pq.delMin();  \nint v = e.either();  \nint w = e.other(v);  \nif(uf.connected(v,w))  \ncontinue;  \nuf.unionPQ(v,w);  \nmst.enqueue(e);  \n}  \n}  \n\nQueue\\<Edge\\> getMST()  \n{  \nreturn mst;  \n}  \n\nprivate:  \nQueue\\<Edge\\> mst;  \n};\n\n## 2.7 MainTest.cpp设计与实现\n\n先给出相应的提示，之后创建一个map以将之后用户输入的节点代号和节点数字相互对应。然后进入循环等待用户进行操作。\n\n如果用户选择操作A，就让用户输入N个顶点和他们的代号，然后程序会生成一个含有N个顶点的不含有边的图（这里图中存的只是顶点数字，而顶点代号与顶点数字的对应关系存在map中）。\n\n如果选择B操作，将不断循环，将用户输入的正确的两个顶点与边的权值加入到加权无向图中（当然首先得把用户输入的顶点代号通过map转换为对应的顶点数字）。当用户输入0\n0 0时，退出当前输入边的循环。\n\n如果选择C操作，则将加权无向图传入上述所实现的KruskalMST.h类的构造函数中，其实此时已经生成了最小生成树，就存在指向KruskalMST.h类的指针kruskal中。\n\n如果选择D操作，将显示最小生成树，具体是，通过kruskal-\\>getMST()得到存储有所有最小生成树边的队列。然后从队列中取出所有的边，并且将边的两个顶点数字通过map转换为顶点代号，并且打印出来。\n\nint main()  \n{  \n\ncout \\<\\< \"\\*\\* 电网建设造价模拟系统 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"================================================\" \\<\\< endl;  \ncout \\<\\< \"\\*\\* A---创建电网顶点 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"\\*\\* B---添加电网的边 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"\\*\\* C---构造最小生成树 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"\\*\\* D---显示最小生成树 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"\\*\\* E---退出程序 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"================================================\" \\<\\< endl;  \n\nunordered_map\\<string, int\\> names;//节点名字与节点数字相互对应  \nEdgeWeightedGraph \\* G = nullptr;  \nKruskalMST \\* kruskal = nullptr;  \n\nwhile (true)  \n{  \ncout \\<\\< \"请选择操作:\";  \nchar operation;  \ncin \\>\\> operation;  \nif (operation == 'A')  \n{  \ncout \\<\\< \"请输入节点数量:\";  \nint N;//节点数量  \ncin \\>\\> N;  \ncout \\<\\< \"请依次输入节点名称:\";  \nfor (int i = 0; i \\< N; ++i)  \n{  \nstring node;  \ncin \\>\\> node;  \nnames[node] = i;  \n}  \nG = new EdgeWeightedGraph(N);//生成一个没有边的图  \n}  \nelse if (operation == 'B')  \n{  \nwhile (true)  \n{  \ncout \\<\\< \"请输入两个顶点及边：(输入0 0 0 结束)\";  \nstring node1, node2;  \ndouble nodeValue;  \ncin \\>\\> node1 \\>\\> node2 \\>\\> nodeValue;  \nif (node1 == \"0\" && node2 == \"0\" && nodeValue == 0)  \n{  \nbreak;  \n}  \nif (nodeValue \\<= 0)  \n{  \ncout \\<\\< \"输入错误,两个城市线路的花费不能小于等于0\";  \n}  \nint v = 0, w = 0;  \nauto iter = names.find(node1);  \nif (iter != names.end())  \n{  \nv = iter-\\>second;  \n}  \nauto iter2 = names.find(node2);  \nif (iter2 != names.end())  \n{  \nw = iter2-\\>second;  \n}  \nif (v == -1 \\|\\| w == -1)  \n{  \ncout \\<\\< \"输入错误,输入的顶点不在图中!\";  \n}  \nelse  \n{  \nEdge edge(v, w, nodeValue);  \nG-\\>addEdge(edge);  \n}  \n}  \n}  \nelse if (operation == 'C')  \n{  \ncout \\<\\< \"最小生成树构建成功!\";  \nkruskal = new KruskalMST(\\*G);  \n}  \nelse if (operation == 'D')  \n{  \ncout \\<\\< \"最小生成树的顶点和边为:\" \\<\\< endl;  \nQueue\\<Edge\\> queue = kruskal-\\>getMST();  \nwhile (!queue.empty())  \n{  \nEdge e = queue.dequeue();  \nint v = e.either();  \nint w = e.other(v);  \nstring name1, name2;  \n\nint count = 0;  \nfor (auto iter = names.begin(); iter != names.end(); ++iter)  \n{  \nif (iter-\\>second == v)  \n{  \nname1 = iter-\\>first;  \n++count;  \n}  \nif (iter-\\>second == w)  \n{  \nname2 = iter-\\>first;  \n++count;  \n}  \nif (count == 2)  \n{  \nbreak;  \n}//找到这两就退出  \n}  \ncout \\<\\< \"[\" \\<\\< name1 \\<\\< \"---\" \\<\\< name2 \\<\\< \" cost: \" \\<\\< e.getWeight()\n\\<\\< \"]\" \\<\\< endl;  \n}  \n// kruskal-\\>printAll(); 需要字符显示  \n}  \nelse if (operation == 'E')  \n{  \ncout \\<\\< \"期待您的下次使用!\";  \nreturn 0;  \n}  \n}  \n}\n\n# 3 测试\n\n## 3.1 功能测试\n\n### 3.1.1 测试1\n\n测试数据：\n\n>   A\n\n>   4\n\n>   a b c d\n\n>   B\n\n>   a b 8\n\n>   b c 7\n\n>   c d 5\n\n>   d a 11\n\n>   a c 18\n\n>   b d 12\n\n>   0 0 0\n\n>   C\n\n>   D\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/95b5a5199946769ae1d9457ebb9843d4.jpg)\n\n>   最小生成树如下图（打勾位置为最小生成树的边）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/164782c09a1b8b0035e283513e84c6a1.png)\n\n### 3.1.2 测试2\n\n测试数据：\n\n>   A\n\n>   8\n\n>   0 1 2 3 4 5 6 7\n\n>   B\n\n>   4 5 0.35\n\n>   4 7 0.37\n\n>   5 7 0.28\n\n>   0 7 0.16\n\n>   1 5 0.32\n\n>   0 4 0.38\n\n>   2 3 0.17\n\n>   1 7 0.19\n\n>   0 2 0.26\n\n>   1 2 0.36\n\n>   1 3 0.29\n\n>   2 7 0.34\n\n>   6 2 0.40\n\n>   3 6 0.52\n\n>   6 0 0.58\n\n>   6 4 0.93\n\n>   0 0 0\n\n>   C\n\n>   D\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e3674c9e620a0fc449001bca649d983a.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1402164181b81b090104671eb480894b.png)\n\n相应的最小生成树如下图：\n\n![这里写图片描述](https://tongji4m3.oss-cn-beijing.aliyuncs.com/a2ba172c465dbdd9736e7d5c059b1f05.png)\n","source":"_posts/项目笔记/dataStructureProjects/电网建设造价模拟系统.md","raw":"---\ntitle: 数据结构项目-------电网建设造价模拟系统\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习数据结构项目--电网建设造价模拟系统所写的文档,主要是最小生成树'\ncategories: 项目文档\ntags:\n  - 数据结构\n  - 最小生成树\n  - 图\nabbrlink: ada3a5c8\ndate: 2020-01-16 00:00:00\n---\n\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n\n>   电网建设造价模拟系统\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目简介\n\n假设一个城市有n个小区，要实现n个小区之间的电网都能够相互接通，构造这个城市n个小区之间的电网，使总工程造价最低。请设计一个能够满足要求的造价方案。\n\n在每个小区之间都可以设置一条电网线路，都要付出相应的经济代价。n个小区之间最多可以有n（n-1）/2条线路，选择其中的n-1条使总的耗费最少。\n\n## 1.2 功能分析\n\n首先,每个小区当作一个顶点,那么就有n个顶点。两个小区之间设置一条电网线路相互联通且有相应的经济代价。所以可以抽取为一个加权无向图的模型。\n\n所以问题就成了求一个加权无向图的最小生成树。所以首先需要用户输入小区即顶点数，并且给每个小区进行命名以方便查看。然后用户将添加若干个电网线路以及他们之间的花费。而程序就负责找出这个加权无向图的最小生成树，并且显示出来。\n\n我用了Kruskal算法,所以需要许多类来辅助。大致架构是，MainTest类与用户交互，负责接受用户输入，并且用EdgeWeightedGraph类构造加权无向图，并且通过KruskalMST类得到一个存储边（Edge类）的队列（Queue类）（存储了最小生成树的边），然后再将这些边显示出来。而KruskalMST类还需要最小堆（MinPQ类）找最小的边与UF类辨认连通分量。所以总的来说有八个类以及一个input.txt存储一些测试数据。\n\n# 2 设计与实现\n\n## 2.1 Edge.h设计与实现\n\nEdge类代表了图中的边，它有三个成员变量：边的两个顶点v，w与double类型的权值weight。\n\n构造函数就将这三个参数传入；还有三个函数分别得到v，w，weight的值，不过有些不同的是other函数是根据传入的边传出另外一条边，更加的灵活（如other（v）传回w）。最后重载了小于运算符\\<,根据weight进行比较。\n\nclass Edge  \n{  \npublic:  \nEdge(){}  \nEdge(int v, int w, double weight) : v(v), w(w), weight(weight) {}  \n\nint either() const  \n{  \nreturn v;  \n}  \n\nint other(int vertex) const  \n{  \nif(vertex==v)  \nreturn w;  \nelse if(vertex==w)  \nreturn v;  \n}  \n\ndouble getWeight() const  \n{  \nreturn weight;  \n}  \n\nbool operator \\< (const Edge & that) const  \n{  \nif (weight \\< that.weight)  \nreturn true;  \nelse  \nreturn false;  \n}  \n\nprivate:  \nint v;  \nint w;  \ndouble weight;  \n};\n\n## 2.2 EdgeWeightedGraph.h设计与实现\n\n代表了图。三个成员变量，分别是顶点的数量V，边的数量E以及邻接表adj。其中邻接表存储了每个顶点所含有的边（类型为vector\\<vector\\<Edge\\>\\>）。\n\n构造函数将给定顶点数量N，并且让边为0，而且为邻接表adj开辟N个空间，使得每个顶点i都能使用adj[i]。\n\n函数有返回V和E数量的函数，以及添加边的函数addEdge（）：传入一条边，并且让边的两个顶点的邻接表分别加入这条边，最后让边数量+1。还有一个返回所以边的函数edges（）：很简单，就是遍历邻接表，对于每个顶点的每条边，将边放入队列中，需要注意的是，因为是无向图，所以如果所有顶点的边都加入就重复了，所以只加入v\\<w\n\n的边，防止重复。\n\nclass EdgeWeightedGraph  \n{  \npublic:  \nEdgeWeightedGraph(int v) : V(v),E(0)  \n{  \nvector\\<vector\\<Edge\\>\\> temp(V);  \nadj=temp;  \n}  \n\n\nvoid addEdge(Edge e)  \n{  \nint v = e.either();  \nint w = e.other(v);  \nadj[v].push_back(e);//往邻接表中添加  \nadj[w].push_back(e);  \n++E;  \n}  \n\nQueue\\<Edge\\> edges()//返回所有边  \n{  \nQueue\\<Edge\\> queue;  \nfor (int v = 0; v \\< V; ++v)  \n{  \nfor(Edge e:adj[v])  \n{  \nif(e.other(v)\\>v)  \n{  \nqueue.enqueue(e);  \n}  \n}  \n}  \nreturn queue;  \n}  \n\nint getV()  \n{  \nreturn V;  \n}  \n\nint getE()  \n{  \nreturn E;  \n}  \n\nprivate:  \nint V;  \nint E;  \nvector\\<vector\\<Edge\\>\\> adj;//邻接表  \n\n};\n\n## 2.3 Queue.h与Node.h设计与实现\n\n因为很多地方用到队列，所以又自己实现了一遍。队列需要用到Node.h之前说过很多此就不说了。\n\n队列为模板类，存储T类型。成员变量是指向队首的first指针以及指向队尾的last指针，还有一个存储元素个数的N。\n\n队列主要就是enqueue，dequeue以及empty和size四个函数。empty只要判断N==0即可，size也只要返回N即可。enqueue就是在队尾加入元素，具体操作为：如果队列为空，让头尾指针同时指向加入的元素，让计数N++。如果不为空，让当前的last-\\>next指向新加入元素，再让last指向当前的最后元素，让计数N++。dequeue就将队首弹出，让first指向下一个元素，让计数N--，再稍微处理异常情况，比如弹出队首后让last也为空。\n\ntemplate \\<class T\\> class Node  \n{  \npublic:  \n\nNode(const T & value, Node\\<T\\> \\*next= nullptr) : value(value), next(next) {}  \nNode(Node\\<T\\> \\*next= nullptr) : next(next) {}  \n\nT value;  \nNode\\<T\\> \\*next;  \n};\n\ntemplate \\<class T\\> class Queue  \n{  \npublic:  \nvoid enqueue(T t)  \n{  \nif(empty())//为空指向同一个  \n{  \nfirst=new Node\\<T\\>(t, nullptr);  \nlast=first;  \n}  \nelse  \n{  \nNode\\<T\\> \\* temp = new Node\\<T\\>(t, nullptr);  \nlast-\\>next=temp;  \nlast=temp;  \n}  \n++N;  \n}  \nT dequeue()  \n{  \nif (empty())  \nthrow \"队列为空\";  \nT value=first-\\>value;  \nfirst=first-\\>next;  \n--N;  \nif(empty())  \nlast= nullptr;  \nreturn value;  \n}  \n\nbool empty()  \n{  \nreturn N==0;  \n}  \n\nint size()  \n{  \nreturn N;  \n}  \n\nprivate:  \nNode\\<T\\> \\* first;  \nNode\\<T\\> \\* last;  \nint N = 0;  \n};\n\n## 2.4 MinPQ.h设计与实现\n\n当构造一个堆时，需要输入一个堆中应该存的元素数量最大值len，令堆中的成员变量数组的长度为len+1，（因为不用数组的vec[0]），堆的这个类还有一个N记录当前堆的元素数量。\n\n公有函数：\n\n>   1.isEmpty函数及size函数：因为N记录当前堆的元素数量,所以isEmpty函数返回N==0，\n>   size函数返回N即可。\n\n>   2.push函数：令N+1,并且在N处添加元素，然后将这个元素swim，使得还是一个堆。\n\n>   3.delMin函数：最小元素在堆顶，先用一个变量存储堆顶的值，将堆顶与堆中最后一个元素交换，令N-1，此时不是一个堆，需要将堆顶sink到合适的位置，最后返回之前存的堆顶元素的值。\n\n私有函数：\n\n>   1.sink函数：sink的思路是将这个元素与他的子节点做对比，并且将较小的放上面，一直对比到这个元素小于他的两个子节点为止。具体实现是，假如要下沉k，则先找它的子节点2\\*k与2\\*k+1中最小的一个（当然得判断是否存在），如果小于他的子节点的值，那么就交换他们的值，并且让k=2\\*k或2\\*k+1（＝最小的那个），这是为了继续追踪原本的k，继续和他此时的两个子节点做对比。不断的循环，直到他没有子节点或者他小于了子节点。\n\n2.swim函数：直观看就是一个元素比较轻，然后它要不断上浮，直到它重与他的父节点。而代码的实现就是，查看他的父节点k/2的值是否小于它，如果不小于它，则交换它和它父节点的值，并且让k=k/2，即继续追踪这个元素，让它继续与它当前的父节点做对比。直到它本身为数组的第一个元素或者它不小于它的父节点。\n\ntemplate \\<class T\\> class MinPQ  \n{  \npublic:  \nMinPQ(int N):pq(N+1)  \n{  \n\n}  \n\nbool isEmpty()  \n{  \nreturn size()==0;  \n}  \n\nint size()  \n{  \nreturn N;  \n}  \n\nT delMin()  \n{  \nT min = pq[1];  \nexch(1, N--);  \nsink(1);  \nreturn min;  \n}  \n\nvoid push(T t)  \n{  \npq[++N] = t;  \nswim(N);  \n}  \n\nprivate:  \nvector\\<T\\> pq;  \nint N=0;//元素个数,从1开始  \n\nvoid swim(int k)  \n{  \nwhile(k\\>1 && pq[k] \\< pq[k/2])  \n{  \nexch(k, k / 2);  \nk /= 2;  \n}  \n}  \n\nvoid sink(int k)  \n{  \nwhile(2 \\* k \\<=N)  \n{  \nint j = 2 \\* k;  \nif(j+1\\<=N && pq[j+1]\\<pq[j])  \n{  \n++j;  \n}  \nif(pq[k]\\<pq[j])  \n{  \nbreak;  \n}  \nexch(k, j);  \nk = j;  \n}  \n}  \n\nvoid exch(int i,int j)  \n{  \nT temp = pq[i];  \npq[i] = pq[j];  \npq[j] = temp;  \n}  \n};\n\n## 2.5 UF.h设计与实现\n\n该类负责构造连通分量。他有三个成员变量，id存储每个顶点的父节点，sz存储每个顶点所属于的那个连通分量的规模（想象如果将规模大的根节点链接到规模小的,那么就会使得节点平均访问到根节点的时间增加,所以需要将规模大的作为根节点），以及当前连通分量数量count。\n\n构造函数将当前所以节点的父节点赋值为他们本身并且每个节点的size都是1，并且让当前连通分量数量count等于顶点总数N。这代表了当前有N个连通分量，每两个顶点之间都互不连通。\n\n主要有这几个函数：getCount()返回当前连通分量数量count；connected(int p, int\nq)检测两个顶点是否是连通的，这通过调用find(int\np)来判断，如果find（p）==find(q),他们就是同一个连通分量；find(int\np)则找到p的根节点，即顶点p所属于的连通分量。unionPQ(int p, int\nq)则将两个不连通的节点连通。\n\n详细说明find（int\np）：因为每次查找id[p],如果id[p]=p，代表p是p的根节点，代表这就是一个连通分量。而如果id[p]不等于p，则代表p是某个连通分量的子节点，而id[p]就是它的父节点，所以让p=\nid[p]使得p到了他的父节点，继续查找，直到找到这个连通分量的根节点，对应的就是最终的p=\nid[p]。\n\nunionPQ(int p, int\nq)：先找到传入的p，q的根节点i，j，如果根节点相同，那么他们是同一个连通分量直接返回。接着，判断这两个根节点的规模sz[i],sz[j]。然后将规模小的链接到规模大的上面(也就是以规模大的这个根节点作为这两棵树合起来的根节点)，这样找某个节点的根节点更快。然后将该根节点的规模再加上规模小的那个节点的规模,这样才使得规模有意义。\n\nclass UF  \n{  \npublic:  \nUF(int N)  \n{  \nfor (int i = 0; i \\< N; ++i)  \n{  \nid.push_back(i);  \nsz.push_back(1);  \n}  \ncount=N;  \n}  \n\nint getCount()  \n{  \nreturn count;  \n}  \n\nbool connected(int p,int q)  \n{  \nreturn find(p) == find(q);//检测是不是在同一颗树上  \n}  \n\nint find(int p)  \n{  \nwhile(p!=id[p])  \n{  \np = id[p];  \n}  \nreturn p;  \n}  \n\nvoid unionPQ(int p,int q)  \n{  \nint i = find(p);  \nint j = find(q);  \nif(i==j)  \n{  \nreturn;  \n}  \nif(sz[i]\\<sz[j])  \n{  \nid[i] = j;  \nsz[j] += sz[i];  \n}  \nelse  \n{  \nid[j] = i;  \nsz[i] += sz[j];  \n}  \ncount--;  \n}  \n\nprivate:  \nvector\\<int\\> id;//父链接数组  \nvector\\<int\\> sz;//没颗树高度  \nint count;//连通分量数量  \n};\n\n## 2.6 KruskalMST.h设计与实现\n\n该类就负责计算最小生成树。需要传入构造好的加权无向图，它有个成员变量mst将负责返回存有最小生成树的所有边的队列。\n\n主要就两个函数，getMST返回mst，即返回存有最小生成树的所有边的队列；构造函数传入加权无向图，调用MinPQ类，并且把树中所有的边都放入最小堆中。还调用了UF类，传入了图中的顶点数，代表了初试有V个连通分量。紧接着，当最小生成树中边的数量小于V-1并且最小堆中还有边的时候，就一直循环。在循环之中，不断的弹出最小堆中最小的边，而如果这条边的两个顶点是两个不同的连通分量，说明这条边是最小生成树中的边，于是将之加入到存有最小生成树的所有边的队列mst中，并且将这两个顶点连接起来，成为同一个连通分量。而如果弹出最小堆中最小的边的两个顶点是同一个连通分量，则这条边不是最小生成树中的边，则忽略它，继续循环。\n\nclass KruskalMST  \n{  \npublic:  \nKruskalMST(EdgeWeightedGraph G)  \n{  \nMinPQ\\<Edge\\> pq(G.getE());  \nQueue\\<Edge\\> edges = G.edges();  \nwhile(!edges.empty())  \n{  \npq.push(edges.dequeue());  \n}  \nUF uf(G.getV());  \n\nwhile(!pq.isEmpty() && mst.size()\\<G.getV()-1)  \n{  \nEdge e = pq.delMin();  \nint v = e.either();  \nint w = e.other(v);  \nif(uf.connected(v,w))  \ncontinue;  \nuf.unionPQ(v,w);  \nmst.enqueue(e);  \n}  \n}  \n\nQueue\\<Edge\\> getMST()  \n{  \nreturn mst;  \n}  \n\nprivate:  \nQueue\\<Edge\\> mst;  \n};\n\n## 2.7 MainTest.cpp设计与实现\n\n先给出相应的提示，之后创建一个map以将之后用户输入的节点代号和节点数字相互对应。然后进入循环等待用户进行操作。\n\n如果用户选择操作A，就让用户输入N个顶点和他们的代号，然后程序会生成一个含有N个顶点的不含有边的图（这里图中存的只是顶点数字，而顶点代号与顶点数字的对应关系存在map中）。\n\n如果选择B操作，将不断循环，将用户输入的正确的两个顶点与边的权值加入到加权无向图中（当然首先得把用户输入的顶点代号通过map转换为对应的顶点数字）。当用户输入0\n0 0时，退出当前输入边的循环。\n\n如果选择C操作，则将加权无向图传入上述所实现的KruskalMST.h类的构造函数中，其实此时已经生成了最小生成树，就存在指向KruskalMST.h类的指针kruskal中。\n\n如果选择D操作，将显示最小生成树，具体是，通过kruskal-\\>getMST()得到存储有所有最小生成树边的队列。然后从队列中取出所有的边，并且将边的两个顶点数字通过map转换为顶点代号，并且打印出来。\n\nint main()  \n{  \n\ncout \\<\\< \"\\*\\* 电网建设造价模拟系统 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"================================================\" \\<\\< endl;  \ncout \\<\\< \"\\*\\* A---创建电网顶点 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"\\*\\* B---添加电网的边 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"\\*\\* C---构造最小生成树 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"\\*\\* D---显示最小生成树 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"\\*\\* E---退出程序 \\*\\*\" \\<\\< endl;  \ncout \\<\\< \"================================================\" \\<\\< endl;  \n\nunordered_map\\<string, int\\> names;//节点名字与节点数字相互对应  \nEdgeWeightedGraph \\* G = nullptr;  \nKruskalMST \\* kruskal = nullptr;  \n\nwhile (true)  \n{  \ncout \\<\\< \"请选择操作:\";  \nchar operation;  \ncin \\>\\> operation;  \nif (operation == 'A')  \n{  \ncout \\<\\< \"请输入节点数量:\";  \nint N;//节点数量  \ncin \\>\\> N;  \ncout \\<\\< \"请依次输入节点名称:\";  \nfor (int i = 0; i \\< N; ++i)  \n{  \nstring node;  \ncin \\>\\> node;  \nnames[node] = i;  \n}  \nG = new EdgeWeightedGraph(N);//生成一个没有边的图  \n}  \nelse if (operation == 'B')  \n{  \nwhile (true)  \n{  \ncout \\<\\< \"请输入两个顶点及边：(输入0 0 0 结束)\";  \nstring node1, node2;  \ndouble nodeValue;  \ncin \\>\\> node1 \\>\\> node2 \\>\\> nodeValue;  \nif (node1 == \"0\" && node2 == \"0\" && nodeValue == 0)  \n{  \nbreak;  \n}  \nif (nodeValue \\<= 0)  \n{  \ncout \\<\\< \"输入错误,两个城市线路的花费不能小于等于0\";  \n}  \nint v = 0, w = 0;  \nauto iter = names.find(node1);  \nif (iter != names.end())  \n{  \nv = iter-\\>second;  \n}  \nauto iter2 = names.find(node2);  \nif (iter2 != names.end())  \n{  \nw = iter2-\\>second;  \n}  \nif (v == -1 \\|\\| w == -1)  \n{  \ncout \\<\\< \"输入错误,输入的顶点不在图中!\";  \n}  \nelse  \n{  \nEdge edge(v, w, nodeValue);  \nG-\\>addEdge(edge);  \n}  \n}  \n}  \nelse if (operation == 'C')  \n{  \ncout \\<\\< \"最小生成树构建成功!\";  \nkruskal = new KruskalMST(\\*G);  \n}  \nelse if (operation == 'D')  \n{  \ncout \\<\\< \"最小生成树的顶点和边为:\" \\<\\< endl;  \nQueue\\<Edge\\> queue = kruskal-\\>getMST();  \nwhile (!queue.empty())  \n{  \nEdge e = queue.dequeue();  \nint v = e.either();  \nint w = e.other(v);  \nstring name1, name2;  \n\nint count = 0;  \nfor (auto iter = names.begin(); iter != names.end(); ++iter)  \n{  \nif (iter-\\>second == v)  \n{  \nname1 = iter-\\>first;  \n++count;  \n}  \nif (iter-\\>second == w)  \n{  \nname2 = iter-\\>first;  \n++count;  \n}  \nif (count == 2)  \n{  \nbreak;  \n}//找到这两就退出  \n}  \ncout \\<\\< \"[\" \\<\\< name1 \\<\\< \"---\" \\<\\< name2 \\<\\< \" cost: \" \\<\\< e.getWeight()\n\\<\\< \"]\" \\<\\< endl;  \n}  \n// kruskal-\\>printAll(); 需要字符显示  \n}  \nelse if (operation == 'E')  \n{  \ncout \\<\\< \"期待您的下次使用!\";  \nreturn 0;  \n}  \n}  \n}\n\n# 3 测试\n\n## 3.1 功能测试\n\n### 3.1.1 测试1\n\n测试数据：\n\n>   A\n\n>   4\n\n>   a b c d\n\n>   B\n\n>   a b 8\n\n>   b c 7\n\n>   c d 5\n\n>   d a 11\n\n>   a c 18\n\n>   b d 12\n\n>   0 0 0\n\n>   C\n\n>   D\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/95b5a5199946769ae1d9457ebb9843d4.jpg)\n\n>   最小生成树如下图（打勾位置为最小生成树的边）：\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/164782c09a1b8b0035e283513e84c6a1.png)\n\n### 3.1.2 测试2\n\n测试数据：\n\n>   A\n\n>   8\n\n>   0 1 2 3 4 5 6 7\n\n>   B\n\n>   4 5 0.35\n\n>   4 7 0.37\n\n>   5 7 0.28\n\n>   0 7 0.16\n\n>   1 5 0.32\n\n>   0 4 0.38\n\n>   2 3 0.17\n\n>   1 7 0.19\n\n>   0 2 0.26\n\n>   1 2 0.36\n\n>   1 3 0.29\n\n>   2 7 0.34\n\n>   6 2 0.40\n\n>   3 6 0.52\n\n>   6 0 0.58\n\n>   6 4 0.93\n\n>   0 0 0\n\n>   C\n\n>   D\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/e3674c9e620a0fc449001bca649d983a.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1402164181b81b090104671eb480894b.png)\n\n相应的最小生成树如下图：\n\n![这里写图片描述](https://tongji4m3.oss-cn-beijing.aliyuncs.com/a2ba172c465dbdd9736e7d5c059b1f05.png)\n","slug":"项目笔记/dataStructureProjects/电网建设造价模拟系统","published":1,"updated":"2020-11-12T11:57:30.415Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73w00onjotpgy0jhlit","content":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  电网建设造价模拟系统</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目简介\"><a href=\"#1-1-项目简介\" class=\"headerlink\" title=\"1.1 项目简介\"></a>1.1 项目简介</h2><p>假设一个城市有n个小区，要实现n个小区之间的电网都能够相互接通，构造这个城市n个小区之间的电网，使总工程造价最低。请设计一个能够满足要求的造价方案。</p>\n<p>在每个小区之间都可以设置一条电网线路，都要付出相应的经济代价。n个小区之间最多可以有n（n-1）/2条线路，选择其中的n-1条使总的耗费最少。</p>\n<h2 id=\"1-2-功能分析\"><a href=\"#1-2-功能分析\" class=\"headerlink\" title=\"1.2 功能分析\"></a>1.2 功能分析</h2><p>首先,每个小区当作一个顶点,那么就有n个顶点。两个小区之间设置一条电网线路相互联通且有相应的经济代价。所以可以抽取为一个加权无向图的模型。</p>\n<p>所以问题就成了求一个加权无向图的最小生成树。所以首先需要用户输入小区即顶点数，并且给每个小区进行命名以方便查看。然后用户将添加若干个电网线路以及他们之间的花费。而程序就负责找出这个加权无向图的最小生成树，并且显示出来。</p>\n<p>我用了Kruskal算法,所以需要许多类来辅助。大致架构是，MainTest类与用户交互，负责接受用户输入，并且用EdgeWeightedGraph类构造加权无向图，并且通过KruskalMST类得到一个存储边（Edge类）的队列（Queue类）（存储了最小生成树的边），然后再将这些边显示出来。而KruskalMST类还需要最小堆（MinPQ类）找最小的边与UF类辨认连通分量。所以总的来说有八个类以及一个input.txt存储一些测试数据。</p>\n<h1 id=\"2-设计与实现\"><a href=\"#2-设计与实现\" class=\"headerlink\" title=\"2 设计与实现\"></a>2 设计与实现</h1><h2 id=\"2-1-Edge-h设计与实现\"><a href=\"#2-1-Edge-h设计与实现\" class=\"headerlink\" title=\"2.1 Edge.h设计与实现\"></a>2.1 Edge.h设计与实现</h2><p>Edge类代表了图中的边，它有三个成员变量：边的两个顶点v，w与double类型的权值weight。</p>\n<p>构造函数就将这三个参数传入；还有三个函数分别得到v，w，weight的值，不过有些不同的是other函数是根据传入的边传出另外一条边，更加的灵活（如other（v）传回w）。最后重载了小于运算符&lt;,根据weight进行比较。</p>\n<p>class Edge<br>{<br>public:<br>Edge(){}<br>Edge(int v, int w, double weight) : v(v), w(w), weight(weight) {}  </p>\n<p>int either() const<br>{<br>return v;<br>}  </p>\n<p>int other(int vertex) const<br>{<br>if(vertex==v)<br>return w;<br>else if(vertex==w)<br>return v;<br>}  </p>\n<p>double getWeight() const<br>{<br>return weight;<br>}  </p>\n<p>bool operator &lt; (const Edge &amp; that) const<br>{<br>if (weight &lt; that.weight)<br>return true;<br>else<br>return false;<br>}  </p>\n<p>private:<br>int v;<br>int w;<br>double weight;<br>};</p>\n<h2 id=\"2-2-EdgeWeightedGraph-h设计与实现\"><a href=\"#2-2-EdgeWeightedGraph-h设计与实现\" class=\"headerlink\" title=\"2.2 EdgeWeightedGraph.h设计与实现\"></a>2.2 EdgeWeightedGraph.h设计与实现</h2><p>代表了图。三个成员变量，分别是顶点的数量V，边的数量E以及邻接表adj。其中邻接表存储了每个顶点所含有的边（类型为vector&lt;vector&lt;Edge&gt;&gt;）。</p>\n<p>构造函数将给定顶点数量N，并且让边为0，而且为邻接表adj开辟N个空间，使得每个顶点i都能使用adj[i]。</p>\n<p>函数有返回V和E数量的函数，以及添加边的函数addEdge（）：传入一条边，并且让边的两个顶点的邻接表分别加入这条边，最后让边数量+1。还有一个返回所以边的函数edges（）：很简单，就是遍历邻接表，对于每个顶点的每条边，将边放入队列中，需要注意的是，因为是无向图，所以如果所有顶点的边都加入就重复了，所以只加入v&lt;w</p>\n<p>的边，防止重复。</p>\n<p>class EdgeWeightedGraph<br>{<br>public:<br>EdgeWeightedGraph(int v) : V(v),E(0)<br>{<br>vector&lt;vector&lt;Edge&gt;&gt; temp(V);<br>adj=temp;<br>}  </p>\n<p>void addEdge(Edge e)<br>{<br>int v = e.either();<br>int w = e.other(v);<br>adj[v].push_back(e);//往邻接表中添加<br>adj[w].push_back(e);<br>++E;<br>}  </p>\n<p>Queue&lt;Edge&gt; edges()//返回所有边<br>{<br>Queue&lt;Edge&gt; queue;<br>for (int v = 0; v &lt; V; ++v)<br>{<br>for(Edge e:adj[v])<br>{<br>if(e.other(v)&gt;v)<br>{<br>queue.enqueue(e);<br>}<br>}<br>}<br>return queue;<br>}  </p>\n<p>int getV()<br>{<br>return V;<br>}  </p>\n<p>int getE()<br>{<br>return E;<br>}  </p>\n<p>private:<br>int V;<br>int E;<br>vector&lt;vector&lt;Edge&gt;&gt; adj;//邻接表  </p>\n<p>};</p>\n<h2 id=\"2-3-Queue-h与Node-h设计与实现\"><a href=\"#2-3-Queue-h与Node-h设计与实现\" class=\"headerlink\" title=\"2.3 Queue.h与Node.h设计与实现\"></a>2.3 Queue.h与Node.h设计与实现</h2><p>因为很多地方用到队列，所以又自己实现了一遍。队列需要用到Node.h之前说过很多此就不说了。</p>\n<p>队列为模板类，存储T类型。成员变量是指向队首的first指针以及指向队尾的last指针，还有一个存储元素个数的N。</p>\n<p>队列主要就是enqueue，dequeue以及empty和size四个函数。empty只要判断N==0即可，size也只要返回N即可。enqueue就是在队尾加入元素，具体操作为：如果队列为空，让头尾指针同时指向加入的元素，让计数N++。如果不为空，让当前的last-&gt;next指向新加入元素，再让last指向当前的最后元素，让计数N++。dequeue就将队首弹出，让first指向下一个元素，让计数N–，再稍微处理异常情况，比如弹出队首后让last也为空。</p>\n<p>template &lt;class T&gt; class Node<br>{<br>public:  </p>\n<p>Node(const T &amp; value, Node&lt;T&gt; *next= nullptr) : value(value), next(next) {}<br>Node(Node&lt;T&gt; *next= nullptr) : next(next) {}  </p>\n<p>T value;<br>Node&lt;T&gt; *next;<br>};</p>\n<p>template &lt;class T&gt; class Queue<br>{<br>public:<br>void enqueue(T t)<br>{<br>if(empty())//为空指向同一个<br>{<br>first=new Node&lt;T&gt;(t, nullptr);<br>last=first;<br>}<br>else<br>{<br>Node&lt;T&gt; * temp = new Node&lt;T&gt;(t, nullptr);<br>last-&gt;next=temp;<br>last=temp;<br>}<br>++N;<br>}<br>T dequeue()<br>{<br>if (empty())<br>throw “队列为空”;<br>T value=first-&gt;value;<br>first=first-&gt;next;<br>–N;<br>if(empty())<br>last= nullptr;<br>return value;<br>}  </p>\n<p>bool empty()<br>{<br>return N==0;<br>}  </p>\n<p>int size()<br>{<br>return N;<br>}  </p>\n<p>private:<br>Node&lt;T&gt; * first;<br>Node&lt;T&gt; * last;<br>int N = 0;<br>};</p>\n<h2 id=\"2-4-MinPQ-h设计与实现\"><a href=\"#2-4-MinPQ-h设计与实现\" class=\"headerlink\" title=\"2.4 MinPQ.h设计与实现\"></a>2.4 MinPQ.h设计与实现</h2><p>当构造一个堆时，需要输入一个堆中应该存的元素数量最大值len，令堆中的成员变量数组的长度为len+1，（因为不用数组的vec[0]），堆的这个类还有一个N记录当前堆的元素数量。</p>\n<p>公有函数：</p>\n<blockquote>\n<p>  1.isEmpty函数及size函数：因为N记录当前堆的元素数量,所以isEmpty函数返回N==0，<br>  size函数返回N即可。</p>\n</blockquote>\n<blockquote>\n<p>  2.push函数：令N+1,并且在N处添加元素，然后将这个元素swim，使得还是一个堆。</p>\n</blockquote>\n<blockquote>\n<p>  3.delMin函数：最小元素在堆顶，先用一个变量存储堆顶的值，将堆顶与堆中最后一个元素交换，令N-1，此时不是一个堆，需要将堆顶sink到合适的位置，最后返回之前存的堆顶元素的值。</p>\n</blockquote>\n<p>私有函数：</p>\n<blockquote>\n<p>  1.sink函数：sink的思路是将这个元素与他的子节点做对比，并且将较小的放上面，一直对比到这个元素小于他的两个子节点为止。具体实现是，假如要下沉k，则先找它的子节点2*k与2*k+1中最小的一个（当然得判断是否存在），如果小于他的子节点的值，那么就交换他们的值，并且让k=2*k或2*k+1（＝最小的那个），这是为了继续追踪原本的k，继续和他此时的两个子节点做对比。不断的循环，直到他没有子节点或者他小于了子节点。</p>\n</blockquote>\n<p>2.swim函数：直观看就是一个元素比较轻，然后它要不断上浮，直到它重与他的父节点。而代码的实现就是，查看他的父节点k/2的值是否小于它，如果不小于它，则交换它和它父节点的值，并且让k=k/2，即继续追踪这个元素，让它继续与它当前的父节点做对比。直到它本身为数组的第一个元素或者它不小于它的父节点。</p>\n<p>template &lt;class T&gt; class MinPQ<br>{<br>public:<br>MinPQ(int N):pq(N+1)<br>{  </p>\n<p>}  </p>\n<p>bool isEmpty()<br>{<br>return size()==0;<br>}  </p>\n<p>int size()<br>{<br>return N;<br>}  </p>\n<p>T delMin()<br>{<br>T min = pq[1];<br>exch(1, N–);<br>sink(1);<br>return min;<br>}  </p>\n<p>void push(T t)<br>{<br>pq[++N] = t;<br>swim(N);<br>}  </p>\n<p>private:<br>vector&lt;T&gt; pq;<br>int N=0;//元素个数,从1开始  </p>\n<p>void swim(int k)<br>{<br>while(k&gt;1 &amp;&amp; pq[k] &lt; pq[k/2])<br>{<br>exch(k, k / 2);<br>k /= 2;<br>}<br>}  </p>\n<p>void sink(int k)<br>{<br>while(2 * k &lt;=N)<br>{<br>int j = 2 * k;<br>if(j+1&lt;=N &amp;&amp; pq[j+1]&lt;pq[j])<br>{<br>++j;<br>}<br>if(pq[k]&lt;pq[j])<br>{<br>break;<br>}<br>exch(k, j);<br>k = j;<br>}<br>}  </p>\n<p>void exch(int i,int j)<br>{<br>T temp = pq[i];<br>pq[i] = pq[j];<br>pq[j] = temp;<br>}<br>};</p>\n<h2 id=\"2-5-UF-h设计与实现\"><a href=\"#2-5-UF-h设计与实现\" class=\"headerlink\" title=\"2.5 UF.h设计与实现\"></a>2.5 UF.h设计与实现</h2><p>该类负责构造连通分量。他有三个成员变量，id存储每个顶点的父节点，sz存储每个顶点所属于的那个连通分量的规模（想象如果将规模大的根节点链接到规模小的,那么就会使得节点平均访问到根节点的时间增加,所以需要将规模大的作为根节点），以及当前连通分量数量count。</p>\n<p>构造函数将当前所以节点的父节点赋值为他们本身并且每个节点的size都是1，并且让当前连通分量数量count等于顶点总数N。这代表了当前有N个连通分量，每两个顶点之间都互不连通。</p>\n<p>主要有这几个函数：getCount()返回当前连通分量数量count；connected(int p, int<br>q)检测两个顶点是否是连通的，这通过调用find(int<br>p)来判断，如果find（p）==find(q),他们就是同一个连通分量；find(int<br>p)则找到p的根节点，即顶点p所属于的连通分量。unionPQ(int p, int<br>q)则将两个不连通的节点连通。</p>\n<p>详细说明find（int<br>p）：因为每次查找id[p],如果id[p]=p，代表p是p的根节点，代表这就是一个连通分量。而如果id[p]不等于p，则代表p是某个连通分量的子节点，而id[p]就是它的父节点，所以让p=<br>id[p]使得p到了他的父节点，继续查找，直到找到这个连通分量的根节点，对应的就是最终的p=<br>id[p]。</p>\n<p>unionPQ(int p, int<br>q)：先找到传入的p，q的根节点i，j，如果根节点相同，那么他们是同一个连通分量直接返回。接着，判断这两个根节点的规模sz[i],sz[j]。然后将规模小的链接到规模大的上面(也就是以规模大的这个根节点作为这两棵树合起来的根节点)，这样找某个节点的根节点更快。然后将该根节点的规模再加上规模小的那个节点的规模,这样才使得规模有意义。</p>\n<p>class UF<br>{<br>public:<br>UF(int N)<br>{<br>for (int i = 0; i &lt; N; ++i)<br>{<br>id.push_back(i);<br>sz.push_back(1);<br>}<br>count=N;<br>}  </p>\n<p>int getCount()<br>{<br>return count;<br>}  </p>\n<p>bool connected(int p,int q)<br>{<br>return find(p) == find(q);//检测是不是在同一颗树上<br>}  </p>\n<p>int find(int p)<br>{<br>while(p!=id[p])<br>{<br>p = id[p];<br>}<br>return p;<br>}  </p>\n<p>void unionPQ(int p,int q)<br>{<br>int i = find(p);<br>int j = find(q);<br>if(i==j)<br>{<br>return;<br>}<br>if(sz[i]&lt;sz[j])<br>{<br>id[i] = j;<br>sz[j] += sz[i];<br>}<br>else<br>{<br>id[j] = i;<br>sz[i] += sz[j];<br>}<br>count–;<br>}  </p>\n<p>private:<br>vector&lt;int&gt; id;//父链接数组<br>vector&lt;int&gt; sz;//没颗树高度<br>int count;//连通分量数量<br>};</p>\n<h2 id=\"2-6-KruskalMST-h设计与实现\"><a href=\"#2-6-KruskalMST-h设计与实现\" class=\"headerlink\" title=\"2.6 KruskalMST.h设计与实现\"></a>2.6 KruskalMST.h设计与实现</h2><p>该类就负责计算最小生成树。需要传入构造好的加权无向图，它有个成员变量mst将负责返回存有最小生成树的所有边的队列。</p>\n<p>主要就两个函数，getMST返回mst，即返回存有最小生成树的所有边的队列；构造函数传入加权无向图，调用MinPQ类，并且把树中所有的边都放入最小堆中。还调用了UF类，传入了图中的顶点数，代表了初试有V个连通分量。紧接着，当最小生成树中边的数量小于V-1并且最小堆中还有边的时候，就一直循环。在循环之中，不断的弹出最小堆中最小的边，而如果这条边的两个顶点是两个不同的连通分量，说明这条边是最小生成树中的边，于是将之加入到存有最小生成树的所有边的队列mst中，并且将这两个顶点连接起来，成为同一个连通分量。而如果弹出最小堆中最小的边的两个顶点是同一个连通分量，则这条边不是最小生成树中的边，则忽略它，继续循环。</p>\n<p>class KruskalMST<br>{<br>public:<br>KruskalMST(EdgeWeightedGraph G)<br>{<br>MinPQ&lt;Edge&gt; pq(G.getE());<br>Queue&lt;Edge&gt; edges = G.edges();<br>while(!edges.empty())<br>{<br>pq.push(edges.dequeue());<br>}<br>UF uf(G.getV());  </p>\n<p>while(!pq.isEmpty() &amp;&amp; mst.size()&lt;G.getV()-1)<br>{<br>Edge e = pq.delMin();<br>int v = e.either();<br>int w = e.other(v);<br>if(uf.connected(v,w))<br>continue;<br>uf.unionPQ(v,w);<br>mst.enqueue(e);<br>}<br>}  </p>\n<p>Queue&lt;Edge&gt; getMST()<br>{<br>return mst;<br>}  </p>\n<p>private:<br>Queue&lt;Edge&gt; mst;<br>};</p>\n<h2 id=\"2-7-MainTest-cpp设计与实现\"><a href=\"#2-7-MainTest-cpp设计与实现\" class=\"headerlink\" title=\"2.7 MainTest.cpp设计与实现\"></a>2.7 MainTest.cpp设计与实现</h2><p>先给出相应的提示，之后创建一个map以将之后用户输入的节点代号和节点数字相互对应。然后进入循环等待用户进行操作。</p>\n<p>如果用户选择操作A，就让用户输入N个顶点和他们的代号，然后程序会生成一个含有N个顶点的不含有边的图（这里图中存的只是顶点数字，而顶点代号与顶点数字的对应关系存在map中）。</p>\n<p>如果选择B操作，将不断循环，将用户输入的正确的两个顶点与边的权值加入到加权无向图中（当然首先得把用户输入的顶点代号通过map转换为对应的顶点数字）。当用户输入0<br>0 0时，退出当前输入边的循环。</p>\n<p>如果选择C操作，则将加权无向图传入上述所实现的KruskalMST.h类的构造函数中，其实此时已经生成了最小生成树，就存在指向KruskalMST.h类的指针kruskal中。</p>\n<p>如果选择D操作，将显示最小生成树，具体是，通过kruskal-&gt;getMST()得到存储有所有最小生成树边的队列。然后从队列中取出所有的边，并且将边的两个顶点数字通过map转换为顶点代号，并且打印出来。</p>\n<p>int main()<br>{  </p>\n<p>cout &lt;&lt; “** 电网建设造价模拟系统 **“ &lt;&lt; endl;<br>cout &lt;&lt; “================================================” &lt;&lt; endl;<br>cout &lt;&lt; “** A—创建电网顶点 **“ &lt;&lt; endl;<br>cout &lt;&lt; “** B—添加电网的边 **“ &lt;&lt; endl;<br>cout &lt;&lt; “** C—构造最小生成树 **“ &lt;&lt; endl;<br>cout &lt;&lt; “** D—显示最小生成树 **“ &lt;&lt; endl;<br>cout &lt;&lt; “** E—退出程序 **“ &lt;&lt; endl;<br>cout &lt;&lt; “================================================” &lt;&lt; endl;  </p>\n<p>unordered_map&lt;string, int&gt; names;//节点名字与节点数字相互对应<br>EdgeWeightedGraph * G = nullptr;<br>KruskalMST * kruskal = nullptr;  </p>\n<p>while (true)<br>{<br>cout &lt;&lt; “请选择操作:”;<br>char operation;<br>cin &gt;&gt; operation;<br>if (operation == ‘A’)<br>{<br>cout &lt;&lt; “请输入节点数量:”;<br>int N;//节点数量<br>cin &gt;&gt; N;<br>cout &lt;&lt; “请依次输入节点名称:”;<br>for (int i = 0; i &lt; N; ++i)<br>{<br>string node;<br>cin &gt;&gt; node;<br>names[node] = i;<br>}<br>G = new EdgeWeightedGraph(N);//生成一个没有边的图<br>}<br>else if (operation == ‘B’)<br>{<br>while (true)<br>{<br>cout &lt;&lt; “请输入两个顶点及边：(输入0 0 0 结束)”;<br>string node1, node2;<br>double nodeValue;<br>cin &gt;&gt; node1 &gt;&gt; node2 &gt;&gt; nodeValue;<br>if (node1 == “0” &amp;&amp; node2 == “0” &amp;&amp; nodeValue == 0)<br>{<br>break;<br>}<br>if (nodeValue &lt;= 0)<br>{<br>cout &lt;&lt; “输入错误,两个城市线路的花费不能小于等于0”;<br>}<br>int v = 0, w = 0;<br>auto iter = names.find(node1);<br>if (iter != names.end())<br>{<br>v = iter-&gt;second;<br>}<br>auto iter2 = names.find(node2);<br>if (iter2 != names.end())<br>{<br>w = iter2-&gt;second;<br>}<br>if (v == -1 || w == -1)<br>{<br>cout &lt;&lt; “输入错误,输入的顶点不在图中!”;<br>}<br>else<br>{<br>Edge edge(v, w, nodeValue);<br>G-&gt;addEdge(edge);<br>}<br>}<br>}<br>else if (operation == ‘C’)<br>{<br>cout &lt;&lt; “最小生成树构建成功!”;<br>kruskal = new KruskalMST(*G);<br>}<br>else if (operation == ‘D’)<br>{<br>cout &lt;&lt; “最小生成树的顶点和边为:” &lt;&lt; endl;<br>Queue&lt;Edge&gt; queue = kruskal-&gt;getMST();<br>while (!queue.empty())<br>{<br>Edge e = queue.dequeue();<br>int v = e.either();<br>int w = e.other(v);<br>string name1, name2;  </p>\n<p>int count = 0;<br>for (auto iter = names.begin(); iter != names.end(); ++iter)<br>{<br>if (iter-&gt;second == v)<br>{<br>name1 = iter-&gt;first;<br>++count;<br>}<br>if (iter-&gt;second == w)<br>{<br>name2 = iter-&gt;first;<br>++count;<br>}<br>if (count == 2)<br>{<br>break;<br>}//找到这两就退出<br>}<br>cout &lt;&lt; “[“ &lt;&lt; name1 &lt;&lt; “—“ &lt;&lt; name2 &lt;&lt; “ cost: “ &lt;&lt; e.getWeight()<br>&lt;&lt; “]” &lt;&lt; endl;<br>}<br>// kruskal-&gt;printAll(); 需要字符显示<br>}<br>else if (operation == ‘E’)<br>{<br>cout &lt;&lt; “期待您的下次使用!”;<br>return 0;<br>}<br>}<br>}</p>\n<h1 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3 测试\"></a>3 测试</h1><h2 id=\"3-1-功能测试\"><a href=\"#3-1-功能测试\" class=\"headerlink\" title=\"3.1 功能测试\"></a>3.1 功能测试</h2><h3 id=\"3-1-1-测试1\"><a href=\"#3-1-1-测试1\" class=\"headerlink\" title=\"3.1.1 测试1\"></a>3.1.1 测试1</h3><p>测试数据：</p>\n<blockquote>\n<p>  A</p>\n</blockquote>\n<blockquote>\n<p>  4</p>\n</blockquote>\n<blockquote>\n<p>  a b c d</p>\n</blockquote>\n<blockquote>\n<p>  B</p>\n</blockquote>\n<blockquote>\n<p>  a b 8</p>\n</blockquote>\n<blockquote>\n<p>  b c 7</p>\n</blockquote>\n<blockquote>\n<p>  c d 5</p>\n</blockquote>\n<blockquote>\n<p>  d a 11</p>\n</blockquote>\n<blockquote>\n<p>  a c 18</p>\n</blockquote>\n<blockquote>\n<p>  b d 12</p>\n</blockquote>\n<blockquote>\n<p>  0 0 0</p>\n</blockquote>\n<blockquote>\n<p>  C</p>\n</blockquote>\n<blockquote>\n<p>  D</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/95b5a5199946769ae1d9457ebb9843d4.jpg\"></p>\n<blockquote>\n<p>  最小生成树如下图（打勾位置为最小生成树的边）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/164782c09a1b8b0035e283513e84c6a1.png\"></p>\n<h3 id=\"3-1-2-测试2\"><a href=\"#3-1-2-测试2\" class=\"headerlink\" title=\"3.1.2 测试2\"></a>3.1.2 测试2</h3><p>测试数据：</p>\n<blockquote>\n<p>  A</p>\n</blockquote>\n<blockquote>\n<p>  8</p>\n</blockquote>\n<blockquote>\n<p>  0 1 2 3 4 5 6 7</p>\n</blockquote>\n<blockquote>\n<p>  B</p>\n</blockquote>\n<blockquote>\n<p>  4 5 0.35</p>\n</blockquote>\n<blockquote>\n<p>  4 7 0.37</p>\n</blockquote>\n<blockquote>\n<p>  5 7 0.28</p>\n</blockquote>\n<blockquote>\n<p>  0 7 0.16</p>\n</blockquote>\n<blockquote>\n<p>  1 5 0.32</p>\n</blockquote>\n<blockquote>\n<p>  0 4 0.38</p>\n</blockquote>\n<blockquote>\n<p>  2 3 0.17</p>\n</blockquote>\n<blockquote>\n<p>  1 7 0.19</p>\n</blockquote>\n<blockquote>\n<p>  0 2 0.26</p>\n</blockquote>\n<blockquote>\n<p>  1 2 0.36</p>\n</blockquote>\n<blockquote>\n<p>  1 3 0.29</p>\n</blockquote>\n<blockquote>\n<p>  2 7 0.34</p>\n</blockquote>\n<blockquote>\n<p>  6 2 0.40</p>\n</blockquote>\n<blockquote>\n<p>  3 6 0.52</p>\n</blockquote>\n<blockquote>\n<p>  6 0 0.58</p>\n</blockquote>\n<blockquote>\n<p>  6 4 0.93</p>\n</blockquote>\n<blockquote>\n<p>  0 0 0</p>\n</blockquote>\n<blockquote>\n<p>  C</p>\n</blockquote>\n<blockquote>\n<p>  D</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e3674c9e620a0fc449001bca649d983a.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1402164181b81b090104671eb480894b.png\"></p>\n<p>相应的最小生成树如下图：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/a2ba172c465dbdd9736e7d5c059b1f05.png\" alt=\"这里写图片描述\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  电网建设造价模拟系统</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目简介\"><a href=\"#1-1-项目简介\" class=\"headerlink\" title=\"1.1 项目简介\"></a>1.1 项目简介</h2><p>假设一个城市有n个小区，要实现n个小区之间的电网都能够相互接通，构造这个城市n个小区之间的电网，使总工程造价最低。请设计一个能够满足要求的造价方案。</p>\n<p>在每个小区之间都可以设置一条电网线路，都要付出相应的经济代价。n个小区之间最多可以有n（n-1）/2条线路，选择其中的n-1条使总的耗费最少。</p>\n<h2 id=\"1-2-功能分析\"><a href=\"#1-2-功能分析\" class=\"headerlink\" title=\"1.2 功能分析\"></a>1.2 功能分析</h2><p>首先,每个小区当作一个顶点,那么就有n个顶点。两个小区之间设置一条电网线路相互联通且有相应的经济代价。所以可以抽取为一个加权无向图的模型。</p>\n<p>所以问题就成了求一个加权无向图的最小生成树。所以首先需要用户输入小区即顶点数，并且给每个小区进行命名以方便查看。然后用户将添加若干个电网线路以及他们之间的花费。而程序就负责找出这个加权无向图的最小生成树，并且显示出来。</p>\n<p>我用了Kruskal算法,所以需要许多类来辅助。大致架构是，MainTest类与用户交互，负责接受用户输入，并且用EdgeWeightedGraph类构造加权无向图，并且通过KruskalMST类得到一个存储边（Edge类）的队列（Queue类）（存储了最小生成树的边），然后再将这些边显示出来。而KruskalMST类还需要最小堆（MinPQ类）找最小的边与UF类辨认连通分量。所以总的来说有八个类以及一个input.txt存储一些测试数据。</p>\n<h1 id=\"2-设计与实现\"><a href=\"#2-设计与实现\" class=\"headerlink\" title=\"2 设计与实现\"></a>2 设计与实现</h1><h2 id=\"2-1-Edge-h设计与实现\"><a href=\"#2-1-Edge-h设计与实现\" class=\"headerlink\" title=\"2.1 Edge.h设计与实现\"></a>2.1 Edge.h设计与实现</h2><p>Edge类代表了图中的边，它有三个成员变量：边的两个顶点v，w与double类型的权值weight。</p>\n<p>构造函数就将这三个参数传入；还有三个函数分别得到v，w，weight的值，不过有些不同的是other函数是根据传入的边传出另外一条边，更加的灵活（如other（v）传回w）。最后重载了小于运算符&lt;,根据weight进行比较。</p>\n<p>class Edge<br>{<br>public:<br>Edge(){}<br>Edge(int v, int w, double weight) : v(v), w(w), weight(weight) {}  </p>\n<p>int either() const<br>{<br>return v;<br>}  </p>\n<p>int other(int vertex) const<br>{<br>if(vertex==v)<br>return w;<br>else if(vertex==w)<br>return v;<br>}  </p>\n<p>double getWeight() const<br>{<br>return weight;<br>}  </p>\n<p>bool operator &lt; (const Edge &amp; that) const<br>{<br>if (weight &lt; that.weight)<br>return true;<br>else<br>return false;<br>}  </p>\n<p>private:<br>int v;<br>int w;<br>double weight;<br>};</p>\n<h2 id=\"2-2-EdgeWeightedGraph-h设计与实现\"><a href=\"#2-2-EdgeWeightedGraph-h设计与实现\" class=\"headerlink\" title=\"2.2 EdgeWeightedGraph.h设计与实现\"></a>2.2 EdgeWeightedGraph.h设计与实现</h2><p>代表了图。三个成员变量，分别是顶点的数量V，边的数量E以及邻接表adj。其中邻接表存储了每个顶点所含有的边（类型为vector&lt;vector&lt;Edge&gt;&gt;）。</p>\n<p>构造函数将给定顶点数量N，并且让边为0，而且为邻接表adj开辟N个空间，使得每个顶点i都能使用adj[i]。</p>\n<p>函数有返回V和E数量的函数，以及添加边的函数addEdge（）：传入一条边，并且让边的两个顶点的邻接表分别加入这条边，最后让边数量+1。还有一个返回所以边的函数edges（）：很简单，就是遍历邻接表，对于每个顶点的每条边，将边放入队列中，需要注意的是，因为是无向图，所以如果所有顶点的边都加入就重复了，所以只加入v&lt;w</p>\n<p>的边，防止重复。</p>\n<p>class EdgeWeightedGraph<br>{<br>public:<br>EdgeWeightedGraph(int v) : V(v),E(0)<br>{<br>vector&lt;vector&lt;Edge&gt;&gt; temp(V);<br>adj=temp;<br>}  </p>\n<p>void addEdge(Edge e)<br>{<br>int v = e.either();<br>int w = e.other(v);<br>adj[v].push_back(e);//往邻接表中添加<br>adj[w].push_back(e);<br>++E;<br>}  </p>\n<p>Queue&lt;Edge&gt; edges()//返回所有边<br>{<br>Queue&lt;Edge&gt; queue;<br>for (int v = 0; v &lt; V; ++v)<br>{<br>for(Edge e:adj[v])<br>{<br>if(e.other(v)&gt;v)<br>{<br>queue.enqueue(e);<br>}<br>}<br>}<br>return queue;<br>}  </p>\n<p>int getV()<br>{<br>return V;<br>}  </p>\n<p>int getE()<br>{<br>return E;<br>}  </p>\n<p>private:<br>int V;<br>int E;<br>vector&lt;vector&lt;Edge&gt;&gt; adj;//邻接表  </p>\n<p>};</p>\n<h2 id=\"2-3-Queue-h与Node-h设计与实现\"><a href=\"#2-3-Queue-h与Node-h设计与实现\" class=\"headerlink\" title=\"2.3 Queue.h与Node.h设计与实现\"></a>2.3 Queue.h与Node.h设计与实现</h2><p>因为很多地方用到队列，所以又自己实现了一遍。队列需要用到Node.h之前说过很多此就不说了。</p>\n<p>队列为模板类，存储T类型。成员变量是指向队首的first指针以及指向队尾的last指针，还有一个存储元素个数的N。</p>\n<p>队列主要就是enqueue，dequeue以及empty和size四个函数。empty只要判断N==0即可，size也只要返回N即可。enqueue就是在队尾加入元素，具体操作为：如果队列为空，让头尾指针同时指向加入的元素，让计数N++。如果不为空，让当前的last-&gt;next指向新加入元素，再让last指向当前的最后元素，让计数N++。dequeue就将队首弹出，让first指向下一个元素，让计数N–，再稍微处理异常情况，比如弹出队首后让last也为空。</p>\n<p>template &lt;class T&gt; class Node<br>{<br>public:  </p>\n<p>Node(const T &amp; value, Node&lt;T&gt; *next= nullptr) : value(value), next(next) {}<br>Node(Node&lt;T&gt; *next= nullptr) : next(next) {}  </p>\n<p>T value;<br>Node&lt;T&gt; *next;<br>};</p>\n<p>template &lt;class T&gt; class Queue<br>{<br>public:<br>void enqueue(T t)<br>{<br>if(empty())//为空指向同一个<br>{<br>first=new Node&lt;T&gt;(t, nullptr);<br>last=first;<br>}<br>else<br>{<br>Node&lt;T&gt; * temp = new Node&lt;T&gt;(t, nullptr);<br>last-&gt;next=temp;<br>last=temp;<br>}<br>++N;<br>}<br>T dequeue()<br>{<br>if (empty())<br>throw “队列为空”;<br>T value=first-&gt;value;<br>first=first-&gt;next;<br>–N;<br>if(empty())<br>last= nullptr;<br>return value;<br>}  </p>\n<p>bool empty()<br>{<br>return N==0;<br>}  </p>\n<p>int size()<br>{<br>return N;<br>}  </p>\n<p>private:<br>Node&lt;T&gt; * first;<br>Node&lt;T&gt; * last;<br>int N = 0;<br>};</p>\n<h2 id=\"2-4-MinPQ-h设计与实现\"><a href=\"#2-4-MinPQ-h设计与实现\" class=\"headerlink\" title=\"2.4 MinPQ.h设计与实现\"></a>2.4 MinPQ.h设计与实现</h2><p>当构造一个堆时，需要输入一个堆中应该存的元素数量最大值len，令堆中的成员变量数组的长度为len+1，（因为不用数组的vec[0]），堆的这个类还有一个N记录当前堆的元素数量。</p>\n<p>公有函数：</p>\n<blockquote>\n<p>  1.isEmpty函数及size函数：因为N记录当前堆的元素数量,所以isEmpty函数返回N==0，<br>  size函数返回N即可。</p>\n</blockquote>\n<blockquote>\n<p>  2.push函数：令N+1,并且在N处添加元素，然后将这个元素swim，使得还是一个堆。</p>\n</blockquote>\n<blockquote>\n<p>  3.delMin函数：最小元素在堆顶，先用一个变量存储堆顶的值，将堆顶与堆中最后一个元素交换，令N-1，此时不是一个堆，需要将堆顶sink到合适的位置，最后返回之前存的堆顶元素的值。</p>\n</blockquote>\n<p>私有函数：</p>\n<blockquote>\n<p>  1.sink函数：sink的思路是将这个元素与他的子节点做对比，并且将较小的放上面，一直对比到这个元素小于他的两个子节点为止。具体实现是，假如要下沉k，则先找它的子节点2*k与2*k+1中最小的一个（当然得判断是否存在），如果小于他的子节点的值，那么就交换他们的值，并且让k=2*k或2*k+1（＝最小的那个），这是为了继续追踪原本的k，继续和他此时的两个子节点做对比。不断的循环，直到他没有子节点或者他小于了子节点。</p>\n</blockquote>\n<p>2.swim函数：直观看就是一个元素比较轻，然后它要不断上浮，直到它重与他的父节点。而代码的实现就是，查看他的父节点k/2的值是否小于它，如果不小于它，则交换它和它父节点的值，并且让k=k/2，即继续追踪这个元素，让它继续与它当前的父节点做对比。直到它本身为数组的第一个元素或者它不小于它的父节点。</p>\n<p>template &lt;class T&gt; class MinPQ<br>{<br>public:<br>MinPQ(int N):pq(N+1)<br>{  </p>\n<p>}  </p>\n<p>bool isEmpty()<br>{<br>return size()==0;<br>}  </p>\n<p>int size()<br>{<br>return N;<br>}  </p>\n<p>T delMin()<br>{<br>T min = pq[1];<br>exch(1, N–);<br>sink(1);<br>return min;<br>}  </p>\n<p>void push(T t)<br>{<br>pq[++N] = t;<br>swim(N);<br>}  </p>\n<p>private:<br>vector&lt;T&gt; pq;<br>int N=0;//元素个数,从1开始  </p>\n<p>void swim(int k)<br>{<br>while(k&gt;1 &amp;&amp; pq[k] &lt; pq[k/2])<br>{<br>exch(k, k / 2);<br>k /= 2;<br>}<br>}  </p>\n<p>void sink(int k)<br>{<br>while(2 * k &lt;=N)<br>{<br>int j = 2 * k;<br>if(j+1&lt;=N &amp;&amp; pq[j+1]&lt;pq[j])<br>{<br>++j;<br>}<br>if(pq[k]&lt;pq[j])<br>{<br>break;<br>}<br>exch(k, j);<br>k = j;<br>}<br>}  </p>\n<p>void exch(int i,int j)<br>{<br>T temp = pq[i];<br>pq[i] = pq[j];<br>pq[j] = temp;<br>}<br>};</p>\n<h2 id=\"2-5-UF-h设计与实现\"><a href=\"#2-5-UF-h设计与实现\" class=\"headerlink\" title=\"2.5 UF.h设计与实现\"></a>2.5 UF.h设计与实现</h2><p>该类负责构造连通分量。他有三个成员变量，id存储每个顶点的父节点，sz存储每个顶点所属于的那个连通分量的规模（想象如果将规模大的根节点链接到规模小的,那么就会使得节点平均访问到根节点的时间增加,所以需要将规模大的作为根节点），以及当前连通分量数量count。</p>\n<p>构造函数将当前所以节点的父节点赋值为他们本身并且每个节点的size都是1，并且让当前连通分量数量count等于顶点总数N。这代表了当前有N个连通分量，每两个顶点之间都互不连通。</p>\n<p>主要有这几个函数：getCount()返回当前连通分量数量count；connected(int p, int<br>q)检测两个顶点是否是连通的，这通过调用find(int<br>p)来判断，如果find（p）==find(q),他们就是同一个连通分量；find(int<br>p)则找到p的根节点，即顶点p所属于的连通分量。unionPQ(int p, int<br>q)则将两个不连通的节点连通。</p>\n<p>详细说明find（int<br>p）：因为每次查找id[p],如果id[p]=p，代表p是p的根节点，代表这就是一个连通分量。而如果id[p]不等于p，则代表p是某个连通分量的子节点，而id[p]就是它的父节点，所以让p=<br>id[p]使得p到了他的父节点，继续查找，直到找到这个连通分量的根节点，对应的就是最终的p=<br>id[p]。</p>\n<p>unionPQ(int p, int<br>q)：先找到传入的p，q的根节点i，j，如果根节点相同，那么他们是同一个连通分量直接返回。接着，判断这两个根节点的规模sz[i],sz[j]。然后将规模小的链接到规模大的上面(也就是以规模大的这个根节点作为这两棵树合起来的根节点)，这样找某个节点的根节点更快。然后将该根节点的规模再加上规模小的那个节点的规模,这样才使得规模有意义。</p>\n<p>class UF<br>{<br>public:<br>UF(int N)<br>{<br>for (int i = 0; i &lt; N; ++i)<br>{<br>id.push_back(i);<br>sz.push_back(1);<br>}<br>count=N;<br>}  </p>\n<p>int getCount()<br>{<br>return count;<br>}  </p>\n<p>bool connected(int p,int q)<br>{<br>return find(p) == find(q);//检测是不是在同一颗树上<br>}  </p>\n<p>int find(int p)<br>{<br>while(p!=id[p])<br>{<br>p = id[p];<br>}<br>return p;<br>}  </p>\n<p>void unionPQ(int p,int q)<br>{<br>int i = find(p);<br>int j = find(q);<br>if(i==j)<br>{<br>return;<br>}<br>if(sz[i]&lt;sz[j])<br>{<br>id[i] = j;<br>sz[j] += sz[i];<br>}<br>else<br>{<br>id[j] = i;<br>sz[i] += sz[j];<br>}<br>count–;<br>}  </p>\n<p>private:<br>vector&lt;int&gt; id;//父链接数组<br>vector&lt;int&gt; sz;//没颗树高度<br>int count;//连通分量数量<br>};</p>\n<h2 id=\"2-6-KruskalMST-h设计与实现\"><a href=\"#2-6-KruskalMST-h设计与实现\" class=\"headerlink\" title=\"2.6 KruskalMST.h设计与实现\"></a>2.6 KruskalMST.h设计与实现</h2><p>该类就负责计算最小生成树。需要传入构造好的加权无向图，它有个成员变量mst将负责返回存有最小生成树的所有边的队列。</p>\n<p>主要就两个函数，getMST返回mst，即返回存有最小生成树的所有边的队列；构造函数传入加权无向图，调用MinPQ类，并且把树中所有的边都放入最小堆中。还调用了UF类，传入了图中的顶点数，代表了初试有V个连通分量。紧接着，当最小生成树中边的数量小于V-1并且最小堆中还有边的时候，就一直循环。在循环之中，不断的弹出最小堆中最小的边，而如果这条边的两个顶点是两个不同的连通分量，说明这条边是最小生成树中的边，于是将之加入到存有最小生成树的所有边的队列mst中，并且将这两个顶点连接起来，成为同一个连通分量。而如果弹出最小堆中最小的边的两个顶点是同一个连通分量，则这条边不是最小生成树中的边，则忽略它，继续循环。</p>\n<p>class KruskalMST<br>{<br>public:<br>KruskalMST(EdgeWeightedGraph G)<br>{<br>MinPQ&lt;Edge&gt; pq(G.getE());<br>Queue&lt;Edge&gt; edges = G.edges();<br>while(!edges.empty())<br>{<br>pq.push(edges.dequeue());<br>}<br>UF uf(G.getV());  </p>\n<p>while(!pq.isEmpty() &amp;&amp; mst.size()&lt;G.getV()-1)<br>{<br>Edge e = pq.delMin();<br>int v = e.either();<br>int w = e.other(v);<br>if(uf.connected(v,w))<br>continue;<br>uf.unionPQ(v,w);<br>mst.enqueue(e);<br>}<br>}  </p>\n<p>Queue&lt;Edge&gt; getMST()<br>{<br>return mst;<br>}  </p>\n<p>private:<br>Queue&lt;Edge&gt; mst;<br>};</p>\n<h2 id=\"2-7-MainTest-cpp设计与实现\"><a href=\"#2-7-MainTest-cpp设计与实现\" class=\"headerlink\" title=\"2.7 MainTest.cpp设计与实现\"></a>2.7 MainTest.cpp设计与实现</h2><p>先给出相应的提示，之后创建一个map以将之后用户输入的节点代号和节点数字相互对应。然后进入循环等待用户进行操作。</p>\n<p>如果用户选择操作A，就让用户输入N个顶点和他们的代号，然后程序会生成一个含有N个顶点的不含有边的图（这里图中存的只是顶点数字，而顶点代号与顶点数字的对应关系存在map中）。</p>\n<p>如果选择B操作，将不断循环，将用户输入的正确的两个顶点与边的权值加入到加权无向图中（当然首先得把用户输入的顶点代号通过map转换为对应的顶点数字）。当用户输入0<br>0 0时，退出当前输入边的循环。</p>\n<p>如果选择C操作，则将加权无向图传入上述所实现的KruskalMST.h类的构造函数中，其实此时已经生成了最小生成树，就存在指向KruskalMST.h类的指针kruskal中。</p>\n<p>如果选择D操作，将显示最小生成树，具体是，通过kruskal-&gt;getMST()得到存储有所有最小生成树边的队列。然后从队列中取出所有的边，并且将边的两个顶点数字通过map转换为顶点代号，并且打印出来。</p>\n<p>int main()<br>{  </p>\n<p>cout &lt;&lt; “** 电网建设造价模拟系统 **“ &lt;&lt; endl;<br>cout &lt;&lt; “================================================” &lt;&lt; endl;<br>cout &lt;&lt; “** A—创建电网顶点 **“ &lt;&lt; endl;<br>cout &lt;&lt; “** B—添加电网的边 **“ &lt;&lt; endl;<br>cout &lt;&lt; “** C—构造最小生成树 **“ &lt;&lt; endl;<br>cout &lt;&lt; “** D—显示最小生成树 **“ &lt;&lt; endl;<br>cout &lt;&lt; “** E—退出程序 **“ &lt;&lt; endl;<br>cout &lt;&lt; “================================================” &lt;&lt; endl;  </p>\n<p>unordered_map&lt;string, int&gt; names;//节点名字与节点数字相互对应<br>EdgeWeightedGraph * G = nullptr;<br>KruskalMST * kruskal = nullptr;  </p>\n<p>while (true)<br>{<br>cout &lt;&lt; “请选择操作:”;<br>char operation;<br>cin &gt;&gt; operation;<br>if (operation == ‘A’)<br>{<br>cout &lt;&lt; “请输入节点数量:”;<br>int N;//节点数量<br>cin &gt;&gt; N;<br>cout &lt;&lt; “请依次输入节点名称:”;<br>for (int i = 0; i &lt; N; ++i)<br>{<br>string node;<br>cin &gt;&gt; node;<br>names[node] = i;<br>}<br>G = new EdgeWeightedGraph(N);//生成一个没有边的图<br>}<br>else if (operation == ‘B’)<br>{<br>while (true)<br>{<br>cout &lt;&lt; “请输入两个顶点及边：(输入0 0 0 结束)”;<br>string node1, node2;<br>double nodeValue;<br>cin &gt;&gt; node1 &gt;&gt; node2 &gt;&gt; nodeValue;<br>if (node1 == “0” &amp;&amp; node2 == “0” &amp;&amp; nodeValue == 0)<br>{<br>break;<br>}<br>if (nodeValue &lt;= 0)<br>{<br>cout &lt;&lt; “输入错误,两个城市线路的花费不能小于等于0”;<br>}<br>int v = 0, w = 0;<br>auto iter = names.find(node1);<br>if (iter != names.end())<br>{<br>v = iter-&gt;second;<br>}<br>auto iter2 = names.find(node2);<br>if (iter2 != names.end())<br>{<br>w = iter2-&gt;second;<br>}<br>if (v == -1 || w == -1)<br>{<br>cout &lt;&lt; “输入错误,输入的顶点不在图中!”;<br>}<br>else<br>{<br>Edge edge(v, w, nodeValue);<br>G-&gt;addEdge(edge);<br>}<br>}<br>}<br>else if (operation == ‘C’)<br>{<br>cout &lt;&lt; “最小生成树构建成功!”;<br>kruskal = new KruskalMST(*G);<br>}<br>else if (operation == ‘D’)<br>{<br>cout &lt;&lt; “最小生成树的顶点和边为:” &lt;&lt; endl;<br>Queue&lt;Edge&gt; queue = kruskal-&gt;getMST();<br>while (!queue.empty())<br>{<br>Edge e = queue.dequeue();<br>int v = e.either();<br>int w = e.other(v);<br>string name1, name2;  </p>\n<p>int count = 0;<br>for (auto iter = names.begin(); iter != names.end(); ++iter)<br>{<br>if (iter-&gt;second == v)<br>{<br>name1 = iter-&gt;first;<br>++count;<br>}<br>if (iter-&gt;second == w)<br>{<br>name2 = iter-&gt;first;<br>++count;<br>}<br>if (count == 2)<br>{<br>break;<br>}//找到这两就退出<br>}<br>cout &lt;&lt; “[“ &lt;&lt; name1 &lt;&lt; “—“ &lt;&lt; name2 &lt;&lt; “ cost: “ &lt;&lt; e.getWeight()<br>&lt;&lt; “]” &lt;&lt; endl;<br>}<br>// kruskal-&gt;printAll(); 需要字符显示<br>}<br>else if (operation == ‘E’)<br>{<br>cout &lt;&lt; “期待您的下次使用!”;<br>return 0;<br>}<br>}<br>}</p>\n<h1 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3 测试\"></a>3 测试</h1><h2 id=\"3-1-功能测试\"><a href=\"#3-1-功能测试\" class=\"headerlink\" title=\"3.1 功能测试\"></a>3.1 功能测试</h2><h3 id=\"3-1-1-测试1\"><a href=\"#3-1-1-测试1\" class=\"headerlink\" title=\"3.1.1 测试1\"></a>3.1.1 测试1</h3><p>测试数据：</p>\n<blockquote>\n<p>  A</p>\n</blockquote>\n<blockquote>\n<p>  4</p>\n</blockquote>\n<blockquote>\n<p>  a b c d</p>\n</blockquote>\n<blockquote>\n<p>  B</p>\n</blockquote>\n<blockquote>\n<p>  a b 8</p>\n</blockquote>\n<blockquote>\n<p>  b c 7</p>\n</blockquote>\n<blockquote>\n<p>  c d 5</p>\n</blockquote>\n<blockquote>\n<p>  d a 11</p>\n</blockquote>\n<blockquote>\n<p>  a c 18</p>\n</blockquote>\n<blockquote>\n<p>  b d 12</p>\n</blockquote>\n<blockquote>\n<p>  0 0 0</p>\n</blockquote>\n<blockquote>\n<p>  C</p>\n</blockquote>\n<blockquote>\n<p>  D</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/95b5a5199946769ae1d9457ebb9843d4.jpg\"></p>\n<blockquote>\n<p>  最小生成树如下图（打勾位置为最小生成树的边）：</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/164782c09a1b8b0035e283513e84c6a1.png\"></p>\n<h3 id=\"3-1-2-测试2\"><a href=\"#3-1-2-测试2\" class=\"headerlink\" title=\"3.1.2 测试2\"></a>3.1.2 测试2</h3><p>测试数据：</p>\n<blockquote>\n<p>  A</p>\n</blockquote>\n<blockquote>\n<p>  8</p>\n</blockquote>\n<blockquote>\n<p>  0 1 2 3 4 5 6 7</p>\n</blockquote>\n<blockquote>\n<p>  B</p>\n</blockquote>\n<blockquote>\n<p>  4 5 0.35</p>\n</blockquote>\n<blockquote>\n<p>  4 7 0.37</p>\n</blockquote>\n<blockquote>\n<p>  5 7 0.28</p>\n</blockquote>\n<blockquote>\n<p>  0 7 0.16</p>\n</blockquote>\n<blockquote>\n<p>  1 5 0.32</p>\n</blockquote>\n<blockquote>\n<p>  0 4 0.38</p>\n</blockquote>\n<blockquote>\n<p>  2 3 0.17</p>\n</blockquote>\n<blockquote>\n<p>  1 7 0.19</p>\n</blockquote>\n<blockquote>\n<p>  0 2 0.26</p>\n</blockquote>\n<blockquote>\n<p>  1 2 0.36</p>\n</blockquote>\n<blockquote>\n<p>  1 3 0.29</p>\n</blockquote>\n<blockquote>\n<p>  2 7 0.34</p>\n</blockquote>\n<blockquote>\n<p>  6 2 0.40</p>\n</blockquote>\n<blockquote>\n<p>  3 6 0.52</p>\n</blockquote>\n<blockquote>\n<p>  6 0 0.58</p>\n</blockquote>\n<blockquote>\n<p>  6 4 0.93</p>\n</blockquote>\n<blockquote>\n<p>  0 0 0</p>\n</blockquote>\n<blockquote>\n<p>  C</p>\n</blockquote>\n<blockquote>\n<p>  D</p>\n</blockquote>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/e3674c9e620a0fc449001bca649d983a.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1402164181b81b090104671eb480894b.png\"></p>\n<p>相应的最小生成树如下图：</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/a2ba172c465dbdd9736e7d5c059b1f05.png\" alt=\"这里写图片描述\"></p>\n"},{"title":"数据结构项目-------勇闯迷宫游戏","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习数据结构项目--勇闯迷宫游戏所写的文档,主要是对二维数组的深搜.","abbrlink":"d9face0f","date":"2020-01-05T16:00:00.000Z","_content":"\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n>   勇闯迷宫游戏\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目简介\n\n迷宫只有两个门，一个门叫入口，另一个门叫出口。一个骑士骑马从入口进入迷宫，迷宫设置很多障碍，骑士需要在迷宫中寻找通路以到达出口。\n\n## 1.2 功能要求\n\n迷宫问题的求解过程可以采用回溯法即在一定的约束条件下试探地搜索前进，若前进中受阻，则及时回头纠正错误另择通路继续搜索的方法。从入口出发，按某一方向向前探索，若能走通，即某处可达，则到达新点，否则探索下一个方向；若所有的方向均没有通路，则沿原路返回前一点，换下一个方向再继续试探，直到所有可能的道路都探索到，或找到一条通路，或无路可走又返回入口点。在求解过程中，为了保证在达到某一个点后不能向前继续行走时，能正确返回前一个以便从下一个方向向前试探，则需要在试探过程中保存所能够达到的每个点的下标以及该点前进的方向，当找到出口时试探过程就结束了。\n\n实际就是一个深度优先搜索,只不过不是在图中,而是在数组中,所有只要注意数组边界就好。同时，需要存储迷宫的路径，所以还需要一个栈。\n\n# 2 设计\n\n## 2.1 Node设计\n\nNode节点和之前的类似,它保存一个模板类型的元素value,并且有一个指针next指向下一个元素,都是public的,以便于访问。\n\n## 2.2 Stack设计\n\n底层存储Node类头节点以及栈的元素个数N。为外界提供公有函数push（），pop（），top（），empty（）。提供栈的基本功能。\n\n## 2.3 主程序设计\n\n由用户输入迷宫的规模以及迷宫具体地形，再让用户输入起始位置及目标位置。并且程序判断位置是否合理。展示迷宫原来的样子，再通过dfs（）递归寻找出路，并且用一个栈存储路径，如果找到了从栈中取出路径（颠倒一次栈），如果没找到给出没有路径的提示。\n\n# 3 实现\n\n## 3.1 Node类实现\n\ntemplate \\<class T\\> class Node  \n{  \npublic:  \n\nNode(const T & value, Node\\<T\\> \\*next= nullptr) : value(value), next(next) {}  \nNode(Node\\<T\\> \\*next= nullptr) : next(next) {}  \n\nT value;  \nNode\\<T\\> \\*next;  \n};\n\n## 3.2 Stack类实现\n\n### 3.2.1 push功能实现\n\n新加入一个Node元素，并且将之指向原来的头节点，原来的头节点指向现在的头节点，将存储的元素个数N+1。\n\nvoid push(T t)  \n{  \nNode\\<T\\> \\*oldFirst = first;  \nfirst = new Node\\<T\\>(t, oldFirst);  \n++N;  \n}\n\n### 3.2.2 pop功能实现\n\n判断是否为空，不为空就让头节点指向下一个元素，然后delete之前的元素，释放内存，--N\n\nvoid pop()  \n{  \nif(empty())  \nreturn;  \nNode\\<T\\> \\*temp = first;  \nfirst = first-\\>next;  \ndelete temp;  \n--N;  \n}\n\n### 3.2.3 empty，top功能实现\n\nbool empty()  \n{  \nreturn N==0;  \n}  \n\nT top()  \n{  \nreturn first-\\>value;  \n}\n\n## 3.3 主函数功能的实现\n\n### 3.3.1 输入的处理\n\n先根据输入,赋值给M,N,然后创建M\\*N大小的二维数组,再根据输入的内容创建迷宫地形。\n\nint M,N;  \ncout \\<\\<\n\"先输入两个正整数,代表迷宫大小M\\*N;再输入M\\*N正整数(0,1代表迷宫的路和墙):\";  \ncin \\>\\> M \\>\\> N;  \nvector\\<vector\\<int\\>\\> map(M,\nvector\\<int\\>(N,1));//默认设置全为墙,当然没什么用,因为是用户进行输入  \nvector\\<vector\\<bool\\>\\> marked(M, vector\\<bool\\>(N, false));//默认为没访问过的\n\n/\\*  \n\\* 0 0 路  \n\\* 1 \\# 墙  \n\\* 2 x 走的路径  \n\\*/  \nfor (int i = 0; i \\< M; i++)  \n{  \nfor (int j = 0; j \\< N; j++)  \n{  \nint mapType;  \ncin \\>\\> mapType;  \nmap[i][j] = mapType;  \n}  \n}\n\n然后输入起始，终止位置\n\ncout \\<\\< \"输入起始坐标和结束坐标(xlo, ylo), (xhi, yhi):\";  \nint xlo, ylo, xhi, yhi;  \ncin \\>\\> xlo \\>\\> ylo \\>\\> xhi \\>\\> yhi;\n\n### 3.3.2 isValid（）函数\n\n用于检查起始，终止位置合理性，是否越界，是否为墙，并且给相应的提示，如果不合法，就直接结束程序。\n\nbool isValid(vector\\<vector\\<int\\>\\> & map,int M,int N,int xlo,int ylo,int\nxhi,int yhi)  \n{  \nif (xlo \\< 0 \\|\\| xlo \\>= M \\|\\| ylo \\< 0 \\|\\| ylo \\>= N)  \n{  \ncout \\<\\< \"起始路径就不在迷宫里面啊,大哥\";  \n}  \nelse if (map[xlo][ylo] == 1)//输入为墙,搞什么  \n{  \ncout \\<\\< \"起始路径为墙,你让他怎么走?\";  \n}  \nelse if (xhi \\< 0 \\|\\| xhi \\>= M \\|\\| yhi \\< 0 \\|\\| yhi \\>= N)  \n{  \ncout \\<\\< \"终点就不在迷宫里面啊,大哥\";  \n}  \nelse if (map[xhi][yhi] == 1)//终点为墙,搞什么  \n{  \ncout \\<\\< \"终点为墙,你让他怎么到?\";  \n}  \nelse  \n{  \nreturn true;  \n}  \nreturn false;  \n}\n\n### 3.3.3 dfs()函数初步实现\n\n从xlo,ylo开始，在没有找到xhi,yhi之前，不懂调用递归往四个方向的，没有标记为访问过的，没有越界的，是路径的位置走，而且是深度优先搜索，即如果进入了一个方向，则直到找完这个方向的所有路径后，才走另一个方向。\n\n初步实现的关键地方的代码（因为是直接截取完整程序，所以参数会带上了之后所用到的栈）：\n\nmarked[i][j] = true;\n\nif(i-1\\>=0 && map[i-1][j]==0 && !marked[i-1][j])  \n{  \ndfs(map, marked,path, i - 1, j, xhi, yhi, hasPath);  \n}  \nif(i+1\\<M && map[i+1][j]==0 && !marked[i+1][j])  \n{  \ndfs(map, marked,path, i+1, j, xhi, yhi, hasPath);  \n}  \nif(j+1\\<N && map[i][j+1]==0 && !marked[i][j+1])  \n{  \ndfs(map, marked,path, i, j+1, xhi, yhi, hasPath);  \n}  \nif(j-1\\>=0 && map[i][j-1]==0 && !marked[i][j-1])  \n{  \ndfs(map, marked,path, i, j-1, xhi, yhi, hasPath);  \n}\n\n### 3.3.4 dfs完整实现\n\n初步实现后，为了增加显示迷宫路径功能以及没有路径时给出提示的功能，还用到了一个自己实现的栈，以及bool类型的hasPath,用于当没有路径时才输出没有路径的提示信息。\n\n每递归调用一次，就将这个坐标加入栈中（用pair存储了坐标）。而当四个if都没进入时，即无路可走时，就弹出栈顶元素，这意味着，这个栈总是存储着当前能走的路径。\n\npath.push(make_pair(i, j));\n\n//四个if，不写出来了\n\n//无路可走时,弹栈  \npath.pop();\n\n然后，如果递归到了终点位置，即有路可走，就将hasPath设为true，并且用一个栈存储当前栈的反转（这样才是从入口到出口）。并且还将map在这个路径上的元素设置为2，即为路径。\n\n最后，输出迷宫，迷宫上的路径用（X）表示，并且在下方通过遍历那个反转栈，输出路径坐标，从入口到出口。结束dfs（）函数。\n\nvoid dfs(vector\\<vector\\<int\\>\\> & map, vector\\<vector\\<bool\\>\\>&\nmarked,Stack\\<pair\\<int,int\\>\\>& path, int i, int j, int xhi,int yhi,bool &\nhasPath)  \n{  \nint M = map.size(), N = map[0].size();  \npath.push(make_pair(i, j));  \nmarked[i][j] = true;  \nif(i==xhi && j==yhi)  \n{  \nhasPath = true;  \nStack\\<pair\\<int, int\\>\\> reverse;  \nwhile(!path.empty())  \n{  \npair\\<int, int\\> p = path.top();  \npath.pop();  \nreverse.push(p);//反转的stack,用于输出路径  \nmap[p.first][p.second] = 2;  \n}  \n\ncout\\<\\<endl;  \ncout \\<\\< \" \";  \nfor (int i = 0; i \\< N; ++i)  \n{  \ncout \\<\\< i \\<\\< \"列 \";  \n}  \ncout\\<\\<endl;  \nfor (int i = 0; i \\< M; ++i)  \n{  \ncout \\<\\< i \\<\\< \"行 \";  \nfor (int j = 0; j \\< N; ++j)  \n{  \nif(map[i][j]==0)  \n{  \ncout \\<\\< \"0\";  \n}  \nelse if(map[i][j]==2)  \n{  \ncout \\<\\< \"X\";  \n}  \nelse  \n{  \ncout \\<\\< \"\\#\";  \n}  \ncout \\<\\< \" \";  \n}  \ncout\\<\\<endl;  \n}  \n\ncout\\<\\<endl\\<\\<\"迷宫路径为:\"\\<\\<endl;  \nwhile(!reverse.empty())  \n{  \npair\\<int, int\\> p = reverse.top();  \nreverse.pop();  \nif(p.first==xhi && p.second==yhi)  \ncout\\<\\<\"(\" \\<\\< p.first \\<\\< \",\" \\<\\< p.second\\<\\<\")\"\\<\\<endl;  \nelse  \ncout \\<\\< \"(\" \\<\\< p.first \\<\\< \",\" \\<\\< p.second \\<\\< \")-\\>\";  \n}  \n}  \nif(i-1\\>=0 && map[i-1][j]==0 && !marked[i-1][j])  \n{  \ndfs(map, marked,path, i - 1, j, xhi, yhi, hasPath);  \n}  \nif(i+1\\<M && map[i+1][j]==0 && !marked[i+1][j])  \n{  \ndfs(map, marked,path, i+1, j, xhi, yhi, hasPath);  \n}  \nif(j+1\\<N && map[i][j+1]==0 && !marked[i][j+1])  \n{  \ndfs(map, marked,path, i, j+1, xhi, yhi, hasPath);  \n}  \nif(j-1\\>=0 && map[i][j-1]==0 && !marked[i][j-1])  \n{  \ndfs(map, marked,path, i, j-1, xhi, yhi, hasPath);  \n}  \n//无路可走时,弹栈  \npath.pop();  \n}\n\n# 4 测试\n\n## 4.1 功能测试\n\n### 4.1.1测试1\n\n**测试用例**：\n\n7 7\n\n>   0 0 1 1 1 1 1\n\n>   1 0 0 0 1 0 1\n\n>   0 0 1 0 1 1 1\n\n>   1 0 0 1 1 1 1\n\n>   0 0 1 1 0 0 0\n\n>   1 0 0 0 0 1 0\n\n>   1 1 0 1 0 1 0\n\n>   0 0 6 6\n\n**实验结果**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7348e9a6be66cbb7fbb596e3ad243881.png)\n\n### 4.1.2 测试2\n\n**测试用例：**\n\n7 7\n\n>   0 0 1 1 1 1 1\n\n>   1 0 0 0 1 0 1\n\n>   0 0 1 0 1 1 1\n\n>   1 0 0 1 1 1 1\n\n>   0 0 1 1 0 0 0\n\n>   1 0 0 0 0 1 0\n\n>   1 1 0 1 0 1 0\n\n>   1 2 6 2\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/808db98d12e8b446fd6b095419ba6765.png)\n\n### 4.1.3 测试3\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n1 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n0 0 3 8\n\n**实验结果：**\n\n**(从测试用例可以看出来,虽然找到了路径,但是不是最短路径)**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8e9fa6a0af7301967df044342347f881.png)\n\n## 4.2 边界测试\n\n### 4.2.1 没有从入口到出口的路径\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n0 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n0 0 6 0\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d3baf4ae3fc3dae87b3bca15183b5cf.png)\n\n### 4.2.2 入口不在数组中或者为墙\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n0 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n0 2 1 3\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/b217508045085f7f3ecf5d4c50c16dc7.png)\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n0 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n\\-1 -1 1 3\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/60fe345e77364143f9f493368d15f0b1.png)\n\n### 4.2.3 出口不在迷宫中或者出口为墙\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n0 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n0 0 -1 -1\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d10c0f20bb9d26b7761e786e3effd05f.png)\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n0 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n0 0 7 8\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/53b62b30d753de7a459fb3a75797283c.png)\n","source":"_posts/项目笔记/dataStructureProjects/勇闯迷宫游戏.md","raw":"---\ntitle: 数据结构项目-------勇闯迷宫游戏\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习数据结构项目--勇闯迷宫游戏所写的文档,主要是对二维数组的深搜.'\ncategories: 项目文档\ntags:\n  - 数据结构\n  - 二维数组\n  - c++\nabbrlink: d9face0f\ndate: 2020-01-06 00:00:00\n---\n\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n>   勇闯迷宫游戏\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目简介\n\n迷宫只有两个门，一个门叫入口，另一个门叫出口。一个骑士骑马从入口进入迷宫，迷宫设置很多障碍，骑士需要在迷宫中寻找通路以到达出口。\n\n## 1.2 功能要求\n\n迷宫问题的求解过程可以采用回溯法即在一定的约束条件下试探地搜索前进，若前进中受阻，则及时回头纠正错误另择通路继续搜索的方法。从入口出发，按某一方向向前探索，若能走通，即某处可达，则到达新点，否则探索下一个方向；若所有的方向均没有通路，则沿原路返回前一点，换下一个方向再继续试探，直到所有可能的道路都探索到，或找到一条通路，或无路可走又返回入口点。在求解过程中，为了保证在达到某一个点后不能向前继续行走时，能正确返回前一个以便从下一个方向向前试探，则需要在试探过程中保存所能够达到的每个点的下标以及该点前进的方向，当找到出口时试探过程就结束了。\n\n实际就是一个深度优先搜索,只不过不是在图中,而是在数组中,所有只要注意数组边界就好。同时，需要存储迷宫的路径，所以还需要一个栈。\n\n# 2 设计\n\n## 2.1 Node设计\n\nNode节点和之前的类似,它保存一个模板类型的元素value,并且有一个指针next指向下一个元素,都是public的,以便于访问。\n\n## 2.2 Stack设计\n\n底层存储Node类头节点以及栈的元素个数N。为外界提供公有函数push（），pop（），top（），empty（）。提供栈的基本功能。\n\n## 2.3 主程序设计\n\n由用户输入迷宫的规模以及迷宫具体地形，再让用户输入起始位置及目标位置。并且程序判断位置是否合理。展示迷宫原来的样子，再通过dfs（）递归寻找出路，并且用一个栈存储路径，如果找到了从栈中取出路径（颠倒一次栈），如果没找到给出没有路径的提示。\n\n# 3 实现\n\n## 3.1 Node类实现\n\ntemplate \\<class T\\> class Node  \n{  \npublic:  \n\nNode(const T & value, Node\\<T\\> \\*next= nullptr) : value(value), next(next) {}  \nNode(Node\\<T\\> \\*next= nullptr) : next(next) {}  \n\nT value;  \nNode\\<T\\> \\*next;  \n};\n\n## 3.2 Stack类实现\n\n### 3.2.1 push功能实现\n\n新加入一个Node元素，并且将之指向原来的头节点，原来的头节点指向现在的头节点，将存储的元素个数N+1。\n\nvoid push(T t)  \n{  \nNode\\<T\\> \\*oldFirst = first;  \nfirst = new Node\\<T\\>(t, oldFirst);  \n++N;  \n}\n\n### 3.2.2 pop功能实现\n\n判断是否为空，不为空就让头节点指向下一个元素，然后delete之前的元素，释放内存，--N\n\nvoid pop()  \n{  \nif(empty())  \nreturn;  \nNode\\<T\\> \\*temp = first;  \nfirst = first-\\>next;  \ndelete temp;  \n--N;  \n}\n\n### 3.2.3 empty，top功能实现\n\nbool empty()  \n{  \nreturn N==0;  \n}  \n\nT top()  \n{  \nreturn first-\\>value;  \n}\n\n## 3.3 主函数功能的实现\n\n### 3.3.1 输入的处理\n\n先根据输入,赋值给M,N,然后创建M\\*N大小的二维数组,再根据输入的内容创建迷宫地形。\n\nint M,N;  \ncout \\<\\<\n\"先输入两个正整数,代表迷宫大小M\\*N;再输入M\\*N正整数(0,1代表迷宫的路和墙):\";  \ncin \\>\\> M \\>\\> N;  \nvector\\<vector\\<int\\>\\> map(M,\nvector\\<int\\>(N,1));//默认设置全为墙,当然没什么用,因为是用户进行输入  \nvector\\<vector\\<bool\\>\\> marked(M, vector\\<bool\\>(N, false));//默认为没访问过的\n\n/\\*  \n\\* 0 0 路  \n\\* 1 \\# 墙  \n\\* 2 x 走的路径  \n\\*/  \nfor (int i = 0; i \\< M; i++)  \n{  \nfor (int j = 0; j \\< N; j++)  \n{  \nint mapType;  \ncin \\>\\> mapType;  \nmap[i][j] = mapType;  \n}  \n}\n\n然后输入起始，终止位置\n\ncout \\<\\< \"输入起始坐标和结束坐标(xlo, ylo), (xhi, yhi):\";  \nint xlo, ylo, xhi, yhi;  \ncin \\>\\> xlo \\>\\> ylo \\>\\> xhi \\>\\> yhi;\n\n### 3.3.2 isValid（）函数\n\n用于检查起始，终止位置合理性，是否越界，是否为墙，并且给相应的提示，如果不合法，就直接结束程序。\n\nbool isValid(vector\\<vector\\<int\\>\\> & map,int M,int N,int xlo,int ylo,int\nxhi,int yhi)  \n{  \nif (xlo \\< 0 \\|\\| xlo \\>= M \\|\\| ylo \\< 0 \\|\\| ylo \\>= N)  \n{  \ncout \\<\\< \"起始路径就不在迷宫里面啊,大哥\";  \n}  \nelse if (map[xlo][ylo] == 1)//输入为墙,搞什么  \n{  \ncout \\<\\< \"起始路径为墙,你让他怎么走?\";  \n}  \nelse if (xhi \\< 0 \\|\\| xhi \\>= M \\|\\| yhi \\< 0 \\|\\| yhi \\>= N)  \n{  \ncout \\<\\< \"终点就不在迷宫里面啊,大哥\";  \n}  \nelse if (map[xhi][yhi] == 1)//终点为墙,搞什么  \n{  \ncout \\<\\< \"终点为墙,你让他怎么到?\";  \n}  \nelse  \n{  \nreturn true;  \n}  \nreturn false;  \n}\n\n### 3.3.3 dfs()函数初步实现\n\n从xlo,ylo开始，在没有找到xhi,yhi之前，不懂调用递归往四个方向的，没有标记为访问过的，没有越界的，是路径的位置走，而且是深度优先搜索，即如果进入了一个方向，则直到找完这个方向的所有路径后，才走另一个方向。\n\n初步实现的关键地方的代码（因为是直接截取完整程序，所以参数会带上了之后所用到的栈）：\n\nmarked[i][j] = true;\n\nif(i-1\\>=0 && map[i-1][j]==0 && !marked[i-1][j])  \n{  \ndfs(map, marked,path, i - 1, j, xhi, yhi, hasPath);  \n}  \nif(i+1\\<M && map[i+1][j]==0 && !marked[i+1][j])  \n{  \ndfs(map, marked,path, i+1, j, xhi, yhi, hasPath);  \n}  \nif(j+1\\<N && map[i][j+1]==0 && !marked[i][j+1])  \n{  \ndfs(map, marked,path, i, j+1, xhi, yhi, hasPath);  \n}  \nif(j-1\\>=0 && map[i][j-1]==0 && !marked[i][j-1])  \n{  \ndfs(map, marked,path, i, j-1, xhi, yhi, hasPath);  \n}\n\n### 3.3.4 dfs完整实现\n\n初步实现后，为了增加显示迷宫路径功能以及没有路径时给出提示的功能，还用到了一个自己实现的栈，以及bool类型的hasPath,用于当没有路径时才输出没有路径的提示信息。\n\n每递归调用一次，就将这个坐标加入栈中（用pair存储了坐标）。而当四个if都没进入时，即无路可走时，就弹出栈顶元素，这意味着，这个栈总是存储着当前能走的路径。\n\npath.push(make_pair(i, j));\n\n//四个if，不写出来了\n\n//无路可走时,弹栈  \npath.pop();\n\n然后，如果递归到了终点位置，即有路可走，就将hasPath设为true，并且用一个栈存储当前栈的反转（这样才是从入口到出口）。并且还将map在这个路径上的元素设置为2，即为路径。\n\n最后，输出迷宫，迷宫上的路径用（X）表示，并且在下方通过遍历那个反转栈，输出路径坐标，从入口到出口。结束dfs（）函数。\n\nvoid dfs(vector\\<vector\\<int\\>\\> & map, vector\\<vector\\<bool\\>\\>&\nmarked,Stack\\<pair\\<int,int\\>\\>& path, int i, int j, int xhi,int yhi,bool &\nhasPath)  \n{  \nint M = map.size(), N = map[0].size();  \npath.push(make_pair(i, j));  \nmarked[i][j] = true;  \nif(i==xhi && j==yhi)  \n{  \nhasPath = true;  \nStack\\<pair\\<int, int\\>\\> reverse;  \nwhile(!path.empty())  \n{  \npair\\<int, int\\> p = path.top();  \npath.pop();  \nreverse.push(p);//反转的stack,用于输出路径  \nmap[p.first][p.second] = 2;  \n}  \n\ncout\\<\\<endl;  \ncout \\<\\< \" \";  \nfor (int i = 0; i \\< N; ++i)  \n{  \ncout \\<\\< i \\<\\< \"列 \";  \n}  \ncout\\<\\<endl;  \nfor (int i = 0; i \\< M; ++i)  \n{  \ncout \\<\\< i \\<\\< \"行 \";  \nfor (int j = 0; j \\< N; ++j)  \n{  \nif(map[i][j]==0)  \n{  \ncout \\<\\< \"0\";  \n}  \nelse if(map[i][j]==2)  \n{  \ncout \\<\\< \"X\";  \n}  \nelse  \n{  \ncout \\<\\< \"\\#\";  \n}  \ncout \\<\\< \" \";  \n}  \ncout\\<\\<endl;  \n}  \n\ncout\\<\\<endl\\<\\<\"迷宫路径为:\"\\<\\<endl;  \nwhile(!reverse.empty())  \n{  \npair\\<int, int\\> p = reverse.top();  \nreverse.pop();  \nif(p.first==xhi && p.second==yhi)  \ncout\\<\\<\"(\" \\<\\< p.first \\<\\< \",\" \\<\\< p.second\\<\\<\")\"\\<\\<endl;  \nelse  \ncout \\<\\< \"(\" \\<\\< p.first \\<\\< \",\" \\<\\< p.second \\<\\< \")-\\>\";  \n}  \n}  \nif(i-1\\>=0 && map[i-1][j]==0 && !marked[i-1][j])  \n{  \ndfs(map, marked,path, i - 1, j, xhi, yhi, hasPath);  \n}  \nif(i+1\\<M && map[i+1][j]==0 && !marked[i+1][j])  \n{  \ndfs(map, marked,path, i+1, j, xhi, yhi, hasPath);  \n}  \nif(j+1\\<N && map[i][j+1]==0 && !marked[i][j+1])  \n{  \ndfs(map, marked,path, i, j+1, xhi, yhi, hasPath);  \n}  \nif(j-1\\>=0 && map[i][j-1]==0 && !marked[i][j-1])  \n{  \ndfs(map, marked,path, i, j-1, xhi, yhi, hasPath);  \n}  \n//无路可走时,弹栈  \npath.pop();  \n}\n\n# 4 测试\n\n## 4.1 功能测试\n\n### 4.1.1测试1\n\n**测试用例**：\n\n7 7\n\n>   0 0 1 1 1 1 1\n\n>   1 0 0 0 1 0 1\n\n>   0 0 1 0 1 1 1\n\n>   1 0 0 1 1 1 1\n\n>   0 0 1 1 0 0 0\n\n>   1 0 0 0 0 1 0\n\n>   1 1 0 1 0 1 0\n\n>   0 0 6 6\n\n**实验结果**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/7348e9a6be66cbb7fbb596e3ad243881.png)\n\n### 4.1.2 测试2\n\n**测试用例：**\n\n7 7\n\n>   0 0 1 1 1 1 1\n\n>   1 0 0 0 1 0 1\n\n>   0 0 1 0 1 1 1\n\n>   1 0 0 1 1 1 1\n\n>   0 0 1 1 0 0 0\n\n>   1 0 0 0 0 1 0\n\n>   1 1 0 1 0 1 0\n\n>   1 2 6 2\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/808db98d12e8b446fd6b095419ba6765.png)\n\n### 4.1.3 测试3\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n1 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n0 0 3 8\n\n**实验结果：**\n\n**(从测试用例可以看出来,虽然找到了路径,但是不是最短路径)**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8e9fa6a0af7301967df044342347f881.png)\n\n## 4.2 边界测试\n\n### 4.2.1 没有从入口到出口的路径\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n0 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n0 0 6 0\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d3baf4ae3fc3dae87b3bca15183b5cf.png)\n\n### 4.2.2 入口不在数组中或者为墙\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n0 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n0 2 1 3\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/b217508045085f7f3ecf5d4c50c16dc7.png)\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n0 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n\\-1 -1 1 3\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/60fe345e77364143f9f493368d15f0b1.png)\n\n### 4.2.3 出口不在迷宫中或者出口为墙\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n0 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n0 0 -1 -1\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d10c0f20bb9d26b7761e786e3effd05f.png)\n\n**测试用例：**\n\n8 9\n\n0 0 1 1 1 1 1 0 1\n\n0 0 0 0 0 0 1 0 1\n\n0 0 1 0 1 0 0 0 0\n\n1 0 0 1 1 1 1 1 0\n\n0 0 1 1 0 0 0 1 0\n\n1 0 0 0 0 1 0 1 1\n\n0 1 0 1 0 1 0 1 1\n\n1 0 1 1 0 1 0 1 1\n\n0 0 7 8\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/53b62b30d753de7a459fb3a75797283c.png)\n","slug":"项目笔记/dataStructureProjects/勇闯迷宫游戏","published":1,"updated":"2020-11-12T11:57:30.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73x00oqjotp57895sve","content":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  勇闯迷宫游戏</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目简介\"><a href=\"#1-1-项目简介\" class=\"headerlink\" title=\"1.1 项目简介\"></a>1.1 项目简介</h2><p>迷宫只有两个门，一个门叫入口，另一个门叫出口。一个骑士骑马从入口进入迷宫，迷宫设置很多障碍，骑士需要在迷宫中寻找通路以到达出口。</p>\n<h2 id=\"1-2-功能要求\"><a href=\"#1-2-功能要求\" class=\"headerlink\" title=\"1.2 功能要求\"></a>1.2 功能要求</h2><p>迷宫问题的求解过程可以采用回溯法即在一定的约束条件下试探地搜索前进，若前进中受阻，则及时回头纠正错误另择通路继续搜索的方法。从入口出发，按某一方向向前探索，若能走通，即某处可达，则到达新点，否则探索下一个方向；若所有的方向均没有通路，则沿原路返回前一点，换下一个方向再继续试探，直到所有可能的道路都探索到，或找到一条通路，或无路可走又返回入口点。在求解过程中，为了保证在达到某一个点后不能向前继续行走时，能正确返回前一个以便从下一个方向向前试探，则需要在试探过程中保存所能够达到的每个点的下标以及该点前进的方向，当找到出口时试探过程就结束了。</p>\n<p>实际就是一个深度优先搜索,只不过不是在图中,而是在数组中,所有只要注意数组边界就好。同时，需要存储迷宫的路径，所以还需要一个栈。</p>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-Node设计\"><a href=\"#2-1-Node设计\" class=\"headerlink\" title=\"2.1 Node设计\"></a>2.1 Node设计</h2><p>Node节点和之前的类似,它保存一个模板类型的元素value,并且有一个指针next指向下一个元素,都是public的,以便于访问。</p>\n<h2 id=\"2-2-Stack设计\"><a href=\"#2-2-Stack设计\" class=\"headerlink\" title=\"2.2 Stack设计\"></a>2.2 Stack设计</h2><p>底层存储Node类头节点以及栈的元素个数N。为外界提供公有函数push（），pop（），top（），empty（）。提供栈的基本功能。</p>\n<h2 id=\"2-3-主程序设计\"><a href=\"#2-3-主程序设计\" class=\"headerlink\" title=\"2.3 主程序设计\"></a>2.3 主程序设计</h2><p>由用户输入迷宫的规模以及迷宫具体地形，再让用户输入起始位置及目标位置。并且程序判断位置是否合理。展示迷宫原来的样子，再通过dfs（）递归寻找出路，并且用一个栈存储路径，如果找到了从栈中取出路径（颠倒一次栈），如果没找到给出没有路径的提示。</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-Node类实现\"><a href=\"#3-1-Node类实现\" class=\"headerlink\" title=\"3.1 Node类实现\"></a>3.1 Node类实现</h2><p>template &lt;class T&gt; class Node<br>{<br>public:  </p>\n<p>Node(const T &amp; value, Node&lt;T&gt; *next= nullptr) : value(value), next(next) {}<br>Node(Node&lt;T&gt; *next= nullptr) : next(next) {}  </p>\n<p>T value;<br>Node&lt;T&gt; *next;<br>};</p>\n<h2 id=\"3-2-Stack类实现\"><a href=\"#3-2-Stack类实现\" class=\"headerlink\" title=\"3.2 Stack类实现\"></a>3.2 Stack类实现</h2><h3 id=\"3-2-1-push功能实现\"><a href=\"#3-2-1-push功能实现\" class=\"headerlink\" title=\"3.2.1 push功能实现\"></a>3.2.1 push功能实现</h3><p>新加入一个Node元素，并且将之指向原来的头节点，原来的头节点指向现在的头节点，将存储的元素个数N+1。</p>\n<p>void push(T t)<br>{<br>Node&lt;T&gt; *oldFirst = first;<br>first = new Node&lt;T&gt;(t, oldFirst);<br>++N;<br>}</p>\n<h3 id=\"3-2-2-pop功能实现\"><a href=\"#3-2-2-pop功能实现\" class=\"headerlink\" title=\"3.2.2 pop功能实现\"></a>3.2.2 pop功能实现</h3><p>判断是否为空，不为空就让头节点指向下一个元素，然后delete之前的元素，释放内存，–N</p>\n<p>void pop()<br>{<br>if(empty())<br>return;<br>Node&lt;T&gt; *temp = first;<br>first = first-&gt;next;<br>delete temp;<br>–N;<br>}</p>\n<h3 id=\"3-2-3-empty，top功能实现\"><a href=\"#3-2-3-empty，top功能实现\" class=\"headerlink\" title=\"3.2.3 empty，top功能实现\"></a>3.2.3 empty，top功能实现</h3><p>bool empty()<br>{<br>return N==0;<br>}  </p>\n<p>T top()<br>{<br>return first-&gt;value;<br>}</p>\n<h2 id=\"3-3-主函数功能的实现\"><a href=\"#3-3-主函数功能的实现\" class=\"headerlink\" title=\"3.3 主函数功能的实现\"></a>3.3 主函数功能的实现</h2><h3 id=\"3-3-1-输入的处理\"><a href=\"#3-3-1-输入的处理\" class=\"headerlink\" title=\"3.3.1 输入的处理\"></a>3.3.1 输入的处理</h3><p>先根据输入,赋值给M,N,然后创建M*N大小的二维数组,再根据输入的内容创建迷宫地形。</p>\n<p>int M,N;<br>cout &lt;&lt;<br>“先输入两个正整数,代表迷宫大小M*N;再输入M*N正整数(0,1代表迷宫的路和墙):”;<br>cin &gt;&gt; M &gt;&gt; N;<br>vector&lt;vector&lt;int&gt;&gt; map(M,<br>vector&lt;int&gt;(N,1));//默认设置全为墙,当然没什么用,因为是用户进行输入<br>vector&lt;vector&lt;bool&gt;&gt; marked(M, vector&lt;bool&gt;(N, false));//默认为没访问过的</p>\n<p>/*<br>* 0 0 路<br>* 1 # 墙<br>* 2 x 走的路径<br>*/<br>for (int i = 0; i &lt; M; i++)<br>{<br>for (int j = 0; j &lt; N; j++)<br>{<br>int mapType;<br>cin &gt;&gt; mapType;<br>map[i][j] = mapType;<br>}<br>}</p>\n<p>然后输入起始，终止位置</p>\n<p>cout &lt;&lt; “输入起始坐标和结束坐标(xlo, ylo), (xhi, yhi):”;<br>int xlo, ylo, xhi, yhi;<br>cin &gt;&gt; xlo &gt;&gt; ylo &gt;&gt; xhi &gt;&gt; yhi;</p>\n<h3 id=\"3-3-2-isValid（）函数\"><a href=\"#3-3-2-isValid（）函数\" class=\"headerlink\" title=\"3.3.2 isValid（）函数\"></a>3.3.2 isValid（）函数</h3><p>用于检查起始，终止位置合理性，是否越界，是否为墙，并且给相应的提示，如果不合法，就直接结束程序。</p>\n<p>bool isValid(vector&lt;vector&lt;int&gt;&gt; &amp; map,int M,int N,int xlo,int ylo,int<br>xhi,int yhi)<br>{<br>if (xlo &lt; 0 || xlo &gt;= M || ylo &lt; 0 || ylo &gt;= N)<br>{<br>cout &lt;&lt; “起始路径就不在迷宫里面啊,大哥”;<br>}<br>else if (map[xlo][ylo] == 1)//输入为墙,搞什么<br>{<br>cout &lt;&lt; “起始路径为墙,你让他怎么走?”;<br>}<br>else if (xhi &lt; 0 || xhi &gt;= M || yhi &lt; 0 || yhi &gt;= N)<br>{<br>cout &lt;&lt; “终点就不在迷宫里面啊,大哥”;<br>}<br>else if (map[xhi][yhi] == 1)//终点为墙,搞什么<br>{<br>cout &lt;&lt; “终点为墙,你让他怎么到?”;<br>}<br>else<br>{<br>return true;<br>}<br>return false;<br>}</p>\n<h3 id=\"3-3-3-dfs-函数初步实现\"><a href=\"#3-3-3-dfs-函数初步实现\" class=\"headerlink\" title=\"3.3.3 dfs()函数初步实现\"></a>3.3.3 dfs()函数初步实现</h3><p>从xlo,ylo开始，在没有找到xhi,yhi之前，不懂调用递归往四个方向的，没有标记为访问过的，没有越界的，是路径的位置走，而且是深度优先搜索，即如果进入了一个方向，则直到找完这个方向的所有路径后，才走另一个方向。</p>\n<p>初步实现的关键地方的代码（因为是直接截取完整程序，所以参数会带上了之后所用到的栈）：</p>\n<p>marked[i][j] = true;</p>\n<p>if(i-1&gt;=0 &amp;&amp; map[i-1][j]==0 &amp;&amp; !marked[i-1][j])<br>{<br>dfs(map, marked,path, i - 1, j, xhi, yhi, hasPath);<br>}<br>if(i+1&lt;M &amp;&amp; map[i+1][j]==0 &amp;&amp; !marked[i+1][j])<br>{<br>dfs(map, marked,path, i+1, j, xhi, yhi, hasPath);<br>}<br>if(j+1&lt;N &amp;&amp; map[i][j+1]==0 &amp;&amp; !marked[i][j+1])<br>{<br>dfs(map, marked,path, i, j+1, xhi, yhi, hasPath);<br>}<br>if(j-1&gt;=0 &amp;&amp; map[i][j-1]==0 &amp;&amp; !marked[i][j-1])<br>{<br>dfs(map, marked,path, i, j-1, xhi, yhi, hasPath);<br>}</p>\n<h3 id=\"3-3-4-dfs完整实现\"><a href=\"#3-3-4-dfs完整实现\" class=\"headerlink\" title=\"3.3.4 dfs完整实现\"></a>3.3.4 dfs完整实现</h3><p>初步实现后，为了增加显示迷宫路径功能以及没有路径时给出提示的功能，还用到了一个自己实现的栈，以及bool类型的hasPath,用于当没有路径时才输出没有路径的提示信息。</p>\n<p>每递归调用一次，就将这个坐标加入栈中（用pair存储了坐标）。而当四个if都没进入时，即无路可走时，就弹出栈顶元素，这意味着，这个栈总是存储着当前能走的路径。</p>\n<p>path.push(make_pair(i, j));</p>\n<p>//四个if，不写出来了</p>\n<p>//无路可走时,弹栈<br>path.pop();</p>\n<p>然后，如果递归到了终点位置，即有路可走，就将hasPath设为true，并且用一个栈存储当前栈的反转（这样才是从入口到出口）。并且还将map在这个路径上的元素设置为2，即为路径。</p>\n<p>最后，输出迷宫，迷宫上的路径用（X）表示，并且在下方通过遍历那个反转栈，输出路径坐标，从入口到出口。结束dfs（）函数。</p>\n<p>void dfs(vector&lt;vector&lt;int&gt;&gt; &amp; map, vector&lt;vector&lt;bool&gt;&gt;&amp;<br>marked,Stack&lt;pair&lt;int,int&gt;&gt;&amp; path, int i, int j, int xhi,int yhi,bool &amp;<br>hasPath)<br>{<br>int M = map.size(), N = map[0].size();<br>path.push(make_pair(i, j));<br>marked[i][j] = true;<br>if(i==xhi &amp;&amp; j==yhi)<br>{<br>hasPath = true;<br>Stack&lt;pair&lt;int, int&gt;&gt; reverse;<br>while(!path.empty())<br>{<br>pair&lt;int, int&gt; p = path.top();<br>path.pop();<br>reverse.push(p);//反转的stack,用于输出路径<br>map[p.first][p.second] = 2;<br>}  </p>\n<p>cout&lt;&lt;endl;<br>cout &lt;&lt; “ “;<br>for (int i = 0; i &lt; N; ++i)<br>{<br>cout &lt;&lt; i &lt;&lt; “列 “;<br>}<br>cout&lt;&lt;endl;<br>for (int i = 0; i &lt; M; ++i)<br>{<br>cout &lt;&lt; i &lt;&lt; “行 “;<br>for (int j = 0; j &lt; N; ++j)<br>{<br>if(map[i][j]==0)<br>{<br>cout &lt;&lt; “0”;<br>}<br>else if(map[i][j]==2)<br>{<br>cout &lt;&lt; “X”;<br>}<br>else<br>{<br>cout &lt;&lt; “#“;<br>}<br>cout &lt;&lt; “ “;<br>}<br>cout&lt;&lt;endl;<br>}  </p>\n<p>cout&lt;&lt;endl&lt;&lt;“迷宫路径为:”&lt;&lt;endl;<br>while(!reverse.empty())<br>{<br>pair&lt;int, int&gt; p = reverse.top();<br>reverse.pop();<br>if(p.first==xhi &amp;&amp; p.second==yhi)<br>cout&lt;&lt;“(“ &lt;&lt; p.first &lt;&lt; “,” &lt;&lt; p.second&lt;&lt;“)”&lt;&lt;endl;<br>else<br>cout &lt;&lt; “(“ &lt;&lt; p.first &lt;&lt; “,” &lt;&lt; p.second &lt;&lt; “)-&gt;“;<br>}<br>}<br>if(i-1&gt;=0 &amp;&amp; map[i-1][j]==0 &amp;&amp; !marked[i-1][j])<br>{<br>dfs(map, marked,path, i - 1, j, xhi, yhi, hasPath);<br>}<br>if(i+1&lt;M &amp;&amp; map[i+1][j]==0 &amp;&amp; !marked[i+1][j])<br>{<br>dfs(map, marked,path, i+1, j, xhi, yhi, hasPath);<br>}<br>if(j+1&lt;N &amp;&amp; map[i][j+1]==0 &amp;&amp; !marked[i][j+1])<br>{<br>dfs(map, marked,path, i, j+1, xhi, yhi, hasPath);<br>}<br>if(j-1&gt;=0 &amp;&amp; map[i][j-1]==0 &amp;&amp; !marked[i][j-1])<br>{<br>dfs(map, marked,path, i, j-1, xhi, yhi, hasPath);<br>}<br>//无路可走时,弹栈<br>path.pop();<br>}</p>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><h2 id=\"4-1-功能测试\"><a href=\"#4-1-功能测试\" class=\"headerlink\" title=\"4.1 功能测试\"></a>4.1 功能测试</h2><h3 id=\"4-1-1测试1\"><a href=\"#4-1-1测试1\" class=\"headerlink\" title=\"4.1.1测试1\"></a>4.1.1测试1</h3><p><strong>测试用例</strong>：</p>\n<p>7 7</p>\n<blockquote>\n<p>  0 0 1 1 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 0 1 0 1</p>\n</blockquote>\n<blockquote>\n<p>  0 0 1 0 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 1 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  0 0 1 1 0 0 0</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 0 0 1 0</p>\n</blockquote>\n<blockquote>\n<p>  1 1 0 1 0 1 0</p>\n</blockquote>\n<blockquote>\n<p>  0 0 6 6</p>\n</blockquote>\n<p><strong>实验结果</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7348e9a6be66cbb7fbb596e3ad243881.png\"></p>\n<h3 id=\"4-1-2-测试2\"><a href=\"#4-1-2-测试2\" class=\"headerlink\" title=\"4.1.2 测试2\"></a>4.1.2 测试2</h3><p><strong>测试用例：</strong></p>\n<p>7 7</p>\n<blockquote>\n<p>  0 0 1 1 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 0 1 0 1</p>\n</blockquote>\n<blockquote>\n<p>  0 0 1 0 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 1 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  0 0 1 1 0 0 0</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 0 0 1 0</p>\n</blockquote>\n<blockquote>\n<p>  1 1 0 1 0 1 0</p>\n</blockquote>\n<blockquote>\n<p>  1 2 6 2</p>\n</blockquote>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/808db98d12e8b446fd6b095419ba6765.png\"></p>\n<h3 id=\"4-1-3-测试3\"><a href=\"#4-1-3-测试3\" class=\"headerlink\" title=\"4.1.3 测试3\"></a>4.1.3 测试3</h3><p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>1 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>0 0 3 8</p>\n<p><strong>实验结果：</strong></p>\n<p><strong>(从测试用例可以看出来,虽然找到了路径,但是不是最短路径)</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8e9fa6a0af7301967df044342347f881.png\"></p>\n<h2 id=\"4-2-边界测试\"><a href=\"#4-2-边界测试\" class=\"headerlink\" title=\"4.2 边界测试\"></a>4.2 边界测试</h2><h3 id=\"4-2-1-没有从入口到出口的路径\"><a href=\"#4-2-1-没有从入口到出口的路径\" class=\"headerlink\" title=\"4.2.1 没有从入口到出口的路径\"></a>4.2.1 没有从入口到出口的路径</h3><p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>0 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>0 0 6 0</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d3baf4ae3fc3dae87b3bca15183b5cf.png\"></p>\n<h3 id=\"4-2-2-入口不在数组中或者为墙\"><a href=\"#4-2-2-入口不在数组中或者为墙\" class=\"headerlink\" title=\"4.2.2 入口不在数组中或者为墙\"></a>4.2.2 入口不在数组中或者为墙</h3><p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>0 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>0 2 1 3</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/b217508045085f7f3ecf5d4c50c16dc7.png\"></p>\n<p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>0 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>-1 -1 1 3</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/60fe345e77364143f9f493368d15f0b1.png\"></p>\n<h3 id=\"4-2-3-出口不在迷宫中或者出口为墙\"><a href=\"#4-2-3-出口不在迷宫中或者出口为墙\" class=\"headerlink\" title=\"4.2.3 出口不在迷宫中或者出口为墙\"></a>4.2.3 出口不在迷宫中或者出口为墙</h3><p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>0 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>0 0 -1 -1</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d10c0f20bb9d26b7761e786e3effd05f.png\"></p>\n<p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>0 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>0 0 7 8</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/53b62b30d753de7a459fb3a75797283c.png\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  勇闯迷宫游戏</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目简介\"><a href=\"#1-1-项目简介\" class=\"headerlink\" title=\"1.1 项目简介\"></a>1.1 项目简介</h2><p>迷宫只有两个门，一个门叫入口，另一个门叫出口。一个骑士骑马从入口进入迷宫，迷宫设置很多障碍，骑士需要在迷宫中寻找通路以到达出口。</p>\n<h2 id=\"1-2-功能要求\"><a href=\"#1-2-功能要求\" class=\"headerlink\" title=\"1.2 功能要求\"></a>1.2 功能要求</h2><p>迷宫问题的求解过程可以采用回溯法即在一定的约束条件下试探地搜索前进，若前进中受阻，则及时回头纠正错误另择通路继续搜索的方法。从入口出发，按某一方向向前探索，若能走通，即某处可达，则到达新点，否则探索下一个方向；若所有的方向均没有通路，则沿原路返回前一点，换下一个方向再继续试探，直到所有可能的道路都探索到，或找到一条通路，或无路可走又返回入口点。在求解过程中，为了保证在达到某一个点后不能向前继续行走时，能正确返回前一个以便从下一个方向向前试探，则需要在试探过程中保存所能够达到的每个点的下标以及该点前进的方向，当找到出口时试探过程就结束了。</p>\n<p>实际就是一个深度优先搜索,只不过不是在图中,而是在数组中,所有只要注意数组边界就好。同时，需要存储迷宫的路径，所以还需要一个栈。</p>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-Node设计\"><a href=\"#2-1-Node设计\" class=\"headerlink\" title=\"2.1 Node设计\"></a>2.1 Node设计</h2><p>Node节点和之前的类似,它保存一个模板类型的元素value,并且有一个指针next指向下一个元素,都是public的,以便于访问。</p>\n<h2 id=\"2-2-Stack设计\"><a href=\"#2-2-Stack设计\" class=\"headerlink\" title=\"2.2 Stack设计\"></a>2.2 Stack设计</h2><p>底层存储Node类头节点以及栈的元素个数N。为外界提供公有函数push（），pop（），top（），empty（）。提供栈的基本功能。</p>\n<h2 id=\"2-3-主程序设计\"><a href=\"#2-3-主程序设计\" class=\"headerlink\" title=\"2.3 主程序设计\"></a>2.3 主程序设计</h2><p>由用户输入迷宫的规模以及迷宫具体地形，再让用户输入起始位置及目标位置。并且程序判断位置是否合理。展示迷宫原来的样子，再通过dfs（）递归寻找出路，并且用一个栈存储路径，如果找到了从栈中取出路径（颠倒一次栈），如果没找到给出没有路径的提示。</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-Node类实现\"><a href=\"#3-1-Node类实现\" class=\"headerlink\" title=\"3.1 Node类实现\"></a>3.1 Node类实现</h2><p>template &lt;class T&gt; class Node<br>{<br>public:  </p>\n<p>Node(const T &amp; value, Node&lt;T&gt; *next= nullptr) : value(value), next(next) {}<br>Node(Node&lt;T&gt; *next= nullptr) : next(next) {}  </p>\n<p>T value;<br>Node&lt;T&gt; *next;<br>};</p>\n<h2 id=\"3-2-Stack类实现\"><a href=\"#3-2-Stack类实现\" class=\"headerlink\" title=\"3.2 Stack类实现\"></a>3.2 Stack类实现</h2><h3 id=\"3-2-1-push功能实现\"><a href=\"#3-2-1-push功能实现\" class=\"headerlink\" title=\"3.2.1 push功能实现\"></a>3.2.1 push功能实现</h3><p>新加入一个Node元素，并且将之指向原来的头节点，原来的头节点指向现在的头节点，将存储的元素个数N+1。</p>\n<p>void push(T t)<br>{<br>Node&lt;T&gt; *oldFirst = first;<br>first = new Node&lt;T&gt;(t, oldFirst);<br>++N;<br>}</p>\n<h3 id=\"3-2-2-pop功能实现\"><a href=\"#3-2-2-pop功能实现\" class=\"headerlink\" title=\"3.2.2 pop功能实现\"></a>3.2.2 pop功能实现</h3><p>判断是否为空，不为空就让头节点指向下一个元素，然后delete之前的元素，释放内存，–N</p>\n<p>void pop()<br>{<br>if(empty())<br>return;<br>Node&lt;T&gt; *temp = first;<br>first = first-&gt;next;<br>delete temp;<br>–N;<br>}</p>\n<h3 id=\"3-2-3-empty，top功能实现\"><a href=\"#3-2-3-empty，top功能实现\" class=\"headerlink\" title=\"3.2.3 empty，top功能实现\"></a>3.2.3 empty，top功能实现</h3><p>bool empty()<br>{<br>return N==0;<br>}  </p>\n<p>T top()<br>{<br>return first-&gt;value;<br>}</p>\n<h2 id=\"3-3-主函数功能的实现\"><a href=\"#3-3-主函数功能的实现\" class=\"headerlink\" title=\"3.3 主函数功能的实现\"></a>3.3 主函数功能的实现</h2><h3 id=\"3-3-1-输入的处理\"><a href=\"#3-3-1-输入的处理\" class=\"headerlink\" title=\"3.3.1 输入的处理\"></a>3.3.1 输入的处理</h3><p>先根据输入,赋值给M,N,然后创建M*N大小的二维数组,再根据输入的内容创建迷宫地形。</p>\n<p>int M,N;<br>cout &lt;&lt;<br>“先输入两个正整数,代表迷宫大小M*N;再输入M*N正整数(0,1代表迷宫的路和墙):”;<br>cin &gt;&gt; M &gt;&gt; N;<br>vector&lt;vector&lt;int&gt;&gt; map(M,<br>vector&lt;int&gt;(N,1));//默认设置全为墙,当然没什么用,因为是用户进行输入<br>vector&lt;vector&lt;bool&gt;&gt; marked(M, vector&lt;bool&gt;(N, false));//默认为没访问过的</p>\n<p>/*<br>* 0 0 路<br>* 1 # 墙<br>* 2 x 走的路径<br>*/<br>for (int i = 0; i &lt; M; i++)<br>{<br>for (int j = 0; j &lt; N; j++)<br>{<br>int mapType;<br>cin &gt;&gt; mapType;<br>map[i][j] = mapType;<br>}<br>}</p>\n<p>然后输入起始，终止位置</p>\n<p>cout &lt;&lt; “输入起始坐标和结束坐标(xlo, ylo), (xhi, yhi):”;<br>int xlo, ylo, xhi, yhi;<br>cin &gt;&gt; xlo &gt;&gt; ylo &gt;&gt; xhi &gt;&gt; yhi;</p>\n<h3 id=\"3-3-2-isValid（）函数\"><a href=\"#3-3-2-isValid（）函数\" class=\"headerlink\" title=\"3.3.2 isValid（）函数\"></a>3.3.2 isValid（）函数</h3><p>用于检查起始，终止位置合理性，是否越界，是否为墙，并且给相应的提示，如果不合法，就直接结束程序。</p>\n<p>bool isValid(vector&lt;vector&lt;int&gt;&gt; &amp; map,int M,int N,int xlo,int ylo,int<br>xhi,int yhi)<br>{<br>if (xlo &lt; 0 || xlo &gt;= M || ylo &lt; 0 || ylo &gt;= N)<br>{<br>cout &lt;&lt; “起始路径就不在迷宫里面啊,大哥”;<br>}<br>else if (map[xlo][ylo] == 1)//输入为墙,搞什么<br>{<br>cout &lt;&lt; “起始路径为墙,你让他怎么走?”;<br>}<br>else if (xhi &lt; 0 || xhi &gt;= M || yhi &lt; 0 || yhi &gt;= N)<br>{<br>cout &lt;&lt; “终点就不在迷宫里面啊,大哥”;<br>}<br>else if (map[xhi][yhi] == 1)//终点为墙,搞什么<br>{<br>cout &lt;&lt; “终点为墙,你让他怎么到?”;<br>}<br>else<br>{<br>return true;<br>}<br>return false;<br>}</p>\n<h3 id=\"3-3-3-dfs-函数初步实现\"><a href=\"#3-3-3-dfs-函数初步实现\" class=\"headerlink\" title=\"3.3.3 dfs()函数初步实现\"></a>3.3.3 dfs()函数初步实现</h3><p>从xlo,ylo开始，在没有找到xhi,yhi之前，不懂调用递归往四个方向的，没有标记为访问过的，没有越界的，是路径的位置走，而且是深度优先搜索，即如果进入了一个方向，则直到找完这个方向的所有路径后，才走另一个方向。</p>\n<p>初步实现的关键地方的代码（因为是直接截取完整程序，所以参数会带上了之后所用到的栈）：</p>\n<p>marked[i][j] = true;</p>\n<p>if(i-1&gt;=0 &amp;&amp; map[i-1][j]==0 &amp;&amp; !marked[i-1][j])<br>{<br>dfs(map, marked,path, i - 1, j, xhi, yhi, hasPath);<br>}<br>if(i+1&lt;M &amp;&amp; map[i+1][j]==0 &amp;&amp; !marked[i+1][j])<br>{<br>dfs(map, marked,path, i+1, j, xhi, yhi, hasPath);<br>}<br>if(j+1&lt;N &amp;&amp; map[i][j+1]==0 &amp;&amp; !marked[i][j+1])<br>{<br>dfs(map, marked,path, i, j+1, xhi, yhi, hasPath);<br>}<br>if(j-1&gt;=0 &amp;&amp; map[i][j-1]==0 &amp;&amp; !marked[i][j-1])<br>{<br>dfs(map, marked,path, i, j-1, xhi, yhi, hasPath);<br>}</p>\n<h3 id=\"3-3-4-dfs完整实现\"><a href=\"#3-3-4-dfs完整实现\" class=\"headerlink\" title=\"3.3.4 dfs完整实现\"></a>3.3.4 dfs完整实现</h3><p>初步实现后，为了增加显示迷宫路径功能以及没有路径时给出提示的功能，还用到了一个自己实现的栈，以及bool类型的hasPath,用于当没有路径时才输出没有路径的提示信息。</p>\n<p>每递归调用一次，就将这个坐标加入栈中（用pair存储了坐标）。而当四个if都没进入时，即无路可走时，就弹出栈顶元素，这意味着，这个栈总是存储着当前能走的路径。</p>\n<p>path.push(make_pair(i, j));</p>\n<p>//四个if，不写出来了</p>\n<p>//无路可走时,弹栈<br>path.pop();</p>\n<p>然后，如果递归到了终点位置，即有路可走，就将hasPath设为true，并且用一个栈存储当前栈的反转（这样才是从入口到出口）。并且还将map在这个路径上的元素设置为2，即为路径。</p>\n<p>最后，输出迷宫，迷宫上的路径用（X）表示，并且在下方通过遍历那个反转栈，输出路径坐标，从入口到出口。结束dfs（）函数。</p>\n<p>void dfs(vector&lt;vector&lt;int&gt;&gt; &amp; map, vector&lt;vector&lt;bool&gt;&gt;&amp;<br>marked,Stack&lt;pair&lt;int,int&gt;&gt;&amp; path, int i, int j, int xhi,int yhi,bool &amp;<br>hasPath)<br>{<br>int M = map.size(), N = map[0].size();<br>path.push(make_pair(i, j));<br>marked[i][j] = true;<br>if(i==xhi &amp;&amp; j==yhi)<br>{<br>hasPath = true;<br>Stack&lt;pair&lt;int, int&gt;&gt; reverse;<br>while(!path.empty())<br>{<br>pair&lt;int, int&gt; p = path.top();<br>path.pop();<br>reverse.push(p);//反转的stack,用于输出路径<br>map[p.first][p.second] = 2;<br>}  </p>\n<p>cout&lt;&lt;endl;<br>cout &lt;&lt; “ “;<br>for (int i = 0; i &lt; N; ++i)<br>{<br>cout &lt;&lt; i &lt;&lt; “列 “;<br>}<br>cout&lt;&lt;endl;<br>for (int i = 0; i &lt; M; ++i)<br>{<br>cout &lt;&lt; i &lt;&lt; “行 “;<br>for (int j = 0; j &lt; N; ++j)<br>{<br>if(map[i][j]==0)<br>{<br>cout &lt;&lt; “0”;<br>}<br>else if(map[i][j]==2)<br>{<br>cout &lt;&lt; “X”;<br>}<br>else<br>{<br>cout &lt;&lt; “#“;<br>}<br>cout &lt;&lt; “ “;<br>}<br>cout&lt;&lt;endl;<br>}  </p>\n<p>cout&lt;&lt;endl&lt;&lt;“迷宫路径为:”&lt;&lt;endl;<br>while(!reverse.empty())<br>{<br>pair&lt;int, int&gt; p = reverse.top();<br>reverse.pop();<br>if(p.first==xhi &amp;&amp; p.second==yhi)<br>cout&lt;&lt;“(“ &lt;&lt; p.first &lt;&lt; “,” &lt;&lt; p.second&lt;&lt;“)”&lt;&lt;endl;<br>else<br>cout &lt;&lt; “(“ &lt;&lt; p.first &lt;&lt; “,” &lt;&lt; p.second &lt;&lt; “)-&gt;“;<br>}<br>}<br>if(i-1&gt;=0 &amp;&amp; map[i-1][j]==0 &amp;&amp; !marked[i-1][j])<br>{<br>dfs(map, marked,path, i - 1, j, xhi, yhi, hasPath);<br>}<br>if(i+1&lt;M &amp;&amp; map[i+1][j]==0 &amp;&amp; !marked[i+1][j])<br>{<br>dfs(map, marked,path, i+1, j, xhi, yhi, hasPath);<br>}<br>if(j+1&lt;N &amp;&amp; map[i][j+1]==0 &amp;&amp; !marked[i][j+1])<br>{<br>dfs(map, marked,path, i, j+1, xhi, yhi, hasPath);<br>}<br>if(j-1&gt;=0 &amp;&amp; map[i][j-1]==0 &amp;&amp; !marked[i][j-1])<br>{<br>dfs(map, marked,path, i, j-1, xhi, yhi, hasPath);<br>}<br>//无路可走时,弹栈<br>path.pop();<br>}</p>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><h2 id=\"4-1-功能测试\"><a href=\"#4-1-功能测试\" class=\"headerlink\" title=\"4.1 功能测试\"></a>4.1 功能测试</h2><h3 id=\"4-1-1测试1\"><a href=\"#4-1-1测试1\" class=\"headerlink\" title=\"4.1.1测试1\"></a>4.1.1测试1</h3><p><strong>测试用例</strong>：</p>\n<p>7 7</p>\n<blockquote>\n<p>  0 0 1 1 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 0 1 0 1</p>\n</blockquote>\n<blockquote>\n<p>  0 0 1 0 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 1 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  0 0 1 1 0 0 0</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 0 0 1 0</p>\n</blockquote>\n<blockquote>\n<p>  1 1 0 1 0 1 0</p>\n</blockquote>\n<blockquote>\n<p>  0 0 6 6</p>\n</blockquote>\n<p><strong>实验结果</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/7348e9a6be66cbb7fbb596e3ad243881.png\"></p>\n<h3 id=\"4-1-2-测试2\"><a href=\"#4-1-2-测试2\" class=\"headerlink\" title=\"4.1.2 测试2\"></a>4.1.2 测试2</h3><p><strong>测试用例：</strong></p>\n<p>7 7</p>\n<blockquote>\n<p>  0 0 1 1 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 0 1 0 1</p>\n</blockquote>\n<blockquote>\n<p>  0 0 1 0 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 1 1 1 1</p>\n</blockquote>\n<blockquote>\n<p>  0 0 1 1 0 0 0</p>\n</blockquote>\n<blockquote>\n<p>  1 0 0 0 0 1 0</p>\n</blockquote>\n<blockquote>\n<p>  1 1 0 1 0 1 0</p>\n</blockquote>\n<blockquote>\n<p>  1 2 6 2</p>\n</blockquote>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/808db98d12e8b446fd6b095419ba6765.png\"></p>\n<h3 id=\"4-1-3-测试3\"><a href=\"#4-1-3-测试3\" class=\"headerlink\" title=\"4.1.3 测试3\"></a>4.1.3 测试3</h3><p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>1 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>0 0 3 8</p>\n<p><strong>实验结果：</strong></p>\n<p><strong>(从测试用例可以看出来,虽然找到了路径,但是不是最短路径)</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8e9fa6a0af7301967df044342347f881.png\"></p>\n<h2 id=\"4-2-边界测试\"><a href=\"#4-2-边界测试\" class=\"headerlink\" title=\"4.2 边界测试\"></a>4.2 边界测试</h2><h3 id=\"4-2-1-没有从入口到出口的路径\"><a href=\"#4-2-1-没有从入口到出口的路径\" class=\"headerlink\" title=\"4.2.1 没有从入口到出口的路径\"></a>4.2.1 没有从入口到出口的路径</h3><p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>0 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>0 0 6 0</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1d3baf4ae3fc3dae87b3bca15183b5cf.png\"></p>\n<h3 id=\"4-2-2-入口不在数组中或者为墙\"><a href=\"#4-2-2-入口不在数组中或者为墙\" class=\"headerlink\" title=\"4.2.2 入口不在数组中或者为墙\"></a>4.2.2 入口不在数组中或者为墙</h3><p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>0 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>0 2 1 3</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/b217508045085f7f3ecf5d4c50c16dc7.png\"></p>\n<p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>0 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>-1 -1 1 3</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/60fe345e77364143f9f493368d15f0b1.png\"></p>\n<h3 id=\"4-2-3-出口不在迷宫中或者出口为墙\"><a href=\"#4-2-3-出口不在迷宫中或者出口为墙\" class=\"headerlink\" title=\"4.2.3 出口不在迷宫中或者出口为墙\"></a>4.2.3 出口不在迷宫中或者出口为墙</h3><p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>0 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>0 0 -1 -1</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d10c0f20bb9d26b7761e786e3effd05f.png\"></p>\n<p><strong>测试用例：</strong></p>\n<p>8 9</p>\n<p>0 0 1 1 1 1 1 0 1</p>\n<p>0 0 0 0 0 0 1 0 1</p>\n<p>0 0 1 0 1 0 0 0 0</p>\n<p>1 0 0 1 1 1 1 1 0</p>\n<p>0 0 1 1 0 0 0 1 0</p>\n<p>1 0 0 0 0 1 0 1 1</p>\n<p>0 1 0 1 0 1 0 1 1</p>\n<p>1 0 1 1 0 1 0 1 1</p>\n<p>0 0 7 8</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/53b62b30d753de7a459fb3a75797283c.png\"></p>\n"},{"title":"数据结构项目-------家谱管理系统","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习数据结构项目--家谱管理系统所写的文档,主要是特殊的链表.","abbrlink":"629471e8","date":"2020-01-19T16:00:00.000Z","_content":"\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n\n>   家谱管理系统\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目简介\n\n家谱是一种以表谱形式，记载一个以血缘关系为主体的家族世袭繁衍和重要任务事迹的特殊图书体裁。家谱是中国特有的文化遗产，是中华民族的三大文献（国史，地志，族谱）之一，属于珍贵的人文资料，对于历史学，民俗学，人口学，社会学和经济学的深入研究，均有其不可替代的独特功能。本项目兑对家谱管理进行简单的模拟，以实现查看祖先和子孙个人信息，插入家族成员，删除家族成员的功能。\n\n## 1.2 功能要求\n\n本项目的实质是完成兑家谱成员信息的建立，查找，插入，修改，删除等功能，可以首先定义家族成员数据结构，然后将每个功能作为一个成员函数来完成对数据的操作，最后完成主函数以验证各个函数功能并得到运行结果。\n\n# 2 设计\n\n## 2.1 Node类设计\n\nNode类是一个模板类,存储一个T类型的值和两个指针,分别是代表指向兄弟节点的next指针和指向自己子节点的link指针。\n\n## 2.2 LinkedList类设计\n\n首先，LinkedList依旧是模板类，它存储了两个成员变量，分别是代表家谱祖先的root节点，以及将来用于代表所操作的人物的curFind。主要有六个public函数，分别是：\n\nadd(T familyRoot) 传入的是祖先名字，创建家谱中第一个元素。\n\nvoid add(T familyName,T childName) 给家谱中的某个人添加子女。\n\nvoid deleteFromTree(T fatherName) 删除家谱中的某个人，连带子女一起从家谱中删除。\n\nvoid update(T fatherName,T updateName)更改家谱中某个人的姓名\n\nvoid show(T familyName)展示家谱中某个人的子女\n\nbool findFromTree(T familyName)找出在家谱中这个人是否存在\n\n还有一个private函数：\n\nvoid findFromTree(Node\\<T\\> \\* x,T familyName)\n从家谱中找到某个人，并将它存在curFind中，供其他函数使用\n\n## 2.3 主程序设计\n\n首先需要打印出提示信息，让用户知道如何建立家谱树。接着，首先让用户输入家谱中祖先的姓名并展示。之后让用户通过指令自由选择对家谱的操作，完成增删改查等对家谱的基本操作，并且操作完能妥善退出。\n\n# 3 实现\n\n## 3.1 Node类实现\n\n其实就是在以前的Node类基础上添加了一个指向自己子类的指针link。\n\ntemplate \\<class T\\> class Node  \n{  \npublic:  \nT value;  \nNode\\<T\\> \\*next;  \nNode\\<T\\> \\*link;  \n\nNode(T value) : value(value), next(nullptr), link(nullptr) {}  \n};\n\n## 3.2 LinkedList类实现\n\n### 3.2.1 findFromTree(Node\\<T\\> \\* x,T familyName)\n\n因为该私有函数是其他函数的基础，所以先说它的实现。\n\n这是一个递归类型的函数，首先，其他函数调用它的时候，基本都会传入家谱的根节点root和要查找人的姓名familyName。然后，该函数的终止条件有两个，一个是在家谱中找到了那个人，那么令curFind指向这个人，并且返回。另一个是整个家谱树中都找不到这个人，即直接返回。（因为每一次调用这个函数时curFind都重置为nullptr，所以这个函数之后，如果没有找到，相当于就是curFind为nullptr，所以之后有一些也可以用这个作为判断依据）。\n\n而该函数的查找流程是，对于传入的x，先查询它本身是否为这个人，然后再它所有子节点中递归查找，最后再在他之后的兄弟节点中递归查找。\n\nvoid findFromTree(Node\\<T\\> \\* x,T familyName)  \n{  \nif(x== nullptr)  \n{  \nreturn;  \n}  \nif(x-\\>value==familyName)  \n{  \ncurFind = x;  \nreturn;  \n}  \nfindFromTree(x-\\>link,familyName);  \nfor (Node\\<T\\> \\* temp=x-\\>next;temp!= nullptr;temp=temp-\\>next)  \n{  \nfindFromTree(temp,familyName);  \n}  \n}\n\n### 3.2.2 add(T familyRoot)\n\n该函数往家谱中添加第一个节点，即祖先。\n\nvoid add(T familyRoot)  \n{  \nroot = new Node\\<T\\>(familyRoot);  \n}\n\n### 3.2.3 add(T familyName,T childName)\n\n先把curFind置为nullptr，然后调用之前所说的findFromTree函数，把curFind节点指向familyName这个人。如果curFind为nullptr，或者值为-1,(删除函数中会说明)说明查无此人，提示并返回。否则，往这人的link节点（即代表他的子女）后面插入一个名为childName的节点，代表他的孩子。（这里要分一下，如果本来curFind没子节点，就直接增加一个。如果本来有，则要走到curFind子节点的末尾，再在末尾加入该子女childName）。\n\nvoid add(T familyName,T childName)  \n{  \ncurFind = nullptr;//每次都要重新开始  \nfindFromTree(root,familyName);//找到了父节点  \nif(curFind== nullptr \\|\\| curFind-\\>value==\"-1\")  \n{  \nreturn;  \n}  \nNode\\<T\\> \\*curChild = curFind-\\>link;//父节点的子节点,不一定存在  \nif(curChild== nullptr)  \n{  \ncurChild = new Node\\<T\\>(childName);  \ncurFind-\\>link = curChild;  \n}  \nelse  \n{  \n//平行节点  \nNode\\<T\\> \\*x = curChild;  \nwhile(x-\\>next!= nullptr)  \n{  \nx = x-\\>next;  \n}  \nx-\\>next = new Node\\<T\\>(childName);  \n}  \n}\n\n### 3.2.4 deleteFromTree(T fatherName)\n\n该函数作用是将给定人物和他子女都删除。\n\n首先还是将curFind置为找到的那个人，如果没有找到就提示返回。然后将这个人的值置为“-1”（由于没有前驱指针，所以找不到该人的上一个兄弟，所以采用这种延时删除的操作，当查询或者是其他的，看到了“-1”，就代表了这个人不存在），代表该人已经被删除了。并且将指向他子女的节点置为nullptr，并且将他的子女一一删除。\n\nvoid deleteFromTree(T fatherName)  \n{  \ncurFind = nullptr;//每次都要重新开始  \nfindFromTree(root,fatherName);  \nif(curFind== nullptr \\|\\| curFind-\\>value==\"-1\")  \n{  \nreturn;  \n}  \ncurFind-\\>value = \"-1\";//延时实现删除操作  \nNode\\<T\\> \\*x=curFind-\\>link;  \ncurFind-\\>link = nullptr;//子代没了  \n\n}\n\n### 3.2.5 update(T fatherName,T updateName)\n\n该函数主要更新家谱中那个人的姓名。和前面的操作差不多，都是先查找到那个人，找不到就提示并且返回，找到就把找到那个人的名字改了。\n\nvoid update(T fatherName,T updateName)  \n{  \ncurFind = nullptr;//每次都要重新开始  \nfindFromTree(root,fatherName);  \nif(curFind== nullptr \\|\\| curFind-\\>value==\"-1\")  \n{  \nreturn;  \n}  \nNode\\<T\\> \\*cur = curFind;  \ncur-\\>value = updateName;  \n}\n\n### 3.2.6 show(T familyName)\n\n同样是先找到那个人，找不到就提示并且返回，然后对他的所有子女节点进行遍历，如果他的子女节点值不是-1的话，就打印他的值，这样之前所说的延时删除才有了意义。\n\n同时，用一个变量N记录子女的个数，如果子女个数为0，就打印一条提示信息null，代表该节点没有子女，以免用户在操作时产生困惑。\n\n>   void show(T familyName)  \n>   {  \n>   int N = 0;//子女个数,为了在为空的时候输出一条信息  \n>   curFind = nullptr;//每次都要重新开始  \n>   findFromTree(root, familyName);  \n>   if(curFind== nullptr \\|\\| curFind-\\>value==\"-1\")  \n>   {  \n>   return;  \n>   }  \n>   for (Node\\<T\\> \\* temp=curFind-\\>link;temp!= nullptr;temp=temp-\\>next)  \n>   {  \n>   if(temp-\\>value!=\"-1\")  \n>   {  \n>   ++N;  \n>   cout \\<\\< temp-\\>value \\<\\< \" \";  \n>   }  \n>   }  \n>   if(N==0)  \n>   {  \n>   cout \\<\\< \"null\"\\<\\<endl;  \n>   }  \n>   }\n\n### 3.2.7 findFromTree(T familyName)\n\n该函数是为了查看要查找的人在家谱中是否存在，实现很简单，但也很有用。\n\n通过调用findFromTree函数，如果找到了就返回true，否则返回false。\n\nbool findFromTree(T familyName)  \n{  \ncurFind = nullptr;  \nfindFromTree(root, familyName);  \nif(curFind== nullptr \\|\\| curFind-\\>value==\"-1\")  \nreturn false;  \nelse  \nreturn true;  \n}\n\n## 3.3 主函数的实现\n\n### 3.3.1 总体系统描述\n\n先输出一些用户提示信息。然后让用户输入家谱中的祖先的名字。随后进入一个直到用户主动退出才结束的while循环，让用户选择相应的操作。当用户选择相应的操作后，给出相应的提示，让用户进行相应的输入，程序调用LinkedList类的相应增删改查函数操作，并且把结果输出给用户。因为每个操作大体类似，所以用删除操作举例：\n\n当用户选择C时，代表要解散家谱中的某个家庭，这时给出提示信息让用户输入要解散的人的名字，然后通过LinkedList类的findFromTree函数判断输入的名字是否存在在家谱中，不存在就打印提示信息并且进入下一个循环选择。如果存在首先通过show函数展示这个人的第一代子孙，并且用deleteFromTree函数输出该人和他的子女。\n\n### 3.3.2 总体系统核心代码\n\ncout\\<\\<\"请选择要执行的操作:\"\\<\\<endl;  \nstring ops;  \ncin \\>\\> ops;  \nwhile(true)  \n{  \nif(ops==\"A\")  \n{  \nstring fatherName;  \nint childCount;  \ncout\\<\\<\"请输入要建立家庭的人的姓名:\";  \ncin \\>\\> fatherName;  \nif (families.findFromTree(fatherName))//这个人存在了才继续给他加入子女  \n{  \ncout \\<\\< \"请输入\" \\<\\< fatherName \\<\\< \"的儿女人数：\";  \ncin \\>\\> childCount;  \ncout \\<\\< \"请依次输入\" \\<\\< fatherName \\<\\< \"的儿女的姓名\";  \nstring childName;  \nfor (int i = 0; i \\< childCount; ++i)  \n{  \ncin \\>\\> childName;  \nfamilies.add(fatherName, childName);  \n}  \ncout \\<\\< fatherName \\<\\< \"的第一代子孙是：\";  \nfamilies.show(fatherName);  \n}  \nelse  \n{  \ncout \\<\\< \"该人不存在!\";  \n}  \n}  \nelse if(ops==\"B\")  \n{  \ncout \\<\\< \"请输入要添加儿子（或女儿）的人的姓名:\";  \nstring fatherName;  \ncin \\>\\> fatherName;  \nif (families.findFromTree(fatherName))  \n{  \ncout \\<\\< \" 请输入\" \\<\\< fatherName \\<\\< \"新添加的儿子（或女儿）的姓名：\";  \nstring childName;  \ncin \\>\\> childName;  \nfamilies.add(fatherName, childName);  \ncout \\<\\< fatherName \\<\\< \"的第一代子孙是：\";  \nfamilies.show(fatherName);  \n}  \nelse  \n{  \ncout \\<\\< \"该人不存在!\";  \n}  \n}  \nelse if(ops==\"C\")  \n{  \ncout \\<\\< \"请输入要解散家庭的人的姓名：\";  \nstring fatherName;  \ncin \\>\\> fatherName;  \n//删除操作  \ncout \\<\\< \"要解散家庭的人是\"\\<\\< fatherName\\<\\<endl;  \nif (families.findFromTree(fatherName))  \n{  \ncout \\<\\< fatherName \\<\\< \"的第一代子孙是:\";  \nfamilies.show(fatherName);  \nfamilies.deleteFromTree(fatherName);  \n}  \nelse  \n{  \ncout \\<\\< \"该人不存在!\";  \n}  \n\n}  \nelse if(ops==\"D\")  \n{  \ncout \\<\\< \"请输入更改姓名的人的目前姓名\";  \nstring fatherName;  \ncin \\>\\> fatherName;  \nif (families.findFromTree(fatherName))  \n{  \ncout \\<\\< \"请输入更改后的姓名\";  \nstring updateName;  \ncin \\>\\> updateName;  \ncout \\<\\< fatherName \\<\\< \"已更名为\" \\<\\<\nupdateName;//不成功的更名也会有这个提示,但是不想弄了  \nfamilies.update(fatherName, updateName);  \n}  \nelse  \n{  \ncout \\<\\< \"该人不存在!\";  \n}  \n}  \nelse if(ops==\"E\")  \n{  \nstring fatherName;  \ncout \\<\\< \" 请输入要查询人的姓名：\";  \ncin \\>\\> fatherName;  \nif(families.findFromTree(fatherName))  \n{  \ncout \\<\\<fatherName\\<\\< \"的第一代子孙是：\";  \nfamilies.show(fatherName);  \n}  \nelse  \n{  \ncout \\<\\< \"该人不存在!\";  \n}  \n}  \nelse if(ops==\"F\")  \n{  \nbreak;  \n}  \ncout\\<\\<endl\\<\\<\"请选择要执行的操作:\"\\<\\<endl;  \ncin\\>\\>ops;  \n}\n\n# 4 测试\n\n## 4.1 功能测试\n\n### 4.1.1 建立功能测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1ecf880c07339b6f915da76ab1096eac.png)\n\n### 4.1.2 插入功能测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/5843e748ccae8628603d30aed0a29bb7.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9a42edb88cfcf6fef4846454ef1feb4f.png)\n\n### 4.1.3 删除功能测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ef4fe21180570c065692cfcb54e3610e.png)\n\n### 4.1.4 查找功能测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/65d49c01ab9059b8d0b1a77471de17f1.png)\n\n### 4.1.5 修改功能测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8abd6aef4a6ea692e70cb21f70c9241a.png)\n\n## 4.2 边界测试\n\n### 4.2.1 要建立家庭的人不在家谱中\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/cedb11b06c24ec43315dc22aa30a50fa.png)\n\n### 4.2.2 要增加子女的人不在家谱中\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/b2f3357e015f8a746a640464b9112c38.png)\n\n### 4.2.3 要解散家庭的人不在家谱中\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/0db4755d60b7c6330faff9474dec14fc.png)\n\n### 4.2.4 要更改姓名的人不在家谱中\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/cb9e7e7e02487293ff98f1fb483e8431.png)\n\n### 4.2.5 要查询的人不在家谱中\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8834a573f1c2c0dcc8a99e2ffd4b21cf.png)\n","source":"_posts/项目笔记/dataStructureProjects/家谱管理系统.md","raw":"---\ntitle: 数据结构项目-------家谱管理系统\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习数据结构项目--家谱管理系统所写的文档,主要是特殊的链表.'\ncategories: 项目文档\ntags:\n  - 数据结构\n  - 链表\n  - c++\nabbrlink: '629471e8'\ndate: 2020-01-20 00:00:00\n---\n\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n\n>   家谱管理系统\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 项目简介\n\n家谱是一种以表谱形式，记载一个以血缘关系为主体的家族世袭繁衍和重要任务事迹的特殊图书体裁。家谱是中国特有的文化遗产，是中华民族的三大文献（国史，地志，族谱）之一，属于珍贵的人文资料，对于历史学，民俗学，人口学，社会学和经济学的深入研究，均有其不可替代的独特功能。本项目兑对家谱管理进行简单的模拟，以实现查看祖先和子孙个人信息，插入家族成员，删除家族成员的功能。\n\n## 1.2 功能要求\n\n本项目的实质是完成兑家谱成员信息的建立，查找，插入，修改，删除等功能，可以首先定义家族成员数据结构，然后将每个功能作为一个成员函数来完成对数据的操作，最后完成主函数以验证各个函数功能并得到运行结果。\n\n# 2 设计\n\n## 2.1 Node类设计\n\nNode类是一个模板类,存储一个T类型的值和两个指针,分别是代表指向兄弟节点的next指针和指向自己子节点的link指针。\n\n## 2.2 LinkedList类设计\n\n首先，LinkedList依旧是模板类，它存储了两个成员变量，分别是代表家谱祖先的root节点，以及将来用于代表所操作的人物的curFind。主要有六个public函数，分别是：\n\nadd(T familyRoot) 传入的是祖先名字，创建家谱中第一个元素。\n\nvoid add(T familyName,T childName) 给家谱中的某个人添加子女。\n\nvoid deleteFromTree(T fatherName) 删除家谱中的某个人，连带子女一起从家谱中删除。\n\nvoid update(T fatherName,T updateName)更改家谱中某个人的姓名\n\nvoid show(T familyName)展示家谱中某个人的子女\n\nbool findFromTree(T familyName)找出在家谱中这个人是否存在\n\n还有一个private函数：\n\nvoid findFromTree(Node\\<T\\> \\* x,T familyName)\n从家谱中找到某个人，并将它存在curFind中，供其他函数使用\n\n## 2.3 主程序设计\n\n首先需要打印出提示信息，让用户知道如何建立家谱树。接着，首先让用户输入家谱中祖先的姓名并展示。之后让用户通过指令自由选择对家谱的操作，完成增删改查等对家谱的基本操作，并且操作完能妥善退出。\n\n# 3 实现\n\n## 3.1 Node类实现\n\n其实就是在以前的Node类基础上添加了一个指向自己子类的指针link。\n\ntemplate \\<class T\\> class Node  \n{  \npublic:  \nT value;  \nNode\\<T\\> \\*next;  \nNode\\<T\\> \\*link;  \n\nNode(T value) : value(value), next(nullptr), link(nullptr) {}  \n};\n\n## 3.2 LinkedList类实现\n\n### 3.2.1 findFromTree(Node\\<T\\> \\* x,T familyName)\n\n因为该私有函数是其他函数的基础，所以先说它的实现。\n\n这是一个递归类型的函数，首先，其他函数调用它的时候，基本都会传入家谱的根节点root和要查找人的姓名familyName。然后，该函数的终止条件有两个，一个是在家谱中找到了那个人，那么令curFind指向这个人，并且返回。另一个是整个家谱树中都找不到这个人，即直接返回。（因为每一次调用这个函数时curFind都重置为nullptr，所以这个函数之后，如果没有找到，相当于就是curFind为nullptr，所以之后有一些也可以用这个作为判断依据）。\n\n而该函数的查找流程是，对于传入的x，先查询它本身是否为这个人，然后再它所有子节点中递归查找，最后再在他之后的兄弟节点中递归查找。\n\nvoid findFromTree(Node\\<T\\> \\* x,T familyName)  \n{  \nif(x== nullptr)  \n{  \nreturn;  \n}  \nif(x-\\>value==familyName)  \n{  \ncurFind = x;  \nreturn;  \n}  \nfindFromTree(x-\\>link,familyName);  \nfor (Node\\<T\\> \\* temp=x-\\>next;temp!= nullptr;temp=temp-\\>next)  \n{  \nfindFromTree(temp,familyName);  \n}  \n}\n\n### 3.2.2 add(T familyRoot)\n\n该函数往家谱中添加第一个节点，即祖先。\n\nvoid add(T familyRoot)  \n{  \nroot = new Node\\<T\\>(familyRoot);  \n}\n\n### 3.2.3 add(T familyName,T childName)\n\n先把curFind置为nullptr，然后调用之前所说的findFromTree函数，把curFind节点指向familyName这个人。如果curFind为nullptr，或者值为-1,(删除函数中会说明)说明查无此人，提示并返回。否则，往这人的link节点（即代表他的子女）后面插入一个名为childName的节点，代表他的孩子。（这里要分一下，如果本来curFind没子节点，就直接增加一个。如果本来有，则要走到curFind子节点的末尾，再在末尾加入该子女childName）。\n\nvoid add(T familyName,T childName)  \n{  \ncurFind = nullptr;//每次都要重新开始  \nfindFromTree(root,familyName);//找到了父节点  \nif(curFind== nullptr \\|\\| curFind-\\>value==\"-1\")  \n{  \nreturn;  \n}  \nNode\\<T\\> \\*curChild = curFind-\\>link;//父节点的子节点,不一定存在  \nif(curChild== nullptr)  \n{  \ncurChild = new Node\\<T\\>(childName);  \ncurFind-\\>link = curChild;  \n}  \nelse  \n{  \n//平行节点  \nNode\\<T\\> \\*x = curChild;  \nwhile(x-\\>next!= nullptr)  \n{  \nx = x-\\>next;  \n}  \nx-\\>next = new Node\\<T\\>(childName);  \n}  \n}\n\n### 3.2.4 deleteFromTree(T fatherName)\n\n该函数作用是将给定人物和他子女都删除。\n\n首先还是将curFind置为找到的那个人，如果没有找到就提示返回。然后将这个人的值置为“-1”（由于没有前驱指针，所以找不到该人的上一个兄弟，所以采用这种延时删除的操作，当查询或者是其他的，看到了“-1”，就代表了这个人不存在），代表该人已经被删除了。并且将指向他子女的节点置为nullptr，并且将他的子女一一删除。\n\nvoid deleteFromTree(T fatherName)  \n{  \ncurFind = nullptr;//每次都要重新开始  \nfindFromTree(root,fatherName);  \nif(curFind== nullptr \\|\\| curFind-\\>value==\"-1\")  \n{  \nreturn;  \n}  \ncurFind-\\>value = \"-1\";//延时实现删除操作  \nNode\\<T\\> \\*x=curFind-\\>link;  \ncurFind-\\>link = nullptr;//子代没了  \n\n}\n\n### 3.2.5 update(T fatherName,T updateName)\n\n该函数主要更新家谱中那个人的姓名。和前面的操作差不多，都是先查找到那个人，找不到就提示并且返回，找到就把找到那个人的名字改了。\n\nvoid update(T fatherName,T updateName)  \n{  \ncurFind = nullptr;//每次都要重新开始  \nfindFromTree(root,fatherName);  \nif(curFind== nullptr \\|\\| curFind-\\>value==\"-1\")  \n{  \nreturn;  \n}  \nNode\\<T\\> \\*cur = curFind;  \ncur-\\>value = updateName;  \n}\n\n### 3.2.6 show(T familyName)\n\n同样是先找到那个人，找不到就提示并且返回，然后对他的所有子女节点进行遍历，如果他的子女节点值不是-1的话，就打印他的值，这样之前所说的延时删除才有了意义。\n\n同时，用一个变量N记录子女的个数，如果子女个数为0，就打印一条提示信息null，代表该节点没有子女，以免用户在操作时产生困惑。\n\n>   void show(T familyName)  \n>   {  \n>   int N = 0;//子女个数,为了在为空的时候输出一条信息  \n>   curFind = nullptr;//每次都要重新开始  \n>   findFromTree(root, familyName);  \n>   if(curFind== nullptr \\|\\| curFind-\\>value==\"-1\")  \n>   {  \n>   return;  \n>   }  \n>   for (Node\\<T\\> \\* temp=curFind-\\>link;temp!= nullptr;temp=temp-\\>next)  \n>   {  \n>   if(temp-\\>value!=\"-1\")  \n>   {  \n>   ++N;  \n>   cout \\<\\< temp-\\>value \\<\\< \" \";  \n>   }  \n>   }  \n>   if(N==0)  \n>   {  \n>   cout \\<\\< \"null\"\\<\\<endl;  \n>   }  \n>   }\n\n### 3.2.7 findFromTree(T familyName)\n\n该函数是为了查看要查找的人在家谱中是否存在，实现很简单，但也很有用。\n\n通过调用findFromTree函数，如果找到了就返回true，否则返回false。\n\nbool findFromTree(T familyName)  \n{  \ncurFind = nullptr;  \nfindFromTree(root, familyName);  \nif(curFind== nullptr \\|\\| curFind-\\>value==\"-1\")  \nreturn false;  \nelse  \nreturn true;  \n}\n\n## 3.3 主函数的实现\n\n### 3.3.1 总体系统描述\n\n先输出一些用户提示信息。然后让用户输入家谱中的祖先的名字。随后进入一个直到用户主动退出才结束的while循环，让用户选择相应的操作。当用户选择相应的操作后，给出相应的提示，让用户进行相应的输入，程序调用LinkedList类的相应增删改查函数操作，并且把结果输出给用户。因为每个操作大体类似，所以用删除操作举例：\n\n当用户选择C时，代表要解散家谱中的某个家庭，这时给出提示信息让用户输入要解散的人的名字，然后通过LinkedList类的findFromTree函数判断输入的名字是否存在在家谱中，不存在就打印提示信息并且进入下一个循环选择。如果存在首先通过show函数展示这个人的第一代子孙，并且用deleteFromTree函数输出该人和他的子女。\n\n### 3.3.2 总体系统核心代码\n\ncout\\<\\<\"请选择要执行的操作:\"\\<\\<endl;  \nstring ops;  \ncin \\>\\> ops;  \nwhile(true)  \n{  \nif(ops==\"A\")  \n{  \nstring fatherName;  \nint childCount;  \ncout\\<\\<\"请输入要建立家庭的人的姓名:\";  \ncin \\>\\> fatherName;  \nif (families.findFromTree(fatherName))//这个人存在了才继续给他加入子女  \n{  \ncout \\<\\< \"请输入\" \\<\\< fatherName \\<\\< \"的儿女人数：\";  \ncin \\>\\> childCount;  \ncout \\<\\< \"请依次输入\" \\<\\< fatherName \\<\\< \"的儿女的姓名\";  \nstring childName;  \nfor (int i = 0; i \\< childCount; ++i)  \n{  \ncin \\>\\> childName;  \nfamilies.add(fatherName, childName);  \n}  \ncout \\<\\< fatherName \\<\\< \"的第一代子孙是：\";  \nfamilies.show(fatherName);  \n}  \nelse  \n{  \ncout \\<\\< \"该人不存在!\";  \n}  \n}  \nelse if(ops==\"B\")  \n{  \ncout \\<\\< \"请输入要添加儿子（或女儿）的人的姓名:\";  \nstring fatherName;  \ncin \\>\\> fatherName;  \nif (families.findFromTree(fatherName))  \n{  \ncout \\<\\< \" 请输入\" \\<\\< fatherName \\<\\< \"新添加的儿子（或女儿）的姓名：\";  \nstring childName;  \ncin \\>\\> childName;  \nfamilies.add(fatherName, childName);  \ncout \\<\\< fatherName \\<\\< \"的第一代子孙是：\";  \nfamilies.show(fatherName);  \n}  \nelse  \n{  \ncout \\<\\< \"该人不存在!\";  \n}  \n}  \nelse if(ops==\"C\")  \n{  \ncout \\<\\< \"请输入要解散家庭的人的姓名：\";  \nstring fatherName;  \ncin \\>\\> fatherName;  \n//删除操作  \ncout \\<\\< \"要解散家庭的人是\"\\<\\< fatherName\\<\\<endl;  \nif (families.findFromTree(fatherName))  \n{  \ncout \\<\\< fatherName \\<\\< \"的第一代子孙是:\";  \nfamilies.show(fatherName);  \nfamilies.deleteFromTree(fatherName);  \n}  \nelse  \n{  \ncout \\<\\< \"该人不存在!\";  \n}  \n\n}  \nelse if(ops==\"D\")  \n{  \ncout \\<\\< \"请输入更改姓名的人的目前姓名\";  \nstring fatherName;  \ncin \\>\\> fatherName;  \nif (families.findFromTree(fatherName))  \n{  \ncout \\<\\< \"请输入更改后的姓名\";  \nstring updateName;  \ncin \\>\\> updateName;  \ncout \\<\\< fatherName \\<\\< \"已更名为\" \\<\\<\nupdateName;//不成功的更名也会有这个提示,但是不想弄了  \nfamilies.update(fatherName, updateName);  \n}  \nelse  \n{  \ncout \\<\\< \"该人不存在!\";  \n}  \n}  \nelse if(ops==\"E\")  \n{  \nstring fatherName;  \ncout \\<\\< \" 请输入要查询人的姓名：\";  \ncin \\>\\> fatherName;  \nif(families.findFromTree(fatherName))  \n{  \ncout \\<\\<fatherName\\<\\< \"的第一代子孙是：\";  \nfamilies.show(fatherName);  \n}  \nelse  \n{  \ncout \\<\\< \"该人不存在!\";  \n}  \n}  \nelse if(ops==\"F\")  \n{  \nbreak;  \n}  \ncout\\<\\<endl\\<\\<\"请选择要执行的操作:\"\\<\\<endl;  \ncin\\>\\>ops;  \n}\n\n# 4 测试\n\n## 4.1 功能测试\n\n### 4.1.1 建立功能测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1ecf880c07339b6f915da76ab1096eac.png)\n\n### 4.1.2 插入功能测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/5843e748ccae8628603d30aed0a29bb7.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9a42edb88cfcf6fef4846454ef1feb4f.png)\n\n### 4.1.3 删除功能测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/ef4fe21180570c065692cfcb54e3610e.png)\n\n### 4.1.4 查找功能测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/65d49c01ab9059b8d0b1a77471de17f1.png)\n\n### 4.1.5 修改功能测试\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8abd6aef4a6ea692e70cb21f70c9241a.png)\n\n## 4.2 边界测试\n\n### 4.2.1 要建立家庭的人不在家谱中\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/cedb11b06c24ec43315dc22aa30a50fa.png)\n\n### 4.2.2 要增加子女的人不在家谱中\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/b2f3357e015f8a746a640464b9112c38.png)\n\n### 4.2.3 要解散家庭的人不在家谱中\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/0db4755d60b7c6330faff9474dec14fc.png)\n\n### 4.2.4 要更改姓名的人不在家谱中\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/cb9e7e7e02487293ff98f1fb483e8431.png)\n\n### 4.2.5 要查询的人不在家谱中\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8834a573f1c2c0dcc8a99e2ffd4b21cf.png)\n","slug":"项目笔记/dataStructureProjects/家谱管理系统","published":1,"updated":"2020-11-12T11:57:30.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73y00oujotpgw5aaa96","content":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  家谱管理系统</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目简介\"><a href=\"#1-1-项目简介\" class=\"headerlink\" title=\"1.1 项目简介\"></a>1.1 项目简介</h2><p>家谱是一种以表谱形式，记载一个以血缘关系为主体的家族世袭繁衍和重要任务事迹的特殊图书体裁。家谱是中国特有的文化遗产，是中华民族的三大文献（国史，地志，族谱）之一，属于珍贵的人文资料，对于历史学，民俗学，人口学，社会学和经济学的深入研究，均有其不可替代的独特功能。本项目兑对家谱管理进行简单的模拟，以实现查看祖先和子孙个人信息，插入家族成员，删除家族成员的功能。</p>\n<h2 id=\"1-2-功能要求\"><a href=\"#1-2-功能要求\" class=\"headerlink\" title=\"1.2 功能要求\"></a>1.2 功能要求</h2><p>本项目的实质是完成兑家谱成员信息的建立，查找，插入，修改，删除等功能，可以首先定义家族成员数据结构，然后将每个功能作为一个成员函数来完成对数据的操作，最后完成主函数以验证各个函数功能并得到运行结果。</p>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-Node类设计\"><a href=\"#2-1-Node类设计\" class=\"headerlink\" title=\"2.1 Node类设计\"></a>2.1 Node类设计</h2><p>Node类是一个模板类,存储一个T类型的值和两个指针,分别是代表指向兄弟节点的next指针和指向自己子节点的link指针。</p>\n<h2 id=\"2-2-LinkedList类设计\"><a href=\"#2-2-LinkedList类设计\" class=\"headerlink\" title=\"2.2 LinkedList类设计\"></a>2.2 LinkedList类设计</h2><p>首先，LinkedList依旧是模板类，它存储了两个成员变量，分别是代表家谱祖先的root节点，以及将来用于代表所操作的人物的curFind。主要有六个public函数，分别是：</p>\n<p>add(T familyRoot) 传入的是祖先名字，创建家谱中第一个元素。</p>\n<p>void add(T familyName,T childName) 给家谱中的某个人添加子女。</p>\n<p>void deleteFromTree(T fatherName) 删除家谱中的某个人，连带子女一起从家谱中删除。</p>\n<p>void update(T fatherName,T updateName)更改家谱中某个人的姓名</p>\n<p>void show(T familyName)展示家谱中某个人的子女</p>\n<p>bool findFromTree(T familyName)找出在家谱中这个人是否存在</p>\n<p>还有一个private函数：</p>\n<p>void findFromTree(Node&lt;T&gt; * x,T familyName)<br>从家谱中找到某个人，并将它存在curFind中，供其他函数使用</p>\n<h2 id=\"2-3-主程序设计\"><a href=\"#2-3-主程序设计\" class=\"headerlink\" title=\"2.3 主程序设计\"></a>2.3 主程序设计</h2><p>首先需要打印出提示信息，让用户知道如何建立家谱树。接着，首先让用户输入家谱中祖先的姓名并展示。之后让用户通过指令自由选择对家谱的操作，完成增删改查等对家谱的基本操作，并且操作完能妥善退出。</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-Node类实现\"><a href=\"#3-1-Node类实现\" class=\"headerlink\" title=\"3.1 Node类实现\"></a>3.1 Node类实现</h2><p>其实就是在以前的Node类基础上添加了一个指向自己子类的指针link。</p>\n<p>template &lt;class T&gt; class Node<br>{<br>public:<br>T value;<br>Node&lt;T&gt; *next;<br>Node&lt;T&gt; *link;  </p>\n<p>Node(T value) : value(value), next(nullptr), link(nullptr) {}<br>};</p>\n<h2 id=\"3-2-LinkedList类实现\"><a href=\"#3-2-LinkedList类实现\" class=\"headerlink\" title=\"3.2 LinkedList类实现\"></a>3.2 LinkedList类实现</h2><h3 id=\"3-2-1-findFromTree-Node-lt-T-gt-x-T-familyName\"><a href=\"#3-2-1-findFromTree-Node-lt-T-gt-x-T-familyName\" class=\"headerlink\" title=\"3.2.1 findFromTree(Node&lt;T&gt; * x,T familyName)\"></a>3.2.1 findFromTree(Node&lt;T&gt; * x,T familyName)</h3><p>因为该私有函数是其他函数的基础，所以先说它的实现。</p>\n<p>这是一个递归类型的函数，首先，其他函数调用它的时候，基本都会传入家谱的根节点root和要查找人的姓名familyName。然后，该函数的终止条件有两个，一个是在家谱中找到了那个人，那么令curFind指向这个人，并且返回。另一个是整个家谱树中都找不到这个人，即直接返回。（因为每一次调用这个函数时curFind都重置为nullptr，所以这个函数之后，如果没有找到，相当于就是curFind为nullptr，所以之后有一些也可以用这个作为判断依据）。</p>\n<p>而该函数的查找流程是，对于传入的x，先查询它本身是否为这个人，然后再它所有子节点中递归查找，最后再在他之后的兄弟节点中递归查找。</p>\n<p>void findFromTree(Node&lt;T&gt; * x,T familyName)<br>{<br>if(x== nullptr)<br>{<br>return;<br>}<br>if(x-&gt;value==familyName)<br>{<br>curFind = x;<br>return;<br>}<br>findFromTree(x-&gt;link,familyName);<br>for (Node&lt;T&gt; * temp=x-&gt;next;temp!= nullptr;temp=temp-&gt;next)<br>{<br>findFromTree(temp,familyName);<br>}<br>}</p>\n<h3 id=\"3-2-2-add-T-familyRoot\"><a href=\"#3-2-2-add-T-familyRoot\" class=\"headerlink\" title=\"3.2.2 add(T familyRoot)\"></a>3.2.2 add(T familyRoot)</h3><p>该函数往家谱中添加第一个节点，即祖先。</p>\n<p>void add(T familyRoot)<br>{<br>root = new Node&lt;T&gt;(familyRoot);<br>}</p>\n<h3 id=\"3-2-3-add-T-familyName-T-childName\"><a href=\"#3-2-3-add-T-familyName-T-childName\" class=\"headerlink\" title=\"3.2.3 add(T familyName,T childName)\"></a>3.2.3 add(T familyName,T childName)</h3><p>先把curFind置为nullptr，然后调用之前所说的findFromTree函数，把curFind节点指向familyName这个人。如果curFind为nullptr，或者值为-1,(删除函数中会说明)说明查无此人，提示并返回。否则，往这人的link节点（即代表他的子女）后面插入一个名为childName的节点，代表他的孩子。（这里要分一下，如果本来curFind没子节点，就直接增加一个。如果本来有，则要走到curFind子节点的末尾，再在末尾加入该子女childName）。</p>\n<p>void add(T familyName,T childName)<br>{<br>curFind = nullptr;//每次都要重新开始<br>findFromTree(root,familyName);//找到了父节点<br>if(curFind== nullptr || curFind-&gt;value==”-1”)<br>{<br>return;<br>}<br>Node&lt;T&gt; *curChild = curFind-&gt;link;//父节点的子节点,不一定存在<br>if(curChild== nullptr)<br>{<br>curChild = new Node&lt;T&gt;(childName);<br>curFind-&gt;link = curChild;<br>}<br>else<br>{<br>//平行节点<br>Node&lt;T&gt; *x = curChild;<br>while(x-&gt;next!= nullptr)<br>{<br>x = x-&gt;next;<br>}<br>x-&gt;next = new Node&lt;T&gt;(childName);<br>}<br>}</p>\n<h3 id=\"3-2-4-deleteFromTree-T-fatherName\"><a href=\"#3-2-4-deleteFromTree-T-fatherName\" class=\"headerlink\" title=\"3.2.4 deleteFromTree(T fatherName)\"></a>3.2.4 deleteFromTree(T fatherName)</h3><p>该函数作用是将给定人物和他子女都删除。</p>\n<p>首先还是将curFind置为找到的那个人，如果没有找到就提示返回。然后将这个人的值置为“-1”（由于没有前驱指针，所以找不到该人的上一个兄弟，所以采用这种延时删除的操作，当查询或者是其他的，看到了“-1”，就代表了这个人不存在），代表该人已经被删除了。并且将指向他子女的节点置为nullptr，并且将他的子女一一删除。</p>\n<p>void deleteFromTree(T fatherName)<br>{<br>curFind = nullptr;//每次都要重新开始<br>findFromTree(root,fatherName);<br>if(curFind== nullptr || curFind-&gt;value==”-1”)<br>{<br>return;<br>}<br>curFind-&gt;value = “-1”;//延时实现删除操作<br>Node&lt;T&gt; *x=curFind-&gt;link;<br>curFind-&gt;link = nullptr;//子代没了  </p>\n<p>}</p>\n<h3 id=\"3-2-5-update-T-fatherName-T-updateName\"><a href=\"#3-2-5-update-T-fatherName-T-updateName\" class=\"headerlink\" title=\"3.2.5 update(T fatherName,T updateName)\"></a>3.2.5 update(T fatherName,T updateName)</h3><p>该函数主要更新家谱中那个人的姓名。和前面的操作差不多，都是先查找到那个人，找不到就提示并且返回，找到就把找到那个人的名字改了。</p>\n<p>void update(T fatherName,T updateName)<br>{<br>curFind = nullptr;//每次都要重新开始<br>findFromTree(root,fatherName);<br>if(curFind== nullptr || curFind-&gt;value==”-1”)<br>{<br>return;<br>}<br>Node&lt;T&gt; *cur = curFind;<br>cur-&gt;value = updateName;<br>}</p>\n<h3 id=\"3-2-6-show-T-familyName\"><a href=\"#3-2-6-show-T-familyName\" class=\"headerlink\" title=\"3.2.6 show(T familyName)\"></a>3.2.6 show(T familyName)</h3><p>同样是先找到那个人，找不到就提示并且返回，然后对他的所有子女节点进行遍历，如果他的子女节点值不是-1的话，就打印他的值，这样之前所说的延时删除才有了意义。</p>\n<p>同时，用一个变量N记录子女的个数，如果子女个数为0，就打印一条提示信息null，代表该节点没有子女，以免用户在操作时产生困惑。</p>\n<blockquote>\n<p>  void show(T familyName)<br>  {<br>  int N = 0;//子女个数,为了在为空的时候输出一条信息<br>  curFind = nullptr;//每次都要重新开始<br>  findFromTree(root, familyName);<br>  if(curFind== nullptr || curFind-&gt;value==”-1”)<br>  {<br>  return;<br>  }<br>  for (Node&lt;T&gt; * temp=curFind-&gt;link;temp!= nullptr;temp=temp-&gt;next)<br>  {<br>  if(temp-&gt;value!=”-1”)<br>  {<br>  ++N;<br>  cout &lt;&lt; temp-&gt;value &lt;&lt; “ “;<br>  }<br>  }<br>  if(N==0)<br>  {<br>  cout &lt;&lt; “null”&lt;&lt;endl;<br>  }<br>  }</p>\n</blockquote>\n<h3 id=\"3-2-7-findFromTree-T-familyName\"><a href=\"#3-2-7-findFromTree-T-familyName\" class=\"headerlink\" title=\"3.2.7 findFromTree(T familyName)\"></a>3.2.7 findFromTree(T familyName)</h3><p>该函数是为了查看要查找的人在家谱中是否存在，实现很简单，但也很有用。</p>\n<p>通过调用findFromTree函数，如果找到了就返回true，否则返回false。</p>\n<p>bool findFromTree(T familyName)<br>{<br>curFind = nullptr;<br>findFromTree(root, familyName);<br>if(curFind== nullptr || curFind-&gt;value==”-1”)<br>return false;<br>else<br>return true;<br>}</p>\n<h2 id=\"3-3-主函数的实现\"><a href=\"#3-3-主函数的实现\" class=\"headerlink\" title=\"3.3 主函数的实现\"></a>3.3 主函数的实现</h2><h3 id=\"3-3-1-总体系统描述\"><a href=\"#3-3-1-总体系统描述\" class=\"headerlink\" title=\"3.3.1 总体系统描述\"></a>3.3.1 总体系统描述</h3><p>先输出一些用户提示信息。然后让用户输入家谱中的祖先的名字。随后进入一个直到用户主动退出才结束的while循环，让用户选择相应的操作。当用户选择相应的操作后，给出相应的提示，让用户进行相应的输入，程序调用LinkedList类的相应增删改查函数操作，并且把结果输出给用户。因为每个操作大体类似，所以用删除操作举例：</p>\n<p>当用户选择C时，代表要解散家谱中的某个家庭，这时给出提示信息让用户输入要解散的人的名字，然后通过LinkedList类的findFromTree函数判断输入的名字是否存在在家谱中，不存在就打印提示信息并且进入下一个循环选择。如果存在首先通过show函数展示这个人的第一代子孙，并且用deleteFromTree函数输出该人和他的子女。</p>\n<h3 id=\"3-3-2-总体系统核心代码\"><a href=\"#3-3-2-总体系统核心代码\" class=\"headerlink\" title=\"3.3.2 总体系统核心代码\"></a>3.3.2 总体系统核心代码</h3><p>cout&lt;&lt;“请选择要执行的操作:”&lt;&lt;endl;<br>string ops;<br>cin &gt;&gt; ops;<br>while(true)<br>{<br>if(ops==”A”)<br>{<br>string fatherName;<br>int childCount;<br>cout&lt;&lt;“请输入要建立家庭的人的姓名:”;<br>cin &gt;&gt; fatherName;<br>if (families.findFromTree(fatherName))//这个人存在了才继续给他加入子女<br>{<br>cout &lt;&lt; “请输入” &lt;&lt; fatherName &lt;&lt; “的儿女人数：”;<br>cin &gt;&gt; childCount;<br>cout &lt;&lt; “请依次输入” &lt;&lt; fatherName &lt;&lt; “的儿女的姓名”;<br>string childName;<br>for (int i = 0; i &lt; childCount; ++i)<br>{<br>cin &gt;&gt; childName;<br>families.add(fatherName, childName);<br>}<br>cout &lt;&lt; fatherName &lt;&lt; “的第一代子孙是：”;<br>families.show(fatherName);<br>}<br>else<br>{<br>cout &lt;&lt; “该人不存在!”;<br>}<br>}<br>else if(ops==”B”)<br>{<br>cout &lt;&lt; “请输入要添加儿子（或女儿）的人的姓名:”;<br>string fatherName;<br>cin &gt;&gt; fatherName;<br>if (families.findFromTree(fatherName))<br>{<br>cout &lt;&lt; “ 请输入” &lt;&lt; fatherName &lt;&lt; “新添加的儿子（或女儿）的姓名：”;<br>string childName;<br>cin &gt;&gt; childName;<br>families.add(fatherName, childName);<br>cout &lt;&lt; fatherName &lt;&lt; “的第一代子孙是：”;<br>families.show(fatherName);<br>}<br>else<br>{<br>cout &lt;&lt; “该人不存在!”;<br>}<br>}<br>else if(ops==”C”)<br>{<br>cout &lt;&lt; “请输入要解散家庭的人的姓名：”;<br>string fatherName;<br>cin &gt;&gt; fatherName;<br>//删除操作<br>cout &lt;&lt; “要解散家庭的人是”&lt;&lt; fatherName&lt;&lt;endl;<br>if (families.findFromTree(fatherName))<br>{<br>cout &lt;&lt; fatherName &lt;&lt; “的第一代子孙是:”;<br>families.show(fatherName);<br>families.deleteFromTree(fatherName);<br>}<br>else<br>{<br>cout &lt;&lt; “该人不存在!”;<br>}  </p>\n<p>}<br>else if(ops==”D”)<br>{<br>cout &lt;&lt; “请输入更改姓名的人的目前姓名”;<br>string fatherName;<br>cin &gt;&gt; fatherName;<br>if (families.findFromTree(fatherName))<br>{<br>cout &lt;&lt; “请输入更改后的姓名”;<br>string updateName;<br>cin &gt;&gt; updateName;<br>cout &lt;&lt; fatherName &lt;&lt; “已更名为” &lt;&lt;<br>updateName;//不成功的更名也会有这个提示,但是不想弄了<br>families.update(fatherName, updateName);<br>}<br>else<br>{<br>cout &lt;&lt; “该人不存在!”;<br>}<br>}<br>else if(ops==”E”)<br>{<br>string fatherName;<br>cout &lt;&lt; “ 请输入要查询人的姓名：”;<br>cin &gt;&gt; fatherName;<br>if(families.findFromTree(fatherName))<br>{<br>cout &lt;&lt;fatherName&lt;&lt; “的第一代子孙是：”;<br>families.show(fatherName);<br>}<br>else<br>{<br>cout &lt;&lt; “该人不存在!”;<br>}<br>}<br>else if(ops==”F”)<br>{<br>break;<br>}<br>cout&lt;&lt;endl&lt;&lt;“请选择要执行的操作:”&lt;&lt;endl;<br>cin&gt;&gt;ops;<br>}</p>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><h2 id=\"4-1-功能测试\"><a href=\"#4-1-功能测试\" class=\"headerlink\" title=\"4.1 功能测试\"></a>4.1 功能测试</h2><h3 id=\"4-1-1-建立功能测试\"><a href=\"#4-1-1-建立功能测试\" class=\"headerlink\" title=\"4.1.1 建立功能测试\"></a>4.1.1 建立功能测试</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1ecf880c07339b6f915da76ab1096eac.png\"></p>\n<h3 id=\"4-1-2-插入功能测试\"><a href=\"#4-1-2-插入功能测试\" class=\"headerlink\" title=\"4.1.2 插入功能测试\"></a>4.1.2 插入功能测试</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/5843e748ccae8628603d30aed0a29bb7.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9a42edb88cfcf6fef4846454ef1feb4f.png\"></p>\n<h3 id=\"4-1-3-删除功能测试\"><a href=\"#4-1-3-删除功能测试\" class=\"headerlink\" title=\"4.1.3 删除功能测试\"></a>4.1.3 删除功能测试</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ef4fe21180570c065692cfcb54e3610e.png\"></p>\n<h3 id=\"4-1-4-查找功能测试\"><a href=\"#4-1-4-查找功能测试\" class=\"headerlink\" title=\"4.1.4 查找功能测试\"></a>4.1.4 查找功能测试</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/65d49c01ab9059b8d0b1a77471de17f1.png\"></p>\n<h3 id=\"4-1-5-修改功能测试\"><a href=\"#4-1-5-修改功能测试\" class=\"headerlink\" title=\"4.1.5 修改功能测试\"></a>4.1.5 修改功能测试</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8abd6aef4a6ea692e70cb21f70c9241a.png\"></p>\n<h2 id=\"4-2-边界测试\"><a href=\"#4-2-边界测试\" class=\"headerlink\" title=\"4.2 边界测试\"></a>4.2 边界测试</h2><h3 id=\"4-2-1-要建立家庭的人不在家谱中\"><a href=\"#4-2-1-要建立家庭的人不在家谱中\" class=\"headerlink\" title=\"4.2.1 要建立家庭的人不在家谱中\"></a>4.2.1 要建立家庭的人不在家谱中</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/cedb11b06c24ec43315dc22aa30a50fa.png\"></p>\n<h3 id=\"4-2-2-要增加子女的人不在家谱中\"><a href=\"#4-2-2-要增加子女的人不在家谱中\" class=\"headerlink\" title=\"4.2.2 要增加子女的人不在家谱中\"></a>4.2.2 要增加子女的人不在家谱中</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/b2f3357e015f8a746a640464b9112c38.png\"></p>\n<h3 id=\"4-2-3-要解散家庭的人不在家谱中\"><a href=\"#4-2-3-要解散家庭的人不在家谱中\" class=\"headerlink\" title=\"4.2.3 要解散家庭的人不在家谱中\"></a>4.2.3 要解散家庭的人不在家谱中</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/0db4755d60b7c6330faff9474dec14fc.png\"></p>\n<h3 id=\"4-2-4-要更改姓名的人不在家谱中\"><a href=\"#4-2-4-要更改姓名的人不在家谱中\" class=\"headerlink\" title=\"4.2.4 要更改姓名的人不在家谱中\"></a>4.2.4 要更改姓名的人不在家谱中</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/cb9e7e7e02487293ff98f1fb483e8431.png\"></p>\n<h3 id=\"4-2-5-要查询的人不在家谱中\"><a href=\"#4-2-5-要查询的人不在家谱中\" class=\"headerlink\" title=\"4.2.5 要查询的人不在家谱中\"></a>4.2.5 要查询的人不在家谱中</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8834a573f1c2c0dcc8a99e2ffd4b21cf.png\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  家谱管理系统</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目简介\"><a href=\"#1-1-项目简介\" class=\"headerlink\" title=\"1.1 项目简介\"></a>1.1 项目简介</h2><p>家谱是一种以表谱形式，记载一个以血缘关系为主体的家族世袭繁衍和重要任务事迹的特殊图书体裁。家谱是中国特有的文化遗产，是中华民族的三大文献（国史，地志，族谱）之一，属于珍贵的人文资料，对于历史学，民俗学，人口学，社会学和经济学的深入研究，均有其不可替代的独特功能。本项目兑对家谱管理进行简单的模拟，以实现查看祖先和子孙个人信息，插入家族成员，删除家族成员的功能。</p>\n<h2 id=\"1-2-功能要求\"><a href=\"#1-2-功能要求\" class=\"headerlink\" title=\"1.2 功能要求\"></a>1.2 功能要求</h2><p>本项目的实质是完成兑家谱成员信息的建立，查找，插入，修改，删除等功能，可以首先定义家族成员数据结构，然后将每个功能作为一个成员函数来完成对数据的操作，最后完成主函数以验证各个函数功能并得到运行结果。</p>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-Node类设计\"><a href=\"#2-1-Node类设计\" class=\"headerlink\" title=\"2.1 Node类设计\"></a>2.1 Node类设计</h2><p>Node类是一个模板类,存储一个T类型的值和两个指针,分别是代表指向兄弟节点的next指针和指向自己子节点的link指针。</p>\n<h2 id=\"2-2-LinkedList类设计\"><a href=\"#2-2-LinkedList类设计\" class=\"headerlink\" title=\"2.2 LinkedList类设计\"></a>2.2 LinkedList类设计</h2><p>首先，LinkedList依旧是模板类，它存储了两个成员变量，分别是代表家谱祖先的root节点，以及将来用于代表所操作的人物的curFind。主要有六个public函数，分别是：</p>\n<p>add(T familyRoot) 传入的是祖先名字，创建家谱中第一个元素。</p>\n<p>void add(T familyName,T childName) 给家谱中的某个人添加子女。</p>\n<p>void deleteFromTree(T fatherName) 删除家谱中的某个人，连带子女一起从家谱中删除。</p>\n<p>void update(T fatherName,T updateName)更改家谱中某个人的姓名</p>\n<p>void show(T familyName)展示家谱中某个人的子女</p>\n<p>bool findFromTree(T familyName)找出在家谱中这个人是否存在</p>\n<p>还有一个private函数：</p>\n<p>void findFromTree(Node&lt;T&gt; * x,T familyName)<br>从家谱中找到某个人，并将它存在curFind中，供其他函数使用</p>\n<h2 id=\"2-3-主程序设计\"><a href=\"#2-3-主程序设计\" class=\"headerlink\" title=\"2.3 主程序设计\"></a>2.3 主程序设计</h2><p>首先需要打印出提示信息，让用户知道如何建立家谱树。接着，首先让用户输入家谱中祖先的姓名并展示。之后让用户通过指令自由选择对家谱的操作，完成增删改查等对家谱的基本操作，并且操作完能妥善退出。</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-Node类实现\"><a href=\"#3-1-Node类实现\" class=\"headerlink\" title=\"3.1 Node类实现\"></a>3.1 Node类实现</h2><p>其实就是在以前的Node类基础上添加了一个指向自己子类的指针link。</p>\n<p>template &lt;class T&gt; class Node<br>{<br>public:<br>T value;<br>Node&lt;T&gt; *next;<br>Node&lt;T&gt; *link;  </p>\n<p>Node(T value) : value(value), next(nullptr), link(nullptr) {}<br>};</p>\n<h2 id=\"3-2-LinkedList类实现\"><a href=\"#3-2-LinkedList类实现\" class=\"headerlink\" title=\"3.2 LinkedList类实现\"></a>3.2 LinkedList类实现</h2><h3 id=\"3-2-1-findFromTree-Node-lt-T-gt-x-T-familyName\"><a href=\"#3-2-1-findFromTree-Node-lt-T-gt-x-T-familyName\" class=\"headerlink\" title=\"3.2.1 findFromTree(Node&lt;T&gt; * x,T familyName)\"></a>3.2.1 findFromTree(Node&lt;T&gt; * x,T familyName)</h3><p>因为该私有函数是其他函数的基础，所以先说它的实现。</p>\n<p>这是一个递归类型的函数，首先，其他函数调用它的时候，基本都会传入家谱的根节点root和要查找人的姓名familyName。然后，该函数的终止条件有两个，一个是在家谱中找到了那个人，那么令curFind指向这个人，并且返回。另一个是整个家谱树中都找不到这个人，即直接返回。（因为每一次调用这个函数时curFind都重置为nullptr，所以这个函数之后，如果没有找到，相当于就是curFind为nullptr，所以之后有一些也可以用这个作为判断依据）。</p>\n<p>而该函数的查找流程是，对于传入的x，先查询它本身是否为这个人，然后再它所有子节点中递归查找，最后再在他之后的兄弟节点中递归查找。</p>\n<p>void findFromTree(Node&lt;T&gt; * x,T familyName)<br>{<br>if(x== nullptr)<br>{<br>return;<br>}<br>if(x-&gt;value==familyName)<br>{<br>curFind = x;<br>return;<br>}<br>findFromTree(x-&gt;link,familyName);<br>for (Node&lt;T&gt; * temp=x-&gt;next;temp!= nullptr;temp=temp-&gt;next)<br>{<br>findFromTree(temp,familyName);<br>}<br>}</p>\n<h3 id=\"3-2-2-add-T-familyRoot\"><a href=\"#3-2-2-add-T-familyRoot\" class=\"headerlink\" title=\"3.2.2 add(T familyRoot)\"></a>3.2.2 add(T familyRoot)</h3><p>该函数往家谱中添加第一个节点，即祖先。</p>\n<p>void add(T familyRoot)<br>{<br>root = new Node&lt;T&gt;(familyRoot);<br>}</p>\n<h3 id=\"3-2-3-add-T-familyName-T-childName\"><a href=\"#3-2-3-add-T-familyName-T-childName\" class=\"headerlink\" title=\"3.2.3 add(T familyName,T childName)\"></a>3.2.3 add(T familyName,T childName)</h3><p>先把curFind置为nullptr，然后调用之前所说的findFromTree函数，把curFind节点指向familyName这个人。如果curFind为nullptr，或者值为-1,(删除函数中会说明)说明查无此人，提示并返回。否则，往这人的link节点（即代表他的子女）后面插入一个名为childName的节点，代表他的孩子。（这里要分一下，如果本来curFind没子节点，就直接增加一个。如果本来有，则要走到curFind子节点的末尾，再在末尾加入该子女childName）。</p>\n<p>void add(T familyName,T childName)<br>{<br>curFind = nullptr;//每次都要重新开始<br>findFromTree(root,familyName);//找到了父节点<br>if(curFind== nullptr || curFind-&gt;value==”-1”)<br>{<br>return;<br>}<br>Node&lt;T&gt; *curChild = curFind-&gt;link;//父节点的子节点,不一定存在<br>if(curChild== nullptr)<br>{<br>curChild = new Node&lt;T&gt;(childName);<br>curFind-&gt;link = curChild;<br>}<br>else<br>{<br>//平行节点<br>Node&lt;T&gt; *x = curChild;<br>while(x-&gt;next!= nullptr)<br>{<br>x = x-&gt;next;<br>}<br>x-&gt;next = new Node&lt;T&gt;(childName);<br>}<br>}</p>\n<h3 id=\"3-2-4-deleteFromTree-T-fatherName\"><a href=\"#3-2-4-deleteFromTree-T-fatherName\" class=\"headerlink\" title=\"3.2.4 deleteFromTree(T fatherName)\"></a>3.2.4 deleteFromTree(T fatherName)</h3><p>该函数作用是将给定人物和他子女都删除。</p>\n<p>首先还是将curFind置为找到的那个人，如果没有找到就提示返回。然后将这个人的值置为“-1”（由于没有前驱指针，所以找不到该人的上一个兄弟，所以采用这种延时删除的操作，当查询或者是其他的，看到了“-1”，就代表了这个人不存在），代表该人已经被删除了。并且将指向他子女的节点置为nullptr，并且将他的子女一一删除。</p>\n<p>void deleteFromTree(T fatherName)<br>{<br>curFind = nullptr;//每次都要重新开始<br>findFromTree(root,fatherName);<br>if(curFind== nullptr || curFind-&gt;value==”-1”)<br>{<br>return;<br>}<br>curFind-&gt;value = “-1”;//延时实现删除操作<br>Node&lt;T&gt; *x=curFind-&gt;link;<br>curFind-&gt;link = nullptr;//子代没了  </p>\n<p>}</p>\n<h3 id=\"3-2-5-update-T-fatherName-T-updateName\"><a href=\"#3-2-5-update-T-fatherName-T-updateName\" class=\"headerlink\" title=\"3.2.5 update(T fatherName,T updateName)\"></a>3.2.5 update(T fatherName,T updateName)</h3><p>该函数主要更新家谱中那个人的姓名。和前面的操作差不多，都是先查找到那个人，找不到就提示并且返回，找到就把找到那个人的名字改了。</p>\n<p>void update(T fatherName,T updateName)<br>{<br>curFind = nullptr;//每次都要重新开始<br>findFromTree(root,fatherName);<br>if(curFind== nullptr || curFind-&gt;value==”-1”)<br>{<br>return;<br>}<br>Node&lt;T&gt; *cur = curFind;<br>cur-&gt;value = updateName;<br>}</p>\n<h3 id=\"3-2-6-show-T-familyName\"><a href=\"#3-2-6-show-T-familyName\" class=\"headerlink\" title=\"3.2.6 show(T familyName)\"></a>3.2.6 show(T familyName)</h3><p>同样是先找到那个人，找不到就提示并且返回，然后对他的所有子女节点进行遍历，如果他的子女节点值不是-1的话，就打印他的值，这样之前所说的延时删除才有了意义。</p>\n<p>同时，用一个变量N记录子女的个数，如果子女个数为0，就打印一条提示信息null，代表该节点没有子女，以免用户在操作时产生困惑。</p>\n<blockquote>\n<p>  void show(T familyName)<br>  {<br>  int N = 0;//子女个数,为了在为空的时候输出一条信息<br>  curFind = nullptr;//每次都要重新开始<br>  findFromTree(root, familyName);<br>  if(curFind== nullptr || curFind-&gt;value==”-1”)<br>  {<br>  return;<br>  }<br>  for (Node&lt;T&gt; * temp=curFind-&gt;link;temp!= nullptr;temp=temp-&gt;next)<br>  {<br>  if(temp-&gt;value!=”-1”)<br>  {<br>  ++N;<br>  cout &lt;&lt; temp-&gt;value &lt;&lt; “ “;<br>  }<br>  }<br>  if(N==0)<br>  {<br>  cout &lt;&lt; “null”&lt;&lt;endl;<br>  }<br>  }</p>\n</blockquote>\n<h3 id=\"3-2-7-findFromTree-T-familyName\"><a href=\"#3-2-7-findFromTree-T-familyName\" class=\"headerlink\" title=\"3.2.7 findFromTree(T familyName)\"></a>3.2.7 findFromTree(T familyName)</h3><p>该函数是为了查看要查找的人在家谱中是否存在，实现很简单，但也很有用。</p>\n<p>通过调用findFromTree函数，如果找到了就返回true，否则返回false。</p>\n<p>bool findFromTree(T familyName)<br>{<br>curFind = nullptr;<br>findFromTree(root, familyName);<br>if(curFind== nullptr || curFind-&gt;value==”-1”)<br>return false;<br>else<br>return true;<br>}</p>\n<h2 id=\"3-3-主函数的实现\"><a href=\"#3-3-主函数的实现\" class=\"headerlink\" title=\"3.3 主函数的实现\"></a>3.3 主函数的实现</h2><h3 id=\"3-3-1-总体系统描述\"><a href=\"#3-3-1-总体系统描述\" class=\"headerlink\" title=\"3.3.1 总体系统描述\"></a>3.3.1 总体系统描述</h3><p>先输出一些用户提示信息。然后让用户输入家谱中的祖先的名字。随后进入一个直到用户主动退出才结束的while循环，让用户选择相应的操作。当用户选择相应的操作后，给出相应的提示，让用户进行相应的输入，程序调用LinkedList类的相应增删改查函数操作，并且把结果输出给用户。因为每个操作大体类似，所以用删除操作举例：</p>\n<p>当用户选择C时，代表要解散家谱中的某个家庭，这时给出提示信息让用户输入要解散的人的名字，然后通过LinkedList类的findFromTree函数判断输入的名字是否存在在家谱中，不存在就打印提示信息并且进入下一个循环选择。如果存在首先通过show函数展示这个人的第一代子孙，并且用deleteFromTree函数输出该人和他的子女。</p>\n<h3 id=\"3-3-2-总体系统核心代码\"><a href=\"#3-3-2-总体系统核心代码\" class=\"headerlink\" title=\"3.3.2 总体系统核心代码\"></a>3.3.2 总体系统核心代码</h3><p>cout&lt;&lt;“请选择要执行的操作:”&lt;&lt;endl;<br>string ops;<br>cin &gt;&gt; ops;<br>while(true)<br>{<br>if(ops==”A”)<br>{<br>string fatherName;<br>int childCount;<br>cout&lt;&lt;“请输入要建立家庭的人的姓名:”;<br>cin &gt;&gt; fatherName;<br>if (families.findFromTree(fatherName))//这个人存在了才继续给他加入子女<br>{<br>cout &lt;&lt; “请输入” &lt;&lt; fatherName &lt;&lt; “的儿女人数：”;<br>cin &gt;&gt; childCount;<br>cout &lt;&lt; “请依次输入” &lt;&lt; fatherName &lt;&lt; “的儿女的姓名”;<br>string childName;<br>for (int i = 0; i &lt; childCount; ++i)<br>{<br>cin &gt;&gt; childName;<br>families.add(fatherName, childName);<br>}<br>cout &lt;&lt; fatherName &lt;&lt; “的第一代子孙是：”;<br>families.show(fatherName);<br>}<br>else<br>{<br>cout &lt;&lt; “该人不存在!”;<br>}<br>}<br>else if(ops==”B”)<br>{<br>cout &lt;&lt; “请输入要添加儿子（或女儿）的人的姓名:”;<br>string fatherName;<br>cin &gt;&gt; fatherName;<br>if (families.findFromTree(fatherName))<br>{<br>cout &lt;&lt; “ 请输入” &lt;&lt; fatherName &lt;&lt; “新添加的儿子（或女儿）的姓名：”;<br>string childName;<br>cin &gt;&gt; childName;<br>families.add(fatherName, childName);<br>cout &lt;&lt; fatherName &lt;&lt; “的第一代子孙是：”;<br>families.show(fatherName);<br>}<br>else<br>{<br>cout &lt;&lt; “该人不存在!”;<br>}<br>}<br>else if(ops==”C”)<br>{<br>cout &lt;&lt; “请输入要解散家庭的人的姓名：”;<br>string fatherName;<br>cin &gt;&gt; fatherName;<br>//删除操作<br>cout &lt;&lt; “要解散家庭的人是”&lt;&lt; fatherName&lt;&lt;endl;<br>if (families.findFromTree(fatherName))<br>{<br>cout &lt;&lt; fatherName &lt;&lt; “的第一代子孙是:”;<br>families.show(fatherName);<br>families.deleteFromTree(fatherName);<br>}<br>else<br>{<br>cout &lt;&lt; “该人不存在!”;<br>}  </p>\n<p>}<br>else if(ops==”D”)<br>{<br>cout &lt;&lt; “请输入更改姓名的人的目前姓名”;<br>string fatherName;<br>cin &gt;&gt; fatherName;<br>if (families.findFromTree(fatherName))<br>{<br>cout &lt;&lt; “请输入更改后的姓名”;<br>string updateName;<br>cin &gt;&gt; updateName;<br>cout &lt;&lt; fatherName &lt;&lt; “已更名为” &lt;&lt;<br>updateName;//不成功的更名也会有这个提示,但是不想弄了<br>families.update(fatherName, updateName);<br>}<br>else<br>{<br>cout &lt;&lt; “该人不存在!”;<br>}<br>}<br>else if(ops==”E”)<br>{<br>string fatherName;<br>cout &lt;&lt; “ 请输入要查询人的姓名：”;<br>cin &gt;&gt; fatherName;<br>if(families.findFromTree(fatherName))<br>{<br>cout &lt;&lt;fatherName&lt;&lt; “的第一代子孙是：”;<br>families.show(fatherName);<br>}<br>else<br>{<br>cout &lt;&lt; “该人不存在!”;<br>}<br>}<br>else if(ops==”F”)<br>{<br>break;<br>}<br>cout&lt;&lt;endl&lt;&lt;“请选择要执行的操作:”&lt;&lt;endl;<br>cin&gt;&gt;ops;<br>}</p>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><h2 id=\"4-1-功能测试\"><a href=\"#4-1-功能测试\" class=\"headerlink\" title=\"4.1 功能测试\"></a>4.1 功能测试</h2><h3 id=\"4-1-1-建立功能测试\"><a href=\"#4-1-1-建立功能测试\" class=\"headerlink\" title=\"4.1.1 建立功能测试\"></a>4.1.1 建立功能测试</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/1ecf880c07339b6f915da76ab1096eac.png\"></p>\n<h3 id=\"4-1-2-插入功能测试\"><a href=\"#4-1-2-插入功能测试\" class=\"headerlink\" title=\"4.1.2 插入功能测试\"></a>4.1.2 插入功能测试</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/5843e748ccae8628603d30aed0a29bb7.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9a42edb88cfcf6fef4846454ef1feb4f.png\"></p>\n<h3 id=\"4-1-3-删除功能测试\"><a href=\"#4-1-3-删除功能测试\" class=\"headerlink\" title=\"4.1.3 删除功能测试\"></a>4.1.3 删除功能测试</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/ef4fe21180570c065692cfcb54e3610e.png\"></p>\n<h3 id=\"4-1-4-查找功能测试\"><a href=\"#4-1-4-查找功能测试\" class=\"headerlink\" title=\"4.1.4 查找功能测试\"></a>4.1.4 查找功能测试</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/65d49c01ab9059b8d0b1a77471de17f1.png\"></p>\n<h3 id=\"4-1-5-修改功能测试\"><a href=\"#4-1-5-修改功能测试\" class=\"headerlink\" title=\"4.1.5 修改功能测试\"></a>4.1.5 修改功能测试</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8abd6aef4a6ea692e70cb21f70c9241a.png\"></p>\n<h2 id=\"4-2-边界测试\"><a href=\"#4-2-边界测试\" class=\"headerlink\" title=\"4.2 边界测试\"></a>4.2 边界测试</h2><h3 id=\"4-2-1-要建立家庭的人不在家谱中\"><a href=\"#4-2-1-要建立家庭的人不在家谱中\" class=\"headerlink\" title=\"4.2.1 要建立家庭的人不在家谱中\"></a>4.2.1 要建立家庭的人不在家谱中</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/cedb11b06c24ec43315dc22aa30a50fa.png\"></p>\n<h3 id=\"4-2-2-要增加子女的人不在家谱中\"><a href=\"#4-2-2-要增加子女的人不在家谱中\" class=\"headerlink\" title=\"4.2.2 要增加子女的人不在家谱中\"></a>4.2.2 要增加子女的人不在家谱中</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/b2f3357e015f8a746a640464b9112c38.png\"></p>\n<h3 id=\"4-2-3-要解散家庭的人不在家谱中\"><a href=\"#4-2-3-要解散家庭的人不在家谱中\" class=\"headerlink\" title=\"4.2.3 要解散家庭的人不在家谱中\"></a>4.2.3 要解散家庭的人不在家谱中</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/0db4755d60b7c6330faff9474dec14fc.png\"></p>\n<h3 id=\"4-2-4-要更改姓名的人不在家谱中\"><a href=\"#4-2-4-要更改姓名的人不在家谱中\" class=\"headerlink\" title=\"4.2.4 要更改姓名的人不在家谱中\"></a>4.2.4 要更改姓名的人不在家谱中</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/cb9e7e7e02487293ff98f1fb483e8431.png\"></p>\n<h3 id=\"4-2-5-要查询的人不在家谱中\"><a href=\"#4-2-5-要查询的人不在家谱中\" class=\"headerlink\" title=\"4.2.5 要查询的人不在家谱中\"></a>4.2.5 要查询的人不在家谱中</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8834a573f1c2c0dcc8a99e2ffd4b21cf.png\"></p>\n"},{"title":"数据结构项目-------算数表达式求解","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习数据结构项目--算数表达式求解所写的文档,用到了栈的相关特性.","abbrlink":"38c2cf7b","date":"2020-01-18T16:00:00.000Z","_content":"# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n>   算数表达式求解\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n\n# 1 分析\n\n## 1.1 项目要求\n\n从键盘上输入中缀算数表达式，包括括号，计算出表达式的值。\n\n程序对所有输入的表达式作简单的判断，如表达式有错，能给出适当的提示。\n\n支持包括加减，乘除取余，乘方和括号等操作符，其中优先级是等于\\<括号\\<加减\\<乘除取余\\<乘方。\n\n能处理单目运算符：+或-。\n\n## 1.2 功能分析\n\n首先,得对输入表达式进行判断,看它是否合理,如果不合理,要指出错误之处;如果是合理的,那么要计算这个表达式的结果并返回。\n\n表达式是否错误根据下面几条进行判断：\n\n>   1.出现了除了+-\\* % / \\^ ()=,数字以外的其他字符\n\n>   2.()匹配不全 或者()里面为空\n\n>   3.表达式没有结束之前出现了=,或者表达式最后不是=\n\n>   4.+-不是开头,或者前方不是( 一目运算符\n\n>   5.运算符前方或者后方无数字或者(),左边为),右边为(,避免(+) 二目运算符\n\n# 2 设计\n\n## 2.1 主函数设计\n\n先输入表达式，调用函数判断表达式是否合理，如果合理，首先将之转换为后续表达式，输出后续表达式的字符串，并且调用函数计算后续表达式，并且打印后续表达式的结果。\n\n（因为之后需要用到栈，所以程序还出现了Stack.h，与Node.h，因为之前的题目也用过，所以这里直接复用之前已经实现的了，不在重新说明。）\n\n## 2.2 isValid()函数设计\n\n大致就是通过循环查看表达式每一个字符来判断表达式是否符合上面几条，如果不合法，就输出对应的提示信息，并且函数返回false，表示表达式有误，直到所有的条件都满足了，才返回true。\n\n主要的难度就是对（）合理性的判断，于是通过许多条件限制来判断是否是合理的表达式，如：左括号右边都没出现右括号；检测到了右括号后，在该处左边的右括号数量大于左括号数量；以及左括号右括号之中没有东西等。\n\n随后，当+-作为单目运算符，或者双目运算符的相关讨论也需要进行比较细致的分类讨论。再对其他运算符进行讨论是否合理。\n\n## 2.3 toPostOrder()函数设计\n\n该函数目的是将之前的那个已经检验过合理性的表达式转为后续表达式，因为后序表达式能直接的计算。大致思路是：用栈存储运算符（char类型），然后遍历传入的字符串，分情况讨论，例如处理一目运算符+-（正负），处理数字，处理左右括号，处理其他运算符等。准备一个string存储后序表达式，如果是数字直接放入，如果是其他，则要小心的判断优先级，当遇到的优先级不断增大时，压入栈中，如果优先级相同,则将所有小于等于他优先级的运算符弹出,再在栈中加入这个运算符。这样就能保证后续表达式优先级正确了。在每个元素之间，还加入了一个空格（如12\n5\n+），这样可以避免出现将之读为125的bug。大致就是这样转换，但是还有许多细节来保证转换正确，这将在函数实现中进行细致讨论。\n\n## 2.4 caculatePostOrder ()函数设计\n\n该函数通过传入一个后续表达式,输出一个int值,代表表达式的结果。主要设计思路是用栈存储数值，遍历后续表达式，如果是数字就把整个数字压入栈中（如遇到19）会把19压入，而不是压入1和9。如果遍历到了操作符，那么就将栈顶两个元素取出并且计算，再压入栈中（因为这时是后续表达式，后续表达式已经把优先级等都考虑好了，所以只要根据符号采取特定的方法计算即可）。遍历完之后将栈顶元素返回，这个即为表达式的值。\n\n# 3 实现\n\n## 3.1 主函数实现\n\n先让用户输入表达式，然后判断合理性，合理的话再打印转换成为后续表达式的字符串，随后打印表达式的结果，最后让用户选择是否结束程序（不这样的话运行exe文件输入完之后就会退出，强制设定退出时间也不太好，所以让用户自己选择）。\n\nint main()  \n{  \nwhile(true)  \n{  \nstring expr,isContinue;  \ncout \\<\\< \"输入表达式：\" \\<\\< endl;  \ngetline(cin,expr);  \nif(isValid(expr))  \n{  \nstring postOrderedExpr=toPostOrder(expr);  \ncout \\<\\<\"后序表达式为:\"\\<\\< postOrderedExpr\\<\\<endl;  \nint result = caculatePostOrder(postOrderedExpr);  \ncout\\<\\<result\\<\\<endl;  \n}  \ncout\\<\\<\"任意键继续,n退出？\";  \ngetline(cin,isContinue);  \nif(isContinue==\"n\")  \n{  \nbreak;  \n}  \n}  \nreturn 0;  \n}\n\n## 3.2 isValid()函数实现\n\n### 3.2.1 简单的判断\n\n对表达式进行遍历（对运算符和左右括号的判断也在遍历表达式的时候进行，只不过为了分节而在下面几节再叙述），如果出现了表达式意外的字符，即既不是数字又不是+-\\*/%\\^=(),则立即提示并且返回。如果表达式没有结束之前出现了=,或者表达式最后不是=，也提示并且返回。\n\nif(expr[i]!='+'&&expr[i]!='-'&&expr[i]!='\\*'&&expr[i]!='/'&&expr[i]!='%'&&expr[i]!='\\^'&&  \nexpr[i]!='('&&expr[i]!=')'&&expr[i]!='='&& !(expr[i]\\<='9'&&expr[i]\\>='0'))  \n{  \ncout\\<\\<\"表达式含有非法字符\"\\<\\<endl;  \nreturn false;  \n}\n\nif(i==N-1 && expr[i]!='=')  \n{  \ncout \\<\\< \"不以=结尾\"\\<\\<endl;  \nreturn false;  \n}  \nif(i!=N-1 && expr[i]=='=')  \n{  \ncout \\<\\< \"表达式中出现了=\"\\<\\<endl;  \nreturn false;  \n}\n\n### 3.2.2 对左右括号的判断\n\n对于每一个左括号，如果它右边位置都没出现右括号则提示并返回，这样能确保有足够的右括号，但是右括号可能多了，于是需要对右括号进行判断。\n\n对于每一个右括号，从该位置计算，如果左边的左括号数量小于了右括号的数量（该右括号也算上），那么是不合理的，则提示并返回。这样对于每一个右括号，都保证它左边有充分的左括号（或许多了，但是经过上面的条件，则符合条件的左右括号应该正好完全匹配）。\n\n还判断了空（）的情况，即左括号右括号之中没有东西，那么也视为不合理，则提示并返回。\n\nif(expr[i]=='(')  \n{  \nif(expr.find(')', i)==-1)  \n{  \ncout\\<\\<\"没有足够的右括号匹配左括号\"\\<\\<endl;  \nreturn false;  \n}  \n}  \nif(expr[i]==')')  \n{  \nint leftCount = 0, rightCount = 0;//()的个数  \nfor (int j = 0; j \\<= i; ++j)  \n{  \nif(expr[j]=='(')  \n{  \n++leftCount;  \n}  \nelse if(expr[j]==')')  \n{  \n++rightCount;  \n}  \n}  \nif(leftCount\\<rightCount)  \n{  \ncout\\<\\<\"没有足够的左括号匹配右括号\"\\<\\<endl;  \nreturn false;  \n}  \n}  \nif(expr[i]=='(' &&i+1\\<N && expr[i+1]==')')  \n{  \ncout\\<\\<\"出现了空()\"\\<\\<endl;  \nreturn false;  \n}\n\n### 3.2.3单目表达式的判断\n\n之所以单独讨论，是因为要以单目运算符，双目运算符来分别讨论。\n\n如果这两个符号是表达式的第一个元素，或者它左边是左括号（这里假定合理的表达式中单目表达式都用括号括起来，如（-1）），则是单目表达式，代表的是正负。而是单目运算符时，他右边可以是一个子表达式（判断条件是它右边第一个元素是左括号），或者是一个数（判断条件是右边第一个字符大于‘0’并且小于‘9’）。否则不合理，则提示并返回。\n\n如果出现的=-不是单目运算符正负，那么再通过左右条件判断是否是合理的双目运算符，即为加减。而这样他们和其他运算符判断方式一样，在下一小节统一叙述。\n\nif(expr[i]=='+' \\|\\| expr[i]=='-')  \n{  \nif(i==0 \\|\\| expr[i-1]=='(')//满足第四点 单目运算符  \n{  \nif(i+1\\<N && ((expr[i+1]=='(')\\|\\|(expr[i+1]\\<='9'&&expr[i+1]\\>='0')))//合理了的  \n{  \n}  \nelse  \n{  \ncout\\<\\<\"+-后面没有数字或者(\"\\<\\<endl;  \nreturn false;  \n}  \n}  \n//i+1存在,并且左边是)或者数字,并且右边是(或者数字  \nelse if(i+1\\<N && (expr[i-1]==')' \\|\\| (expr[i-1]\\<='9'&&expr[i-1]\\>='0'))&&\n((expr[i+1]=='(')\\|\\|(expr[i+1]\\<='9'&&expr[i+1]\\>='0')))//i-1肯定\\>=0,因为上面的条件  \n{  \n\n}  \nelse  \n{  \ncout\\<\\<\"不合理的+-\"\\<\\<endl;  \nreturn false;  \n}  \n}\n\n### 3.2.4 双目表达式的判断\n\n判断很简单，首先，要判断双目表达式的左右两边不是空的，因为双目表达式需要接受两个操作数。然后判断它左右两边是否是子表达式，或者是数字。如果不是这两者之一，就是不合理的双目表达式，则不合理，则提示并返回。\n\nif(expr[i]=='\\^'\\|\\|expr[i]=='%'\\|\\|expr[i]=='\\*'\\|\\|expr[i]=='/')  \n{  \nif(i-1\\>=0 && i+1\\<N && ((expr[i-1]==')' \\|\\|\n(expr[i-1]\\<='9'&&expr[i-1]\\>='0'))&&\n((expr[i+1]=='(')\\|\\|(expr[i+1]\\<='9'&&expr[i+1]\\>='0'))))  \n{  \n//合格  \n}  \nelse  \n{  \ncout\\<\\<\"不合理的\\*/\\^%\"\\<\\<endl;  \nreturn false;  \n}  \n}\n\n## 3.3 toPostOrder()函数实现\n\n### 3.3.1函数描述\n\n用一个map将运算符和他对应的优先级绑定（用数字表示，数字越大优先级越高）。并且准备一个栈存储运算符字符，一个字符串存储整个后续表达式。\n\n开始遍历整个原始的表达式字符串，根据字符的不同采取不同的操作：\n\n>   1.如果是一目运算符=-(正负),(判断是他们的条件是他们是第一个字符或者前方是左括号),如果是+,不处理,如果是-,那么就相当于是0-目标数,例如-5,那么后续表达式就加入0\n>   5\n>   -,这里注意两点,一是,作为负号,优先级是最高的,所以不用考虑其他符号,直接加入即可。二是需要小心的加入空格，如这里必须要是0\n>   5 -，不能是05 -。\n\n>   2.如果是数字，那么用另外的指针记录该位置，该指针循环往后直到找到第一个非数字字符，把整个数字都截取出来加入到后序表达式中，再再后续表达式后面加上一个空格，避免出现原本代表两个数的后续表达式（10\n>   5 +）变成了错误的（105+）。\n\n>   3.处理左括号（，左括号就直接压入栈中，将来作为一个弹栈的标志。\n\n>   4.处理非）的其他字符，因为是按顺序处理下来的，代表前方已经处理了一目运算符，左括号，数字，所以这里的\n>   ！=‘）’\n>   代表了所有其他的双目运算符。首先，如果栈为空的话，直接将该运算符压入栈中，而如果栈不为空，则需要与栈顶元素对比，将所有大于等于该运算符优先级的栈元素依次取出栈，放入后续表达式中，这样就能保证优先级大的总是优先计算，而大于等于的都取出来是因为如果是等于的话，代表前后的优先级是相同的，但是为了从左往右计算，所以需要把左边那个优先级相等的运算符先取出来放入后续表达式中。当确保栈中没有大于等于该运算符的元素后，再将该运算符放入栈中。\n\n>   5.处理右括号）运算符，到这一步时，只需要不断弹栈，不断将栈中运算符加入后续表达式中直到遇到左括号（为止，因为在处理其他运算符时运算符已经按照相应的顺序在栈中或者在后续表达式中摆放好了，所以直接这样处理即可。\n\n>   循环结束后，已经将所有的数字和大部分运算符放入了后续表达式中，但是最后还会有少部分的运算符存在栈中（除非表达式最后一个字符是右括号）），所以此时要把栈中剩余所有元素放入后续表达式中。最后，将后续表达式返回即可。\n\n### 3.3.2 函数代码\n```\nstring toPostOrder(const string & expr)  \n{  \nunordered_map\\<char,int\\> priority;//存储运算符的优先级  \npriority['='] = 1;  \npriority['('] = 2;  \npriority[')'] = 2;  \npriority['+'] = 3;  \npriority['-'] = 3;  \npriority['\\*'] = 4;  \npriority['/'] = 4;  \npriority['%'] = 5;  \npriority['\\^'] = 6;  \nstring postOrderedExpr;  \nStack\\<char\\> ops;//存储运算符的  \nfor (int i = 0; i \\< expr.length(); ++i)  \n{  \n//处理一目运算符  \nif((expr[i]=='+' \\|\\| expr[i]=='-')&&(i == 0 \\|\\| expr[i - 1] ==\n'('))//当作正负来使用时  \n{  \nif(expr[i]=='+')  \n{  \n//忽略他  \n}  \nelse  \n{  \npostOrderedExpr += \"0 \";  \n++i;//将-后面的读入  \npostOrderedExpr += expr[i];  \npostOrderedExpr += \" - \";  \n}  \n\n}  \nelse\nif(expr[i]\\<='9'&&expr[i]\\>='0')//这里需要处理下,就是如果输入大于0-9的数字也能正确处理  \n{  \nint hi = i+1;  \nwhile (true)  \n{  \nif (hi \\< expr.length() && expr[hi] \\<= '9'&&expr[hi] \\>= '0')  \n{  \n++hi;  \n}  \nelse  \n{  \nbreak;  \n}  \n\n}  \n//hi指向的是数字后面的第一个非数字字符  \n//expr.substr(i, hi - i); 得到了数字的字符串  \npostOrderedExpr += expr.substr(i, hi - i);  \npostOrderedExpr += \" \";//避免出现10+5-\\>105+的问题  \ni = hi - 1;  \n}  \nelse if(expr[i]=='(')  \n{  \nops.push(expr[i]);  \n}  \nelse if(expr[i]!=')')//除)外的运算符都压入  \n{  \nif(ops.empty())//栈为空,简单压入即可  \n{  \nops.push(expr[i]);  \n}  \nelse  \n{  \n//需要与栈顶运算符比较优先级  \nint topStackPriority = priority[ops.top()];  \nif(priority[expr[i]]\\>topStackPriority)  \n{  \nops.push(expr[i]);  \n}  \nelse  \n{  \n//优先级相同,必将弹出之前所有小于等于他优先级的运算符,再加入这个运算符  \nwhile(!ops.empty() && priority[expr[i]]\\<=topStackPriority)  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += \" \";  \nops.pop();  \nif(!ops.empty())  \n{  \ntopStackPriority = priority[ops.top()];  \n}  \n}  \n\nops.push(expr[i]);  \n}  \n}  \n}  \nelse if(expr[i]==')')  \n{  \n//表达式检验过,一定正确,所以可以直接这样用  \nwhile(ops.top()!='(')  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += \" \";//避免出现10+5-\\>105+的问题  \nops.pop();  \n}  \nops.pop();//把(弹出去  \n}  \n}  \n//剩下的运算符一起加上  \nwhile(!ops.empty())  \n{  \nif(ops.top()!='=')//不要=  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += \" \";  \n}  \nops.pop();  \n}  \nreturn postOrderedExpr;  \n}\n```\n## 3.4 caculatePostOrder（）的实现\n\n### 3.4.1函数描述\n\n传入一个后续表达式，将计算的结果以int类型返回。\n\n用栈存储int类型数字。对后续表达式进行遍历，如果是数字，同样，得按照和前面一样的方法，将整个数字取出来，如23等，将数字放入栈中。如果是运算符，根据运算符的不同，采取相应的操作，但其实操作是很类似的，都是从栈中取出两个数字，用前面的数采用相应的运算符和后面的数进行计算，并且将运算符重新加入栈中。\n\n因为一目运算符正负=-已经转换为空或者双目运算符，左右括号也去掉，表达式也是合理的了，所以只要这样简单的运算到后续表达式结束即可得到结果，而结果就是栈顶元素。\n\n### 3.4.2 函数代码\n\n（一些重复部分没放上来）\n\nint caculatePostOrder(const string & postOrderedExpr)  \n{  \nStack\\<int\\> nums;  \nfor (int i = 0; i \\< postOrderedExpr.length(); ++i)  \n{  \nif(postOrderedExpr[i]\\<='9'&&postOrderedExpr[i]\\>='0')  \n{  \n//还要考虑处理大于10的数字  \n\nint hi = i + 1;  \nwhile (true)  \n{  \nif (hi \\< postOrderedExpr.length() && postOrderedExpr[hi] \\<=\n'9'&&postOrderedExpr[hi] \\>= '0')  \n{  \n++hi;  \n}  \nelse  \n{  \nbreak;  \n}  \n\n}  \n//hi指向的是数字后面的第一个非数字字符  \n//postOrderedExpr.substr(i, hi - i); 得到了数字的字符串  \n\nnums.push(atoi(postOrderedExpr.substr(i, hi - i).c_str()));  \n\ni = hi - 1;  \n}  \nelse if(postOrderedExpr[i]=='\\^')  \n{  \n//num1为左,num2为右  \nint num2 = nums.top();  \nnums.pop();  \nint num1 = nums.top();  \nnums.pop();  \nnums.push(pow(num1, num2));  \n}  \nelse if(postOrderedExpr[i]=='%')  \n{  \n//num1为左,num2为右  \nint num2 = nums.top();  \nnums.pop();  \nint num1 = nums.top();  \nnums.pop();  \nnums.push(num1%num2);  \n}  \n\n}  \nreturn nums.top();  \n}\n\n# 4 测试\n\n## 4.1 功能测试\n\n### 4.1.1 测试1\n\n**测试用例**：101+222=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3b0feb3db599b29bb40f8324b63a5999.png)\n\n### 4.1.2 测试2\n\n**测试用例：**-2\\*(3+5)+2\\^3/4=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/87e4d36191d5d4540aef89f800956e6c.png)\n\n### 4.1.3 测试3\n\n**测试用例：**5+(-3\\*(-6))=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9e201b33a2306b0f53b4a333b27229b9.png)\n\n### 4.1.4 测试4\n\n**测试用例：** 2\\^4/8-(+2+8)%3=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc08f317871e93a46b5286a9a2f94e89.png)\n\n### 4.1.4 测试5\n\n**测试用例：** 1+(-5\\*3)/(-2)-9/2=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4a5c05685b663cdadd33ad595a0ad38e.png)\n\n### 4.1.4 测试6\n\n**测试用例：** 2\\*101-31\\*24=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/a0e6b9a48eac835cdef546116facb972.png)\n\n## 4.2 非法表达式测试\n\n### 4.2.1 含有非法字符\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/480a0d4c4fb144eef60f6cb52020c9d3.png)\n\n### 4.2.2 左右括号中内容为空\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2ee5ff4b96f3d904342cfb904b4afeaa.png)\n\n### 4.2.3 左右括号不匹配\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/6deba4f18cb7d5abc5a3a1e4f80152fc.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc3dc005e974be2057305ab3f7b57d0a.png)\n\n### 4.2.4 等号位置错误\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f81ada7588a4bc5102ded4253d49193b.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/13e27456b27841991812efd63041ca47.png)\n\n### 4.2.5 正负号不合理\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8beb181f79e57702123cb2496b44e568.png)\n\n### 4.2.6 双目运算符使用不合理\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/275c7a98a4363b5a43f707cb2d1cf470.png)\n","source":"_posts/项目笔记/dataStructureProjects/算数表达式求解.md","raw":"---\ntitle: 数据结构项目-------算数表达式求解\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习数据结构项目--算数表达式求解所写的文档,用到了栈的相关特性.'\ncategories: 项目文档\ntags:\n  - 数据结构\n  - 栈\n  - c++\nabbrlink: 38c2cf7b\ndate: 2020-01-19 00:00:00\n---\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n>   算数表达式求解\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n\n# 1 分析\n\n## 1.1 项目要求\n\n从键盘上输入中缀算数表达式，包括括号，计算出表达式的值。\n\n程序对所有输入的表达式作简单的判断，如表达式有错，能给出适当的提示。\n\n支持包括加减，乘除取余，乘方和括号等操作符，其中优先级是等于\\<括号\\<加减\\<乘除取余\\<乘方。\n\n能处理单目运算符：+或-。\n\n## 1.2 功能分析\n\n首先,得对输入表达式进行判断,看它是否合理,如果不合理,要指出错误之处;如果是合理的,那么要计算这个表达式的结果并返回。\n\n表达式是否错误根据下面几条进行判断：\n\n>   1.出现了除了+-\\* % / \\^ ()=,数字以外的其他字符\n\n>   2.()匹配不全 或者()里面为空\n\n>   3.表达式没有结束之前出现了=,或者表达式最后不是=\n\n>   4.+-不是开头,或者前方不是( 一目运算符\n\n>   5.运算符前方或者后方无数字或者(),左边为),右边为(,避免(+) 二目运算符\n\n# 2 设计\n\n## 2.1 主函数设计\n\n先输入表达式，调用函数判断表达式是否合理，如果合理，首先将之转换为后续表达式，输出后续表达式的字符串，并且调用函数计算后续表达式，并且打印后续表达式的结果。\n\n（因为之后需要用到栈，所以程序还出现了Stack.h，与Node.h，因为之前的题目也用过，所以这里直接复用之前已经实现的了，不在重新说明。）\n\n## 2.2 isValid()函数设计\n\n大致就是通过循环查看表达式每一个字符来判断表达式是否符合上面几条，如果不合法，就输出对应的提示信息，并且函数返回false，表示表达式有误，直到所有的条件都满足了，才返回true。\n\n主要的难度就是对（）合理性的判断，于是通过许多条件限制来判断是否是合理的表达式，如：左括号右边都没出现右括号；检测到了右括号后，在该处左边的右括号数量大于左括号数量；以及左括号右括号之中没有东西等。\n\n随后，当+-作为单目运算符，或者双目运算符的相关讨论也需要进行比较细致的分类讨论。再对其他运算符进行讨论是否合理。\n\n## 2.3 toPostOrder()函数设计\n\n该函数目的是将之前的那个已经检验过合理性的表达式转为后续表达式，因为后序表达式能直接的计算。大致思路是：用栈存储运算符（char类型），然后遍历传入的字符串，分情况讨论，例如处理一目运算符+-（正负），处理数字，处理左右括号，处理其他运算符等。准备一个string存储后序表达式，如果是数字直接放入，如果是其他，则要小心的判断优先级，当遇到的优先级不断增大时，压入栈中，如果优先级相同,则将所有小于等于他优先级的运算符弹出,再在栈中加入这个运算符。这样就能保证后续表达式优先级正确了。在每个元素之间，还加入了一个空格（如12\n5\n+），这样可以避免出现将之读为125的bug。大致就是这样转换，但是还有许多细节来保证转换正确，这将在函数实现中进行细致讨论。\n\n## 2.4 caculatePostOrder ()函数设计\n\n该函数通过传入一个后续表达式,输出一个int值,代表表达式的结果。主要设计思路是用栈存储数值，遍历后续表达式，如果是数字就把整个数字压入栈中（如遇到19）会把19压入，而不是压入1和9。如果遍历到了操作符，那么就将栈顶两个元素取出并且计算，再压入栈中（因为这时是后续表达式，后续表达式已经把优先级等都考虑好了，所以只要根据符号采取特定的方法计算即可）。遍历完之后将栈顶元素返回，这个即为表达式的值。\n\n# 3 实现\n\n## 3.1 主函数实现\n\n先让用户输入表达式，然后判断合理性，合理的话再打印转换成为后续表达式的字符串，随后打印表达式的结果，最后让用户选择是否结束程序（不这样的话运行exe文件输入完之后就会退出，强制设定退出时间也不太好，所以让用户自己选择）。\n\nint main()  \n{  \nwhile(true)  \n{  \nstring expr,isContinue;  \ncout \\<\\< \"输入表达式：\" \\<\\< endl;  \ngetline(cin,expr);  \nif(isValid(expr))  \n{  \nstring postOrderedExpr=toPostOrder(expr);  \ncout \\<\\<\"后序表达式为:\"\\<\\< postOrderedExpr\\<\\<endl;  \nint result = caculatePostOrder(postOrderedExpr);  \ncout\\<\\<result\\<\\<endl;  \n}  \ncout\\<\\<\"任意键继续,n退出？\";  \ngetline(cin,isContinue);  \nif(isContinue==\"n\")  \n{  \nbreak;  \n}  \n}  \nreturn 0;  \n}\n\n## 3.2 isValid()函数实现\n\n### 3.2.1 简单的判断\n\n对表达式进行遍历（对运算符和左右括号的判断也在遍历表达式的时候进行，只不过为了分节而在下面几节再叙述），如果出现了表达式意外的字符，即既不是数字又不是+-\\*/%\\^=(),则立即提示并且返回。如果表达式没有结束之前出现了=,或者表达式最后不是=，也提示并且返回。\n\nif(expr[i]!='+'&&expr[i]!='-'&&expr[i]!='\\*'&&expr[i]!='/'&&expr[i]!='%'&&expr[i]!='\\^'&&  \nexpr[i]!='('&&expr[i]!=')'&&expr[i]!='='&& !(expr[i]\\<='9'&&expr[i]\\>='0'))  \n{  \ncout\\<\\<\"表达式含有非法字符\"\\<\\<endl;  \nreturn false;  \n}\n\nif(i==N-1 && expr[i]!='=')  \n{  \ncout \\<\\< \"不以=结尾\"\\<\\<endl;  \nreturn false;  \n}  \nif(i!=N-1 && expr[i]=='=')  \n{  \ncout \\<\\< \"表达式中出现了=\"\\<\\<endl;  \nreturn false;  \n}\n\n### 3.2.2 对左右括号的判断\n\n对于每一个左括号，如果它右边位置都没出现右括号则提示并返回，这样能确保有足够的右括号，但是右括号可能多了，于是需要对右括号进行判断。\n\n对于每一个右括号，从该位置计算，如果左边的左括号数量小于了右括号的数量（该右括号也算上），那么是不合理的，则提示并返回。这样对于每一个右括号，都保证它左边有充分的左括号（或许多了，但是经过上面的条件，则符合条件的左右括号应该正好完全匹配）。\n\n还判断了空（）的情况，即左括号右括号之中没有东西，那么也视为不合理，则提示并返回。\n\nif(expr[i]=='(')  \n{  \nif(expr.find(')', i)==-1)  \n{  \ncout\\<\\<\"没有足够的右括号匹配左括号\"\\<\\<endl;  \nreturn false;  \n}  \n}  \nif(expr[i]==')')  \n{  \nint leftCount = 0, rightCount = 0;//()的个数  \nfor (int j = 0; j \\<= i; ++j)  \n{  \nif(expr[j]=='(')  \n{  \n++leftCount;  \n}  \nelse if(expr[j]==')')  \n{  \n++rightCount;  \n}  \n}  \nif(leftCount\\<rightCount)  \n{  \ncout\\<\\<\"没有足够的左括号匹配右括号\"\\<\\<endl;  \nreturn false;  \n}  \n}  \nif(expr[i]=='(' &&i+1\\<N && expr[i+1]==')')  \n{  \ncout\\<\\<\"出现了空()\"\\<\\<endl;  \nreturn false;  \n}\n\n### 3.2.3单目表达式的判断\n\n之所以单独讨论，是因为要以单目运算符，双目运算符来分别讨论。\n\n如果这两个符号是表达式的第一个元素，或者它左边是左括号（这里假定合理的表达式中单目表达式都用括号括起来，如（-1）），则是单目表达式，代表的是正负。而是单目运算符时，他右边可以是一个子表达式（判断条件是它右边第一个元素是左括号），或者是一个数（判断条件是右边第一个字符大于‘0’并且小于‘9’）。否则不合理，则提示并返回。\n\n如果出现的=-不是单目运算符正负，那么再通过左右条件判断是否是合理的双目运算符，即为加减。而这样他们和其他运算符判断方式一样，在下一小节统一叙述。\n\nif(expr[i]=='+' \\|\\| expr[i]=='-')  \n{  \nif(i==0 \\|\\| expr[i-1]=='(')//满足第四点 单目运算符  \n{  \nif(i+1\\<N && ((expr[i+1]=='(')\\|\\|(expr[i+1]\\<='9'&&expr[i+1]\\>='0')))//合理了的  \n{  \n}  \nelse  \n{  \ncout\\<\\<\"+-后面没有数字或者(\"\\<\\<endl;  \nreturn false;  \n}  \n}  \n//i+1存在,并且左边是)或者数字,并且右边是(或者数字  \nelse if(i+1\\<N && (expr[i-1]==')' \\|\\| (expr[i-1]\\<='9'&&expr[i-1]\\>='0'))&&\n((expr[i+1]=='(')\\|\\|(expr[i+1]\\<='9'&&expr[i+1]\\>='0')))//i-1肯定\\>=0,因为上面的条件  \n{  \n\n}  \nelse  \n{  \ncout\\<\\<\"不合理的+-\"\\<\\<endl;  \nreturn false;  \n}  \n}\n\n### 3.2.4 双目表达式的判断\n\n判断很简单，首先，要判断双目表达式的左右两边不是空的，因为双目表达式需要接受两个操作数。然后判断它左右两边是否是子表达式，或者是数字。如果不是这两者之一，就是不合理的双目表达式，则不合理，则提示并返回。\n\nif(expr[i]=='\\^'\\|\\|expr[i]=='%'\\|\\|expr[i]=='\\*'\\|\\|expr[i]=='/')  \n{  \nif(i-1\\>=0 && i+1\\<N && ((expr[i-1]==')' \\|\\|\n(expr[i-1]\\<='9'&&expr[i-1]\\>='0'))&&\n((expr[i+1]=='(')\\|\\|(expr[i+1]\\<='9'&&expr[i+1]\\>='0'))))  \n{  \n//合格  \n}  \nelse  \n{  \ncout\\<\\<\"不合理的\\*/\\^%\"\\<\\<endl;  \nreturn false;  \n}  \n}\n\n## 3.3 toPostOrder()函数实现\n\n### 3.3.1函数描述\n\n用一个map将运算符和他对应的优先级绑定（用数字表示，数字越大优先级越高）。并且准备一个栈存储运算符字符，一个字符串存储整个后续表达式。\n\n开始遍历整个原始的表达式字符串，根据字符的不同采取不同的操作：\n\n>   1.如果是一目运算符=-(正负),(判断是他们的条件是他们是第一个字符或者前方是左括号),如果是+,不处理,如果是-,那么就相当于是0-目标数,例如-5,那么后续表达式就加入0\n>   5\n>   -,这里注意两点,一是,作为负号,优先级是最高的,所以不用考虑其他符号,直接加入即可。二是需要小心的加入空格，如这里必须要是0\n>   5 -，不能是05 -。\n\n>   2.如果是数字，那么用另外的指针记录该位置，该指针循环往后直到找到第一个非数字字符，把整个数字都截取出来加入到后序表达式中，再再后续表达式后面加上一个空格，避免出现原本代表两个数的后续表达式（10\n>   5 +）变成了错误的（105+）。\n\n>   3.处理左括号（，左括号就直接压入栈中，将来作为一个弹栈的标志。\n\n>   4.处理非）的其他字符，因为是按顺序处理下来的，代表前方已经处理了一目运算符，左括号，数字，所以这里的\n>   ！=‘）’\n>   代表了所有其他的双目运算符。首先，如果栈为空的话，直接将该运算符压入栈中，而如果栈不为空，则需要与栈顶元素对比，将所有大于等于该运算符优先级的栈元素依次取出栈，放入后续表达式中，这样就能保证优先级大的总是优先计算，而大于等于的都取出来是因为如果是等于的话，代表前后的优先级是相同的，但是为了从左往右计算，所以需要把左边那个优先级相等的运算符先取出来放入后续表达式中。当确保栈中没有大于等于该运算符的元素后，再将该运算符放入栈中。\n\n>   5.处理右括号）运算符，到这一步时，只需要不断弹栈，不断将栈中运算符加入后续表达式中直到遇到左括号（为止，因为在处理其他运算符时运算符已经按照相应的顺序在栈中或者在后续表达式中摆放好了，所以直接这样处理即可。\n\n>   循环结束后，已经将所有的数字和大部分运算符放入了后续表达式中，但是最后还会有少部分的运算符存在栈中（除非表达式最后一个字符是右括号）），所以此时要把栈中剩余所有元素放入后续表达式中。最后，将后续表达式返回即可。\n\n### 3.3.2 函数代码\n```\nstring toPostOrder(const string & expr)  \n{  \nunordered_map\\<char,int\\> priority;//存储运算符的优先级  \npriority['='] = 1;  \npriority['('] = 2;  \npriority[')'] = 2;  \npriority['+'] = 3;  \npriority['-'] = 3;  \npriority['\\*'] = 4;  \npriority['/'] = 4;  \npriority['%'] = 5;  \npriority['\\^'] = 6;  \nstring postOrderedExpr;  \nStack\\<char\\> ops;//存储运算符的  \nfor (int i = 0; i \\< expr.length(); ++i)  \n{  \n//处理一目运算符  \nif((expr[i]=='+' \\|\\| expr[i]=='-')&&(i == 0 \\|\\| expr[i - 1] ==\n'('))//当作正负来使用时  \n{  \nif(expr[i]=='+')  \n{  \n//忽略他  \n}  \nelse  \n{  \npostOrderedExpr += \"0 \";  \n++i;//将-后面的读入  \npostOrderedExpr += expr[i];  \npostOrderedExpr += \" - \";  \n}  \n\n}  \nelse\nif(expr[i]\\<='9'&&expr[i]\\>='0')//这里需要处理下,就是如果输入大于0-9的数字也能正确处理  \n{  \nint hi = i+1;  \nwhile (true)  \n{  \nif (hi \\< expr.length() && expr[hi] \\<= '9'&&expr[hi] \\>= '0')  \n{  \n++hi;  \n}  \nelse  \n{  \nbreak;  \n}  \n\n}  \n//hi指向的是数字后面的第一个非数字字符  \n//expr.substr(i, hi - i); 得到了数字的字符串  \npostOrderedExpr += expr.substr(i, hi - i);  \npostOrderedExpr += \" \";//避免出现10+5-\\>105+的问题  \ni = hi - 1;  \n}  \nelse if(expr[i]=='(')  \n{  \nops.push(expr[i]);  \n}  \nelse if(expr[i]!=')')//除)外的运算符都压入  \n{  \nif(ops.empty())//栈为空,简单压入即可  \n{  \nops.push(expr[i]);  \n}  \nelse  \n{  \n//需要与栈顶运算符比较优先级  \nint topStackPriority = priority[ops.top()];  \nif(priority[expr[i]]\\>topStackPriority)  \n{  \nops.push(expr[i]);  \n}  \nelse  \n{  \n//优先级相同,必将弹出之前所有小于等于他优先级的运算符,再加入这个运算符  \nwhile(!ops.empty() && priority[expr[i]]\\<=topStackPriority)  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += \" \";  \nops.pop();  \nif(!ops.empty())  \n{  \ntopStackPriority = priority[ops.top()];  \n}  \n}  \n\nops.push(expr[i]);  \n}  \n}  \n}  \nelse if(expr[i]==')')  \n{  \n//表达式检验过,一定正确,所以可以直接这样用  \nwhile(ops.top()!='(')  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += \" \";//避免出现10+5-\\>105+的问题  \nops.pop();  \n}  \nops.pop();//把(弹出去  \n}  \n}  \n//剩下的运算符一起加上  \nwhile(!ops.empty())  \n{  \nif(ops.top()!='=')//不要=  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += \" \";  \n}  \nops.pop();  \n}  \nreturn postOrderedExpr;  \n}\n```\n## 3.4 caculatePostOrder（）的实现\n\n### 3.4.1函数描述\n\n传入一个后续表达式，将计算的结果以int类型返回。\n\n用栈存储int类型数字。对后续表达式进行遍历，如果是数字，同样，得按照和前面一样的方法，将整个数字取出来，如23等，将数字放入栈中。如果是运算符，根据运算符的不同，采取相应的操作，但其实操作是很类似的，都是从栈中取出两个数字，用前面的数采用相应的运算符和后面的数进行计算，并且将运算符重新加入栈中。\n\n因为一目运算符正负=-已经转换为空或者双目运算符，左右括号也去掉，表达式也是合理的了，所以只要这样简单的运算到后续表达式结束即可得到结果，而结果就是栈顶元素。\n\n### 3.4.2 函数代码\n\n（一些重复部分没放上来）\n\nint caculatePostOrder(const string & postOrderedExpr)  \n{  \nStack\\<int\\> nums;  \nfor (int i = 0; i \\< postOrderedExpr.length(); ++i)  \n{  \nif(postOrderedExpr[i]\\<='9'&&postOrderedExpr[i]\\>='0')  \n{  \n//还要考虑处理大于10的数字  \n\nint hi = i + 1;  \nwhile (true)  \n{  \nif (hi \\< postOrderedExpr.length() && postOrderedExpr[hi] \\<=\n'9'&&postOrderedExpr[hi] \\>= '0')  \n{  \n++hi;  \n}  \nelse  \n{  \nbreak;  \n}  \n\n}  \n//hi指向的是数字后面的第一个非数字字符  \n//postOrderedExpr.substr(i, hi - i); 得到了数字的字符串  \n\nnums.push(atoi(postOrderedExpr.substr(i, hi - i).c_str()));  \n\ni = hi - 1;  \n}  \nelse if(postOrderedExpr[i]=='\\^')  \n{  \n//num1为左,num2为右  \nint num2 = nums.top();  \nnums.pop();  \nint num1 = nums.top();  \nnums.pop();  \nnums.push(pow(num1, num2));  \n}  \nelse if(postOrderedExpr[i]=='%')  \n{  \n//num1为左,num2为右  \nint num2 = nums.top();  \nnums.pop();  \nint num1 = nums.top();  \nnums.pop();  \nnums.push(num1%num2);  \n}  \n\n}  \nreturn nums.top();  \n}\n\n# 4 测试\n\n## 4.1 功能测试\n\n### 4.1.1 测试1\n\n**测试用例**：101+222=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/3b0feb3db599b29bb40f8324b63a5999.png)\n\n### 4.1.2 测试2\n\n**测试用例：**-2\\*(3+5)+2\\^3/4=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/87e4d36191d5d4540aef89f800956e6c.png)\n\n### 4.1.3 测试3\n\n**测试用例：**5+(-3\\*(-6))=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/9e201b33a2306b0f53b4a333b27229b9.png)\n\n### 4.1.4 测试4\n\n**测试用例：** 2\\^4/8-(+2+8)%3=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc08f317871e93a46b5286a9a2f94e89.png)\n\n### 4.1.4 测试5\n\n**测试用例：** 1+(-5\\*3)/(-2)-9/2=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4a5c05685b663cdadd33ad595a0ad38e.png)\n\n### 4.1.4 测试6\n\n**测试用例：** 2\\*101-31\\*24=\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/a0e6b9a48eac835cdef546116facb972.png)\n\n## 4.2 非法表达式测试\n\n### 4.2.1 含有非法字符\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/480a0d4c4fb144eef60f6cb52020c9d3.png)\n\n### 4.2.2 左右括号中内容为空\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/2ee5ff4b96f3d904342cfb904b4afeaa.png)\n\n### 4.2.3 左右括号不匹配\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/6deba4f18cb7d5abc5a3a1e4f80152fc.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc3dc005e974be2057305ab3f7b57d0a.png)\n\n### 4.2.4 等号位置错误\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f81ada7588a4bc5102ded4253d49193b.png)\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/13e27456b27841991812efd63041ca47.png)\n\n### 4.2.5 正负号不合理\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/8beb181f79e57702123cb2496b44e568.png)\n\n### 4.2.6 双目运算符使用不合理\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/275c7a98a4363b5a43f707cb2d1cf470.png)\n","slug":"项目笔记/dataStructureProjects/算数表达式求解","published":1,"updated":"2020-11-12T11:57:30.409Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o73z00oxjotpaa2n0gxb","content":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  算数表达式求解</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目要求\"><a href=\"#1-1-项目要求\" class=\"headerlink\" title=\"1.1 项目要求\"></a>1.1 项目要求</h2><p>从键盘上输入中缀算数表达式，包括括号，计算出表达式的值。</p>\n<p>程序对所有输入的表达式作简单的判断，如表达式有错，能给出适当的提示。</p>\n<p>支持包括加减，乘除取余，乘方和括号等操作符，其中优先级是等于&lt;括号&lt;加减&lt;乘除取余&lt;乘方。</p>\n<p>能处理单目运算符：+或-。</p>\n<h2 id=\"1-2-功能分析\"><a href=\"#1-2-功能分析\" class=\"headerlink\" title=\"1.2 功能分析\"></a>1.2 功能分析</h2><p>首先,得对输入表达式进行判断,看它是否合理,如果不合理,要指出错误之处;如果是合理的,那么要计算这个表达式的结果并返回。</p>\n<p>表达式是否错误根据下面几条进行判断：</p>\n<blockquote>\n<p>  1.出现了除了+-* % / ^ ()=,数字以外的其他字符</p>\n</blockquote>\n<blockquote>\n<p>  2.()匹配不全 或者()里面为空</p>\n</blockquote>\n<blockquote>\n<p>  3.表达式没有结束之前出现了=,或者表达式最后不是=</p>\n</blockquote>\n<blockquote>\n<p>  4.+-不是开头,或者前方不是( 一目运算符</p>\n</blockquote>\n<blockquote>\n<p>  5.运算符前方或者后方无数字或者(),左边为),右边为(,避免(+) 二目运算符</p>\n</blockquote>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-主函数设计\"><a href=\"#2-1-主函数设计\" class=\"headerlink\" title=\"2.1 主函数设计\"></a>2.1 主函数设计</h2><p>先输入表达式，调用函数判断表达式是否合理，如果合理，首先将之转换为后续表达式，输出后续表达式的字符串，并且调用函数计算后续表达式，并且打印后续表达式的结果。</p>\n<p>（因为之后需要用到栈，所以程序还出现了Stack.h，与Node.h，因为之前的题目也用过，所以这里直接复用之前已经实现的了，不在重新说明。）</p>\n<h2 id=\"2-2-isValid-函数设计\"><a href=\"#2-2-isValid-函数设计\" class=\"headerlink\" title=\"2.2 isValid()函数设计\"></a>2.2 isValid()函数设计</h2><p>大致就是通过循环查看表达式每一个字符来判断表达式是否符合上面几条，如果不合法，就输出对应的提示信息，并且函数返回false，表示表达式有误，直到所有的条件都满足了，才返回true。</p>\n<p>主要的难度就是对（）合理性的判断，于是通过许多条件限制来判断是否是合理的表达式，如：左括号右边都没出现右括号；检测到了右括号后，在该处左边的右括号数量大于左括号数量；以及左括号右括号之中没有东西等。</p>\n<p>随后，当+-作为单目运算符，或者双目运算符的相关讨论也需要进行比较细致的分类讨论。再对其他运算符进行讨论是否合理。</p>\n<h2 id=\"2-3-toPostOrder-函数设计\"><a href=\"#2-3-toPostOrder-函数设计\" class=\"headerlink\" title=\"2.3 toPostOrder()函数设计\"></a>2.3 toPostOrder()函数设计</h2><p>该函数目的是将之前的那个已经检验过合理性的表达式转为后续表达式，因为后序表达式能直接的计算。大致思路是：用栈存储运算符（char类型），然后遍历传入的字符串，分情况讨论，例如处理一目运算符+-（正负），处理数字，处理左右括号，处理其他运算符等。准备一个string存储后序表达式，如果是数字直接放入，如果是其他，则要小心的判断优先级，当遇到的优先级不断增大时，压入栈中，如果优先级相同,则将所有小于等于他优先级的运算符弹出,再在栈中加入这个运算符。这样就能保证后续表达式优先级正确了。在每个元素之间，还加入了一个空格（如12<br>5<br>+），这样可以避免出现将之读为125的bug。大致就是这样转换，但是还有许多细节来保证转换正确，这将在函数实现中进行细致讨论。</p>\n<h2 id=\"2-4-caculatePostOrder-函数设计\"><a href=\"#2-4-caculatePostOrder-函数设计\" class=\"headerlink\" title=\"2.4 caculatePostOrder ()函数设计\"></a>2.4 caculatePostOrder ()函数设计</h2><p>该函数通过传入一个后续表达式,输出一个int值,代表表达式的结果。主要设计思路是用栈存储数值，遍历后续表达式，如果是数字就把整个数字压入栈中（如遇到19）会把19压入，而不是压入1和9。如果遍历到了操作符，那么就将栈顶两个元素取出并且计算，再压入栈中（因为这时是后续表达式，后续表达式已经把优先级等都考虑好了，所以只要根据符号采取特定的方法计算即可）。遍历完之后将栈顶元素返回，这个即为表达式的值。</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-主函数实现\"><a href=\"#3-1-主函数实现\" class=\"headerlink\" title=\"3.1 主函数实现\"></a>3.1 主函数实现</h2><p>先让用户输入表达式，然后判断合理性，合理的话再打印转换成为后续表达式的字符串，随后打印表达式的结果，最后让用户选择是否结束程序（不这样的话运行exe文件输入完之后就会退出，强制设定退出时间也不太好，所以让用户自己选择）。</p>\n<p>int main()<br>{<br>while(true)<br>{<br>string expr,isContinue;<br>cout &lt;&lt; “输入表达式：” &lt;&lt; endl;<br>getline(cin,expr);<br>if(isValid(expr))<br>{<br>string postOrderedExpr=toPostOrder(expr);<br>cout &lt;&lt;“后序表达式为:”&lt;&lt; postOrderedExpr&lt;&lt;endl;<br>int result = caculatePostOrder(postOrderedExpr);<br>cout&lt;&lt;result&lt;&lt;endl;<br>}<br>cout&lt;&lt;“任意键继续,n退出？”;<br>getline(cin,isContinue);<br>if(isContinue==”n”)<br>{<br>break;<br>}<br>}<br>return 0;<br>}</p>\n<h2 id=\"3-2-isValid-函数实现\"><a href=\"#3-2-isValid-函数实现\" class=\"headerlink\" title=\"3.2 isValid()函数实现\"></a>3.2 isValid()函数实现</h2><h3 id=\"3-2-1-简单的判断\"><a href=\"#3-2-1-简单的判断\" class=\"headerlink\" title=\"3.2.1 简单的判断\"></a>3.2.1 简单的判断</h3><p>对表达式进行遍历（对运算符和左右括号的判断也在遍历表达式的时候进行，只不过为了分节而在下面几节再叙述），如果出现了表达式意外的字符，即既不是数字又不是+-*/%^=(),则立即提示并且返回。如果表达式没有结束之前出现了=,或者表达式最后不是=，也提示并且返回。</p>\n<p>if(expr[i]!=’+’&amp;&amp;expr[i]!=’-‘&amp;&amp;expr[i]!=’*‘&amp;&amp;expr[i]!=’/‘&amp;&amp;expr[i]!=’%’&amp;&amp;expr[i]!=’^‘&amp;&amp;<br>expr[i]!=’(‘&amp;&amp;expr[i]!=’)’&amp;&amp;expr[i]!=’=’&amp;&amp; !(expr[i]&lt;=’9’&amp;&amp;expr[i]&gt;=’0’))<br>{<br>cout&lt;&lt;“表达式含有非法字符”&lt;&lt;endl;<br>return false;<br>}</p>\n<p>if(i==N-1 &amp;&amp; expr[i]!=’=’)<br>{<br>cout &lt;&lt; “不以=结尾”&lt;&lt;endl;<br>return false;<br>}<br>if(i!=N-1 &amp;&amp; expr[i]==’=’)<br>{<br>cout &lt;&lt; “表达式中出现了=”&lt;&lt;endl;<br>return false;<br>}</p>\n<h3 id=\"3-2-2-对左右括号的判断\"><a href=\"#3-2-2-对左右括号的判断\" class=\"headerlink\" title=\"3.2.2 对左右括号的判断\"></a>3.2.2 对左右括号的判断</h3><p>对于每一个左括号，如果它右边位置都没出现右括号则提示并返回，这样能确保有足够的右括号，但是右括号可能多了，于是需要对右括号进行判断。</p>\n<p>对于每一个右括号，从该位置计算，如果左边的左括号数量小于了右括号的数量（该右括号也算上），那么是不合理的，则提示并返回。这样对于每一个右括号，都保证它左边有充分的左括号（或许多了，但是经过上面的条件，则符合条件的左右括号应该正好完全匹配）。</p>\n<p>还判断了空（）的情况，即左括号右括号之中没有东西，那么也视为不合理，则提示并返回。</p>\n<p>if(expr[i]==’(‘)<br>{<br>if(expr.find(‘)’, i)==-1)<br>{<br>cout&lt;&lt;“没有足够的右括号匹配左括号”&lt;&lt;endl;<br>return false;<br>}<br>}<br>if(expr[i]==’)’)<br>{<br>int leftCount = 0, rightCount = 0;//()的个数<br>for (int j = 0; j &lt;= i; ++j)<br>{<br>if(expr[j]==’(‘)<br>{<br>++leftCount;<br>}<br>else if(expr[j]==’)’)<br>{<br>++rightCount;<br>}<br>}<br>if(leftCount&lt;rightCount)<br>{<br>cout&lt;&lt;“没有足够的左括号匹配右括号”&lt;&lt;endl;<br>return false;<br>}<br>}<br>if(expr[i]==’(‘ &amp;&amp;i+1&lt;N &amp;&amp; expr[i+1]==’)’)<br>{<br>cout&lt;&lt;“出现了空()”&lt;&lt;endl;<br>return false;<br>}</p>\n<h3 id=\"3-2-3单目表达式的判断\"><a href=\"#3-2-3单目表达式的判断\" class=\"headerlink\" title=\"3.2.3单目表达式的判断\"></a>3.2.3单目表达式的判断</h3><p>之所以单独讨论，是因为要以单目运算符，双目运算符来分别讨论。</p>\n<p>如果这两个符号是表达式的第一个元素，或者它左边是左括号（这里假定合理的表达式中单目表达式都用括号括起来，如（-1）），则是单目表达式，代表的是正负。而是单目运算符时，他右边可以是一个子表达式（判断条件是它右边第一个元素是左括号），或者是一个数（判断条件是右边第一个字符大于‘0’并且小于‘9’）。否则不合理，则提示并返回。</p>\n<p>如果出现的=-不是单目运算符正负，那么再通过左右条件判断是否是合理的双目运算符，即为加减。而这样他们和其他运算符判断方式一样，在下一小节统一叙述。</p>\n<p>if(expr[i]==’+’ || expr[i]==’-‘)<br>{<br>if(i==0 || expr[i-1]==’(‘)//满足第四点 单目运算符<br>{<br>if(i+1&lt;N &amp;&amp; ((expr[i+1]==’(‘)||(expr[i+1]&lt;=’9’&amp;&amp;expr[i+1]&gt;=’0’)))//合理了的<br>{<br>}<br>else<br>{<br>cout&lt;&lt;“+-后面没有数字或者(“&lt;&lt;endl;<br>return false;<br>}<br>}<br>//i+1存在,并且左边是)或者数字,并且右边是(或者数字<br>else if(i+1&lt;N &amp;&amp; (expr[i-1]==’)’ || (expr[i-1]&lt;=’9’&amp;&amp;expr[i-1]&gt;=’0’))&amp;&amp;<br>((expr[i+1]==’(‘)||(expr[i+1]&lt;=’9’&amp;&amp;expr[i+1]&gt;=’0’)))//i-1肯定&gt;=0,因为上面的条件<br>{  </p>\n<p>}<br>else<br>{<br>cout&lt;&lt;“不合理的+-“&lt;&lt;endl;<br>return false;<br>}<br>}</p>\n<h3 id=\"3-2-4-双目表达式的判断\"><a href=\"#3-2-4-双目表达式的判断\" class=\"headerlink\" title=\"3.2.4 双目表达式的判断\"></a>3.2.4 双目表达式的判断</h3><p>判断很简单，首先，要判断双目表达式的左右两边不是空的，因为双目表达式需要接受两个操作数。然后判断它左右两边是否是子表达式，或者是数字。如果不是这两者之一，就是不合理的双目表达式，则不合理，则提示并返回。</p>\n<p>if(expr[i]==’^‘||expr[i]==’%’||expr[i]==’*‘||expr[i]==’/‘)<br>{<br>if(i-1&gt;=0 &amp;&amp; i+1&lt;N &amp;&amp; ((expr[i-1]==’)’ ||<br>(expr[i-1]&lt;=’9’&amp;&amp;expr[i-1]&gt;=’0’))&amp;&amp;<br>((expr[i+1]==’(‘)||(expr[i+1]&lt;=’9’&amp;&amp;expr[i+1]&gt;=’0’))))<br>{<br>//合格<br>}<br>else<br>{<br>cout&lt;&lt;“不合理的*/^%”&lt;&lt;endl;<br>return false;<br>}<br>}</p>\n<h2 id=\"3-3-toPostOrder-函数实现\"><a href=\"#3-3-toPostOrder-函数实现\" class=\"headerlink\" title=\"3.3 toPostOrder()函数实现\"></a>3.3 toPostOrder()函数实现</h2><h3 id=\"3-3-1函数描述\"><a href=\"#3-3-1函数描述\" class=\"headerlink\" title=\"3.3.1函数描述\"></a>3.3.1函数描述</h3><p>用一个map将运算符和他对应的优先级绑定（用数字表示，数字越大优先级越高）。并且准备一个栈存储运算符字符，一个字符串存储整个后续表达式。</p>\n<p>开始遍历整个原始的表达式字符串，根据字符的不同采取不同的操作：</p>\n<blockquote>\n<p>  1.如果是一目运算符=-(正负),(判断是他们的条件是他们是第一个字符或者前方是左括号),如果是+,不处理,如果是-,那么就相当于是0-目标数,例如-5,那么后续表达式就加入0<br>  5<br>  -,这里注意两点,一是,作为负号,优先级是最高的,所以不用考虑其他符号,直接加入即可。二是需要小心的加入空格，如这里必须要是0<br>  5 -，不能是05 -。</p>\n</blockquote>\n<blockquote>\n<p>  2.如果是数字，那么用另外的指针记录该位置，该指针循环往后直到找到第一个非数字字符，把整个数字都截取出来加入到后序表达式中，再再后续表达式后面加上一个空格，避免出现原本代表两个数的后续表达式（10<br>  5 +）变成了错误的（105+）。</p>\n</blockquote>\n<blockquote>\n<p>  3.处理左括号（，左括号就直接压入栈中，将来作为一个弹栈的标志。</p>\n</blockquote>\n<blockquote>\n<p>  4.处理非）的其他字符，因为是按顺序处理下来的，代表前方已经处理了一目运算符，左括号，数字，所以这里的<br>  ！=‘）’<br>  代表了所有其他的双目运算符。首先，如果栈为空的话，直接将该运算符压入栈中，而如果栈不为空，则需要与栈顶元素对比，将所有大于等于该运算符优先级的栈元素依次取出栈，放入后续表达式中，这样就能保证优先级大的总是优先计算，而大于等于的都取出来是因为如果是等于的话，代表前后的优先级是相同的，但是为了从左往右计算，所以需要把左边那个优先级相等的运算符先取出来放入后续表达式中。当确保栈中没有大于等于该运算符的元素后，再将该运算符放入栈中。</p>\n</blockquote>\n<blockquote>\n<p>  5.处理右括号）运算符，到这一步时，只需要不断弹栈，不断将栈中运算符加入后续表达式中直到遇到左括号（为止，因为在处理其他运算符时运算符已经按照相应的顺序在栈中或者在后续表达式中摆放好了，所以直接这样处理即可。</p>\n</blockquote>\n<blockquote>\n<p>  循环结束后，已经将所有的数字和大部分运算符放入了后续表达式中，但是最后还会有少部分的运算符存在栈中（除非表达式最后一个字符是右括号）），所以此时要把栈中剩余所有元素放入后续表达式中。最后，将后续表达式返回即可。</p>\n</blockquote>\n<h3 id=\"3-3-2-函数代码\"><a href=\"#3-3-2-函数代码\" class=\"headerlink\" title=\"3.3.2 函数代码\"></a>3.3.2 函数代码</h3><pre><code>string toPostOrder(const string &amp; expr)  \n{  \nunordered_map\\&lt;char,int\\&gt; priority;//存储运算符的优先级  \npriority[&#39;=&#39;] = 1;  \npriority[&#39;(&#39;] = 2;  \npriority[&#39;)&#39;] = 2;  \npriority[&#39;+&#39;] = 3;  \npriority[&#39;-&#39;] = 3;  \npriority[&#39;\\*&#39;] = 4;  \npriority[&#39;/&#39;] = 4;  \npriority[&#39;%&#39;] = 5;  \npriority[&#39;\\^&#39;] = 6;  \nstring postOrderedExpr;  \nStack\\&lt;char\\&gt; ops;//存储运算符的  \nfor (int i = 0; i \\&lt; expr.length(); ++i)  \n{  \n//处理一目运算符  \nif((expr[i]==&#39;+&#39; \\|\\| expr[i]==&#39;-&#39;)&amp;&amp;(i == 0 \\|\\| expr[i - 1] ==\n&#39;(&#39;))//当作正负来使用时  \n{  \nif(expr[i]==&#39;+&#39;)  \n{  \n//忽略他  \n}  \nelse  \n{  \npostOrderedExpr += &quot;0 &quot;;  \n++i;//将-后面的读入  \npostOrderedExpr += expr[i];  \npostOrderedExpr += &quot; - &quot;;  \n}  \n\n}  \nelse\nif(expr[i]\\&lt;=&#39;9&#39;&amp;&amp;expr[i]\\&gt;=&#39;0&#39;)//这里需要处理下,就是如果输入大于0-9的数字也能正确处理  \n{  \nint hi = i+1;  \nwhile (true)  \n{  \nif (hi \\&lt; expr.length() &amp;&amp; expr[hi] \\&lt;= &#39;9&#39;&amp;&amp;expr[hi] \\&gt;= &#39;0&#39;)  \n{  \n++hi;  \n}  \nelse  \n{  \nbreak;  \n}  \n\n}  \n//hi指向的是数字后面的第一个非数字字符  \n//expr.substr(i, hi - i); 得到了数字的字符串  \npostOrderedExpr += expr.substr(i, hi - i);  \npostOrderedExpr += &quot; &quot;;//避免出现10+5-\\&gt;105+的问题  \ni = hi - 1;  \n}  \nelse if(expr[i]==&#39;(&#39;)  \n{  \nops.push(expr[i]);  \n}  \nelse if(expr[i]!=&#39;)&#39;)//除)外的运算符都压入  \n{  \nif(ops.empty())//栈为空,简单压入即可  \n{  \nops.push(expr[i]);  \n}  \nelse  \n{  \n//需要与栈顶运算符比较优先级  \nint topStackPriority = priority[ops.top()];  \nif(priority[expr[i]]\\&gt;topStackPriority)  \n{  \nops.push(expr[i]);  \n}  \nelse  \n{  \n//优先级相同,必将弹出之前所有小于等于他优先级的运算符,再加入这个运算符  \nwhile(!ops.empty() &amp;&amp; priority[expr[i]]\\&lt;=topStackPriority)  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += &quot; &quot;;  \nops.pop();  \nif(!ops.empty())  \n{  \ntopStackPriority = priority[ops.top()];  \n}  \n}  \n\nops.push(expr[i]);  \n}  \n}  \n}  \nelse if(expr[i]==&#39;)&#39;)  \n{  \n//表达式检验过,一定正确,所以可以直接这样用  \nwhile(ops.top()!=&#39;(&#39;)  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += &quot; &quot;;//避免出现10+5-\\&gt;105+的问题  \nops.pop();  \n}  \nops.pop();//把(弹出去  \n}  \n}  \n//剩下的运算符一起加上  \nwhile(!ops.empty())  \n{  \nif(ops.top()!=&#39;=&#39;)//不要=  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += &quot; &quot;;  \n}  \nops.pop();  \n}  \nreturn postOrderedExpr;  \n}</code></pre>\n<h2 id=\"3-4-caculatePostOrder（）的实现\"><a href=\"#3-4-caculatePostOrder（）的实现\" class=\"headerlink\" title=\"3.4 caculatePostOrder（）的实现\"></a>3.4 caculatePostOrder（）的实现</h2><h3 id=\"3-4-1函数描述\"><a href=\"#3-4-1函数描述\" class=\"headerlink\" title=\"3.4.1函数描述\"></a>3.4.1函数描述</h3><p>传入一个后续表达式，将计算的结果以int类型返回。</p>\n<p>用栈存储int类型数字。对后续表达式进行遍历，如果是数字，同样，得按照和前面一样的方法，将整个数字取出来，如23等，将数字放入栈中。如果是运算符，根据运算符的不同，采取相应的操作，但其实操作是很类似的，都是从栈中取出两个数字，用前面的数采用相应的运算符和后面的数进行计算，并且将运算符重新加入栈中。</p>\n<p>因为一目运算符正负=-已经转换为空或者双目运算符，左右括号也去掉，表达式也是合理的了，所以只要这样简单的运算到后续表达式结束即可得到结果，而结果就是栈顶元素。</p>\n<h3 id=\"3-4-2-函数代码\"><a href=\"#3-4-2-函数代码\" class=\"headerlink\" title=\"3.4.2 函数代码\"></a>3.4.2 函数代码</h3><p>（一些重复部分没放上来）</p>\n<p>int caculatePostOrder(const string &amp; postOrderedExpr)<br>{<br>Stack&lt;int&gt; nums;<br>for (int i = 0; i &lt; postOrderedExpr.length(); ++i)<br>{<br>if(postOrderedExpr[i]&lt;=’9’&amp;&amp;postOrderedExpr[i]&gt;=’0’)<br>{<br>//还要考虑处理大于10的数字  </p>\n<p>int hi = i + 1;<br>while (true)<br>{<br>if (hi &lt; postOrderedExpr.length() &amp;&amp; postOrderedExpr[hi] &lt;=<br>‘9’&amp;&amp;postOrderedExpr[hi] &gt;= ‘0’)<br>{<br>++hi;<br>}<br>else<br>{<br>break;<br>}  </p>\n<p>}<br>//hi指向的是数字后面的第一个非数字字符<br>//postOrderedExpr.substr(i, hi - i); 得到了数字的字符串  </p>\n<p>nums.push(atoi(postOrderedExpr.substr(i, hi - i).c_str()));  </p>\n<p>i = hi - 1;<br>}<br>else if(postOrderedExpr[i]==’^‘)<br>{<br>//num1为左,num2为右<br>int num2 = nums.top();<br>nums.pop();<br>int num1 = nums.top();<br>nums.pop();<br>nums.push(pow(num1, num2));<br>}<br>else if(postOrderedExpr[i]==’%’)<br>{<br>//num1为左,num2为右<br>int num2 = nums.top();<br>nums.pop();<br>int num1 = nums.top();<br>nums.pop();<br>nums.push(num1%num2);<br>}  </p>\n<p>}<br>return nums.top();<br>}</p>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><h2 id=\"4-1-功能测试\"><a href=\"#4-1-功能测试\" class=\"headerlink\" title=\"4.1 功能测试\"></a>4.1 功能测试</h2><h3 id=\"4-1-1-测试1\"><a href=\"#4-1-1-测试1\" class=\"headerlink\" title=\"4.1.1 测试1\"></a>4.1.1 测试1</h3><p><strong>测试用例</strong>：101+222=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3b0feb3db599b29bb40f8324b63a5999.png\"></p>\n<h3 id=\"4-1-2-测试2\"><a href=\"#4-1-2-测试2\" class=\"headerlink\" title=\"4.1.2 测试2\"></a>4.1.2 测试2</h3><p><strong>测试用例：</strong>-2*(3+5)+2^3/4=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/87e4d36191d5d4540aef89f800956e6c.png\"></p>\n<h3 id=\"4-1-3-测试3\"><a href=\"#4-1-3-测试3\" class=\"headerlink\" title=\"4.1.3 测试3\"></a>4.1.3 测试3</h3><p><strong>测试用例：</strong>5+(-3*(-6))=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9e201b33a2306b0f53b4a333b27229b9.png\"></p>\n<h3 id=\"4-1-4-测试4\"><a href=\"#4-1-4-测试4\" class=\"headerlink\" title=\"4.1.4 测试4\"></a>4.1.4 测试4</h3><p><strong>测试用例：</strong> 2^4/8-(+2+8)%3=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc08f317871e93a46b5286a9a2f94e89.png\"></p>\n<h3 id=\"4-1-4-测试5\"><a href=\"#4-1-4-测试5\" class=\"headerlink\" title=\"4.1.4 测试5\"></a>4.1.4 测试5</h3><p><strong>测试用例：</strong> 1+(-5*3)/(-2)-9/2=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4a5c05685b663cdadd33ad595a0ad38e.png\"></p>\n<h3 id=\"4-1-4-测试6\"><a href=\"#4-1-4-测试6\" class=\"headerlink\" title=\"4.1.4 测试6\"></a>4.1.4 测试6</h3><p><strong>测试用例：</strong> 2*101-31*24=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/a0e6b9a48eac835cdef546116facb972.png\"></p>\n<h2 id=\"4-2-非法表达式测试\"><a href=\"#4-2-非法表达式测试\" class=\"headerlink\" title=\"4.2 非法表达式测试\"></a>4.2 非法表达式测试</h2><h3 id=\"4-2-1-含有非法字符\"><a href=\"#4-2-1-含有非法字符\" class=\"headerlink\" title=\"4.2.1 含有非法字符\"></a>4.2.1 含有非法字符</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/480a0d4c4fb144eef60f6cb52020c9d3.png\"></p>\n<h3 id=\"4-2-2-左右括号中内容为空\"><a href=\"#4-2-2-左右括号中内容为空\" class=\"headerlink\" title=\"4.2.2 左右括号中内容为空\"></a>4.2.2 左右括号中内容为空</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2ee5ff4b96f3d904342cfb904b4afeaa.png\"></p>\n<h3 id=\"4-2-3-左右括号不匹配\"><a href=\"#4-2-3-左右括号不匹配\" class=\"headerlink\" title=\"4.2.3 左右括号不匹配\"></a>4.2.3 左右括号不匹配</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/6deba4f18cb7d5abc5a3a1e4f80152fc.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc3dc005e974be2057305ab3f7b57d0a.png\"></p>\n<h3 id=\"4-2-4-等号位置错误\"><a href=\"#4-2-4-等号位置错误\" class=\"headerlink\" title=\"4.2.4 等号位置错误\"></a>4.2.4 等号位置错误</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f81ada7588a4bc5102ded4253d49193b.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/13e27456b27841991812efd63041ca47.png\"></p>\n<h3 id=\"4-2-5-正负号不合理\"><a href=\"#4-2-5-正负号不合理\" class=\"headerlink\" title=\"4.2.5 正负号不合理\"></a>4.2.5 正负号不合理</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8beb181f79e57702123cb2496b44e568.png\"></p>\n<h3 id=\"4-2-6-双目运算符使用不合理\"><a href=\"#4-2-6-双目运算符使用不合理\" class=\"headerlink\" title=\"4.2.6 双目运算符使用不合理\"></a>4.2.6 双目运算符使用不合理</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/275c7a98a4363b5a43f707cb2d1cf470.png\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  算数表达式求解</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-项目要求\"><a href=\"#1-1-项目要求\" class=\"headerlink\" title=\"1.1 项目要求\"></a>1.1 项目要求</h2><p>从键盘上输入中缀算数表达式，包括括号，计算出表达式的值。</p>\n<p>程序对所有输入的表达式作简单的判断，如表达式有错，能给出适当的提示。</p>\n<p>支持包括加减，乘除取余，乘方和括号等操作符，其中优先级是等于&lt;括号&lt;加减&lt;乘除取余&lt;乘方。</p>\n<p>能处理单目运算符：+或-。</p>\n<h2 id=\"1-2-功能分析\"><a href=\"#1-2-功能分析\" class=\"headerlink\" title=\"1.2 功能分析\"></a>1.2 功能分析</h2><p>首先,得对输入表达式进行判断,看它是否合理,如果不合理,要指出错误之处;如果是合理的,那么要计算这个表达式的结果并返回。</p>\n<p>表达式是否错误根据下面几条进行判断：</p>\n<blockquote>\n<p>  1.出现了除了+-* % / ^ ()=,数字以外的其他字符</p>\n</blockquote>\n<blockquote>\n<p>  2.()匹配不全 或者()里面为空</p>\n</blockquote>\n<blockquote>\n<p>  3.表达式没有结束之前出现了=,或者表达式最后不是=</p>\n</blockquote>\n<blockquote>\n<p>  4.+-不是开头,或者前方不是( 一目运算符</p>\n</blockquote>\n<blockquote>\n<p>  5.运算符前方或者后方无数字或者(),左边为),右边为(,避免(+) 二目运算符</p>\n</blockquote>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-主函数设计\"><a href=\"#2-1-主函数设计\" class=\"headerlink\" title=\"2.1 主函数设计\"></a>2.1 主函数设计</h2><p>先输入表达式，调用函数判断表达式是否合理，如果合理，首先将之转换为后续表达式，输出后续表达式的字符串，并且调用函数计算后续表达式，并且打印后续表达式的结果。</p>\n<p>（因为之后需要用到栈，所以程序还出现了Stack.h，与Node.h，因为之前的题目也用过，所以这里直接复用之前已经实现的了，不在重新说明。）</p>\n<h2 id=\"2-2-isValid-函数设计\"><a href=\"#2-2-isValid-函数设计\" class=\"headerlink\" title=\"2.2 isValid()函数设计\"></a>2.2 isValid()函数设计</h2><p>大致就是通过循环查看表达式每一个字符来判断表达式是否符合上面几条，如果不合法，就输出对应的提示信息，并且函数返回false，表示表达式有误，直到所有的条件都满足了，才返回true。</p>\n<p>主要的难度就是对（）合理性的判断，于是通过许多条件限制来判断是否是合理的表达式，如：左括号右边都没出现右括号；检测到了右括号后，在该处左边的右括号数量大于左括号数量；以及左括号右括号之中没有东西等。</p>\n<p>随后，当+-作为单目运算符，或者双目运算符的相关讨论也需要进行比较细致的分类讨论。再对其他运算符进行讨论是否合理。</p>\n<h2 id=\"2-3-toPostOrder-函数设计\"><a href=\"#2-3-toPostOrder-函数设计\" class=\"headerlink\" title=\"2.3 toPostOrder()函数设计\"></a>2.3 toPostOrder()函数设计</h2><p>该函数目的是将之前的那个已经检验过合理性的表达式转为后续表达式，因为后序表达式能直接的计算。大致思路是：用栈存储运算符（char类型），然后遍历传入的字符串，分情况讨论，例如处理一目运算符+-（正负），处理数字，处理左右括号，处理其他运算符等。准备一个string存储后序表达式，如果是数字直接放入，如果是其他，则要小心的判断优先级，当遇到的优先级不断增大时，压入栈中，如果优先级相同,则将所有小于等于他优先级的运算符弹出,再在栈中加入这个运算符。这样就能保证后续表达式优先级正确了。在每个元素之间，还加入了一个空格（如12<br>5<br>+），这样可以避免出现将之读为125的bug。大致就是这样转换，但是还有许多细节来保证转换正确，这将在函数实现中进行细致讨论。</p>\n<h2 id=\"2-4-caculatePostOrder-函数设计\"><a href=\"#2-4-caculatePostOrder-函数设计\" class=\"headerlink\" title=\"2.4 caculatePostOrder ()函数设计\"></a>2.4 caculatePostOrder ()函数设计</h2><p>该函数通过传入一个后续表达式,输出一个int值,代表表达式的结果。主要设计思路是用栈存储数值，遍历后续表达式，如果是数字就把整个数字压入栈中（如遇到19）会把19压入，而不是压入1和9。如果遍历到了操作符，那么就将栈顶两个元素取出并且计算，再压入栈中（因为这时是后续表达式，后续表达式已经把优先级等都考虑好了，所以只要根据符号采取特定的方法计算即可）。遍历完之后将栈顶元素返回，这个即为表达式的值。</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-主函数实现\"><a href=\"#3-1-主函数实现\" class=\"headerlink\" title=\"3.1 主函数实现\"></a>3.1 主函数实现</h2><p>先让用户输入表达式，然后判断合理性，合理的话再打印转换成为后续表达式的字符串，随后打印表达式的结果，最后让用户选择是否结束程序（不这样的话运行exe文件输入完之后就会退出，强制设定退出时间也不太好，所以让用户自己选择）。</p>\n<p>int main()<br>{<br>while(true)<br>{<br>string expr,isContinue;<br>cout &lt;&lt; “输入表达式：” &lt;&lt; endl;<br>getline(cin,expr);<br>if(isValid(expr))<br>{<br>string postOrderedExpr=toPostOrder(expr);<br>cout &lt;&lt;“后序表达式为:”&lt;&lt; postOrderedExpr&lt;&lt;endl;<br>int result = caculatePostOrder(postOrderedExpr);<br>cout&lt;&lt;result&lt;&lt;endl;<br>}<br>cout&lt;&lt;“任意键继续,n退出？”;<br>getline(cin,isContinue);<br>if(isContinue==”n”)<br>{<br>break;<br>}<br>}<br>return 0;<br>}</p>\n<h2 id=\"3-2-isValid-函数实现\"><a href=\"#3-2-isValid-函数实现\" class=\"headerlink\" title=\"3.2 isValid()函数实现\"></a>3.2 isValid()函数实现</h2><h3 id=\"3-2-1-简单的判断\"><a href=\"#3-2-1-简单的判断\" class=\"headerlink\" title=\"3.2.1 简单的判断\"></a>3.2.1 简单的判断</h3><p>对表达式进行遍历（对运算符和左右括号的判断也在遍历表达式的时候进行，只不过为了分节而在下面几节再叙述），如果出现了表达式意外的字符，即既不是数字又不是+-*/%^=(),则立即提示并且返回。如果表达式没有结束之前出现了=,或者表达式最后不是=，也提示并且返回。</p>\n<p>if(expr[i]!=’+’&amp;&amp;expr[i]!=’-‘&amp;&amp;expr[i]!=’*‘&amp;&amp;expr[i]!=’/‘&amp;&amp;expr[i]!=’%’&amp;&amp;expr[i]!=’^‘&amp;&amp;<br>expr[i]!=’(‘&amp;&amp;expr[i]!=’)’&amp;&amp;expr[i]!=’=’&amp;&amp; !(expr[i]&lt;=’9’&amp;&amp;expr[i]&gt;=’0’))<br>{<br>cout&lt;&lt;“表达式含有非法字符”&lt;&lt;endl;<br>return false;<br>}</p>\n<p>if(i==N-1 &amp;&amp; expr[i]!=’=’)<br>{<br>cout &lt;&lt; “不以=结尾”&lt;&lt;endl;<br>return false;<br>}<br>if(i!=N-1 &amp;&amp; expr[i]==’=’)<br>{<br>cout &lt;&lt; “表达式中出现了=”&lt;&lt;endl;<br>return false;<br>}</p>\n<h3 id=\"3-2-2-对左右括号的判断\"><a href=\"#3-2-2-对左右括号的判断\" class=\"headerlink\" title=\"3.2.2 对左右括号的判断\"></a>3.2.2 对左右括号的判断</h3><p>对于每一个左括号，如果它右边位置都没出现右括号则提示并返回，这样能确保有足够的右括号，但是右括号可能多了，于是需要对右括号进行判断。</p>\n<p>对于每一个右括号，从该位置计算，如果左边的左括号数量小于了右括号的数量（该右括号也算上），那么是不合理的，则提示并返回。这样对于每一个右括号，都保证它左边有充分的左括号（或许多了，但是经过上面的条件，则符合条件的左右括号应该正好完全匹配）。</p>\n<p>还判断了空（）的情况，即左括号右括号之中没有东西，那么也视为不合理，则提示并返回。</p>\n<p>if(expr[i]==’(‘)<br>{<br>if(expr.find(‘)’, i)==-1)<br>{<br>cout&lt;&lt;“没有足够的右括号匹配左括号”&lt;&lt;endl;<br>return false;<br>}<br>}<br>if(expr[i]==’)’)<br>{<br>int leftCount = 0, rightCount = 0;//()的个数<br>for (int j = 0; j &lt;= i; ++j)<br>{<br>if(expr[j]==’(‘)<br>{<br>++leftCount;<br>}<br>else if(expr[j]==’)’)<br>{<br>++rightCount;<br>}<br>}<br>if(leftCount&lt;rightCount)<br>{<br>cout&lt;&lt;“没有足够的左括号匹配右括号”&lt;&lt;endl;<br>return false;<br>}<br>}<br>if(expr[i]==’(‘ &amp;&amp;i+1&lt;N &amp;&amp; expr[i+1]==’)’)<br>{<br>cout&lt;&lt;“出现了空()”&lt;&lt;endl;<br>return false;<br>}</p>\n<h3 id=\"3-2-3单目表达式的判断\"><a href=\"#3-2-3单目表达式的判断\" class=\"headerlink\" title=\"3.2.3单目表达式的判断\"></a>3.2.3单目表达式的判断</h3><p>之所以单独讨论，是因为要以单目运算符，双目运算符来分别讨论。</p>\n<p>如果这两个符号是表达式的第一个元素，或者它左边是左括号（这里假定合理的表达式中单目表达式都用括号括起来，如（-1）），则是单目表达式，代表的是正负。而是单目运算符时，他右边可以是一个子表达式（判断条件是它右边第一个元素是左括号），或者是一个数（判断条件是右边第一个字符大于‘0’并且小于‘9’）。否则不合理，则提示并返回。</p>\n<p>如果出现的=-不是单目运算符正负，那么再通过左右条件判断是否是合理的双目运算符，即为加减。而这样他们和其他运算符判断方式一样，在下一小节统一叙述。</p>\n<p>if(expr[i]==’+’ || expr[i]==’-‘)<br>{<br>if(i==0 || expr[i-1]==’(‘)//满足第四点 单目运算符<br>{<br>if(i+1&lt;N &amp;&amp; ((expr[i+1]==’(‘)||(expr[i+1]&lt;=’9’&amp;&amp;expr[i+1]&gt;=’0’)))//合理了的<br>{<br>}<br>else<br>{<br>cout&lt;&lt;“+-后面没有数字或者(“&lt;&lt;endl;<br>return false;<br>}<br>}<br>//i+1存在,并且左边是)或者数字,并且右边是(或者数字<br>else if(i+1&lt;N &amp;&amp; (expr[i-1]==’)’ || (expr[i-1]&lt;=’9’&amp;&amp;expr[i-1]&gt;=’0’))&amp;&amp;<br>((expr[i+1]==’(‘)||(expr[i+1]&lt;=’9’&amp;&amp;expr[i+1]&gt;=’0’)))//i-1肯定&gt;=0,因为上面的条件<br>{  </p>\n<p>}<br>else<br>{<br>cout&lt;&lt;“不合理的+-“&lt;&lt;endl;<br>return false;<br>}<br>}</p>\n<h3 id=\"3-2-4-双目表达式的判断\"><a href=\"#3-2-4-双目表达式的判断\" class=\"headerlink\" title=\"3.2.4 双目表达式的判断\"></a>3.2.4 双目表达式的判断</h3><p>判断很简单，首先，要判断双目表达式的左右两边不是空的，因为双目表达式需要接受两个操作数。然后判断它左右两边是否是子表达式，或者是数字。如果不是这两者之一，就是不合理的双目表达式，则不合理，则提示并返回。</p>\n<p>if(expr[i]==’^‘||expr[i]==’%’||expr[i]==’*‘||expr[i]==’/‘)<br>{<br>if(i-1&gt;=0 &amp;&amp; i+1&lt;N &amp;&amp; ((expr[i-1]==’)’ ||<br>(expr[i-1]&lt;=’9’&amp;&amp;expr[i-1]&gt;=’0’))&amp;&amp;<br>((expr[i+1]==’(‘)||(expr[i+1]&lt;=’9’&amp;&amp;expr[i+1]&gt;=’0’))))<br>{<br>//合格<br>}<br>else<br>{<br>cout&lt;&lt;“不合理的*/^%”&lt;&lt;endl;<br>return false;<br>}<br>}</p>\n<h2 id=\"3-3-toPostOrder-函数实现\"><a href=\"#3-3-toPostOrder-函数实现\" class=\"headerlink\" title=\"3.3 toPostOrder()函数实现\"></a>3.3 toPostOrder()函数实现</h2><h3 id=\"3-3-1函数描述\"><a href=\"#3-3-1函数描述\" class=\"headerlink\" title=\"3.3.1函数描述\"></a>3.3.1函数描述</h3><p>用一个map将运算符和他对应的优先级绑定（用数字表示，数字越大优先级越高）。并且准备一个栈存储运算符字符，一个字符串存储整个后续表达式。</p>\n<p>开始遍历整个原始的表达式字符串，根据字符的不同采取不同的操作：</p>\n<blockquote>\n<p>  1.如果是一目运算符=-(正负),(判断是他们的条件是他们是第一个字符或者前方是左括号),如果是+,不处理,如果是-,那么就相当于是0-目标数,例如-5,那么后续表达式就加入0<br>  5<br>  -,这里注意两点,一是,作为负号,优先级是最高的,所以不用考虑其他符号,直接加入即可。二是需要小心的加入空格，如这里必须要是0<br>  5 -，不能是05 -。</p>\n</blockquote>\n<blockquote>\n<p>  2.如果是数字，那么用另外的指针记录该位置，该指针循环往后直到找到第一个非数字字符，把整个数字都截取出来加入到后序表达式中，再再后续表达式后面加上一个空格，避免出现原本代表两个数的后续表达式（10<br>  5 +）变成了错误的（105+）。</p>\n</blockquote>\n<blockquote>\n<p>  3.处理左括号（，左括号就直接压入栈中，将来作为一个弹栈的标志。</p>\n</blockquote>\n<blockquote>\n<p>  4.处理非）的其他字符，因为是按顺序处理下来的，代表前方已经处理了一目运算符，左括号，数字，所以这里的<br>  ！=‘）’<br>  代表了所有其他的双目运算符。首先，如果栈为空的话，直接将该运算符压入栈中，而如果栈不为空，则需要与栈顶元素对比，将所有大于等于该运算符优先级的栈元素依次取出栈，放入后续表达式中，这样就能保证优先级大的总是优先计算，而大于等于的都取出来是因为如果是等于的话，代表前后的优先级是相同的，但是为了从左往右计算，所以需要把左边那个优先级相等的运算符先取出来放入后续表达式中。当确保栈中没有大于等于该运算符的元素后，再将该运算符放入栈中。</p>\n</blockquote>\n<blockquote>\n<p>  5.处理右括号）运算符，到这一步时，只需要不断弹栈，不断将栈中运算符加入后续表达式中直到遇到左括号（为止，因为在处理其他运算符时运算符已经按照相应的顺序在栈中或者在后续表达式中摆放好了，所以直接这样处理即可。</p>\n</blockquote>\n<blockquote>\n<p>  循环结束后，已经将所有的数字和大部分运算符放入了后续表达式中，但是最后还会有少部分的运算符存在栈中（除非表达式最后一个字符是右括号）），所以此时要把栈中剩余所有元素放入后续表达式中。最后，将后续表达式返回即可。</p>\n</blockquote>\n<h3 id=\"3-3-2-函数代码\"><a href=\"#3-3-2-函数代码\" class=\"headerlink\" title=\"3.3.2 函数代码\"></a>3.3.2 函数代码</h3><pre><code>string toPostOrder(const string &amp; expr)  \n{  \nunordered_map\\&lt;char,int\\&gt; priority;//存储运算符的优先级  \npriority[&#39;=&#39;] = 1;  \npriority[&#39;(&#39;] = 2;  \npriority[&#39;)&#39;] = 2;  \npriority[&#39;+&#39;] = 3;  \npriority[&#39;-&#39;] = 3;  \npriority[&#39;\\*&#39;] = 4;  \npriority[&#39;/&#39;] = 4;  \npriority[&#39;%&#39;] = 5;  \npriority[&#39;\\^&#39;] = 6;  \nstring postOrderedExpr;  \nStack\\&lt;char\\&gt; ops;//存储运算符的  \nfor (int i = 0; i \\&lt; expr.length(); ++i)  \n{  \n//处理一目运算符  \nif((expr[i]==&#39;+&#39; \\|\\| expr[i]==&#39;-&#39;)&amp;&amp;(i == 0 \\|\\| expr[i - 1] ==\n&#39;(&#39;))//当作正负来使用时  \n{  \nif(expr[i]==&#39;+&#39;)  \n{  \n//忽略他  \n}  \nelse  \n{  \npostOrderedExpr += &quot;0 &quot;;  \n++i;//将-后面的读入  \npostOrderedExpr += expr[i];  \npostOrderedExpr += &quot; - &quot;;  \n}  \n\n}  \nelse\nif(expr[i]\\&lt;=&#39;9&#39;&amp;&amp;expr[i]\\&gt;=&#39;0&#39;)//这里需要处理下,就是如果输入大于0-9的数字也能正确处理  \n{  \nint hi = i+1;  \nwhile (true)  \n{  \nif (hi \\&lt; expr.length() &amp;&amp; expr[hi] \\&lt;= &#39;9&#39;&amp;&amp;expr[hi] \\&gt;= &#39;0&#39;)  \n{  \n++hi;  \n}  \nelse  \n{  \nbreak;  \n}  \n\n}  \n//hi指向的是数字后面的第一个非数字字符  \n//expr.substr(i, hi - i); 得到了数字的字符串  \npostOrderedExpr += expr.substr(i, hi - i);  \npostOrderedExpr += &quot; &quot;;//避免出现10+5-\\&gt;105+的问题  \ni = hi - 1;  \n}  \nelse if(expr[i]==&#39;(&#39;)  \n{  \nops.push(expr[i]);  \n}  \nelse if(expr[i]!=&#39;)&#39;)//除)外的运算符都压入  \n{  \nif(ops.empty())//栈为空,简单压入即可  \n{  \nops.push(expr[i]);  \n}  \nelse  \n{  \n//需要与栈顶运算符比较优先级  \nint topStackPriority = priority[ops.top()];  \nif(priority[expr[i]]\\&gt;topStackPriority)  \n{  \nops.push(expr[i]);  \n}  \nelse  \n{  \n//优先级相同,必将弹出之前所有小于等于他优先级的运算符,再加入这个运算符  \nwhile(!ops.empty() &amp;&amp; priority[expr[i]]\\&lt;=topStackPriority)  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += &quot; &quot;;  \nops.pop();  \nif(!ops.empty())  \n{  \ntopStackPriority = priority[ops.top()];  \n}  \n}  \n\nops.push(expr[i]);  \n}  \n}  \n}  \nelse if(expr[i]==&#39;)&#39;)  \n{  \n//表达式检验过,一定正确,所以可以直接这样用  \nwhile(ops.top()!=&#39;(&#39;)  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += &quot; &quot;;//避免出现10+5-\\&gt;105+的问题  \nops.pop();  \n}  \nops.pop();//把(弹出去  \n}  \n}  \n//剩下的运算符一起加上  \nwhile(!ops.empty())  \n{  \nif(ops.top()!=&#39;=&#39;)//不要=  \n{  \npostOrderedExpr += ops.top();  \npostOrderedExpr += &quot; &quot;;  \n}  \nops.pop();  \n}  \nreturn postOrderedExpr;  \n}</code></pre>\n<h2 id=\"3-4-caculatePostOrder（）的实现\"><a href=\"#3-4-caculatePostOrder（）的实现\" class=\"headerlink\" title=\"3.4 caculatePostOrder（）的实现\"></a>3.4 caculatePostOrder（）的实现</h2><h3 id=\"3-4-1函数描述\"><a href=\"#3-4-1函数描述\" class=\"headerlink\" title=\"3.4.1函数描述\"></a>3.4.1函数描述</h3><p>传入一个后续表达式，将计算的结果以int类型返回。</p>\n<p>用栈存储int类型数字。对后续表达式进行遍历，如果是数字，同样，得按照和前面一样的方法，将整个数字取出来，如23等，将数字放入栈中。如果是运算符，根据运算符的不同，采取相应的操作，但其实操作是很类似的，都是从栈中取出两个数字，用前面的数采用相应的运算符和后面的数进行计算，并且将运算符重新加入栈中。</p>\n<p>因为一目运算符正负=-已经转换为空或者双目运算符，左右括号也去掉，表达式也是合理的了，所以只要这样简单的运算到后续表达式结束即可得到结果，而结果就是栈顶元素。</p>\n<h3 id=\"3-4-2-函数代码\"><a href=\"#3-4-2-函数代码\" class=\"headerlink\" title=\"3.4.2 函数代码\"></a>3.4.2 函数代码</h3><p>（一些重复部分没放上来）</p>\n<p>int caculatePostOrder(const string &amp; postOrderedExpr)<br>{<br>Stack&lt;int&gt; nums;<br>for (int i = 0; i &lt; postOrderedExpr.length(); ++i)<br>{<br>if(postOrderedExpr[i]&lt;=’9’&amp;&amp;postOrderedExpr[i]&gt;=’0’)<br>{<br>//还要考虑处理大于10的数字  </p>\n<p>int hi = i + 1;<br>while (true)<br>{<br>if (hi &lt; postOrderedExpr.length() &amp;&amp; postOrderedExpr[hi] &lt;=<br>‘9’&amp;&amp;postOrderedExpr[hi] &gt;= ‘0’)<br>{<br>++hi;<br>}<br>else<br>{<br>break;<br>}  </p>\n<p>}<br>//hi指向的是数字后面的第一个非数字字符<br>//postOrderedExpr.substr(i, hi - i); 得到了数字的字符串  </p>\n<p>nums.push(atoi(postOrderedExpr.substr(i, hi - i).c_str()));  </p>\n<p>i = hi - 1;<br>}<br>else if(postOrderedExpr[i]==’^‘)<br>{<br>//num1为左,num2为右<br>int num2 = nums.top();<br>nums.pop();<br>int num1 = nums.top();<br>nums.pop();<br>nums.push(pow(num1, num2));<br>}<br>else if(postOrderedExpr[i]==’%’)<br>{<br>//num1为左,num2为右<br>int num2 = nums.top();<br>nums.pop();<br>int num1 = nums.top();<br>nums.pop();<br>nums.push(num1%num2);<br>}  </p>\n<p>}<br>return nums.top();<br>}</p>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><h2 id=\"4-1-功能测试\"><a href=\"#4-1-功能测试\" class=\"headerlink\" title=\"4.1 功能测试\"></a>4.1 功能测试</h2><h3 id=\"4-1-1-测试1\"><a href=\"#4-1-1-测试1\" class=\"headerlink\" title=\"4.1.1 测试1\"></a>4.1.1 测试1</h3><p><strong>测试用例</strong>：101+222=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/3b0feb3db599b29bb40f8324b63a5999.png\"></p>\n<h3 id=\"4-1-2-测试2\"><a href=\"#4-1-2-测试2\" class=\"headerlink\" title=\"4.1.2 测试2\"></a>4.1.2 测试2</h3><p><strong>测试用例：</strong>-2*(3+5)+2^3/4=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/87e4d36191d5d4540aef89f800956e6c.png\"></p>\n<h3 id=\"4-1-3-测试3\"><a href=\"#4-1-3-测试3\" class=\"headerlink\" title=\"4.1.3 测试3\"></a>4.1.3 测试3</h3><p><strong>测试用例：</strong>5+(-3*(-6))=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/9e201b33a2306b0f53b4a333b27229b9.png\"></p>\n<h3 id=\"4-1-4-测试4\"><a href=\"#4-1-4-测试4\" class=\"headerlink\" title=\"4.1.4 测试4\"></a>4.1.4 测试4</h3><p><strong>测试用例：</strong> 2^4/8-(+2+8)%3=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc08f317871e93a46b5286a9a2f94e89.png\"></p>\n<h3 id=\"4-1-4-测试5\"><a href=\"#4-1-4-测试5\" class=\"headerlink\" title=\"4.1.4 测试5\"></a>4.1.4 测试5</h3><p><strong>测试用例：</strong> 1+(-5*3)/(-2)-9/2=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4a5c05685b663cdadd33ad595a0ad38e.png\"></p>\n<h3 id=\"4-1-4-测试6\"><a href=\"#4-1-4-测试6\" class=\"headerlink\" title=\"4.1.4 测试6\"></a>4.1.4 测试6</h3><p><strong>测试用例：</strong> 2*101-31*24=</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/a0e6b9a48eac835cdef546116facb972.png\"></p>\n<h2 id=\"4-2-非法表达式测试\"><a href=\"#4-2-非法表达式测试\" class=\"headerlink\" title=\"4.2 非法表达式测试\"></a>4.2 非法表达式测试</h2><h3 id=\"4-2-1-含有非法字符\"><a href=\"#4-2-1-含有非法字符\" class=\"headerlink\" title=\"4.2.1 含有非法字符\"></a>4.2.1 含有非法字符</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/480a0d4c4fb144eef60f6cb52020c9d3.png\"></p>\n<h3 id=\"4-2-2-左右括号中内容为空\"><a href=\"#4-2-2-左右括号中内容为空\" class=\"headerlink\" title=\"4.2.2 左右括号中内容为空\"></a>4.2.2 左右括号中内容为空</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/2ee5ff4b96f3d904342cfb904b4afeaa.png\"></p>\n<h3 id=\"4-2-3-左右括号不匹配\"><a href=\"#4-2-3-左右括号不匹配\" class=\"headerlink\" title=\"4.2.3 左右括号不匹配\"></a>4.2.3 左右括号不匹配</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/6deba4f18cb7d5abc5a3a1e4f80152fc.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/fc3dc005e974be2057305ab3f7b57d0a.png\"></p>\n<h3 id=\"4-2-4-等号位置错误\"><a href=\"#4-2-4-等号位置错误\" class=\"headerlink\" title=\"4.2.4 等号位置错误\"></a>4.2.4 等号位置错误</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f81ada7588a4bc5102ded4253d49193b.png\"></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/13e27456b27841991812efd63041ca47.png\"></p>\n<h3 id=\"4-2-5-正负号不合理\"><a href=\"#4-2-5-正负号不合理\" class=\"headerlink\" title=\"4.2.5 正负号不合理\"></a>4.2.5 正负号不合理</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/8beb181f79e57702123cb2496b44e568.png\"></p>\n<h3 id=\"4-2-6-双目运算符使用不合理\"><a href=\"#4-2-6-双目运算符使用不合理\" class=\"headerlink\" title=\"4.2.6 双目运算符使用不合理\"></a>4.2.6 双目运算符使用不合理</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/275c7a98a4363b5a43f707cb2d1cf470.png\"></p>\n"},{"title":"数据结构项目-------考试报名系统","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习数据结构项目--考试报名系统所写的文档,主要就是链表以及交互应用.","abbrlink":"bee2295f","date":"2020-01-01T16:00:00.000Z","_content":"# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n>   考试报名系统\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 背景分析\n\n考试报名工作给各高校报名工作带来了新的挑战，给教务管理部门增加了很大的工作量。本项目是对考试报名管理的简单模拟，用控制台选项的选择方式完成下列功能：输入考生信息；输出考生信息；查询考生信息；添加考生信息；修改考生信息；删除考生信息。\n\n## 1.2 功能分析\n\n本项目的实质是完成对考生信息的建立，查找，插入，修改，删除等功能。其中考生信息包括准考证号，姓名，性别，年龄和报考类别等信息。项目在设计时应首先确定系统的数据结构，定义类的成员变量和成员函数；然后实现各成员函数以完成对数据操作的相应功能；最后完成主函数以验证各个成员函数的功能并得到运行结果。采用链表实现。\n\n综上,至少有建立，查找，插入，修改，删除,退出功能。\n\n# 2 设计\n\n## 2.1 存储结构设计\n\n因为在建立学生信息表之后还需要进行大量添加,删除操作,所以采用链表存储.用模板类Node存储学生信息,模板类LinkedList存储一条由Node构成的链表,即存储了所有学生信息,并且能进行相应的操作.因为无其他要求,所以采用单向链表,且有一个头指针first.\n\nLinkedList中,通过add(),pop(),change(),show()等方法,来对链表进行对应的操作,即实现了对学生信息表的增删改查功能.\n\n## 2.2 Student类结构设计\n\nStudent类代表了一个学生的实体,含有该学生所需要的成员变量:准考证号，姓名，性别，年龄和报考类别.这些成员变量设为private以达到封装的效果,所以也提供了相应的get(),set()方法来对这些属性进行修改.并且有一个展示该学生信息的show()方法.\n\n## 2.3 主程序设计\n\n开始时建立LinkedList的对象students,输出窗口将提示引导用户逐步建立学生信息表,然后展示所建立表.随后进入循环,直到用户按0退出程序.循环中,根据用户输入,调用students对象相应的函数,执行相应的操作,\n完成插入删除，查找，修改，统计功能.\n\n# 3 实现\n\n## 3.1 插入功能的实现\n\n### 3.1.1 表头插入\n\n在建立表时,就采用了简单的在表头插入,即每一个学生在插入时都处于first的位置,调用了Node的构造方法,所以很简洁\n>   void add(T t)  \n>   {  \n>   Node\\<T\\> \\*oldFirst = first;  \n>   first = new Node\\<T\\>(t,oldFirst);  \n>   }\n\n### 3.1.2 任意位置插入\n\n提供了在任意位置插入的功能,首先判断传入位置是否合理,然后移到要插入的位置的前面一个,进行插入,并且展示插入后的学生表.\n\n>   void insert(int pos, T t)  \n>   {  \n>   if(pos\\<=0) return;  \n>   //相当于add  \n>   if(pos==1)  \n>   {  \n>   add(t);  \n>   }  \n>   else  \n>   {  \n>   Node\\<T\\> \\*cur = first;  \n>   for (int i = 0; i \\< pos - 2; ++i)  \n>   {  \n>   if(cur== nullptr)  \n>   return;  \n>   cur = cur-\\>next;  \n>   }  \n>   Node\\<T\\> \\*newNode = new Node\\<T\\>(t,cur-\\>next);  \n>   cur-\\>next = newNode;  \n>   }  \n>   show();  \n>   }\n\n## 3.2 删除功能的实现\n\n### 3.2.1 删除功能描述\n\n首先先判断first不为nullptr,否则继续程序可能会报错,然后根据传入的id进行判断,如果是首元素,直接让first指向它的下一个元素,即使只有一个元素的情况下也是正确的.\n\n如果不是首元素,同理,通过检测下一个元素是否为空小心的向后移动,找到下一个元素id为传入id的元素,删除之,展示删除之后的学生表.\n\n### 3.2.2 删除功能代码\n\n>   void pop(const string & id)  \n>   {  \n>   if(first== nullptr)  \n>   return;  \n>   if(id==first-\\>value.getId())//相当于add  \n>   {  \n>   first = first-\\>next;  \n>   }  \n>   else  \n>   {  \n>   for (Node\\<T\\> \\* x=first; x!= nullptr ; x=x-\\>next)  \n>   {  \n>   if(x-\\>next && x-\\>next-\\>value.getId()==id)  \n>   {  \n>   Node\\<T\\> \\* temp = x-\\>next;  \n>   x-\\>next = x-\\>next-\\>next;  \n>   delete temp;  \n>   }  \n>   }  \n>   }  \n>   show();  \n>   }\n\n## 3.3 查找功能的实现\n\n### 3.3.1 查找功能描述\n\n遍历链表,找到学生表中符合传入id的元素,通过重载了的\\<\\<把该学生信息打印出来.\n\n### 3.3.2 查找功能代码\n\n>   void show(const string & id)  \n>   {  \n>   cout\\<\\<endl\\<\\<\"学号 姓名 性别 年龄 报考类别\"\\<\\<endl;//空四格  \n>   for (Node\\<T\\> \\* x=first; x!= nullptr ; x=x-\\>next)  \n>   {  \n>   if(id==x-\\>value.getId())  \n>   {  \n>   cout\\<\\<x-\\>value\\<\\<endl;  \n>   return;  \n>   }  \n>   }  \n>   cout \\<\\< \"No such student\";  \n>   }\n\n## 3.4 修改功能的实现\n\n### 3.4.1 修改功能描述\n\n修改功能首先根据传入的id找到对应的学生,然后根据传入的pos,找到想要修改的属性,并且把该属性设置为传入的value值,需要注意的是,如果传入的是age的string,需要转换为int.重新展示学生信息表.\n\n### 3.4.2 修改功能代码\n\n>   void change(const string & id,int pos,string value)  \n>   {  \n>   //pos 0,1,2,3,4 id,name,gender,age,examCategory  \n>   for (Node\\<T\\> \\* x=first; x!= nullptr ; x=x-\\>next)  \n>   {  \n>   if(id==x-\\>value.getId())  \n>   {  \n>   switch (pos)  \n>   {  \n>   case 0:  \n>   x-\\>value.setId(value);  \n>   break;  \n>   case 1:  \n>   x-\\>value.setName(value);  \n>   break;  \n>   case 2:  \n>   x-\\>value.setGender(value);  \n>   break;  \n>   case 3:  \n>   x-\\>value.setAge(atoi(value.c_str()));  \n>   break;  \n>   case 4:  \n>   x-\\>value.setExamCategory(value);  \n>   break;  \n>   default:  \n>   break;  \n>   }  \n>   }  \n>   }  \n>   show();  \n>   }\n\n## 3.5 统计功能的实现\n\n>   void show()  \n>   {  \n>   cout\\<\\<endl\\<\\<\"学号 姓名 性别 年龄 报考类别\"\\<\\<endl;//空四格  \n>   for (Node\\<T\\> \\* x=first; x!= nullptr ; x=x-\\>next)  \n>   {  \n>   cout\\<\\<x-\\>value\\<\\<endl;  \n>   }  \n>   }\n\n## 3.6 总体系统的实现\n\n### 3.6.1 总体系统描述\n\n引导用户输入建立表的总人数N,创建表studentList,并引导用户逐个输入每个学生的每个属性.展示学生表.进入循环,根据用户输入的operate,switch之,并且根据不同的operate调用studentList里相应的函数.\n\n### 3.6.2 总体系统核心代码\n\nbool is_continue=true;  \nwhile(is_continue)  \n{  \ncout\\<\\<\"请选择你要进行的操作：\";  \nint operate;//操作  \nint pos;//位置  \nstring id,name,gender,exam_category;  \nint age;  \nstring value;//修改时指定的属性  \nStudent student;  \ncin\\>\\>operate;  \n//1为插入，2为删除，3为查找，4为修改，5为统计，0为取消操作  \nswitch(operate)  \n{  \ncase 1:  \ncout\\<\\<\"请输入你要插入的考生的位置：\";  \ncin\\>\\>pos;  \n//插入一个考生信息  \ncout \\<\\< \"请依次输入该考生的信息: \";  \ncin\\>\\>id\\>\\>name\\>\\>gender\\>\\>age\\>\\>exam_category;  \nstudent.setId(id);  \nstudent.setName(name);  \nstudent.setGender(gender);  \nstudent.setAge(age);  \nstudent.setExamCategory(exam_category);  \nstudentList.insert(pos,student);  \nbreak;  \ncase 2:  \ncout\\<\\<\"请输入要删除的考生的考号：\";  \n//注意是操作考号，所有得是string  \ncin\\>\\>id;  \nstudentList.pop(id);  \nbreak;  \ncase 3:  \ncout \\<\\< \"请输入要查找的考生的考号：\";  \ncin \\>\\> id;  \nstudentList.show(id);  \nbreak;  \ncase 4:  \ncout \\<\\< \"请输入要修改的考生的考号：\";  \ncin \\>\\> id;  \ncout \\<\\< \"请输入要修改的位置：\";  \ncin \\>\\> pos;  \ncout \\<\\< \"请输入要修改的值：\";  \ncin \\>\\> value;  \nstudentList.change(id,pos,value);  \nbreak;  \ncase 5:  \nstudentList.show();  \nbreak;  \ncase 0:  \nis_continue=false;  \nbreak;  \ndefault:  \nbreak;  \n}  \n}\n\n# 4 测试\n\n## 4.1 功能测试\n\n### 4.1.1 建立功能测试\n\n**测试用例**：\n\n5  \n1 stu1 女 18 软件工程师  \n2 stu2 男 19 计算机科学  \n3 stu3 男 20 大数据分析  \n4 stu4 男 21 机器学习  \n5 stu5 女 22 数据挖掘\n\n**实验结果**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/6e28543e0dcaa302d2bc3f16ab6f0df0.png)\n\n### 4.1.2 插入功能测试\n\n**测试用例：**\n\n1  \n5  \n7 stu7 女 27 游戏开发\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/58a01c08b8cfeb5c32862265996c6065.png)\n\n### 4.1.3 删除功能测试\n\n**测试用例：**删除考号为7的考生\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4c9a14aee03df511773dba811ea94f16.png)\n\n### 4.1.4 查找功能测试\n\n**测试用例：**查找考号为4的考生\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/454ee04d2df779557d016e4e945d8f6a.png)\n\n### 4.1.5 修改功能测试\n\n**测试用例：**修改考号为1的学生的姓名为stu100\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/abc09b37d16301104d6e660fbde5dc38.png)\n\n### 4.1.6 统计功能测试\n\n**测试用例：**统计所有学生信息\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d4cb88b7f6e75deb38584098e6612d73.png)\n\n## 4.2 边界测试\n\n### 4.2.1 初始化无输入数据\n\n**测试用例：**初始无输入数据\n\n预期结果:程序不报错,且进入循环中\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/a14ee996512875dbae403ae914f66822.png)\n\n### 4.2.2 删除头结点\n\n**测试用例：**删除头结点\n\n**预期结果：**程序正常运行，不崩溃。\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/00fba70a23a5ad7de4d31d6b6d3e27ef.png)\n\n### 4.2.3 删除后链表为空\n\n**测试用例：**删除前链表只有一个结点，删除后链表为空\n\n**预期结果：**程序正常运行，不崩溃。\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/5e11136a7a56560eb2f52355c8e33775.png)\n\n### 4.2.4 考生人数错误\n\n**测试用例：**输入考生人数为负数\n\n**预期结果：**程序正常运行不崩溃。\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/bd257e9238fcab35de511d506f2222d7.png)\n\n### 4.2.5 位置不正确\n\n**测试用例：**在不正确的位置进行插入\n\n**预期结果：**程序正常运行不崩溃。\n\n**实验结果**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/59ed2b4346c5a1c09d535798a3450fa7.png)\n\n### 4.2.6 id不存在\n\n**测试用例：**删除不存在的id\n\n**预期结果：**程序正常运行不崩溃。\n\n**实验结果**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f5309c8358bd23683dd30b76491bc03c.png)\n","source":"_posts/项目笔记/dataStructureProjects/考试报名系统.md","raw":"---\ntitle: 数据结构项目-------考试报名系统\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: '学习数据结构项目--考试报名系统所写的文档,主要就是链表以及交互应用.'\ncategories: 项目文档\ntags:\n  - 数据结构\n  - 链表\n  - c++\nabbrlink: bee2295f\ndate: 2020-01-02 00:00:00\n---\n# [源码地址](https://github.com/tongji4m3/DataStructureDesign)\n>   考试报名系统\n>\n>   数据结构作业 C++语言实现\n>\n>   直接从word文档转的,代码格式有些问题,建议在源码地址查看word版\n\n# 1 分析\n\n## 1.1 背景分析\n\n考试报名工作给各高校报名工作带来了新的挑战，给教务管理部门增加了很大的工作量。本项目是对考试报名管理的简单模拟，用控制台选项的选择方式完成下列功能：输入考生信息；输出考生信息；查询考生信息；添加考生信息；修改考生信息；删除考生信息。\n\n## 1.2 功能分析\n\n本项目的实质是完成对考生信息的建立，查找，插入，修改，删除等功能。其中考生信息包括准考证号，姓名，性别，年龄和报考类别等信息。项目在设计时应首先确定系统的数据结构，定义类的成员变量和成员函数；然后实现各成员函数以完成对数据操作的相应功能；最后完成主函数以验证各个成员函数的功能并得到运行结果。采用链表实现。\n\n综上,至少有建立，查找，插入，修改，删除,退出功能。\n\n# 2 设计\n\n## 2.1 存储结构设计\n\n因为在建立学生信息表之后还需要进行大量添加,删除操作,所以采用链表存储.用模板类Node存储学生信息,模板类LinkedList存储一条由Node构成的链表,即存储了所有学生信息,并且能进行相应的操作.因为无其他要求,所以采用单向链表,且有一个头指针first.\n\nLinkedList中,通过add(),pop(),change(),show()等方法,来对链表进行对应的操作,即实现了对学生信息表的增删改查功能.\n\n## 2.2 Student类结构设计\n\nStudent类代表了一个学生的实体,含有该学生所需要的成员变量:准考证号，姓名，性别，年龄和报考类别.这些成员变量设为private以达到封装的效果,所以也提供了相应的get(),set()方法来对这些属性进行修改.并且有一个展示该学生信息的show()方法.\n\n## 2.3 主程序设计\n\n开始时建立LinkedList的对象students,输出窗口将提示引导用户逐步建立学生信息表,然后展示所建立表.随后进入循环,直到用户按0退出程序.循环中,根据用户输入,调用students对象相应的函数,执行相应的操作,\n完成插入删除，查找，修改，统计功能.\n\n# 3 实现\n\n## 3.1 插入功能的实现\n\n### 3.1.1 表头插入\n\n在建立表时,就采用了简单的在表头插入,即每一个学生在插入时都处于first的位置,调用了Node的构造方法,所以很简洁\n>   void add(T t)  \n>   {  \n>   Node\\<T\\> \\*oldFirst = first;  \n>   first = new Node\\<T\\>(t,oldFirst);  \n>   }\n\n### 3.1.2 任意位置插入\n\n提供了在任意位置插入的功能,首先判断传入位置是否合理,然后移到要插入的位置的前面一个,进行插入,并且展示插入后的学生表.\n\n>   void insert(int pos, T t)  \n>   {  \n>   if(pos\\<=0) return;  \n>   //相当于add  \n>   if(pos==1)  \n>   {  \n>   add(t);  \n>   }  \n>   else  \n>   {  \n>   Node\\<T\\> \\*cur = first;  \n>   for (int i = 0; i \\< pos - 2; ++i)  \n>   {  \n>   if(cur== nullptr)  \n>   return;  \n>   cur = cur-\\>next;  \n>   }  \n>   Node\\<T\\> \\*newNode = new Node\\<T\\>(t,cur-\\>next);  \n>   cur-\\>next = newNode;  \n>   }  \n>   show();  \n>   }\n\n## 3.2 删除功能的实现\n\n### 3.2.1 删除功能描述\n\n首先先判断first不为nullptr,否则继续程序可能会报错,然后根据传入的id进行判断,如果是首元素,直接让first指向它的下一个元素,即使只有一个元素的情况下也是正确的.\n\n如果不是首元素,同理,通过检测下一个元素是否为空小心的向后移动,找到下一个元素id为传入id的元素,删除之,展示删除之后的学生表.\n\n### 3.2.2 删除功能代码\n\n>   void pop(const string & id)  \n>   {  \n>   if(first== nullptr)  \n>   return;  \n>   if(id==first-\\>value.getId())//相当于add  \n>   {  \n>   first = first-\\>next;  \n>   }  \n>   else  \n>   {  \n>   for (Node\\<T\\> \\* x=first; x!= nullptr ; x=x-\\>next)  \n>   {  \n>   if(x-\\>next && x-\\>next-\\>value.getId()==id)  \n>   {  \n>   Node\\<T\\> \\* temp = x-\\>next;  \n>   x-\\>next = x-\\>next-\\>next;  \n>   delete temp;  \n>   }  \n>   }  \n>   }  \n>   show();  \n>   }\n\n## 3.3 查找功能的实现\n\n### 3.3.1 查找功能描述\n\n遍历链表,找到学生表中符合传入id的元素,通过重载了的\\<\\<把该学生信息打印出来.\n\n### 3.3.2 查找功能代码\n\n>   void show(const string & id)  \n>   {  \n>   cout\\<\\<endl\\<\\<\"学号 姓名 性别 年龄 报考类别\"\\<\\<endl;//空四格  \n>   for (Node\\<T\\> \\* x=first; x!= nullptr ; x=x-\\>next)  \n>   {  \n>   if(id==x-\\>value.getId())  \n>   {  \n>   cout\\<\\<x-\\>value\\<\\<endl;  \n>   return;  \n>   }  \n>   }  \n>   cout \\<\\< \"No such student\";  \n>   }\n\n## 3.4 修改功能的实现\n\n### 3.4.1 修改功能描述\n\n修改功能首先根据传入的id找到对应的学生,然后根据传入的pos,找到想要修改的属性,并且把该属性设置为传入的value值,需要注意的是,如果传入的是age的string,需要转换为int.重新展示学生信息表.\n\n### 3.4.2 修改功能代码\n\n>   void change(const string & id,int pos,string value)  \n>   {  \n>   //pos 0,1,2,3,4 id,name,gender,age,examCategory  \n>   for (Node\\<T\\> \\* x=first; x!= nullptr ; x=x-\\>next)  \n>   {  \n>   if(id==x-\\>value.getId())  \n>   {  \n>   switch (pos)  \n>   {  \n>   case 0:  \n>   x-\\>value.setId(value);  \n>   break;  \n>   case 1:  \n>   x-\\>value.setName(value);  \n>   break;  \n>   case 2:  \n>   x-\\>value.setGender(value);  \n>   break;  \n>   case 3:  \n>   x-\\>value.setAge(atoi(value.c_str()));  \n>   break;  \n>   case 4:  \n>   x-\\>value.setExamCategory(value);  \n>   break;  \n>   default:  \n>   break;  \n>   }  \n>   }  \n>   }  \n>   show();  \n>   }\n\n## 3.5 统计功能的实现\n\n>   void show()  \n>   {  \n>   cout\\<\\<endl\\<\\<\"学号 姓名 性别 年龄 报考类别\"\\<\\<endl;//空四格  \n>   for (Node\\<T\\> \\* x=first; x!= nullptr ; x=x-\\>next)  \n>   {  \n>   cout\\<\\<x-\\>value\\<\\<endl;  \n>   }  \n>   }\n\n## 3.6 总体系统的实现\n\n### 3.6.1 总体系统描述\n\n引导用户输入建立表的总人数N,创建表studentList,并引导用户逐个输入每个学生的每个属性.展示学生表.进入循环,根据用户输入的operate,switch之,并且根据不同的operate调用studentList里相应的函数.\n\n### 3.6.2 总体系统核心代码\n\nbool is_continue=true;  \nwhile(is_continue)  \n{  \ncout\\<\\<\"请选择你要进行的操作：\";  \nint operate;//操作  \nint pos;//位置  \nstring id,name,gender,exam_category;  \nint age;  \nstring value;//修改时指定的属性  \nStudent student;  \ncin\\>\\>operate;  \n//1为插入，2为删除，3为查找，4为修改，5为统计，0为取消操作  \nswitch(operate)  \n{  \ncase 1:  \ncout\\<\\<\"请输入你要插入的考生的位置：\";  \ncin\\>\\>pos;  \n//插入一个考生信息  \ncout \\<\\< \"请依次输入该考生的信息: \";  \ncin\\>\\>id\\>\\>name\\>\\>gender\\>\\>age\\>\\>exam_category;  \nstudent.setId(id);  \nstudent.setName(name);  \nstudent.setGender(gender);  \nstudent.setAge(age);  \nstudent.setExamCategory(exam_category);  \nstudentList.insert(pos,student);  \nbreak;  \ncase 2:  \ncout\\<\\<\"请输入要删除的考生的考号：\";  \n//注意是操作考号，所有得是string  \ncin\\>\\>id;  \nstudentList.pop(id);  \nbreak;  \ncase 3:  \ncout \\<\\< \"请输入要查找的考生的考号：\";  \ncin \\>\\> id;  \nstudentList.show(id);  \nbreak;  \ncase 4:  \ncout \\<\\< \"请输入要修改的考生的考号：\";  \ncin \\>\\> id;  \ncout \\<\\< \"请输入要修改的位置：\";  \ncin \\>\\> pos;  \ncout \\<\\< \"请输入要修改的值：\";  \ncin \\>\\> value;  \nstudentList.change(id,pos,value);  \nbreak;  \ncase 5:  \nstudentList.show();  \nbreak;  \ncase 0:  \nis_continue=false;  \nbreak;  \ndefault:  \nbreak;  \n}  \n}\n\n# 4 测试\n\n## 4.1 功能测试\n\n### 4.1.1 建立功能测试\n\n**测试用例**：\n\n5  \n1 stu1 女 18 软件工程师  \n2 stu2 男 19 计算机科学  \n3 stu3 男 20 大数据分析  \n4 stu4 男 21 机器学习  \n5 stu5 女 22 数据挖掘\n\n**实验结果**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/6e28543e0dcaa302d2bc3f16ab6f0df0.png)\n\n### 4.1.2 插入功能测试\n\n**测试用例：**\n\n1  \n5  \n7 stu7 女 27 游戏开发\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/58a01c08b8cfeb5c32862265996c6065.png)\n\n### 4.1.3 删除功能测试\n\n**测试用例：**删除考号为7的考生\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/4c9a14aee03df511773dba811ea94f16.png)\n\n### 4.1.4 查找功能测试\n\n**测试用例：**查找考号为4的考生\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/454ee04d2df779557d016e4e945d8f6a.png)\n\n### 4.1.5 修改功能测试\n\n**测试用例：**修改考号为1的学生的姓名为stu100\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/abc09b37d16301104d6e660fbde5dc38.png)\n\n### 4.1.6 统计功能测试\n\n**测试用例：**统计所有学生信息\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/d4cb88b7f6e75deb38584098e6612d73.png)\n\n## 4.2 边界测试\n\n### 4.2.1 初始化无输入数据\n\n**测试用例：**初始无输入数据\n\n预期结果:程序不报错,且进入循环中\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/a14ee996512875dbae403ae914f66822.png)\n\n### 4.2.2 删除头结点\n\n**测试用例：**删除头结点\n\n**预期结果：**程序正常运行，不崩溃。\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/00fba70a23a5ad7de4d31d6b6d3e27ef.png)\n\n### 4.2.3 删除后链表为空\n\n**测试用例：**删除前链表只有一个结点，删除后链表为空\n\n**预期结果：**程序正常运行，不崩溃。\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/5e11136a7a56560eb2f52355c8e33775.png)\n\n### 4.2.4 考生人数错误\n\n**测试用例：**输入考生人数为负数\n\n**预期结果：**程序正常运行不崩溃。\n\n**实验结果：**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/bd257e9238fcab35de511d506f2222d7.png)\n\n### 4.2.5 位置不正确\n\n**测试用例：**在不正确的位置进行插入\n\n**预期结果：**程序正常运行不崩溃。\n\n**实验结果**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/59ed2b4346c5a1c09d535798a3450fa7.png)\n\n### 4.2.6 id不存在\n\n**测试用例：**删除不存在的id\n\n**预期结果：**程序正常运行不崩溃。\n\n**实验结果**\n\n![](https://tongji4m3.oss-cn-beijing.aliyuncs.com/f5309c8358bd23683dd30b76491bc03c.png)\n","slug":"项目笔记/dataStructureProjects/考试报名系统","published":1,"updated":"2020-11-12T11:57:30.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkq5o74q00s4jotp94bv9s8m","content":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  考试报名系统</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-背景分析\"><a href=\"#1-1-背景分析\" class=\"headerlink\" title=\"1.1 背景分析\"></a>1.1 背景分析</h2><p>考试报名工作给各高校报名工作带来了新的挑战，给教务管理部门增加了很大的工作量。本项目是对考试报名管理的简单模拟，用控制台选项的选择方式完成下列功能：输入考生信息；输出考生信息；查询考生信息；添加考生信息；修改考生信息；删除考生信息。</p>\n<h2 id=\"1-2-功能分析\"><a href=\"#1-2-功能分析\" class=\"headerlink\" title=\"1.2 功能分析\"></a>1.2 功能分析</h2><p>本项目的实质是完成对考生信息的建立，查找，插入，修改，删除等功能。其中考生信息包括准考证号，姓名，性别，年龄和报考类别等信息。项目在设计时应首先确定系统的数据结构，定义类的成员变量和成员函数；然后实现各成员函数以完成对数据操作的相应功能；最后完成主函数以验证各个成员函数的功能并得到运行结果。采用链表实现。</p>\n<p>综上,至少有建立，查找，插入，修改，删除,退出功能。</p>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-存储结构设计\"><a href=\"#2-1-存储结构设计\" class=\"headerlink\" title=\"2.1 存储结构设计\"></a>2.1 存储结构设计</h2><p>因为在建立学生信息表之后还需要进行大量添加,删除操作,所以采用链表存储.用模板类Node存储学生信息,模板类LinkedList存储一条由Node构成的链表,即存储了所有学生信息,并且能进行相应的操作.因为无其他要求,所以采用单向链表,且有一个头指针first.</p>\n<p>LinkedList中,通过add(),pop(),change(),show()等方法,来对链表进行对应的操作,即实现了对学生信息表的增删改查功能.</p>\n<h2 id=\"2-2-Student类结构设计\"><a href=\"#2-2-Student类结构设计\" class=\"headerlink\" title=\"2.2 Student类结构设计\"></a>2.2 Student类结构设计</h2><p>Student类代表了一个学生的实体,含有该学生所需要的成员变量:准考证号，姓名，性别，年龄和报考类别.这些成员变量设为private以达到封装的效果,所以也提供了相应的get(),set()方法来对这些属性进行修改.并且有一个展示该学生信息的show()方法.</p>\n<h2 id=\"2-3-主程序设计\"><a href=\"#2-3-主程序设计\" class=\"headerlink\" title=\"2.3 主程序设计\"></a>2.3 主程序设计</h2><p>开始时建立LinkedList的对象students,输出窗口将提示引导用户逐步建立学生信息表,然后展示所建立表.随后进入循环,直到用户按0退出程序.循环中,根据用户输入,调用students对象相应的函数,执行相应的操作,<br>完成插入删除，查找，修改，统计功能.</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-插入功能的实现\"><a href=\"#3-1-插入功能的实现\" class=\"headerlink\" title=\"3.1 插入功能的实现\"></a>3.1 插入功能的实现</h2><h3 id=\"3-1-1-表头插入\"><a href=\"#3-1-1-表头插入\" class=\"headerlink\" title=\"3.1.1 表头插入\"></a>3.1.1 表头插入</h3><p>在建立表时,就采用了简单的在表头插入,即每一个学生在插入时都处于first的位置,调用了Node的构造方法,所以很简洁</p>\n<blockquote>\n<p>  void add(T t)<br>  {<br>  Node&lt;T&gt; *oldFirst = first;<br>  first = new Node&lt;T&gt;(t,oldFirst);<br>  }</p>\n</blockquote>\n<h3 id=\"3-1-2-任意位置插入\"><a href=\"#3-1-2-任意位置插入\" class=\"headerlink\" title=\"3.1.2 任意位置插入\"></a>3.1.2 任意位置插入</h3><p>提供了在任意位置插入的功能,首先判断传入位置是否合理,然后移到要插入的位置的前面一个,进行插入,并且展示插入后的学生表.</p>\n<blockquote>\n<p>  void insert(int pos, T t)<br>  {<br>  if(pos&lt;=0) return;<br>  //相当于add<br>  if(pos==1)<br>  {<br>  add(t);<br>  }<br>  else<br>  {<br>  Node&lt;T&gt; *cur = first;<br>  for (int i = 0; i &lt; pos - 2; ++i)<br>  {<br>  if(cur== nullptr)<br>  return;<br>  cur = cur-&gt;next;<br>  }<br>  Node&lt;T&gt; *newNode = new Node&lt;T&gt;(t,cur-&gt;next);<br>  cur-&gt;next = newNode;<br>  }<br>  show();<br>  }</p>\n</blockquote>\n<h2 id=\"3-2-删除功能的实现\"><a href=\"#3-2-删除功能的实现\" class=\"headerlink\" title=\"3.2 删除功能的实现\"></a>3.2 删除功能的实现</h2><h3 id=\"3-2-1-删除功能描述\"><a href=\"#3-2-1-删除功能描述\" class=\"headerlink\" title=\"3.2.1 删除功能描述\"></a>3.2.1 删除功能描述</h3><p>首先先判断first不为nullptr,否则继续程序可能会报错,然后根据传入的id进行判断,如果是首元素,直接让first指向它的下一个元素,即使只有一个元素的情况下也是正确的.</p>\n<p>如果不是首元素,同理,通过检测下一个元素是否为空小心的向后移动,找到下一个元素id为传入id的元素,删除之,展示删除之后的学生表.</p>\n<h3 id=\"3-2-2-删除功能代码\"><a href=\"#3-2-2-删除功能代码\" class=\"headerlink\" title=\"3.2.2 删除功能代码\"></a>3.2.2 删除功能代码</h3><blockquote>\n<p>  void pop(const string &amp; id)<br>  {<br>  if(first== nullptr)<br>  return;<br>  if(id==first-&gt;value.getId())//相当于add<br>  {<br>  first = first-&gt;next;<br>  }<br>  else<br>  {<br>  for (Node&lt;T&gt; * x=first; x!= nullptr ; x=x-&gt;next)<br>  {<br>  if(x-&gt;next &amp;&amp; x-&gt;next-&gt;value.getId()==id)<br>  {<br>  Node&lt;T&gt; * temp = x-&gt;next;<br>  x-&gt;next = x-&gt;next-&gt;next;<br>  delete temp;<br>  }<br>  }<br>  }<br>  show();<br>  }</p>\n</blockquote>\n<h2 id=\"3-3-查找功能的实现\"><a href=\"#3-3-查找功能的实现\" class=\"headerlink\" title=\"3.3 查找功能的实现\"></a>3.3 查找功能的实现</h2><h3 id=\"3-3-1-查找功能描述\"><a href=\"#3-3-1-查找功能描述\" class=\"headerlink\" title=\"3.3.1 查找功能描述\"></a>3.3.1 查找功能描述</h3><p>遍历链表,找到学生表中符合传入id的元素,通过重载了的&lt;&lt;把该学生信息打印出来.</p>\n<h3 id=\"3-3-2-查找功能代码\"><a href=\"#3-3-2-查找功能代码\" class=\"headerlink\" title=\"3.3.2 查找功能代码\"></a>3.3.2 查找功能代码</h3><blockquote>\n<p>  void show(const string &amp; id)<br>  {<br>  cout&lt;&lt;endl&lt;&lt;“学号 姓名 性别 年龄 报考类别”&lt;&lt;endl;//空四格<br>  for (Node&lt;T&gt; * x=first; x!= nullptr ; x=x-&gt;next)<br>  {<br>  if(id==x-&gt;value.getId())<br>  {<br>  cout&lt;&lt;x-&gt;value&lt;&lt;endl;<br>  return;<br>  }<br>  }<br>  cout &lt;&lt; “No such student”;<br>  }</p>\n</blockquote>\n<h2 id=\"3-4-修改功能的实现\"><a href=\"#3-4-修改功能的实现\" class=\"headerlink\" title=\"3.4 修改功能的实现\"></a>3.4 修改功能的实现</h2><h3 id=\"3-4-1-修改功能描述\"><a href=\"#3-4-1-修改功能描述\" class=\"headerlink\" title=\"3.4.1 修改功能描述\"></a>3.4.1 修改功能描述</h3><p>修改功能首先根据传入的id找到对应的学生,然后根据传入的pos,找到想要修改的属性,并且把该属性设置为传入的value值,需要注意的是,如果传入的是age的string,需要转换为int.重新展示学生信息表.</p>\n<h3 id=\"3-4-2-修改功能代码\"><a href=\"#3-4-2-修改功能代码\" class=\"headerlink\" title=\"3.4.2 修改功能代码\"></a>3.4.2 修改功能代码</h3><blockquote>\n<p>  void change(const string &amp; id,int pos,string value)<br>  {<br>  //pos 0,1,2,3,4 id,name,gender,age,examCategory<br>  for (Node&lt;T&gt; * x=first; x!= nullptr ; x=x-&gt;next)<br>  {<br>  if(id==x-&gt;value.getId())<br>  {<br>  switch (pos)<br>  {<br>  case 0:<br>  x-&gt;value.setId(value);<br>  break;<br>  case 1:<br>  x-&gt;value.setName(value);<br>  break;<br>  case 2:<br>  x-&gt;value.setGender(value);<br>  break;<br>  case 3:<br>  x-&gt;value.setAge(atoi(value.c_str()));<br>  break;<br>  case 4:<br>  x-&gt;value.setExamCategory(value);<br>  break;<br>  default:<br>  break;<br>  }<br>  }<br>  }<br>  show();<br>  }</p>\n</blockquote>\n<h2 id=\"3-5-统计功能的实现\"><a href=\"#3-5-统计功能的实现\" class=\"headerlink\" title=\"3.5 统计功能的实现\"></a>3.5 统计功能的实现</h2><blockquote>\n<p>  void show()<br>  {<br>  cout&lt;&lt;endl&lt;&lt;“学号 姓名 性别 年龄 报考类别”&lt;&lt;endl;//空四格<br>  for (Node&lt;T&gt; * x=first; x!= nullptr ; x=x-&gt;next)<br>  {<br>  cout&lt;&lt;x-&gt;value&lt;&lt;endl;<br>  }<br>  }</p>\n</blockquote>\n<h2 id=\"3-6-总体系统的实现\"><a href=\"#3-6-总体系统的实现\" class=\"headerlink\" title=\"3.6 总体系统的实现\"></a>3.6 总体系统的实现</h2><h3 id=\"3-6-1-总体系统描述\"><a href=\"#3-6-1-总体系统描述\" class=\"headerlink\" title=\"3.6.1 总体系统描述\"></a>3.6.1 总体系统描述</h3><p>引导用户输入建立表的总人数N,创建表studentList,并引导用户逐个输入每个学生的每个属性.展示学生表.进入循环,根据用户输入的operate,switch之,并且根据不同的operate调用studentList里相应的函数.</p>\n<h3 id=\"3-6-2-总体系统核心代码\"><a href=\"#3-6-2-总体系统核心代码\" class=\"headerlink\" title=\"3.6.2 总体系统核心代码\"></a>3.6.2 总体系统核心代码</h3><p>bool is_continue=true;<br>while(is_continue)<br>{<br>cout&lt;&lt;“请选择你要进行的操作：”;<br>int operate;//操作<br>int pos;//位置<br>string id,name,gender,exam_category;<br>int age;<br>string value;//修改时指定的属性<br>Student student;<br>cin&gt;&gt;operate;<br>//1为插入，2为删除，3为查找，4为修改，5为统计，0为取消操作<br>switch(operate)<br>{<br>case 1:<br>cout&lt;&lt;“请输入你要插入的考生的位置：”;<br>cin&gt;&gt;pos;<br>//插入一个考生信息<br>cout &lt;&lt; “请依次输入该考生的信息: “;<br>cin&gt;&gt;id&gt;&gt;name&gt;&gt;gender&gt;&gt;age&gt;&gt;exam_category;<br>student.setId(id);<br>student.setName(name);<br>student.setGender(gender);<br>student.setAge(age);<br>student.setExamCategory(exam_category);<br>studentList.insert(pos,student);<br>break;<br>case 2:<br>cout&lt;&lt;“请输入要删除的考生的考号：”;<br>//注意是操作考号，所有得是string<br>cin&gt;&gt;id;<br>studentList.pop(id);<br>break;<br>case 3:<br>cout &lt;&lt; “请输入要查找的考生的考号：”;<br>cin &gt;&gt; id;<br>studentList.show(id);<br>break;<br>case 4:<br>cout &lt;&lt; “请输入要修改的考生的考号：”;<br>cin &gt;&gt; id;<br>cout &lt;&lt; “请输入要修改的位置：”;<br>cin &gt;&gt; pos;<br>cout &lt;&lt; “请输入要修改的值：”;<br>cin &gt;&gt; value;<br>studentList.change(id,pos,value);<br>break;<br>case 5:<br>studentList.show();<br>break;<br>case 0:<br>is_continue=false;<br>break;<br>default:<br>break;<br>}<br>}</p>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><h2 id=\"4-1-功能测试\"><a href=\"#4-1-功能测试\" class=\"headerlink\" title=\"4.1 功能测试\"></a>4.1 功能测试</h2><h3 id=\"4-1-1-建立功能测试\"><a href=\"#4-1-1-建立功能测试\" class=\"headerlink\" title=\"4.1.1 建立功能测试\"></a>4.1.1 建立功能测试</h3><p><strong>测试用例</strong>：</p>\n<p>5<br>1 stu1 女 18 软件工程师<br>2 stu2 男 19 计算机科学<br>3 stu3 男 20 大数据分析<br>4 stu4 男 21 机器学习<br>5 stu5 女 22 数据挖掘</p>\n<p><strong>实验结果</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/6e28543e0dcaa302d2bc3f16ab6f0df0.png\"></p>\n<h3 id=\"4-1-2-插入功能测试\"><a href=\"#4-1-2-插入功能测试\" class=\"headerlink\" title=\"4.1.2 插入功能测试\"></a>4.1.2 插入功能测试</h3><p><strong>测试用例：</strong></p>\n<p>1<br>5<br>7 stu7 女 27 游戏开发</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/58a01c08b8cfeb5c32862265996c6065.png\"></p>\n<h3 id=\"4-1-3-删除功能测试\"><a href=\"#4-1-3-删除功能测试\" class=\"headerlink\" title=\"4.1.3 删除功能测试\"></a>4.1.3 删除功能测试</h3><p><strong>测试用例：</strong>删除考号为7的考生</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4c9a14aee03df511773dba811ea94f16.png\"></p>\n<h3 id=\"4-1-4-查找功能测试\"><a href=\"#4-1-4-查找功能测试\" class=\"headerlink\" title=\"4.1.4 查找功能测试\"></a>4.1.4 查找功能测试</h3><p><strong>测试用例：</strong>查找考号为4的考生</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/454ee04d2df779557d016e4e945d8f6a.png\"></p>\n<h3 id=\"4-1-5-修改功能测试\"><a href=\"#4-1-5-修改功能测试\" class=\"headerlink\" title=\"4.1.5 修改功能测试\"></a>4.1.5 修改功能测试</h3><p><strong>测试用例：</strong>修改考号为1的学生的姓名为stu100</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/abc09b37d16301104d6e660fbde5dc38.png\"></p>\n<h3 id=\"4-1-6-统计功能测试\"><a href=\"#4-1-6-统计功能测试\" class=\"headerlink\" title=\"4.1.6 统计功能测试\"></a>4.1.6 统计功能测试</h3><p><strong>测试用例：</strong>统计所有学生信息</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d4cb88b7f6e75deb38584098e6612d73.png\"></p>\n<h2 id=\"4-2-边界测试\"><a href=\"#4-2-边界测试\" class=\"headerlink\" title=\"4.2 边界测试\"></a>4.2 边界测试</h2><h3 id=\"4-2-1-初始化无输入数据\"><a href=\"#4-2-1-初始化无输入数据\" class=\"headerlink\" title=\"4.2.1 初始化无输入数据\"></a>4.2.1 初始化无输入数据</h3><p><strong>测试用例：</strong>初始无输入数据</p>\n<p>预期结果:程序不报错,且进入循环中</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/a14ee996512875dbae403ae914f66822.png\"></p>\n<h3 id=\"4-2-2-删除头结点\"><a href=\"#4-2-2-删除头结点\" class=\"headerlink\" title=\"4.2.2 删除头结点\"></a>4.2.2 删除头结点</h3><p><strong>测试用例：</strong>删除头结点</p>\n<p><strong>预期结果：</strong>程序正常运行，不崩溃。</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/00fba70a23a5ad7de4d31d6b6d3e27ef.png\"></p>\n<h3 id=\"4-2-3-删除后链表为空\"><a href=\"#4-2-3-删除后链表为空\" class=\"headerlink\" title=\"4.2.3 删除后链表为空\"></a>4.2.3 删除后链表为空</h3><p><strong>测试用例：</strong>删除前链表只有一个结点，删除后链表为空</p>\n<p><strong>预期结果：</strong>程序正常运行，不崩溃。</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/5e11136a7a56560eb2f52355c8e33775.png\"></p>\n<h3 id=\"4-2-4-考生人数错误\"><a href=\"#4-2-4-考生人数错误\" class=\"headerlink\" title=\"4.2.4 考生人数错误\"></a>4.2.4 考生人数错误</h3><p><strong>测试用例：</strong>输入考生人数为负数</p>\n<p><strong>预期结果：</strong>程序正常运行不崩溃。</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/bd257e9238fcab35de511d506f2222d7.png\"></p>\n<h3 id=\"4-2-5-位置不正确\"><a href=\"#4-2-5-位置不正确\" class=\"headerlink\" title=\"4.2.5 位置不正确\"></a>4.2.5 位置不正确</h3><p><strong>测试用例：</strong>在不正确的位置进行插入</p>\n<p><strong>预期结果：</strong>程序正常运行不崩溃。</p>\n<p><strong>实验结果</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/59ed2b4346c5a1c09d535798a3450fa7.png\"></p>\n<h3 id=\"4-2-6-id不存在\"><a href=\"#4-2-6-id不存在\" class=\"headerlink\" title=\"4.2.6 id不存在\"></a>4.2.6 id不存在</h3><p><strong>测试用例：</strong>删除不存在的id</p>\n<p><strong>预期结果：</strong>程序正常运行不崩溃。</p>\n<p><strong>实验结果</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f5309c8358bd23683dd30b76491bc03c.png\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/tongji4m3/DataStructureDesign\" target=\"_blank\" rel=\"noopener\">源码地址</a></h1><blockquote>\n<p>  考试报名系统</p>\n<p>  数据结构作业 C++语言实现</p>\n<p>  直接从word文档转的,代码格式有些问题,建议在源码地址查看word版</p>\n</blockquote>\n<h1 id=\"1-分析\"><a href=\"#1-分析\" class=\"headerlink\" title=\"1 分析\"></a>1 分析</h1><h2 id=\"1-1-背景分析\"><a href=\"#1-1-背景分析\" class=\"headerlink\" title=\"1.1 背景分析\"></a>1.1 背景分析</h2><p>考试报名工作给各高校报名工作带来了新的挑战，给教务管理部门增加了很大的工作量。本项目是对考试报名管理的简单模拟，用控制台选项的选择方式完成下列功能：输入考生信息；输出考生信息；查询考生信息；添加考生信息；修改考生信息；删除考生信息。</p>\n<h2 id=\"1-2-功能分析\"><a href=\"#1-2-功能分析\" class=\"headerlink\" title=\"1.2 功能分析\"></a>1.2 功能分析</h2><p>本项目的实质是完成对考生信息的建立，查找，插入，修改，删除等功能。其中考生信息包括准考证号，姓名，性别，年龄和报考类别等信息。项目在设计时应首先确定系统的数据结构，定义类的成员变量和成员函数；然后实现各成员函数以完成对数据操作的相应功能；最后完成主函数以验证各个成员函数的功能并得到运行结果。采用链表实现。</p>\n<p>综上,至少有建立，查找，插入，修改，删除,退出功能。</p>\n<h1 id=\"2-设计\"><a href=\"#2-设计\" class=\"headerlink\" title=\"2 设计\"></a>2 设计</h1><h2 id=\"2-1-存储结构设计\"><a href=\"#2-1-存储结构设计\" class=\"headerlink\" title=\"2.1 存储结构设计\"></a>2.1 存储结构设计</h2><p>因为在建立学生信息表之后还需要进行大量添加,删除操作,所以采用链表存储.用模板类Node存储学生信息,模板类LinkedList存储一条由Node构成的链表,即存储了所有学生信息,并且能进行相应的操作.因为无其他要求,所以采用单向链表,且有一个头指针first.</p>\n<p>LinkedList中,通过add(),pop(),change(),show()等方法,来对链表进行对应的操作,即实现了对学生信息表的增删改查功能.</p>\n<h2 id=\"2-2-Student类结构设计\"><a href=\"#2-2-Student类结构设计\" class=\"headerlink\" title=\"2.2 Student类结构设计\"></a>2.2 Student类结构设计</h2><p>Student类代表了一个学生的实体,含有该学生所需要的成员变量:准考证号，姓名，性别，年龄和报考类别.这些成员变量设为private以达到封装的效果,所以也提供了相应的get(),set()方法来对这些属性进行修改.并且有一个展示该学生信息的show()方法.</p>\n<h2 id=\"2-3-主程序设计\"><a href=\"#2-3-主程序设计\" class=\"headerlink\" title=\"2.3 主程序设计\"></a>2.3 主程序设计</h2><p>开始时建立LinkedList的对象students,输出窗口将提示引导用户逐步建立学生信息表,然后展示所建立表.随后进入循环,直到用户按0退出程序.循环中,根据用户输入,调用students对象相应的函数,执行相应的操作,<br>完成插入删除，查找，修改，统计功能.</p>\n<h1 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h1><h2 id=\"3-1-插入功能的实现\"><a href=\"#3-1-插入功能的实现\" class=\"headerlink\" title=\"3.1 插入功能的实现\"></a>3.1 插入功能的实现</h2><h3 id=\"3-1-1-表头插入\"><a href=\"#3-1-1-表头插入\" class=\"headerlink\" title=\"3.1.1 表头插入\"></a>3.1.1 表头插入</h3><p>在建立表时,就采用了简单的在表头插入,即每一个学生在插入时都处于first的位置,调用了Node的构造方法,所以很简洁</p>\n<blockquote>\n<p>  void add(T t)<br>  {<br>  Node&lt;T&gt; *oldFirst = first;<br>  first = new Node&lt;T&gt;(t,oldFirst);<br>  }</p>\n</blockquote>\n<h3 id=\"3-1-2-任意位置插入\"><a href=\"#3-1-2-任意位置插入\" class=\"headerlink\" title=\"3.1.2 任意位置插入\"></a>3.1.2 任意位置插入</h3><p>提供了在任意位置插入的功能,首先判断传入位置是否合理,然后移到要插入的位置的前面一个,进行插入,并且展示插入后的学生表.</p>\n<blockquote>\n<p>  void insert(int pos, T t)<br>  {<br>  if(pos&lt;=0) return;<br>  //相当于add<br>  if(pos==1)<br>  {<br>  add(t);<br>  }<br>  else<br>  {<br>  Node&lt;T&gt; *cur = first;<br>  for (int i = 0; i &lt; pos - 2; ++i)<br>  {<br>  if(cur== nullptr)<br>  return;<br>  cur = cur-&gt;next;<br>  }<br>  Node&lt;T&gt; *newNode = new Node&lt;T&gt;(t,cur-&gt;next);<br>  cur-&gt;next = newNode;<br>  }<br>  show();<br>  }</p>\n</blockquote>\n<h2 id=\"3-2-删除功能的实现\"><a href=\"#3-2-删除功能的实现\" class=\"headerlink\" title=\"3.2 删除功能的实现\"></a>3.2 删除功能的实现</h2><h3 id=\"3-2-1-删除功能描述\"><a href=\"#3-2-1-删除功能描述\" class=\"headerlink\" title=\"3.2.1 删除功能描述\"></a>3.2.1 删除功能描述</h3><p>首先先判断first不为nullptr,否则继续程序可能会报错,然后根据传入的id进行判断,如果是首元素,直接让first指向它的下一个元素,即使只有一个元素的情况下也是正确的.</p>\n<p>如果不是首元素,同理,通过检测下一个元素是否为空小心的向后移动,找到下一个元素id为传入id的元素,删除之,展示删除之后的学生表.</p>\n<h3 id=\"3-2-2-删除功能代码\"><a href=\"#3-2-2-删除功能代码\" class=\"headerlink\" title=\"3.2.2 删除功能代码\"></a>3.2.2 删除功能代码</h3><blockquote>\n<p>  void pop(const string &amp; id)<br>  {<br>  if(first== nullptr)<br>  return;<br>  if(id==first-&gt;value.getId())//相当于add<br>  {<br>  first = first-&gt;next;<br>  }<br>  else<br>  {<br>  for (Node&lt;T&gt; * x=first; x!= nullptr ; x=x-&gt;next)<br>  {<br>  if(x-&gt;next &amp;&amp; x-&gt;next-&gt;value.getId()==id)<br>  {<br>  Node&lt;T&gt; * temp = x-&gt;next;<br>  x-&gt;next = x-&gt;next-&gt;next;<br>  delete temp;<br>  }<br>  }<br>  }<br>  show();<br>  }</p>\n</blockquote>\n<h2 id=\"3-3-查找功能的实现\"><a href=\"#3-3-查找功能的实现\" class=\"headerlink\" title=\"3.3 查找功能的实现\"></a>3.3 查找功能的实现</h2><h3 id=\"3-3-1-查找功能描述\"><a href=\"#3-3-1-查找功能描述\" class=\"headerlink\" title=\"3.3.1 查找功能描述\"></a>3.3.1 查找功能描述</h3><p>遍历链表,找到学生表中符合传入id的元素,通过重载了的&lt;&lt;把该学生信息打印出来.</p>\n<h3 id=\"3-3-2-查找功能代码\"><a href=\"#3-3-2-查找功能代码\" class=\"headerlink\" title=\"3.3.2 查找功能代码\"></a>3.3.2 查找功能代码</h3><blockquote>\n<p>  void show(const string &amp; id)<br>  {<br>  cout&lt;&lt;endl&lt;&lt;“学号 姓名 性别 年龄 报考类别”&lt;&lt;endl;//空四格<br>  for (Node&lt;T&gt; * x=first; x!= nullptr ; x=x-&gt;next)<br>  {<br>  if(id==x-&gt;value.getId())<br>  {<br>  cout&lt;&lt;x-&gt;value&lt;&lt;endl;<br>  return;<br>  }<br>  }<br>  cout &lt;&lt; “No such student”;<br>  }</p>\n</blockquote>\n<h2 id=\"3-4-修改功能的实现\"><a href=\"#3-4-修改功能的实现\" class=\"headerlink\" title=\"3.4 修改功能的实现\"></a>3.4 修改功能的实现</h2><h3 id=\"3-4-1-修改功能描述\"><a href=\"#3-4-1-修改功能描述\" class=\"headerlink\" title=\"3.4.1 修改功能描述\"></a>3.4.1 修改功能描述</h3><p>修改功能首先根据传入的id找到对应的学生,然后根据传入的pos,找到想要修改的属性,并且把该属性设置为传入的value值,需要注意的是,如果传入的是age的string,需要转换为int.重新展示学生信息表.</p>\n<h3 id=\"3-4-2-修改功能代码\"><a href=\"#3-4-2-修改功能代码\" class=\"headerlink\" title=\"3.4.2 修改功能代码\"></a>3.4.2 修改功能代码</h3><blockquote>\n<p>  void change(const string &amp; id,int pos,string value)<br>  {<br>  //pos 0,1,2,3,4 id,name,gender,age,examCategory<br>  for (Node&lt;T&gt; * x=first; x!= nullptr ; x=x-&gt;next)<br>  {<br>  if(id==x-&gt;value.getId())<br>  {<br>  switch (pos)<br>  {<br>  case 0:<br>  x-&gt;value.setId(value);<br>  break;<br>  case 1:<br>  x-&gt;value.setName(value);<br>  break;<br>  case 2:<br>  x-&gt;value.setGender(value);<br>  break;<br>  case 3:<br>  x-&gt;value.setAge(atoi(value.c_str()));<br>  break;<br>  case 4:<br>  x-&gt;value.setExamCategory(value);<br>  break;<br>  default:<br>  break;<br>  }<br>  }<br>  }<br>  show();<br>  }</p>\n</blockquote>\n<h2 id=\"3-5-统计功能的实现\"><a href=\"#3-5-统计功能的实现\" class=\"headerlink\" title=\"3.5 统计功能的实现\"></a>3.5 统计功能的实现</h2><blockquote>\n<p>  void show()<br>  {<br>  cout&lt;&lt;endl&lt;&lt;“学号 姓名 性别 年龄 报考类别”&lt;&lt;endl;//空四格<br>  for (Node&lt;T&gt; * x=first; x!= nullptr ; x=x-&gt;next)<br>  {<br>  cout&lt;&lt;x-&gt;value&lt;&lt;endl;<br>  }<br>  }</p>\n</blockquote>\n<h2 id=\"3-6-总体系统的实现\"><a href=\"#3-6-总体系统的实现\" class=\"headerlink\" title=\"3.6 总体系统的实现\"></a>3.6 总体系统的实现</h2><h3 id=\"3-6-1-总体系统描述\"><a href=\"#3-6-1-总体系统描述\" class=\"headerlink\" title=\"3.6.1 总体系统描述\"></a>3.6.1 总体系统描述</h3><p>引导用户输入建立表的总人数N,创建表studentList,并引导用户逐个输入每个学生的每个属性.展示学生表.进入循环,根据用户输入的operate,switch之,并且根据不同的operate调用studentList里相应的函数.</p>\n<h3 id=\"3-6-2-总体系统核心代码\"><a href=\"#3-6-2-总体系统核心代码\" class=\"headerlink\" title=\"3.6.2 总体系统核心代码\"></a>3.6.2 总体系统核心代码</h3><p>bool is_continue=true;<br>while(is_continue)<br>{<br>cout&lt;&lt;“请选择你要进行的操作：”;<br>int operate;//操作<br>int pos;//位置<br>string id,name,gender,exam_category;<br>int age;<br>string value;//修改时指定的属性<br>Student student;<br>cin&gt;&gt;operate;<br>//1为插入，2为删除，3为查找，4为修改，5为统计，0为取消操作<br>switch(operate)<br>{<br>case 1:<br>cout&lt;&lt;“请输入你要插入的考生的位置：”;<br>cin&gt;&gt;pos;<br>//插入一个考生信息<br>cout &lt;&lt; “请依次输入该考生的信息: “;<br>cin&gt;&gt;id&gt;&gt;name&gt;&gt;gender&gt;&gt;age&gt;&gt;exam_category;<br>student.setId(id);<br>student.setName(name);<br>student.setGender(gender);<br>student.setAge(age);<br>student.setExamCategory(exam_category);<br>studentList.insert(pos,student);<br>break;<br>case 2:<br>cout&lt;&lt;“请输入要删除的考生的考号：”;<br>//注意是操作考号，所有得是string<br>cin&gt;&gt;id;<br>studentList.pop(id);<br>break;<br>case 3:<br>cout &lt;&lt; “请输入要查找的考生的考号：”;<br>cin &gt;&gt; id;<br>studentList.show(id);<br>break;<br>case 4:<br>cout &lt;&lt; “请输入要修改的考生的考号：”;<br>cin &gt;&gt; id;<br>cout &lt;&lt; “请输入要修改的位置：”;<br>cin &gt;&gt; pos;<br>cout &lt;&lt; “请输入要修改的值：”;<br>cin &gt;&gt; value;<br>studentList.change(id,pos,value);<br>break;<br>case 5:<br>studentList.show();<br>break;<br>case 0:<br>is_continue=false;<br>break;<br>default:<br>break;<br>}<br>}</p>\n<h1 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4 测试\"></a>4 测试</h1><h2 id=\"4-1-功能测试\"><a href=\"#4-1-功能测试\" class=\"headerlink\" title=\"4.1 功能测试\"></a>4.1 功能测试</h2><h3 id=\"4-1-1-建立功能测试\"><a href=\"#4-1-1-建立功能测试\" class=\"headerlink\" title=\"4.1.1 建立功能测试\"></a>4.1.1 建立功能测试</h3><p><strong>测试用例</strong>：</p>\n<p>5<br>1 stu1 女 18 软件工程师<br>2 stu2 男 19 计算机科学<br>3 stu3 男 20 大数据分析<br>4 stu4 男 21 机器学习<br>5 stu5 女 22 数据挖掘</p>\n<p><strong>实验结果</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/6e28543e0dcaa302d2bc3f16ab6f0df0.png\"></p>\n<h3 id=\"4-1-2-插入功能测试\"><a href=\"#4-1-2-插入功能测试\" class=\"headerlink\" title=\"4.1.2 插入功能测试\"></a>4.1.2 插入功能测试</h3><p><strong>测试用例：</strong></p>\n<p>1<br>5<br>7 stu7 女 27 游戏开发</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/58a01c08b8cfeb5c32862265996c6065.png\"></p>\n<h3 id=\"4-1-3-删除功能测试\"><a href=\"#4-1-3-删除功能测试\" class=\"headerlink\" title=\"4.1.3 删除功能测试\"></a>4.1.3 删除功能测试</h3><p><strong>测试用例：</strong>删除考号为7的考生</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/4c9a14aee03df511773dba811ea94f16.png\"></p>\n<h3 id=\"4-1-4-查找功能测试\"><a href=\"#4-1-4-查找功能测试\" class=\"headerlink\" title=\"4.1.4 查找功能测试\"></a>4.1.4 查找功能测试</h3><p><strong>测试用例：</strong>查找考号为4的考生</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/454ee04d2df779557d016e4e945d8f6a.png\"></p>\n<h3 id=\"4-1-5-修改功能测试\"><a href=\"#4-1-5-修改功能测试\" class=\"headerlink\" title=\"4.1.5 修改功能测试\"></a>4.1.5 修改功能测试</h3><p><strong>测试用例：</strong>修改考号为1的学生的姓名为stu100</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/abc09b37d16301104d6e660fbde5dc38.png\"></p>\n<h3 id=\"4-1-6-统计功能测试\"><a href=\"#4-1-6-统计功能测试\" class=\"headerlink\" title=\"4.1.6 统计功能测试\"></a>4.1.6 统计功能测试</h3><p><strong>测试用例：</strong>统计所有学生信息</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/d4cb88b7f6e75deb38584098e6612d73.png\"></p>\n<h2 id=\"4-2-边界测试\"><a href=\"#4-2-边界测试\" class=\"headerlink\" title=\"4.2 边界测试\"></a>4.2 边界测试</h2><h3 id=\"4-2-1-初始化无输入数据\"><a href=\"#4-2-1-初始化无输入数据\" class=\"headerlink\" title=\"4.2.1 初始化无输入数据\"></a>4.2.1 初始化无输入数据</h3><p><strong>测试用例：</strong>初始无输入数据</p>\n<p>预期结果:程序不报错,且进入循环中</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/a14ee996512875dbae403ae914f66822.png\"></p>\n<h3 id=\"4-2-2-删除头结点\"><a href=\"#4-2-2-删除头结点\" class=\"headerlink\" title=\"4.2.2 删除头结点\"></a>4.2.2 删除头结点</h3><p><strong>测试用例：</strong>删除头结点</p>\n<p><strong>预期结果：</strong>程序正常运行，不崩溃。</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/00fba70a23a5ad7de4d31d6b6d3e27ef.png\"></p>\n<h3 id=\"4-2-3-删除后链表为空\"><a href=\"#4-2-3-删除后链表为空\" class=\"headerlink\" title=\"4.2.3 删除后链表为空\"></a>4.2.3 删除后链表为空</h3><p><strong>测试用例：</strong>删除前链表只有一个结点，删除后链表为空</p>\n<p><strong>预期结果：</strong>程序正常运行，不崩溃。</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/5e11136a7a56560eb2f52355c8e33775.png\"></p>\n<h3 id=\"4-2-4-考生人数错误\"><a href=\"#4-2-4-考生人数错误\" class=\"headerlink\" title=\"4.2.4 考生人数错误\"></a>4.2.4 考生人数错误</h3><p><strong>测试用例：</strong>输入考生人数为负数</p>\n<p><strong>预期结果：</strong>程序正常运行不崩溃。</p>\n<p><strong>实验结果：</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/bd257e9238fcab35de511d506f2222d7.png\"></p>\n<h3 id=\"4-2-5-位置不正确\"><a href=\"#4-2-5-位置不正确\" class=\"headerlink\" title=\"4.2.5 位置不正确\"></a>4.2.5 位置不正确</h3><p><strong>测试用例：</strong>在不正确的位置进行插入</p>\n<p><strong>预期结果：</strong>程序正常运行不崩溃。</p>\n<p><strong>实验结果</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/59ed2b4346c5a1c09d535798a3450fa7.png\"></p>\n<h3 id=\"4-2-6-id不存在\"><a href=\"#4-2-6-id不存在\" class=\"headerlink\" title=\"4.2.6 id不存在\"></a>4.2.6 id不存在</h3><p><strong>测试用例：</strong>删除不存在的id</p>\n<p><strong>预期结果：</strong>程序正常运行不崩溃。</p>\n<p><strong>实验结果</strong></p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f5309c8358bd23683dd30b76491bc03c.png\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckkq5o6vp000bjotp9n1zbd69","category_id":"ckkq5o6vm0008jotpdcd18avl","_id":"ckkq5o6vv000hjotphe3121cc"},{"post_id":"ckkq5o6vh0006jotp5wf6fzsk","category_id":"ckkq5o6vm0008jotpdcd18avl","_id":"ckkq5o6vw000ljotp0dr2bc7c"},{"post_id":"ckkq5o6vq000cjotp8kdiejoq","category_id":"ckkq5o6vm0008jotpdcd18avl","_id":"ckkq5o6vx000njotpcegf1vdf"},{"post_id":"ckkq5o6vt000fjotp6b6cg8v2","category_id":"ckkq5o6vm0008jotpdcd18avl","_id":"ckkq5o6vz000rjotp5nexbpeb"},{"post_id":"ckkq5o6vk0007jotpcqcm0hu4","category_id":"ckkq5o6vm0008jotpdcd18avl","_id":"ckkq5o6w0000ujotp7ovz99pe"},{"post_id":"ckkq5o6vu000gjotp1hcbdscp","category_id":"ckkq5o6vm0008jotpdcd18avl","_id":"ckkq5o6w3000zjotp09yvdn4k"},{"post_id":"ckkq5o6vo000ajotp79sr9reb","category_id":"ckkq5o6vm0008jotpdcd18avl","_id":"ckkq5o6w50012jotpcmhmaqrw"},{"post_id":"ckkq5o6vx000mjotp1kis0zbw","category_id":"ckkq5o6vm0008jotpdcd18avl","_id":"ckkq5o6w70015jotph6227xhy"},{"post_id":"ckkq5o6vz000tjotpa3fverm9","category_id":"ckkq5o6vm0008jotpdcd18avl","_id":"ckkq5o6w80017jotp4jclc9dr"},{"post_id":"ckkq5o6vw000kjotph3o36sj4","category_id":"ckkq5o6vy000pjotphv84crnp","_id":"ckkq5o6wa001ajotpdjm2hybg"},{"post_id":"ckkq5o6w2000xjotpgcirgk67","category_id":"ckkq5o6vy000pjotphv84crnp","_id":"ckkq5o6wa001cjotp1gwq11pp"},{"post_id":"ckkq5o6w40011jotpbxa9efsv","category_id":"ckkq5o6vy000pjotphv84crnp","_id":"ckkq5o6wb001ejotpab564nl7"},{"post_id":"ckkq5o6vy000qjotp96qtfbo1","category_id":"ckkq5o6vy000pjotphv84crnp","_id":"ckkq5o6wd001jjotpf5xqgefv"},{"post_id":"ckkq5o6w60014jotpa40h6quc","category_id":"ckkq5o6vy000pjotphv84crnp","_id":"ckkq5o6we001mjotp5s64f70i"},{"post_id":"ckkq5o6w80016jotpbmey3xaw","category_id":"ckkq5o6vy000pjotphv84crnp","_id":"ckkq5o6wh001rjotpazsj54d7"},{"post_id":"ckkq5o6w90019jotphjlw4f2b","category_id":"ckkq5o6vy000pjotphv84crnp","_id":"ckkq5o6wj001ujotpc30ohi14"},{"post_id":"ckkq5o6wd001ljotpfu098kwl","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6wk001yjotp2h5x91oa"},{"post_id":"ckkq5o6wa001bjotpgva3c3vx","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6wm0020jotp1j2o124s"},{"post_id":"ckkq5o6wg001pjotp6tv8auya","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6wo0023jotpc1fm1zs4"},{"post_id":"ckkq5o6wi001tjotp07fk5vl9","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6wr0026jotp0bam4sah"},{"post_id":"ckkq5o6wb001djotp782v0pu9","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6ws002ajotp9cyk0skz"},{"post_id":"ckkq5o6wj001wjotp3o2n7vgi","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6wt002djotp2rzrgmn0"},{"post_id":"ckkq5o6wl001zjotp3bdzdbjb","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6wu002gjotpclwhfs18"},{"post_id":"ckkq5o6wc001ijotpdjsugbnk","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6wv002kjotp1unx5p6d"},{"post_id":"ckkq5o6wn0022jotp0rdh32je","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6ww002ojotp1gwlbxi5"},{"post_id":"ckkq5o6wo0025jotp9ze701zz","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6wz002sjotp2tne5ibl"},{"post_id":"ckkq5o6ws0029jotp9upycyf5","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6x0002ujotp9p8qhukr"},{"post_id":"ckkq5o6wt002fjotpghcs4y0o","category_id":"ckkq5o6wc001gjotp1ncuca7s","_id":"ckkq5o6x3002yjotp1yit034g"},{"post_id":"ckkq5o6wv002njotp2eiphiu0","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6x50031jotpatbe2x8p"},{"post_id":"ckkq5o6ws002cjotpf37sefzg","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6x60035jotpapn7aan6"},{"post_id":"ckkq5o6wy002qjotp7xhahzk9","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6x70038jotpc2ha80ww"},{"post_id":"ckkq5o6x0002tjotp1wolglp8","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6x8003cjotp784xf07t"},{"post_id":"ckkq5o6wu002jjotp9cg9fnun","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6x8003fjotpdaag0dgx"},{"post_id":"ckkq5o6x2002xjotpg0i9c1c7","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6x9003jjotpd0ft4tc7"},{"post_id":"ckkq5o6x30030jotphi8yh7ug","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6xa003mjotphu7c06jc"},{"post_id":"ckkq5o6x50034jotpazyg1vox","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6xb003pjotpcwcz5bjn"},{"post_id":"ckkq5o6x60037jotp2u6g74e5","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6xc003tjotpez1shk8m"},{"post_id":"ckkq5o6x7003bjotpaj9d9en8","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6xd003xjotpd7r0hsp8"},{"post_id":"ckkq5o6x8003ejotp5uoufkih","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6xe0040jotpcv2i6tow"},{"post_id":"ckkq5o6x9003ijotp1jxt72px","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6xf0043jotpcwsbgg00"},{"post_id":"ckkq5o6x9003ljotpfzpa5pb2","category_id":"ckkq5o6wu002ijotp29ww1cdu","_id":"ckkq5o6xg0046jotpfda7354i"},{"post_id":"ckkq5o6xd003zjotp8easeo1r","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xi004ajotp1sib1l9x"},{"post_id":"ckkq5o6xa003ojotp9c952tv2","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xm004ejotp6sd5c3g9"},{"post_id":"ckkq5o6xe0041jotp41uqgiz1","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xm004hjotp1b7bcp90"},{"post_id":"ckkq5o6xg0045jotpgy23fqfp","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xn004kjotp3z0wc7o6"},{"post_id":"ckkq5o6xb003sjotpg8k08de4","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xo004njotp4o7p5prb"},{"post_id":"ckkq5o6xg0048jotpcr9n3pgu","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xp004qjotp60ia8cd6"},{"post_id":"ckkq5o6xl004djotpeedy3xjk","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xr004ujotp68f83x34"},{"post_id":"ckkq5o6xc003wjotpbaele78m","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xs004xjotp5smvhas9"},{"post_id":"ckkq5o6xm004gjotp4vlc0c13","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xu0051jotp89la65sj"},{"post_id":"ckkq5o6xn004jjotpg48j2x1s","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xv0054jotpcr228gub"},{"post_id":"ckkq5o6xo004mjotpas42hlq7","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xw0057jotphm2t7w3g"},{"post_id":"ckkq5o6xo004pjotp7edygz15","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xx0059jotpbxqc0uyh"},{"post_id":"ckkq5o6xq004tjotp6qwghwnk","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6xz005cjotpa2b8agb9"},{"post_id":"ckkq5o6xr004wjotp6rc60cuy","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6y0005fjotp333bhor1"},{"post_id":"ckkq5o6xt0050jotp1q5i10um","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6y3005jjotpdey3abej"},{"post_id":"ckkq5o6xu0053jotpfaib5lvq","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6y4005ljotpclscez3r"},{"post_id":"ckkq5o6xv0056jotp6o8f92l0","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6y5005ojotpc37j3ar9"},{"post_id":"ckkq5o6xw0058jotp9e065d7j","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6y6005rjotp8dm25l83"},{"post_id":"ckkq5o6xy005bjotpg30z87qs","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6y7005vjotp6ado0gfl"},{"post_id":"ckkq5o6y0005ejotp8ev7cxzl","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6y8005xjotp3qkmc3il"},{"post_id":"ckkq5o6y2005ijotpg6rw4fof","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6y90060jotp9q8u9cav"},{"post_id":"ckkq5o6y3005kjotpe3nza4vb","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6ya0063jotp7tje3y6p"},{"post_id":"ckkq5o6y4005njotp6bu71iew","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yb0067jotp1we09azk"},{"post_id":"ckkq5o6y5005qjotp7vxy8ans","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yc006ajotp0i2o60o6"},{"post_id":"ckkq5o6y7005ujotp0fxh78p3","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yd006cjotphui5cfhv"},{"post_id":"ckkq5o6y8005wjotph2i750lt","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6ye006fjotpb1z35w5n"},{"post_id":"ckkq5o6y9005zjotpf1e52ngn","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yg006hjotp12n6bj7g"},{"post_id":"ckkq5o6ya0062jotp4m2u7ezk","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yg006kjotp7qva8euc"},{"post_id":"ckkq5o6yb0066jotphl2u0mqf","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yh006mjotp8a7y4vvb"},{"post_id":"ckkq5o6yc0069jotp71wtgoad","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yi006pjotp7r4maqsj"},{"post_id":"ckkq5o6yc006bjotphqccgb9g","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yj006sjotp30rceqpb"},{"post_id":"ckkq5o6ye006ejotpb03da097","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yk006wjotp6nzl0yib"},{"post_id":"ckkq5o6yf006gjotp9ccs4ba2","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6ym006zjotpdaaf0j2n"},{"post_id":"ckkq5o6yg006jjotpaz800uja","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yo0072jotp53aaddlh"},{"post_id":"ckkq5o6yh006ljotp8yoj5o8p","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yp0074jotpfljc4u9t"},{"post_id":"ckkq5o6yi006ojotphvwlcj7o","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yp0077jotpa5fc2qjm"},{"post_id":"ckkq5o6yi006rjotp0qz60x2w","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yq007ajotp1s7r2nxz"},{"post_id":"ckkq5o6yk006vjotpdi4bhgf3","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yr007ejotp5sxmf57g"},{"post_id":"ckkq5o6yk006yjotpd67uchk1","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yr007hjotp9t5x3o8w"},{"post_id":"ckkq5o6yn0071jotp246cf92o","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6ys007jjotp9oxm6xlu"},{"post_id":"ckkq5o6yo0073jotpbskj35ch","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yu007mjotp27tq8g40"},{"post_id":"ckkq5o6yp0076jotpfrxze2h0","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yv007ojotphzm5axzh"},{"post_id":"ckkq5o6yq0079jotp73339dhd","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yw007sjotp1rv42f8v"},{"post_id":"ckkq5o6yr007djotp1b0oegf9","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yx007vjotp8qkt14al"},{"post_id":"ckkq5o6yr007gjotpabk7gziq","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yy007zjotpcjas109m"},{"post_id":"ckkq5o6ys007ijotp1pzyafde","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yz0081jotp2oiafi7j"},{"post_id":"ckkq5o6yt007ljotpghfc2drm","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6yz0084jotp08ftc1zb"},{"post_id":"ckkq5o6yu007njotpbxls86fn","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6z00086jotpc723affo"},{"post_id":"ckkq5o6yv007rjotpfz7mdt0m","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6z10089jotpd5139l3m"},{"post_id":"ckkq5o6yw007ujotp9c317jtv","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6z2008cjotpeqw34h9n"},{"post_id":"ckkq5o6yx007yjotp1c0313d9","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6z3008hjotph91qa3kf"},{"post_id":"ckkq5o6yy0080jotpgrtbefou","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6z4008kjotph86ygpi8"},{"post_id":"ckkq5o6yz0083jotpaczbca4l","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6z4008ojotp67639162"},{"post_id":"ckkq5o6z00085jotphqgr3dgx","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6z5008qjotpefvweo2i"},{"post_id":"ckkq5o6z3008gjotp506q7jfs","category_id":"ckkq5o6xc003ujotph3mjhfun","_id":"ckkq5o6z6008ujotp2cjaesul"},{"post_id":"ckkq5o6z3008jjotpacx2915c","category_id":"ckkq5o6z2008fjotp22c677nj","_id":"ckkq5o6z7008xjotp6y5y4ewl"},{"post_id":"ckkq5o6z10088jotpd8ce9l9y","category_id":"ckkq5o6z2008fjotp22c677nj","_id":"ckkq5o6z70091jotp9q6ld47e"},{"post_id":"ckkq5o6z2008bjotpcflc22hc","category_id":"ckkq5o6z2008fjotp22c677nj","_id":"ckkq5o6z80094jotp4qh0csxz"},{"post_id":"ckkq5o6z6008wjotp0049hc9u","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o6z80095jotp2x9ka3i2"},{"post_id":"ckkq5o6z4008mjotp95uvfxkh","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o6z90098jotp0w6tgggj"},{"post_id":"ckkq5o6z70090jotpb7ee81fh","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o6z90099jotp63ilgpuw"},{"post_id":"ckkq5o6z5008pjotp21f97lgj","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o6za009cjotp00od11d3"},{"post_id":"ckkq5o6z5008sjotp6a2n4vub","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o6za009fjotp278o4797"},{"post_id":"ckkq5o73400mijotpcz6p19si","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73900mqjotph1b4gaw8"},{"post_id":"ckkq5o72y00mdjotpdxcggkhv","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73a00mujotp40oeef1i"},{"post_id":"ckkq5o73500mjjotp7a3r6hl2","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73a00mwjotpe5w8eegu"},{"post_id":"ckkq5o73700mnjotp1h2u9dlh","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73b00mzjotp2w5kalk1"},{"post_id":"ckkq5o72z00mejotpbqpe7ocu","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73c00n2jotp2nqlhqxb"},{"post_id":"ckkq5o73800mpjotp3rjncnys","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73d00n6jotp2aza9a41"},{"post_id":"ckkq5o73900mtjotpdk7z0k5n","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73e00n9jotp7gph5wm9"},{"post_id":"ckkq5o73100mhjotpg2yg08in","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73e00nbjotpfcw732vr"},{"post_id":"ckkq5o73a00mvjotpesyx1h1p","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73g00ngjotpauua81qw"},{"post_id":"ckkq5o73b00myjotp8fq25z6u","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73h00njjotpbkfmbh72"},{"post_id":"ckkq5o73c00n1jotpb0hudkdj","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73j00nojotp5nqnaw5u"},{"post_id":"ckkq5o73c00n5jotpbx3r5flq","category_id":"ckkq5o73000mfjotpatau6s66","_id":"ckkq5o73k00nqjotp1b65axug"},{"post_id":"ckkq5o73g00nijotp6rk52xms","category_id":"ckkq5o73f00ndjotp3stefydk","_id":"ckkq5o73m00nujotp5azxduti"},{"post_id":"ckkq5o73d00n8jotp1e0g1aju","category_id":"ckkq5o73f00ndjotp3stefydk","_id":"ckkq5o73o00nxjotpe5dk4szs"},{"post_id":"ckkq5o73h00nmjotp7cpwger0","category_id":"ckkq5o73f00ndjotp3stefydk","_id":"ckkq5o73p00o1jotpczkleoix"},{"post_id":"ckkq5o73k00npjotpblek9rmi","category_id":"ckkq5o73f00ndjotp3stefydk","_id":"ckkq5o73p00o4jotpcqapdsvw"},{"post_id":"ckkq5o73e00najotp93wq69e1","category_id":"ckkq5o73f00ndjotp3stefydk","_id":"ckkq5o73q00o7jotpgpv46b1l"},{"post_id":"ckkq5o73l00nsjotp6exmhabz","category_id":"ckkq5o73f00ndjotp3stefydk","_id":"ckkq5o73r00oajotp7c2hca0b"},{"post_id":"ckkq5o73n00nwjotp0qvw6jdz","category_id":"ckkq5o73f00ndjotp3stefydk","_id":"ckkq5o73s00odjotp18xw1tut"},{"post_id":"ckkq5o73f00nfjotp460o4440","category_id":"ckkq5o73f00ndjotp3stefydk","_id":"ckkq5o73s00ohjotp3vp3g5se"},{"post_id":"ckkq5o73o00o0jotp3yla6zdx","category_id":"ckkq5o73f00ndjotp3stefydk","_id":"ckkq5o73u00okjotpao2393bn"},{"post_id":"ckkq5o73p00o3jotp73hb91nl","category_id":"ckkq5o73f00ndjotp3stefydk","_id":"ckkq5o73x00oojotpf2ms34sr"},{"post_id":"ckkq5o73q00o6jotp7dh82wgv","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o73x00orjotp7ivmeaag"},{"post_id":"ckkq5o73r00o9jotphcowauhb","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o73y00ovjotp7h4k2hq9"},{"post_id":"ckkq5o73r00ocjotp4ui20yv5","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o74100oyjotp46tn50iy"},{"post_id":"ckkq5o73s00ogjotp0kb3gkef","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o74300p1jotp4hizgebj"},{"post_id":"ckkq5o73t00ojjotp69hz6cfc","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o74300p3jotp27gc0w10"},{"post_id":"ckkq5o73w00onjotpgy0jhlit","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o74300p5jotper9egxpi"},{"post_id":"ckkq5o73x00oqjotp57895sve","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o74400p8jotp0my25zaf"},{"post_id":"ckkq5o73y00oujotpgw5aaa96","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o74400pajotpbpiq75s9"},{"post_id":"ckkq5o73z00oxjotpaa2n0gxb","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o74400pdjotpd72h87q1"},{"post_id":"ckkq5o74q00s4jotp94bv9s8m","category_id":"ckkq5o6z6008tjotpf55cbdcd","_id":"ckkq5o74r00s7jotpc29c6nxo"}],"PostTag":[{"post_id":"ckkq5o6vh0006jotp5wf6fzsk","tag_id":"ckkq5o6vo0009jotp07to77ln","_id":"ckkq5o6vz000sjotpann4h38g"},{"post_id":"ckkq5o6vh0006jotp5wf6fzsk","tag_id":"ckkq5o6vs000ejotpe6va1gro","_id":"ckkq5o6w1000vjotp9dqa8ajl"},{"post_id":"ckkq5o6vh0006jotp5wf6fzsk","tag_id":"ckkq5o6vv000jjotpc6rx7b7d","_id":"ckkq5o6w30010jotp2wt3afco"},{"post_id":"ckkq5o6vk0007jotpcqcm0hu4","tag_id":"ckkq5o6vo0009jotp07to77ln","_id":"ckkq5o6wc001hjotph8nr93gh"},{"post_id":"ckkq5o6vk0007jotpcqcm0hu4","tag_id":"ckkq5o6vs000ejotpe6va1gro","_id":"ckkq5o6wd001kjotpdmrc7tfj"},{"post_id":"ckkq5o6vk0007jotpcqcm0hu4","tag_id":"ckkq5o6w60013jotp7a5de4sr","_id":"ckkq5o6wg001ojotp06fye815"},{"post_id":"ckkq5o6vk0007jotpcqcm0hu4","tag_id":"ckkq5o6w90018jotpfj5863mu","_id":"ckkq5o6wi001sjotp0dm804ym"},{"post_id":"ckkq5o6vo000ajotp79sr9reb","tag_id":"ckkq5o6vo0009jotp07to77ln","_id":"ckkq5o6wo0024jotpf4mp49tf"},{"post_id":"ckkq5o6vo000ajotp79sr9reb","tag_id":"ckkq5o6wf001njotpg1yvaauf","_id":"ckkq5o6wr0027jotpgxxo3v9s"},{"post_id":"ckkq5o6vo000ajotp79sr9reb","tag_id":"ckkq5o6wj001vjotp10ckfrd0","_id":"ckkq5o6ws002bjotp66hoexq5"},{"post_id":"ckkq5o6vp000bjotp9n1zbd69","tag_id":"ckkq5o6vo0009jotp07to77ln","_id":"ckkq5o6wu002hjotp7rgv0kwn"},{"post_id":"ckkq5o6vp000bjotp9n1zbd69","tag_id":"ckkq5o6wf001njotpg1yvaauf","_id":"ckkq5o6wv002ljotp3gondmf5"},{"post_id":"ckkq5o6vp000bjotp9n1zbd69","tag_id":"ckkq5o6wr0028jotp019be5zv","_id":"ckkq5o6wx002pjotpgma9d9z6"},{"post_id":"ckkq5o6vq000cjotp8kdiejoq","tag_id":"ckkq5o6vo0009jotp07to77ln","_id":"ckkq5o6x2002wjotpd2poapf5"},{"post_id":"ckkq5o6vq000cjotp8kdiejoq","tag_id":"ckkq5o6vs000ejotpe6va1gro","_id":"ckkq5o6x3002zjotp1kou4bbr"},{"post_id":"ckkq5o6vq000cjotp8kdiejoq","tag_id":"ckkq5o6wv002mjotp0gmhhn3a","_id":"ckkq5o6x50033jotphsbvhtr9"},{"post_id":"ckkq5o6vt000fjotp6b6cg8v2","tag_id":"ckkq5o6vo0009jotp07to77ln","_id":"ckkq5o6x60036jotp6jnt10ir"},{"post_id":"ckkq5o6vt000fjotp6b6cg8v2","tag_id":"ckkq5o6vs000ejotpe6va1gro","_id":"ckkq5o6x7003ajotp2ult5f0d"},{"post_id":"ckkq5o6vt000fjotp6b6cg8v2","tag_id":"ckkq5o6x0002vjotp3xh600ea","_id":"ckkq5o6x8003djotp4sg1ea6e"},{"post_id":"ckkq5o6vu000gjotp1hcbdscp","tag_id":"ckkq5o6vo0009jotp07to77ln","_id":"ckkq5o6x9003hjotp6x7p2ykx"},{"post_id":"ckkq5o6vu000gjotp1hcbdscp","tag_id":"ckkq5o6vs000ejotpe6va1gro","_id":"ckkq5o6x9003kjotp1nrq72ve"},{"post_id":"ckkq5o6vu000gjotp1hcbdscp","tag_id":"ckkq5o6x50032jotpavw5hkzw","_id":"ckkq5o6xa003njotpd5ah5q59"},{"post_id":"ckkq5o6vw000kjotph3o36sj4","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o6xb003rjotp3p959si9"},{"post_id":"ckkq5o6vw000kjotph3o36sj4","tag_id":"ckkq5o6x8003gjotpanvn0s5w","_id":"ckkq5o6xc003vjotp2r607gxq"},{"post_id":"ckkq5o6vx000mjotp1kis0zbw","tag_id":"ckkq5o6vs000ejotpe6va1gro","_id":"ckkq5o6xg0047jotp8paw2zvu"},{"post_id":"ckkq5o6vx000mjotp1kis0zbw","tag_id":"ckkq5o6xb003qjotp9o2xht5f","_id":"ckkq5o6xj004bjotph6vpar55"},{"post_id":"ckkq5o6vx000mjotp1kis0zbw","tag_id":"ckkq5o6xd003yjotp71rpf0lt","_id":"ckkq5o6xm004fjotphc8p5xwz"},{"post_id":"ckkq5o6vy000qjotp96qtfbo1","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o6xo004ljotpghvreco4"},{"post_id":"ckkq5o6vy000qjotp96qtfbo1","tag_id":"ckkq5o6xj004cjotp032mbxix","_id":"ckkq5o6xo004ojotp362459jk"},{"post_id":"ckkq5o6vz000tjotpa3fverm9","tag_id":"ckkq5o6vo0009jotp07to77ln","_id":"ckkq5o6xq004sjotph3sdbqgp"},{"post_id":"ckkq5o6vz000tjotpa3fverm9","tag_id":"ckkq5o6vs000ejotpe6va1gro","_id":"ckkq5o6xr004vjotp2q7z9fus"},{"post_id":"ckkq5o6vz000tjotpa3fverm9","tag_id":"ckkq5o6xn004ijotpcq77esoi","_id":"ckkq5o6xt004zjotp72cb0wsd"},{"post_id":"ckkq5o6w2000xjotpgcirgk67","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o6xu0052jotp2yeb09qb"},{"post_id":"ckkq5o6w40011jotpbxa9efsv","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o6xz005djotp0jhigxxp"},{"post_id":"ckkq5o6w40011jotpbxa9efsv","tag_id":"ckkq5o6xv0055jotphoz2fpnu","_id":"ckkq5o6y0005gjotp9oxv98dl"},{"post_id":"ckkq5o6w60014jotpa40h6quc","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o6y5005pjotpa6ce5xtu"},{"post_id":"ckkq5o6w60014jotpa40h6quc","tag_id":"ckkq5o6y0005hjotpej8weex1","_id":"ckkq5o6y6005sjotp9dal4mp2"},{"post_id":"ckkq5o6w80016jotpbmey3xaw","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o6ya0061jotp768732vh"},{"post_id":"ckkq5o6w80016jotpbmey3xaw","tag_id":"ckkq5o6y6005tjotp4oh26qq3","_id":"ckkq5o6ya0064jotp0kesdz97"},{"post_id":"ckkq5o6w90019jotphjlw4f2b","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o6yb0068jotpgx1e310j"},{"post_id":"ckkq5o6wa001bjotpgva3c3vx","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6yi006qjotp3pdo83si"},{"post_id":"ckkq5o6wa001bjotpgva3c3vx","tag_id":"ckkq5o6yd006djotpdsg24r5t","_id":"ckkq5o6yj006tjotphuh4g0ii"},{"post_id":"ckkq5o6wa001bjotpgva3c3vx","tag_id":"ckkq5o6yg006ijotpek2t7fvj","_id":"ckkq5o6yk006xjotp3okc7lb9"},{"post_id":"ckkq5o6wb001djotp782v0pu9","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6yq0078jotpfi847dmh"},{"post_id":"ckkq5o6wb001djotp782v0pu9","tag_id":"ckkq5o6yj006ujotp41zf8vyo","_id":"ckkq5o6yq007bjotpcsgbfuki"},{"post_id":"ckkq5o6wb001djotp782v0pu9","tag_id":"ckkq5o6yg006ijotpek2t7fvj","_id":"ckkq5o6yr007fjotp1iq617eq"},{"post_id":"ckkq5o6wc001ijotpdjsugbnk","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6yv007qjotpe4fx0m5c"},{"post_id":"ckkq5o6wc001ijotpdjsugbnk","tag_id":"ckkq5o6yq007cjotpcmfk263y","_id":"ckkq5o6yw007tjotp7ly55juw"},{"post_id":"ckkq5o6wc001ijotpdjsugbnk","tag_id":"ckkq5o6yg006ijotpek2t7fvj","_id":"ckkq5o6yx007xjotpa4xa83tv"},{"post_id":"ckkq5o6wd001ljotpfu098kwl","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6z1008ajotp33mt4e0n"},{"post_id":"ckkq5o6wd001ljotpfu098kwl","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o6z2008djotp0pxl49ku"},{"post_id":"ckkq5o6wd001ljotpfu098kwl","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o6z3008ijotp3yr6b62p"},{"post_id":"ckkq5o6wg001pjotp6tv8auya","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6z6008vjotp1xbwb6pe"},{"post_id":"ckkq5o6wg001pjotp6tv8auya","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o6z7008yjotp42092054"},{"post_id":"ckkq5o6wg001pjotp6tv8auya","tag_id":"ckkq5o6z4008ljotp5fe8gt2e","_id":"ckkq5o6z80093jotpfw904au1"},{"post_id":"ckkq5o6wi001tjotp07fk5vl9","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6za009bjotp81wfb05e"},{"post_id":"ckkq5o6wi001tjotp07fk5vl9","tag_id":"ckkq5o6z7008zjotp81chc93b","_id":"ckkq5o6za009djotpdda9cl3p"},{"post_id":"ckkq5o6wi001tjotp07fk5vl9","tag_id":"ckkq5o6yg006ijotpek2t7fvj","_id":"ckkq5o6zb009gjotpgy8n7315"},{"post_id":"ckkq5o6wj001wjotp3o2n7vgi","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6zb009jjotpab1965zm"},{"post_id":"ckkq5o6wj001wjotp3o2n7vgi","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o6zb009kjotp90owh8vs"},{"post_id":"ckkq5o6wj001wjotp3o2n7vgi","tag_id":"ckkq5o6zb009hjotpdox3gb18","_id":"ckkq5o6zc009mjotp21oiaa6h"},{"post_id":"ckkq5o6wl001zjotp3bdzdbjb","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6zd009pjotpcc9t4ccz"},{"post_id":"ckkq5o6wl001zjotp3bdzdbjb","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o6zd009qjotp4anh71s6"},{"post_id":"ckkq5o6wl001zjotp3bdzdbjb","tag_id":"ckkq5o6zc009njotp0hhyeq3w","_id":"ckkq5o6zd009sjotp20bc5wwt"},{"post_id":"ckkq5o6wn0022jotp0rdh32je","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6zh009wjotphh1b05x0"},{"post_id":"ckkq5o6wn0022jotp0rdh32je","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o6zh009xjotpfn9ja2pg"},{"post_id":"ckkq5o6wn0022jotp0rdh32je","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o6zh009zjotpgggkh7ta"},{"post_id":"ckkq5o6wn0022jotp0rdh32je","tag_id":"ckkq5o6ze009ujotp4w9i3lmm","_id":"ckkq5o6zh00a0jotpat0scla3"},{"post_id":"ckkq5o6wo0025jotp9ze701zz","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6zi00a3jotpbix315qb"},{"post_id":"ckkq5o6wo0025jotp9ze701zz","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o6zi00a4jotp13ut40lp"},{"post_id":"ckkq5o6wo0025jotp9ze701zz","tag_id":"ckkq5o6zh00a1jotp8wec3od2","_id":"ckkq5o6zi00a6jotpdlrtfwfo"},{"post_id":"ckkq5o6ws0029jotp9upycyf5","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6zi00a8jotpg7f7bz6z"},{"post_id":"ckkq5o6ws0029jotp9upycyf5","tag_id":"ckkq5o6yg006ijotpek2t7fvj","_id":"ckkq5o6zi00a9jotp6izf7wpc"},{"post_id":"ckkq5o6ws002cjotpf37sefzg","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zj00adjotp83n1gyf4"},{"post_id":"ckkq5o6ws002cjotpf37sefzg","tag_id":"ckkq5o6zj00aajotpfyeia22t","_id":"ckkq5o6zj00aejotp4jvn7ups"},{"post_id":"ckkq5o6ws002cjotpf37sefzg","tag_id":"ckkq5o6zj00abjotp1w8a7rb9","_id":"ckkq5o6zj00agjotp91k6bf5k"},{"post_id":"ckkq5o6wt002fjotpghcs4y0o","tag_id":"ckkq5o6ya0065jotp65rbgcms","_id":"ckkq5o6zk00aijotpco43bcs3"},{"post_id":"ckkq5o6wt002fjotpghcs4y0o","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o6zk00ajjotpeu7ogfut"},{"post_id":"ckkq5o6wu002jjotp9cg9fnun","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zk00amjotpcafr0o5u"},{"post_id":"ckkq5o6wu002jjotp9cg9fnun","tag_id":"ckkq5o6zk00akjotp0ra9bh2z","_id":"ckkq5o6zk00anjotp4fqj4vdf"},{"post_id":"ckkq5o6wv002njotp2eiphiu0","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zl00aqjotp3jdzdai6"},{"post_id":"ckkq5o6wv002njotp2eiphiu0","tag_id":"ckkq5o6zk00aojotp8amzcj1r","_id":"ckkq5o6zl00arjotp431q57sw"},{"post_id":"ckkq5o6wy002qjotp7xhahzk9","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zl00aujotp2czr3a5b"},{"post_id":"ckkq5o6wy002qjotp7xhahzk9","tag_id":"ckkq5o6zl00asjotpa8j9gnqq","_id":"ckkq5o6zm00avjotp254d29fo"},{"post_id":"ckkq5o6x0002tjotp1wolglp8","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zm00ayjotp132p4x9n"},{"post_id":"ckkq5o6x0002tjotp1wolglp8","tag_id":"ckkq5o6zm00awjotp0wpe9xlp","_id":"ckkq5o6zm00azjotp0if2dijj"},{"post_id":"ckkq5o6x2002xjotpg0i9c1c7","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zn00b2jotp2j4t39ej"},{"post_id":"ckkq5o6x2002xjotpg0i9c1c7","tag_id":"ckkq5o6zm00b0jotpaqyl9n9b","_id":"ckkq5o6zn00b3jotpho3kdkx9"},{"post_id":"ckkq5o6x30030jotphi8yh7ug","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zn00b6jotp6pbrc8kk"},{"post_id":"ckkq5o6x30030jotphi8yh7ug","tag_id":"ckkq5o6zn00b4jotp9655hap4","_id":"ckkq5o6zn00b7jotpd6fs0j5m"},{"post_id":"ckkq5o6x50034jotpazyg1vox","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zo00bajotpfadb10aa"},{"post_id":"ckkq5o6x50034jotpazyg1vox","tag_id":"ckkq5o6zn00b8jotp8dj96sjd","_id":"ckkq5o6zo00bbjotp24jmguxd"},{"post_id":"ckkq5o6x60037jotp2u6g74e5","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zq00bejotp9q5aaibn"},{"post_id":"ckkq5o6x60037jotp2u6g74e5","tag_id":"ckkq5o6zo00bcjotp1h3rcry9","_id":"ckkq5o6zq00bfjotp1n071msg"},{"post_id":"ckkq5o6x7003bjotpaj9d9en8","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zr00bijotpbvb95hqt"},{"post_id":"ckkq5o6x7003bjotpaj9d9en8","tag_id":"ckkq5o6zl00asjotpa8j9gnqq","_id":"ckkq5o6zs00bjjotpco4vfsv1"},{"post_id":"ckkq5o6x8003ejotp5uoufkih","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zt00bnjotphqc3aknt"},{"post_id":"ckkq5o6x8003ejotp5uoufkih","tag_id":"ckkq5o6zs00bkjotpfyfqhwe6","_id":"ckkq5o6zt00bojotp7g4tczg1"},{"post_id":"ckkq5o6x8003ejotp5uoufkih","tag_id":"ckkq5o6zl00asjotpa8j9gnqq","_id":"ckkq5o6zu00bqjotp3jwfa486"},{"post_id":"ckkq5o6x9003ijotp1jxt72px","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zu00brjotp3204fuv9"},{"post_id":"ckkq5o6x9003ljotpfzpa5pb2","tag_id":"ckkq5o6zi00a7jotp512m8qea","_id":"ckkq5o6zw00bujotpfehv9bnj"},{"post_id":"ckkq5o6x9003ljotpfzpa5pb2","tag_id":"ckkq5o6zu00bsjotpf6gq3jlm","_id":"ckkq5o6zw00bvjotp3o0t1x3d"},{"post_id":"ckkq5o6xa003ojotp9c952tv2","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o6zy00bzjotpaetf4dae"},{"post_id":"ckkq5o6xa003ojotp9c952tv2","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o6zy00c0jotp7zro982k"},{"post_id":"ckkq5o6xa003ojotp9c952tv2","tag_id":"ckkq5o6zx00bxjotp2f9d8a37","_id":"ckkq5o6zz00c2jotpa7fc7ucn"},{"post_id":"ckkq5o6xb003sjotpg8k08de4","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70100c5jotpe8v52mv6"},{"post_id":"ckkq5o6xb003sjotpg8k08de4","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o70100c6jotp7tq30b8y"},{"post_id":"ckkq5o6xb003sjotpg8k08de4","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o70200c8jotp7asagxm6"},{"post_id":"ckkq5o6xc003wjotpbaele78m","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70300cbjotpebea6fze"},{"post_id":"ckkq5o6xc003wjotpbaele78m","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o70300ccjotp90zg6qfn"},{"post_id":"ckkq5o6xc003wjotpbaele78m","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o70400cejotpa3v441uf"},{"post_id":"ckkq5o6xd003zjotp8easeo1r","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70400chjotp1o4jfdrp"},{"post_id":"ckkq5o6xd003zjotp8easeo1r","tag_id":"ckkq5o70300cdjotp3kfga96k","_id":"ckkq5o70400cijotp1im9c8ri"},{"post_id":"ckkq5o6xd003zjotp8easeo1r","tag_id":"ckkq5o70400cfjotp1uuu8ell","_id":"ckkq5o70400ckjotp622z87h8"},{"post_id":"ckkq5o6xe0041jotp41uqgiz1","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70600cnjotp1ta038ud"},{"post_id":"ckkq5o6xe0041jotp41uqgiz1","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o70600cojotp9c34h4pr"},{"post_id":"ckkq5o6xe0041jotp41uqgiz1","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o70800cqjotp6ozz51px"},{"post_id":"ckkq5o6xg0045jotpgy23fqfp","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70900ctjotpehlb32dj"},{"post_id":"ckkq5o6xg0045jotpgy23fqfp","tag_id":"ckkq5o70300cdjotp3kfga96k","_id":"ckkq5o70900cujotpal84c8hq"},{"post_id":"ckkq5o6xg0045jotpgy23fqfp","tag_id":"ckkq5o70800crjotp1rvfdhxg","_id":"ckkq5o70900cwjotpa204c7my"},{"post_id":"ckkq5o6xg0048jotpcr9n3pgu","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70a00czjotp87mv52oa"},{"post_id":"ckkq5o6xg0048jotpcr9n3pgu","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o70b00d0jotpfwfo1jyg"},{"post_id":"ckkq5o6xg0048jotpcr9n3pgu","tag_id":"ckkq5o70900cxjotp2mpz519b","_id":"ckkq5o70b00d2jotpabwwbf64"},{"post_id":"ckkq5o6xl004djotpeedy3xjk","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70c00d5jotpa8sl0rn6"},{"post_id":"ckkq5o6xl004djotpeedy3xjk","tag_id":"ckkq5o70300cdjotp3kfga96k","_id":"ckkq5o70c00d6jotp5ot25ai6"},{"post_id":"ckkq5o6xl004djotpeedy3xjk","tag_id":"ckkq5o70400cfjotp1uuu8ell","_id":"ckkq5o70d00d8jotpdxee28pj"},{"post_id":"ckkq5o6xm004gjotp4vlc0c13","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70e00dbjotp5yxubixl"},{"post_id":"ckkq5o6xm004gjotp4vlc0c13","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o70e00dcjotp82j30dvl"},{"post_id":"ckkq5o6xm004gjotp4vlc0c13","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o70e00dejotpf3srdf9y"},{"post_id":"ckkq5o6xn004jjotpg48j2x1s","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70f00dhjotpd6ptb4at"},{"post_id":"ckkq5o6xn004jjotpg48j2x1s","tag_id":"ckkq5o70300cdjotp3kfga96k","_id":"ckkq5o70f00dijotp3mou08y2"},{"post_id":"ckkq5o6xn004jjotpg48j2x1s","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o70g00dkjotp8ixg2jzu"},{"post_id":"ckkq5o6xo004mjotpas42hlq7","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70g00dnjotpfnmxh9b4"},{"post_id":"ckkq5o6xo004mjotpas42hlq7","tag_id":"ckkq5o70300cdjotp3kfga96k","_id":"ckkq5o70g00dojotpe6h09ezx"},{"post_id":"ckkq5o6xo004mjotpas42hlq7","tag_id":"ckkq5o70g00dljotpclkz748k","_id":"ckkq5o70g00dqjotpb1cy5ftx"},{"post_id":"ckkq5o6xo004pjotp7edygz15","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70h00dtjotp7oqa2l7x"},{"post_id":"ckkq5o6xo004pjotp7edygz15","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o70h00dujotp0r88g6hz"},{"post_id":"ckkq5o6xo004pjotp7edygz15","tag_id":"ckkq5o70h00drjotpajg60am9","_id":"ckkq5o70h00dwjotp3nas39aq"},{"post_id":"ckkq5o6xq004tjotp6qwghwnk","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70i00dzjotpf36t107b"},{"post_id":"ckkq5o6xq004tjotp6qwghwnk","tag_id":"ckkq5o70900cxjotp2mpz519b","_id":"ckkq5o70i00e0jotpd6ok392r"},{"post_id":"ckkq5o6xq004tjotp6qwghwnk","tag_id":"ckkq5o70h00dxjotpduhfcvi6","_id":"ckkq5o70i00e2jotp88rzekwk"},{"post_id":"ckkq5o6xr004wjotp6rc60cuy","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70j00e5jotp9m2413ue"},{"post_id":"ckkq5o6xr004wjotp6rc60cuy","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o70j00e6jotpbef70rk1"},{"post_id":"ckkq5o6xr004wjotp6rc60cuy","tag_id":"ckkq5o70h00dxjotpduhfcvi6","_id":"ckkq5o70j00e8jotpazrzfqf8"},{"post_id":"ckkq5o6xt0050jotp1q5i10um","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70k00ebjotp2cl9cdkw"},{"post_id":"ckkq5o6xt0050jotp1q5i10um","tag_id":"ckkq5o70900cxjotp2mpz519b","_id":"ckkq5o70k00ecjotp33w8hbgh"},{"post_id":"ckkq5o6xt0050jotp1q5i10um","tag_id":"ckkq5o70j00e9jotp5th0fnfa","_id":"ckkq5o70k00eejotp490p1v8w"},{"post_id":"ckkq5o6xu0053jotpfaib5lvq","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70l00ehjotp0q2360ot"},{"post_id":"ckkq5o6xu0053jotpfaib5lvq","tag_id":"ckkq5o70k00edjotp1hvm0p7y","_id":"ckkq5o70l00eijotph3v36p1x"},{"post_id":"ckkq5o6xu0053jotpfaib5lvq","tag_id":"ckkq5o70k00efjotp6je07ti8","_id":"ckkq5o70l00ekjotp5ey42s9j"},{"post_id":"ckkq5o6xv0056jotp6o8f92l0","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70m00enjotpfiexc0km"},{"post_id":"ckkq5o6xv0056jotp6o8f92l0","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o70m00eojotpf5bd06gw"},{"post_id":"ckkq5o6xv0056jotp6o8f92l0","tag_id":"ckkq5o70l00eljotp0oblft6v","_id":"ckkq5o70m00eqjotp5lpl7nk1"},{"post_id":"ckkq5o6xw0058jotp9e065d7j","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70m00etjotp8fbug0sd"},{"post_id":"ckkq5o6xw0058jotp9e065d7j","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o70n00eujotphmfjdrtg"},{"post_id":"ckkq5o6xw0058jotp9e065d7j","tag_id":"ckkq5o70m00erjotp78o8alr3","_id":"ckkq5o70n00ewjotp9xq25p2v"},{"post_id":"ckkq5o6xy005bjotpg30z87qs","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70o00ezjotpeog47om2"},{"post_id":"ckkq5o6xy005bjotpg30z87qs","tag_id":"ckkq5o70900cxjotp2mpz519b","_id":"ckkq5o70o00f0jotpc0ipfe2s"},{"post_id":"ckkq5o6xy005bjotpg30z87qs","tag_id":"ckkq5o70h00dxjotpduhfcvi6","_id":"ckkq5o70o00f2jotp964n1j7y"},{"post_id":"ckkq5o6y0005ejotp8ev7cxzl","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70p00f5jotp8pribcd1"},{"post_id":"ckkq5o6y0005ejotp8ev7cxzl","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o70p00f6jotpaqnc8ypj"},{"post_id":"ckkq5o6y0005ejotp8ev7cxzl","tag_id":"ckkq5o70m00erjotp78o8alr3","_id":"ckkq5o70p00f8jotp8hrah10f"},{"post_id":"ckkq5o6y2005ijotpg6rw4fof","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70r00fbjotpdzqggp4a"},{"post_id":"ckkq5o6y2005ijotpg6rw4fof","tag_id":"ckkq5o70p00f7jotpgunbf4oa","_id":"ckkq5o70r00fcjotpct9af3sj"},{"post_id":"ckkq5o6y2005ijotpg6rw4fof","tag_id":"ckkq5o70h00drjotpajg60am9","_id":"ckkq5o70s00fejotpfvkqgemq"},{"post_id":"ckkq5o6y3005kjotpe3nza4vb","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70u00fhjotp2iqvhhq3"},{"post_id":"ckkq5o6y3005kjotpe3nza4vb","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o70u00fijotp0mw10xtk"},{"post_id":"ckkq5o6y3005kjotpe3nza4vb","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o70u00fkjotp53vhbyjd"},{"post_id":"ckkq5o6y4005njotp6bu71iew","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70v00fnjotp6ym712ix"},{"post_id":"ckkq5o6y4005njotp6bu71iew","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o70v00fojotpabtj6mbg"},{"post_id":"ckkq5o6y4005njotp6bu71iew","tag_id":"ckkq5o70h00drjotpajg60am9","_id":"ckkq5o70v00fqjotp7srj272m"},{"post_id":"ckkq5o6y5005qjotp7vxy8ans","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70w00ftjotpf0tyblw2"},{"post_id":"ckkq5o6y5005qjotp7vxy8ans","tag_id":"ckkq5o70v00fpjotp1ris1iro","_id":"ckkq5o70w00fujotp79yzdccp"},{"post_id":"ckkq5o6y5005qjotp7vxy8ans","tag_id":"ckkq5o70w00frjotp51m59is7","_id":"ckkq5o70x00fwjotpb0m24epw"},{"post_id":"ckkq5o6y7005ujotp0fxh78p3","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70x00fzjotp1tz827iq"},{"post_id":"ckkq5o6y7005ujotp0fxh78p3","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o70x00g0jotpf3r7chz1"},{"post_id":"ckkq5o6y7005ujotp0fxh78p3","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o70y00g2jotp9tdy0p6g"},{"post_id":"ckkq5o6y8005wjotph2i750lt","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o70z00g5jotpa3e0agtq"},{"post_id":"ckkq5o6y8005wjotph2i750lt","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o70z00g6jotphm9rb87l"},{"post_id":"ckkq5o6y8005wjotph2i750lt","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o71000g8jotpekfq2dab"},{"post_id":"ckkq5o6y9005zjotpf1e52ngn","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71100gbjotpbg2xhhh4"},{"post_id":"ckkq5o6y9005zjotpf1e52ngn","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71100gcjotp3o24a2ce"},{"post_id":"ckkq5o6y9005zjotpf1e52ngn","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o71100gejotpb76qekmg"},{"post_id":"ckkq5o6ya0062jotp4m2u7ezk","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71200ghjotp5qqaccu0"},{"post_id":"ckkq5o6ya0062jotp4m2u7ezk","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o71200gijotp9q40b4hz"},{"post_id":"ckkq5o6ya0062jotp4m2u7ezk","tag_id":"ckkq5o71100gfjotp1bgb9xwj","_id":"ckkq5o71200gkjotp9ose4rhb"},{"post_id":"ckkq5o6yb0066jotphl2u0mqf","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71300gnjotp45iihtrr"},{"post_id":"ckkq5o6yb0066jotphl2u0mqf","tag_id":"ckkq5o70h00dxjotpduhfcvi6","_id":"ckkq5o71300gojotphhoqd9mx"},{"post_id":"ckkq5o6yb0066jotphl2u0mqf","tag_id":"ckkq5o71200gljotpb2ktdh0w","_id":"ckkq5o71400gqjotphflohzhv"},{"post_id":"ckkq5o6yc0069jotp71wtgoad","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71400gtjotp7kxxbksl"},{"post_id":"ckkq5o6yc0069jotp71wtgoad","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71500gujotpfen9gs9j"},{"post_id":"ckkq5o6yc0069jotp71wtgoad","tag_id":"ckkq5o70400cfjotp1uuu8ell","_id":"ckkq5o71500gwjotp1m5h7zjs"},{"post_id":"ckkq5o6yc006bjotphqccgb9g","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71600gzjotp4wftbxzd"},{"post_id":"ckkq5o6yc006bjotphqccgb9g","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71600h0jotpew7p2h1y"},{"post_id":"ckkq5o6yc006bjotphqccgb9g","tag_id":"ckkq5o71500gxjotpb1ew1jdl","_id":"ckkq5o71600h2jotpf92n8emo"},{"post_id":"ckkq5o6ye006ejotpb03da097","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71800h5jotpflaj8xvz"},{"post_id":"ckkq5o6ye006ejotpb03da097","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71800h6jotpfth1amy8"},{"post_id":"ckkq5o6ye006ejotpb03da097","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o71800h8jotp9hq6hmqt"},{"post_id":"ckkq5o6yf006gjotp9ccs4ba2","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71900hbjotpdawt5ltp"},{"post_id":"ckkq5o6yf006gjotp9ccs4ba2","tag_id":"ckkq5o71800h7jotp6zu85omx","_id":"ckkq5o71900hcjotp4mrk5sik"},{"post_id":"ckkq5o6yf006gjotp9ccs4ba2","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o71900hejotpbjheca8i"},{"post_id":"ckkq5o6yg006jjotpaz800uja","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71a00hhjotphbxv4vnl"},{"post_id":"ckkq5o6yg006jjotpaz800uja","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71a00hijotpc50fhcz1"},{"post_id":"ckkq5o6yg006jjotpaz800uja","tag_id":"ckkq5o71900hfjotp61prcgnr","_id":"ckkq5o71a00hkjotp5463ekg9"},{"post_id":"ckkq5o6yh006ljotp8yoj5o8p","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71b00hnjotpdtzf5m4u"},{"post_id":"ckkq5o6yh006ljotp8yoj5o8p","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71b00hojotpbxl5dyzo"},{"post_id":"ckkq5o6yh006ljotp8yoj5o8p","tag_id":"ckkq5o71a00hljotpdk2n5zv5","_id":"ckkq5o71c00hqjotp05ww5yqv"},{"post_id":"ckkq5o6yi006ojotphvwlcj7o","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71d00htjotpbb2k9afl"},{"post_id":"ckkq5o6yi006ojotphvwlcj7o","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71d00hujotp6r5l8fby"},{"post_id":"ckkq5o6yi006ojotphvwlcj7o","tag_id":"ckkq5o71900hfjotp61prcgnr","_id":"ckkq5o71d00hwjotp431vg6u7"},{"post_id":"ckkq5o6yi006rjotp0qz60x2w","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71e00hzjotp848t7l50"},{"post_id":"ckkq5o6yi006rjotp0qz60x2w","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71e00i0jotpcasah4rt"},{"post_id":"ckkq5o6yi006rjotp0qz60x2w","tag_id":"ckkq5o70900cxjotp2mpz519b","_id":"ckkq5o71e00i2jotph0kubfqn"},{"post_id":"ckkq5o6yk006vjotpdi4bhgf3","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71f00i5jotpa7cj0cak"},{"post_id":"ckkq5o6yk006vjotpdi4bhgf3","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71f00i6jotpc4436bdk"},{"post_id":"ckkq5o6yk006vjotpdi4bhgf3","tag_id":"ckkq5o71500gxjotpb1ew1jdl","_id":"ckkq5o71f00i8jotpgxjaazgg"},{"post_id":"ckkq5o6yk006yjotpd67uchk1","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71g00ibjotpf1rz0qpi"},{"post_id":"ckkq5o6yk006yjotpd67uchk1","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71g00icjotp0io63k1t"},{"post_id":"ckkq5o6yk006yjotpd67uchk1","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o71g00iejotp1vc48def"},{"post_id":"ckkq5o6yn0071jotp246cf92o","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71h00ihjotp83zn8hgd"},{"post_id":"ckkq5o6yn0071jotp246cf92o","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71h00iijotp0b860quh"},{"post_id":"ckkq5o6yn0071jotp246cf92o","tag_id":"ckkq5o70900cxjotp2mpz519b","_id":"ckkq5o71h00ikjotp1mmh3qsy"},{"post_id":"ckkq5o6yo0073jotpbskj35ch","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71i00injotpdhxwa4ea"},{"post_id":"ckkq5o6yo0073jotpbskj35ch","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71i00iojotp77tgbwse"},{"post_id":"ckkq5o6yo0073jotpbskj35ch","tag_id":"ckkq5o70900cxjotp2mpz519b","_id":"ckkq5o71i00iqjotp11y95c4i"},{"post_id":"ckkq5o6yp0076jotpfrxze2h0","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71j00itjotp23w1f7q4"},{"post_id":"ckkq5o6yp0076jotpfrxze2h0","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71j00iujotpcq233vjf"},{"post_id":"ckkq5o6yp0076jotpfrxze2h0","tag_id":"ckkq5o71i00irjotpdwcm2ra7","_id":"ckkq5o71j00iwjotpemng88lf"},{"post_id":"ckkq5o6yq0079jotp73339dhd","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71k00izjotp8i34cmdm"},{"post_id":"ckkq5o6yq0079jotp73339dhd","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71k00j0jotpdg59231h"},{"post_id":"ckkq5o6yq0079jotp73339dhd","tag_id":"ckkq5o70900cxjotp2mpz519b","_id":"ckkq5o71k00j2jotp5b6g88wt"},{"post_id":"ckkq5o6yr007djotp1b0oegf9","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71l00j5jotp7ai30gf7"},{"post_id":"ckkq5o6yr007djotp1b0oegf9","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71l00j6jotpahp26cwi"},{"post_id":"ckkq5o6yr007djotp1b0oegf9","tag_id":"ckkq5o70h00dxjotpduhfcvi6","_id":"ckkq5o71m00j8jotpbetk76rs"},{"post_id":"ckkq5o6yr007gjotpabk7gziq","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71n00jbjotp3u6yfff0"},{"post_id":"ckkq5o6yr007gjotpabk7gziq","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71n00jcjotp3ozuakft"},{"post_id":"ckkq5o6yr007gjotpabk7gziq","tag_id":"ckkq5o70h00dxjotpduhfcvi6","_id":"ckkq5o71n00jejotphul95ep8"},{"post_id":"ckkq5o6ys007ijotp1pzyafde","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71p00jhjotp1vh35xg4"},{"post_id":"ckkq5o6ys007ijotp1pzyafde","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71p00jijotpgfebalz0"},{"post_id":"ckkq5o6ys007ijotp1pzyafde","tag_id":"ckkq5o70h00dxjotpduhfcvi6","_id":"ckkq5o71p00jkjotp86zf7h7l"},{"post_id":"ckkq5o6yt007ljotpghfc2drm","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71q00jnjotpg73l4ret"},{"post_id":"ckkq5o6yt007ljotpghfc2drm","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o71q00jojotp84pvhf6w"},{"post_id":"ckkq5o6yt007ljotpghfc2drm","tag_id":"ckkq5o70h00dxjotpduhfcvi6","_id":"ckkq5o71r00jqjotp5mqnh6ml"},{"post_id":"ckkq5o6yu007njotpbxls86fn","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71r00jtjotpadz93w8h"},{"post_id":"ckkq5o6yu007njotpbxls86fn","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71s00jujotph907dm6x"},{"post_id":"ckkq5o6yu007njotpbxls86fn","tag_id":"ckkq5o71r00jrjotpb0xd3dki","_id":"ckkq5o71t00jwjotp6ecb8gz5"},{"post_id":"ckkq5o6yv007rjotpfz7mdt0m","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71u00jzjotp70wv5ckn"},{"post_id":"ckkq5o6yv007rjotpfz7mdt0m","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o71u00k0jotp3vf5brmg"},{"post_id":"ckkq5o6yv007rjotpfz7mdt0m","tag_id":"ckkq5o71t00jxjotpe9ptdy6i","_id":"ckkq5o71v00k2jotpefprdkbt"},{"post_id":"ckkq5o6yw007ujotp9c317jtv","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71w00k5jotp4q45b2cu"},{"post_id":"ckkq5o6yw007ujotp9c317jtv","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71w00k6jotp6djg8933"},{"post_id":"ckkq5o6yw007ujotp9c317jtv","tag_id":"ckkq5o71v00k3jotpgcokg0jc","_id":"ckkq5o71x00k8jotpbvhearbj"},{"post_id":"ckkq5o6yx007yjotp1c0313d9","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o71y00kbjotphjcxhlo1"},{"post_id":"ckkq5o6yx007yjotp1c0313d9","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o71y00kcjotp1qk5bec5"},{"post_id":"ckkq5o6yx007yjotp1c0313d9","tag_id":"ckkq5o71x00k9jotpar9d93o8","_id":"ckkq5o71z00kejotpeeta9is0"},{"post_id":"ckkq5o6yy0080jotpgrtbefou","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o72000khjotp12flgyvp"},{"post_id":"ckkq5o6yy0080jotpgrtbefou","tag_id":"ckkq5o70p00f7jotpgunbf4oa","_id":"ckkq5o72000kijotpg6klekmf"},{"post_id":"ckkq5o6yy0080jotpgrtbefou","tag_id":"ckkq5o70900cxjotp2mpz519b","_id":"ckkq5o72000kkjotpd5azfn0j"},{"post_id":"ckkq5o6yz0083jotpaczbca4l","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o72200knjotpgwhs172a"},{"post_id":"ckkq5o6yz0083jotpaczbca4l","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o72200kojotp3jadcfl5"},{"post_id":"ckkq5o6yz0083jotpaczbca4l","tag_id":"ckkq5o70300cdjotp3kfga96k","_id":"ckkq5o72300kqjotp0ar5a2jz"},{"post_id":"ckkq5o6z00085jotphqgr3dgx","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o72400ktjotpeklqhhxw"},{"post_id":"ckkq5o6z00085jotphqgr3dgx","tag_id":"ckkq5o70300cdjotp3kfga96k","_id":"ckkq5o72400kujotp4pvs9mi3"},{"post_id":"ckkq5o6z00085jotphqgr3dgx","tag_id":"ckkq5o70400cfjotp1uuu8ell","_id":"ckkq5o72400kwjotp6czdc6hz"},{"post_id":"ckkq5o6z10088jotpd8ce9l9y","tag_id":"ckkq5o72300ksjotpei6ufy33","_id":"ckkq5o72600kzjotp901qdh71"},{"post_id":"ckkq5o6z10088jotpd8ce9l9y","tag_id":"ckkq5o72400kvjotp0tmi1lnm","_id":"ckkq5o72600l0jotp606qdrhe"},{"post_id":"ckkq5o6z10088jotpd8ce9l9y","tag_id":"ckkq5o72500kxjotpgvac9ysg","_id":"ckkq5o72700l2jotp2e9hhpgi"},{"post_id":"ckkq5o6z2008bjotpcflc22hc","tag_id":"ckkq5o72500kyjotp7e3hc1zp","_id":"ckkq5o72700l5jotp8u9ccbsg"},{"post_id":"ckkq5o6z2008bjotpcflc22hc","tag_id":"ckkq5o72600l1jotpeuvf862t","_id":"ckkq5o72700l6jotphxux2v24"},{"post_id":"ckkq5o6z2008bjotpcflc22hc","tag_id":"ckkq5o72700l3jotpdjfybadt","_id":"ckkq5o72800l8jotp22nt3h49"},{"post_id":"ckkq5o6z3008gjotp506q7jfs","tag_id":"ckkq5o6zv00btjotparco8ov4","_id":"ckkq5o72900lbjotp9d1e42ea"},{"post_id":"ckkq5o6z3008gjotp506q7jfs","tag_id":"ckkq5o70300cdjotp3kfga96k","_id":"ckkq5o72900lcjotp1al58nfs"},{"post_id":"ckkq5o6z3008gjotp506q7jfs","tag_id":"ckkq5o70h00dxjotpduhfcvi6","_id":"ckkq5o72900lejotp8is922ve"},{"post_id":"ckkq5o6z3008jjotpacx2915c","tag_id":"ckkq5o72800lajotp3tnign9c","_id":"ckkq5o72a00lhjotpcca2anli"},{"post_id":"ckkq5o6z3008jjotpacx2915c","tag_id":"ckkq5o72900ldjotp67du1mut","_id":"ckkq5o72a00lijotphxxv7tkz"},{"post_id":"ckkq5o6z3008jjotpacx2915c","tag_id":"ckkq5o72900lfjotp4s0v2oav","_id":"ckkq5o72a00lkjotpcmqehjqh"},{"post_id":"ckkq5o6z4008mjotp95uvfxkh","tag_id":"ckkq5o72a00lgjotp7u6udmir","_id":"ckkq5o72b00lnjotpacrh4471"},{"post_id":"ckkq5o6z4008mjotp95uvfxkh","tag_id":"ckkq5o72a00ljjotp3c9l5u5v","_id":"ckkq5o72b00lojotp13olfkrl"},{"post_id":"ckkq5o6z4008mjotp95uvfxkh","tag_id":"ckkq5o72b00lljotp51jxh9ov","_id":"ckkq5o72c00lqjotp3i7i4rri"},{"post_id":"ckkq5o6z5008pjotp21f97lgj","tag_id":"ckkq5o72a00lgjotp7u6udmir","_id":"ckkq5o72c00ltjotp6zns8zdq"},{"post_id":"ckkq5o6z5008pjotp21f97lgj","tag_id":"ckkq5o72a00ljjotp3c9l5u5v","_id":"ckkq5o72c00lujotpfeav821o"},{"post_id":"ckkq5o6z5008pjotp21f97lgj","tag_id":"ckkq5o72c00lrjotpbogyb4rv","_id":"ckkq5o72d00lwjotp6wmq79q0"},{"post_id":"ckkq5o6z5008sjotp6a2n4vub","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o72d00lzjotp4ntmdeir"},{"post_id":"ckkq5o6z5008sjotp6a2n4vub","tag_id":"ckkq5o72c00lvjotp9s883rnl","_id":"ckkq5o72d00m0jotpgo89fvm3"},{"post_id":"ckkq5o6z5008sjotp6a2n4vub","tag_id":"ckkq5o72d00lxjotpe9br9ln8","_id":"ckkq5o72e00m2jotp4zal7djf"},{"post_id":"ckkq5o6z6008wjotp0049hc9u","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o72e00m5jotpg1cbguke"},{"post_id":"ckkq5o6z6008wjotp0049hc9u","tag_id":"ckkq5o72c00lvjotp9s883rnl","_id":"ckkq5o72e00m6jotp2s2z2rml"},{"post_id":"ckkq5o6z6008wjotp0049hc9u","tag_id":"ckkq5o72e00m3jotp3osmao6j","_id":"ckkq5o72f00m8jotp96t54ds2"},{"post_id":"ckkq5o6z70090jotpb7ee81fh","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o72f00majotp1nw3006v"},{"post_id":"ckkq5o6z70090jotpb7ee81fh","tag_id":"ckkq5o72c00lvjotp9s883rnl","_id":"ckkq5o72f00mbjotp46paeq5z"},{"post_id":"ckkq5o6z70090jotpb7ee81fh","tag_id":"ckkq5o72f00m9jotpgbo00mqx","_id":"ckkq5o72f00mcjotp6rkxcfte"},{"post_id":"ckkq5o72y00mdjotpdxcggkhv","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o73700mmjotpa1wsb9bf"},{"post_id":"ckkq5o72y00mdjotpdxcggkhv","tag_id":"ckkq5o73000mgjotpae3pcx89","_id":"ckkq5o73800mojotp16lhe7jz"},{"post_id":"ckkq5o72z00mejotpbqpe7ocu","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o73b00n0jotp0d2o8nsm"},{"post_id":"ckkq5o72z00mejotpbqpe7ocu","tag_id":"ckkq5o73600mljotp57iqc4gb","_id":"ckkq5o73c00n3jotpa9mp0rth"},{"post_id":"ckkq5o72z00mejotpbqpe7ocu","tag_id":"ckkq5o73900msjotpcjjw4x11","_id":"ckkq5o73d00n7jotpgkv06715"},{"post_id":"ckkq5o73100mhjotpg2yg08in","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o73f00nejotpgqxe2zb0"},{"post_id":"ckkq5o73100mhjotpg2yg08in","tag_id":"ckkq5o73b00mxjotp3txz2ta4","_id":"ckkq5o73g00nhjotp9xgidvx9"},{"post_id":"ckkq5o73100mhjotpg2yg08in","tag_id":"ckkq5o73c00n4jotp8i930mdt","_id":"ckkq5o73h00nljotp9b9n8pcx"},{"post_id":"ckkq5o73400mijotpcz6p19si","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o73n00nvjotpcwmvf0wg"},{"post_id":"ckkq5o73400mijotpcz6p19si","tag_id":"ckkq5o73e00ncjotp81x114jw","_id":"ckkq5o73o00nyjotpczb80rgw"},{"post_id":"ckkq5o73400mijotpcz6p19si","tag_id":"ckkq5o73h00nkjotpamezbv74","_id":"ckkq5o73p00o2jotp6dhkgxe4"},{"post_id":"ckkq5o73500mjjotp7a3r6hl2","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o73q00o8jotpd8wrgara"},{"post_id":"ckkq5o73500mjjotp7a3r6hl2","tag_id":"ckkq5o73b00mxjotp3txz2ta4","_id":"ckkq5o73r00objotp3xz06w7l"},{"post_id":"ckkq5o73500mjjotp7a3r6hl2","tag_id":"ckkq5o73o00nzjotp83snhno9","_id":"ckkq5o73s00ofjotpdk8tho5w"},{"post_id":"ckkq5o73r00ocjotp4ui20yv5","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o73t00oijotpbwdqat6a"},{"post_id":"ckkq5o73r00ocjotp4ui20yv5","tag_id":"ckkq5o70l00eljotp0oblft6v","_id":"ckkq5o73w00omjotp8p07ej3f"},{"post_id":"ckkq5o73r00ocjotp4ui20yv5","tag_id":"ckkq5o70h00drjotpajg60am9","_id":"ckkq5o73x00opjotpbwsr58gd"},{"post_id":"ckkq5o73700mnjotp1h2u9dlh","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o73y00otjotp0oujhl48"},{"post_id":"ckkq5o73700mnjotp1h2u9dlh","tag_id":"ckkq5o73q00o5jotp2wtt5to9","_id":"ckkq5o73y00owjotp0ic6a6cd"},{"post_id":"ckkq5o73700mnjotp1h2u9dlh","tag_id":"ckkq5o73s00oejotp08l0bc29","_id":"ckkq5o74200ozjotpb4upa2v1"},{"post_id":"ckkq5o73800mpjotp3rjncnys","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o74300p2jotpgmgoap3v"},{"post_id":"ckkq5o73800mpjotp3rjncnys","tag_id":"ckkq5o73u00oljotp8yygcpg5","_id":"ckkq5o74300p4jotp9l6ncuwc"},{"post_id":"ckkq5o73900mtjotpdk7z0k5n","tag_id":"ckkq5o73x00osjotp9ybz2uzo","_id":"ckkq5o74400p7jotpafeyg6k4"},{"post_id":"ckkq5o73900mtjotpdk7z0k5n","tag_id":"ckkq5o74200p0jotpaco0hkoh","_id":"ckkq5o74400p9jotphvl516om"},{"post_id":"ckkq5o73900mtjotpdk7z0k5n","tag_id":"ckkq5o70k00edjotp1hvm0p7y","_id":"ckkq5o74400pcjotp1vxeb874"},{"post_id":"ckkq5o73a00mvjotpesyx1h1p","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o74400pejotphz9u18vr"},{"post_id":"ckkq5o73a00mvjotpesyx1h1p","tag_id":"ckkq5o6yz0082jotp3jwx85ss","_id":"ckkq5o74500pgjotpfdns88av"},{"post_id":"ckkq5o73a00mvjotpesyx1h1p","tag_id":"ckkq5o74300p6jotpdjpo93pe","_id":"ckkq5o74500phjotpfgmf6x97"},{"post_id":"ckkq5o73b00myjotp8fq25z6u","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o74500pjjotp5jwya7v7"},{"post_id":"ckkq5o73b00myjotp8fq25z6u","tag_id":"ckkq5o6y0005hjotpej8weex1","_id":"ckkq5o74500pkjotpcbu676ye"},{"post_id":"ckkq5o73b00myjotp8fq25z6u","tag_id":"ckkq5o74400pbjotp84yeb7zy","_id":"ckkq5o74500pljotp07ov9icg"},{"post_id":"ckkq5o73c00n1jotpb0hudkdj","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o74600pnjotp3y846ieh"},{"post_id":"ckkq5o73c00n1jotpb0hudkdj","tag_id":"ckkq5o74400pfjotp3axy136z","_id":"ckkq5o74600pojotpby2o5ik7"},{"post_id":"ckkq5o73c00n1jotpb0hudkdj","tag_id":"ckkq5o6x50032jotpavw5hkzw","_id":"ckkq5o74700pqjotpbnbvfl42"},{"post_id":"ckkq5o73c00n5jotpbx3r5flq","tag_id":"ckkq5o6x70039jotpbxkj4axv","_id":"ckkq5o74700prjotp7zdb5epg"},{"post_id":"ckkq5o73c00n5jotpbx3r5flq","tag_id":"ckkq5o74500pijotp5yyp7116","_id":"ckkq5o74700ptjotpdrjwb0yo"},{"post_id":"ckkq5o73c00n5jotpbx3r5flq","tag_id":"ckkq5o73c00n4jotp8i930mdt","_id":"ckkq5o74700pujotpbvzi54ql"},{"post_id":"ckkq5o73d00n8jotp1e0g1aju","tag_id":"ckkq5o74600ppjotp2w0y3xva","_id":"ckkq5o74800pwjotp594p3gd5"},{"post_id":"ckkq5o73d00n8jotp1e0g1aju","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o74800pxjotpb0hsa2lr"},{"post_id":"ckkq5o73d00n8jotp1e0g1aju","tag_id":"ckkq5o74700psjotp8y074s38","_id":"ckkq5o74900pzjotpdy0g8ck6"},{"post_id":"ckkq5o73e00najotp93wq69e1","tag_id":"ckkq5o74600ppjotp2w0y3xva","_id":"ckkq5o74a00q1jotpf7km1bo4"},{"post_id":"ckkq5o73e00najotp93wq69e1","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o74a00q2jotphb5ceib6"},{"post_id":"ckkq5o73e00najotp93wq69e1","tag_id":"ckkq5o74700psjotp8y074s38","_id":"ckkq5o74a00q4jotp8rz63u9k"},{"post_id":"ckkq5o73f00nfjotp460o4440","tag_id":"ckkq5o74600ppjotp2w0y3xva","_id":"ckkq5o74a00q6jotpenba7dif"},{"post_id":"ckkq5o73f00nfjotp460o4440","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o74a00q7jotpcjya9tab"},{"post_id":"ckkq5o73f00nfjotp460o4440","tag_id":"ckkq5o74700psjotp8y074s38","_id":"ckkq5o74b00q9jotpe4wlfba9"},{"post_id":"ckkq5o73g00nijotp6rk52xms","tag_id":"ckkq5o74600ppjotp2w0y3xva","_id":"ckkq5o74b00qbjotp01k657kz"},{"post_id":"ckkq5o73g00nijotp6rk52xms","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o74b00qcjotpao4dgvob"},{"post_id":"ckkq5o73g00nijotp6rk52xms","tag_id":"ckkq5o74700psjotp8y074s38","_id":"ckkq5o74c00qejotpeohtaa51"},{"post_id":"ckkq5o73h00nmjotp7cpwger0","tag_id":"ckkq5o74600ppjotp2w0y3xva","_id":"ckkq5o74c00qgjotpa78h4biq"},{"post_id":"ckkq5o73h00nmjotp7cpwger0","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o74d00qhjotpcfyucbiy"},{"post_id":"ckkq5o73h00nmjotp7cpwger0","tag_id":"ckkq5o74700psjotp8y074s38","_id":"ckkq5o74d00qjjotp243s1ntb"},{"post_id":"ckkq5o73k00npjotpblek9rmi","tag_id":"ckkq5o74600ppjotp2w0y3xva","_id":"ckkq5o74e00qljotpf2b40ep3"},{"post_id":"ckkq5o73k00npjotpblek9rmi","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o74e00qmjotp8pfceh5p"},{"post_id":"ckkq5o73k00npjotpblek9rmi","tag_id":"ckkq5o74700psjotp8y074s38","_id":"ckkq5o74e00qojotp9eb09drd"},{"post_id":"ckkq5o73l00nsjotp6exmhabz","tag_id":"ckkq5o74600ppjotp2w0y3xva","_id":"ckkq5o74f00qqjotp8d1jcs5j"},{"post_id":"ckkq5o73l00nsjotp6exmhabz","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o74f00qrjotpcu4ub25c"},{"post_id":"ckkq5o73l00nsjotp6exmhabz","tag_id":"ckkq5o74700psjotp8y074s38","_id":"ckkq5o74g00qtjotp0gcfdakh"},{"post_id":"ckkq5o73n00nwjotp0qvw6jdz","tag_id":"ckkq5o74600ppjotp2w0y3xva","_id":"ckkq5o74h00qvjotp697y7x9c"},{"post_id":"ckkq5o73n00nwjotp0qvw6jdz","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o74h00qwjotp25wkdpxq"},{"post_id":"ckkq5o73n00nwjotp0qvw6jdz","tag_id":"ckkq5o74700psjotp8y074s38","_id":"ckkq5o74h00qyjotp5ihw0bak"},{"post_id":"ckkq5o73o00o0jotp3yla6zdx","tag_id":"ckkq5o74600ppjotp2w0y3xva","_id":"ckkq5o74i00r0jotp1k8n81wh"},{"post_id":"ckkq5o73o00o0jotp3yla6zdx","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o74i00r1jotp8ksa0ymy"},{"post_id":"ckkq5o73o00o0jotp3yla6zdx","tag_id":"ckkq5o74700psjotp8y074s38","_id":"ckkq5o74k00r3jotpdung7zvl"},{"post_id":"ckkq5o73p00o3jotp73hb91nl","tag_id":"ckkq5o74600ppjotp2w0y3xva","_id":"ckkq5o74l00r5jotpfbly0gzo"},{"post_id":"ckkq5o73p00o3jotp73hb91nl","tag_id":"ckkq5o6zw00bwjotpgpga0usw","_id":"ckkq5o74l00r6jotpc9m87ngj"},{"post_id":"ckkq5o73p00o3jotp73hb91nl","tag_id":"ckkq5o74700psjotp8y074s38","_id":"ckkq5o74l00r8jotp0eqi3u3w"},{"post_id":"ckkq5o73q00o6jotp7dh82wgv","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o74l00r9jotpgulq1gic"},{"post_id":"ckkq5o73q00o6jotp7dh82wgv","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o74m00rbjotp8ytj3jdq"},{"post_id":"ckkq5o73q00o6jotp7dh82wgv","tag_id":"ckkq5o74k00r4jotphd7f2igg","_id":"ckkq5o74m00rcjotp2y4r24zt"},{"post_id":"ckkq5o73r00o9jotphcowauhb","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o74m00rejotp4bsd5f6s"},{"post_id":"ckkq5o73r00o9jotphcowauhb","tag_id":"ckkq5o74l00r7jotp567m7vli","_id":"ckkq5o74m00rfjotp8xn7bydu"},{"post_id":"ckkq5o73r00o9jotphcowauhb","tag_id":"ckkq5o74l00rajotp045hf9oe","_id":"ckkq5o74n00rhjotpc30y7lgc"},{"post_id":"ckkq5o73s00ogjotp0kb3gkef","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o74n00rijotp82b845uv"},{"post_id":"ckkq5o73s00ogjotp0kb3gkef","tag_id":"ckkq5o6ze009ujotp4w9i3lmm","_id":"ckkq5o74n00rkjotp93ii1c70"},{"post_id":"ckkq5o73s00ogjotp0kb3gkef","tag_id":"ckkq5o74k00r4jotphd7f2igg","_id":"ckkq5o74n00rljotp0fs525df"},{"post_id":"ckkq5o73t00ojjotp69hz6cfc","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o74o00rnjotphtzoblxq"},{"post_id":"ckkq5o73t00ojjotp69hz6cfc","tag_id":"ckkq5o74m00rgjotph3m4et0w","_id":"ckkq5o74o00rojotpf5ikcwv1"},{"post_id":"ckkq5o73t00ojjotp69hz6cfc","tag_id":"ckkq5o70h00drjotpajg60am9","_id":"ckkq5o74o00rqjotp61vh64g4"},{"post_id":"ckkq5o73w00onjotpgy0jhlit","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o74o00rrjotp905sdy9t"},{"post_id":"ckkq5o73w00onjotpgy0jhlit","tag_id":"ckkq5o74n00rjjotpb2qt8q1o","_id":"ckkq5o74p00rtjotpa5sufcjb"},{"post_id":"ckkq5o73w00onjotpgy0jhlit","tag_id":"ckkq5o70v00fpjotp1ris1iro","_id":"ckkq5o74p00rujotp9bbigka9"},{"post_id":"ckkq5o73x00oqjotp57895sve","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o74p00rvjotp4lr75p8g"},{"post_id":"ckkq5o73x00oqjotp57895sve","tag_id":"ckkq5o71200gljotpb2ktdh0w","_id":"ckkq5o74p00rwjotpf76nak43"},{"post_id":"ckkq5o73x00oqjotp57895sve","tag_id":"ckkq5o74k00r4jotphd7f2igg","_id":"ckkq5o74p00rxjotp2tkbfdf2"},{"post_id":"ckkq5o73y00oujotpgw5aaa96","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o74p00ryjotphow41ocb"},{"post_id":"ckkq5o73y00oujotpgw5aaa96","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o74p00rzjotp406f0f5z"},{"post_id":"ckkq5o73y00oujotpgw5aaa96","tag_id":"ckkq5o74k00r4jotphd7f2igg","_id":"ckkq5o74p00s0jotp8257h7h3"},{"post_id":"ckkq5o73z00oxjotpaa2n0gxb","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o74p00s1jotp1y7baw99"},{"post_id":"ckkq5o73z00oxjotpaa2n0gxb","tag_id":"ckkq5o70p00f7jotpgunbf4oa","_id":"ckkq5o74p00s2jotpgp99g7q9"},{"post_id":"ckkq5o73z00oxjotpaa2n0gxb","tag_id":"ckkq5o74k00r4jotphd7f2igg","_id":"ckkq5o74p00s3jotpgzzucxio"},{"post_id":"ckkq5o74q00s4jotp94bv9s8m","tag_id":"ckkq5o6yx007wjotpge8v9brx","_id":"ckkq5o74r00s5jotp2d6ucap0"},{"post_id":"ckkq5o74q00s4jotp94bv9s8m","tag_id":"ckkq5o6zd009tjotp8z78f3px","_id":"ckkq5o74r00s6jotph1qic0lo"},{"post_id":"ckkq5o74q00s4jotp94bv9s8m","tag_id":"ckkq5o74k00r4jotphd7f2igg","_id":"ckkq5o74r00s8jotpc80980ds"}],"Tag":[{"name":"深入理解Java虚拟机","_id":"ckkq5o6vo0009jotp07to77ln"},{"name":"JVM","_id":"ckkq5o6vs000ejotpe6va1gro"},{"name":"编译器","_id":"ckkq5o6vv000jjotpc6rx7b7d"},{"name":"Javac","_id":"ckkq5o6w60013jotp7a5de4sr"},{"name":"语法糖","_id":"ckkq5o6w90018jotpfj5863mu"},{"name":"线程","_id":"ckkq5o6wf001njotpg1yvaauf"},{"name":"锁","_id":"ckkq5o6wj001vjotp10ckfrd0"},{"name":"内存模型","_id":"ckkq5o6wr0028jotp019be5zv"},{"name":"运行时数据区","_id":"ckkq5o6wv002mjotp0gmhhn3a"},{"name":"垃圾收集器","_id":"ckkq5o6x0002vjotp3xh600ea"},{"name":"Class","_id":"ckkq5o6x50032jotpavw5hkzw"},{"name":"Java基础","_id":"ckkq5o6x70039jotpbxkj4axv"},{"name":"JavaWeb","_id":"ckkq5o6x8003gjotpanvn0s5w"},{"name":"栈帧","_id":"ckkq5o6xb003qjotp9o2xht5f"},{"name":"方法调用","_id":"ckkq5o6xd003yjotp71rpf0lt"},{"name":"IO","_id":"ckkq5o6xj004cjotp032mbxix"},{"name":"类加载器","_id":"ckkq5o6xn004ijotpcq77esoi"},{"name":"对象","_id":"ckkq5o6xv0055jotphoz2fpnu"},{"name":"异常","_id":"ckkq5o6y0005hjotpej8weex1"},{"name":"String","_id":"ckkq5o6y6005tjotp4oh26qq3"},{"name":"Redis","_id":"ckkq5o6ya0065jotp65rbgcms"},{"name":"RDB","_id":"ckkq5o6yd006djotpdsg24r5t"},{"name":"数据库","_id":"ckkq5o6yg006ijotpek2t7fvj"},{"name":"AOF","_id":"ckkq5o6yj006ujotp41zf8vyo"},{"name":"复制","_id":"ckkq5o6yq007cjotpcmfk263y"},{"name":"数据结构","_id":"ckkq5o6yx007wjotpge8v9brx"},{"name":"字符串","_id":"ckkq5o6yz0082jotp3jwx85ss"},{"name":"字典","_id":"ckkq5o6z4008ljotp5fe8gt2e"},{"name":"Sentinel","_id":"ckkq5o6z7008zjotp81chc93b"},{"name":"整数集合","_id":"ckkq5o6zb009hjotpdox3gb18"},{"name":"跳跃表","_id":"ckkq5o6zc009njotp0hhyeq3w"},{"name":"链表","_id":"ckkq5o6zd009tjotp8z78f3px"},{"name":"指针","_id":"ckkq5o6ze009ujotp4w9i3lmm"},{"name":"压缩列表","_id":"ckkq5o6zh00a1jotp8wec3od2"},{"name":"工具","_id":"ckkq5o6zi00a7jotp512m8qea"},{"name":"Hadoop","_id":"ckkq5o6zj00aajotpfyeia22t"},{"name":"NLP","_id":"ckkq5o6zj00abjotp1w8a7rb9"},{"name":"VMware","_id":"ckkq5o6zk00akjotp0ra9bh2z"},{"name":"Vue","_id":"ckkq5o6zk00aojotp8amzcj1r"},{"name":"markdown","_id":"ckkq5o6zl00asjotpa8j9gnqq"},{"name":"Docker","_id":"ckkq5o6zm00awjotp0wpe9xlp"},{"name":"hexo","_id":"ckkq5o6zm00b0jotpaqyl9n9b"},{"name":"idea","_id":"ckkq5o6zn00b4jotp9655hap4"},{"name":"linux","_id":"ckkq5o6zn00b8jotp8dj96sjd"},{"name":"SSH","_id":"ckkq5o6zo00bcjotp1h3rcry9"},{"name":"图床","_id":"ckkq5o6zs00bkjotpfyfqhwe6"},{"name":"windows","_id":"ckkq5o6zu00bsjotpf6gq3jlm"},{"name":"LeetCode","_id":"ckkq5o6zv00btjotparco8ov4"},{"name":"Java","_id":"ckkq5o6zw00bwjotpgpga0usw"},{"name":"HashMap","_id":"ckkq5o6zx00bxjotp2f9d8a37"},{"name":"二叉树","_id":"ckkq5o70300cdjotp3kfga96k"},{"name":"递归","_id":"ckkq5o70400cfjotp1uuu8ell"},{"name":"层次遍历","_id":"ckkq5o70800crjotp1rvfdhxg"},{"name":"数组","_id":"ckkq5o70900cxjotp2mpz519b"},{"name":"遍历","_id":"ckkq5o70g00dljotpclkz748k"},{"name":"算法","_id":"ckkq5o70h00drjotpajg60am9"},{"name":"动态规划","_id":"ckkq5o70h00dxjotpduhfcvi6"},{"name":"异或","_id":"ckkq5o70j00e9jotp5th0fnfa"},{"name":"Map","_id":"ckkq5o70k00edjotp1hvm0p7y"},{"name":"LRU","_id":"ckkq5o70k00efjotp6je07ti8"},{"name":"排序","_id":"ckkq5o70l00eljotp0oblft6v"},{"name":"快慢指针","_id":"ckkq5o70m00erjotp78o8alr3"},{"name":"栈","_id":"ckkq5o70p00f7jotpgunbf4oa"},{"name":"图","_id":"ckkq5o70v00fpjotp1ris1iro"},{"name":"dfs","_id":"ckkq5o70w00frjotp51m59is7"},{"name":"树","_id":"ckkq5o71100gfjotp1bgb9xwj"},{"name":"二维数组","_id":"ckkq5o71200gljotpb2ktdh0w"},{"name":"全排列","_id":"ckkq5o71500gxjotpb1ew1jdl"},{"name":"归并","_id":"ckkq5o71800h7jotp6zu85omx"},{"name":"二分搜索","_id":"ckkq5o71900hfjotp61prcgnr"},{"name":"回溯","_id":"ckkq5o71a00hljotpdk2n5zv5"},{"name":"矩阵","_id":"ckkq5o71i00irjotpdwcm2ra7"},{"name":"快排","_id":"ckkq5o71r00jrjotpb0xd3dki"},{"name":"滑动窗口","_id":"ckkq5o71t00jxjotpe9ptdy6i"},{"name":"深搜","_id":"ckkq5o71v00k3jotpgcokg0jc"},{"name":"解空间树","_id":"ckkq5o71x00k9jotpar9d93o8"},{"name":"计算机网络","_id":"ckkq5o72300ksjotpei6ufy33"},{"name":"OSI参考模型","_id":"ckkq5o72400kvjotp0tmi1lnm"},{"name":"TCP/IP","_id":"ckkq5o72500kxjotpgvac9ysg"},{"name":"运输层","_id":"ckkq5o72500kyjotp7e3hc1zp"},{"name":"TCP","_id":"ckkq5o72600l1jotpeuvf862t"},{"name":"UDP","_id":"ckkq5o72700l3jotpdjfybadt"},{"name":"DNS","_id":"ckkq5o72800lajotp3tnign9c"},{"name":"应用层","_id":"ckkq5o72900ldjotp67du1mut"},{"name":"HTTP","_id":"ckkq5o72900lfjotp4s0v2oav"},{"name":"HTML","_id":"ckkq5o72a00lgjotp7u6udmir"},{"name":"JavaScript","_id":"ckkq5o72a00ljjotp3c9l5u5v"},{"name":"Springboot","_id":"ckkq5o72b00lljotp51jxh9ov"},{"name":"CSS","_id":"ckkq5o72c00lrjotpbogyb4rv"},{"name":"操作系统","_id":"ckkq5o72c00lvjotp9s883rnl"},{"name":"Swing","_id":"ckkq5o72d00lxjotpe9br9ln8"},{"name":"内存管理","_id":"ckkq5o72e00m3jotp3osmao6j"},{"name":"文件管理","_id":"ckkq5o72f00m9jotpgbo00mqx"},{"name":"操作符","_id":"ckkq5o73000mgjotpae3pcx89"},{"name":"类","_id":"ckkq5o73600mljotp57iqc4gb"},{"name":"数据类型","_id":"ckkq5o73900msjotpcjjw4x11"},{"name":"继承","_id":"ckkq5o73b00mxjotp3txz2ta4"},{"name":"多态","_id":"ckkq5o73c00n4jotp8i930mdt"},{"name":"构造函数","_id":"ckkq5o73e00ncjotp81x114jw"},{"name":"初始化","_id":"ckkq5o73h00nkjotpamezbv74"},{"name":"类加载","_id":"ckkq5o73o00nzjotp83snhno9"},{"name":"修饰符","_id":"ckkq5o73q00o5jotp2wtt5to9"},{"name":"访问权限","_id":"ckkq5o73s00oejotp08l0bc29"},{"name":"内部类","_id":"ckkq5o73u00oljotp8yygcpg5"},{"name":"Collection","_id":"ckkq5o73x00osjotp9ybz2uzo"},{"name":"集合","_id":"ckkq5o74200p0jotpaco0hkoh"},{"name":"正则表达式","_id":"ckkq5o74300p6jotpdjpo93pe"},{"name":"Exception","_id":"ckkq5o74400pbjotp84yeb7zy"},{"name":"反射","_id":"ckkq5o74400pfjotp3axy136z"},{"name":"泛型","_id":"ckkq5o74500pijotp5yyp7116"},{"name":"设计模式","_id":"ckkq5o74600ppjotp2w0y3xva"},{"name":"UML","_id":"ckkq5o74700psjotp8y074s38"},{"name":"c++","_id":"ckkq5o74k00r4jotphd7f2igg"},{"name":"排序算法","_id":"ckkq5o74l00r7jotp567m7vli"},{"name":"快速排序","_id":"ckkq5o74l00rajotp045hf9oe"},{"name":"堆","_id":"ckkq5o74m00rgjotph3m4et0w"},{"name":"最小生成树","_id":"ckkq5o74n00rjjotpb2qt8q1o"}]}}