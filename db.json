{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/my_hexo/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/icp.png","path":"medias/icp.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/cover.jpg","path":"medias/cover.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/reward/wechat.jpg","path":"medias/reward/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":1,"renderable":1},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"2822f616502c540e80d741ac696406db5084f8af","modified":1601639408157},{"_id":"themes/my_hexo/.gitignore","hash":"727607929a51db7ea10968f547c26041eee9cfff","modified":1601106471000},{"_id":"themes/my_hexo/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1601106471000},{"_id":"themes/my_hexo/README.md","hash":"56299cf1fe60a11fef61b3948fe148f995df747e","modified":1601106471000},{"_id":"themes/my_hexo/README_CN.md","hash":"0fdf818476a444663cc8ffa2f194199d9fd93508","modified":1601343393696},{"_id":"themes/my_hexo/_config.yml","hash":"561ab871deabd221e0a3c525419a2cb130addbbe","modified":1612399972069},{"_id":"source/404/index.md","hash":"adc4e1296fa512139519930ee498ac9d95a1fb25","modified":1601200416358},{"_id":"source/_data/friends.json","hash":"8828a88b0cd35bb91b7951a9826c3b0a5f04bf1c","modified":1601283996719},{"_id":"source/about/index.md","hash":"3f969cb7ab37ad41aa25bcdb4fe165b0256359a0","modified":1601199515722},{"_id":"source/categories/index.md","hash":"130625d0bdd8cf8d513ada545a00766000e099ed","modified":1601199466287},{"_id":"source/contact/index.md","hash":"b4d65c2b202c7f339dead9ef10af31793b0f762b","modified":1601199966504},{"_id":"source/friends/index.md","hash":"09a403a4c3cd449ca3a4cdbdd5e2b79531bc5967","modified":1601216799511},{"_id":"source/tags/index.md","hash":"fc35ab5abf719ac3dc4092d260e3321d766cd546","modified":1601199450443},{"_id":"themes/my_hexo/languages/default.yml","hash":"54ccc01b097c5bf6820f0edfcece1a87b78ab32d","modified":1601106471000},{"_id":"themes/my_hexo/languages/zh-CN.yml","hash":"a957b05f70265a86a87d922e18488571809d2472","modified":1601106471000},{"_id":"themes/my_hexo/languages/zh-HK.yml","hash":"ae34ac0e175c3037675722e436637efbceea32f0","modified":1601106471000},{"_id":"themes/my_hexo/layout/404.ejs","hash":"9c8ca67377211e5d60fdde272a975faa9a91a22a","modified":1601106471000},{"_id":"themes/my_hexo/layout/archive.ejs","hash":"cdac701de8370f9f3794a0eed4165983993a1ca7","modified":1601106471000},{"_id":"themes/my_hexo/layout/about.ejs","hash":"41849f9300b8dc47048333fcf4a897dd8a2a13ca","modified":1601106471000},{"_id":"themes/my_hexo/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1601106471000},{"_id":"themes/my_hexo/layout/category.ejs","hash":"00019bca11fb46477f22017cb1f5ad8444da0580","modified":1601106471000},{"_id":"themes/my_hexo/layout/contact.ejs","hash":"72fb5af3fc2f8955e2eb10926bbe4532a04ccd1b","modified":1601106471000},{"_id":"themes/my_hexo/layout/friends.ejs","hash":"f5d6459bed0f4ecb214f2dbff5b2207a80c44f66","modified":1601106471000},{"_id":"themes/my_hexo/layout/index.ejs","hash":"4dc6f08e7709cc04e886be72dbf0d06469f0effc","modified":1601106471000},{"_id":"themes/my_hexo/layout/layout.ejs","hash":"22125624381b8d4dd50cb17ffe0631c838557364","modified":1601106471000},{"_id":"themes/my_hexo/layout/post.ejs","hash":"90b5a4c1f70e4756db569c15a7c6cad0c77c4500","modified":1601106471000},{"_id":"themes/my_hexo/layout/tag.ejs","hash":"85a4b05bd8a6ad0f17ff2e97dae56949b379c204","modified":1601106471000},{"_id":"themes/my_hexo/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1601106471000},{"_id":"themes/my_hexo/source/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/dream.ejs","hash":"9a472ad5591100cdb65d0df9d01034163bd6dd9d","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/category-radar.ejs","hash":"1d8747fda89a0b2ca3c7008867cbfeecad0578a6","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/category-cloud.ejs","hash":"1b3df1009234c0112424b497b18b4ad8240b3bc7","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/music.ejs","hash":"e9e3e327d5de9d7aeadbde32e1d558652d9e9195","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/my-gallery.ejs","hash":"65a2d2f9722f84c7fd98f6bdf79087a14848ebd8","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/my-projects.ejs","hash":"ef60b64021fa349b0048425d858dfcf6c906fede","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/post-calendar.ejs","hash":"48821e644bc73553d7c5c56d2e8ee111a70cd776","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/post-charts.ejs","hash":"ab5f986f428215941aeaa0c88aefd440c47d3bcf","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/recommend.ejs","hash":"8551137e94ca4e2e3b8b63d5626255884cb60cb5","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/tag-wordcloud.ejs","hash":"487aacb2454d6bf0d21cdb07ddd1fd5ddbca9038","modified":1601106471000},{"_id":"themes/my_hexo/layout/_widget/video.ejs","hash":"a0e002377af2a7f7e4da6d9a644de97adb035925","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/bg-cover-content.ejs","hash":"2fdb3ff1e571663daf91b8634ec2968b4f55ce84","modified":1601277376507},{"_id":"themes/my_hexo/layout/_partial/disqus.ejs","hash":"b2dc2c8b5ed56815e55cc2ea54a6dc4eeba2375d","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/gitalk.ejs","hash":"2aa8fbb04b046fa7679092a48372d7e036835dff","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/footer.ejs","hash":"c4b917d3ac0f5996b02e646639d5d414e161f9df","modified":1601368687022},{"_id":"themes/my_hexo/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/gitment.ejs","hash":"90f6218512ef2eab63ada7ad2fc766ae635a2297","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/head.ejs","hash":"79480f22a18d84e8f54a72e9b5dcd26356e8f039","modified":1601706694921},{"_id":"themes/my_hexo/layout/_partial/header.ejs","hash":"59e38c70f3d8e7165e686e5e84a627835f4321b0","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/index-cover.ejs","hash":"76b4a37e0364380b143fdf94bf1a5e6941564414","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/minivaline.ejs","hash":"5f09386aece8f9cf31f6059bbde79cd6c5171493","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/mobile-nav.ejs","hash":"cb0cb452be1cd1857ba600f04025b506f3b6fc79","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/navigation.ejs","hash":"78b70ff24b3039c871331ebec114b936c1756cc8","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/post-cover.ejs","hash":"d1c873c5de54498c722e155aadb8c0ec39485dfa","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/post-detail-toc.ejs","hash":"ff3ceb93a03af5d9d120710347570ecaafc00979","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/post-detail.ejs","hash":"d05926e79aa6dfc235193b9d8c6aa03118b0eade","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/prev-next.ejs","hash":"c76b78782ea82340104fccc089417572e0adece4","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/reprint-statement.ejs","hash":"0ce3f9361f558b99cc2f059c5e50b0e2a152ae38","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/reward.ejs","hash":"ffc55bc7e73bc698bfc58d8e3780c336b83282cf","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/search.ejs","hash":"b39db4e38cf230a83e83dbbfae5560519f59abfa","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/share.ejs","hash":"c941730a2471d6aab367cbb6e09ed08b56c83143","modified":1601106471000},{"_id":"themes/my_hexo/layout/_partial/social-link.ejs","hash":"ee0a23d94a559ff5d8d5f4b40a2fc06b6ee37c15","modified":1601341415854},{"_id":"themes/my_hexo/layout/_partial/valine.ejs","hash":"0e4c0a6154aa34007849928ca88f05b6185b256e","modified":1601106471000},{"_id":"themes/my_hexo/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1601106471000},{"_id":"themes/my_hexo/source/css/matery.css","hash":"87bd1dacf48c9daab7ea43466368247f1e4107d1","modified":1601106471000},{"_id":"themes/my_hexo/source/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1601106471000},{"_id":"themes/my_hexo/source/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1601106471000},{"_id":"themes/my_hexo/source/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1601106471000},{"_id":"themes/my_hexo/source/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/logo.png","hash":"488870f0f476a2349ac258b7c42a4c732eaef5a0","modified":1601340508586},{"_id":"themes/my_hexo/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1601106471000},{"_id":"source/_posts/Java语言/Java多线程/1.内存模型.md","hash":"52c5680c44b286bd510d0acfa85a447b1827697f","modified":1623123300509},{"_id":"source/_posts/Java语言/Java多线程/2.线程基础.md","hash":"fcfcbef098c09efa7e4d31bd96698931339a565a","modified":1623123300514},{"_id":"source/_posts/Java语言/Java多线程/3.ReentrantLock锁.md","hash":"d919dbd408b7a12f5f3c83ed549223ec1014b0ef","modified":1623123300511},{"_id":"source/_posts/Java语言/Java多线程/4.AQS与应用.md","hash":"ac68115b82ccce1c3b51848c383368b682ee3f9d","modified":1623123300503},{"_id":"source/_posts/Java语言/Java虚拟机/1.运行时数据区.md","hash":"04af7b4bd3818a6cfe584157288a2d2ee8eb8f05","modified":1623123300518},{"_id":"source/_posts/Java语言/Java虚拟机/2.垃圾收集器.md","hash":"dc0a853f0d30fcb961fa21354937869a5cd4bd9b","modified":1623123300516},{"_id":"source/_posts/Java语言/Java虚拟机/3.类加载机制.md","hash":"cc8e4db00342ffd158c7df9a99868f4d1cd26f3a","modified":1623123300521},{"_id":"source/_posts/Java语言/Java集合/1.集合基础.md","hash":"4700e79106139d6bd39ee921a45c8ef41e4fd1fc","modified":1623123300520},{"_id":"source/_posts/Java语言/Java集合/2.List集合.md","hash":"8dff994ffbbcae29b5513fb9f32fbb6b10d614c9","modified":1623123300523},{"_id":"source/_posts/Java语言/Java集合/3.Map集合.md","hash":"530c41a532c2ff3591392097fe9954b961254301","modified":1623123300526},{"_id":"source/_posts/计算机基础/计算机网络/Netty.md","hash":"ae5baea11fb9db577c174e82fa132b5a785ff252","modified":1623123300524},{"_id":"source/_posts/计算机基础/设计模式/01.单例模式.md","hash":"dda35a5b0c4c4ca989b964899536a984617f05ce","modified":1623123300527},{"_id":"source/_posts/计算机基础/设计模式/03.代理模式.md","hash":"ead7fb050dc0b4f50ee51e733b13a6653a7b9644","modified":1623123300631},{"_id":"source/_posts/计算机基础/设计模式/02.装饰者模式.md","hash":"e9411df944f7fa2b89c7c9f7ac9680f8f585bc60","modified":1623123300528},{"_id":"source/_posts/数据库/MySQL数据库/01.MySQL索引.md","hash":"3e9b795a7423ff6de5def947efe5b82c1dc49e9a","modified":1623123300530},{"_id":"source/_posts/数据库/MySQL数据库/03.MySQL慢查询与优化.md","hash":"28bdca9039af656da4f7cbd8043734694d8ef0a8","modified":1623123300638},{"_id":"source/_posts/数据库/MySQL数据库/02.MySQL事务.md","hash":"4456a018727e1712a8bf90adad18cc3044a966c4","modified":1623123300633},{"_id":"source/_posts/数据库/Redis数据库/1.Redis数据结构.md","hash":"ae9acb7c889846b7eb5e4bbe0e5b1bf3a357d422","modified":1623123300636},{"_id":"source/_posts/数据库/Redis数据库/2.Redis设计机制.md","hash":"a5adb13a70cd829bb40548fac6a4b3ca9599e318","modified":1623123300640},{"_id":"source/_posts/数据库/Redis数据库/3.Redis集群.md","hash":"cc9b1c5b2e2484d1e96674ecea8a05d360d82bfc","modified":1623123300697},{"_id":"themes/my_hexo/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1601106471000},{"_id":"source/_posts/计算机基础/计算机网络/网络编程基础.md","hash":"eb6c16f7f3e05650ec036710b22f0abf11205e33","modified":1623123300700},{"_id":"themes/my_hexo/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/avatar.jpg","hash":"5df0399b8097fc06d8fa3641da3db1a22aaca936","modified":1601293366757},{"_id":"themes/my_hexo/source/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/reward/wechat.jpg","hash":"4ab47898643c36db9b679e3dfa1dc050ad13e476","modified":1601278131468},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/reward/alipay.jpg","hash":"2d9fc663c295daa53adc716234a018679ea23c3e","modified":1601278314468},{"_id":"themes/my_hexo/source/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1601106471000},{"_id":"themes/my_hexo/source/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1601106471000},{"_id":"themes/my_hexo/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1601106471000},{"_id":"public/atom.xml","hash":"f39459c97abbdc750daef655799a24f8aec43b7a","modified":1623138450750},{"_id":"public/search.xml","hash":"8d3ffa7f3c6733fd6ef2cee143af4763324825bc","modified":1623138450750},{"_id":"public/baidusitemap.xml","hash":"66c21b9430884580e81e78b831a7da3b8fddb02c","modified":1623138450750},{"_id":"public/sitemap.xml","hash":"cad8ce2e8edb0dc46d1415fccc67255514f3cf6b","modified":1623138450750},{"_id":"public/404/index.html","hash":"83eb3d14afadbd495cd5b4bf78691608272578e1","modified":1623138450750},{"_id":"public/about/index.html","hash":"914e283ff3aff501ac85acd8aab996b4b0039429","modified":1623138450750},{"_id":"public/categories/index.html","hash":"7842bb1ac7b20d4fc551033dafdf39e73b9bf3d4","modified":1623138450750},{"_id":"public/contact/index.html","hash":"e2411ad115d852a7399fa13e7eb4718a358d5e2d","modified":1623138450750},{"_id":"public/friends/index.html","hash":"e4d5512a4a0fe35ce9ec023342e550970e08eccf","modified":1623138450750},{"_id":"public/tags/index.html","hash":"52edbedd436f6637cdb66f767240221da46c0bc1","modified":1623138450750},{"_id":"public/posts/6ab5c4a5.html","hash":"3a29e2775a4bc43cf9771598b24afd7ca3e5f0e6","modified":1623138450750},{"_id":"public/posts/1c6ba3e2.html","hash":"ce86e916f996cb5e5c0751a7e8fe56c16bd65a82","modified":1623138450750},{"_id":"public/posts/d6e0ce95.html","hash":"416e050e84dbce2c443db6dc572092561756bc14","modified":1623138450750},{"_id":"public/posts/adcb768c.html","hash":"0fab14bf2bf09a1cb3aa668de6d4f3fdc89884ba","modified":1623138450750},{"_id":"public/posts/e6493c73.html","hash":"156336e7d5e9e9b3cf644366c9c0200ceef29b04","modified":1623138450750},{"_id":"public/posts/b9f6280b.html","hash":"9c6c9b9a4a5f5c9ebc196cd2f78332c89b7745cc","modified":1623138450750},{"_id":"public/posts/cd1d308.html","hash":"a9ab86b013e8d064391344798bb8f3d5899f7656","modified":1623138450750},{"_id":"public/posts/6158ee9c.html","hash":"019ec299c07032d613c20b28a989ad3f9b2495ef","modified":1623138450750},{"_id":"public/posts/11595de.html","hash":"c6bf39d039d4f76de4ae84ef74a332b1c27fb7d1","modified":1623138450750},{"_id":"public/posts/a708a60d.html","hash":"bad655b6a5a029c3750f9388fa46fd5b14d53a31","modified":1623138450750},{"_id":"public/posts/7b510e10.html","hash":"b3d5d2e13ad9405f409d7be561f5c8f88149de9a","modified":1623138450750},{"_id":"public/posts/f1601c3e.html","hash":"18cecdcadf7f64ec10484fde7e795e8dfec9c10e","modified":1623138450750},{"_id":"public/posts/5b59a61f.html","hash":"3e51fceac91467ebc48d3edf73848650f653dca2","modified":1623138450750},{"_id":"public/posts/cf90fc03.html","hash":"589fe6e6909cc5d4cfe941caacb91d107cbd132c","modified":1623138450750},{"_id":"public/posts/ca057823.html","hash":"ddfcba2b75074359bf30a0aa1f82880ef4b07d95","modified":1623138450750},{"_id":"public/posts/37cf2cfd.html","hash":"dc24487e34cf01625994aef2b627cbbe2a7d4aca","modified":1623138450750},{"_id":"public/posts/83265645.html","hash":"0bc20c5b6c147cc635af1bd552af5c4266f2576f","modified":1623138450750},{"_id":"public/posts/85682d75.html","hash":"a81495da3bc52c2e6d4bec01531853032172e415","modified":1623138450750},{"_id":"public/posts/1cb7ab34.html","hash":"9d9c5e6935dec47ac4629a325488bca11357dfd2","modified":1623138450750},{"_id":"public/posts/f91535f.html","hash":"d2ab2069b3ed7d0f740b9f66f86aa4842e7efd1a","modified":1623138450750},{"_id":"public/posts/43a71ae4.html","hash":"3551696f2aeeeedb224315aa3037cf48950bfc39","modified":1623138450750},{"_id":"public/archives/index.html","hash":"cacc5d91fa560e4d3dfa278738710e6e1ffa41b9","modified":1623138450750},{"_id":"public/archives/page/2/index.html","hash":"6d22ade83a344ca06c6dbd6a8e2916da9f1f22c8","modified":1623138450750},{"_id":"public/archives/2020/index.html","hash":"8ec3bdb6ad71c3efd41bdfcb90c5534be90d4fdb","modified":1623138450750},{"_id":"public/archives/2020/10/index.html","hash":"d30f4dd168fb5c48a8ae75a0dddf4979d31fe2be","modified":1623138450750},{"_id":"public/archives/2020/11/index.html","hash":"c41973a35f115dfe22b1121ca6b4a120ed371723","modified":1623138450750},{"_id":"public/archives/2020/12/index.html","hash":"298ee1708883aae34e5f5548ff04fb18f2cd8e4a","modified":1623138450750},{"_id":"public/archives/2021/index.html","hash":"8b562db2a20fae3a2a95cbd4d184240bcb9209b7","modified":1623138450750},{"_id":"public/archives/2021/01/index.html","hash":"99773fbf5a8c9a72c5a30ba25cb9d962be7bf5b3","modified":1623138450750},{"_id":"public/archives/2021/02/index.html","hash":"03ae7f9d44a65448f6a2e3a0f599470adf28dced","modified":1623138450750},{"_id":"public/archives/2021/03/index.html","hash":"6bde3ae32c748f5ef2f7bedd22d029e5bad5993e","modified":1623138450750},{"_id":"public/archives/2021/04/index.html","hash":"a8e269a01f46b95316b9b592bfbe2e2b3de7e921","modified":1623138450750},{"_id":"public/archives/2021/05/index.html","hash":"85ffcf7e747f94beeecd8d184c3eaa44ae82b113","modified":1623138450750},{"_id":"public/archives/2021/06/index.html","hash":"13d1d7e4d588be8cad43c56fe497d1fe85ef5d6d","modified":1623138450750},{"_id":"public/index.html","hash":"2098a225a391f2a73c3745ef9da6292e44e83809","modified":1623138450750},{"_id":"public/page/2/index.html","hash":"4b07e28445a9fa7ac58df6eecf96a9f0ceefda99","modified":1623138450750},{"_id":"public/categories/Java多线程/index.html","hash":"8af28c2ee7c4e0a5039c5f06d7000a373326a580","modified":1623138450750},{"_id":"public/categories/Java虚拟机/index.html","hash":"7a2ba3bbd020479418d777b1b8d04bf406cf0e8f","modified":1623138450750},{"_id":"public/categories/Java集合/index.html","hash":"b7ac958007f9a39b4711557ea862ae82c4692ef9","modified":1623138450750},{"_id":"public/categories/设计模式/index.html","hash":"ea2f9a5d3aae01168ef55a0b72cc117e445ebc25","modified":1623138450750},{"_id":"public/categories/计算机网络/index.html","hash":"5fbbd9d4c609231f5838b62c7195a2743d34e14d","modified":1623138450750},{"_id":"public/categories/MySQL/index.html","hash":"740c9f4c54d66041ce0b33f2c3632ec3d2a22bf5","modified":1623138450750},{"_id":"public/categories/Redis/index.html","hash":"82223ce69e0a5d52d7e0f82b7b25cb7a49bc8aee","modified":1623138450750},{"_id":"public/tags/volatile/index.html","hash":"5a57d20b47f46a397a0ebc09c4852da9536f4025","modified":1623138450750},{"_id":"public/tags/synchronized/index.html","hash":"acf293fccc825ac7b45506192d637360e0400343","modified":1623138450750},{"_id":"public/tags/CAS/index.html","hash":"4289ca47a480ca18cc86cfb70ced0a37cf503763","modified":1623138450750},{"_id":"public/tags/ReentrantLock/index.html","hash":"83ad99c6f23ab04ea4e589315f49e90d1faeb730","modified":1623138450750},{"_id":"public/tags/锁/index.html","hash":"cf682260878e719a1daaf6b39c59c43954fa387c","modified":1623138450750},{"_id":"public/tags/AQS/index.html","hash":"7da814401ac3bb281b6ad45f04207a27329b78f6","modified":1623138450750},{"_id":"public/tags/ThreadLocal/index.html","hash":"a9975dcd86bbf561d156c376b38c63be745121e8","modified":1623138450750},{"_id":"public/tags/线程/index.html","hash":"a7d515d4e76b02982d9055c9b3a6e30f3c41f5f8","modified":1623138450750},{"_id":"public/tags/线程池/index.html","hash":"109695c18fa5bdbb4d9cf5d9e8497a80766574b0","modified":1623138450750},{"_id":"public/tags/引用/index.html","hash":"32b73a4e36ee1c40c0ae5708ea0be2005424d368","modified":1623138450750},{"_id":"public/tags/算法/index.html","hash":"3933358f5fa1bc166ac72dda649c0b08de36b0a3","modified":1623138450750},{"_id":"public/tags/垃圾收集器/index.html","hash":"05ac96dcc04c6a2fe81bf90117f8b09c842c8701","modified":1623138450750},{"_id":"public/tags/集合安全/index.html","hash":"1eb4b587d1822ab566dd4ceab0ac75c39d095c70","modified":1623138450750},{"_id":"public/tags/迭代器机制/index.html","hash":"34b56e0edf2a6179dc325edbeca8c0bf9a8c15d2","modified":1623138450750},{"_id":"public/tags/LRU算法/index.html","hash":"25c6eddf89dcbeaa0fbf99c5e0fa6d99f1cbdfe6","modified":1623138450750},{"_id":"public/tags/阻塞队列/index.html","hash":"eb5eee3c8c97037d7a68a048d17a49f0628eb659","modified":1623138450750},{"_id":"public/tags/并发/index.html","hash":"6cac0a417dd0a0a7a2458216315833c40e6047e4","modified":1623138450750},{"_id":"public/tags/运行时数据区/index.html","hash":"c6d8c773652d67dd7422faae52ff604e4d8a0548","modified":1623138450750},{"_id":"public/tags/异常/index.html","hash":"a4f46e16a0b684a27ca36073bbf45d685b8f3eab","modified":1623138450750},{"_id":"public/tags/工具/index.html","hash":"6985a79c0bb19fac311a419640d57323d3fae5f8","modified":1623138450750},{"_id":"public/tags/双亲委派模型/index.html","hash":"c6ac9e2087a608c74cc50f2066f7075274d9baec","modified":1623138450750},{"_id":"public/tags/生命周期/index.html","hash":"876c3bbcbcefa54b5268bc3722730ea347447c8c","modified":1623138450750},{"_id":"public/tags/类加载器/index.html","hash":"19f52778a3a04bc4a4712ddd3d225e8e62d0d45a","modified":1623138450750},{"_id":"public/tags/HashMap/index.html","hash":"2ebc1c2cefa87e4deaed13645df9d6d497cbf765","modified":1623138450750},{"_id":"public/tags/ConcurrentHashMap/index.html","hash":"3794bf7c77cdecfbdb816484819bb7556472c16d","modified":1623138450750},{"_id":"public/tags/Set/index.html","hash":"196088f18438f8878a4aeece6dd91a18f32b83cd","modified":1623138450750},{"_id":"public/tags/ArrayList/index.html","hash":"fbb1c28716835dee76862ea4177b8fadea5bf46d","modified":1623138450750},{"_id":"public/tags/LinkedList/index.html","hash":"7f828b12e51421f6d606dd66f22279d7ec3a9cf2","modified":1623138450750},{"_id":"public/tags/CopyOnWriteArrayList/index.html","hash":"b76cc53c8236f2c6e942c2529d68efdb9cf9edd8","modified":1623138450750},{"_id":"public/tags/架构/index.html","hash":"4cde804ae694b7e13bf7d42ade224b48317de740","modified":1623138450750},{"_id":"public/tags/静态代理/index.html","hash":"4cb4ab28b64087d74d460c0d94b01b93d973a146","modified":1623138450750},{"_id":"public/tags/动态代理/index.html","hash":"edc9841945695b5b6dde126659f0d2fb5528960b","modified":1623138450750},{"_id":"public/tags/枚举/index.html","hash":"b686c63b6ea2b584183d9fd60575113d972f2ff1","modified":1623138450750},{"_id":"public/tags/单例模式/index.html","hash":"24b7cb158a4e2bc526768a531b4ea887e9963b3e","modified":1623138450750},{"_id":"public/tags/线程模型/index.html","hash":"7691f5bfad5caafc23a223450eef3f80055f9d32","modified":1623138450750},{"_id":"public/tags/设计模式/index.html","hash":"ca9f452043bf6187e6076e6d929298f4af7bccc2","modified":1623138450750},{"_id":"public/tags/开源框架/index.html","hash":"ecb25722c86f966ee6fbd706a1c87a1411554cbe","modified":1623138450750},{"_id":"public/tags/IO/index.html","hash":"88c84dfc9597fc5cc410471246f80e3cdc03752c","modified":1623138450750},{"_id":"public/tags/装饰者模式/index.html","hash":"031651476bcc469efec2ef69937e5f9cf3b71cba","modified":1623138450750},{"_id":"public/tags/优化/index.html","hash":"50f34c565fedb116590b5f9cefb63ad9c970db96","modified":1623138450750},{"_id":"public/tags/explain/index.html","hash":"033446f1582a8c2cbaaf3d61d8a8d3b761bbfc38","modified":1623138450750},{"_id":"public/tags/慢查询/index.html","hash":"de4688c72e3d70d8113f36214325917984af9809","modified":1623138450750},{"_id":"public/tags/索引/index.html","hash":"08ff6f1f8837e129e5dd28a50410c6a8af9024df","modified":1623138450750},{"_id":"public/tags/B-树/index.html","hash":"c877e77c225a1931a7e3f6812ec37a4799cb42e0","modified":1623138450750},{"_id":"public/tags/MySQL/index.html","hash":"57958039aaf4ccd57e4f0f8f7d81791ca4cd6d81","modified":1623138450750},{"_id":"public/tags/事务/index.html","hash":"e8b38b7fe7f9bfc502422e3e94785cef6d4038b0","modified":1623138450750},{"_id":"public/tags/MVCC/index.html","hash":"6b302b4e52655d3c0e4416fcfa76233f2d6702fd","modified":1623138450750},{"_id":"public/tags/数据结构/index.html","hash":"eaad6f573b309803b8da362b5be476645d18c1b7","modified":1623138450750},{"_id":"public/tags/对象/index.html","hash":"05b54e9e7fc7bf0fa2dce1e4c419c2460e6d3025","modified":1623138450750},{"_id":"public/tags/缓存/index.html","hash":"f341a58d3267dea5d24c77a081e0f3f02732ea9e","modified":1623138450750},{"_id":"public/tags/持久化/index.html","hash":"13d1ebaafb39921181017f553851e0d702d2b947","modified":1623138450750},{"_id":"public/tags/删除策略/index.html","hash":"219a37e5e9afc2a7eefb3688085676f6fa8937e5","modified":1623138450750},{"_id":"public/tags/主从复制/index.html","hash":"b8ef4749260d0cd06144b8eadf9fa0dfd080bee2","modified":1623138450750},{"_id":"public/tags/Sentinel/index.html","hash":"883d509bb6266e008c9cd06e46e6e15a04f209f2","modified":1623138450750},{"_id":"public/tags/集群/index.html","hash":"5e9220a2a20665acc128982fc9bdd4d597e482d2","modified":1623138450750},{"_id":"public/tags/IO模型/index.html","hash":"eb02c4b0143ca38a514a92b31d2ef9dc888f1fdb","modified":1623138450750},{"_id":"public/tags/epoll/index.html","hash":"1a955399adb9cc912bbb791839ecf060b93396e4","modified":1623138450750},{"_id":"public/tags/NIO/index.html","hash":"2f26a2b3129dbd175370ecfff434d1f810504705","modified":1623138450750},{"_id":"public/CNAME","hash":"2822f616502c540e80d741ac696406db5084f8af","modified":1623138450750},{"_id":"public/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1623138450750},{"_id":"public/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1623138450750},{"_id":"public/medias/logo.png","hash":"488870f0f476a2349ac258b7c42a4c732eaef5a0","modified":1623138450750},{"_id":"public/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1623138450750},{"_id":"public/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1623138450750},{"_id":"public/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1623138450750},{"_id":"public/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1623138450750},{"_id":"public/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1623138450750},{"_id":"public/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1623138450750},{"_id":"public/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1623138450750},{"_id":"public/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1623138450750},{"_id":"public/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1623138450750},{"_id":"public/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1623138450750},{"_id":"public/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1623138450750},{"_id":"public/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1623138450750},{"_id":"public/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1623138450750},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1623138450750},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1623138450750},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1623138450750},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1623138450750},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1623138450750},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1623138450750},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1623138450750},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1623138450750},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1623138450750},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1623138450750},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1623138450750},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1623138450750},{"_id":"public/css/prism-tomorrow.css","hash":"3b99487dfc9b4e51e9105a93743b92a761840e34","modified":1623138450750},{"_id":"public/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1623138450750},{"_id":"public/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1623138450750},{"_id":"public/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1623138450750},{"_id":"public/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1623138450750},{"_id":"public/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1623138450750},{"_id":"public/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1623138450750},{"_id":"public/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1623138450750},{"_id":"public/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1623138450750},{"_id":"public/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1623138450750},{"_id":"public/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1623138450750},{"_id":"public/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1623138450750},{"_id":"public/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1623138450750},{"_id":"public/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1623138450750},{"_id":"public/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1623138450750},{"_id":"public/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1623138450750},{"_id":"public/medias/reward/wechat.jpg","hash":"4ab47898643c36db9b679e3dfa1dc050ad13e476","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1623138450750},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1623138450750},{"_id":"public/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1623138450750},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1623138450750},{"_id":"public/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1623138450750},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1623138450750},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1623138450750},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1623138450750},{"_id":"public/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1623138450750},{"_id":"public/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1623138450750},{"_id":"public/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1623138450750},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1623138450750},{"_id":"public/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1623138450750},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1623138450750},{"_id":"public/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1623138450750},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1623138450750},{"_id":"public/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1623138450750},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1623138450750},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1623138450750},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1623138450750},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1623138450750},{"_id":"public/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1623138450750},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1623138450750},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1623138450750},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1623138450750},{"_id":"public/css/matery.css","hash":"87bd1dacf48c9daab7ea43466368247f1e4107d1","modified":1623138450750},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1623138450750},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1623138450750},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1623138450750},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1623138450750},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1623138450750},{"_id":"public/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1623138450750},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1623138450750},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1623138450750},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1623138450750},{"_id":"public/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1623138450750},{"_id":"public/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1623138450750},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1623138450750},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1623138450750},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1623138450750},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1623138450750},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1623138450750},{"_id":"public/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1623138450750},{"_id":"public/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1623138450750},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1623138450750},{"_id":"public/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1623138450750},{"_id":"public/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1623138450750},{"_id":"public/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1623138450750},{"_id":"public/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1623138450750},{"_id":"public/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1623138450750},{"_id":"public/medias/reward/alipay.jpg","hash":"2d9fc663c295daa53adc716234a018679ea23c3e","modified":1623138450750},{"_id":"public/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1623138450750},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1623138450750},{"_id":"public/medias/avatar.jpg","hash":"5df0399b8097fc06d8fa3641da3db1a22aaca936","modified":1623138450750},{"_id":"public/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1623138450750},{"_id":"public/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1623138450750}],"Category":[{"name":"Java多线程","_id":"ckpnqq50p0008z0tp43yy8yjh"},{"name":"Java虚拟机","_id":"ckpnqq510000nz0tp2sxt6t31"},{"name":"Java集合","_id":"ckpnqq513000uz0tp4j4v1jl5"},{"name":"设计模式","_id":"ckpnqq51g001lz0tp4q2t5dlq"},{"name":"计算机网络","_id":"ckpnqq51i001tz0tp5fmkgwqg"},{"name":"MySQL","_id":"ckpnqq51j0020z0tpctyeabtv"},{"name":"Redis","_id":"ckpnqq51l002bz0tp9yel1zwx"}],"Data":[{"_id":"friends","data":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}],"Page":[{"title":"404","date":"2020-07-20T05:10:05.000Z","type":"404","layout":"404","description":"Oops～，我崩溃了！找不到你想要的页面 :(","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2020-07-20 13:10:05\ntype: \"404\"\nlayout: \"404\"\ndescription: \"Oops～，我崩溃了！找不到你想要的页面 :(\"\n---","updated":"2020-09-27T09:53:36.358Z","path":"404/index.html","comments":1,"_id":"ckpnqq4y70000z0tpf42r8wlg","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"关于我","date":"2020-07-20T04:01:43.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2020-07-20 12:01:43\ntype: \"about\"\nlayout: \"about\"\n---","updated":"2020-09-27T09:38:35.722Z","path":"about/index.html","comments":1,"_id":"ckpnqq4ya0001z0tp2v0bemxv","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"目录","date":"2020-09-27T09:36:30.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 目录\ndate: 2020-09-27 17:36:30\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2020-09-27T09:37:46.287Z","path":"categories/index.html","comments":1,"_id":"ckpnqq4yx0002z0tp2gmu3jh8","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"留言板","date":"2020-09-27T09:43:59.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: 留言板\ndate: 2020-09-27 17:43:59\ntype: \"contact\"\nlayout: \"contact\"\n---","updated":"2020-09-27T09:46:06.504Z","path":"contact/index.html","comments":1,"_id":"ckpnqq4yy0003z0tp5q9hfs5m","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"友情链接","date":"2020-09-27T09:36:30.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: 友情链接\ndate: 2020-09-27 17:36:30\ntype: \"friends\"\nlayout: \"friends\"\n---","updated":"2020-09-27T14:26:39.511Z","path":"friends/index.html","comments":1,"_id":"ckpnqq4yy0004z0tpe6gmagx9","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"标签","date":"2020-07-20T04:02:07.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-07-20 12:02:07\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2020-09-27T09:37:30.443Z","path":"tags/index.html","comments":1,"_id":"ckpnqq4yz0005z0tp3ulx3y5p","content":"","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":""}],"Post":[{"title":"内存模型","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"内存模型，包括JMM、volatile、synchronized、CAS、线程安全等","abbrlink":"e6493c73","date":"2021-04-04T16:00:00.000Z","_content":"\n\n\n# JMM\n\n## 对象内存布局\n\n+ 对象头\n    + Mark Word \n    + Class Metadata Address \n    + 数组长度\n+ 实例数据（instance data）\n+ 对齐填充（padding）\n\n### Mark Word\n\n- 存储对象自身的运行时数据（如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等）\n- Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。\n\n- 会根据对象的状态复用自己的存储空间\n\n- Mark Word记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。\n\n\n### Class Metadata Address\n\n类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。 压缩后4字节\n\n### 实例数据\n\n- 存放类的属性数据信息\n- 包括父类的属性信息\n- 压缩后每个4字节\n\n### 对齐填充\n\n对象起始地址必须是8字节的整数倍\n\n### 压缩指针\n\n+ 默认64位操作系统应该是八个字节，但是使用压缩指针`UseCompressedClassPointers`，`class pointer`只占了4字节\n+ `UseCompressedOops`，使得对象指针也是压缩的\n\n## Java内存模型\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/v2-af520d543f0f4f205f822ec3b151ad46_1440w.jpg\" style=\"zoom: 25%;\" />\n\n+ 所有变量都存储在主内存中，主内存是共享内存区域，所有线程都可以访问（对应于物理硬件内存）\n\n+ 每个线程都有自己的工作内存（优先存在寄存器和高速缓存）\n\n    + 每个线程创建时JVM都会为其创建一个工作内存(栈空间)，工作内存是每个线程的私有数据结构\n+ 各个线程中的工作内存都存储着主内存中的变量副本拷贝 \n    + 但线程对变量的所有操作必须在工作内存中进行，而不能直接读取主内存中的数据。\n+ 不同线程不能访问其他线程的工作内存。线程间变量值的传递需要通过主内存来完成\n\n# volatile\n\n## 可见性\n\n- volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存\n- volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。\n\n## 禁止指令重排序\n\n指令重排序：从硬件架构上，指令重排序是指处理器采用了运行将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，他必须能正确处理指令依赖情况，保证能输出正确的结果。所以在同一个处理器中，重排序后的代码看起来仍然是有序的\n\n## 不保证原子性\n\ni++对应的字节码：\n\n+ getfield\n+ iconst_1\n+ iadd\n+ putfield\n\n例如一条i++ 指令，由四条字节码指令构成，当`getstatic`指令把i的值取到操作栈顶时，`volatile`关键字保证此时i的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将i的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的i值同步回主内存中\n\n## 原理\n\n有volatile修饰的变量，赋值后字节码多了个`lock addl $0x0,(%esp)`操作，相当于一个内存屏障（指重排序后不能把后面指令重排序到内存屏障之前的位置）\n\nlock作用是将本处理器的缓存写入了内存，会引起其他处理器无效化其缓存，可让前面volatile变量的修改对其他处理器立即可见\n\n`lock addl $0x0,(%esp)`把修改同步到缓存时，意味着所有之前的操作已经完成了，就形成了指令重排序无法越过内存屏障的效果\n\n# synchronized\n\n## 原理\n\n- 互斥：多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。互斥是实现同步的一种手段\n\n- 被synchronized修饰的同步块对同一个线程可重入\n\n- 被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件阻塞后面线程的进入\n\n- 即使出现异常，锁也能自动释放\n\n- synchronized关键字是块结构同步语法，经过Javac编译后，会在同步块前后形成monitorenter、monitorexit两条字节码指令。这两个字节码指令都需要一个reference类型的参数指明要锁定和解锁的对象\n\n- 如果指定了对象参数，就以该对象引用作为reference；如果没有，则以修饰的方法类型（实例方法/类方法）来选择用代码所在的对象实例/Class对象作为线程要持有的锁\n\n- 在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有了这个对象的锁，就把锁的计数器的值+1，执行monitorexit则-1。一旦计数器值为0，锁则释放。如果获取对象锁失败，则当前线程应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止\n\n- Java线程是映射到操作系统的原生内核线程上的，如果要阻塞或唤醒一个线程，需要操作系统帮忙，则需要从用户态到内核态转换。\n\n## 锁升级\n\n### MarkWord布局\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/aHR0cHM6Ly9rYW16aHV5dXFpbmcuZ2l0aHViLmlvLzIwMTkvMDIvMjcvSmF2YSVFNSVBRiVCOSVFOCVCMSVBMSVFNSVBNCVCNCVFNCVCOCU4RSVFOSU5NCU4MSVFNyU5QSU4NCVFNSU4RCU4NyVFNyVCQSVBNy9FMzg3MzdERjE5MEYzN0IwREE0N0RDNEU4NDAyMEE0Ny5qcGc)\n\n### 初始状态\n\n当我们创建一个对象LockObject时，该对象的部分Markword关键数据如下。\n\n| bit fields | 是否偏向锁 | 锁标志位 |\n| ---------- | ---------- | -------- |\n| hash       | 0          | 01       |\n\n　　偏向锁的标志位是“01”，状态是“0”，表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。\n\n### 偏向锁\n\n+ 消除数据在无竞争情况下的同步原语\n+ 这个锁会偏向于第一个获得他的线程，执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步\n+ 当锁对象第一次被线程获取的时候，虚拟机会将对象头中的标志位设置为01，把偏向模式设置为1，表示进入偏向模式；同时使用CAS操作**把获取到这个锁的线程ID记录在对象的Mark Word中**\n+ 如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁的相关同步块时，JVM都可以不再进行任何同步操作\n+ **一旦出现另一个线程去尝试获取这个锁，偏向模式就马上宣告结束**。根据锁对象目前是否处于被锁定状态决定是否撤销偏向，撤销后恢复到未锁定或轻量级锁定状态\n+ 可以提高带有同步但无竞争的程序性能，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式是多余的\n\n| bit fields |       | 是否偏向锁 | 锁标志位 |\n| ---------- | ----- | ---------- | -------- |\n| thread Id  | epoch | 1          | 01       |\n\n**锁膨胀**\n\n　　刚才说了，当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。这也是我们经常所说的**锁膨胀**\n\n**锁撤销**\n\n由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，其大概的过程如下：\n\n1. 在一个安全点停止拥有锁的线程。\n2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。\n3. 唤醒当前线程，将当前锁升级成轻量级锁。所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭\n\n**HashCode**\n\n+ 如果一个对象计算过HashCode，则应该保持该值不变\n+ 而绝大多数对象哈希码的来源Object::hashCode()返回的是对象的一致性哈希码，能强制保持不变\n+ 他通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取得的哈希码值永远不会再发生改变。\n+ 因此，当一个对象已经计算过一致性哈希码后，他就再也无法进入偏向状态\n+ 如果一个对象正处于偏向状态，又需要计算一致性哈希码，则会立刻撤销偏向状态，锁膨胀为重量级锁\n+ 在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类中有字段可以记录非加锁状态（标志位01）下的Mark Word，自然可以存储哈希码\n\n### 轻量级锁\n\n> 轻量级锁也被称为**非阻塞同步**、**乐观锁**，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。\n>\n> 也叫无锁，自旋锁，自适应自旋\n>\n> 设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗\n\n1. 线程在自己的栈桢中创建锁记录Lock Record。\n2. 将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。\n3. 将锁记录中的Owner指针指向锁对象。\n4. 将使用CAS操作把锁对象的MarkWord更新为指向锁记录的指针。\n    - 如果更新成功，则代表这个线程拥有了这个对象的锁\n    - 如果更新失败，意味着至少存在一条线程和当前线程竞争获取该对象的锁，虚拟机会首先检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有这个对象的锁，则直接进入同步块执行\n    - 否则说明这个锁对象被其他线程抢占。如果出现两条以上的线程争用同一个锁，则膨胀为重量级锁，存储指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态\n5. 解锁时，使用CAS把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来\n\n| bit fields           | 锁标志位 |\n| -------------------- | -------- |\n| 指向LockRecord的指针 | 00       |\n\n ![图片1](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165614893a59be34)\n ![图片2](https://user-gold-cdn.xitu.io/2018/8/22/165614960abf2f0e?w=549&h=343&f=png&s=35522)\n\n### 自旋锁\n\n让后面请求锁的那个线程稍等一会（执行一个忙循环），但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，以此避免**阻塞**对性能的影响（挂起线程和恢复线程的操作都需要转入**内核态**执行）\n\n自旋避免线程切换开销，但是占用处理器时间，如果占用过长时间，会白白消耗处理器资源，所以限定自旋次数，如果没有成功获取到锁，则传统方式挂起线程（**默认十次**）\n\n**自适应自旋锁**\n\n自旋时间不固定，由前一次在同一个锁上的自旋时间以及锁的拥有者状态决定\n\n如果同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在执行中，那么虚拟机认为这次自旋很有可能再次成功，进而允许自旋等待相对更长时间，例如100次忙循环\n\n相反，如果自旋很少成功获得锁，则很有可能忽略自旋过程，避免浪费处理器资源\n\n即根据程序性能监控信息，对程序锁的状况预测越来越精确\n\n### 重量级锁\n\n> 互斥锁(重量级锁)也称为**阻塞同步**、**悲观锁**\n\n轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为**互斥锁**。\n当轻量级所经过锁撤销等步骤升级为重量级锁之后，它的Markword部分数据大体如下\n\n| bit fields      | 锁标志位 |\n| --------------- | -------- |\n| 指向Mutex的指针 | 10       |\n\n**为什么说重量级锁开销大呢**\n\n主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行**阻塞**，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从**用户态**转换到**内核态**，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。\n\n# CAS\n\n+ 基于冲突检测的乐观并发策略：不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。不需要把线程阻塞挂起，非阻塞同步，无锁编程\n+ 要求操作和冲突检测这两个步骤具有原子性，需要靠硬件实现：比较并交换（Compare and Swap）\n\n## 原理\n\n需要3个操作数：内存位置（变量的内存地址 V)，旧的预期值（A)，准备设置的新值（B)。\n\n仅当V符合A时，才会用B更新V的值，否则不更新；不管是否更新V值，都会返回V的旧值\n\nCAS是原子操作，执行期间不会被其他线程中断\n\n```java\nprivate volatile int value;\n\npublic synchronized int compareAndSwap(int expectValue， int newValue) {\n        int oldValue = value;\n        if (oldValue == expectValue) {\n            value = newValue;\n        }\n        return oldValue;\n    }\n```\n\n\n\n## ABA问题\n\n其他线程修改数次最后值和原值相同\n\n可以修改版本号，添加时间戳\n\n使用原子引用类AtomicStampedReference，通过控制变量值的版本来保证CAS的正确性\n\n需要解决ABA问题，采用传统互斥同步比原子类更高效\n\n```java\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\n\n/*\n输出:\nt3 第一次版本号: 1\nt4 第一次版本号: 1\nt3 第二次版本号: 2\nt3 第三次版本号: 3\nt4 修改成功与否: false\n当前最新值:100\n */\npublic class MainTest {\n    // 初始值、版本号\n    static AtomicStampedReference<Integer> cas = new AtomicStampedReference<>(100, 1);\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            System.out.println(\"t3 第一次版本号: \" + cas.getStamp());\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            //模拟了一次ABA问题,但是因为有版本号,所以t4线程并不进行更新\n            cas.compareAndSet(100, 101, cas.getStamp(), cas.getStamp() + 1);\n            System.out.println(\"t3 第二次版本号: \" + cas.getStamp());\n            cas.compareAndSet(101, 100, cas.getStamp(), cas.getStamp() + 1);\n            System.out.println(\"t3 第三次版本号: \" + cas.getStamp());\n        }, \"t3\").start();\n\n        new Thread(() -> {\n            int stamp = cas.getStamp();\n            System.out.println(\"t4 第一次版本号: \" + stamp);\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            boolean result = cas.compareAndSet(100, 2019, stamp, stamp + 1);\n            System.out.println(\"t4 修改成功与否: \" + result);\n            System.out.println(\"当前最新值:\" + cas.getReference());\n        }, \"t4\").start();\n    }\n}\n\n```\n\n## AtomicInteger\n\nAtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功\n\n```java\nprivate static final Unsafe unsafe = Unsafe.getUnsafe();\n\npublic final int incrementAndGet()\n{\n    //this当前对象，valueOffset该值的地址偏移量\n    return unsafe.getAndAddInt(this， valueOffset， 1) + 1;\n}\n```\n\n```java\npublic final int getAndAddInt(Object var1， long var2， int var4)\n{\n    int var5;\n    do\n    {\n        var5 = this.getIntVolatile(var1， var2);\n        //因为有可能是这里被挂起，所以获取的值不是最新的\n    } while (!this.compareAndSwapInt(var1， var2， var5， var5 + var4));\n\n    return var5;\n}\n/*\nvar4是1\nvar1， var2 拼接起来得到主内存的值\nvar5相当于自己工作内存的值\n如果这两个比较相等，则将var5 + var4的值赋给(var1， var2)内存地址里，即实现了i++\n*/\n```\n\n底层:`compareAndSwapInt`是一个`native`方法\n\n跟到c++代码后，调用`lock cmpxchg 指令`，即`CAS`在硬件层面上有指令支持\n\n`cmpxchg`仅仅比较并交换，没有确保原子性，原子性是`lock`保证的\n\n`lock`指令在执行后面指令的时候锁定一个北桥信号\n\n#   线程安全\n\n## 不可变\n\n- 被final修饰不一定是不可变：基本数据类型确实是，但是对于对象类型，需要该对象保证自身被创建后，状态永远不会变才行\n- 要保证一个对象不可变，要么他里面所有成员变量都是被final修饰的基本数据类型。要么有引用类型，但是声明为了final，而且没有对该引用类型对象操作的其他函数。例如String\n\n```java\npublic final class String\n{\n    private final char value[];\n    // 除了构造函数，没有修改他的其他方法\n}\n```\n\n- final修饰类则防止被继承。例如String\n- 修饰方法则防止被重写。构造方法不允许final修饰。\n- 修饰变量则防止被修改。如果被final修饰的是对象，只是它的引用不能变，但是本身对象的值可以变\n- 现在一般是为了防止额外的同步开销，它天生是线程安全的\n\n**赋值时机**\n\n- 属性被声明为final后，该变量只能被赋值一次，且一旦被赋值，final变量就不能被改变\n- 类成员变量可以直接显示赋值、构造函数中赋值、类初始代码块中赋值\n- 方法中，final修饰的变量和非final修饰的变量要求一致：必须在使用前赋值\n\n## 栈封闭\n\n把变量写在线程内部\n\n例如在方法里新建的局部变量，实际上是存储在每个线程私有的栈空间，而每个栈的栈空间是不能被其他线程访问到的","source":"_posts/Java语言/Java多线程/1.内存模型.md","raw":"---\ntitle: 内存模型\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 内存模型，包括JMM、volatile、synchronized、CAS、线程安全等\ncategories: Java多线程\ntags:\n  - volatile\n  - synchronized\n  - CAS\nabbrlink: e6493c73\ndate: 2021-04-05 00:00:00\n---\n\n\n\n# JMM\n\n## 对象内存布局\n\n+ 对象头\n    + Mark Word \n    + Class Metadata Address \n    + 数组长度\n+ 实例数据（instance data）\n+ 对齐填充（padding）\n\n### Mark Word\n\n- 存储对象自身的运行时数据（如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等）\n- Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。\n\n- 会根据对象的状态复用自己的存储空间\n\n- Mark Word记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。\n\n\n### Class Metadata Address\n\n类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。 压缩后4字节\n\n### 实例数据\n\n- 存放类的属性数据信息\n- 包括父类的属性信息\n- 压缩后每个4字节\n\n### 对齐填充\n\n对象起始地址必须是8字节的整数倍\n\n### 压缩指针\n\n+ 默认64位操作系统应该是八个字节，但是使用压缩指针`UseCompressedClassPointers`，`class pointer`只占了4字节\n+ `UseCompressedOops`，使得对象指针也是压缩的\n\n## Java内存模型\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/v2-af520d543f0f4f205f822ec3b151ad46_1440w.jpg\" style=\"zoom: 25%;\" />\n\n+ 所有变量都存储在主内存中，主内存是共享内存区域，所有线程都可以访问（对应于物理硬件内存）\n\n+ 每个线程都有自己的工作内存（优先存在寄存器和高速缓存）\n\n    + 每个线程创建时JVM都会为其创建一个工作内存(栈空间)，工作内存是每个线程的私有数据结构\n+ 各个线程中的工作内存都存储着主内存中的变量副本拷贝 \n    + 但线程对变量的所有操作必须在工作内存中进行，而不能直接读取主内存中的数据。\n+ 不同线程不能访问其他线程的工作内存。线程间变量值的传递需要通过主内存来完成\n\n# volatile\n\n## 可见性\n\n- volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存\n- volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。\n\n## 禁止指令重排序\n\n指令重排序：从硬件架构上，指令重排序是指处理器采用了运行将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，他必须能正确处理指令依赖情况，保证能输出正确的结果。所以在同一个处理器中，重排序后的代码看起来仍然是有序的\n\n## 不保证原子性\n\ni++对应的字节码：\n\n+ getfield\n+ iconst_1\n+ iadd\n+ putfield\n\n例如一条i++ 指令，由四条字节码指令构成，当`getstatic`指令把i的值取到操作栈顶时，`volatile`关键字保证此时i的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将i的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的i值同步回主内存中\n\n## 原理\n\n有volatile修饰的变量，赋值后字节码多了个`lock addl $0x0,(%esp)`操作，相当于一个内存屏障（指重排序后不能把后面指令重排序到内存屏障之前的位置）\n\nlock作用是将本处理器的缓存写入了内存，会引起其他处理器无效化其缓存，可让前面volatile变量的修改对其他处理器立即可见\n\n`lock addl $0x0,(%esp)`把修改同步到缓存时，意味着所有之前的操作已经完成了，就形成了指令重排序无法越过内存屏障的效果\n\n# synchronized\n\n## 原理\n\n- 互斥：多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。互斥是实现同步的一种手段\n\n- 被synchronized修饰的同步块对同一个线程可重入\n\n- 被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件阻塞后面线程的进入\n\n- 即使出现异常，锁也能自动释放\n\n- synchronized关键字是块结构同步语法，经过Javac编译后，会在同步块前后形成monitorenter、monitorexit两条字节码指令。这两个字节码指令都需要一个reference类型的参数指明要锁定和解锁的对象\n\n- 如果指定了对象参数，就以该对象引用作为reference；如果没有，则以修饰的方法类型（实例方法/类方法）来选择用代码所在的对象实例/Class对象作为线程要持有的锁\n\n- 在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有了这个对象的锁，就把锁的计数器的值+1，执行monitorexit则-1。一旦计数器值为0，锁则释放。如果获取对象锁失败，则当前线程应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止\n\n- Java线程是映射到操作系统的原生内核线程上的，如果要阻塞或唤醒一个线程，需要操作系统帮忙，则需要从用户态到内核态转换。\n\n## 锁升级\n\n### MarkWord布局\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/aHR0cHM6Ly9rYW16aHV5dXFpbmcuZ2l0aHViLmlvLzIwMTkvMDIvMjcvSmF2YSVFNSVBRiVCOSVFOCVCMSVBMSVFNSVBNCVCNCVFNCVCOCU4RSVFOSU5NCU4MSVFNyU5QSU4NCVFNSU4RCU4NyVFNyVCQSVBNy9FMzg3MzdERjE5MEYzN0IwREE0N0RDNEU4NDAyMEE0Ny5qcGc)\n\n### 初始状态\n\n当我们创建一个对象LockObject时，该对象的部分Markword关键数据如下。\n\n| bit fields | 是否偏向锁 | 锁标志位 |\n| ---------- | ---------- | -------- |\n| hash       | 0          | 01       |\n\n　　偏向锁的标志位是“01”，状态是“0”，表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。\n\n### 偏向锁\n\n+ 消除数据在无竞争情况下的同步原语\n+ 这个锁会偏向于第一个获得他的线程，执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步\n+ 当锁对象第一次被线程获取的时候，虚拟机会将对象头中的标志位设置为01，把偏向模式设置为1，表示进入偏向模式；同时使用CAS操作**把获取到这个锁的线程ID记录在对象的Mark Word中**\n+ 如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁的相关同步块时，JVM都可以不再进行任何同步操作\n+ **一旦出现另一个线程去尝试获取这个锁，偏向模式就马上宣告结束**。根据锁对象目前是否处于被锁定状态决定是否撤销偏向，撤销后恢复到未锁定或轻量级锁定状态\n+ 可以提高带有同步但无竞争的程序性能，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式是多余的\n\n| bit fields |       | 是否偏向锁 | 锁标志位 |\n| ---------- | ----- | ---------- | -------- |\n| thread Id  | epoch | 1          | 01       |\n\n**锁膨胀**\n\n　　刚才说了，当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。这也是我们经常所说的**锁膨胀**\n\n**锁撤销**\n\n由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，其大概的过程如下：\n\n1. 在一个安全点停止拥有锁的线程。\n2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。\n3. 唤醒当前线程，将当前锁升级成轻量级锁。所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭\n\n**HashCode**\n\n+ 如果一个对象计算过HashCode，则应该保持该值不变\n+ 而绝大多数对象哈希码的来源Object::hashCode()返回的是对象的一致性哈希码，能强制保持不变\n+ 他通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取得的哈希码值永远不会再发生改变。\n+ 因此，当一个对象已经计算过一致性哈希码后，他就再也无法进入偏向状态\n+ 如果一个对象正处于偏向状态，又需要计算一致性哈希码，则会立刻撤销偏向状态，锁膨胀为重量级锁\n+ 在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类中有字段可以记录非加锁状态（标志位01）下的Mark Word，自然可以存储哈希码\n\n### 轻量级锁\n\n> 轻量级锁也被称为**非阻塞同步**、**乐观锁**，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。\n>\n> 也叫无锁，自旋锁，自适应自旋\n>\n> 设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗\n\n1. 线程在自己的栈桢中创建锁记录Lock Record。\n2. 将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。\n3. 将锁记录中的Owner指针指向锁对象。\n4. 将使用CAS操作把锁对象的MarkWord更新为指向锁记录的指针。\n    - 如果更新成功，则代表这个线程拥有了这个对象的锁\n    - 如果更新失败，意味着至少存在一条线程和当前线程竞争获取该对象的锁，虚拟机会首先检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有这个对象的锁，则直接进入同步块执行\n    - 否则说明这个锁对象被其他线程抢占。如果出现两条以上的线程争用同一个锁，则膨胀为重量级锁，存储指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态\n5. 解锁时，使用CAS把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来\n\n| bit fields           | 锁标志位 |\n| -------------------- | -------- |\n| 指向LockRecord的指针 | 00       |\n\n ![图片1](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165614893a59be34)\n ![图片2](https://user-gold-cdn.xitu.io/2018/8/22/165614960abf2f0e?w=549&h=343&f=png&s=35522)\n\n### 自旋锁\n\n让后面请求锁的那个线程稍等一会（执行一个忙循环），但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，以此避免**阻塞**对性能的影响（挂起线程和恢复线程的操作都需要转入**内核态**执行）\n\n自旋避免线程切换开销，但是占用处理器时间，如果占用过长时间，会白白消耗处理器资源，所以限定自旋次数，如果没有成功获取到锁，则传统方式挂起线程（**默认十次**）\n\n**自适应自旋锁**\n\n自旋时间不固定，由前一次在同一个锁上的自旋时间以及锁的拥有者状态决定\n\n如果同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在执行中，那么虚拟机认为这次自旋很有可能再次成功，进而允许自旋等待相对更长时间，例如100次忙循环\n\n相反，如果自旋很少成功获得锁，则很有可能忽略自旋过程，避免浪费处理器资源\n\n即根据程序性能监控信息，对程序锁的状况预测越来越精确\n\n### 重量级锁\n\n> 互斥锁(重量级锁)也称为**阻塞同步**、**悲观锁**\n\n轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为**互斥锁**。\n当轻量级所经过锁撤销等步骤升级为重量级锁之后，它的Markword部分数据大体如下\n\n| bit fields      | 锁标志位 |\n| --------------- | -------- |\n| 指向Mutex的指针 | 10       |\n\n**为什么说重量级锁开销大呢**\n\n主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行**阻塞**，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从**用户态**转换到**内核态**，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。\n\n# CAS\n\n+ 基于冲突检测的乐观并发策略：不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。不需要把线程阻塞挂起，非阻塞同步，无锁编程\n+ 要求操作和冲突检测这两个步骤具有原子性，需要靠硬件实现：比较并交换（Compare and Swap）\n\n## 原理\n\n需要3个操作数：内存位置（变量的内存地址 V)，旧的预期值（A)，准备设置的新值（B)。\n\n仅当V符合A时，才会用B更新V的值，否则不更新；不管是否更新V值，都会返回V的旧值\n\nCAS是原子操作，执行期间不会被其他线程中断\n\n```java\nprivate volatile int value;\n\npublic synchronized int compareAndSwap(int expectValue， int newValue) {\n        int oldValue = value;\n        if (oldValue == expectValue) {\n            value = newValue;\n        }\n        return oldValue;\n    }\n```\n\n\n\n## ABA问题\n\n其他线程修改数次最后值和原值相同\n\n可以修改版本号，添加时间戳\n\n使用原子引用类AtomicStampedReference，通过控制变量值的版本来保证CAS的正确性\n\n需要解决ABA问题，采用传统互斥同步比原子类更高效\n\n```java\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\n\n/*\n输出:\nt3 第一次版本号: 1\nt4 第一次版本号: 1\nt3 第二次版本号: 2\nt3 第三次版本号: 3\nt4 修改成功与否: false\n当前最新值:100\n */\npublic class MainTest {\n    // 初始值、版本号\n    static AtomicStampedReference<Integer> cas = new AtomicStampedReference<>(100, 1);\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            System.out.println(\"t3 第一次版本号: \" + cas.getStamp());\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            //模拟了一次ABA问题,但是因为有版本号,所以t4线程并不进行更新\n            cas.compareAndSet(100, 101, cas.getStamp(), cas.getStamp() + 1);\n            System.out.println(\"t3 第二次版本号: \" + cas.getStamp());\n            cas.compareAndSet(101, 100, cas.getStamp(), cas.getStamp() + 1);\n            System.out.println(\"t3 第三次版本号: \" + cas.getStamp());\n        }, \"t3\").start();\n\n        new Thread(() -> {\n            int stamp = cas.getStamp();\n            System.out.println(\"t4 第一次版本号: \" + stamp);\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            boolean result = cas.compareAndSet(100, 2019, stamp, stamp + 1);\n            System.out.println(\"t4 修改成功与否: \" + result);\n            System.out.println(\"当前最新值:\" + cas.getReference());\n        }, \"t4\").start();\n    }\n}\n\n```\n\n## AtomicInteger\n\nAtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功\n\n```java\nprivate static final Unsafe unsafe = Unsafe.getUnsafe();\n\npublic final int incrementAndGet()\n{\n    //this当前对象，valueOffset该值的地址偏移量\n    return unsafe.getAndAddInt(this， valueOffset， 1) + 1;\n}\n```\n\n```java\npublic final int getAndAddInt(Object var1， long var2， int var4)\n{\n    int var5;\n    do\n    {\n        var5 = this.getIntVolatile(var1， var2);\n        //因为有可能是这里被挂起，所以获取的值不是最新的\n    } while (!this.compareAndSwapInt(var1， var2， var5， var5 + var4));\n\n    return var5;\n}\n/*\nvar4是1\nvar1， var2 拼接起来得到主内存的值\nvar5相当于自己工作内存的值\n如果这两个比较相等，则将var5 + var4的值赋给(var1， var2)内存地址里，即实现了i++\n*/\n```\n\n底层:`compareAndSwapInt`是一个`native`方法\n\n跟到c++代码后，调用`lock cmpxchg 指令`，即`CAS`在硬件层面上有指令支持\n\n`cmpxchg`仅仅比较并交换，没有确保原子性，原子性是`lock`保证的\n\n`lock`指令在执行后面指令的时候锁定一个北桥信号\n\n#   线程安全\n\n## 不可变\n\n- 被final修饰不一定是不可变：基本数据类型确实是，但是对于对象类型，需要该对象保证自身被创建后，状态永远不会变才行\n- 要保证一个对象不可变，要么他里面所有成员变量都是被final修饰的基本数据类型。要么有引用类型，但是声明为了final，而且没有对该引用类型对象操作的其他函数。例如String\n\n```java\npublic final class String\n{\n    private final char value[];\n    // 除了构造函数，没有修改他的其他方法\n}\n```\n\n- final修饰类则防止被继承。例如String\n- 修饰方法则防止被重写。构造方法不允许final修饰。\n- 修饰变量则防止被修改。如果被final修饰的是对象，只是它的引用不能变，但是本身对象的值可以变\n- 现在一般是为了防止额外的同步开销，它天生是线程安全的\n\n**赋值时机**\n\n- 属性被声明为final后，该变量只能被赋值一次，且一旦被赋值，final变量就不能被改变\n- 类成员变量可以直接显示赋值、构造函数中赋值、类初始代码块中赋值\n- 方法中，final修饰的变量和非final修饰的变量要求一致：必须在使用前赋值\n\n## 栈封闭\n\n把变量写在线程内部\n\n例如在方法里新建的局部变量，实际上是存储在每个线程私有的栈空间，而每个栈的栈空间是不能被其他线程访问到的","slug":"Java语言/Java多线程/1.内存模型","published":1,"updated":"2021-06-08T03:35:00.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq50l0006z0tpa07vd078","content":"<h1 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h1><h2 id=\"对象内存布局\"><a href=\"#对象内存布局\" class=\"headerlink\" title=\"对象内存布局\"></a>对象内存布局</h2><ul>\n<li>对象头<ul>\n<li>Mark Word </li>\n<li>Class Metadata Address </li>\n<li>数组长度</li>\n</ul>\n</li>\n<li>实例数据（instance data）</li>\n<li>对齐填充（padding）</li>\n</ul>\n<h3 id=\"Mark-Word\"><a href=\"#Mark-Word\" class=\"headerlink\" title=\"Mark Word\"></a>Mark Word</h3><ul>\n<li><p>存储对象自身的运行时数据（如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等）</p>\n</li>\n<li><p>Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。</p>\n</li>\n<li><p>会根据对象的状态复用自己的存储空间</p>\n</li>\n<li><p>Mark Word记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。</p>\n</li>\n</ul>\n<h3 id=\"Class-Metadata-Address\"><a href=\"#Class-Metadata-Address\" class=\"headerlink\" title=\"Class Metadata Address\"></a>Class Metadata Address</h3><p>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。 压缩后4字节</p>\n<h3 id=\"实例数据\"><a href=\"#实例数据\" class=\"headerlink\" title=\"实例数据\"></a>实例数据</h3><ul>\n<li>存放类的属性数据信息</li>\n<li>包括父类的属性信息</li>\n<li>压缩后每个4字节</li>\n</ul>\n<h3 id=\"对齐填充\"><a href=\"#对齐填充\" class=\"headerlink\" title=\"对齐填充\"></a>对齐填充</h3><p>对象起始地址必须是8字节的整数倍</p>\n<h3 id=\"压缩指针\"><a href=\"#压缩指针\" class=\"headerlink\" title=\"压缩指针\"></a>压缩指针</h3><ul>\n<li>默认64位操作系统应该是八个字节，但是使用压缩指针<code>UseCompressedClassPointers</code>，<code>class pointer</code>只占了4字节</li>\n<li><code>UseCompressedOops</code>，使得对象指针也是压缩的</li>\n</ul>\n<h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/v2-af520d543f0f4f205f822ec3b151ad46_1440w.jpg\" style=\"zoom: 25%;\" />\n\n<ul>\n<li><p>所有变量都存储在主内存中，主内存是共享内存区域，所有线程都可以访问（对应于物理硬件内存）</p>\n</li>\n<li><p>每个线程都有自己的工作内存（优先存在寄存器和高速缓存）</p>\n<ul>\n<li>每个线程创建时JVM都会为其创建一个工作内存(栈空间)，工作内存是每个线程的私有数据结构</li>\n</ul>\n</li>\n<li><p>各个线程中的工作内存都存储着主内存中的变量副本拷贝 </p>\n<ul>\n<li>但线程对变量的所有操作必须在工作内存中进行，而不能直接读取主内存中的数据。</li>\n</ul>\n</li>\n<li><p>不同线程不能访问其他线程的工作内存。线程间变量值的传递需要通过主内存来完成</p>\n</li>\n</ul>\n<h1 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h1><h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><ul>\n<li>volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存</li>\n<li>volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>\n</ul>\n<h2 id=\"禁止指令重排序\"><a href=\"#禁止指令重排序\" class=\"headerlink\" title=\"禁止指令重排序\"></a>禁止指令重排序</h2><p>指令重排序：从硬件架构上，指令重排序是指处理器采用了运行将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，他必须能正确处理指令依赖情况，保证能输出正确的结果。所以在同一个处理器中，重排序后的代码看起来仍然是有序的</p>\n<h2 id=\"不保证原子性\"><a href=\"#不保证原子性\" class=\"headerlink\" title=\"不保证原子性\"></a>不保证原子性</h2><p>i++对应的字节码：</p>\n<ul>\n<li>getfield</li>\n<li>iconst_1</li>\n<li>iadd</li>\n<li>putfield</li>\n</ul>\n<p>例如一条i++ 指令，由四条字节码指令构成，当<code>getstatic</code>指令把i的值取到操作栈顶时，<code>volatile</code>关键字保证此时i的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将i的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的i值同步回主内存中</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>有volatile修饰的变量，赋值后字节码多了个<code>lock addl $0x0,(%esp)</code>操作，相当于一个内存屏障（指重排序后不能把后面指令重排序到内存屏障之前的位置）</p>\n<p>lock作用是将本处理器的缓存写入了内存，会引起其他处理器无效化其缓存，可让前面volatile变量的修改对其他处理器立即可见</p>\n<p><code>lock addl $0x0,(%esp)</code>把修改同步到缓存时，意味着所有之前的操作已经完成了，就形成了指令重排序无法越过内存屏障的效果</p>\n<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h1><h2 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ul>\n<li><p>互斥：多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。互斥是实现同步的一种手段</p>\n</li>\n<li><p>被synchronized修饰的同步块对同一个线程可重入</p>\n</li>\n<li><p>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件阻塞后面线程的进入</p>\n</li>\n<li><p>即使出现异常，锁也能自动释放</p>\n</li>\n<li><p>synchronized关键字是块结构同步语法，经过Javac编译后，会在同步块前后形成monitorenter、monitorexit两条字节码指令。这两个字节码指令都需要一个reference类型的参数指明要锁定和解锁的对象</p>\n</li>\n<li><p>如果指定了对象参数，就以该对象引用作为reference；如果没有，则以修饰的方法类型（实例方法/类方法）来选择用代码所在的对象实例/Class对象作为线程要持有的锁</p>\n</li>\n<li><p>在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有了这个对象的锁，就把锁的计数器的值+1，执行monitorexit则-1。一旦计数器值为0，锁则释放。如果获取对象锁失败，则当前线程应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止</p>\n</li>\n<li><p>Java线程是映射到操作系统的原生内核线程上的，如果要阻塞或唤醒一个线程，需要操作系统帮忙，则需要从用户态到内核态转换。</p>\n</li>\n</ul>\n<h2 id=\"锁升级\"><a href=\"#锁升级\" class=\"headerlink\" title=\"锁升级\"></a>锁升级</h2><h3 id=\"MarkWord布局\"><a href=\"#MarkWord布局\" class=\"headerlink\" title=\"MarkWord布局\"></a>MarkWord布局</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/aHR0cHM6Ly9rYW16aHV5dXFpbmcuZ2l0aHViLmlvLzIwMTkvMDIvMjcvSmF2YSVFNSVBRiVCOSVFOCVCMSVBMSVFNSVBNCVCNCVFNCVCOCU4RSVFOSU5NCU4MSVFNyU5QSU4NCVFNSU4RCU4NyVFNyVCQSVBNy9FMzg3MzdERjE5MEYzN0IwREE0N0RDNEU4NDAyMEE0Ny5qcGc\" alt=\"img\"></p>\n<h3 id=\"初始状态\"><a href=\"#初始状态\" class=\"headerlink\" title=\"初始状态\"></a>初始状态</h3><p>当我们创建一个对象LockObject时，该对象的部分Markword关键数据如下。</p>\n<table>\n<thead>\n<tr>\n<th>bit fields</th>\n<th>是否偏向锁</th>\n<th>锁标志位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hash</td>\n<td>0</td>\n<td>01</td>\n</tr>\n</tbody></table>\n<p>　　偏向锁的标志位是“01”，状态是“0”，表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。</p>\n<h3 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h3><ul>\n<li>消除数据在无竞争情况下的同步原语</li>\n<li>这个锁会偏向于第一个获得他的线程，执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步</li>\n<li>当锁对象第一次被线程获取的时候，虚拟机会将对象头中的标志位设置为01，把偏向模式设置为1，表示进入偏向模式；同时使用CAS操作<strong>把获取到这个锁的线程ID记录在对象的Mark Word中</strong></li>\n<li>如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁的相关同步块时，JVM都可以不再进行任何同步操作</li>\n<li><strong>一旦出现另一个线程去尝试获取这个锁，偏向模式就马上宣告结束</strong>。根据锁对象目前是否处于被锁定状态决定是否撤销偏向，撤销后恢复到未锁定或轻量级锁定状态</li>\n<li>可以提高带有同步但无竞争的程序性能，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式是多余的</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>bit fields</th>\n<th></th>\n<th>是否偏向锁</th>\n<th>锁标志位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>thread Id</td>\n<td>epoch</td>\n<td>1</td>\n<td>01</td>\n</tr>\n</tbody></table>\n<p><strong>锁膨胀</strong></p>\n<p>　　刚才说了，当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。这也是我们经常所说的<strong>锁膨胀</strong></p>\n<p><strong>锁撤销</strong></p>\n<p>由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，其大概的过程如下：</p>\n<ol>\n<li>在一个安全点停止拥有锁的线程。</li>\n<li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。</li>\n<li>唤醒当前线程，将当前锁升级成轻量级锁。所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭</li>\n</ol>\n<p><strong>HashCode</strong></p>\n<ul>\n<li>如果一个对象计算过HashCode，则应该保持该值不变</li>\n<li>而绝大多数对象哈希码的来源Object::hashCode()返回的是对象的一致性哈希码，能强制保持不变</li>\n<li>他通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取得的哈希码值永远不会再发生改变。</li>\n<li>因此，当一个对象已经计算过一致性哈希码后，他就再也无法进入偏向状态</li>\n<li>如果一个对象正处于偏向状态，又需要计算一致性哈希码，则会立刻撤销偏向状态，锁膨胀为重量级锁</li>\n<li>在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类中有字段可以记录非加锁状态（标志位01）下的Mark Word，自然可以存储哈希码</li>\n</ul>\n<h3 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h3><blockquote>\n<p>轻量级锁也被称为<strong>非阻塞同步</strong>、<strong>乐观锁</strong>，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。</p>\n<p>也叫无锁，自旋锁，自适应自旋</p>\n<p>设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗</p>\n</blockquote>\n<ol>\n<li>线程在自己的栈桢中创建锁记录Lock Record。</li>\n<li>将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。</li>\n<li>将锁记录中的Owner指针指向锁对象。</li>\n<li>将使用CAS操作把锁对象的MarkWord更新为指向锁记录的指针。<ul>\n<li>如果更新成功，则代表这个线程拥有了这个对象的锁</li>\n<li>如果更新失败，意味着至少存在一条线程和当前线程竞争获取该对象的锁，虚拟机会首先检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有这个对象的锁，则直接进入同步块执行</li>\n<li>否则说明这个锁对象被其他线程抢占。如果出现两条以上的线程争用同一个锁，则膨胀为重量级锁，存储指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态</li>\n</ul>\n</li>\n<li>解锁时，使用CAS把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>bit fields</th>\n<th>锁标志位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>指向LockRecord的指针</td>\n<td>00</td>\n</tr>\n</tbody></table>\n<p> <img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165614893a59be34\" alt=\"图片1\"><br> <img src=\"https://user-gold-cdn.xitu.io/2018/8/22/165614960abf2f0e?w=549&h=343&f=png&s=35522\" alt=\"图片2\"></p>\n<h3 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h3><p>让后面请求锁的那个线程稍等一会（执行一个忙循环），但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，以此避免<strong>阻塞</strong>对性能的影响（挂起线程和恢复线程的操作都需要转入<strong>内核态</strong>执行）</p>\n<p>自旋避免线程切换开销，但是占用处理器时间，如果占用过长时间，会白白消耗处理器资源，所以限定自旋次数，如果没有成功获取到锁，则传统方式挂起线程（<strong>默认十次</strong>）</p>\n<p><strong>自适应自旋锁</strong></p>\n<p>自旋时间不固定，由前一次在同一个锁上的自旋时间以及锁的拥有者状态决定</p>\n<p>如果同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在执行中，那么虚拟机认为这次自旋很有可能再次成功，进而允许自旋等待相对更长时间，例如100次忙循环</p>\n<p>相反，如果自旋很少成功获得锁，则很有可能忽略自旋过程，避免浪费处理器资源</p>\n<p>即根据程序性能监控信息，对程序锁的状况预测越来越精确</p>\n<h3 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h3><blockquote>\n<p>互斥锁(重量级锁)也称为<strong>阻塞同步</strong>、<strong>悲观锁</strong></p>\n</blockquote>\n<p>轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为<strong>互斥锁</strong>。<br>当轻量级所经过锁撤销等步骤升级为重量级锁之后，它的Markword部分数据大体如下</p>\n<table>\n<thead>\n<tr>\n<th>bit fields</th>\n<th>锁标志位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>指向Mutex的指针</td>\n<td>10</td>\n</tr>\n</tbody></table>\n<p><strong>为什么说重量级锁开销大呢</strong></p>\n<p>主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行<strong>阻塞</strong>，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从<strong>用户态</strong>转换到<strong>内核态</strong>，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。</p>\n<h1 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h1><ul>\n<li>基于冲突检测的乐观并发策略：不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。不需要把线程阻塞挂起，非阻塞同步，无锁编程</li>\n<li>要求操作和冲突检测这两个步骤具有原子性，需要靠硬件实现：比较并交换（Compare and Swap）</li>\n</ul>\n<h2 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>需要3个操作数：内存位置（变量的内存地址 V)，旧的预期值（A)，准备设置的新值（B)。</p>\n<p>仅当V符合A时，才会用B更新V的值，否则不更新；不管是否更新V值，都会返回V的旧值</p>\n<p>CAS是原子操作，执行期间不会被其他线程中断</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareAndSwap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> expectValue， <span class=\"token keyword\">int</span> newValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> oldValue <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldValue <span class=\"token operator\">==</span> expectValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            value <span class=\"token operator\">=</span> newValue<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> oldValue<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h2><p>其他线程修改数次最后值和原值相同</p>\n<p>可以修改版本号，添加时间戳</p>\n<p>使用原子引用类AtomicStampedReference，通过控制变量值的版本来保证CAS的正确性</p>\n<p>需要解决ABA问题，采用传统互斥同步比原子类更高效</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>atomic<span class=\"token punctuation\">.</span>AtomicStampedReference<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">/*\n输出:\nt3 第一次版本号: 1\nt4 第一次版本号: 1\nt3 第二次版本号: 2\nt3 第三次版本号: 3\nt4 修改成功与否: false\n当前最新值:100\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 初始值、版本号</span>\n    <span class=\"token keyword\">static</span> AtomicStampedReference<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> cas <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicStampedReference</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"t3 第一次版本号: \"</span> <span class=\"token operator\">+</span> cas<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//模拟了一次ABA问题,但是因为有版本号,所以t4线程并不进行更新</span>\n            cas<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">101</span><span class=\"token punctuation\">,</span> cas<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> cas<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"t3 第二次版本号: \"</span> <span class=\"token operator\">+</span> cas<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            cas<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token number\">101</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> cas<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> cas<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"t3 第三次版本号: \"</span> <span class=\"token operator\">+</span> cas<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> stamp <span class=\"token operator\">=</span> cas<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"t4 第一次版本号: \"</span> <span class=\"token operator\">+</span> stamp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">boolean</span> result <span class=\"token operator\">=</span> cas<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2019</span><span class=\"token punctuation\">,</span> stamp<span class=\"token punctuation\">,</span> stamp <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"t4 修改成功与否: \"</span> <span class=\"token operator\">+</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"当前最新值:\"</span> <span class=\"token operator\">+</span> cas<span class=\"token punctuation\">.</span><span class=\"token function\">getReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t4\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"AtomicInteger\"><a href=\"#AtomicInteger\" class=\"headerlink\" title=\"AtomicInteger\"></a>AtomicInteger</h2><p>AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Unsafe unsafe <span class=\"token operator\">=</span> Unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">getUnsafe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//this当前对象，valueOffset该值的地址偏移量</span>\n    <span class=\"token keyword\">return</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">getAndAddInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span>， valueOffset， <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAndAddInt</span><span class=\"token punctuation\">(</span>Object var1， <span class=\"token keyword\">long</span> var2， <span class=\"token keyword\">int</span> var4<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> var5<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">{</span>\n        var5 <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getIntVolatile</span><span class=\"token punctuation\">(</span>var1， var2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//因为有可能是这里被挂起，所以获取的值不是最新的</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span>var1， var2， var5， var5 <span class=\"token operator\">+</span> var4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> var5<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/*\nvar4是1\nvar1， var2 拼接起来得到主内存的值\nvar5相当于自己工作内存的值\n如果这两个比较相等，则将var5 + var4的值赋给(var1， var2)内存地址里，即实现了i++\n*/</span></code></pre>\n<p>底层:<code>compareAndSwapInt</code>是一个<code>native</code>方法</p>\n<p>跟到c++代码后，调用<code>lock cmpxchg 指令</code>，即<code>CAS</code>在硬件层面上有指令支持</p>\n<p><code>cmpxchg</code>仅仅比较并交换，没有确保原子性，原子性是<code>lock</code>保证的</p>\n<p><code>lock</code>指令在执行后面指令的时候锁定一个北桥信号</p>\n<h1 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h1><h2 id=\"不可变\"><a href=\"#不可变\" class=\"headerlink\" title=\"不可变\"></a>不可变</h2><ul>\n<li>被final修饰不一定是不可变：基本数据类型确实是，但是对于对象类型，需要该对象保证自身被创建后，状态永远不会变才行</li>\n<li>要保证一个对象不可变，要么他里面所有成员变量都是被final修饰的基本数据类型。要么有引用类型，但是声明为了final，而且没有对该引用类型对象操作的其他函数。例如String</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">String</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">char</span> value<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 除了构造函数，没有修改他的其他方法</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>final修饰类则防止被继承。例如String</li>\n<li>修饰方法则防止被重写。构造方法不允许final修饰。</li>\n<li>修饰变量则防止被修改。如果被final修饰的是对象，只是它的引用不能变，但是本身对象的值可以变</li>\n<li>现在一般是为了防止额外的同步开销，它天生是线程安全的</li>\n</ul>\n<p><strong>赋值时机</strong></p>\n<ul>\n<li>属性被声明为final后，该变量只能被赋值一次，且一旦被赋值，final变量就不能被改变</li>\n<li>类成员变量可以直接显示赋值、构造函数中赋值、类初始代码块中赋值</li>\n<li>方法中，final修饰的变量和非final修饰的变量要求一致：必须在使用前赋值</li>\n</ul>\n<h2 id=\"栈封闭\"><a href=\"#栈封闭\" class=\"headerlink\" title=\"栈封闭\"></a>栈封闭</h2><p>把变量写在线程内部</p>\n<p>例如在方法里新建的局部变量，实际上是存储在每个线程私有的栈空间，而每个栈的栈空间是不能被其他线程访问到的</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h1><h2 id=\"对象内存布局\"><a href=\"#对象内存布局\" class=\"headerlink\" title=\"对象内存布局\"></a>对象内存布局</h2><ul>\n<li>对象头<ul>\n<li>Mark Word </li>\n<li>Class Metadata Address </li>\n<li>数组长度</li>\n</ul>\n</li>\n<li>实例数据（instance data）</li>\n<li>对齐填充（padding）</li>\n</ul>\n<h3 id=\"Mark-Word\"><a href=\"#Mark-Word\" class=\"headerlink\" title=\"Mark Word\"></a>Mark Word</h3><ul>\n<li><p>存储对象自身的运行时数据（如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等）</p>\n</li>\n<li><p>Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。</p>\n</li>\n<li><p>会根据对象的状态复用自己的存储空间</p>\n</li>\n<li><p>Mark Word记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。</p>\n</li>\n</ul>\n<h3 id=\"Class-Metadata-Address\"><a href=\"#Class-Metadata-Address\" class=\"headerlink\" title=\"Class Metadata Address\"></a>Class Metadata Address</h3><p>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。 压缩后4字节</p>\n<h3 id=\"实例数据\"><a href=\"#实例数据\" class=\"headerlink\" title=\"实例数据\"></a>实例数据</h3><ul>\n<li>存放类的属性数据信息</li>\n<li>包括父类的属性信息</li>\n<li>压缩后每个4字节</li>\n</ul>\n<h3 id=\"对齐填充\"><a href=\"#对齐填充\" class=\"headerlink\" title=\"对齐填充\"></a>对齐填充</h3><p>对象起始地址必须是8字节的整数倍</p>\n<h3 id=\"压缩指针\"><a href=\"#压缩指针\" class=\"headerlink\" title=\"压缩指针\"></a>压缩指针</h3><ul>\n<li>默认64位操作系统应该是八个字节，但是使用压缩指针<code>UseCompressedClassPointers</code>，<code>class pointer</code>只占了4字节</li>\n<li><code>UseCompressedOops</code>，使得对象指针也是压缩的</li>\n</ul>\n<h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/v2-af520d543f0f4f205f822ec3b151ad46_1440w.jpg\" style=\"zoom: 25%;\" />\n\n<ul>\n<li><p>所有变量都存储在主内存中，主内存是共享内存区域，所有线程都可以访问（对应于物理硬件内存）</p>\n</li>\n<li><p>每个线程都有自己的工作内存（优先存在寄存器和高速缓存）</p>\n<ul>\n<li>每个线程创建时JVM都会为其创建一个工作内存(栈空间)，工作内存是每个线程的私有数据结构</li>\n</ul>\n</li>\n<li><p>各个线程中的工作内存都存储着主内存中的变量副本拷贝 </p>\n<ul>\n<li>但线程对变量的所有操作必须在工作内存中进行，而不能直接读取主内存中的数据。</li>\n</ul>\n</li>\n<li><p>不同线程不能访问其他线程的工作内存。线程间变量值的传递需要通过主内存来完成</p>\n</li>\n</ul>\n<h1 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h1><h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><ul>\n<li>volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存</li>\n<li>volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>\n</ul>\n<h2 id=\"禁止指令重排序\"><a href=\"#禁止指令重排序\" class=\"headerlink\" title=\"禁止指令重排序\"></a>禁止指令重排序</h2><p>指令重排序：从硬件架构上，指令重排序是指处理器采用了运行将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，他必须能正确处理指令依赖情况，保证能输出正确的结果。所以在同一个处理器中，重排序后的代码看起来仍然是有序的</p>\n<h2 id=\"不保证原子性\"><a href=\"#不保证原子性\" class=\"headerlink\" title=\"不保证原子性\"></a>不保证原子性</h2><p>i++对应的字节码：</p>\n<ul>\n<li>getfield</li>\n<li>iconst_1</li>\n<li>iadd</li>\n<li>putfield</li>\n</ul>\n<p>例如一条i++ 指令，由四条字节码指令构成，当<code>getstatic</code>指令把i的值取到操作栈顶时，<code>volatile</code>关键字保证此时i的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将i的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的i值同步回主内存中</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>有volatile修饰的变量，赋值后字节码多了个<code>lock addl $0x0,(%esp)</code>操作，相当于一个内存屏障（指重排序后不能把后面指令重排序到内存屏障之前的位置）</p>\n<p>lock作用是将本处理器的缓存写入了内存，会引起其他处理器无效化其缓存，可让前面volatile变量的修改对其他处理器立即可见</p>\n<p><code>lock addl $0x0,(%esp)</code>把修改同步到缓存时，意味着所有之前的操作已经完成了，就形成了指令重排序无法越过内存屏障的效果</p>\n<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h1><h2 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ul>\n<li><p>互斥：多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。互斥是实现同步的一种手段</p>\n</li>\n<li><p>被synchronized修饰的同步块对同一个线程可重入</p>\n</li>\n<li><p>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件阻塞后面线程的进入</p>\n</li>\n<li><p>即使出现异常，锁也能自动释放</p>\n</li>\n<li><p>synchronized关键字是块结构同步语法，经过Javac编译后，会在同步块前后形成monitorenter、monitorexit两条字节码指令。这两个字节码指令都需要一个reference类型的参数指明要锁定和解锁的对象</p>\n</li>\n<li><p>如果指定了对象参数，就以该对象引用作为reference；如果没有，则以修饰的方法类型（实例方法/类方法）来选择用代码所在的对象实例/Class对象作为线程要持有的锁</p>\n</li>\n<li><p>在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有了这个对象的锁，就把锁的计数器的值+1，执行monitorexit则-1。一旦计数器值为0，锁则释放。如果获取对象锁失败，则当前线程应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止</p>\n</li>\n<li><p>Java线程是映射到操作系统的原生内核线程上的，如果要阻塞或唤醒一个线程，需要操作系统帮忙，则需要从用户态到内核态转换。</p>\n</li>\n</ul>\n<h2 id=\"锁升级\"><a href=\"#锁升级\" class=\"headerlink\" title=\"锁升级\"></a>锁升级</h2><h3 id=\"MarkWord布局\"><a href=\"#MarkWord布局\" class=\"headerlink\" title=\"MarkWord布局\"></a>MarkWord布局</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/aHR0cHM6Ly9rYW16aHV5dXFpbmcuZ2l0aHViLmlvLzIwMTkvMDIvMjcvSmF2YSVFNSVBRiVCOSVFOCVCMSVBMSVFNSVBNCVCNCVFNCVCOCU4RSVFOSU5NCU4MSVFNyU5QSU4NCVFNSU4RCU4NyVFNyVCQSVBNy9FMzg3MzdERjE5MEYzN0IwREE0N0RDNEU4NDAyMEE0Ny5qcGc\" alt=\"img\"></p>\n<h3 id=\"初始状态\"><a href=\"#初始状态\" class=\"headerlink\" title=\"初始状态\"></a>初始状态</h3><p>当我们创建一个对象LockObject时，该对象的部分Markword关键数据如下。</p>\n<table>\n<thead>\n<tr>\n<th>bit fields</th>\n<th>是否偏向锁</th>\n<th>锁标志位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hash</td>\n<td>0</td>\n<td>01</td>\n</tr>\n</tbody></table>\n<p>　　偏向锁的标志位是“01”，状态是“0”，表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。</p>\n<h3 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h3><ul>\n<li>消除数据在无竞争情况下的同步原语</li>\n<li>这个锁会偏向于第一个获得他的线程，执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步</li>\n<li>当锁对象第一次被线程获取的时候，虚拟机会将对象头中的标志位设置为01，把偏向模式设置为1，表示进入偏向模式；同时使用CAS操作<strong>把获取到这个锁的线程ID记录在对象的Mark Word中</strong></li>\n<li>如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁的相关同步块时，JVM都可以不再进行任何同步操作</li>\n<li><strong>一旦出现另一个线程去尝试获取这个锁，偏向模式就马上宣告结束</strong>。根据锁对象目前是否处于被锁定状态决定是否撤销偏向，撤销后恢复到未锁定或轻量级锁定状态</li>\n<li>可以提高带有同步但无竞争的程序性能，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式是多余的</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>bit fields</th>\n<th></th>\n<th>是否偏向锁</th>\n<th>锁标志位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>thread Id</td>\n<td>epoch</td>\n<td>1</td>\n<td>01</td>\n</tr>\n</tbody></table>\n<p><strong>锁膨胀</strong></p>\n<p>　　刚才说了，当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。这也是我们经常所说的<strong>锁膨胀</strong></p>\n<p><strong>锁撤销</strong></p>\n<p>由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，其大概的过程如下：</p>\n<ol>\n<li>在一个安全点停止拥有锁的线程。</li>\n<li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。</li>\n<li>唤醒当前线程，将当前锁升级成轻量级锁。所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭</li>\n</ol>\n<p><strong>HashCode</strong></p>\n<ul>\n<li>如果一个对象计算过HashCode，则应该保持该值不变</li>\n<li>而绝大多数对象哈希码的来源Object::hashCode()返回的是对象的一致性哈希码，能强制保持不变</li>\n<li>他通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取得的哈希码值永远不会再发生改变。</li>\n<li>因此，当一个对象已经计算过一致性哈希码后，他就再也无法进入偏向状态</li>\n<li>如果一个对象正处于偏向状态，又需要计算一致性哈希码，则会立刻撤销偏向状态，锁膨胀为重量级锁</li>\n<li>在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类中有字段可以记录非加锁状态（标志位01）下的Mark Word，自然可以存储哈希码</li>\n</ul>\n<h3 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h3><blockquote>\n<p>轻量级锁也被称为<strong>非阻塞同步</strong>、<strong>乐观锁</strong>，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。</p>\n<p>也叫无锁，自旋锁，自适应自旋</p>\n<p>设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗</p>\n</blockquote>\n<ol>\n<li>线程在自己的栈桢中创建锁记录Lock Record。</li>\n<li>将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。</li>\n<li>将锁记录中的Owner指针指向锁对象。</li>\n<li>将使用CAS操作把锁对象的MarkWord更新为指向锁记录的指针。<ul>\n<li>如果更新成功，则代表这个线程拥有了这个对象的锁</li>\n<li>如果更新失败，意味着至少存在一条线程和当前线程竞争获取该对象的锁，虚拟机会首先检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有这个对象的锁，则直接进入同步块执行</li>\n<li>否则说明这个锁对象被其他线程抢占。如果出现两条以上的线程争用同一个锁，则膨胀为重量级锁，存储指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态</li>\n</ul>\n</li>\n<li>解锁时，使用CAS把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>bit fields</th>\n<th>锁标志位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>指向LockRecord的指针</td>\n<td>00</td>\n</tr>\n</tbody></table>\n<p> <img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165614893a59be34\" alt=\"图片1\"><br> <img src=\"https://user-gold-cdn.xitu.io/2018/8/22/165614960abf2f0e?w=549&h=343&f=png&s=35522\" alt=\"图片2\"></p>\n<h3 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h3><p>让后面请求锁的那个线程稍等一会（执行一个忙循环），但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，以此避免<strong>阻塞</strong>对性能的影响（挂起线程和恢复线程的操作都需要转入<strong>内核态</strong>执行）</p>\n<p>自旋避免线程切换开销，但是占用处理器时间，如果占用过长时间，会白白消耗处理器资源，所以限定自旋次数，如果没有成功获取到锁，则传统方式挂起线程（<strong>默认十次</strong>）</p>\n<p><strong>自适应自旋锁</strong></p>\n<p>自旋时间不固定，由前一次在同一个锁上的自旋时间以及锁的拥有者状态决定</p>\n<p>如果同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在执行中，那么虚拟机认为这次自旋很有可能再次成功，进而允许自旋等待相对更长时间，例如100次忙循环</p>\n<p>相反，如果自旋很少成功获得锁，则很有可能忽略自旋过程，避免浪费处理器资源</p>\n<p>即根据程序性能监控信息，对程序锁的状况预测越来越精确</p>\n<h3 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h3><blockquote>\n<p>互斥锁(重量级锁)也称为<strong>阻塞同步</strong>、<strong>悲观锁</strong></p>\n</blockquote>\n<p>轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为<strong>互斥锁</strong>。<br>当轻量级所经过锁撤销等步骤升级为重量级锁之后，它的Markword部分数据大体如下</p>\n<table>\n<thead>\n<tr>\n<th>bit fields</th>\n<th>锁标志位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>指向Mutex的指针</td>\n<td>10</td>\n</tr>\n</tbody></table>\n<p><strong>为什么说重量级锁开销大呢</strong></p>\n<p>主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行<strong>阻塞</strong>，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从<strong>用户态</strong>转换到<strong>内核态</strong>，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。</p>\n<h1 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h1><ul>\n<li>基于冲突检测的乐观并发策略：不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。不需要把线程阻塞挂起，非阻塞同步，无锁编程</li>\n<li>要求操作和冲突检测这两个步骤具有原子性，需要靠硬件实现：比较并交换（Compare and Swap）</li>\n</ul>\n<h2 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>需要3个操作数：内存位置（变量的内存地址 V)，旧的预期值（A)，准备设置的新值（B)。</p>\n<p>仅当V符合A时，才会用B更新V的值，否则不更新；不管是否更新V值，都会返回V的旧值</p>\n<p>CAS是原子操作，执行期间不会被其他线程中断</p>\n<pre><code class=\"java\">private volatile int value;\n\npublic synchronized int compareAndSwap(int expectValue， int newValue) {\n        int oldValue = value;\n        if (oldValue == expectValue) {\n            value = newValue;\n        }\n        return oldValue;\n    }</code></pre>\n<h2 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h2><p>其他线程修改数次最后值和原值相同</p>\n<p>可以修改版本号，添加时间戳</p>\n<p>使用原子引用类AtomicStampedReference，通过控制变量值的版本来保证CAS的正确性</p>\n<p>需要解决ABA问题，采用传统互斥同步比原子类更高效</p>\n<pre><code class=\"java\">import java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\n\n/*\n输出:\nt3 第一次版本号: 1\nt4 第一次版本号: 1\nt3 第二次版本号: 2\nt3 第三次版本号: 3\nt4 修改成功与否: false\n当前最新值:100\n */\npublic class MainTest {\n    // 初始值、版本号\n    static AtomicStampedReference&lt;Integer&gt; cas = new AtomicStampedReference&lt;&gt;(100, 1);\n\n    public static void main(String[] args) {\n        new Thread(() -&gt; {\n            System.out.println(&quot;t3 第一次版本号: &quot; + cas.getStamp());\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            //模拟了一次ABA问题,但是因为有版本号,所以t4线程并不进行更新\n            cas.compareAndSet(100, 101, cas.getStamp(), cas.getStamp() + 1);\n            System.out.println(&quot;t3 第二次版本号: &quot; + cas.getStamp());\n            cas.compareAndSet(101, 100, cas.getStamp(), cas.getStamp() + 1);\n            System.out.println(&quot;t3 第三次版本号: &quot; + cas.getStamp());\n        }, &quot;t3&quot;).start();\n\n        new Thread(() -&gt; {\n            int stamp = cas.getStamp();\n            System.out.println(&quot;t4 第一次版本号: &quot; + stamp);\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            boolean result = cas.compareAndSet(100, 2019, stamp, stamp + 1);\n            System.out.println(&quot;t4 修改成功与否: &quot; + result);\n            System.out.println(&quot;当前最新值:&quot; + cas.getReference());\n        }, &quot;t4&quot;).start();\n    }\n}\n</code></pre>\n<h2 id=\"AtomicInteger\"><a href=\"#AtomicInteger\" class=\"headerlink\" title=\"AtomicInteger\"></a>AtomicInteger</h2><p>AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功</p>\n<pre><code class=\"java\">private static final Unsafe unsafe = Unsafe.getUnsafe();\n\npublic final int incrementAndGet()\n{\n    //this当前对象，valueOffset该值的地址偏移量\n    return unsafe.getAndAddInt(this， valueOffset， 1) + 1;\n}</code></pre>\n<pre><code class=\"java\">public final int getAndAddInt(Object var1， long var2， int var4)\n{\n    int var5;\n    do\n    {\n        var5 = this.getIntVolatile(var1， var2);\n        //因为有可能是这里被挂起，所以获取的值不是最新的\n    } while (!this.compareAndSwapInt(var1， var2， var5， var5 + var4));\n\n    return var5;\n}\n/*\nvar4是1\nvar1， var2 拼接起来得到主内存的值\nvar5相当于自己工作内存的值\n如果这两个比较相等，则将var5 + var4的值赋给(var1， var2)内存地址里，即实现了i++\n*/</code></pre>\n<p>底层:<code>compareAndSwapInt</code>是一个<code>native</code>方法</p>\n<p>跟到c++代码后，调用<code>lock cmpxchg 指令</code>，即<code>CAS</code>在硬件层面上有指令支持</p>\n<p><code>cmpxchg</code>仅仅比较并交换，没有确保原子性，原子性是<code>lock</code>保证的</p>\n<p><code>lock</code>指令在执行后面指令的时候锁定一个北桥信号</p>\n<h1 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h1><h2 id=\"不可变\"><a href=\"#不可变\" class=\"headerlink\" title=\"不可变\"></a>不可变</h2><ul>\n<li>被final修饰不一定是不可变：基本数据类型确实是，但是对于对象类型，需要该对象保证自身被创建后，状态永远不会变才行</li>\n<li>要保证一个对象不可变，要么他里面所有成员变量都是被final修饰的基本数据类型。要么有引用类型，但是声明为了final，而且没有对该引用类型对象操作的其他函数。例如String</li>\n</ul>\n<pre><code class=\"java\">public final class String\n{\n    private final char value[];\n    // 除了构造函数，没有修改他的其他方法\n}</code></pre>\n<ul>\n<li>final修饰类则防止被继承。例如String</li>\n<li>修饰方法则防止被重写。构造方法不允许final修饰。</li>\n<li>修饰变量则防止被修改。如果被final修饰的是对象，只是它的引用不能变，但是本身对象的值可以变</li>\n<li>现在一般是为了防止额外的同步开销，它天生是线程安全的</li>\n</ul>\n<p><strong>赋值时机</strong></p>\n<ul>\n<li>属性被声明为final后，该变量只能被赋值一次，且一旦被赋值，final变量就不能被改变</li>\n<li>类成员变量可以直接显示赋值、构造函数中赋值、类初始代码块中赋值</li>\n<li>方法中，final修饰的变量和非final修饰的变量要求一致：必须在使用前赋值</li>\n</ul>\n<h2 id=\"栈封闭\"><a href=\"#栈封闭\" class=\"headerlink\" title=\"栈封闭\"></a>栈封闭</h2><p>把变量写在线程内部</p>\n<p>例如在方法里新建的局部变量，实际上是存储在每个线程私有的栈空间，而每个栈的栈空间是不能被其他线程访问到的</p>\n"},{"title":"锁","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习Java多线程所做的笔记，包括ReentrantLock原理、各种锁的对比、锁粗化、锁消除等。","abbrlink":"d6e0ce95","date":"2021-05-14T16:00:00.000Z","_content":"\n# ReentrantLock\n\n## 概述\n\n### 了解\n\n+ 是Lock的重入锁实现\n+ 提供无条件的、可轮询的、定时的、可中断的锁获取操作\n+ 与synchronized提供相同的互斥性和内存可见性\n+ synchronized无法中断一个正在等待获取锁的线程，或者无法在请求获取一个锁时无限的等待下去\n+ 必须在finally中释放锁\n+ tryLock方法：如果不能获得所有需要的锁，那么可以使用可定时的或可轮询的锁获取方式；它会释放已经获得的锁，然后重新尝试获取所有锁\n\n### 与Synchronized的区别\n\n+ Synchronized是关键字，是JVM层面的，使用monitorenter进入，monitorexit退出，而且保证正常于异常都会退出。Lock是JUC下的具体类，是API层面的锁\n+ Synchronized不需要手动释放锁，当代码块执行完会自动让线程释放对锁的占用，而ReentrantLock需要用户手动释放锁\n+ Synchronized不可中断，除非抛出异常或者运行结束。ReentrantLock可中断，可以通过reentrantLock.tryLock(1, TimeUnit.SECONDS);\n+ Synchronized默认非公平锁，ReentrantLock默认非公平锁，但是可以调节到公平锁\n+ ReentrantLock可以绑定多个条件Condition，用来实现分组唤醒，或者精确唤醒\n\n### 特点\n\n![image-20210608084921006](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608084921006.png)\n\n#### 限时等待\n\n**tryLock()**\n\n用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回true，否则返回false\n\n**boolean tryLock(long timeout, TimeUnit unit)**\n\n一个线程在指定的时间内没有获取锁，那就会返回false\n\n#### 等待可中断\n\n当持有锁的线程长期不释放锁时，正在等待的线程可以放弃等待，改为处理其他事情\n\n**处理死锁**\n\n在这里我们定义了两个锁lock1和lock2。然后使用两个线程thread1和thread2构造死锁场景。正常情况下，这两个线程相互等待获取资源而处于死循环状态。但是我们此时thread1中断，另外一个线程就可以获取资源，正常地执行了。\n\n```java\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Main{\n    private static final Lock lock1 = new ReentrantLock();\n    private static final Lock lock2 = new ReentrantLock();\n\n    private static void demo(Lock first, Lock second) {\n        try {\n            first.lockInterruptibly();\n            TimeUnit.MILLISECONDS.sleep(100);\n            second.lockInterruptibly();\n        } catch (Exception e) {\n        }\n        finally {\n            first.unlock();\n            second.unlock();\n            System.out.println(Thread.currentThread().getName()+\":code end\");\n        }\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -> demo(lock1, lock2), \"t1\");\n        Thread thread2 = new Thread(() -> demo(lock2, lock1), \"t2\");\n        thread1.start();\n        thread2.start();\n        TimeUnit.MILLISECONDS.sleep(200);\n        thread1.interrupt();\n    }\n}\n```\n\n#### 公平锁\n\n+ 公平锁保证多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁\n+ 而非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁\n+ synchronized是非公平锁，ReentrantLock默认非公平，可以通过构造函数设置为公平锁\n+ 使用公平锁，性能急剧下降，明显影响吞吐量\n\n#### 锁绑定多个条件\n\n+ 一个ReentrantLock对象可以绑定多个Condition对象\n+ 多次调用newCondition()即可\n+ signal()是公平的，只会唤醒等待时间最长的线程；signalAll()唤醒所有等待的线程\n\n## 原理\n\n### 结构\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608075716972.png\" alt=\"image-20210608075716972\" style=\"zoom:67%;\" />\n\n通过`Sync`重写的方法`tryAcquire`、`tryRelease`可以知道，**`ReentrantLock`实现的是`AQS`的独占模式，也就是独占锁，这个锁是悲观锁**。\n\n`ReentrantLock`有个重要的成员变量：\n\n```java\nprivate final Sync sync;\n```\n\n这个变量是用来指向`Sync`的子类的，也就是`FairSync`或者`NonfairSync`，这个也就是多态的**父类引用指向子类**，具体`Sycn`指向哪个子类，看构造方法：\n\n```java\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n\n`ReentrantLock`有两个构造方法，无参构造方法默认是创建**非公平锁**，而传入`true`为参数的构造方法创建的是**公平锁**。\n\n### 非公平锁的实现原理\n\n#### lock()\n\n![image-20210608080231479](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608080231479.png)\n\nlock方法调用CAS方法设置state的值，如果state等于期望值0(代表锁没有被占用)，那么就将state更新为1(代表该线程获取锁成功)，然后执行setExclusiveOwnerThread方法直接将该线程设置成锁的所有者。如果CAS设置state的值失败，即state不等于0，代表锁正在被占领着，则执行acquire(1)，即下面的步骤。\n\nnonfairTryAcquire方法首先调用getState方法获取state的值，如果state的值为0(之前占领锁的线程刚好释放了锁)，那么用CAS这是state的值，设置成功则将该线程设置成锁的所有者，并且返回true。如果state的值不为0，那就**调用getExclusiveOwnerThread方法查看占用锁的线程是不是自己**，如果是的话那就直接将state + 1，然后返回true。如果state不为0且锁的所有者又不是自己，那就返回false，**然后线程会进入到同步队列中**。\n\n```java\nfinal void lock() {\n    //CAS操作设置state的值\n    if (compareAndSetState(0, 1))\n        //设置成功 直接将锁的所有者设置为当前线程 流程结束\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        //设置失败 则进行后续的加入同步队列准备\n        acquire(1);\n}\n\npublic final void acquire(int arg) {\n    //调用子类重写的tryAcquire方法 如果tryAcquire方法返回false 那么线程就会进入同步队列\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\n//子类重写的tryAcquire方法\nprotected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires); // 调用nonfairTryAcquire方法\n}\n\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    //如果状态state=0，即在这段时间内 锁的所有者把锁释放了 那么这里state就为0\n    if (c == 0) {\n        //使用CAS操作设置state的值\n        if (compareAndSetState(0, acquires)) {\n            //操作成功 则将锁的所有者设置成当前线程并返回true，也就是当前线程不会进入同步队列\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //如果状态state不等于0，也就是有线程正在占用锁，那么先检查一下这个线程是不是自己\n    else if (current == getExclusiveOwnerThread()) {\n        //如果线程就是自己了，那么直接将state+1，返回true，不需要再获取锁\n        int nextc = c + acquires;\n        if (nextc < 0) // 重入次数溢出\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    //如果state不等于0，且锁的所有者又不是自己，那么线程就会进入到同步队列。\n    return false;\n}\n```\n\n#### unLock()\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608080628732.png\" alt=\"image-20210608080628732\" style=\"zoom:67%;\" />\n\n判断当前线程是不是锁的所有者，如果是则进行步骤`2`，如果不是则抛出异常。\n\n判断此次释放锁后`state`的值是否为0，如果是则代表**锁有没有重入**，然后将锁的所有者设置成`null`且返回true，然后执行步骤`3`，如果不是则**代表锁发生了重入**执行步骤`4`。\n\n现在锁已经释放完，即`state=0`，唤醒同步队列中的后继节点进行锁的获取。\n\n锁还没有释放完，即`state!=0`，不唤醒同步队列。\n\n```java\npublic void unlock() {\n    sync.release(1);\n}\n\npublic final boolean release(int arg) {\n    //子类重写的tryRelease方法，需要等锁的state=0，即tryRelease返回true的时候，才会去唤醒其\n    //它线程进行尝试获取锁。\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n    \nprotected final boolean tryRelease(int releases) {\n    //状态的state减去releases\n    int c = getState() - releases;\n    //判断锁的所有者是不是该线程\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        //如果所的所有者不是该线程 则抛出异常 也就是锁释放的前提是线程拥有这个锁，\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    //如果该线程释放锁之后 状态state=0，即锁没有重入，那么直接将将锁的所有者设置成null\n    //并且返回true，即代表可以唤醒其他线程去获取锁了。如果该线程释放锁之后state不等于0，\n    //那么代表锁重入了，返回false，代表锁还未正在释放，不用去唤醒其他线程。\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\n### 公平锁的实现原理\n\n该方法与 nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了 hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如 果该方法返回 true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线 程获取并释放锁之后才能继续获取锁。\n\n#### lock()\n\n1. 获取状态的`state`的值，如果`state=0`即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤2。如果`state!=0`则代表锁正在被其它线程占用，执行步骤3。\n2. 判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。\n3. 判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中\n\n通过步骤2实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性。\n![image-20210608081308666](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608081308666.png)\n\n```java\nfinal void lock() {\n    acquire(1);\n}\n\npublic final void acquire(int arg) {\n    //同步队列中有线程 且 锁的所有者不是当前线程那么将线程加入到同步队列的尾部，\n    //保证了公平性，也就是先来的线程先获得锁，后来的不能抢先获取。\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    //判断状态state是否等于0，等于0代表锁没有被占用，不等于0则代表锁被占用着。\n    if (c == 0) {\n        //调用hasQueuedPredecessors方法判断同步队列中是否有线程在等待，如果同步队列中没有\n        //线程在等待 则当前线程成为锁的所有者，如果同步队列中有线程在等待，则继续往下执行\n        //这个机制就是公平锁的机制，也就是先让先来的线程获取锁，后来的不能抢先获取。\n        if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //判断当前线程是否为锁的所有者，如果是，那么直接更新状态state，然后返回true。\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    //如果同步队列中有线程存在 且 锁的所有者不是当前线程，则返回false。\n    return false;\n}\n```\n\n#### unLock()\n\n公平锁的释放和非公平锁的释放一样，这里就不重复。\n公平锁和非公平锁的公平性是在**获取锁**的时候体现出来的，释放的时候都是一样释放的。\n\n### 重要方法\n\n#### lockInterruptibly可中断方式获取锁\n\n```java\npublic void lockInterruptibly() throws InterruptedException {\n    sync.acquireInterruptibly(1);\n}\n\npublic final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    //如果当前线程已经中断了，那么抛出异常\n    if (Thread.interrupted()) throw new InterruptedException();\n    //如果当前线程仍然未成功获取锁，则调用doAcquireInterruptibly方法，这个方法和\n    //acquireQueued方法没什么区别，就是线程在等待状态的过程中，如果线程被中断，线程会\n    //抛出异常。\n    if (!tryAcquire(arg)) doAcquireInterruptibly(arg);\n}\n```\n\n#### tryLock超时等待方式获取锁\n\n`ReentrantLock`除了能以能中断的方式去获取锁，还可以以超时等待的方式去获取锁，所谓超时等待就是线程如果在超时时间内没有获取到锁，那么就会返回`false`，而不是一直\"死循环\"获取。\n\n1. 判断当前节点是否已经中断，已经被中断过则抛出异常，如果没有被中断过则尝试获取锁，获取失败则调用`doAcquireNanos`方法使用超时等待的方式获取锁。\n2. 将当前节点封装成独占模式的节点加入到同步队列的队尾中。\n3. 进入到\"死循环\"中，**但是这个死循环是有个限制的，也就是当线程达到超时时间了仍未获得锁，那么就会返回`false`，结束循环**。这里调用的是`LockSupport.parkNanos`方法，在超时时间内没有被中断，那么线程会从**超时等待状态转成了就绪状态**，然后被`CPU`调度继续执行循环，**而这时候线程已经达到超时等到的时间，返回false**。\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608082234599.png\" alt=\"image-20210608082234599\" style=\"zoom:67%;\" />\n\n```java\npublic boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {\n    return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n}\n\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout) {\n    //如果当前线程已经中断了  则抛出异常\n    if (Thread.interrupted()) throw new InterruptedException();\n    //再尝试获取一次 如果不成功则调用doAcquireNanos方法进行超时等待获取锁\n    return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);\n}\n\nprivate boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {\n    if (nanosTimeout <= 0L) return false;\n    //计算超时的时间 即当前虚拟机的时间+设置的超时时间\n    final long deadline = System.nanoTime() + nanosTimeout;\n    //调用addWaiter将当前线程封装成独占模式的节点 并且加入到同步队列尾部\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            //如果当前节点的前驱节点为头结点 则让当前节点去尝试获取锁。\n            if (p == head && tryAcquire(arg)) {\n                //当前节点获取锁成功 则将当前节点设置为头结点，然后返回true。\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return true;\n            }\n            //如果当前节点的前驱节点不是头结点 或者 当前节点获取锁失败，\n            //则再次判断当前线程是否已经超时。\n            nanosTimeout = deadline - System.nanoTime();\n            if (nanosTimeout <= 0L) return false;\n            //调用shouldParkAfterFailedAcquire方法，告诉当前节点的前驱节点 我要进入\n            //等待状态了，到我了记得喊我，即做好进入等待状态前的准备。\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                nanosTimeout > spinForTimeoutThreshold)\n                //调用LockSupport.parkNanos方法，将当前线程设置成超时等待的状态。\n                LockSupport.parkNanos(this, nanosTimeout);\n            if (Thread.interrupted())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n# 锁分类\n\n## 乐观锁和悲观锁\n\n- 互斥同步锁：阻塞、唤醒带来性能劣势\n- 悲观锁适用并发写入多的情况，适用于临界区持锁时间比较长的情况，可以避免大量无用自旋等\n- 乐观锁适合并发写入少，大部分读取情况\n- 悲观锁最典型synchronized、Lock\n- 乐观锁最典型CAS、原子类、并发容器\n\n## 可重入锁和不可重入锁\n\n**可重入锁(递归锁)**\n\n+ 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码\n+ 线程可以进入任何一个他已经拥有的锁所同步着的代码块\n+ `ReentrantLock `，`Synchronized`就是经典的可重入锁\n+ 最大作用在于避免死锁\n+ 即某个线程可以再次获得一个已经由它自己持有的锁\n+ 重入的实现方式是计数（类似引用计数）：获取锁时先判断，如果当前线程就是已经占有锁的线程，则status+1\n\n```java\npublic class Main {\n    public synchronized void sendSMS() {\n        System.out.println(Thread.currentThread().getName() + \" invoke sendSMS\");\n        sendEmail();\n    }\n    public synchronized void sendEmail() {\n        System.out.println(Thread.currentThread().getName() + \" invoke sendEmail\");\n    }\n\n    public static void main(String[] args) {\n        Main main = new Main();\n        new Thread(() -> {\n            main.sendSMS();\n        }，\"t1\").start();\n    }\n}\n```\n\n## 公平和非公平锁\n\n- 公平锁：在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，按照FIFO的规则。\n\n- 非公平锁：运行加塞。是指多个线程获取锁的顺序并不是按照申请锁的顺序\n\n\n+ ReentrantLock 默认非公平锁，可以指定构造函数决定是公平锁还是非公平锁\n+ 对于Synchronized是非公平锁\n+ 例如让10个线程分别打印两次，如果是公平锁，就会0-10，0-10，而非公平锁则会每个线程都连续打印两次。原因是他没有陷入阻塞，所以更快的拿到锁\n\n```java\npublic class Main {\n    static class PrintQueue{\n        // 设置为非公平，则会一个线程打印两次，再到下一个线程；因为其他阻塞，当然执行的那个线程快\n        private Lock queueLock = new ReentrantLock(false);\n\n        public void printJob(Object document) {\n            // 模拟打印两次，正反两面\n            for (int i = 0; i < 2; i++) {\n                queueLock.lock();\n                try\n                {\n                    Long duration = (long)(Math.random() * 1000);\n                    System.out.println(Thread.currentThread().getName()+\"正在打印，需要:\"+duration);\n                    TimeUnit.MILLISECONDS.sleep(duration);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    queueLock.unlock();\n                }\n            }\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        PrintQueue printQueue = new PrintQueue();\n        Thread[] threads = new Thread[10];\n        for (int i = 0; i < 10; i++) {\n            threads[i] = new Thread(() -> {\n                printQueue.printJob(new Object());\n            });\n            threads[i].start();\n            TimeUnit.MILLISECONDS.sleep(10);\n        }\n    }\n}\n```\n\n\n\n## 共享锁和排他锁\n\n+ 独占锁(写锁)：指该锁一次只能被一个线程所持有。`ReentrantLock `，`Synchronized`就是独占锁\n+ 共享锁(读锁)：指该锁可被多个线程所共享，获得共享锁后，可以查看但是无法修改和删除数据，其他线程也还可以获取共享锁\n+ ReentrantReadWriteLock的读锁，写锁（实现读写锁ReadWriteLock接口）\n+ reentrantReadWriteLock.readLock();\n+ reentrantReadWriteLock.writeLock();\n\n    \n\n\n\n+ 读-读能共存\n+ 读-写不能共存\n+ 写-写不能共存\n\n\n\n+ 读和读互不影响，读和写互斥，写和写互斥，提高读写的效率\n+ ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。\n+ 读锁使用共享模式；写锁使用独占模式，换句话说，读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的\n+ 当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁\n+ 线程进入写锁的前提条件：没有其他线程的读锁、没有其他线程的写锁\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nclass MyCache {\n    //保证可见性\n    private volatile Map<String， Object> map = new HashMap<>();\n    //读写锁，可以在读和写时采取不同策略\n    private ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();\n    //写，读，清空\n\n    //写操作必须独占，原子 中间不允许被打断\n    public void put(String key， Object value) {\n        reentrantReadWriteLock.writeLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \" 正在写入: \" + key);\n\n            try {\n                TimeUnit.MILLISECONDS.sleep(300);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            map.put(key， value);\n            System.out.println(Thread.currentThread().getName() + \" 写入完成\");\n        }\n        finally {\n            reentrantReadWriteLock.writeLock().unlock();\n        }\n    }\n\n    public Object get(String key) {\n        reentrantReadWriteLock.readLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \" 正在读取: \" + key);\n\n            try {\n                TimeUnit.MILLISECONDS.sleep(300);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            Object object = map.get(key);\n            System.out.println(Thread.currentThread().getName() + \" 读取完成 \" + object);\n            return object;\n        }\n        finally {\n            reentrantReadWriteLock.readLock().unlock();\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyCache myCache = new MyCache();\n\n        for (int i = 0; i < 5; i++) {\n            int finalI = i;\n            new Thread(() -> {\n                myCache.put(String.valueOf(finalI)， String.valueOf(finalI));\n            }， String.valueOf(i)).start();\n        }\n        for (int i = 0; i < 5; i++) {\n            int finalI = i;\n            new Thread(() -> {\n                myCache.get(String.valueOf(finalI));\n            }， String.valueOf(i+5)).start();\n        }\n        /*\n        0 正在写入: 0\n        0 写入完成\n        1 正在写入: 1\n        1 写入完成\n        2 正在写入: 2\n        2 写入完成\n        3 正在写入: 3\n        3 写入完成\n        4 正在写入: 4\n        4 写入完成\n        5 正在读取: 0\n        6 正在读取: 1\n        7 正在读取: 2\n        8 正在读取: 3\n        9 正在读取: 4\n        9 读取完成 4\n        7 读取完成 2\n        6 读取完成 1\n        8 读取完成 3\n        5 读取完成 0\n         */\n    }\n}\n```\n\n## 自旋锁与非自旋锁\n\n+ 是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁\n+ 好处是减少线程上下文切换，缺点是锁被占用的时间很长的话，自旋的线程不断循环会白白消耗CPU资源\n+ java.util.concurrent的atmoic包下的类基本都是自旋锁的实现\n+ 实现的原理是CAS\n+ AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功\n+ AtomicReference\n\n\n\n## 可中断锁和不可中断锁\n\nReentrantLock中的lockInterruptibly()方法使得线程可以在被阻塞时响应中断，比如一个线程t1通过lockInterruptibly()方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过interrupt()方法就可以立刻打断t1线程的执行，来获取t1持有的那个可重入锁。而通过ReentrantLock的lock()方法或者Synchronized持有锁的线程是不会响应其他线程的interrupt()方法的，直到该方法主动释放锁之后才会响应interrupt()方法。\n\n当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。\n当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。\n而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。\n\n```java\n// 尝试获取锁，被中断会进入中断异常处理块中\n// 这货没有时间限制的尝试获取锁，和synchronized一样，但是，这货能相应中断\n//这是synchronized没有的优点，这使得程序在另外的线程没有释放锁时能自定义退出程序。\ntry {\n    lock.lockInterruptibly();\n} catch (InterruptedException e1) {\n    System.out.println(\"线程\"+t.getName()+\"被中断\");\n    return;\n}\n```\n\n# 锁优化\n\n## 锁消除\n\n+ 即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。\n+ 来源于逃逸分析技术的数据支持。\n+ 如果判断一段代码中堆上所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的\n+ 很多同步机制不是程序员自己加的\n+ StringBuffer.append()都有同步块，锁sb对象\n+ 虚拟机观测变量sb，经过逃逸分析后发现他的动态作用域限制在方法内部，sb的所有引用都不会逃逸到方法外部，其他线程无法访问，所以可以安全消除锁\n\n```java\npublic String concatString(String s1， String s2， String s3) {\n        return s1 + s2 + s3;\n    }\n//上面的代码在JDK5之前会转换成StringBuffer对象进行连续append\n//在JDK5之后会转换成StringBuilder对象\npublic String concatString(String s1， String s2， String s3) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(s1);\n        sb.append(s2);\n        sb.append(s3);\n        return sb.toString();\n    }\n```\n\n锁消除是发生在编译器级别的一种锁优化方式。\n有时候我们写的代码完全不需要加锁，却执行了加锁操作。\n\n比如，StringBuffer类的append操作：\n\n```java\n@Override\npublic synchronized StringBuffer append(String str) {\n    toStringCache = null;\n    super.append(str);\n    return this;\n}\n```\n\n从源码中可以看出，append方法用了synchronized关键词，它是线程安全的。但我们可能仅在线程内部把StringBuffer当作局部变量使用：\n\n```java\npackage com.leeib.thread;\n\npublic class Demo {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        int size = 10000;\n        for (int i = 0; i < size; i++) {\n            createStringBuffer(\"Hyes\", \"为分享技术而生\");\n        }\n        long timeCost = System.currentTimeMillis() - start;\n        System.out.println(\"createStringBuffer:\" + timeCost + \" ms\");\n    }\n\n    public static String createStringBuffer(String str1, String str2) {\n        StringBuffer sBuf = new StringBuffer();\n        sBuf.append(str1);// append方法是同步操作\n        sBuf.append(str2);\n        return sBuf.toString();\n    }\n}\n```\n\n代码中createStringBuffer方法中的局部对象sBuf，就只在该方法内的作用域有效，不同线程同时调用createStringBuffer()方法时，都会创建不同的sBuf对象，因此此时的append操作若是使用同步操作，就是白白浪费的系统资源。\n\n这时我们可以通过编译器将其优化，将锁消除，前提是java必须运行在server模式（server模式会比client模式作更多的优化），同时必须开启逃逸分析:\n\n-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks\n\n其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除。\n\n> 逃逸分析：比如上面的代码，它要看sBuf是否可能逃出它的作用域？如果将sBuf作为方法的返回值进行返回，那么它在方法外部可能被当作一个全局对象使用，就有可能发生线程安全问题，这时就可以说sBuf这个对象发生逃逸了，因而不应将append操作的锁消除，但我们上面的代码没有发生锁逃逸，锁消除就可以带来一定的性能提升。\n\n## 锁粗化\n\n+ 编写代码时推荐把同步块的作用访问限制得尽量小，只在共享数据的实际作用域进行同步。可以使得需要同步的操作数量尽可能变小，即使存在锁竞争，等待锁的线程也能尽快拿到锁\n+ 原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环体内部，即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗\n+ 例如上述的连续append，如果虚拟机探测到一串零碎的操作对同一个对象加锁。就将会把加锁同步的范围粗化到整个操作序列的外部。例如把操作扩展到三次append（）操作外部，只需要一次加锁\n\n\n\n通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽可能短，但是某些情况下，一个程序对同一个锁不间断、高频地请求、同步与释放，会消耗掉一定的系统资源，因为锁的请求、同步与释放本身会带来性能损耗，这样高频的锁请求就反而不利于系统性能的优化了，虽然单次同步操作的时间可能很短。**锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。**\n\n一种极端的情况如下：\n\n```java\npublic void doSomethingMethod(){\n    synchronized(lock){\n        //do some thing\n    }\n    //这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕\n    synchronized(lock){\n        //do other thing\n    }\n}\n```\n\n上面的代码是有两块需要同步操作的，但在这两块需要同步操作的代码之间，需要做一些其它的工作，而这些工作只会花费很少的时间，那么我们就可以把这些工作代码放入锁内，将两个同步代码块合并成一个，以降低多次锁请求、同步、释放带来的系统性能消耗，合并后的代码如下:\n\n```java\npublic void doSomethingMethod(){\n    //进行锁粗化：整合成一次锁请求、同步、释放\n    synchronized(lock){\n        //do some thing\n        //做其它不需要同步但能很快执行完的工作\n        //do other thing\n    }\n}\n```\n\n\n\n> 注意：这样做是有前提的，就是中间不需要同步的代码能够很快速地完成，如果不需要同步的代码需要花很长时间，就会导致同步块的执行需要花费很长的时间，这样做也就不合理了。\n\n另一种需要锁粗化的极端的情况是：\n\n```java\nfor(int i=0;i<size;i++){\n    synchronized(lock){\n    }\n}\n```\n\n上面代码每次循环都会进行锁的请求、同步与释放，看起来貌似没什么问题，且在jdk内部会对这类代码锁的请求做一些优化，但是还不如把加锁代码写在循环体的外面，这样一次锁的请求就可以达到我们的要求，除非有特殊的需要：循环需要花很长时间，但其它线程等不起，要给它们执行的机会。\n\n锁粗化后的代码如下：\n\n```java\nsynchronized(lock){\n    for(int i=0;i<size;i++){\n    }\n}\n```\n","source":"_posts/Java语言/Java多线程/3.ReentrantLock锁.md","raw":"---\ntitle: 锁\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 学习Java多线程所做的笔记，包括ReentrantLock原理、各种锁的对比、锁粗化、锁消除等。\ncategories: Java多线程\ntags:\n  - ReentrantLock\n  - 锁\n  - AQS\nabbrlink: d6e0ce95\ndate: 2021-05-15 00:00:00\n---\n\n# ReentrantLock\n\n## 概述\n\n### 了解\n\n+ 是Lock的重入锁实现\n+ 提供无条件的、可轮询的、定时的、可中断的锁获取操作\n+ 与synchronized提供相同的互斥性和内存可见性\n+ synchronized无法中断一个正在等待获取锁的线程，或者无法在请求获取一个锁时无限的等待下去\n+ 必须在finally中释放锁\n+ tryLock方法：如果不能获得所有需要的锁，那么可以使用可定时的或可轮询的锁获取方式；它会释放已经获得的锁，然后重新尝试获取所有锁\n\n### 与Synchronized的区别\n\n+ Synchronized是关键字，是JVM层面的，使用monitorenter进入，monitorexit退出，而且保证正常于异常都会退出。Lock是JUC下的具体类，是API层面的锁\n+ Synchronized不需要手动释放锁，当代码块执行完会自动让线程释放对锁的占用，而ReentrantLock需要用户手动释放锁\n+ Synchronized不可中断，除非抛出异常或者运行结束。ReentrantLock可中断，可以通过reentrantLock.tryLock(1, TimeUnit.SECONDS);\n+ Synchronized默认非公平锁，ReentrantLock默认非公平锁，但是可以调节到公平锁\n+ ReentrantLock可以绑定多个条件Condition，用来实现分组唤醒，或者精确唤醒\n\n### 特点\n\n![image-20210608084921006](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608084921006.png)\n\n#### 限时等待\n\n**tryLock()**\n\n用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回true，否则返回false\n\n**boolean tryLock(long timeout, TimeUnit unit)**\n\n一个线程在指定的时间内没有获取锁，那就会返回false\n\n#### 等待可中断\n\n当持有锁的线程长期不释放锁时，正在等待的线程可以放弃等待，改为处理其他事情\n\n**处理死锁**\n\n在这里我们定义了两个锁lock1和lock2。然后使用两个线程thread1和thread2构造死锁场景。正常情况下，这两个线程相互等待获取资源而处于死循环状态。但是我们此时thread1中断，另外一个线程就可以获取资源，正常地执行了。\n\n```java\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Main{\n    private static final Lock lock1 = new ReentrantLock();\n    private static final Lock lock2 = new ReentrantLock();\n\n    private static void demo(Lock first, Lock second) {\n        try {\n            first.lockInterruptibly();\n            TimeUnit.MILLISECONDS.sleep(100);\n            second.lockInterruptibly();\n        } catch (Exception e) {\n        }\n        finally {\n            first.unlock();\n            second.unlock();\n            System.out.println(Thread.currentThread().getName()+\":code end\");\n        }\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -> demo(lock1, lock2), \"t1\");\n        Thread thread2 = new Thread(() -> demo(lock2, lock1), \"t2\");\n        thread1.start();\n        thread2.start();\n        TimeUnit.MILLISECONDS.sleep(200);\n        thread1.interrupt();\n    }\n}\n```\n\n#### 公平锁\n\n+ 公平锁保证多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁\n+ 而非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁\n+ synchronized是非公平锁，ReentrantLock默认非公平，可以通过构造函数设置为公平锁\n+ 使用公平锁，性能急剧下降，明显影响吞吐量\n\n#### 锁绑定多个条件\n\n+ 一个ReentrantLock对象可以绑定多个Condition对象\n+ 多次调用newCondition()即可\n+ signal()是公平的，只会唤醒等待时间最长的线程；signalAll()唤醒所有等待的线程\n\n## 原理\n\n### 结构\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608075716972.png\" alt=\"image-20210608075716972\" style=\"zoom:67%;\" />\n\n通过`Sync`重写的方法`tryAcquire`、`tryRelease`可以知道，**`ReentrantLock`实现的是`AQS`的独占模式，也就是独占锁，这个锁是悲观锁**。\n\n`ReentrantLock`有个重要的成员变量：\n\n```java\nprivate final Sync sync;\n```\n\n这个变量是用来指向`Sync`的子类的，也就是`FairSync`或者`NonfairSync`，这个也就是多态的**父类引用指向子类**，具体`Sycn`指向哪个子类，看构造方法：\n\n```java\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n\n`ReentrantLock`有两个构造方法，无参构造方法默认是创建**非公平锁**，而传入`true`为参数的构造方法创建的是**公平锁**。\n\n### 非公平锁的实现原理\n\n#### lock()\n\n![image-20210608080231479](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608080231479.png)\n\nlock方法调用CAS方法设置state的值，如果state等于期望值0(代表锁没有被占用)，那么就将state更新为1(代表该线程获取锁成功)，然后执行setExclusiveOwnerThread方法直接将该线程设置成锁的所有者。如果CAS设置state的值失败，即state不等于0，代表锁正在被占领着，则执行acquire(1)，即下面的步骤。\n\nnonfairTryAcquire方法首先调用getState方法获取state的值，如果state的值为0(之前占领锁的线程刚好释放了锁)，那么用CAS这是state的值，设置成功则将该线程设置成锁的所有者，并且返回true。如果state的值不为0，那就**调用getExclusiveOwnerThread方法查看占用锁的线程是不是自己**，如果是的话那就直接将state + 1，然后返回true。如果state不为0且锁的所有者又不是自己，那就返回false，**然后线程会进入到同步队列中**。\n\n```java\nfinal void lock() {\n    //CAS操作设置state的值\n    if (compareAndSetState(0, 1))\n        //设置成功 直接将锁的所有者设置为当前线程 流程结束\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        //设置失败 则进行后续的加入同步队列准备\n        acquire(1);\n}\n\npublic final void acquire(int arg) {\n    //调用子类重写的tryAcquire方法 如果tryAcquire方法返回false 那么线程就会进入同步队列\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\n//子类重写的tryAcquire方法\nprotected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires); // 调用nonfairTryAcquire方法\n}\n\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    //如果状态state=0，即在这段时间内 锁的所有者把锁释放了 那么这里state就为0\n    if (c == 0) {\n        //使用CAS操作设置state的值\n        if (compareAndSetState(0, acquires)) {\n            //操作成功 则将锁的所有者设置成当前线程并返回true，也就是当前线程不会进入同步队列\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //如果状态state不等于0，也就是有线程正在占用锁，那么先检查一下这个线程是不是自己\n    else if (current == getExclusiveOwnerThread()) {\n        //如果线程就是自己了，那么直接将state+1，返回true，不需要再获取锁\n        int nextc = c + acquires;\n        if (nextc < 0) // 重入次数溢出\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    //如果state不等于0，且锁的所有者又不是自己，那么线程就会进入到同步队列。\n    return false;\n}\n```\n\n#### unLock()\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608080628732.png\" alt=\"image-20210608080628732\" style=\"zoom:67%;\" />\n\n判断当前线程是不是锁的所有者，如果是则进行步骤`2`，如果不是则抛出异常。\n\n判断此次释放锁后`state`的值是否为0，如果是则代表**锁有没有重入**，然后将锁的所有者设置成`null`且返回true，然后执行步骤`3`，如果不是则**代表锁发生了重入**执行步骤`4`。\n\n现在锁已经释放完，即`state=0`，唤醒同步队列中的后继节点进行锁的获取。\n\n锁还没有释放完，即`state!=0`，不唤醒同步队列。\n\n```java\npublic void unlock() {\n    sync.release(1);\n}\n\npublic final boolean release(int arg) {\n    //子类重写的tryRelease方法，需要等锁的state=0，即tryRelease返回true的时候，才会去唤醒其\n    //它线程进行尝试获取锁。\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n    \nprotected final boolean tryRelease(int releases) {\n    //状态的state减去releases\n    int c = getState() - releases;\n    //判断锁的所有者是不是该线程\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        //如果所的所有者不是该线程 则抛出异常 也就是锁释放的前提是线程拥有这个锁，\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    //如果该线程释放锁之后 状态state=0，即锁没有重入，那么直接将将锁的所有者设置成null\n    //并且返回true，即代表可以唤醒其他线程去获取锁了。如果该线程释放锁之后state不等于0，\n    //那么代表锁重入了，返回false，代表锁还未正在释放，不用去唤醒其他线程。\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\n### 公平锁的实现原理\n\n该方法与 nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了 hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如 果该方法返回 true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线 程获取并释放锁之后才能继续获取锁。\n\n#### lock()\n\n1. 获取状态的`state`的值，如果`state=0`即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤2。如果`state!=0`则代表锁正在被其它线程占用，执行步骤3。\n2. 判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。\n3. 判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中\n\n通过步骤2实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性。\n![image-20210608081308666](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608081308666.png)\n\n```java\nfinal void lock() {\n    acquire(1);\n}\n\npublic final void acquire(int arg) {\n    //同步队列中有线程 且 锁的所有者不是当前线程那么将线程加入到同步队列的尾部，\n    //保证了公平性，也就是先来的线程先获得锁，后来的不能抢先获取。\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    //判断状态state是否等于0，等于0代表锁没有被占用，不等于0则代表锁被占用着。\n    if (c == 0) {\n        //调用hasQueuedPredecessors方法判断同步队列中是否有线程在等待，如果同步队列中没有\n        //线程在等待 则当前线程成为锁的所有者，如果同步队列中有线程在等待，则继续往下执行\n        //这个机制就是公平锁的机制，也就是先让先来的线程获取锁，后来的不能抢先获取。\n        if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //判断当前线程是否为锁的所有者，如果是，那么直接更新状态state，然后返回true。\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    //如果同步队列中有线程存在 且 锁的所有者不是当前线程，则返回false。\n    return false;\n}\n```\n\n#### unLock()\n\n公平锁的释放和非公平锁的释放一样，这里就不重复。\n公平锁和非公平锁的公平性是在**获取锁**的时候体现出来的，释放的时候都是一样释放的。\n\n### 重要方法\n\n#### lockInterruptibly可中断方式获取锁\n\n```java\npublic void lockInterruptibly() throws InterruptedException {\n    sync.acquireInterruptibly(1);\n}\n\npublic final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    //如果当前线程已经中断了，那么抛出异常\n    if (Thread.interrupted()) throw new InterruptedException();\n    //如果当前线程仍然未成功获取锁，则调用doAcquireInterruptibly方法，这个方法和\n    //acquireQueued方法没什么区别，就是线程在等待状态的过程中，如果线程被中断，线程会\n    //抛出异常。\n    if (!tryAcquire(arg)) doAcquireInterruptibly(arg);\n}\n```\n\n#### tryLock超时等待方式获取锁\n\n`ReentrantLock`除了能以能中断的方式去获取锁，还可以以超时等待的方式去获取锁，所谓超时等待就是线程如果在超时时间内没有获取到锁，那么就会返回`false`，而不是一直\"死循环\"获取。\n\n1. 判断当前节点是否已经中断，已经被中断过则抛出异常，如果没有被中断过则尝试获取锁，获取失败则调用`doAcquireNanos`方法使用超时等待的方式获取锁。\n2. 将当前节点封装成独占模式的节点加入到同步队列的队尾中。\n3. 进入到\"死循环\"中，**但是这个死循环是有个限制的，也就是当线程达到超时时间了仍未获得锁，那么就会返回`false`，结束循环**。这里调用的是`LockSupport.parkNanos`方法，在超时时间内没有被中断，那么线程会从**超时等待状态转成了就绪状态**，然后被`CPU`调度继续执行循环，**而这时候线程已经达到超时等到的时间，返回false**。\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608082234599.png\" alt=\"image-20210608082234599\" style=\"zoom:67%;\" />\n\n```java\npublic boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {\n    return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n}\n\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout) {\n    //如果当前线程已经中断了  则抛出异常\n    if (Thread.interrupted()) throw new InterruptedException();\n    //再尝试获取一次 如果不成功则调用doAcquireNanos方法进行超时等待获取锁\n    return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);\n}\n\nprivate boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {\n    if (nanosTimeout <= 0L) return false;\n    //计算超时的时间 即当前虚拟机的时间+设置的超时时间\n    final long deadline = System.nanoTime() + nanosTimeout;\n    //调用addWaiter将当前线程封装成独占模式的节点 并且加入到同步队列尾部\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            //如果当前节点的前驱节点为头结点 则让当前节点去尝试获取锁。\n            if (p == head && tryAcquire(arg)) {\n                //当前节点获取锁成功 则将当前节点设置为头结点，然后返回true。\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return true;\n            }\n            //如果当前节点的前驱节点不是头结点 或者 当前节点获取锁失败，\n            //则再次判断当前线程是否已经超时。\n            nanosTimeout = deadline - System.nanoTime();\n            if (nanosTimeout <= 0L) return false;\n            //调用shouldParkAfterFailedAcquire方法，告诉当前节点的前驱节点 我要进入\n            //等待状态了，到我了记得喊我，即做好进入等待状态前的准备。\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                nanosTimeout > spinForTimeoutThreshold)\n                //调用LockSupport.parkNanos方法，将当前线程设置成超时等待的状态。\n                LockSupport.parkNanos(this, nanosTimeout);\n            if (Thread.interrupted())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n# 锁分类\n\n## 乐观锁和悲观锁\n\n- 互斥同步锁：阻塞、唤醒带来性能劣势\n- 悲观锁适用并发写入多的情况，适用于临界区持锁时间比较长的情况，可以避免大量无用自旋等\n- 乐观锁适合并发写入少，大部分读取情况\n- 悲观锁最典型synchronized、Lock\n- 乐观锁最典型CAS、原子类、并发容器\n\n## 可重入锁和不可重入锁\n\n**可重入锁(递归锁)**\n\n+ 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码\n+ 线程可以进入任何一个他已经拥有的锁所同步着的代码块\n+ `ReentrantLock `，`Synchronized`就是经典的可重入锁\n+ 最大作用在于避免死锁\n+ 即某个线程可以再次获得一个已经由它自己持有的锁\n+ 重入的实现方式是计数（类似引用计数）：获取锁时先判断，如果当前线程就是已经占有锁的线程，则status+1\n\n```java\npublic class Main {\n    public synchronized void sendSMS() {\n        System.out.println(Thread.currentThread().getName() + \" invoke sendSMS\");\n        sendEmail();\n    }\n    public synchronized void sendEmail() {\n        System.out.println(Thread.currentThread().getName() + \" invoke sendEmail\");\n    }\n\n    public static void main(String[] args) {\n        Main main = new Main();\n        new Thread(() -> {\n            main.sendSMS();\n        }，\"t1\").start();\n    }\n}\n```\n\n## 公平和非公平锁\n\n- 公平锁：在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，按照FIFO的规则。\n\n- 非公平锁：运行加塞。是指多个线程获取锁的顺序并不是按照申请锁的顺序\n\n\n+ ReentrantLock 默认非公平锁，可以指定构造函数决定是公平锁还是非公平锁\n+ 对于Synchronized是非公平锁\n+ 例如让10个线程分别打印两次，如果是公平锁，就会0-10，0-10，而非公平锁则会每个线程都连续打印两次。原因是他没有陷入阻塞，所以更快的拿到锁\n\n```java\npublic class Main {\n    static class PrintQueue{\n        // 设置为非公平，则会一个线程打印两次，再到下一个线程；因为其他阻塞，当然执行的那个线程快\n        private Lock queueLock = new ReentrantLock(false);\n\n        public void printJob(Object document) {\n            // 模拟打印两次，正反两面\n            for (int i = 0; i < 2; i++) {\n                queueLock.lock();\n                try\n                {\n                    Long duration = (long)(Math.random() * 1000);\n                    System.out.println(Thread.currentThread().getName()+\"正在打印，需要:\"+duration);\n                    TimeUnit.MILLISECONDS.sleep(duration);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    queueLock.unlock();\n                }\n            }\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        PrintQueue printQueue = new PrintQueue();\n        Thread[] threads = new Thread[10];\n        for (int i = 0; i < 10; i++) {\n            threads[i] = new Thread(() -> {\n                printQueue.printJob(new Object());\n            });\n            threads[i].start();\n            TimeUnit.MILLISECONDS.sleep(10);\n        }\n    }\n}\n```\n\n\n\n## 共享锁和排他锁\n\n+ 独占锁(写锁)：指该锁一次只能被一个线程所持有。`ReentrantLock `，`Synchronized`就是独占锁\n+ 共享锁(读锁)：指该锁可被多个线程所共享，获得共享锁后，可以查看但是无法修改和删除数据，其他线程也还可以获取共享锁\n+ ReentrantReadWriteLock的读锁，写锁（实现读写锁ReadWriteLock接口）\n+ reentrantReadWriteLock.readLock();\n+ reentrantReadWriteLock.writeLock();\n\n    \n\n\n\n+ 读-读能共存\n+ 读-写不能共存\n+ 写-写不能共存\n\n\n\n+ 读和读互不影响，读和写互斥，写和写互斥，提高读写的效率\n+ ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。\n+ 读锁使用共享模式；写锁使用独占模式，换句话说，读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的\n+ 当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁\n+ 线程进入写锁的前提条件：没有其他线程的读锁、没有其他线程的写锁\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nclass MyCache {\n    //保证可见性\n    private volatile Map<String， Object> map = new HashMap<>();\n    //读写锁，可以在读和写时采取不同策略\n    private ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();\n    //写，读，清空\n\n    //写操作必须独占，原子 中间不允许被打断\n    public void put(String key， Object value) {\n        reentrantReadWriteLock.writeLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \" 正在写入: \" + key);\n\n            try {\n                TimeUnit.MILLISECONDS.sleep(300);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            map.put(key， value);\n            System.out.println(Thread.currentThread().getName() + \" 写入完成\");\n        }\n        finally {\n            reentrantReadWriteLock.writeLock().unlock();\n        }\n    }\n\n    public Object get(String key) {\n        reentrantReadWriteLock.readLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \" 正在读取: \" + key);\n\n            try {\n                TimeUnit.MILLISECONDS.sleep(300);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            Object object = map.get(key);\n            System.out.println(Thread.currentThread().getName() + \" 读取完成 \" + object);\n            return object;\n        }\n        finally {\n            reentrantReadWriteLock.readLock().unlock();\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyCache myCache = new MyCache();\n\n        for (int i = 0; i < 5; i++) {\n            int finalI = i;\n            new Thread(() -> {\n                myCache.put(String.valueOf(finalI)， String.valueOf(finalI));\n            }， String.valueOf(i)).start();\n        }\n        for (int i = 0; i < 5; i++) {\n            int finalI = i;\n            new Thread(() -> {\n                myCache.get(String.valueOf(finalI));\n            }， String.valueOf(i+5)).start();\n        }\n        /*\n        0 正在写入: 0\n        0 写入完成\n        1 正在写入: 1\n        1 写入完成\n        2 正在写入: 2\n        2 写入完成\n        3 正在写入: 3\n        3 写入完成\n        4 正在写入: 4\n        4 写入完成\n        5 正在读取: 0\n        6 正在读取: 1\n        7 正在读取: 2\n        8 正在读取: 3\n        9 正在读取: 4\n        9 读取完成 4\n        7 读取完成 2\n        6 读取完成 1\n        8 读取完成 3\n        5 读取完成 0\n         */\n    }\n}\n```\n\n## 自旋锁与非自旋锁\n\n+ 是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁\n+ 好处是减少线程上下文切换，缺点是锁被占用的时间很长的话，自旋的线程不断循环会白白消耗CPU资源\n+ java.util.concurrent的atmoic包下的类基本都是自旋锁的实现\n+ 实现的原理是CAS\n+ AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功\n+ AtomicReference\n\n\n\n## 可中断锁和不可中断锁\n\nReentrantLock中的lockInterruptibly()方法使得线程可以在被阻塞时响应中断，比如一个线程t1通过lockInterruptibly()方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过interrupt()方法就可以立刻打断t1线程的执行，来获取t1持有的那个可重入锁。而通过ReentrantLock的lock()方法或者Synchronized持有锁的线程是不会响应其他线程的interrupt()方法的，直到该方法主动释放锁之后才会响应interrupt()方法。\n\n当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。\n当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。\n而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。\n\n```java\n// 尝试获取锁，被中断会进入中断异常处理块中\n// 这货没有时间限制的尝试获取锁，和synchronized一样，但是，这货能相应中断\n//这是synchronized没有的优点，这使得程序在另外的线程没有释放锁时能自定义退出程序。\ntry {\n    lock.lockInterruptibly();\n} catch (InterruptedException e1) {\n    System.out.println(\"线程\"+t.getName()+\"被中断\");\n    return;\n}\n```\n\n# 锁优化\n\n## 锁消除\n\n+ 即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。\n+ 来源于逃逸分析技术的数据支持。\n+ 如果判断一段代码中堆上所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的\n+ 很多同步机制不是程序员自己加的\n+ StringBuffer.append()都有同步块，锁sb对象\n+ 虚拟机观测变量sb，经过逃逸分析后发现他的动态作用域限制在方法内部，sb的所有引用都不会逃逸到方法外部，其他线程无法访问，所以可以安全消除锁\n\n```java\npublic String concatString(String s1， String s2， String s3) {\n        return s1 + s2 + s3;\n    }\n//上面的代码在JDK5之前会转换成StringBuffer对象进行连续append\n//在JDK5之后会转换成StringBuilder对象\npublic String concatString(String s1， String s2， String s3) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(s1);\n        sb.append(s2);\n        sb.append(s3);\n        return sb.toString();\n    }\n```\n\n锁消除是发生在编译器级别的一种锁优化方式。\n有时候我们写的代码完全不需要加锁，却执行了加锁操作。\n\n比如，StringBuffer类的append操作：\n\n```java\n@Override\npublic synchronized StringBuffer append(String str) {\n    toStringCache = null;\n    super.append(str);\n    return this;\n}\n```\n\n从源码中可以看出，append方法用了synchronized关键词，它是线程安全的。但我们可能仅在线程内部把StringBuffer当作局部变量使用：\n\n```java\npackage com.leeib.thread;\n\npublic class Demo {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        int size = 10000;\n        for (int i = 0; i < size; i++) {\n            createStringBuffer(\"Hyes\", \"为分享技术而生\");\n        }\n        long timeCost = System.currentTimeMillis() - start;\n        System.out.println(\"createStringBuffer:\" + timeCost + \" ms\");\n    }\n\n    public static String createStringBuffer(String str1, String str2) {\n        StringBuffer sBuf = new StringBuffer();\n        sBuf.append(str1);// append方法是同步操作\n        sBuf.append(str2);\n        return sBuf.toString();\n    }\n}\n```\n\n代码中createStringBuffer方法中的局部对象sBuf，就只在该方法内的作用域有效，不同线程同时调用createStringBuffer()方法时，都会创建不同的sBuf对象，因此此时的append操作若是使用同步操作，就是白白浪费的系统资源。\n\n这时我们可以通过编译器将其优化，将锁消除，前提是java必须运行在server模式（server模式会比client模式作更多的优化），同时必须开启逃逸分析:\n\n-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks\n\n其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除。\n\n> 逃逸分析：比如上面的代码，它要看sBuf是否可能逃出它的作用域？如果将sBuf作为方法的返回值进行返回，那么它在方法外部可能被当作一个全局对象使用，就有可能发生线程安全问题，这时就可以说sBuf这个对象发生逃逸了，因而不应将append操作的锁消除，但我们上面的代码没有发生锁逃逸，锁消除就可以带来一定的性能提升。\n\n## 锁粗化\n\n+ 编写代码时推荐把同步块的作用访问限制得尽量小，只在共享数据的实际作用域进行同步。可以使得需要同步的操作数量尽可能变小，即使存在锁竞争，等待锁的线程也能尽快拿到锁\n+ 原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环体内部，即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗\n+ 例如上述的连续append，如果虚拟机探测到一串零碎的操作对同一个对象加锁。就将会把加锁同步的范围粗化到整个操作序列的外部。例如把操作扩展到三次append（）操作外部，只需要一次加锁\n\n\n\n通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽可能短，但是某些情况下，一个程序对同一个锁不间断、高频地请求、同步与释放，会消耗掉一定的系统资源，因为锁的请求、同步与释放本身会带来性能损耗，这样高频的锁请求就反而不利于系统性能的优化了，虽然单次同步操作的时间可能很短。**锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。**\n\n一种极端的情况如下：\n\n```java\npublic void doSomethingMethod(){\n    synchronized(lock){\n        //do some thing\n    }\n    //这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕\n    synchronized(lock){\n        //do other thing\n    }\n}\n```\n\n上面的代码是有两块需要同步操作的，但在这两块需要同步操作的代码之间，需要做一些其它的工作，而这些工作只会花费很少的时间，那么我们就可以把这些工作代码放入锁内，将两个同步代码块合并成一个，以降低多次锁请求、同步、释放带来的系统性能消耗，合并后的代码如下:\n\n```java\npublic void doSomethingMethod(){\n    //进行锁粗化：整合成一次锁请求、同步、释放\n    synchronized(lock){\n        //do some thing\n        //做其它不需要同步但能很快执行完的工作\n        //do other thing\n    }\n}\n```\n\n\n\n> 注意：这样做是有前提的，就是中间不需要同步的代码能够很快速地完成，如果不需要同步的代码需要花很长时间，就会导致同步块的执行需要花费很长的时间，这样做也就不合理了。\n\n另一种需要锁粗化的极端的情况是：\n\n```java\nfor(int i=0;i<size;i++){\n    synchronized(lock){\n    }\n}\n```\n\n上面代码每次循环都会进行锁的请求、同步与释放，看起来貌似没什么问题，且在jdk内部会对这类代码锁的请求做一些优化，但是还不如把加锁代码写在循环体的外面，这样一次锁的请求就可以达到我们的要求，除非有特殊的需要：循环需要花很长时间，但其它线程等不起，要给它们执行的机会。\n\n锁粗化后的代码如下：\n\n```java\nsynchronized(lock){\n    for(int i=0;i<size;i++){\n    }\n}\n```\n","slug":"Java语言/Java多线程/3.ReentrantLock锁","published":1,"updated":"2021-06-08T03:35:00.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq50o0007z0tpcb8eafjh","content":"<h1 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"了解\"><a href=\"#了解\" class=\"headerlink\" title=\"了解\"></a>了解</h3><ul>\n<li>是Lock的重入锁实现</li>\n<li>提供无条件的、可轮询的、定时的、可中断的锁获取操作</li>\n<li>与synchronized提供相同的互斥性和内存可见性</li>\n<li>synchronized无法中断一个正在等待获取锁的线程，或者无法在请求获取一个锁时无限的等待下去</li>\n<li>必须在finally中释放锁</li>\n<li>tryLock方法：如果不能获得所有需要的锁，那么可以使用可定时的或可轮询的锁获取方式；它会释放已经获得的锁，然后重新尝试获取所有锁</li>\n</ul>\n<h3 id=\"与Synchronized的区别\"><a href=\"#与Synchronized的区别\" class=\"headerlink\" title=\"与Synchronized的区别\"></a>与Synchronized的区别</h3><ul>\n<li>Synchronized是关键字，是JVM层面的，使用monitorenter进入，monitorexit退出，而且保证正常于异常都会退出。Lock是JUC下的具体类，是API层面的锁</li>\n<li>Synchronized不需要手动释放锁，当代码块执行完会自动让线程释放对锁的占用，而ReentrantLock需要用户手动释放锁</li>\n<li>Synchronized不可中断，除非抛出异常或者运行结束。ReentrantLock可中断，可以通过reentrantLock.tryLock(1, TimeUnit.SECONDS);</li>\n<li>Synchronized默认非公平锁，ReentrantLock默认非公平锁，但是可以调节到公平锁</li>\n<li>ReentrantLock可以绑定多个条件Condition，用来实现分组唤醒，或者精确唤醒</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608084921006.png\" alt=\"image-20210608084921006\"></p>\n<h4 id=\"限时等待\"><a href=\"#限时等待\" class=\"headerlink\" title=\"限时等待\"></a>限时等待</h4><p><strong>tryLock()</strong></p>\n<p>用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回true，否则返回false</p>\n<p><strong>boolean tryLock(long timeout, TimeUnit unit)</strong></p>\n<p>一个线程在指定的时间内没有获取锁，那就会返回false</p>\n<h4 id=\"等待可中断\"><a href=\"#等待可中断\" class=\"headerlink\" title=\"等待可中断\"></a>等待可中断</h4><p>当持有锁的线程长期不释放锁时，正在等待的线程可以放弃等待，改为处理其他事情</p>\n<p><strong>处理死锁</strong></p>\n<p>在这里我们定义了两个锁lock1和lock2。然后使用两个线程thread1和thread2构造死锁场景。正常情况下，这两个线程相互等待获取资源而处于死循环状态。但是我们此时thread1中断，另外一个线程就可以获取资源，正常地执行了。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>locks<span class=\"token punctuation\">.</span>Lock<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>locks<span class=\"token punctuation\">.</span>ReentrantLock<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Lock lock1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Lock lock2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">demo</span><span class=\"token punctuation\">(</span>Lock first<span class=\"token punctuation\">,</span> Lock second<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            first<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            second<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            first<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            second<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\":code end\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        Thread thread1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token function\">demo</span><span class=\"token punctuation\">(</span>lock1<span class=\"token punctuation\">,</span> lock2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Thread thread2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token function\">demo</span><span class=\"token punctuation\">(</span>lock2<span class=\"token punctuation\">,</span> lock1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread1<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h4><ul>\n<li>公平锁保证多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</li>\n<li>而非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁</li>\n<li>synchronized是非公平锁，ReentrantLock默认非公平，可以通过构造函数设置为公平锁</li>\n<li>使用公平锁，性能急剧下降，明显影响吞吐量</li>\n</ul>\n<h4 id=\"锁绑定多个条件\"><a href=\"#锁绑定多个条件\" class=\"headerlink\" title=\"锁绑定多个条件\"></a>锁绑定多个条件</h4><ul>\n<li>一个ReentrantLock对象可以绑定多个Condition对象</li>\n<li>多次调用newCondition()即可</li>\n<li>signal()是公平的，只会唤醒等待时间最长的线程；signalAll()唤醒所有等待的线程</li>\n</ul>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608075716972.png\" alt=\"image-20210608075716972\" style=\"zoom:67%;\" />\n\n<p>通过<code>Sync</code>重写的方法<code>tryAcquire</code>、<code>tryRelease</code>可以知道，**<code>ReentrantLock</code>实现的是<code>AQS</code>的独占模式，也就是独占锁，这个锁是悲观锁**。</p>\n<p><code>ReentrantLock</code>有个重要的成员变量：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Sync sync<span class=\"token punctuation\">;</span></code></pre>\n<p>这个变量是用来指向<code>Sync</code>的子类的，也就是<code>FairSync</code>或者<code>NonfairSync</code>，这个也就是多态的<strong>父类引用指向子类</strong>，具体<code>Sycn</code>指向哪个子类，看构造方法：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    sync <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NonfairSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token function\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> fair<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    sync <span class=\"token operator\">=</span> fair <span class=\"token operator\">?</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FairSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NonfairSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>ReentrantLock</code>有两个构造方法，无参构造方法默认是创建<strong>非公平锁</strong>，而传入<code>true</code>为参数的构造方法创建的是<strong>公平锁</strong>。</p>\n<h3 id=\"非公平锁的实现原理\"><a href=\"#非公平锁的实现原理\" class=\"headerlink\" title=\"非公平锁的实现原理\"></a>非公平锁的实现原理</h3><h4 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock()\"></a>lock()</h4><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608080231479.png\" alt=\"image-20210608080231479\"></p>\n<p>lock方法调用CAS方法设置state的值，如果state等于期望值0(代表锁没有被占用)，那么就将state更新为1(代表该线程获取锁成功)，然后执行setExclusiveOwnerThread方法直接将该线程设置成锁的所有者。如果CAS设置state的值失败，即state不等于0，代表锁正在被占领着，则执行acquire(1)，即下面的步骤。</p>\n<p>nonfairTryAcquire方法首先调用getState方法获取state的值，如果state的值为0(之前占领锁的线程刚好释放了锁)，那么用CAS这是state的值，设置成功则将该线程设置成锁的所有者，并且返回true。如果state的值不为0，那就<strong>调用getExclusiveOwnerThread方法查看占用锁的线程是不是自己</strong>，如果是的话那就直接将state + 1，然后返回true。如果state不为0且锁的所有者又不是自己，那就返回false，<strong>然后线程会进入到同步队列中</strong>。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//CAS操作设置state的值</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">//设置成功 直接将锁的所有者设置为当前线程 流程结束</span>\n        <span class=\"token function\">setExclusiveOwnerThread</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token comment\" spellcheck=\"true\">//设置失败 则进行后续的加入同步队列准备</span>\n        <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//调用子类重写的tryAcquire方法 如果tryAcquire方法返回false 那么线程就会进入同步队列</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">acquireQueued</span><span class=\"token punctuation\">(</span><span class=\"token function\">addWaiter</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">.</span>EXCLUSIVE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">selfInterrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//子类重写的tryAcquire方法</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> acquires<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">nonfairTryAcquire</span><span class=\"token punctuation\">(</span>acquires<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 调用nonfairTryAcquire方法</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">nonfairTryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> acquires<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> Thread current <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果状态state=0，即在这段时间内 锁的所有者把锁释放了 那么这里state就为0</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//使用CAS操作设置state的值</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> acquires<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//操作成功 则将锁的所有者设置成当前线程并返回true，也就是当前线程不会进入同步队列</span>\n            <span class=\"token function\">setExclusiveOwnerThread</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果状态state不等于0，也就是有线程正在占用锁，那么先检查一下这个线程是不是自己</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">==</span> <span class=\"token function\">getExclusiveOwnerThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果线程就是自己了，那么直接将state+1，返回true，不需要再获取锁</span>\n        <span class=\"token keyword\">int</span> nextc <span class=\"token operator\">=</span> c <span class=\"token operator\">+</span> acquires<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextc <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 重入次数溢出</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Maximum lock count exceeded\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>nextc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果state不等于0，且锁的所有者又不是自己，那么线程就会进入到同步队列。</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"unLock\"><a href=\"#unLock\" class=\"headerlink\" title=\"unLock()\"></a>unLock()</h4><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608080628732.png\" alt=\"image-20210608080628732\" style=\"zoom:67%;\" />\n\n<p>判断当前线程是不是锁的所有者，如果是则进行步骤<code>2</code>，如果不是则抛出异常。</p>\n<p>判断此次释放锁后<code>state</code>的值是否为0，如果是则代表<strong>锁有没有重入</strong>，然后将锁的所有者设置成<code>null</code>且返回true，然后执行步骤<code>3</code>，如果不是则<strong>代表锁发生了重入</strong>执行步骤<code>4</code>。</p>\n<p>现在锁已经释放完，即<code>state=0</code>，唤醒同步队列中的后继节点进行锁的获取。</p>\n<p>锁还没有释放完，即<code>state!=0</code>，不唤醒同步队列。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    sync<span class=\"token punctuation\">.</span><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//子类重写的tryRelease方法，需要等锁的state=0，即tryRelease返回true的时候，才会去唤醒其</span>\n    <span class=\"token comment\" spellcheck=\"true\">//它线程进行尝试获取锁。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tryRelease</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Node h <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> h<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">unparkSuccessor</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryRelease</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> releases<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//状态的state减去releases</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> releases<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//判断锁的所有者是不是该线程</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token function\">getExclusiveOwnerThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果所的所有者不是该线程 则抛出异常 也就是锁释放的前提是线程拥有这个锁，</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalMonitorStateException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span> free <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果该线程释放锁之后 状态state=0，即锁没有重入，那么直接将将锁的所有者设置成null</span>\n    <span class=\"token comment\" spellcheck=\"true\">//并且返回true，即代表可以唤醒其他线程去获取锁了。如果该线程释放锁之后state不等于0，</span>\n    <span class=\"token comment\" spellcheck=\"true\">//那么代表锁重入了，返回false，代表锁还未正在释放，不用去唤醒其他线程。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        free <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setExclusiveOwnerThread</span><span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> free<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"公平锁的实现原理\"><a href=\"#公平锁的实现原理\" class=\"headerlink\" title=\"公平锁的实现原理\"></a>公平锁的实现原理</h3><p>该方法与 nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了 hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如 果该方法返回 true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线 程获取并释放锁之后才能继续获取锁。</p>\n<h4 id=\"lock-1\"><a href=\"#lock-1\" class=\"headerlink\" title=\"lock()\"></a>lock()</h4><ol>\n<li>获取状态的<code>state</code>的值，如果<code>state=0</code>即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤2。如果<code>state!=0</code>则代表锁正在被其它线程占用，执行步骤3。</li>\n<li>判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。</li>\n<li>判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中</li>\n</ol>\n<p>通过步骤2实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性。<br><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608081308666.png\" alt=\"image-20210608081308666\"></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//同步队列中有线程 且 锁的所有者不是当前线程那么将线程加入到同步队列的尾部，</span>\n    <span class=\"token comment\" spellcheck=\"true\">//保证了公平性，也就是先来的线程先获得锁，后来的不能抢先获取。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">acquireQueued</span><span class=\"token punctuation\">(</span><span class=\"token function\">addWaiter</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">.</span>EXCLUSIVE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">selfInterrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> acquires<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> Thread current <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//判断状态state是否等于0，等于0代表锁没有被占用，不等于0则代表锁被占用着。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//调用hasQueuedPredecessors方法判断同步队列中是否有线程在等待，如果同步队列中没有</span>\n        <span class=\"token comment\" spellcheck=\"true\">//线程在等待 则当前线程成为锁的所有者，如果同步队列中有线程在等待，则继续往下执行</span>\n        <span class=\"token comment\" spellcheck=\"true\">//这个机制就是公平锁的机制，也就是先让先来的线程获取锁，后来的不能抢先获取。</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">hasQueuedPredecessors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> acquires<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setExclusiveOwnerThread</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//判断当前线程是否为锁的所有者，如果是，那么直接更新状态state，然后返回true。</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">==</span> <span class=\"token function\">getExclusiveOwnerThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> nextc <span class=\"token operator\">=</span> c <span class=\"token operator\">+</span> acquires<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextc <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Maximum lock count exceeded\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>nextc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果同步队列中有线程存在 且 锁的所有者不是当前线程，则返回false。</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"unLock-1\"><a href=\"#unLock-1\" class=\"headerlink\" title=\"unLock()\"></a>unLock()</h4><p>公平锁的释放和非公平锁的释放一样，这里就不重复。<br>公平锁和非公平锁的公平性是在<strong>获取锁</strong>的时候体现出来的，释放的时候都是一样释放的。</p>\n<h3 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h3><h4 id=\"lockInterruptibly可中断方式获取锁\"><a href=\"#lockInterruptibly可中断方式获取锁\" class=\"headerlink\" title=\"lockInterruptibly可中断方式获取锁\"></a>lockInterruptibly可中断方式获取锁</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    sync<span class=\"token punctuation\">.</span><span class=\"token function\">acquireInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">acquireInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果当前线程已经中断了，那么抛出异常</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果当前线程仍然未成功获取锁，则调用doAcquireInterruptibly方法，这个方法和</span>\n    <span class=\"token comment\" spellcheck=\"true\">//acquireQueued方法没什么区别，就是线程在等待状态的过程中，如果线程被中断，线程会</span>\n    <span class=\"token comment\" spellcheck=\"true\">//抛出异常。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token function\">doAcquireInterruptibly</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"tryLock超时等待方式获取锁\"><a href=\"#tryLock超时等待方式获取锁\" class=\"headerlink\" title=\"tryLock超时等待方式获取锁\"></a>tryLock超时等待方式获取锁</h4><p><code>ReentrantLock</code>除了能以能中断的方式去获取锁，还可以以超时等待的方式去获取锁，所谓超时等待就是线程如果在超时时间内没有获取到锁，那么就会返回<code>false</code>，而不是一直”死循环”获取。</p>\n<ol>\n<li>判断当前节点是否已经中断，已经被中断过则抛出异常，如果没有被中断过则尝试获取锁，获取失败则调用<code>doAcquireNanos</code>方法使用超时等待的方式获取锁。</li>\n<li>将当前节点封装成独占模式的节点加入到同步队列的队尾中。</li>\n<li>进入到”死循环”中，<strong>但是这个死循环是有个限制的，也就是当线程达到超时时间了仍未获得锁，那么就会返回<code>false</code>，结束循环</strong>。这里调用的是<code>LockSupport.parkNanos</code>方法，在超时时间内没有被中断，那么线程会从<strong>超时等待状态转成了就绪状态</strong>，然后被<code>CPU</code>调度继续执行循环，<strong>而这时候线程已经达到超时等到的时间，返回false</strong>。</li>\n</ol>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608082234599.png\" alt=\"image-20210608082234599\" style=\"zoom:67%;\" />\n\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryLock</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> timeout<span class=\"token punctuation\">,</span> TimeUnit unit<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> sync<span class=\"token punctuation\">.</span><span class=\"token function\">tryAcquireNanos</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> unit<span class=\"token punctuation\">.</span><span class=\"token function\">toNanos</span><span class=\"token punctuation\">(</span>timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryAcquireNanos</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> nanosTimeout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果当前线程已经中断了  则抛出异常</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//再尝试获取一次 如果不成功则调用doAcquireNanos方法进行超时等待获取锁</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">doAcquireNanos</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">,</span> nanosTimeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">doAcquireNanos</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> nanosTimeout<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nanosTimeout <span class=\"token operator\">&lt;=</span> 0L<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//计算超时的时间 即当前虚拟机的时间+设置的超时时间</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> deadline <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> nanosTimeout<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//调用addWaiter将当前线程封装成独占模式的节点 并且加入到同步队列尾部</span>\n    <span class=\"token keyword\">final</span> Node node <span class=\"token operator\">=</span> <span class=\"token function\">addWaiter</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">.</span>EXCLUSIVE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span> failed <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> Node p <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span><span class=\"token function\">predecessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果当前节点的前驱节点为头结点 则让当前节点去尝试获取锁。</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">==</span> head <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//当前节点获取锁成功 则将当前节点设置为头结点，然后返回true。</span>\n                <span class=\"token function\">setHead</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                p<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// help GC</span>\n                failed <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果当前节点的前驱节点不是头结点 或者 当前节点获取锁失败，</span>\n            <span class=\"token comment\" spellcheck=\"true\">//则再次判断当前线程是否已经超时。</span>\n            nanosTimeout <span class=\"token operator\">=</span> deadline <span class=\"token operator\">-</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nanosTimeout <span class=\"token operator\">&lt;=</span> 0L<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//调用shouldParkAfterFailedAcquire方法，告诉当前节点的前驱节点 我要进入</span>\n            <span class=\"token comment\" spellcheck=\"true\">//等待状态了，到我了记得喊我，即做好进入等待状态前的准备。</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">shouldParkAfterFailedAcquire</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n                nanosTimeout <span class=\"token operator\">></span> spinForTimeoutThreshold<span class=\"token punctuation\">)</span>\n                <span class=\"token comment\" spellcheck=\"true\">//调用LockSupport.parkNanos方法，将当前线程设置成超时等待的状态。</span>\n                LockSupport<span class=\"token punctuation\">.</span><span class=\"token function\">parkNanos</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> nanosTimeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>failed<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">cancelAcquire</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"锁分类\"><a href=\"#锁分类\" class=\"headerlink\" title=\"锁分类\"></a>锁分类</h1><h2 id=\"乐观锁和悲观锁\"><a href=\"#乐观锁和悲观锁\" class=\"headerlink\" title=\"乐观锁和悲观锁\"></a>乐观锁和悲观锁</h2><ul>\n<li>互斥同步锁：阻塞、唤醒带来性能劣势</li>\n<li>悲观锁适用并发写入多的情况，适用于临界区持锁时间比较长的情况，可以避免大量无用自旋等</li>\n<li>乐观锁适合并发写入少，大部分读取情况</li>\n<li>悲观锁最典型synchronized、Lock</li>\n<li>乐观锁最典型CAS、原子类、并发容器</li>\n</ul>\n<h2 id=\"可重入锁和不可重入锁\"><a href=\"#可重入锁和不可重入锁\" class=\"headerlink\" title=\"可重入锁和不可重入锁\"></a>可重入锁和不可重入锁</h2><p><strong>可重入锁(递归锁)</strong></p>\n<ul>\n<li>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码</li>\n<li>线程可以进入任何一个他已经拥有的锁所同步着的代码块</li>\n<li><code>ReentrantLock </code>，<code>Synchronized</code>就是经典的可重入锁</li>\n<li>最大作用在于避免死锁</li>\n<li>即某个线程可以再次获得一个已经由它自己持有的锁</li>\n<li>重入的实现方式是计数（类似引用计数）：获取锁时先判断，如果当前线程就是已经占有锁的线程，则status+1</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sendSMS</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" invoke sendSMS\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">sendEmail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sendEmail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" invoke sendEmail\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Main main <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            main<span class=\"token punctuation\">.</span><span class=\"token function\">sendSMS</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>，<span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"公平和非公平锁\"><a href=\"#公平和非公平锁\" class=\"headerlink\" title=\"公平和非公平锁\"></a>公平和非公平锁</h2><ul>\n<li><p>公平锁：在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，按照FIFO的规则。</p>\n</li>\n<li><p>非公平锁：运行加塞。是指多个线程获取锁的顺序并不是按照申请锁的顺序</p>\n</li>\n</ul>\n<ul>\n<li>ReentrantLock 默认非公平锁，可以指定构造函数决定是公平锁还是非公平锁</li>\n<li>对于Synchronized是非公平锁</li>\n<li>例如让10个线程分别打印两次，如果是公平锁，就会0-10，0-10，而非公平锁则会每个线程都连续打印两次。原因是他没有陷入阻塞，所以更快的拿到锁</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PrintQueue</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 设置为非公平，则会一个线程打印两次，再到下一个线程；因为其他阻塞，当然执行的那个线程快</span>\n        <span class=\"token keyword\">private</span> Lock queueLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">printJob</span><span class=\"token punctuation\">(</span>Object document<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 模拟打印两次，正反两面</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                queueLock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span>\n                <span class=\"token punctuation\">{</span>\n                    Long duration <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"正在打印，需要:\"</span><span class=\"token operator\">+</span>duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                    queueLock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        PrintQueue printQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PrintQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Thread<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> threads <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            threads<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                printQueue<span class=\"token punctuation\">.</span><span class=\"token function\">printJob</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            threads<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"共享锁和排他锁\"><a href=\"#共享锁和排他锁\" class=\"headerlink\" title=\"共享锁和排他锁\"></a>共享锁和排他锁</h2><ul>\n<li>独占锁(写锁)：指该锁一次只能被一个线程所持有。<code>ReentrantLock </code>，<code>Synchronized</code>就是独占锁</li>\n<li>共享锁(读锁)：指该锁可被多个线程所共享，获得共享锁后，可以查看但是无法修改和删除数据，其他线程也还可以获取共享锁</li>\n<li>ReentrantReadWriteLock的读锁，写锁（实现读写锁ReadWriteLock接口）</li>\n<li>reentrantReadWriteLock.readLock();</li>\n<li>reentrantReadWriteLock.writeLock();</li>\n</ul>\n<ul>\n<li>读-读能共存</li>\n<li>读-写不能共存</li>\n<li>写-写不能共存</li>\n</ul>\n<ul>\n<li>读和读互不影响，读和写互斥，写和写互斥，提高读写的效率</li>\n<li>ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。</li>\n<li>读锁使用共享模式；写锁使用独占模式，换句话说，读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的</li>\n<li>当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁</li>\n<li>线程进入写锁的前提条件：没有其他线程的读锁、没有其他线程的写锁</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>HashMap<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Map<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>locks<span class=\"token punctuation\">.</span>ReentrantReadWriteLock<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyCache</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//保证可见性</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> Map<span class=\"token operator\">&lt;</span>String， Object<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//读写锁，可以在读和写时采取不同策略</span>\n    <span class=\"token keyword\">private</span> ReentrantReadWriteLock reentrantReadWriteLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantReadWriteLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//写，读，清空</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//写操作必须独占，原子 中间不允许被打断</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>String key， Object value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        reentrantReadWriteLock<span class=\"token punctuation\">.</span><span class=\"token function\">writeLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" 正在写入: \"</span> <span class=\"token operator\">+</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key， value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" 写入完成\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            reentrantReadWriteLock<span class=\"token punctuation\">.</span><span class=\"token function\">writeLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> Object <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>String key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        reentrantReadWriteLock<span class=\"token punctuation\">.</span><span class=\"token function\">readLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" 正在读取: \"</span> <span class=\"token operator\">+</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            Object object <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" 读取完成 \"</span> <span class=\"token operator\">+</span> object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> object<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            reentrantReadWriteLock<span class=\"token punctuation\">.</span><span class=\"token function\">readLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        MyCache myCache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyCache</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> finalI <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                myCache<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>finalI<span class=\"token punctuation\">)</span>， String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>finalI<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>， String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> finalI <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                myCache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>finalI<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>， String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n        0 正在写入: 0\n        0 写入完成\n        1 正在写入: 1\n        1 写入完成\n        2 正在写入: 2\n        2 写入完成\n        3 正在写入: 3\n        3 写入完成\n        4 正在写入: 4\n        4 写入完成\n        5 正在读取: 0\n        6 正在读取: 1\n        7 正在读取: 2\n        8 正在读取: 3\n        9 正在读取: 4\n        9 读取完成 4\n        7 读取完成 2\n        6 读取完成 1\n        8 读取完成 3\n        5 读取完成 0\n         */</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"自旋锁与非自旋锁\"><a href=\"#自旋锁与非自旋锁\" class=\"headerlink\" title=\"自旋锁与非自旋锁\"></a>自旋锁与非自旋锁</h2><ul>\n<li>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</li>\n<li>好处是减少线程上下文切换，缺点是锁被占用的时间很长的话，自旋的线程不断循环会白白消耗CPU资源</li>\n<li>java.util.concurrent的atmoic包下的类基本都是自旋锁的实现</li>\n<li>实现的原理是CAS</li>\n<li>AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功</li>\n<li>AtomicReference</li>\n</ul>\n<h2 id=\"可中断锁和不可中断锁\"><a href=\"#可中断锁和不可中断锁\" class=\"headerlink\" title=\"可中断锁和不可中断锁\"></a>可中断锁和不可中断锁</h2><p>ReentrantLock中的lockInterruptibly()方法使得线程可以在被阻塞时响应中断，比如一个线程t1通过lockInterruptibly()方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过interrupt()方法就可以立刻打断t1线程的执行，来获取t1持有的那个可重入锁。而通过ReentrantLock的lock()方法或者Synchronized持有锁的线程是不会响应其他线程的interrupt()方法的，直到该方法主动释放锁之后才会响应interrupt()方法。</p>\n<p>当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。<br>当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。<br>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 尝试获取锁，被中断会进入中断异常处理块中</span>\n<span class=\"token comment\" spellcheck=\"true\">// 这货没有时间限制的尝试获取锁，和synchronized一样，但是，这货能相应中断</span>\n<span class=\"token comment\" spellcheck=\"true\">//这是synchronized没有的优点，这使得程序在另外的线程没有释放锁时能自定义退出程序。</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"线程\"</span><span class=\"token operator\">+</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"被中断\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"锁优化\"><a href=\"#锁优化\" class=\"headerlink\" title=\"锁优化\"></a>锁优化</h1><h2 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h2><ul>\n<li>即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。</li>\n<li>来源于逃逸分析技术的数据支持。</li>\n<li>如果判断一段代码中堆上所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的</li>\n<li>很多同步机制不是程序员自己加的</li>\n<li>StringBuffer.append()都有同步块，锁sb对象</li>\n<li>虚拟机观测变量sb，经过逃逸分析后发现他的动态作用域限制在方法内部，sb的所有引用都不会逃逸到方法外部，其他线程无法访问，所以可以安全消除锁</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> String <span class=\"token function\">concatString</span><span class=\"token punctuation\">(</span>String s1， String s2， String s3<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> s1 <span class=\"token operator\">+</span> s2 <span class=\"token operator\">+</span> s3<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//上面的代码在JDK5之前会转换成StringBuffer对象进行连续append</span>\n<span class=\"token comment\" spellcheck=\"true\">//在JDK5之后会转换成StringBuilder对象</span>\n<span class=\"token keyword\">public</span> String <span class=\"token function\">concatString</span><span class=\"token punctuation\">(</span>String s1， String s2， String s3<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        StringBuffer sb <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> sb<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>锁消除是发生在编译器级别的一种锁优化方式。<br>有时候我们写的代码完全不需要加锁，却执行了加锁操作。</p>\n<p>比如，StringBuffer类的append操作：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> StringBuffer <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>String str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    toStringCache <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>从源码中可以看出，append方法用了synchronized关键词，它是线程安全的。但我们可能仅在线程内部把StringBuffer当作局部变量使用：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> com<span class=\"token punctuation\">.</span>leeib<span class=\"token punctuation\">.</span>thread<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">long</span> start <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> size<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">createStringBuffer</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hyes\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"为分享技术而生\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">long</span> timeCost <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"createStringBuffer:\"</span> <span class=\"token operator\">+</span> timeCost <span class=\"token operator\">+</span> <span class=\"token string\">\" ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">createStringBuffer</span><span class=\"token punctuation\">(</span>String str1<span class=\"token punctuation\">,</span> String str2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        StringBuffer sBuf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sBuf<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// append方法是同步操作</span>\n        sBuf<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> sBuf<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>代码中createStringBuffer方法中的局部对象sBuf，就只在该方法内的作用域有效，不同线程同时调用createStringBuffer()方法时，都会创建不同的sBuf对象，因此此时的append操作若是使用同步操作，就是白白浪费的系统资源。</p>\n<p>这时我们可以通过编译器将其优化，将锁消除，前提是java必须运行在server模式（server模式会比client模式作更多的优化），同时必须开启逃逸分析:</p>\n<p>-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</p>\n<p>其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除。</p>\n<blockquote>\n<p>逃逸分析：比如上面的代码，它要看sBuf是否可能逃出它的作用域？如果将sBuf作为方法的返回值进行返回，那么它在方法外部可能被当作一个全局对象使用，就有可能发生线程安全问题，这时就可以说sBuf这个对象发生逃逸了，因而不应将append操作的锁消除，但我们上面的代码没有发生锁逃逸，锁消除就可以带来一定的性能提升。</p>\n</blockquote>\n<h2 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h2><ul>\n<li>编写代码时推荐把同步块的作用访问限制得尽量小，只在共享数据的实际作用域进行同步。可以使得需要同步的操作数量尽可能变小，即使存在锁竞争，等待锁的线程也能尽快拿到锁</li>\n<li>原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环体内部，即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗</li>\n<li>例如上述的连续append，如果虚拟机探测到一串零碎的操作对同一个对象加锁。就将会把加锁同步的范围粗化到整个操作序列的外部。例如把操作扩展到三次append（）操作外部，只需要一次加锁</li>\n</ul>\n<p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽可能短，但是某些情况下，一个程序对同一个锁不间断、高频地请求、同步与释放，会消耗掉一定的系统资源，因为锁的请求、同步与释放本身会带来性能损耗，这样高频的锁请求就反而不利于系统性能的优化了，虽然单次同步操作的时间可能很短。<strong>锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。</strong></p>\n<p>一种极端的情况如下：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomethingMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//do some thing</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕</span>\n    <span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//do other thing</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>上面的代码是有两块需要同步操作的，但在这两块需要同步操作的代码之间，需要做一些其它的工作，而这些工作只会花费很少的时间，那么我们就可以把这些工作代码放入锁内，将两个同步代码块合并成一个，以降低多次锁请求、同步、释放带来的系统性能消耗，合并后的代码如下:</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomethingMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//进行锁粗化：整合成一次锁请求、同步、释放</span>\n    <span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//do some thing</span>\n        <span class=\"token comment\" spellcheck=\"true\">//做其它不需要同步但能很快执行完的工作</span>\n        <span class=\"token comment\" spellcheck=\"true\">//do other thing</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<blockquote>\n<p>注意：这样做是有前提的，就是中间不需要同步的代码能够很快速地完成，如果不需要同步的代码需要花很长时间，就会导致同步块的执行需要花费很长的时间，这样做也就不合理了。</p>\n</blockquote>\n<p>另一种需要锁粗化的极端的情况是：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>size<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>上面代码每次循环都会进行锁的请求、同步与释放，看起来貌似没什么问题，且在jdk内部会对这类代码锁的请求做一些优化，但是还不如把加锁代码写在循环体的外面，这样一次锁的请求就可以达到我们的要求，除非有特殊的需要：循环需要花很长时间，但其它线程等不起，要给它们执行的机会。</p>\n<p>锁粗化后的代码如下：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>size<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"了解\"><a href=\"#了解\" class=\"headerlink\" title=\"了解\"></a>了解</h3><ul>\n<li>是Lock的重入锁实现</li>\n<li>提供无条件的、可轮询的、定时的、可中断的锁获取操作</li>\n<li>与synchronized提供相同的互斥性和内存可见性</li>\n<li>synchronized无法中断一个正在等待获取锁的线程，或者无法在请求获取一个锁时无限的等待下去</li>\n<li>必须在finally中释放锁</li>\n<li>tryLock方法：如果不能获得所有需要的锁，那么可以使用可定时的或可轮询的锁获取方式；它会释放已经获得的锁，然后重新尝试获取所有锁</li>\n</ul>\n<h3 id=\"与Synchronized的区别\"><a href=\"#与Synchronized的区别\" class=\"headerlink\" title=\"与Synchronized的区别\"></a>与Synchronized的区别</h3><ul>\n<li>Synchronized是关键字，是JVM层面的，使用monitorenter进入，monitorexit退出，而且保证正常于异常都会退出。Lock是JUC下的具体类，是API层面的锁</li>\n<li>Synchronized不需要手动释放锁，当代码块执行完会自动让线程释放对锁的占用，而ReentrantLock需要用户手动释放锁</li>\n<li>Synchronized不可中断，除非抛出异常或者运行结束。ReentrantLock可中断，可以通过reentrantLock.tryLock(1, TimeUnit.SECONDS);</li>\n<li>Synchronized默认非公平锁，ReentrantLock默认非公平锁，但是可以调节到公平锁</li>\n<li>ReentrantLock可以绑定多个条件Condition，用来实现分组唤醒，或者精确唤醒</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608084921006.png\" alt=\"image-20210608084921006\"></p>\n<h4 id=\"限时等待\"><a href=\"#限时等待\" class=\"headerlink\" title=\"限时等待\"></a>限时等待</h4><p><strong>tryLock()</strong></p>\n<p>用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回true，否则返回false</p>\n<p><strong>boolean tryLock(long timeout, TimeUnit unit)</strong></p>\n<p>一个线程在指定的时间内没有获取锁，那就会返回false</p>\n<h4 id=\"等待可中断\"><a href=\"#等待可中断\" class=\"headerlink\" title=\"等待可中断\"></a>等待可中断</h4><p>当持有锁的线程长期不释放锁时，正在等待的线程可以放弃等待，改为处理其他事情</p>\n<p><strong>处理死锁</strong></p>\n<p>在这里我们定义了两个锁lock1和lock2。然后使用两个线程thread1和thread2构造死锁场景。正常情况下，这两个线程相互等待获取资源而处于死循环状态。但是我们此时thread1中断，另外一个线程就可以获取资源，正常地执行了。</p>\n<pre><code class=\"java\">import java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Main{\n    private static final Lock lock1 = new ReentrantLock();\n    private static final Lock lock2 = new ReentrantLock();\n\n    private static void demo(Lock first, Lock second) {\n        try {\n            first.lockInterruptibly();\n            TimeUnit.MILLISECONDS.sleep(100);\n            second.lockInterruptibly();\n        } catch (Exception e) {\n        }\n        finally {\n            first.unlock();\n            second.unlock();\n            System.out.println(Thread.currentThread().getName()+&quot;:code end&quot;);\n        }\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -&gt; demo(lock1, lock2), &quot;t1&quot;);\n        Thread thread2 = new Thread(() -&gt; demo(lock2, lock1), &quot;t2&quot;);\n        thread1.start();\n        thread2.start();\n        TimeUnit.MILLISECONDS.sleep(200);\n        thread1.interrupt();\n    }\n}</code></pre>\n<h4 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h4><ul>\n<li>公平锁保证多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</li>\n<li>而非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁</li>\n<li>synchronized是非公平锁，ReentrantLock默认非公平，可以通过构造函数设置为公平锁</li>\n<li>使用公平锁，性能急剧下降，明显影响吞吐量</li>\n</ul>\n<h4 id=\"锁绑定多个条件\"><a href=\"#锁绑定多个条件\" class=\"headerlink\" title=\"锁绑定多个条件\"></a>锁绑定多个条件</h4><ul>\n<li>一个ReentrantLock对象可以绑定多个Condition对象</li>\n<li>多次调用newCondition()即可</li>\n<li>signal()是公平的，只会唤醒等待时间最长的线程；signalAll()唤醒所有等待的线程</li>\n</ul>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608075716972.png\" alt=\"image-20210608075716972\" style=\"zoom:67%;\" />\n\n<p>通过<code>Sync</code>重写的方法<code>tryAcquire</code>、<code>tryRelease</code>可以知道，**<code>ReentrantLock</code>实现的是<code>AQS</code>的独占模式，也就是独占锁，这个锁是悲观锁**。</p>\n<p><code>ReentrantLock</code>有个重要的成员变量：</p>\n<pre><code class=\"java\">private final Sync sync;</code></pre>\n<p>这个变量是用来指向<code>Sync</code>的子类的，也就是<code>FairSync</code>或者<code>NonfairSync</code>，这个也就是多态的<strong>父类引用指向子类</strong>，具体<code>Sycn</code>指向哪个子类，看构造方法：</p>\n<pre><code class=\"java\">public ReentrantLock() {\n    sync = new NonfairSync();\n}\n\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}</code></pre>\n<p><code>ReentrantLock</code>有两个构造方法，无参构造方法默认是创建<strong>非公平锁</strong>，而传入<code>true</code>为参数的构造方法创建的是<strong>公平锁</strong>。</p>\n<h3 id=\"非公平锁的实现原理\"><a href=\"#非公平锁的实现原理\" class=\"headerlink\" title=\"非公平锁的实现原理\"></a>非公平锁的实现原理</h3><h4 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock()\"></a>lock()</h4><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608080231479.png\" alt=\"image-20210608080231479\"></p>\n<p>lock方法调用CAS方法设置state的值，如果state等于期望值0(代表锁没有被占用)，那么就将state更新为1(代表该线程获取锁成功)，然后执行setExclusiveOwnerThread方法直接将该线程设置成锁的所有者。如果CAS设置state的值失败，即state不等于0，代表锁正在被占领着，则执行acquire(1)，即下面的步骤。</p>\n<p>nonfairTryAcquire方法首先调用getState方法获取state的值，如果state的值为0(之前占领锁的线程刚好释放了锁)，那么用CAS这是state的值，设置成功则将该线程设置成锁的所有者，并且返回true。如果state的值不为0，那就<strong>调用getExclusiveOwnerThread方法查看占用锁的线程是不是自己</strong>，如果是的话那就直接将state + 1，然后返回true。如果state不为0且锁的所有者又不是自己，那就返回false，<strong>然后线程会进入到同步队列中</strong>。</p>\n<pre><code class=\"java\">final void lock() {\n    //CAS操作设置state的值\n    if (compareAndSetState(0, 1))\n        //设置成功 直接将锁的所有者设置为当前线程 流程结束\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        //设置失败 则进行后续的加入同步队列准备\n        acquire(1);\n}\n\npublic final void acquire(int arg) {\n    //调用子类重写的tryAcquire方法 如果tryAcquire方法返回false 那么线程就会进入同步队列\n    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\n//子类重写的tryAcquire方法\nprotected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires); // 调用nonfairTryAcquire方法\n}\n\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    //如果状态state=0，即在这段时间内 锁的所有者把锁释放了 那么这里state就为0\n    if (c == 0) {\n        //使用CAS操作设置state的值\n        if (compareAndSetState(0, acquires)) {\n            //操作成功 则将锁的所有者设置成当前线程并返回true，也就是当前线程不会进入同步队列\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //如果状态state不等于0，也就是有线程正在占用锁，那么先检查一下这个线程是不是自己\n    else if (current == getExclusiveOwnerThread()) {\n        //如果线程就是自己了，那么直接将state+1，返回true，不需要再获取锁\n        int nextc = c + acquires;\n        if (nextc &lt; 0) // 重入次数溢出\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    }\n    //如果state不等于0，且锁的所有者又不是自己，那么线程就会进入到同步队列。\n    return false;\n}</code></pre>\n<h4 id=\"unLock\"><a href=\"#unLock\" class=\"headerlink\" title=\"unLock()\"></a>unLock()</h4><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608080628732.png\" alt=\"image-20210608080628732\" style=\"zoom:67%;\" />\n\n<p>判断当前线程是不是锁的所有者，如果是则进行步骤<code>2</code>，如果不是则抛出异常。</p>\n<p>判断此次释放锁后<code>state</code>的值是否为0，如果是则代表<strong>锁有没有重入</strong>，然后将锁的所有者设置成<code>null</code>且返回true，然后执行步骤<code>3</code>，如果不是则<strong>代表锁发生了重入</strong>执行步骤<code>4</code>。</p>\n<p>现在锁已经释放完，即<code>state=0</code>，唤醒同步队列中的后继节点进行锁的获取。</p>\n<p>锁还没有释放完，即<code>state!=0</code>，不唤醒同步队列。</p>\n<pre><code class=\"java\">public void unlock() {\n    sync.release(1);\n}\n\npublic final boolean release(int arg) {\n    //子类重写的tryRelease方法，需要等锁的state=0，即tryRelease返回true的时候，才会去唤醒其\n    //它线程进行尝试获取锁。\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null &amp;&amp; h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n\nprotected final boolean tryRelease(int releases) {\n    //状态的state减去releases\n    int c = getState() - releases;\n    //判断锁的所有者是不是该线程\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        //如果所的所有者不是该线程 则抛出异常 也就是锁释放的前提是线程拥有这个锁，\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    //如果该线程释放锁之后 状态state=0，即锁没有重入，那么直接将将锁的所有者设置成null\n    //并且返回true，即代表可以唤醒其他线程去获取锁了。如果该线程释放锁之后state不等于0，\n    //那么代表锁重入了，返回false，代表锁还未正在释放，不用去唤醒其他线程。\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}</code></pre>\n<h3 id=\"公平锁的实现原理\"><a href=\"#公平锁的实现原理\" class=\"headerlink\" title=\"公平锁的实现原理\"></a>公平锁的实现原理</h3><p>该方法与 nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了 hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如 果该方法返回 true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线 程获取并释放锁之后才能继续获取锁。</p>\n<h4 id=\"lock-1\"><a href=\"#lock-1\" class=\"headerlink\" title=\"lock()\"></a>lock()</h4><ol>\n<li>获取状态的<code>state</code>的值，如果<code>state=0</code>即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤2。如果<code>state!=0</code>则代表锁正在被其它线程占用，执行步骤3。</li>\n<li>判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。</li>\n<li>判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中</li>\n</ol>\n<p>通过步骤2实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性。<br><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608081308666.png\" alt=\"image-20210608081308666\"></p>\n<pre><code class=\"java\">final void lock() {\n    acquire(1);\n}\n\npublic final void acquire(int arg) {\n    //同步队列中有线程 且 锁的所有者不是当前线程那么将线程加入到同步队列的尾部，\n    //保证了公平性，也就是先来的线程先获得锁，后来的不能抢先获取。\n    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    //判断状态state是否等于0，等于0代表锁没有被占用，不等于0则代表锁被占用着。\n    if (c == 0) {\n        //调用hasQueuedPredecessors方法判断同步队列中是否有线程在等待，如果同步队列中没有\n        //线程在等待 则当前线程成为锁的所有者，如果同步队列中有线程在等待，则继续往下执行\n        //这个机制就是公平锁的机制，也就是先让先来的线程获取锁，后来的不能抢先获取。\n        if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //判断当前线程是否为锁的所有者，如果是，那么直接更新状态state，然后返回true。\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc &lt; 0)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    }\n    //如果同步队列中有线程存在 且 锁的所有者不是当前线程，则返回false。\n    return false;\n}</code></pre>\n<h4 id=\"unLock-1\"><a href=\"#unLock-1\" class=\"headerlink\" title=\"unLock()\"></a>unLock()</h4><p>公平锁的释放和非公平锁的释放一样，这里就不重复。<br>公平锁和非公平锁的公平性是在<strong>获取锁</strong>的时候体现出来的，释放的时候都是一样释放的。</p>\n<h3 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h3><h4 id=\"lockInterruptibly可中断方式获取锁\"><a href=\"#lockInterruptibly可中断方式获取锁\" class=\"headerlink\" title=\"lockInterruptibly可中断方式获取锁\"></a>lockInterruptibly可中断方式获取锁</h4><pre><code class=\"java\">public void lockInterruptibly() throws InterruptedException {\n    sync.acquireInterruptibly(1);\n}\n\npublic final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    //如果当前线程已经中断了，那么抛出异常\n    if (Thread.interrupted()) throw new InterruptedException();\n    //如果当前线程仍然未成功获取锁，则调用doAcquireInterruptibly方法，这个方法和\n    //acquireQueued方法没什么区别，就是线程在等待状态的过程中，如果线程被中断，线程会\n    //抛出异常。\n    if (!tryAcquire(arg)) doAcquireInterruptibly(arg);\n}</code></pre>\n<h4 id=\"tryLock超时等待方式获取锁\"><a href=\"#tryLock超时等待方式获取锁\" class=\"headerlink\" title=\"tryLock超时等待方式获取锁\"></a>tryLock超时等待方式获取锁</h4><p><code>ReentrantLock</code>除了能以能中断的方式去获取锁，还可以以超时等待的方式去获取锁，所谓超时等待就是线程如果在超时时间内没有获取到锁，那么就会返回<code>false</code>，而不是一直”死循环”获取。</p>\n<ol>\n<li>判断当前节点是否已经中断，已经被中断过则抛出异常，如果没有被中断过则尝试获取锁，获取失败则调用<code>doAcquireNanos</code>方法使用超时等待的方式获取锁。</li>\n<li>将当前节点封装成独占模式的节点加入到同步队列的队尾中。</li>\n<li>进入到”死循环”中，<strong>但是这个死循环是有个限制的，也就是当线程达到超时时间了仍未获得锁，那么就会返回<code>false</code>，结束循环</strong>。这里调用的是<code>LockSupport.parkNanos</code>方法，在超时时间内没有被中断，那么线程会从<strong>超时等待状态转成了就绪状态</strong>，然后被<code>CPU</code>调度继续执行循环，<strong>而这时候线程已经达到超时等到的时间，返回false</strong>。</li>\n</ol>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608082234599.png\" alt=\"image-20210608082234599\" style=\"zoom:67%;\" />\n\n<pre><code class=\"java\">public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {\n    return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n}\n\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout) {\n    //如果当前线程已经中断了  则抛出异常\n    if (Thread.interrupted()) throw new InterruptedException();\n    //再尝试获取一次 如果不成功则调用doAcquireNanos方法进行超时等待获取锁\n    return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);\n}\n\nprivate boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {\n    if (nanosTimeout &lt;= 0L) return false;\n    //计算超时的时间 即当前虚拟机的时间+设置的超时时间\n    final long deadline = System.nanoTime() + nanosTimeout;\n    //调用addWaiter将当前线程封装成独占模式的节点 并且加入到同步队列尾部\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            //如果当前节点的前驱节点为头结点 则让当前节点去尝试获取锁。\n            if (p == head &amp;&amp; tryAcquire(arg)) {\n                //当前节点获取锁成功 则将当前节点设置为头结点，然后返回true。\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return true;\n            }\n            //如果当前节点的前驱节点不是头结点 或者 当前节点获取锁失败，\n            //则再次判断当前线程是否已经超时。\n            nanosTimeout = deadline - System.nanoTime();\n            if (nanosTimeout &lt;= 0L) return false;\n            //调用shouldParkAfterFailedAcquire方法，告诉当前节点的前驱节点 我要进入\n            //等待状态了，到我了记得喊我，即做好进入等待状态前的准备。\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                nanosTimeout &gt; spinForTimeoutThreshold)\n                //调用LockSupport.parkNanos方法，将当前线程设置成超时等待的状态。\n                LockSupport.parkNanos(this, nanosTimeout);\n            if (Thread.interrupted())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}</code></pre>\n<h1 id=\"锁分类\"><a href=\"#锁分类\" class=\"headerlink\" title=\"锁分类\"></a>锁分类</h1><h2 id=\"乐观锁和悲观锁\"><a href=\"#乐观锁和悲观锁\" class=\"headerlink\" title=\"乐观锁和悲观锁\"></a>乐观锁和悲观锁</h2><ul>\n<li>互斥同步锁：阻塞、唤醒带来性能劣势</li>\n<li>悲观锁适用并发写入多的情况，适用于临界区持锁时间比较长的情况，可以避免大量无用自旋等</li>\n<li>乐观锁适合并发写入少，大部分读取情况</li>\n<li>悲观锁最典型synchronized、Lock</li>\n<li>乐观锁最典型CAS、原子类、并发容器</li>\n</ul>\n<h2 id=\"可重入锁和不可重入锁\"><a href=\"#可重入锁和不可重入锁\" class=\"headerlink\" title=\"可重入锁和不可重入锁\"></a>可重入锁和不可重入锁</h2><p><strong>可重入锁(递归锁)</strong></p>\n<ul>\n<li>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码</li>\n<li>线程可以进入任何一个他已经拥有的锁所同步着的代码块</li>\n<li><code>ReentrantLock </code>，<code>Synchronized</code>就是经典的可重入锁</li>\n<li>最大作用在于避免死锁</li>\n<li>即某个线程可以再次获得一个已经由它自己持有的锁</li>\n<li>重入的实现方式是计数（类似引用计数）：获取锁时先判断，如果当前线程就是已经占有锁的线程，则status+1</li>\n</ul>\n<pre><code class=\"java\">public class Main {\n    public synchronized void sendSMS() {\n        System.out.println(Thread.currentThread().getName() + &quot; invoke sendSMS&quot;);\n        sendEmail();\n    }\n    public synchronized void sendEmail() {\n        System.out.println(Thread.currentThread().getName() + &quot; invoke sendEmail&quot;);\n    }\n\n    public static void main(String[] args) {\n        Main main = new Main();\n        new Thread(() -&gt; {\n            main.sendSMS();\n        }，&quot;t1&quot;).start();\n    }\n}</code></pre>\n<h2 id=\"公平和非公平锁\"><a href=\"#公平和非公平锁\" class=\"headerlink\" title=\"公平和非公平锁\"></a>公平和非公平锁</h2><ul>\n<li><p>公平锁：在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，按照FIFO的规则。</p>\n</li>\n<li><p>非公平锁：运行加塞。是指多个线程获取锁的顺序并不是按照申请锁的顺序</p>\n</li>\n</ul>\n<ul>\n<li>ReentrantLock 默认非公平锁，可以指定构造函数决定是公平锁还是非公平锁</li>\n<li>对于Synchronized是非公平锁</li>\n<li>例如让10个线程分别打印两次，如果是公平锁，就会0-10，0-10，而非公平锁则会每个线程都连续打印两次。原因是他没有陷入阻塞，所以更快的拿到锁</li>\n</ul>\n<pre><code class=\"java\">public class Main {\n    static class PrintQueue{\n        // 设置为非公平，则会一个线程打印两次，再到下一个线程；因为其他阻塞，当然执行的那个线程快\n        private Lock queueLock = new ReentrantLock(false);\n\n        public void printJob(Object document) {\n            // 模拟打印两次，正反两面\n            for (int i = 0; i &lt; 2; i++) {\n                queueLock.lock();\n                try\n                {\n                    Long duration = (long)(Math.random() * 1000);\n                    System.out.println(Thread.currentThread().getName()+&quot;正在打印，需要:&quot;+duration);\n                    TimeUnit.MILLISECONDS.sleep(duration);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    queueLock.unlock();\n                }\n            }\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        PrintQueue printQueue = new PrintQueue();\n        Thread[] threads = new Thread[10];\n        for (int i = 0; i &lt; 10; i++) {\n            threads[i] = new Thread(() -&gt; {\n                printQueue.printJob(new Object());\n            });\n            threads[i].start();\n            TimeUnit.MILLISECONDS.sleep(10);\n        }\n    }\n}</code></pre>\n<h2 id=\"共享锁和排他锁\"><a href=\"#共享锁和排他锁\" class=\"headerlink\" title=\"共享锁和排他锁\"></a>共享锁和排他锁</h2><ul>\n<li>独占锁(写锁)：指该锁一次只能被一个线程所持有。<code>ReentrantLock </code>，<code>Synchronized</code>就是独占锁</li>\n<li>共享锁(读锁)：指该锁可被多个线程所共享，获得共享锁后，可以查看但是无法修改和删除数据，其他线程也还可以获取共享锁</li>\n<li>ReentrantReadWriteLock的读锁，写锁（实现读写锁ReadWriteLock接口）</li>\n<li>reentrantReadWriteLock.readLock();</li>\n<li>reentrantReadWriteLock.writeLock();</li>\n</ul>\n<ul>\n<li>读-读能共存</li>\n<li>读-写不能共存</li>\n<li>写-写不能共存</li>\n</ul>\n<ul>\n<li>读和读互不影响，读和写互斥，写和写互斥，提高读写的效率</li>\n<li>ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。</li>\n<li>读锁使用共享模式；写锁使用独占模式，换句话说，读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的</li>\n<li>当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁</li>\n<li>线程进入写锁的前提条件：没有其他线程的读锁、没有其他线程的写锁</li>\n</ul>\n<pre><code class=\"java\">import java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nclass MyCache {\n    //保证可见性\n    private volatile Map&lt;String， Object&gt; map = new HashMap&lt;&gt;();\n    //读写锁，可以在读和写时采取不同策略\n    private ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();\n    //写，读，清空\n\n    //写操作必须独占，原子 中间不允许被打断\n    public void put(String key， Object value) {\n        reentrantReadWriteLock.writeLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + &quot; 正在写入: &quot; + key);\n\n            try {\n                TimeUnit.MILLISECONDS.sleep(300);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            map.put(key， value);\n            System.out.println(Thread.currentThread().getName() + &quot; 写入完成&quot;);\n        }\n        finally {\n            reentrantReadWriteLock.writeLock().unlock();\n        }\n    }\n\n    public Object get(String key) {\n        reentrantReadWriteLock.readLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + &quot; 正在读取: &quot; + key);\n\n            try {\n                TimeUnit.MILLISECONDS.sleep(300);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            Object object = map.get(key);\n            System.out.println(Thread.currentThread().getName() + &quot; 读取完成 &quot; + object);\n            return object;\n        }\n        finally {\n            reentrantReadWriteLock.readLock().unlock();\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyCache myCache = new MyCache();\n\n        for (int i = 0; i &lt; 5; i++) {\n            int finalI = i;\n            new Thread(() -&gt; {\n                myCache.put(String.valueOf(finalI)， String.valueOf(finalI));\n            }， String.valueOf(i)).start();\n        }\n        for (int i = 0; i &lt; 5; i++) {\n            int finalI = i;\n            new Thread(() -&gt; {\n                myCache.get(String.valueOf(finalI));\n            }， String.valueOf(i+5)).start();\n        }\n        /*\n        0 正在写入: 0\n        0 写入完成\n        1 正在写入: 1\n        1 写入完成\n        2 正在写入: 2\n        2 写入完成\n        3 正在写入: 3\n        3 写入完成\n        4 正在写入: 4\n        4 写入完成\n        5 正在读取: 0\n        6 正在读取: 1\n        7 正在读取: 2\n        8 正在读取: 3\n        9 正在读取: 4\n        9 读取完成 4\n        7 读取完成 2\n        6 读取完成 1\n        8 读取完成 3\n        5 读取完成 0\n         */\n    }\n}</code></pre>\n<h2 id=\"自旋锁与非自旋锁\"><a href=\"#自旋锁与非自旋锁\" class=\"headerlink\" title=\"自旋锁与非自旋锁\"></a>自旋锁与非自旋锁</h2><ul>\n<li>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</li>\n<li>好处是减少线程上下文切换，缺点是锁被占用的时间很长的话，自旋的线程不断循环会白白消耗CPU资源</li>\n<li>java.util.concurrent的atmoic包下的类基本都是自旋锁的实现</li>\n<li>实现的原理是CAS</li>\n<li>AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功</li>\n<li>AtomicReference</li>\n</ul>\n<h2 id=\"可中断锁和不可中断锁\"><a href=\"#可中断锁和不可中断锁\" class=\"headerlink\" title=\"可中断锁和不可中断锁\"></a>可中断锁和不可中断锁</h2><p>ReentrantLock中的lockInterruptibly()方法使得线程可以在被阻塞时响应中断，比如一个线程t1通过lockInterruptibly()方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过interrupt()方法就可以立刻打断t1线程的执行，来获取t1持有的那个可重入锁。而通过ReentrantLock的lock()方法或者Synchronized持有锁的线程是不会响应其他线程的interrupt()方法的，直到该方法主动释放锁之后才会响应interrupt()方法。</p>\n<p>当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。<br>当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。<br>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>\n<pre><code class=\"java\">// 尝试获取锁，被中断会进入中断异常处理块中\n// 这货没有时间限制的尝试获取锁，和synchronized一样，但是，这货能相应中断\n//这是synchronized没有的优点，这使得程序在另外的线程没有释放锁时能自定义退出程序。\ntry {\n    lock.lockInterruptibly();\n} catch (InterruptedException e1) {\n    System.out.println(&quot;线程&quot;+t.getName()+&quot;被中断&quot;);\n    return;\n}</code></pre>\n<h1 id=\"锁优化\"><a href=\"#锁优化\" class=\"headerlink\" title=\"锁优化\"></a>锁优化</h1><h2 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h2><ul>\n<li>即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。</li>\n<li>来源于逃逸分析技术的数据支持。</li>\n<li>如果判断一段代码中堆上所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的</li>\n<li>很多同步机制不是程序员自己加的</li>\n<li>StringBuffer.append()都有同步块，锁sb对象</li>\n<li>虚拟机观测变量sb，经过逃逸分析后发现他的动态作用域限制在方法内部，sb的所有引用都不会逃逸到方法外部，其他线程无法访问，所以可以安全消除锁</li>\n</ul>\n<pre><code class=\"java\">public String concatString(String s1， String s2， String s3) {\n        return s1 + s2 + s3;\n    }\n//上面的代码在JDK5之前会转换成StringBuffer对象进行连续append\n//在JDK5之后会转换成StringBuilder对象\npublic String concatString(String s1， String s2， String s3) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(s1);\n        sb.append(s2);\n        sb.append(s3);\n        return sb.toString();\n    }</code></pre>\n<p>锁消除是发生在编译器级别的一种锁优化方式。<br>有时候我们写的代码完全不需要加锁，却执行了加锁操作。</p>\n<p>比如，StringBuffer类的append操作：</p>\n<pre><code class=\"java\">@Override\npublic synchronized StringBuffer append(String str) {\n    toStringCache = null;\n    super.append(str);\n    return this;\n}</code></pre>\n<p>从源码中可以看出，append方法用了synchronized关键词，它是线程安全的。但我们可能仅在线程内部把StringBuffer当作局部变量使用：</p>\n<pre><code class=\"java\">package com.leeib.thread;\n\npublic class Demo {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        int size = 10000;\n        for (int i = 0; i &lt; size; i++) {\n            createStringBuffer(&quot;Hyes&quot;, &quot;为分享技术而生&quot;);\n        }\n        long timeCost = System.currentTimeMillis() - start;\n        System.out.println(&quot;createStringBuffer:&quot; + timeCost + &quot; ms&quot;);\n    }\n\n    public static String createStringBuffer(String str1, String str2) {\n        StringBuffer sBuf = new StringBuffer();\n        sBuf.append(str1);// append方法是同步操作\n        sBuf.append(str2);\n        return sBuf.toString();\n    }\n}</code></pre>\n<p>代码中createStringBuffer方法中的局部对象sBuf，就只在该方法内的作用域有效，不同线程同时调用createStringBuffer()方法时，都会创建不同的sBuf对象，因此此时的append操作若是使用同步操作，就是白白浪费的系统资源。</p>\n<p>这时我们可以通过编译器将其优化，将锁消除，前提是java必须运行在server模式（server模式会比client模式作更多的优化），同时必须开启逃逸分析:</p>\n<p>-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</p>\n<p>其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除。</p>\n<blockquote>\n<p>逃逸分析：比如上面的代码，它要看sBuf是否可能逃出它的作用域？如果将sBuf作为方法的返回值进行返回，那么它在方法外部可能被当作一个全局对象使用，就有可能发生线程安全问题，这时就可以说sBuf这个对象发生逃逸了，因而不应将append操作的锁消除，但我们上面的代码没有发生锁逃逸，锁消除就可以带来一定的性能提升。</p>\n</blockquote>\n<h2 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h2><ul>\n<li>编写代码时推荐把同步块的作用访问限制得尽量小，只在共享数据的实际作用域进行同步。可以使得需要同步的操作数量尽可能变小，即使存在锁竞争，等待锁的线程也能尽快拿到锁</li>\n<li>原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环体内部，即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗</li>\n<li>例如上述的连续append，如果虚拟机探测到一串零碎的操作对同一个对象加锁。就将会把加锁同步的范围粗化到整个操作序列的外部。例如把操作扩展到三次append（）操作外部，只需要一次加锁</li>\n</ul>\n<p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽可能短，但是某些情况下，一个程序对同一个锁不间断、高频地请求、同步与释放，会消耗掉一定的系统资源，因为锁的请求、同步与释放本身会带来性能损耗，这样高频的锁请求就反而不利于系统性能的优化了，虽然单次同步操作的时间可能很短。<strong>锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。</strong></p>\n<p>一种极端的情况如下：</p>\n<pre><code class=\"java\">public void doSomethingMethod(){\n    synchronized(lock){\n        //do some thing\n    }\n    //这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕\n    synchronized(lock){\n        //do other thing\n    }\n}</code></pre>\n<p>上面的代码是有两块需要同步操作的，但在这两块需要同步操作的代码之间，需要做一些其它的工作，而这些工作只会花费很少的时间，那么我们就可以把这些工作代码放入锁内，将两个同步代码块合并成一个，以降低多次锁请求、同步、释放带来的系统性能消耗，合并后的代码如下:</p>\n<pre><code class=\"java\">public void doSomethingMethod(){\n    //进行锁粗化：整合成一次锁请求、同步、释放\n    synchronized(lock){\n        //do some thing\n        //做其它不需要同步但能很快执行完的工作\n        //do other thing\n    }\n}</code></pre>\n<blockquote>\n<p>注意：这样做是有前提的，就是中间不需要同步的代码能够很快速地完成，如果不需要同步的代码需要花很长时间，就会导致同步块的执行需要花费很长的时间，这样做也就不合理了。</p>\n</blockquote>\n<p>另一种需要锁粗化的极端的情况是：</p>\n<pre><code class=\"java\">for(int i=0;i&lt;size;i++){\n    synchronized(lock){\n    }\n}</code></pre>\n<p>上面代码每次循环都会进行锁的请求、同步与释放，看起来貌似没什么问题，且在jdk内部会对这类代码锁的请求做一些优化，但是还不如把加锁代码写在循环体的外面，这样一次锁的请求就可以达到我们的要求，除非有特殊的需要：循环需要花很长时间，但其它线程等不起，要给它们执行的机会。</p>\n<p>锁粗化后的代码如下：</p>\n<pre><code class=\"java\">synchronized(lock){\n    for(int i=0;i&lt;size;i++){\n    }\n}</code></pre>\n"},{"title":"线程基础","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"线程基础，包括线程创建终止、ThreadLocal原理、线程池、Future和Callable等","abbrlink":"b9f6280b","date":"2021-03-01T16:00:00.000Z","_content":"\n\n\n# 线程\n\n## 创建线程\n\n从原理上看两种方法本质上是一样的\n\n将该Runnable传递给Thread的target成员变量，最终调用target.run()方法\n\n```java\nprivate Runnable target;\n\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}\n```\n\n### 继承Thread类\n\nrun（）方法整个被重写\n\n```java\n//继承Thread类实现多线程\nnew Thread(() -> {\n   System.out.println(Thread.currentThread().getName()+\" start\");\n}， \"thread1\").start();\n```\n\n### 实现Runnable()接口\n\n+ 代码架构角度：代表一个任务，和线程进行区分，解耦\n+ 节约资源：新建线程的损耗大，反复利用同一个线程\n+ 扩展性，Java不允许多继承，如果继承Thread类，就不能多继承了\n\n```java\n//覆写Runnable()接口实现多线程\nRunnable runnable = () -> {\n   System.out.println(Thread.currentThread().getName()+\" start\");\n};\nnew Thread(runnable，\"thread2\").start();\n```\n\n### 通过线程池启动多线程\n\n```java\n//通过线程池启动多线程\n//创建线程池\nExecutorService executorService = Executors.newFixedThreadPool(10);\n//执行\nexecutorService.execute(runnable);\nexecutorService.execute(runnable);\nexecutorService.execute(runnable);\n//关闭连接\nexecutorService.shutdown();\n```\n\n### 覆写Callable接口实现多线程\n\n```java\n//覆写Callable接口实现多线程\nFutureTask<Integer> task = new FutureTask<>(new Callable<Integer>() {\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(Thread.currentThread().getName() + \" start\");\n        Thread.sleep(1000);\n        return 100;\n    }\n});\nnew Thread(task，\"thread3\").start();\n//一直阻塞直到结果返回\nSystem.out.println(task.get());\n```\n\n可以用于延迟计算，如执行数据库查询\n\n它认为主入口点（call)将返回一个值，并可能抛出一个异常\n\n**与Runnable的区别**\n\nRunnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果\n\nCallalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。\n\nCallable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛\n\n**Future**\n\n表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等\n\nget：如果任务已完成，get立即返回或抛异常，未完成，则阻塞直到任务完成\n\n**FutureTask**\n\n实现了Runnable，可以将他提交给Executor来执行\n\n## 启动线程\n\n### start\n\n- 启动新线程\n- 处于就绪(可运行)状态\n- 并没有运行，一旦得到cpu时间片，就开始执行run()方法\n- 不能重复执行start()方法，抛出异常：IllegalThreadStateException\n- Run方法运行结束，此线程随即终止。\n\n### run\n\nrun()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。\n\n调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。\n\n## 停止线程\n\n### 原理\n\n+ 使用interrupt来通知，而不是强制\n+ 被中断的线程拥有如何响应中断的权利，必须等待线程处理完之后主动中止，所以不应该莽撞的使用stop方法\n+ 线程就算是sleep状态，也会响应interrupt\n+ 想停止线程，要请求方、被停止方、子方法被调用方相互配合\n\n#### 常用方法\n\n**void interrupt()**\n\n设置interrupted\n\n如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并且打断标记还是false。但是对于正常进程被打断打断标记是true\n\n**static boolean interrupted()**\n\n目标对象为当前线程\n\n清除当前线程的中断状态，并返回他之前的值\n\n判断是否被打断，并且清除打断标记(设为false)\n\n由于会清除当前线程的中断状态，如果调用他时返回true，那么除非你想屏蔽这个中断，否则必须对他进行处理。可以抛出InterruptedException，或再调用interrupt来恢复中断状态\n\n**boolean isInterrupted()**\n\n判断是否被打断，不会清除打断标记\n\n返回目标线程的中断状态\n\n#### 错误的停止方法\n\n**被弃用的stop、resume方法等**\n\n会导致线程运行一半突然停止，没办法完成一个基本单位的操作\n\n资源分配戛然而止，银行批量转账10个人，只转了8个人，很难排查错误\n\n**用volatile设置boolean标记位**\n\n这样陷入阻塞时，就不会有人去唤醒他，他就不会执行到判断volatile那个变量的标志位的代码，就会一直等待\n\n### 例子\n\n#### run（）内没有sleep或wait方法时，停止线程\n\n如果不检测线程状态isInterrupted()，则调用thread.interrupt();没有任何影响\n\n```java\npublic static void main(String[] args) throws ExecutionException， InterruptedException {\n    Runnable runnable = () -> {\n        int num = 0;\n        //需要检测是否被中断，并且响应\n        for (int i = 0; i < Integer.MAX_VALUE / 2; i++) {\n            if (i % 10000 == 0) {\n                System.out.println(\"Hello + \"+i);\n            }\n            if (Thread.currentThread().isInterrupted()) {\n                System.out.println(\"被中断了\");\n                break;\n            }\n        }\n        System.out.println(\"运行结束了\");\n    };\n    Thread thread = new Thread(runnable);\n    thread.start();\n    TimeUnit.SECONDS.sleep(1);\n    thread.interrupt();\n\n}\n```\n\n#### 在线程sleep期间interrupt\n\n```java\npublic static void main(String[] args) throws ExecutionException， InterruptedException {\n    Runnable runnable = () -> {\n        int num = 0;\n        //需要检测是否被中断，并且响应\n        for (int i = 0; i < Integer.MAX_VALUE / 2; i++) {\n            System.out.println(\"Hello + \" + i);\n\n            //控制不住，因为调用后中断标志被清除了\n            if (Thread.currentThread().isInterrupted()) {\n                System.out.println(\"被中断\");\n                break;\n            }\n\n            //如果在sleep时中断，就会抛出该异常，所以就可以在catch中处理\n            //该循环会继续工作，因为catch后就执行下一轮循环\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            }\n            catch (InterruptedException e) {\n                //sleep interrupted\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"运行结束了\");\n    };\n    Thread thread = new Thread(runnable);\n    thread.start();\n    //控制interrupt时线程正在sleep\n    TimeUnit.MILLISECONDS.sleep(500);\n    thread.interrupt();\n}\n```\n\n会抛出异常：InterruptedException（sleep interrupted）\n\n会继续执行，不会中断：interrupt中断标记被清除，而且是循环，try-catch后会继续执行下一个循环\n\n### 最佳实践\n\n不应屏蔽中断请求\n\n#### 传递异常（优先选择）\n\n```java\npublic class Thread1 {\n    /*\n    catch了InterruptedException后优先选择在方法签名中抛出异常\n    反面教材：在try-catch中处理\n\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n            while (true) {\n                System.out.println(\"业务逻辑\");\n                throwInMethod();\n\n                //如果子方法使用try-catch，则下面不会有效果\n                if (Thread.currentThread().isInterrupted()) {\n                    System.out.println(\"break\");\n                    break;\n                }\n            }\n        };\n\n        //线程使用\n        Thread thread = new Thread(runnable);\n        thread.start();\n        TimeUnit.SECONDS.sleep(1);\n        thread.interrupt();\n    }\n\n    //最佳是抛出异常到方法签名\n    private static void throwInMethod() {\n        //如果用这样，则中断的时候会e.printStackTrace();但是会继续运行\n        //因为该方法不是run()方法，是底层被run()调用的方法，就导致没能响应中断，run的while循环仍然执行\n        //相当于把中断给吞掉了\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        }\n        catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n#### 抛出异常到方法签名（推荐）\n\n```java\npublic class Thread1 {\n    /*\n    catch了InterruptedException后优先选择在方法签名中抛出异常\n\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n            while (true) {\n                System.out.println(\"业务逻辑\");\n                //run方法不能抛出异常，因为顶层的run方法没有异常，子类自然不能有\n                try {\n                    throwInMethod();\n                }\n                catch (InterruptedException e) {\n                    e.printStackTrace();\n                    System.out.println(\"保存日志\");\n                    System.out.println(\"退出\");\n                    break;\n                }\n            }\n        };\n\n        //线程使用\n        Thread thread = new Thread(runnable);\n        thread.start();\n        TimeUnit.SECONDS.sleep(1);\n        thread.interrupt();\n    }\n\n    //最佳是抛出异常到方法签名\n    private static void throwInMethod() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(2);\n    }\n}\n```\n\n\n\n#### 恢复中断（不想或者无法传递时）\n\n```java\npublic class Thread1 {\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n            while (true) {\n                System.out.println(\"业务逻辑\");\n                throwInMethod();\n\n                //因为重新设置了中断状态，所以是有效的\n                if (Thread.currentThread().isInterrupted()) {\n                    System.out.println(\"break\");\n                    break;\n                }\n            }\n        };\n\n        //线程使用\n        Thread thread = new Thread(runnable);\n        thread.start();\n        TimeUnit.SECONDS.sleep(1);\n        thread.interrupt();\n    }\n\n    private static void throwInMethod() {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        }\n        catch (InterruptedException e) {\n            //恢复设置中断状态，以便于在后续执行时，仍然能够检查到刚刚发生了中断\n            Thread.currentThread().interrupt();\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 线程生命周期\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1611884091_1.png)\n\n+ NEW：初始状态，线程被构建，但是没有调用start()\n+ RUNNABLE：运行状态，将操作系统的就绪和运行状态统称为RUNNABLE；有可能正在运行，也有可能等待CPU资源\n+ BLOCKED：阻塞状态，线程阻塞与锁；在程序等待进入同步区域时，将进入这种状态；在等待一个排它锁，该事件在另外一个线程放弃这个锁时发生；只有Synchronized修饰的，而且没有拿到锁，才是BLOCKED状态，其他锁不算\n+ WAITING：无限期等待状态，当前线程需要等待其他线程通知或中断；没有设置Timeout的Object::wait()；没有设置Timeout的Thread::join()；LockSupport::park()\n+ TIME_WAITING：超时等待状态，可以在指定的时间自行返回；Thread::sleep()；设置Timeout的Object::wait()；设置Timeout的Thread::join()；LockSupport::parkUntil()\n+ TERMINATED：终止状态，当前线程已经执行完毕\n\n## Object相关方法\n\n+ wait、notify、notifyAll定义在Object中，因为是锁级别的\n\n+ wait需要在同步代码块内使用，用户必须先拥有monitor\n+ wait()的作用是**让当前线程进入等待状态**，同时，wait()也会**让当前线程释放它所持有的锁**。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)\n+ wait(long timeout)让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。\n+ 因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出IllegalMonitorStateException（正在等待的对象没有锁））\n\n+ notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程（唤醒哪个取决于JVM），而notifyAll()是唤醒所有的线程\n+ notify也要在synchronized使用，应该指定对象，t1.notify()，通知t1对象的等待池里的线程使一个线程进入锁定池，然后与锁定池中的线程争夺锁。那么为什么要在synchronized使用呢？ t1.notify()需要通知一个等待池中的线程，那么这时我们必须得获得t1的监视器（需要使用synchronized），才能对其操作，t1.notify()程序只是知道要对t1操作，但是是否可以操作与是否可以获得t1锁关联的监视器有关。\n\n**唤醒时机**\n\n+ notify()本线程\n+ notifyAll()\n+ wait(long timeout)超时时间达到\n+ 线程自身调用interrupt()\n\n```java\nimport java.util.concurrent.TimeUnit;\n\n\n/*\nThread-0线程开始执行！\nThread-1线程开始执行！\n线程Thread-1获取到了锁！\n线程Thread-0获取到了锁！\n */\npublic class MainTest {\n    private static Object object = new Object();\n\n    static class Thread1 extends Thread {\n        @Override\n        public void run() {\n            synchronized (object) {\n                System.out.println(Thread.currentThread().getName()+\"线程开始执行！\");\n                try {\n                    object.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"线程\"+Thread.currentThread().getName()+\"获取到了锁！\");\n            }\n        }\n    }\n    static class Thread2 extends Thread {\n        @Override\n        public void run() {\n            synchronized (object) {\n                System.out.println(Thread.currentThread().getName()+\"线程开始执行！\");\n                object.notify();\n                System.out.println(\"线程\"+Thread.currentThread().getName()+\"获取到了锁！\");\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread1 thread1 = new Thread1();\n        Thread2 thread2 = new Thread2();\n        thread1.start();\n        TimeUnit.MILLISECONDS.sleep(100);\n        thread2.start();\n    }\n}\n```\n\n## 线程属性\n\n- 线程Id\n- 线程名称\n- isDaemon(true代表是守护线程）\n    - 是给用户线程提供服务的\n    - 默认情况下，Java进程会等待所有线程都运行结束，才会结束\n    - 守护进程，如果所有非守护进程结束，守护进程也都结束了(垃圾回收器)\n    - 如后台记录操作日志，监控内存，垃圾回收\n    - thread1.setDaemon(true);\n- priority（优先级）\n    - 10个优先级，默认是5\n    - 优先级高度依赖于操作系统的优先级，Java映射过去的\n    - 优先级会被操作系统改变\n\n## Thread方法\n\n### sleep()\n\n+ 让当前执行的线程休眠n毫秒， 休眠时让出 cpu 的时间片给其它线程\n+ 可以调用interrupt()方法唤醒，但是会抛出异常：InterruptedException，并且会清除中断状态\n+ **让线程进入Waiting状态，并且不占用CPU资源（阻塞），但不释放锁**\n+ **休眠期间被中断，则抛出异常并清除中断状态**\n\n### join()\n\n+ 等待线程运行结束，可以控制线程的同步\n+ 因为新的线程加入了我们，所以我们要等他执行完再出发\n+ main等待thread1执行完毕\n+ 源码调用wait()一直休眠，但每一个线程在执行完run()都会执行notifyAll()\n+ **主线程在waiting状态**\n\n```java\n/*\n开始等待所有子线程执行\nThread-0执行\nThread-1执行\n所有子线程执行完毕\n */\npublic class MainTest {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"执行\");\n        });\n        Thread thread2 = new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"执行\");\n        });\n\n        thread1.start();\n        thread2.start();\n        System.out.println(\"开始等待所有子线程执行\");\n        thread1.join();\n        thread2.join();\n        System.out.println(\"所有子线程执行完毕\");\n    }\n}\n```\n\n**等价代码**\n\n```java\nimport java.util.concurrent.TimeUnit;\n\npublic class MainTest {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"执行\");\n        });\n\n        thread.start();\n        System.out.println(\"开始等待所有子线程执行\");\n//        thread.join();\n        //等价于以下语句：\n        /*\n        synchronized只是为了能调用wait()\n        主线程执行到下面语句，会阻塞，直到thread线程执行完，隐式的调用了notifyAll()  \n         */\n        synchronized (thread){\n            thread.wait();\n        }\n        System.out.println(\"所有子线程执行完毕\");\n    }\n}\n```\n\n### yield()\n\n+ 状态依旧是RUNNING状态\n+ 提示线程调度器 让出当前线程对CPU的使用，具体要看操作系统实现\n+ 让当前的线程暂停，但是不阻塞，从运行状态变为就绪状态\n+ 让CPU重新调度，但是不能决定CPU\n+ 不会释放锁\n+ 为了稳定性，实际开发不使用，但是很多并发包使用\n\n# ThreadLocal\n\n- ThreadLocal叫做线程本地变量或线程本地存储。为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。让某个需要使用的对象在线程间隔离（每个线程都有自己的独立的对象）\n- initialValue：在ThreadLocal第一次get时就把对象给初始化出来，对象的初始化时机可以由我们控制\n- set：如果需要保存到ThreadLocal里的对象的时机不由我们随意控制，例如拦截器里的用户信息，就用set存放\n\n## 原理\n\n每个Thread中都有一个ThreadLocalMap \n\n```java\npublic class Thread implements Runnable {\n\tThreadLocal.ThreadLocalMap threadLocals = null;\n}\n```\n\n![image-20210529150659281](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529150659281.png)\n\n\n\n**ThreadLocalMap** \n\n+ 是一个Entry数组，Entry是一个键值对，键是该ThreadLocal，值是实际存储的对象\n+ 遇到冲突采取的是线性探测法\n\n```java\nclass ThreadLocalMap{\n    static class Entry extends WeakReference<ThreadLocal<?>> {\n        Object value;\n    }\n\n    private Entry[] table;\n\n    private void set(ThreadLocal<?> key, Object value) {\n\n    }\n}\n```\n\n### initialValue()\n\n一般来说重写该方法\n\n```java\nprotected T initialValue() {\n    return null;\n}\n```\n\n### set()\n\n```java\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    //键值对：(this， value)\n    if (map != null)\n        map.set(this， value);\n    else\n        createMap(t， value);\n}\n```\n\n### get()\n\n```java\npublic T get() {\n    //先找到当前线程 再找到当前线程的ThreadLocalMap\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t); \n    if (map != null) {\n        //key是当前threadLocal引用\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n\n//如果get为null，则initialValue()\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this， value);\n    else\n        createMap(t， value);\n    return value;\n}\n```\n\n### remove()\n\n```java\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n```\n\n## 内存泄漏\n\n+ 可能导致内存泄漏\n+ 内存泄漏：某个对象不再有用，但是占用的内存却不能被回收\n+ ThreadLocalMap中的每个Entry都是一个对key的弱引用，对value的强引用\n+ 正常情况下，线程终止，则保存在ThreadLocalMap里的value会被回收\n+ 但是线程不终止（例如线程池），那么value就不会被回收：key会回收，因为key是弱引用，垃圾回收会回收，key为null、Thread->ThreadLocalMap->Entry(key为null)->value。\n+ JDK考虑过了，在set、remove、rehash方法中会扫描key为null的Entry，并把value设置为null，但如果一个线程中ThreadLocal不被调用，就不会执行上述操作\n+ 阿里规约：在使用完ThreadLocal之后，主动调用remove方法：UserContextHolder.holder.remove();\n\n## 应用场景\n\n### SimpleDateFormat\n\n- 初始版本：使用线程池（创建很多个对象，效率低）\n- 把SimpleDateFormat当静态使用（会出现并发安全问题）\n- 用ThreadLocal实现\n\n```java\npublic class ThreadLocalUsage03 {\n    public static ThreadLocal<SimpleDateFormat> local = new ThreadLocal<SimpleDateFormat>(){\n        @Override\n        protected SimpleDateFormat initialValue() {\n            return new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n        }\n    };\n    public static ExecutorService executorService = Executors.newFixedThreadPool(10);\n\n    public String date(int seconds) {\n        //参数单位是ms，从1970.1.1 00:00:00 GMT计时\n        Date date = new Date(1000L * seconds);\n        return local.get().format(date);\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 1000; i++) {\n            int finalI = i;\n            executorService.submit(() -> {\n                String date = new ThreadLocalUsage03().date(finalI);\n                System.out.println(date);\n            });\n        }\n        executorService.shutdown();\n    }\n}\n```\n\n### 传递用户信息\n\n不同请求（不同线程）user对象不同\n\n即这些信息在同一个线程中相同，但是不同线程中使用的业务内容是不同的\n\n在线程生命周期内，都可以通过这个静态ThreadLocal实例的get()方法取得自己set过的那个对象，避免了将这个对象（例如user对象）作为参数传递的麻烦\n\n```java\npublic class UserContextHolder {\n    public static ThreadLocal<User> holder = new ThreadLocal<>();\n    public static void main(String[] args) {\n        new Service1().process();\n    }\n}\n\nclass Service1 {\n    public void process() {\n        User user = new User(\"张三\"， \"123456\");\n        UserContextHolder.holder.set(user);\n        System.out.println(\"Service1:\"+user);\n        new Service2().process();\n    }\n}\n\nclass Service2 {\n    public void process() {\n        User user = UserContextHolder.holder.get();\n        System.out.println(\"Service2:\"+user);\n        new Service3().process();\n    }\n}\nclass Service3 {\n    public void process() {\n        User user = UserContextHolder.holder.get();\n        System.out.println(\"Service3:\"+user);\n    }\n}\n```\n\n# 线程池\n\n## 概述\n\n### 优点\n\n+ 重用现有的线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销\n+ 当请求到达时，工作线程已经存在，不会由于等待创建线程而延迟任务的执行\n+ 通过适当调整线程池的大小，可以创建足够多的线程使处理器保存忙碌状态，又可以防止过多线程相互竞争资源使得应用程序耗尽内存\n\n### 继承体系\n\n<img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201202211516638.png\" alt=\"image-20201202211516638\" style=\"zoom:50%;\" />\n\nThreadPoolExecutor是实际使用到的类，通过他的构造函数来实例化一个对象，并根据自己需求定制\n\n### 关闭线程池\n\n+ shutdown：将执行平缓的关闭过程，不再接受新的任务，同时等待已提交任务执行完成，包括那些还未开始执行的任务\n+ shutdownNow：执行粗暴给关闭过程，立刻关闭！对正在执行的线程执行中断interrupt；不再启动队列中尚未开始的任务，返回在等待中的队列列表\n\n## 运行规则\n\n+ 如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程运行新任务\n+ 如果线程数大于等于corePoolSize，但小于maximumPoolSize，则将任务放入workQueue队列\n+ 如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务\n+ 如果队列已满，并且线程数大于等于maxPoolSize，则拒绝该任务\n+ 当一个线程无事可做，而且超过keepAliveTime，而且当前运行线程数大于corePoolSize则该线程停止。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529104616059.png\" alt=\"image-20210529104616059\" style=\"zoom: 67%;\" />\n\n## 七大核心参数\n\n| 参数            | 描述             | 具体说明                                                     |\n| --------------- | ---------------- | ------------------------------------------------------------ |\n| corePoolSize    | 核心线程数       | 线程池中的常驻核心线程数，当线程池数量到达corePoolSize后，就会把到达的任务放到缓存队列当中 |\n| maximumPoolSize | 最大线程数       | 线程池能够容纳同时执行的最大线程数，必须大于等于1(当corePoolSize满了，workQueue也满了，则会扩容) |\n| keepAliveTime   | 多余线程存活时间 | 多余的空闲线程的存活时间，当前线程池数量超过corePoolSize时，当空闲时间到达keepAliveTime值时，会将线程销毁到corePoolSize数量 |\n| TimeUnit unit   | 设置时间单位     |                                                              |\n| workQueue       | 阻塞队列         | BlockingQueue<Runnable> workQueue                            |\n| threadFactory   | 线程工厂         | ThreadFactory threadFactory，表示生成线程池中工作线程的线程工厂 一般默认即可 |\n| Handler         | 拒绝策略         | RejectedExecutionHandler handler 拒绝策略，当maximumPoolSize已经满了，则拒绝 |\n\n## 四种拒绝策略\n\n+ 如果线程池被关闭则拒绝\n+ 当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时\n\n### AbortPolicy（终止）\n\n+ 默认的拒绝策略\n+ 抛出未检查的RejectExecution-Exception\n+ 调用者可以捕获这个异常，然后根据需求编写自己的处理代码\n+ 线程池的默认拒绝策略为AbortPolicy，即丢弃任务并抛出RejectedExecutionException异常\n+ 这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。\n\n### DiscardPolicy（抛弃）\n\n+ 丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。\n+ 使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。\n\n### DiscardOldestPolicy（抛弃最旧）\n\n+ 丢弃队列最前面的任务，然后重新提交被拒绝的任务。\n+ 此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。\n\n### CallerRunsPolicy\n\n既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，从而降低新任务的流量\n\n如果任务被拒绝了，则由调用线程（提交任务的线程）直接执行此任务\n\n## 自定义线程池\n\n不允许在应用中显示创建线程，都是得使用线程池\n\n生产实践中不允许适用`Executors`去创建，因为他底层是`new LinkedBlockingQueue<Runnable>())`是无界队列，如果所有工作行程都处于忙碌状态，那么任务将在队列中等候，如果任务持续快速地到达，并且超过了线程池处理他们的速度，那么队列将无限制增加，可能会堆积大量请求，导致`OOM`\n\n### 线程池官方实现\n\n![image-20210529110357928](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529110357928.png)\n\n```java\n//适用于长期执行的任务，性能好很多 阻塞队列可能很大，会OOM\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads， nThreads，\n                                      0L， TimeUnit.MILLISECONDS，\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n\n```java\n//适用于一个任务一个任务执行的场景 阻塞队列可能很大，会OOM\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1， 1，\n                                0L， TimeUnit.MILLISECONDS，\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n\n```java\n//适用执行很多短期异步的小程序或负载较轻的服务器\n//任务数量特别多时，就会创建很多的线程，会OOM\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0， Integer.MAX_VALUE，\n                                  60L， TimeUnit.SECONDS，\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n```java\n// executorService.schedule(()->{System.out.println(\"1\");}, 5, TimeUnit.SECONDS);\n// 支持定时，周期执行任务\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize， Integer.MAX_VALUE， 0， NANOSECONDS，\n              new DelayedWorkQueue());\n    }\n```\n\n### 设置maximumPoolSize\n\n首先分析计算环境、资源预算，例如部署的系统有多少CPU：\n\n```\nSystem.out.println(Runtime.getRuntime().availableProcessors());\n```\n\n系统有多大的内存：计算每个任务对内存的需求量，用总内存/需求量，就得到线程池上限\n\n是否需像JDBC连接等稀缺资源：如果每个任务都需要一个数据库连接，那么连接池大小限制了线程池的大小\n\n**CPU密集型**\n\n线程池大小应该为处理器个数+1，能实现最优的使用率\n\n即使线程偶尔由于缺页故障等原因暂停时，额外的线程也能保证CPU的时钟周期不会被浪费\n\n**IO密集型**\n\n并不是一直在执行任务，则应该配置尽可能多的线程，如CPU核数*2\n\n线程不会一直执行，线程池规模应更大\n\n必须估算任务的等待时间与计算时间的比值\n\n线程池最优大小= CPU核数 * CPU利用率 * （1 + 任务等待时间/运行时间）\n\n# Future和Callable\n\n## 概述\n\n### Callable\n\n+ Runnable不能返回一个返回值\n+ 也不能抛出受查异常，只能try-catch。因为Runnable接口中run()方法没有抛出异常\n+ Callable接口类似Runnable，代表一个被其他线程执行的任务\n\n```java\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n```\n\n### Future\n\n+ 可以用Future.get()来获取Callable的执行结果；用Future.isDone()来判断任务是否执行完成\n+ 在call()未执行完毕之前，调用get()的线程会被阻塞，直到call()方法返回了结果，future.get()才会得到结果\n+ Futute是一个存储器，存储了call()这个任务的结果\n+ 例如给线程池提交我们的任务，提交后线程池会立刻返回给我们一个空的Future容器。当线程的任务一旦执行完毕，也就是当我们可以获取结果时，线程池就会把结果填入该Future中，便可以从原先那个Future获得任务执行的结果\n\n**ExecutorService**\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    ExecutorService service = Executors.newFixedThreadPool(10);\n    Future<Integer> future = service.submit(new CallableTask());\n    System.out.println(future.get()); // 会阻塞3秒\n    service.shutdown();\n\n}\n\nstatic class CallableTask implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        Thread.sleep(3000);\n        return new Random().nextInt();\n    }\n}\n```\n\n**FutureTask**\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    Task task = new Task();\n    FutureTask<Integer> futureTask = new FutureTask<>(task);\n    new Thread(futureTask).start();\n    System.out.println(futureTask.get());\n}\n\nstatic class Task implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        Thread.sleep(3000);\n        return new Random().nextInt();\n    }\n}\n```","source":"_posts/Java语言/Java多线程/2.线程基础.md","raw":"---\ntitle: 线程基础\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 线程基础，包括线程创建终止、ThreadLocal原理、线程池、Future和Callable等\ncategories: Java多线程\ntags:\n  - 线程\n  - ThreadLocal\n  - 线程池\nabbrlink: b9f6280b\ndate: 2021-03-02 00:00:00\n---\n\n\n\n# 线程\n\n## 创建线程\n\n从原理上看两种方法本质上是一样的\n\n将该Runnable传递给Thread的target成员变量，最终调用target.run()方法\n\n```java\nprivate Runnable target;\n\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}\n```\n\n### 继承Thread类\n\nrun（）方法整个被重写\n\n```java\n//继承Thread类实现多线程\nnew Thread(() -> {\n   System.out.println(Thread.currentThread().getName()+\" start\");\n}， \"thread1\").start();\n```\n\n### 实现Runnable()接口\n\n+ 代码架构角度：代表一个任务，和线程进行区分，解耦\n+ 节约资源：新建线程的损耗大，反复利用同一个线程\n+ 扩展性，Java不允许多继承，如果继承Thread类，就不能多继承了\n\n```java\n//覆写Runnable()接口实现多线程\nRunnable runnable = () -> {\n   System.out.println(Thread.currentThread().getName()+\" start\");\n};\nnew Thread(runnable，\"thread2\").start();\n```\n\n### 通过线程池启动多线程\n\n```java\n//通过线程池启动多线程\n//创建线程池\nExecutorService executorService = Executors.newFixedThreadPool(10);\n//执行\nexecutorService.execute(runnable);\nexecutorService.execute(runnable);\nexecutorService.execute(runnable);\n//关闭连接\nexecutorService.shutdown();\n```\n\n### 覆写Callable接口实现多线程\n\n```java\n//覆写Callable接口实现多线程\nFutureTask<Integer> task = new FutureTask<>(new Callable<Integer>() {\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(Thread.currentThread().getName() + \" start\");\n        Thread.sleep(1000);\n        return 100;\n    }\n});\nnew Thread(task，\"thread3\").start();\n//一直阻塞直到结果返回\nSystem.out.println(task.get());\n```\n\n可以用于延迟计算，如执行数据库查询\n\n它认为主入口点（call)将返回一个值，并可能抛出一个异常\n\n**与Runnable的区别**\n\nRunnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果\n\nCallalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。\n\nCallable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛\n\n**Future**\n\n表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等\n\nget：如果任务已完成，get立即返回或抛异常，未完成，则阻塞直到任务完成\n\n**FutureTask**\n\n实现了Runnable，可以将他提交给Executor来执行\n\n## 启动线程\n\n### start\n\n- 启动新线程\n- 处于就绪(可运行)状态\n- 并没有运行，一旦得到cpu时间片，就开始执行run()方法\n- 不能重复执行start()方法，抛出异常：IllegalThreadStateException\n- Run方法运行结束，此线程随即终止。\n\n### run\n\nrun()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。\n\n调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。\n\n## 停止线程\n\n### 原理\n\n+ 使用interrupt来通知，而不是强制\n+ 被中断的线程拥有如何响应中断的权利，必须等待线程处理完之后主动中止，所以不应该莽撞的使用stop方法\n+ 线程就算是sleep状态，也会响应interrupt\n+ 想停止线程，要请求方、被停止方、子方法被调用方相互配合\n\n#### 常用方法\n\n**void interrupt()**\n\n设置interrupted\n\n如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并且打断标记还是false。但是对于正常进程被打断打断标记是true\n\n**static boolean interrupted()**\n\n目标对象为当前线程\n\n清除当前线程的中断状态，并返回他之前的值\n\n判断是否被打断，并且清除打断标记(设为false)\n\n由于会清除当前线程的中断状态，如果调用他时返回true，那么除非你想屏蔽这个中断，否则必须对他进行处理。可以抛出InterruptedException，或再调用interrupt来恢复中断状态\n\n**boolean isInterrupted()**\n\n判断是否被打断，不会清除打断标记\n\n返回目标线程的中断状态\n\n#### 错误的停止方法\n\n**被弃用的stop、resume方法等**\n\n会导致线程运行一半突然停止，没办法完成一个基本单位的操作\n\n资源分配戛然而止，银行批量转账10个人，只转了8个人，很难排查错误\n\n**用volatile设置boolean标记位**\n\n这样陷入阻塞时，就不会有人去唤醒他，他就不会执行到判断volatile那个变量的标志位的代码，就会一直等待\n\n### 例子\n\n#### run（）内没有sleep或wait方法时，停止线程\n\n如果不检测线程状态isInterrupted()，则调用thread.interrupt();没有任何影响\n\n```java\npublic static void main(String[] args) throws ExecutionException， InterruptedException {\n    Runnable runnable = () -> {\n        int num = 0;\n        //需要检测是否被中断，并且响应\n        for (int i = 0; i < Integer.MAX_VALUE / 2; i++) {\n            if (i % 10000 == 0) {\n                System.out.println(\"Hello + \"+i);\n            }\n            if (Thread.currentThread().isInterrupted()) {\n                System.out.println(\"被中断了\");\n                break;\n            }\n        }\n        System.out.println(\"运行结束了\");\n    };\n    Thread thread = new Thread(runnable);\n    thread.start();\n    TimeUnit.SECONDS.sleep(1);\n    thread.interrupt();\n\n}\n```\n\n#### 在线程sleep期间interrupt\n\n```java\npublic static void main(String[] args) throws ExecutionException， InterruptedException {\n    Runnable runnable = () -> {\n        int num = 0;\n        //需要检测是否被中断，并且响应\n        for (int i = 0; i < Integer.MAX_VALUE / 2; i++) {\n            System.out.println(\"Hello + \" + i);\n\n            //控制不住，因为调用后中断标志被清除了\n            if (Thread.currentThread().isInterrupted()) {\n                System.out.println(\"被中断\");\n                break;\n            }\n\n            //如果在sleep时中断，就会抛出该异常，所以就可以在catch中处理\n            //该循环会继续工作，因为catch后就执行下一轮循环\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            }\n            catch (InterruptedException e) {\n                //sleep interrupted\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"运行结束了\");\n    };\n    Thread thread = new Thread(runnable);\n    thread.start();\n    //控制interrupt时线程正在sleep\n    TimeUnit.MILLISECONDS.sleep(500);\n    thread.interrupt();\n}\n```\n\n会抛出异常：InterruptedException（sleep interrupted）\n\n会继续执行，不会中断：interrupt中断标记被清除，而且是循环，try-catch后会继续执行下一个循环\n\n### 最佳实践\n\n不应屏蔽中断请求\n\n#### 传递异常（优先选择）\n\n```java\npublic class Thread1 {\n    /*\n    catch了InterruptedException后优先选择在方法签名中抛出异常\n    反面教材：在try-catch中处理\n\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n            while (true) {\n                System.out.println(\"业务逻辑\");\n                throwInMethod();\n\n                //如果子方法使用try-catch，则下面不会有效果\n                if (Thread.currentThread().isInterrupted()) {\n                    System.out.println(\"break\");\n                    break;\n                }\n            }\n        };\n\n        //线程使用\n        Thread thread = new Thread(runnable);\n        thread.start();\n        TimeUnit.SECONDS.sleep(1);\n        thread.interrupt();\n    }\n\n    //最佳是抛出异常到方法签名\n    private static void throwInMethod() {\n        //如果用这样，则中断的时候会e.printStackTrace();但是会继续运行\n        //因为该方法不是run()方法，是底层被run()调用的方法，就导致没能响应中断，run的while循环仍然执行\n        //相当于把中断给吞掉了\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        }\n        catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n#### 抛出异常到方法签名（推荐）\n\n```java\npublic class Thread1 {\n    /*\n    catch了InterruptedException后优先选择在方法签名中抛出异常\n\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n            while (true) {\n                System.out.println(\"业务逻辑\");\n                //run方法不能抛出异常，因为顶层的run方法没有异常，子类自然不能有\n                try {\n                    throwInMethod();\n                }\n                catch (InterruptedException e) {\n                    e.printStackTrace();\n                    System.out.println(\"保存日志\");\n                    System.out.println(\"退出\");\n                    break;\n                }\n            }\n        };\n\n        //线程使用\n        Thread thread = new Thread(runnable);\n        thread.start();\n        TimeUnit.SECONDS.sleep(1);\n        thread.interrupt();\n    }\n\n    //最佳是抛出异常到方法签名\n    private static void throwInMethod() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(2);\n    }\n}\n```\n\n\n\n#### 恢复中断（不想或者无法传递时）\n\n```java\npublic class Thread1 {\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n            while (true) {\n                System.out.println(\"业务逻辑\");\n                throwInMethod();\n\n                //因为重新设置了中断状态，所以是有效的\n                if (Thread.currentThread().isInterrupted()) {\n                    System.out.println(\"break\");\n                    break;\n                }\n            }\n        };\n\n        //线程使用\n        Thread thread = new Thread(runnable);\n        thread.start();\n        TimeUnit.SECONDS.sleep(1);\n        thread.interrupt();\n    }\n\n    private static void throwInMethod() {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        }\n        catch (InterruptedException e) {\n            //恢复设置中断状态，以便于在后续执行时，仍然能够检查到刚刚发生了中断\n            Thread.currentThread().interrupt();\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 线程生命周期\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1611884091_1.png)\n\n+ NEW：初始状态，线程被构建，但是没有调用start()\n+ RUNNABLE：运行状态，将操作系统的就绪和运行状态统称为RUNNABLE；有可能正在运行，也有可能等待CPU资源\n+ BLOCKED：阻塞状态，线程阻塞与锁；在程序等待进入同步区域时，将进入这种状态；在等待一个排它锁，该事件在另外一个线程放弃这个锁时发生；只有Synchronized修饰的，而且没有拿到锁，才是BLOCKED状态，其他锁不算\n+ WAITING：无限期等待状态，当前线程需要等待其他线程通知或中断；没有设置Timeout的Object::wait()；没有设置Timeout的Thread::join()；LockSupport::park()\n+ TIME_WAITING：超时等待状态，可以在指定的时间自行返回；Thread::sleep()；设置Timeout的Object::wait()；设置Timeout的Thread::join()；LockSupport::parkUntil()\n+ TERMINATED：终止状态，当前线程已经执行完毕\n\n## Object相关方法\n\n+ wait、notify、notifyAll定义在Object中，因为是锁级别的\n\n+ wait需要在同步代码块内使用，用户必须先拥有monitor\n+ wait()的作用是**让当前线程进入等待状态**，同时，wait()也会**让当前线程释放它所持有的锁**。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)\n+ wait(long timeout)让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。\n+ 因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出IllegalMonitorStateException（正在等待的对象没有锁））\n\n+ notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程（唤醒哪个取决于JVM），而notifyAll()是唤醒所有的线程\n+ notify也要在synchronized使用，应该指定对象，t1.notify()，通知t1对象的等待池里的线程使一个线程进入锁定池，然后与锁定池中的线程争夺锁。那么为什么要在synchronized使用呢？ t1.notify()需要通知一个等待池中的线程，那么这时我们必须得获得t1的监视器（需要使用synchronized），才能对其操作，t1.notify()程序只是知道要对t1操作，但是是否可以操作与是否可以获得t1锁关联的监视器有关。\n\n**唤醒时机**\n\n+ notify()本线程\n+ notifyAll()\n+ wait(long timeout)超时时间达到\n+ 线程自身调用interrupt()\n\n```java\nimport java.util.concurrent.TimeUnit;\n\n\n/*\nThread-0线程开始执行！\nThread-1线程开始执行！\n线程Thread-1获取到了锁！\n线程Thread-0获取到了锁！\n */\npublic class MainTest {\n    private static Object object = new Object();\n\n    static class Thread1 extends Thread {\n        @Override\n        public void run() {\n            synchronized (object) {\n                System.out.println(Thread.currentThread().getName()+\"线程开始执行！\");\n                try {\n                    object.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"线程\"+Thread.currentThread().getName()+\"获取到了锁！\");\n            }\n        }\n    }\n    static class Thread2 extends Thread {\n        @Override\n        public void run() {\n            synchronized (object) {\n                System.out.println(Thread.currentThread().getName()+\"线程开始执行！\");\n                object.notify();\n                System.out.println(\"线程\"+Thread.currentThread().getName()+\"获取到了锁！\");\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread1 thread1 = new Thread1();\n        Thread2 thread2 = new Thread2();\n        thread1.start();\n        TimeUnit.MILLISECONDS.sleep(100);\n        thread2.start();\n    }\n}\n```\n\n## 线程属性\n\n- 线程Id\n- 线程名称\n- isDaemon(true代表是守护线程）\n    - 是给用户线程提供服务的\n    - 默认情况下，Java进程会等待所有线程都运行结束，才会结束\n    - 守护进程，如果所有非守护进程结束，守护进程也都结束了(垃圾回收器)\n    - 如后台记录操作日志，监控内存，垃圾回收\n    - thread1.setDaemon(true);\n- priority（优先级）\n    - 10个优先级，默认是5\n    - 优先级高度依赖于操作系统的优先级，Java映射过去的\n    - 优先级会被操作系统改变\n\n## Thread方法\n\n### sleep()\n\n+ 让当前执行的线程休眠n毫秒， 休眠时让出 cpu 的时间片给其它线程\n+ 可以调用interrupt()方法唤醒，但是会抛出异常：InterruptedException，并且会清除中断状态\n+ **让线程进入Waiting状态，并且不占用CPU资源（阻塞），但不释放锁**\n+ **休眠期间被中断，则抛出异常并清除中断状态**\n\n### join()\n\n+ 等待线程运行结束，可以控制线程的同步\n+ 因为新的线程加入了我们，所以我们要等他执行完再出发\n+ main等待thread1执行完毕\n+ 源码调用wait()一直休眠，但每一个线程在执行完run()都会执行notifyAll()\n+ **主线程在waiting状态**\n\n```java\n/*\n开始等待所有子线程执行\nThread-0执行\nThread-1执行\n所有子线程执行完毕\n */\npublic class MainTest {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"执行\");\n        });\n        Thread thread2 = new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"执行\");\n        });\n\n        thread1.start();\n        thread2.start();\n        System.out.println(\"开始等待所有子线程执行\");\n        thread1.join();\n        thread2.join();\n        System.out.println(\"所有子线程执行完毕\");\n    }\n}\n```\n\n**等价代码**\n\n```java\nimport java.util.concurrent.TimeUnit;\n\npublic class MainTest {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"执行\");\n        });\n\n        thread.start();\n        System.out.println(\"开始等待所有子线程执行\");\n//        thread.join();\n        //等价于以下语句：\n        /*\n        synchronized只是为了能调用wait()\n        主线程执行到下面语句，会阻塞，直到thread线程执行完，隐式的调用了notifyAll()  \n         */\n        synchronized (thread){\n            thread.wait();\n        }\n        System.out.println(\"所有子线程执行完毕\");\n    }\n}\n```\n\n### yield()\n\n+ 状态依旧是RUNNING状态\n+ 提示线程调度器 让出当前线程对CPU的使用，具体要看操作系统实现\n+ 让当前的线程暂停，但是不阻塞，从运行状态变为就绪状态\n+ 让CPU重新调度，但是不能决定CPU\n+ 不会释放锁\n+ 为了稳定性，实际开发不使用，但是很多并发包使用\n\n# ThreadLocal\n\n- ThreadLocal叫做线程本地变量或线程本地存储。为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。让某个需要使用的对象在线程间隔离（每个线程都有自己的独立的对象）\n- initialValue：在ThreadLocal第一次get时就把对象给初始化出来，对象的初始化时机可以由我们控制\n- set：如果需要保存到ThreadLocal里的对象的时机不由我们随意控制，例如拦截器里的用户信息，就用set存放\n\n## 原理\n\n每个Thread中都有一个ThreadLocalMap \n\n```java\npublic class Thread implements Runnable {\n\tThreadLocal.ThreadLocalMap threadLocals = null;\n}\n```\n\n![image-20210529150659281](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529150659281.png)\n\n\n\n**ThreadLocalMap** \n\n+ 是一个Entry数组，Entry是一个键值对，键是该ThreadLocal，值是实际存储的对象\n+ 遇到冲突采取的是线性探测法\n\n```java\nclass ThreadLocalMap{\n    static class Entry extends WeakReference<ThreadLocal<?>> {\n        Object value;\n    }\n\n    private Entry[] table;\n\n    private void set(ThreadLocal<?> key, Object value) {\n\n    }\n}\n```\n\n### initialValue()\n\n一般来说重写该方法\n\n```java\nprotected T initialValue() {\n    return null;\n}\n```\n\n### set()\n\n```java\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    //键值对：(this， value)\n    if (map != null)\n        map.set(this， value);\n    else\n        createMap(t， value);\n}\n```\n\n### get()\n\n```java\npublic T get() {\n    //先找到当前线程 再找到当前线程的ThreadLocalMap\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t); \n    if (map != null) {\n        //key是当前threadLocal引用\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n\n//如果get为null，则initialValue()\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this， value);\n    else\n        createMap(t， value);\n    return value;\n}\n```\n\n### remove()\n\n```java\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n```\n\n## 内存泄漏\n\n+ 可能导致内存泄漏\n+ 内存泄漏：某个对象不再有用，但是占用的内存却不能被回收\n+ ThreadLocalMap中的每个Entry都是一个对key的弱引用，对value的强引用\n+ 正常情况下，线程终止，则保存在ThreadLocalMap里的value会被回收\n+ 但是线程不终止（例如线程池），那么value就不会被回收：key会回收，因为key是弱引用，垃圾回收会回收，key为null、Thread->ThreadLocalMap->Entry(key为null)->value。\n+ JDK考虑过了，在set、remove、rehash方法中会扫描key为null的Entry，并把value设置为null，但如果一个线程中ThreadLocal不被调用，就不会执行上述操作\n+ 阿里规约：在使用完ThreadLocal之后，主动调用remove方法：UserContextHolder.holder.remove();\n\n## 应用场景\n\n### SimpleDateFormat\n\n- 初始版本：使用线程池（创建很多个对象，效率低）\n- 把SimpleDateFormat当静态使用（会出现并发安全问题）\n- 用ThreadLocal实现\n\n```java\npublic class ThreadLocalUsage03 {\n    public static ThreadLocal<SimpleDateFormat> local = new ThreadLocal<SimpleDateFormat>(){\n        @Override\n        protected SimpleDateFormat initialValue() {\n            return new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n        }\n    };\n    public static ExecutorService executorService = Executors.newFixedThreadPool(10);\n\n    public String date(int seconds) {\n        //参数单位是ms，从1970.1.1 00:00:00 GMT计时\n        Date date = new Date(1000L * seconds);\n        return local.get().format(date);\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 1000; i++) {\n            int finalI = i;\n            executorService.submit(() -> {\n                String date = new ThreadLocalUsage03().date(finalI);\n                System.out.println(date);\n            });\n        }\n        executorService.shutdown();\n    }\n}\n```\n\n### 传递用户信息\n\n不同请求（不同线程）user对象不同\n\n即这些信息在同一个线程中相同，但是不同线程中使用的业务内容是不同的\n\n在线程生命周期内，都可以通过这个静态ThreadLocal实例的get()方法取得自己set过的那个对象，避免了将这个对象（例如user对象）作为参数传递的麻烦\n\n```java\npublic class UserContextHolder {\n    public static ThreadLocal<User> holder = new ThreadLocal<>();\n    public static void main(String[] args) {\n        new Service1().process();\n    }\n}\n\nclass Service1 {\n    public void process() {\n        User user = new User(\"张三\"， \"123456\");\n        UserContextHolder.holder.set(user);\n        System.out.println(\"Service1:\"+user);\n        new Service2().process();\n    }\n}\n\nclass Service2 {\n    public void process() {\n        User user = UserContextHolder.holder.get();\n        System.out.println(\"Service2:\"+user);\n        new Service3().process();\n    }\n}\nclass Service3 {\n    public void process() {\n        User user = UserContextHolder.holder.get();\n        System.out.println(\"Service3:\"+user);\n    }\n}\n```\n\n# 线程池\n\n## 概述\n\n### 优点\n\n+ 重用现有的线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销\n+ 当请求到达时，工作线程已经存在，不会由于等待创建线程而延迟任务的执行\n+ 通过适当调整线程池的大小，可以创建足够多的线程使处理器保存忙碌状态，又可以防止过多线程相互竞争资源使得应用程序耗尽内存\n\n### 继承体系\n\n<img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201202211516638.png\" alt=\"image-20201202211516638\" style=\"zoom:50%;\" />\n\nThreadPoolExecutor是实际使用到的类，通过他的构造函数来实例化一个对象，并根据自己需求定制\n\n### 关闭线程池\n\n+ shutdown：将执行平缓的关闭过程，不再接受新的任务，同时等待已提交任务执行完成，包括那些还未开始执行的任务\n+ shutdownNow：执行粗暴给关闭过程，立刻关闭！对正在执行的线程执行中断interrupt；不再启动队列中尚未开始的任务，返回在等待中的队列列表\n\n## 运行规则\n\n+ 如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程运行新任务\n+ 如果线程数大于等于corePoolSize，但小于maximumPoolSize，则将任务放入workQueue队列\n+ 如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务\n+ 如果队列已满，并且线程数大于等于maxPoolSize，则拒绝该任务\n+ 当一个线程无事可做，而且超过keepAliveTime，而且当前运行线程数大于corePoolSize则该线程停止。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529104616059.png\" alt=\"image-20210529104616059\" style=\"zoom: 67%;\" />\n\n## 七大核心参数\n\n| 参数            | 描述             | 具体说明                                                     |\n| --------------- | ---------------- | ------------------------------------------------------------ |\n| corePoolSize    | 核心线程数       | 线程池中的常驻核心线程数，当线程池数量到达corePoolSize后，就会把到达的任务放到缓存队列当中 |\n| maximumPoolSize | 最大线程数       | 线程池能够容纳同时执行的最大线程数，必须大于等于1(当corePoolSize满了，workQueue也满了，则会扩容) |\n| keepAliveTime   | 多余线程存活时间 | 多余的空闲线程的存活时间，当前线程池数量超过corePoolSize时，当空闲时间到达keepAliveTime值时，会将线程销毁到corePoolSize数量 |\n| TimeUnit unit   | 设置时间单位     |                                                              |\n| workQueue       | 阻塞队列         | BlockingQueue<Runnable> workQueue                            |\n| threadFactory   | 线程工厂         | ThreadFactory threadFactory，表示生成线程池中工作线程的线程工厂 一般默认即可 |\n| Handler         | 拒绝策略         | RejectedExecutionHandler handler 拒绝策略，当maximumPoolSize已经满了，则拒绝 |\n\n## 四种拒绝策略\n\n+ 如果线程池被关闭则拒绝\n+ 当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时\n\n### AbortPolicy（终止）\n\n+ 默认的拒绝策略\n+ 抛出未检查的RejectExecution-Exception\n+ 调用者可以捕获这个异常，然后根据需求编写自己的处理代码\n+ 线程池的默认拒绝策略为AbortPolicy，即丢弃任务并抛出RejectedExecutionException异常\n+ 这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。\n\n### DiscardPolicy（抛弃）\n\n+ 丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。\n+ 使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。\n\n### DiscardOldestPolicy（抛弃最旧）\n\n+ 丢弃队列最前面的任务，然后重新提交被拒绝的任务。\n+ 此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。\n\n### CallerRunsPolicy\n\n既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，从而降低新任务的流量\n\n如果任务被拒绝了，则由调用线程（提交任务的线程）直接执行此任务\n\n## 自定义线程池\n\n不允许在应用中显示创建线程，都是得使用线程池\n\n生产实践中不允许适用`Executors`去创建，因为他底层是`new LinkedBlockingQueue<Runnable>())`是无界队列，如果所有工作行程都处于忙碌状态，那么任务将在队列中等候，如果任务持续快速地到达，并且超过了线程池处理他们的速度，那么队列将无限制增加，可能会堆积大量请求，导致`OOM`\n\n### 线程池官方实现\n\n![image-20210529110357928](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529110357928.png)\n\n```java\n//适用于长期执行的任务，性能好很多 阻塞队列可能很大，会OOM\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads， nThreads，\n                                      0L， TimeUnit.MILLISECONDS，\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n\n```java\n//适用于一个任务一个任务执行的场景 阻塞队列可能很大，会OOM\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1， 1，\n                                0L， TimeUnit.MILLISECONDS，\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n\n```java\n//适用执行很多短期异步的小程序或负载较轻的服务器\n//任务数量特别多时，就会创建很多的线程，会OOM\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0， Integer.MAX_VALUE，\n                                  60L， TimeUnit.SECONDS，\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n```java\n// executorService.schedule(()->{System.out.println(\"1\");}, 5, TimeUnit.SECONDS);\n// 支持定时，周期执行任务\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize， Integer.MAX_VALUE， 0， NANOSECONDS，\n              new DelayedWorkQueue());\n    }\n```\n\n### 设置maximumPoolSize\n\n首先分析计算环境、资源预算，例如部署的系统有多少CPU：\n\n```\nSystem.out.println(Runtime.getRuntime().availableProcessors());\n```\n\n系统有多大的内存：计算每个任务对内存的需求量，用总内存/需求量，就得到线程池上限\n\n是否需像JDBC连接等稀缺资源：如果每个任务都需要一个数据库连接，那么连接池大小限制了线程池的大小\n\n**CPU密集型**\n\n线程池大小应该为处理器个数+1，能实现最优的使用率\n\n即使线程偶尔由于缺页故障等原因暂停时，额外的线程也能保证CPU的时钟周期不会被浪费\n\n**IO密集型**\n\n并不是一直在执行任务，则应该配置尽可能多的线程，如CPU核数*2\n\n线程不会一直执行，线程池规模应更大\n\n必须估算任务的等待时间与计算时间的比值\n\n线程池最优大小= CPU核数 * CPU利用率 * （1 + 任务等待时间/运行时间）\n\n# Future和Callable\n\n## 概述\n\n### Callable\n\n+ Runnable不能返回一个返回值\n+ 也不能抛出受查异常，只能try-catch。因为Runnable接口中run()方法没有抛出异常\n+ Callable接口类似Runnable，代表一个被其他线程执行的任务\n\n```java\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n```\n\n### Future\n\n+ 可以用Future.get()来获取Callable的执行结果；用Future.isDone()来判断任务是否执行完成\n+ 在call()未执行完毕之前，调用get()的线程会被阻塞，直到call()方法返回了结果，future.get()才会得到结果\n+ Futute是一个存储器，存储了call()这个任务的结果\n+ 例如给线程池提交我们的任务，提交后线程池会立刻返回给我们一个空的Future容器。当线程的任务一旦执行完毕，也就是当我们可以获取结果时，线程池就会把结果填入该Future中，便可以从原先那个Future获得任务执行的结果\n\n**ExecutorService**\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    ExecutorService service = Executors.newFixedThreadPool(10);\n    Future<Integer> future = service.submit(new CallableTask());\n    System.out.println(future.get()); // 会阻塞3秒\n    service.shutdown();\n\n}\n\nstatic class CallableTask implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        Thread.sleep(3000);\n        return new Random().nextInt();\n    }\n}\n```\n\n**FutureTask**\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    Task task = new Task();\n    FutureTask<Integer> futureTask = new FutureTask<>(task);\n    new Thread(futureTask).start();\n    System.out.println(futureTask.get());\n}\n\nstatic class Task implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        Thread.sleep(3000);\n        return new Random().nextInt();\n    }\n}\n```","slug":"Java语言/Java多线程/2.线程基础","published":1,"updated":"2021-06-08T03:35:00.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq50r000az0tp673r1nba","content":"<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h2 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h2><p>从原理上看两种方法本质上是一样的</p>\n<p>将该Runnable传递给Thread的target成员变量，最终调用target.run()方法</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> Runnable target<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>target <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        target<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"继承Thread类\"><a href=\"#继承Thread类\" class=\"headerlink\" title=\"继承Thread类\"></a>继承Thread类</h3><p>run（）方法整个被重写</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//继承Thread类实现多线程</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n   System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" start\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>， <span class=\"token string\">\"thread1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"实现Runnable-接口\"><a href=\"#实现Runnable-接口\" class=\"headerlink\" title=\"实现Runnable()接口\"></a>实现Runnable()接口</h3><ul>\n<li>代码架构角度：代表一个任务，和线程进行区分，解耦</li>\n<li>节约资源：新建线程的损耗大，反复利用同一个线程</li>\n<li>扩展性，Java不允许多继承，如果继承Thread类，就不能多继承了</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//覆写Runnable()接口实现多线程</span>\nRunnable runnable <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n   System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" start\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnable，<span class=\"token string\">\"thread2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"通过线程池启动多线程\"><a href=\"#通过线程池启动多线程\" class=\"headerlink\" title=\"通过线程池启动多线程\"></a>通过线程池启动多线程</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//通过线程池启动多线程</span>\n<span class=\"token comment\" spellcheck=\"true\">//创建线程池</span>\nExecutorService executorService <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//执行</span>\nexecutorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nexecutorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nexecutorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//关闭连接</span>\nexecutorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"覆写Callable接口实现多线程\"><a href=\"#覆写Callable接口实现多线程\" class=\"headerlink\" title=\"覆写Callable接口实现多线程\"></a>覆写Callable接口实现多线程</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//覆写Callable接口实现多线程</span>\nFutureTask<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> task <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FutureTask</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Callable</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Integer <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" start\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>task，<span class=\"token string\">\"thread3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//一直阻塞直到结果返回</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>可以用于延迟计算，如执行数据库查询</p>\n<p>它认为主入口点（call)将返回一个值，并可能抛出一个异常</p>\n<p><strong>与Runnable的区别</strong></p>\n<p>Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p>\n<p>Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p>\n<p>Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛</p>\n<p><strong>Future</strong></p>\n<p>表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等</p>\n<p>get：如果任务已完成，get立即返回或抛异常，未完成，则阻塞直到任务完成</p>\n<p><strong>FutureTask</strong></p>\n<p>实现了Runnable，可以将他提交给Executor来执行</p>\n<h2 id=\"启动线程\"><a href=\"#启动线程\" class=\"headerlink\" title=\"启动线程\"></a>启动线程</h2><h3 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h3><ul>\n<li>启动新线程</li>\n<li>处于就绪(可运行)状态</li>\n<li>并没有运行，一旦得到cpu时间片，就开始执行run()方法</li>\n<li>不能重复执行start()方法，抛出异常：IllegalThreadStateException</li>\n<li>Run方法运行结束，此线程随即终止。</li>\n</ul>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>\n<p>调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</p>\n<h2 id=\"停止线程\"><a href=\"#停止线程\" class=\"headerlink\" title=\"停止线程\"></a>停止线程</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li>使用interrupt来通知，而不是强制</li>\n<li>被中断的线程拥有如何响应中断的权利，必须等待线程处理完之后主动中止，所以不应该莽撞的使用stop方法</li>\n<li>线程就算是sleep状态，也会响应interrupt</li>\n<li>想停止线程，要请求方、被停止方、子方法被调用方相互配合</li>\n</ul>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><p><strong>void interrupt()</strong></p>\n<p>设置interrupted</p>\n<p>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并且打断标记还是false。但是对于正常进程被打断打断标记是true</p>\n<p><strong>static boolean interrupted()</strong></p>\n<p>目标对象为当前线程</p>\n<p>清除当前线程的中断状态，并返回他之前的值</p>\n<p>判断是否被打断，并且清除打断标记(设为false)</p>\n<p>由于会清除当前线程的中断状态，如果调用他时返回true，那么除非你想屏蔽这个中断，否则必须对他进行处理。可以抛出InterruptedException，或再调用interrupt来恢复中断状态</p>\n<p><strong>boolean isInterrupted()</strong></p>\n<p>判断是否被打断，不会清除打断标记</p>\n<p>返回目标线程的中断状态</p>\n<h4 id=\"错误的停止方法\"><a href=\"#错误的停止方法\" class=\"headerlink\" title=\"错误的停止方法\"></a>错误的停止方法</h4><p><strong>被弃用的stop、resume方法等</strong></p>\n<p>会导致线程运行一半突然停止，没办法完成一个基本单位的操作</p>\n<p>资源分配戛然而止，银行批量转账10个人，只转了8个人，很难排查错误</p>\n<p><strong>用volatile设置boolean标记位</strong></p>\n<p>这样陷入阻塞时，就不会有人去唤醒他，他就不会执行到判断volatile那个变量的标志位的代码，就会一直等待</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"run（）内没有sleep或wait方法时，停止线程\"><a href=\"#run（）内没有sleep或wait方法时，停止线程\" class=\"headerlink\" title=\"run（）内没有sleep或wait方法时，停止线程\"></a>run（）内没有sleep或wait方法时，停止线程</h4><p>如果不检测线程状态isInterrupted()，则调用thread.interrupt();没有任何影响</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException， InterruptedException <span class=\"token punctuation\">{</span>\n    Runnable runnable <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//需要检测是否被中断，并且响应</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> Integer<span class=\"token punctuation\">.</span>MAX_VALUE <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">%</span> <span class=\"token number\">10000</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello + \"</span><span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"被中断了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"运行结束了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    Thread thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"在线程sleep期间interrupt\"><a href=\"#在线程sleep期间interrupt\" class=\"headerlink\" title=\"在线程sleep期间interrupt\"></a>在线程sleep期间interrupt</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException， InterruptedException <span class=\"token punctuation\">{</span>\n    Runnable runnable <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//需要检测是否被中断，并且响应</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> Integer<span class=\"token punctuation\">.</span>MAX_VALUE <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello + \"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">//控制不住，因为调用后中断标志被清除了</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"被中断\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">//如果在sleep时中断，就会抛出该异常，所以就可以在catch中处理</span>\n            <span class=\"token comment\" spellcheck=\"true\">//该循环会继续工作，因为catch后就执行下一轮循环</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//sleep interrupted</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"运行结束了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    Thread thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//控制interrupt时线程正在sleep</span>\n    TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>会抛出异常：InterruptedException（sleep interrupted）</p>\n<p>会继续执行，不会中断：interrupt中断标记被清除，而且是循环，try-catch后会继续执行下一个循环</p>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><p>不应屏蔽中断请求</p>\n<h4 id=\"传递异常（优先选择）\"><a href=\"#传递异常（优先选择）\" class=\"headerlink\" title=\"传递异常（优先选择）\"></a>传递异常（优先选择）</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Thread1</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    catch了InterruptedException后优先选择在方法签名中抛出异常\n    反面教材：在try-catch中处理\n\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        Runnable runnable <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"业务逻辑\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">throwInMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token comment\" spellcheck=\"true\">//如果子方法使用try-catch，则下面不会有效果</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"break\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//线程使用</span>\n        Thread thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//最佳是抛出异常到方法签名</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">throwInMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果用这样，则中断的时候会e.printStackTrace();但是会继续运行</span>\n        <span class=\"token comment\" spellcheck=\"true\">//因为该方法不是run()方法，是底层被run()调用的方法，就导致没能响应中断，run的while循环仍然执行</span>\n        <span class=\"token comment\" spellcheck=\"true\">//相当于把中断给吞掉了</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"抛出异常到方法签名（推荐）\"><a href=\"#抛出异常到方法签名（推荐）\" class=\"headerlink\" title=\"抛出异常到方法签名（推荐）\"></a>抛出异常到方法签名（推荐）</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Thread1</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    catch了InterruptedException后优先选择在方法签名中抛出异常\n\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        Runnable runnable <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"业务逻辑\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//run方法不能抛出异常，因为顶层的run方法没有异常，子类自然不能有</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">throwInMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"保存日志\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"退出\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//线程使用</span>\n        Thread thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//最佳是抛出异常到方法签名</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">throwInMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"恢复中断（不想或者无法传递时）\"><a href=\"#恢复中断（不想或者无法传递时）\" class=\"headerlink\" title=\"恢复中断（不想或者无法传递时）\"></a>恢复中断（不想或者无法传递时）</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Thread1</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        Runnable runnable <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"业务逻辑\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">throwInMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token comment\" spellcheck=\"true\">//因为重新设置了中断状态，所以是有效的</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"break\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//线程使用</span>\n        Thread thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">throwInMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//恢复设置中断状态，以便于在后续执行时，仍然能够检查到刚刚发生了中断</span>\n            Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"线程生命周期\"><a href=\"#线程生命周期\" class=\"headerlink\" title=\"线程生命周期\"></a>线程生命周期</h2><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1611884091_1.png\" alt=\"img\"></p>\n<ul>\n<li>NEW：初始状态，线程被构建，但是没有调用start()</li>\n<li>RUNNABLE：运行状态，将操作系统的就绪和运行状态统称为RUNNABLE；有可能正在运行，也有可能等待CPU资源</li>\n<li>BLOCKED：阻塞状态，线程阻塞与锁；在程序等待进入同步区域时，将进入这种状态；在等待一个排它锁，该事件在另外一个线程放弃这个锁时发生；只有Synchronized修饰的，而且没有拿到锁，才是BLOCKED状态，其他锁不算</li>\n<li>WAITING：无限期等待状态，当前线程需要等待其他线程通知或中断；没有设置Timeout的Object::wait()；没有设置Timeout的Thread::join()；LockSupport::park()</li>\n<li>TIME_WAITING：超时等待状态，可以在指定的时间自行返回；Thread::sleep()；设置Timeout的Object::wait()；设置Timeout的Thread::join()；LockSupport::parkUntil()</li>\n<li>TERMINATED：终止状态，当前线程已经执行完毕</li>\n</ul>\n<h2 id=\"Object相关方法\"><a href=\"#Object相关方法\" class=\"headerlink\" title=\"Object相关方法\"></a>Object相关方法</h2><ul>\n<li><p>wait、notify、notifyAll定义在Object中，因为是锁级别的</p>\n</li>\n<li><p>wait需要在同步代码块内使用，用户必须先拥有monitor</p>\n</li>\n<li><p>wait()的作用是<strong>让当前线程进入等待状态</strong>，同时，wait()也会<strong>让当前线程释放它所持有的锁</strong>。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)</p>\n</li>\n<li><p>wait(long timeout)让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p>\n</li>\n<li><p>因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出IllegalMonitorStateException（正在等待的对象没有锁））</p>\n</li>\n<li><p>notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程（唤醒哪个取决于JVM），而notifyAll()是唤醒所有的线程</p>\n</li>\n<li><p>notify也要在synchronized使用，应该指定对象，t1.notify()，通知t1对象的等待池里的线程使一个线程进入锁定池，然后与锁定池中的线程争夺锁。那么为什么要在synchronized使用呢？ t1.notify()需要通知一个等待池中的线程，那么这时我们必须得获得t1的监视器（需要使用synchronized），才能对其操作，t1.notify()程序只是知道要对t1操作，但是是否可以操作与是否可以获得t1锁关联的监视器有关。</p>\n</li>\n</ul>\n<p><strong>唤醒时机</strong></p>\n<ul>\n<li>notify()本线程</li>\n<li>notifyAll()</li>\n<li>wait(long timeout)超时时间达到</li>\n<li>线程自身调用interrupt()</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">/*\nThread-0线程开始执行！\nThread-1线程开始执行！\n线程Thread-1获取到了锁！\n线程Thread-0获取到了锁！\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Object object <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Thread1</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"线程开始执行！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    object<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"线程\"</span><span class=\"token operator\">+</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"获取到了锁！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Thread2</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"线程开始执行！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                object<span class=\"token punctuation\">.</span><span class=\"token function\">notify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"线程\"</span><span class=\"token operator\">+</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"获取到了锁！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        Thread1 thread1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Thread2 thread2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"线程属性\"><a href=\"#线程属性\" class=\"headerlink\" title=\"线程属性\"></a>线程属性</h2><ul>\n<li>线程Id</li>\n<li>线程名称</li>\n<li>isDaemon(true代表是守护线程）<ul>\n<li>是给用户线程提供服务的</li>\n<li>默认情况下，Java进程会等待所有线程都运行结束，才会结束</li>\n<li>守护进程，如果所有非守护进程结束，守护进程也都结束了(垃圾回收器)</li>\n<li>如后台记录操作日志，监控内存，垃圾回收</li>\n<li>thread1.setDaemon(true);</li>\n</ul>\n</li>\n<li>priority（优先级）<ul>\n<li>10个优先级，默认是5</li>\n<li>优先级高度依赖于操作系统的优先级，Java映射过去的</li>\n<li>优先级会被操作系统改变</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Thread方法\"><a href=\"#Thread方法\" class=\"headerlink\" title=\"Thread方法\"></a>Thread方法</h2><h3 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep()\"></a>sleep()</h3><ul>\n<li>让当前执行的线程休眠n毫秒， 休眠时让出 cpu 的时间片给其它线程</li>\n<li>可以调用interrupt()方法唤醒，但是会抛出异常：InterruptedException，并且会清除中断状态</li>\n<li><strong>让线程进入Waiting状态，并且不占用CPU资源（阻塞），但不释放锁</strong></li>\n<li><strong>休眠期间被中断，则抛出异常并清除中断状态</strong></li>\n</ul>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h3><ul>\n<li>等待线程运行结束，可以控制线程的同步</li>\n<li>因为新的线程加入了我们，所以我们要等他执行完再出发</li>\n<li>main等待thread1执行完毕</li>\n<li>源码调用wait()一直休眠，但每一个线程在执行完run()都会执行notifyAll()</li>\n<li><strong>主线程在waiting状态</strong></li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/*\n开始等待所有子线程执行\nThread-0执行\nThread-1执行\n所有子线程执行完毕\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        Thread thread1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"执行\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Thread thread2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"执行\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        thread1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"开始等待所有子线程执行\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread2<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"所有子线程执行完毕\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>等价代码</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MainTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        Thread thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"执行\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"开始等待所有子线程执行\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//        thread.join();</span>\n        <span class=\"token comment\" spellcheck=\"true\">//等价于以下语句：</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n        synchronized只是为了能调用wait()\n        主线程执行到下面语句，会阻塞，直到thread线程执行完，隐式的调用了notifyAll()  \n         */</span>\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>thread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            thread<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"所有子线程执行完毕\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield()\"></a>yield()</h3><ul>\n<li>状态依旧是RUNNING状态</li>\n<li>提示线程调度器 让出当前线程对CPU的使用，具体要看操作系统实现</li>\n<li>让当前的线程暂停，但是不阻塞，从运行状态变为就绪状态</li>\n<li>让CPU重新调度，但是不能决定CPU</li>\n<li>不会释放锁</li>\n<li>为了稳定性，实际开发不使用，但是很多并发包使用</li>\n</ul>\n<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><ul>\n<li>ThreadLocal叫做线程本地变量或线程本地存储。为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。让某个需要使用的对象在线程间隔离（每个线程都有自己的独立的对象）</li>\n<li>initialValue：在ThreadLocal第一次get时就把对象给初始化出来，对象的初始化时机可以由我们控制</li>\n<li>set：如果需要保存到ThreadLocal里的对象的时机不由我们随意控制，例如拦截器里的用户信息，就用set存放</li>\n</ul>\n<h2 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>每个Thread中都有一个ThreadLocalMap </p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Thread</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n    ThreadLocal<span class=\"token punctuation\">.</span>ThreadLocalMap threadLocals <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529150659281.png\" alt=\"image-20210529150659281\"></p>\n<p><strong>ThreadLocalMap</strong> </p>\n<ul>\n<li>是一个Entry数组，Entry是一个键值对，键是该ThreadLocal，值是实际存储的对象</li>\n<li>遇到冲突采取的是线性探测法</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadLocalMap</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Entry</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">WeakReference</span><span class=\"token operator\">&lt;</span>ThreadLocal<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">>></span> <span class=\"token punctuation\">{</span>\n        Object value<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> Entry<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> table<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>ThreadLocal<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> key<span class=\"token punctuation\">,</span> Object value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h3><p>一般来说重写该方法</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> T <span class=\"token function\">initialValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>T value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Thread t <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ThreadLocalMap map <span class=\"token operator\">=</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//键值对：(this， value)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span>， value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token function\">createMap</span><span class=\"token punctuation\">(</span>t， value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> T <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//先找到当前线程 再找到当前线程的ThreadLocalMap</span>\n    Thread t <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ThreadLocalMap map <span class=\"token operator\">=</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//key是当前threadLocal引用</span>\n        ThreadLocalMap<span class=\"token punctuation\">.</span>Entry e <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">getEntry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@SuppressWarnings</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unchecked\"</span><span class=\"token punctuation\">)</span>\n            T result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span>e<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">setInitialValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//如果get为null，则initialValue()</span>\n<span class=\"token keyword\">private</span> T <span class=\"token function\">setInitialValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    T value <span class=\"token operator\">=</span> <span class=\"token function\">initialValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Thread t <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ThreadLocalMap map <span class=\"token operator\">=</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span>， value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token function\">createMap</span><span class=\"token punctuation\">(</span>t， value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ThreadLocalMap m <span class=\"token operator\">=</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        m<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><ul>\n<li>可能导致内存泄漏</li>\n<li>内存泄漏：某个对象不再有用，但是占用的内存却不能被回收</li>\n<li>ThreadLocalMap中的每个Entry都是一个对key的弱引用，对value的强引用</li>\n<li>正常情况下，线程终止，则保存在ThreadLocalMap里的value会被回收</li>\n<li>但是线程不终止（例如线程池），那么value就不会被回收：key会回收，因为key是弱引用，垃圾回收会回收，key为null、Thread-&gt;ThreadLocalMap-&gt;Entry(key为null)-&gt;value。</li>\n<li>JDK考虑过了，在set、remove、rehash方法中会扫描key为null的Entry，并把value设置为null，但如果一个线程中ThreadLocal不被调用，就不会执行上述操作</li>\n<li>阿里规约：在使用完ThreadLocal之后，主动调用remove方法：UserContextHolder.holder.remove();</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><h3 id=\"SimpleDateFormat\"><a href=\"#SimpleDateFormat\" class=\"headerlink\" title=\"SimpleDateFormat\"></a>SimpleDateFormat</h3><ul>\n<li>初始版本：使用线程池（创建很多个对象，效率低）</li>\n<li>把SimpleDateFormat当静态使用（会出现并发安全问题）</li>\n<li>用ThreadLocal实现</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadLocalUsage03</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> ThreadLocal<span class=\"token operator\">&lt;</span>SimpleDateFormat<span class=\"token operator\">></span> local <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadLocal</span><span class=\"token operator\">&lt;</span>SimpleDateFormat<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> SimpleDateFormat <span class=\"token function\">initialValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"yyyy-MM-dd hh:mm:ss\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> ExecutorService executorService <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> seconds<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//参数单位是ms，从1970.1.1 00:00:00 GMT计时</span>\n        Date date <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>1000L <span class=\"token operator\">*</span> seconds<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> local<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> finalI <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                String date <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadLocalUsage03</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">date</span><span class=\"token punctuation\">(</span>finalI<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"传递用户信息\"><a href=\"#传递用户信息\" class=\"headerlink\" title=\"传递用户信息\"></a>传递用户信息</h3><p>不同请求（不同线程）user对象不同</p>\n<p>即这些信息在同一个线程中相同，但是不同线程中使用的业务内容是不同的</p>\n<p>在线程生命周期内，都可以通过这个静态ThreadLocal实例的get()方法取得自己set过的那个对象，避免了将这个对象（例如user对象）作为参数传递的麻烦</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserContextHolder</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> ThreadLocal<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> holder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadLocal</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Service1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Service1</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        User user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"张三\"</span>， <span class=\"token string\">\"123456\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        UserContextHolder<span class=\"token punctuation\">.</span>holder<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Service1:\"</span><span class=\"token operator\">+</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Service2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Service2</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        User user <span class=\"token operator\">=</span> UserContextHolder<span class=\"token punctuation\">.</span>holder<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Service2:\"</span><span class=\"token operator\">+</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Service3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Service3</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        User user <span class=\"token operator\">=</span> UserContextHolder<span class=\"token punctuation\">.</span>holder<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Service3:\"</span><span class=\"token operator\">+</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>重用现有的线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销</li>\n<li>当请求到达时，工作线程已经存在，不会由于等待创建线程而延迟任务的执行</li>\n<li>通过适当调整线程池的大小，可以创建足够多的线程使处理器保存忙碌状态，又可以防止过多线程相互竞争资源使得应用程序耗尽内存</li>\n</ul>\n<h3 id=\"继承体系\"><a href=\"#继承体系\" class=\"headerlink\" title=\"继承体系\"></a>继承体系</h3><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201202211516638.png\" alt=\"image-20201202211516638\" style=\"zoom:50%;\" />\n\n<p>ThreadPoolExecutor是实际使用到的类，通过他的构造函数来实例化一个对象，并根据自己需求定制</p>\n<h3 id=\"关闭线程池\"><a href=\"#关闭线程池\" class=\"headerlink\" title=\"关闭线程池\"></a>关闭线程池</h3><ul>\n<li>shutdown：将执行平缓的关闭过程，不再接受新的任务，同时等待已提交任务执行完成，包括那些还未开始执行的任务</li>\n<li>shutdownNow：执行粗暴给关闭过程，立刻关闭！对正在执行的线程执行中断interrupt；不再启动队列中尚未开始的任务，返回在等待中的队列列表</li>\n</ul>\n<h2 id=\"运行规则\"><a href=\"#运行规则\" class=\"headerlink\" title=\"运行规则\"></a>运行规则</h2><ul>\n<li>如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程运行新任务</li>\n<li>如果线程数大于等于corePoolSize，但小于maximumPoolSize，则将任务放入workQueue队列</li>\n<li>如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务</li>\n<li>如果队列已满，并且线程数大于等于maxPoolSize，则拒绝该任务</li>\n<li>当一个线程无事可做，而且超过keepAliveTime，而且当前运行线程数大于corePoolSize则该线程停止。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小</li>\n</ul>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529104616059.png\" alt=\"image-20210529104616059\" style=\"zoom: 67%;\" />\n\n<h2 id=\"七大核心参数\"><a href=\"#七大核心参数\" class=\"headerlink\" title=\"七大核心参数\"></a>七大核心参数</h2><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>具体说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>corePoolSize</td>\n<td>核心线程数</td>\n<td>线程池中的常驻核心线程数，当线程池数量到达corePoolSize后，就会把到达的任务放到缓存队列当中</td>\n</tr>\n<tr>\n<td>maximumPoolSize</td>\n<td>最大线程数</td>\n<td>线程池能够容纳同时执行的最大线程数，必须大于等于1(当corePoolSize满了，workQueue也满了，则会扩容)</td>\n</tr>\n<tr>\n<td>keepAliveTime</td>\n<td>多余线程存活时间</td>\n<td>多余的空闲线程的存活时间，当前线程池数量超过corePoolSize时，当空闲时间到达keepAliveTime值时，会将线程销毁到corePoolSize数量</td>\n</tr>\n<tr>\n<td>TimeUnit unit</td>\n<td>设置时间单位</td>\n<td></td>\n</tr>\n<tr>\n<td>workQueue</td>\n<td>阻塞队列</td>\n<td>BlockingQueue<Runnable> workQueue</td>\n</tr>\n<tr>\n<td>threadFactory</td>\n<td>线程工厂</td>\n<td>ThreadFactory threadFactory，表示生成线程池中工作线程的线程工厂 一般默认即可</td>\n</tr>\n<tr>\n<td>Handler</td>\n<td>拒绝策略</td>\n<td>RejectedExecutionHandler handler 拒绝策略，当maximumPoolSize已经满了，则拒绝</td>\n</tr>\n</tbody></table>\n<h2 id=\"四种拒绝策略\"><a href=\"#四种拒绝策略\" class=\"headerlink\" title=\"四种拒绝策略\"></a>四种拒绝策略</h2><ul>\n<li>如果线程池被关闭则拒绝</li>\n<li>当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时</li>\n</ul>\n<h3 id=\"AbortPolicy（终止）\"><a href=\"#AbortPolicy（终止）\" class=\"headerlink\" title=\"AbortPolicy（终止）\"></a>AbortPolicy（终止）</h3><ul>\n<li>默认的拒绝策略</li>\n<li>抛出未检查的RejectExecution-Exception</li>\n<li>调用者可以捕获这个异常，然后根据需求编写自己的处理代码</li>\n<li>线程池的默认拒绝策略为AbortPolicy，即丢弃任务并抛出RejectedExecutionException异常</li>\n<li>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</li>\n</ul>\n<h3 id=\"DiscardPolicy（抛弃）\"><a href=\"#DiscardPolicy（抛弃）\" class=\"headerlink\" title=\"DiscardPolicy（抛弃）\"></a>DiscardPolicy（抛弃）</h3><ul>\n<li>丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</li>\n<li>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。</li>\n</ul>\n<h3 id=\"DiscardOldestPolicy（抛弃最旧）\"><a href=\"#DiscardOldestPolicy（抛弃最旧）\" class=\"headerlink\" title=\"DiscardOldestPolicy（抛弃最旧）\"></a>DiscardOldestPolicy（抛弃最旧）</h3><ul>\n<li>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li>\n<li>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。</li>\n</ul>\n<h3 id=\"CallerRunsPolicy\"><a href=\"#CallerRunsPolicy\" class=\"headerlink\" title=\"CallerRunsPolicy\"></a>CallerRunsPolicy</h3><p>既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，从而降低新任务的流量</p>\n<p>如果任务被拒绝了，则由调用线程（提交任务的线程）直接执行此任务</p>\n<h2 id=\"自定义线程池\"><a href=\"#自定义线程池\" class=\"headerlink\" title=\"自定义线程池\"></a>自定义线程池</h2><p>不允许在应用中显示创建线程，都是得使用线程池</p>\n<p>生产实践中不允许适用<code>Executors</code>去创建，因为他底层是<code>new LinkedBlockingQueue&lt;Runnable&gt;())</code>是无界队列，如果所有工作行程都处于忙碌状态，那么任务将在队列中等候，如果任务持续快速地到达，并且超过了线程池处理他们的速度，那么队列将无限制增加，可能会堆积大量请求，导致<code>OOM</code></p>\n<h3 id=\"线程池官方实现\"><a href=\"#线程池官方实现\" class=\"headerlink\" title=\"线程池官方实现\"></a>线程池官方实现</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529110357928.png\" alt=\"image-20210529110357928\"></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//适用于长期执行的任务，性能好很多 阻塞队列可能很大，会OOM</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> ExecutorService <span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> nThreads<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span>nThreads， nThreads，\n                                      0L， TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS，\n                                      <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token operator\">&lt;</span>Runnable<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//适用于一个任务一个任务执行的场景 阻塞队列可能很大，会OOM</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> ExecutorService <span class=\"token function\">newSingleThreadExecutor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FinalizableDelegatedExecutorService</span>\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span>， <span class=\"token number\">1</span>，\n                                0L， TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS，\n                                <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token operator\">&lt;</span>Runnable<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//适用执行很多短期异步的小程序或负载较轻的服务器</span>\n<span class=\"token comment\" spellcheck=\"true\">//任务数量特别多时，就会创建很多的线程，会OOM</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> ExecutorService <span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span>， Integer<span class=\"token punctuation\">.</span>MAX_VALUE，\n                                  60L， TimeUnit<span class=\"token punctuation\">.</span>SECONDS，\n                                  <span class=\"token keyword\">new</span> <span class=\"token class-name\">SynchronousQueue</span><span class=\"token operator\">&lt;</span>Runnable<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// executorService.schedule(()->{System.out.println(\"1\");}, 5, TimeUnit.SECONDS);</span>\n<span class=\"token comment\" spellcheck=\"true\">// 支持定时，周期执行任务</span>\n<span class=\"token keyword\">public</span> <span class=\"token function\">ScheduledThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>corePoolSize， Integer<span class=\"token punctuation\">.</span>MAX_VALUE， <span class=\"token number\">0</span>， NANOSECONDS，\n              <span class=\"token keyword\">new</span> <span class=\"token class-name\">DelayedWorkQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"设置maximumPoolSize\"><a href=\"#设置maximumPoolSize\" class=\"headerlink\" title=\"设置maximumPoolSize\"></a>设置maximumPoolSize</h3><p>首先分析计算环境、资源预算，例如部署的系统有多少CPU：</p>\n<pre><code>System.out.println(Runtime.getRuntime().availableProcessors());</code></pre>\n<p>系统有多大的内存：计算每个任务对内存的需求量，用总内存/需求量，就得到线程池上限</p>\n<p>是否需像JDBC连接等稀缺资源：如果每个任务都需要一个数据库连接，那么连接池大小限制了线程池的大小</p>\n<p><strong>CPU密集型</strong></p>\n<p>线程池大小应该为处理器个数+1，能实现最优的使用率</p>\n<p>即使线程偶尔由于缺页故障等原因暂停时，额外的线程也能保证CPU的时钟周期不会被浪费</p>\n<p><strong>IO密集型</strong></p>\n<p>并不是一直在执行任务，则应该配置尽可能多的线程，如CPU核数*2</p>\n<p>线程不会一直执行，线程池规模应更大</p>\n<p>必须估算任务的等待时间与计算时间的比值</p>\n<p>线程池最优大小= CPU核数 * CPU利用率 * （1 + 任务等待时间/运行时间）</p>\n<h1 id=\"Future和Callable\"><a href=\"#Future和Callable\" class=\"headerlink\" title=\"Future和Callable\"></a>Future和Callable</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"Callable\"><a href=\"#Callable\" class=\"headerlink\" title=\"Callable\"></a>Callable</h3><ul>\n<li>Runnable不能返回一个返回值</li>\n<li>也不能抛出受查异常，只能try-catch。因为Runnable接口中run()方法没有抛出异常</li>\n<li>Callable接口类似Runnable，代表一个被其他线程执行的任务</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Callable</span><span class=\"token operator\">&lt;</span>V<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    V <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h3><ul>\n<li>可以用Future.get()来获取Callable的执行结果；用Future.isDone()来判断任务是否执行完成</li>\n<li>在call()未执行完毕之前，调用get()的线程会被阻塞，直到call()方法返回了结果，future.get()才会得到结果</li>\n<li>Futute是一个存储器，存储了call()这个任务的结果</li>\n<li>例如给线程池提交我们的任务，提交后线程池会立刻返回给我们一个空的Future容器。当线程的任务一旦执行完毕，也就是当我们可以获取结果时，线程池就会把结果填入该Future中，便可以从原先那个Future获得任务执行的结果</li>\n</ul>\n<p><strong>ExecutorService</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException<span class=\"token punctuation\">,</span> InterruptedException <span class=\"token punctuation\">{</span>\n    ExecutorService service <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Future<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> future <span class=\"token operator\">=</span> service<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">CallableTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 会阻塞3秒</span>\n    service<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CallableTask</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Callable</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Integer <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>FutureTask</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException<span class=\"token punctuation\">,</span> InterruptedException <span class=\"token punctuation\">{</span>\n    Task task <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    FutureTask<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> futureTask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FutureTask</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>futureTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>futureTask<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Task</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Callable</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Integer <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h2 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h2><p>从原理上看两种方法本质上是一样的</p>\n<p>将该Runnable传递给Thread的target成员变量，最终调用target.run()方法</p>\n<pre><code class=\"java\">private Runnable target;\n\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}</code></pre>\n<h3 id=\"继承Thread类\"><a href=\"#继承Thread类\" class=\"headerlink\" title=\"继承Thread类\"></a>继承Thread类</h3><p>run（）方法整个被重写</p>\n<pre><code class=\"java\">//继承Thread类实现多线程\nnew Thread(() -&gt; {\n   System.out.println(Thread.currentThread().getName()+&quot; start&quot;);\n}， &quot;thread1&quot;).start();</code></pre>\n<h3 id=\"实现Runnable-接口\"><a href=\"#实现Runnable-接口\" class=\"headerlink\" title=\"实现Runnable()接口\"></a>实现Runnable()接口</h3><ul>\n<li>代码架构角度：代表一个任务，和线程进行区分，解耦</li>\n<li>节约资源：新建线程的损耗大，反复利用同一个线程</li>\n<li>扩展性，Java不允许多继承，如果继承Thread类，就不能多继承了</li>\n</ul>\n<pre><code class=\"java\">//覆写Runnable()接口实现多线程\nRunnable runnable = () -&gt; {\n   System.out.println(Thread.currentThread().getName()+&quot; start&quot;);\n};\nnew Thread(runnable，&quot;thread2&quot;).start();</code></pre>\n<h3 id=\"通过线程池启动多线程\"><a href=\"#通过线程池启动多线程\" class=\"headerlink\" title=\"通过线程池启动多线程\"></a>通过线程池启动多线程</h3><pre><code class=\"java\">//通过线程池启动多线程\n//创建线程池\nExecutorService executorService = Executors.newFixedThreadPool(10);\n//执行\nexecutorService.execute(runnable);\nexecutorService.execute(runnable);\nexecutorService.execute(runnable);\n//关闭连接\nexecutorService.shutdown();</code></pre>\n<h3 id=\"覆写Callable接口实现多线程\"><a href=\"#覆写Callable接口实现多线程\" class=\"headerlink\" title=\"覆写Callable接口实现多线程\"></a>覆写Callable接口实现多线程</h3><pre><code class=\"java\">//覆写Callable接口实现多线程\nFutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() {\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(Thread.currentThread().getName() + &quot; start&quot;);\n        Thread.sleep(1000);\n        return 100;\n    }\n});\nnew Thread(task，&quot;thread3&quot;).start();\n//一直阻塞直到结果返回\nSystem.out.println(task.get());</code></pre>\n<p>可以用于延迟计算，如执行数据库查询</p>\n<p>它认为主入口点（call)将返回一个值，并可能抛出一个异常</p>\n<p><strong>与Runnable的区别</strong></p>\n<p>Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p>\n<p>Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p>\n<p>Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛</p>\n<p><strong>Future</strong></p>\n<p>表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等</p>\n<p>get：如果任务已完成，get立即返回或抛异常，未完成，则阻塞直到任务完成</p>\n<p><strong>FutureTask</strong></p>\n<p>实现了Runnable，可以将他提交给Executor来执行</p>\n<h2 id=\"启动线程\"><a href=\"#启动线程\" class=\"headerlink\" title=\"启动线程\"></a>启动线程</h2><h3 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h3><ul>\n<li>启动新线程</li>\n<li>处于就绪(可运行)状态</li>\n<li>并没有运行，一旦得到cpu时间片，就开始执行run()方法</li>\n<li>不能重复执行start()方法，抛出异常：IllegalThreadStateException</li>\n<li>Run方法运行结束，此线程随即终止。</li>\n</ul>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>\n<p>调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</p>\n<h2 id=\"停止线程\"><a href=\"#停止线程\" class=\"headerlink\" title=\"停止线程\"></a>停止线程</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li>使用interrupt来通知，而不是强制</li>\n<li>被中断的线程拥有如何响应中断的权利，必须等待线程处理完之后主动中止，所以不应该莽撞的使用stop方法</li>\n<li>线程就算是sleep状态，也会响应interrupt</li>\n<li>想停止线程，要请求方、被停止方、子方法被调用方相互配合</li>\n</ul>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><p><strong>void interrupt()</strong></p>\n<p>设置interrupted</p>\n<p>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并且打断标记还是false。但是对于正常进程被打断打断标记是true</p>\n<p><strong>static boolean interrupted()</strong></p>\n<p>目标对象为当前线程</p>\n<p>清除当前线程的中断状态，并返回他之前的值</p>\n<p>判断是否被打断，并且清除打断标记(设为false)</p>\n<p>由于会清除当前线程的中断状态，如果调用他时返回true，那么除非你想屏蔽这个中断，否则必须对他进行处理。可以抛出InterruptedException，或再调用interrupt来恢复中断状态</p>\n<p><strong>boolean isInterrupted()</strong></p>\n<p>判断是否被打断，不会清除打断标记</p>\n<p>返回目标线程的中断状态</p>\n<h4 id=\"错误的停止方法\"><a href=\"#错误的停止方法\" class=\"headerlink\" title=\"错误的停止方法\"></a>错误的停止方法</h4><p><strong>被弃用的stop、resume方法等</strong></p>\n<p>会导致线程运行一半突然停止，没办法完成一个基本单位的操作</p>\n<p>资源分配戛然而止，银行批量转账10个人，只转了8个人，很难排查错误</p>\n<p><strong>用volatile设置boolean标记位</strong></p>\n<p>这样陷入阻塞时，就不会有人去唤醒他，他就不会执行到判断volatile那个变量的标志位的代码，就会一直等待</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"run（）内没有sleep或wait方法时，停止线程\"><a href=\"#run（）内没有sleep或wait方法时，停止线程\" class=\"headerlink\" title=\"run（）内没有sleep或wait方法时，停止线程\"></a>run（）内没有sleep或wait方法时，停止线程</h4><p>如果不检测线程状态isInterrupted()，则调用thread.interrupt();没有任何影响</p>\n<pre><code class=\"java\">public static void main(String[] args) throws ExecutionException， InterruptedException {\n    Runnable runnable = () -&gt; {\n        int num = 0;\n        //需要检测是否被中断，并且响应\n        for (int i = 0; i &lt; Integer.MAX_VALUE / 2; i++) {\n            if (i % 10000 == 0) {\n                System.out.println(&quot;Hello + &quot;+i);\n            }\n            if (Thread.currentThread().isInterrupted()) {\n                System.out.println(&quot;被中断了&quot;);\n                break;\n            }\n        }\n        System.out.println(&quot;运行结束了&quot;);\n    };\n    Thread thread = new Thread(runnable);\n    thread.start();\n    TimeUnit.SECONDS.sleep(1);\n    thread.interrupt();\n\n}</code></pre>\n<h4 id=\"在线程sleep期间interrupt\"><a href=\"#在线程sleep期间interrupt\" class=\"headerlink\" title=\"在线程sleep期间interrupt\"></a>在线程sleep期间interrupt</h4><pre><code class=\"java\">public static void main(String[] args) throws ExecutionException， InterruptedException {\n    Runnable runnable = () -&gt; {\n        int num = 0;\n        //需要检测是否被中断，并且响应\n        for (int i = 0; i &lt; Integer.MAX_VALUE / 2; i++) {\n            System.out.println(&quot;Hello + &quot; + i);\n\n            //控制不住，因为调用后中断标志被清除了\n            if (Thread.currentThread().isInterrupted()) {\n                System.out.println(&quot;被中断&quot;);\n                break;\n            }\n\n            //如果在sleep时中断，就会抛出该异常，所以就可以在catch中处理\n            //该循环会继续工作，因为catch后就执行下一轮循环\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            }\n            catch (InterruptedException e) {\n                //sleep interrupted\n                e.printStackTrace();\n            }\n        }\n        System.out.println(&quot;运行结束了&quot;);\n    };\n    Thread thread = new Thread(runnable);\n    thread.start();\n    //控制interrupt时线程正在sleep\n    TimeUnit.MILLISECONDS.sleep(500);\n    thread.interrupt();\n}</code></pre>\n<p>会抛出异常：InterruptedException（sleep interrupted）</p>\n<p>会继续执行，不会中断：interrupt中断标记被清除，而且是循环，try-catch后会继续执行下一个循环</p>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><p>不应屏蔽中断请求</p>\n<h4 id=\"传递异常（优先选择）\"><a href=\"#传递异常（优先选择）\" class=\"headerlink\" title=\"传递异常（优先选择）\"></a>传递异常（优先选择）</h4><pre><code class=\"java\">public class Thread1 {\n    /*\n    catch了InterruptedException后优先选择在方法签名中抛出异常\n    反面教材：在try-catch中处理\n\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -&gt; {\n            while (true) {\n                System.out.println(&quot;业务逻辑&quot;);\n                throwInMethod();\n\n                //如果子方法使用try-catch，则下面不会有效果\n                if (Thread.currentThread().isInterrupted()) {\n                    System.out.println(&quot;break&quot;);\n                    break;\n                }\n            }\n        };\n\n        //线程使用\n        Thread thread = new Thread(runnable);\n        thread.start();\n        TimeUnit.SECONDS.sleep(1);\n        thread.interrupt();\n    }\n\n    //最佳是抛出异常到方法签名\n    private static void throwInMethod() {\n        //如果用这样，则中断的时候会e.printStackTrace();但是会继续运行\n        //因为该方法不是run()方法，是底层被run()调用的方法，就导致没能响应中断，run的while循环仍然执行\n        //相当于把中断给吞掉了\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        }\n        catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<h4 id=\"抛出异常到方法签名（推荐）\"><a href=\"#抛出异常到方法签名（推荐）\" class=\"headerlink\" title=\"抛出异常到方法签名（推荐）\"></a>抛出异常到方法签名（推荐）</h4><pre><code class=\"java\">public class Thread1 {\n    /*\n    catch了InterruptedException后优先选择在方法签名中抛出异常\n\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -&gt; {\n            while (true) {\n                System.out.println(&quot;业务逻辑&quot;);\n                //run方法不能抛出异常，因为顶层的run方法没有异常，子类自然不能有\n                try {\n                    throwInMethod();\n                }\n                catch (InterruptedException e) {\n                    e.printStackTrace();\n                    System.out.println(&quot;保存日志&quot;);\n                    System.out.println(&quot;退出&quot;);\n                    break;\n                }\n            }\n        };\n\n        //线程使用\n        Thread thread = new Thread(runnable);\n        thread.start();\n        TimeUnit.SECONDS.sleep(1);\n        thread.interrupt();\n    }\n\n    //最佳是抛出异常到方法签名\n    private static void throwInMethod() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(2);\n    }\n}</code></pre>\n<h4 id=\"恢复中断（不想或者无法传递时）\"><a href=\"#恢复中断（不想或者无法传递时）\" class=\"headerlink\" title=\"恢复中断（不想或者无法传递时）\"></a>恢复中断（不想或者无法传递时）</h4><pre><code class=\"java\">public class Thread1 {\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -&gt; {\n            while (true) {\n                System.out.println(&quot;业务逻辑&quot;);\n                throwInMethod();\n\n                //因为重新设置了中断状态，所以是有效的\n                if (Thread.currentThread().isInterrupted()) {\n                    System.out.println(&quot;break&quot;);\n                    break;\n                }\n            }\n        };\n\n        //线程使用\n        Thread thread = new Thread(runnable);\n        thread.start();\n        TimeUnit.SECONDS.sleep(1);\n        thread.interrupt();\n    }\n\n    private static void throwInMethod() {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        }\n        catch (InterruptedException e) {\n            //恢复设置中断状态，以便于在后续执行时，仍然能够检查到刚刚发生了中断\n            Thread.currentThread().interrupt();\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<h2 id=\"线程生命周期\"><a href=\"#线程生命周期\" class=\"headerlink\" title=\"线程生命周期\"></a>线程生命周期</h2><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1611884091_1.png\" alt=\"img\"></p>\n<ul>\n<li>NEW：初始状态，线程被构建，但是没有调用start()</li>\n<li>RUNNABLE：运行状态，将操作系统的就绪和运行状态统称为RUNNABLE；有可能正在运行，也有可能等待CPU资源</li>\n<li>BLOCKED：阻塞状态，线程阻塞与锁；在程序等待进入同步区域时，将进入这种状态；在等待一个排它锁，该事件在另外一个线程放弃这个锁时发生；只有Synchronized修饰的，而且没有拿到锁，才是BLOCKED状态，其他锁不算</li>\n<li>WAITING：无限期等待状态，当前线程需要等待其他线程通知或中断；没有设置Timeout的Object::wait()；没有设置Timeout的Thread::join()；LockSupport::park()</li>\n<li>TIME_WAITING：超时等待状态，可以在指定的时间自行返回；Thread::sleep()；设置Timeout的Object::wait()；设置Timeout的Thread::join()；LockSupport::parkUntil()</li>\n<li>TERMINATED：终止状态，当前线程已经执行完毕</li>\n</ul>\n<h2 id=\"Object相关方法\"><a href=\"#Object相关方法\" class=\"headerlink\" title=\"Object相关方法\"></a>Object相关方法</h2><ul>\n<li><p>wait、notify、notifyAll定义在Object中，因为是锁级别的</p>\n</li>\n<li><p>wait需要在同步代码块内使用，用户必须先拥有monitor</p>\n</li>\n<li><p>wait()的作用是<strong>让当前线程进入等待状态</strong>，同时，wait()也会<strong>让当前线程释放它所持有的锁</strong>。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)</p>\n</li>\n<li><p>wait(long timeout)让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p>\n</li>\n<li><p>因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出IllegalMonitorStateException（正在等待的对象没有锁））</p>\n</li>\n<li><p>notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程（唤醒哪个取决于JVM），而notifyAll()是唤醒所有的线程</p>\n</li>\n<li><p>notify也要在synchronized使用，应该指定对象，t1.notify()，通知t1对象的等待池里的线程使一个线程进入锁定池，然后与锁定池中的线程争夺锁。那么为什么要在synchronized使用呢？ t1.notify()需要通知一个等待池中的线程，那么这时我们必须得获得t1的监视器（需要使用synchronized），才能对其操作，t1.notify()程序只是知道要对t1操作，但是是否可以操作与是否可以获得t1锁关联的监视器有关。</p>\n</li>\n</ul>\n<p><strong>唤醒时机</strong></p>\n<ul>\n<li>notify()本线程</li>\n<li>notifyAll()</li>\n<li>wait(long timeout)超时时间达到</li>\n<li>线程自身调用interrupt()</li>\n</ul>\n<pre><code class=\"java\">import java.util.concurrent.TimeUnit;\n\n\n/*\nThread-0线程开始执行！\nThread-1线程开始执行！\n线程Thread-1获取到了锁！\n线程Thread-0获取到了锁！\n */\npublic class MainTest {\n    private static Object object = new Object();\n\n    static class Thread1 extends Thread {\n        @Override\n        public void run() {\n            synchronized (object) {\n                System.out.println(Thread.currentThread().getName()+&quot;线程开始执行！&quot;);\n                try {\n                    object.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;获取到了锁！&quot;);\n            }\n        }\n    }\n    static class Thread2 extends Thread {\n        @Override\n        public void run() {\n            synchronized (object) {\n                System.out.println(Thread.currentThread().getName()+&quot;线程开始执行！&quot;);\n                object.notify();\n                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;获取到了锁！&quot;);\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread1 thread1 = new Thread1();\n        Thread2 thread2 = new Thread2();\n        thread1.start();\n        TimeUnit.MILLISECONDS.sleep(100);\n        thread2.start();\n    }\n}</code></pre>\n<h2 id=\"线程属性\"><a href=\"#线程属性\" class=\"headerlink\" title=\"线程属性\"></a>线程属性</h2><ul>\n<li>线程Id</li>\n<li>线程名称</li>\n<li>isDaemon(true代表是守护线程）<ul>\n<li>是给用户线程提供服务的</li>\n<li>默认情况下，Java进程会等待所有线程都运行结束，才会结束</li>\n<li>守护进程，如果所有非守护进程结束，守护进程也都结束了(垃圾回收器)</li>\n<li>如后台记录操作日志，监控内存，垃圾回收</li>\n<li>thread1.setDaemon(true);</li>\n</ul>\n</li>\n<li>priority（优先级）<ul>\n<li>10个优先级，默认是5</li>\n<li>优先级高度依赖于操作系统的优先级，Java映射过去的</li>\n<li>优先级会被操作系统改变</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Thread方法\"><a href=\"#Thread方法\" class=\"headerlink\" title=\"Thread方法\"></a>Thread方法</h2><h3 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep()\"></a>sleep()</h3><ul>\n<li>让当前执行的线程休眠n毫秒， 休眠时让出 cpu 的时间片给其它线程</li>\n<li>可以调用interrupt()方法唤醒，但是会抛出异常：InterruptedException，并且会清除中断状态</li>\n<li><strong>让线程进入Waiting状态，并且不占用CPU资源（阻塞），但不释放锁</strong></li>\n<li><strong>休眠期间被中断，则抛出异常并清除中断状态</strong></li>\n</ul>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h3><ul>\n<li>等待线程运行结束，可以控制线程的同步</li>\n<li>因为新的线程加入了我们，所以我们要等他执行完再出发</li>\n<li>main等待thread1执行完毕</li>\n<li>源码调用wait()一直休眠，但每一个线程在执行完run()都会执行notifyAll()</li>\n<li><strong>主线程在waiting状态</strong></li>\n</ul>\n<pre><code class=\"java\">/*\n开始等待所有子线程执行\nThread-0执行\nThread-1执行\n所有子线程执行完毕\n */\npublic class MainTest {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -&gt; {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + &quot;执行&quot;);\n        });\n        Thread thread2 = new Thread(() -&gt; {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + &quot;执行&quot;);\n        });\n\n        thread1.start();\n        thread2.start();\n        System.out.println(&quot;开始等待所有子线程执行&quot;);\n        thread1.join();\n        thread2.join();\n        System.out.println(&quot;所有子线程执行完毕&quot;);\n    }\n}</code></pre>\n<p><strong>等价代码</strong></p>\n<pre><code class=\"java\">import java.util.concurrent.TimeUnit;\n\npublic class MainTest {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(() -&gt; {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + &quot;执行&quot;);\n        });\n\n        thread.start();\n        System.out.println(&quot;开始等待所有子线程执行&quot;);\n//        thread.join();\n        //等价于以下语句：\n        /*\n        synchronized只是为了能调用wait()\n        主线程执行到下面语句，会阻塞，直到thread线程执行完，隐式的调用了notifyAll()  \n         */\n        synchronized (thread){\n            thread.wait();\n        }\n        System.out.println(&quot;所有子线程执行完毕&quot;);\n    }\n}</code></pre>\n<h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield()\"></a>yield()</h3><ul>\n<li>状态依旧是RUNNING状态</li>\n<li>提示线程调度器 让出当前线程对CPU的使用，具体要看操作系统实现</li>\n<li>让当前的线程暂停，但是不阻塞，从运行状态变为就绪状态</li>\n<li>让CPU重新调度，但是不能决定CPU</li>\n<li>不会释放锁</li>\n<li>为了稳定性，实际开发不使用，但是很多并发包使用</li>\n</ul>\n<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><ul>\n<li>ThreadLocal叫做线程本地变量或线程本地存储。为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。让某个需要使用的对象在线程间隔离（每个线程都有自己的独立的对象）</li>\n<li>initialValue：在ThreadLocal第一次get时就把对象给初始化出来，对象的初始化时机可以由我们控制</li>\n<li>set：如果需要保存到ThreadLocal里的对象的时机不由我们随意控制，例如拦截器里的用户信息，就用set存放</li>\n</ul>\n<h2 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>每个Thread中都有一个ThreadLocalMap </p>\n<pre><code class=\"java\">public class Thread implements Runnable {\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n}</code></pre>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529150659281.png\" alt=\"image-20210529150659281\"></p>\n<p><strong>ThreadLocalMap</strong> </p>\n<ul>\n<li>是一个Entry数组，Entry是一个键值对，键是该ThreadLocal，值是实际存储的对象</li>\n<li>遇到冲突采取的是线性探测法</li>\n</ul>\n<pre><code class=\"java\">class ThreadLocalMap{\n    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n        Object value;\n    }\n\n    private Entry[] table;\n\n    private void set(ThreadLocal&lt;?&gt; key, Object value) {\n\n    }\n}</code></pre>\n<h3 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h3><p>一般来说重写该方法</p>\n<pre><code class=\"java\">protected T initialValue() {\n    return null;\n}</code></pre>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h3><pre><code class=\"java\">public void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    //键值对：(this， value)\n    if (map != null)\n        map.set(this， value);\n    else\n        createMap(t， value);\n}</code></pre>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><pre><code class=\"java\">public T get() {\n    //先找到当前线程 再找到当前线程的ThreadLocalMap\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t); \n    if (map != null) {\n        //key是当前threadLocal引用\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(&quot;unchecked&quot;)\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n\n//如果get为null，则initialValue()\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this， value);\n    else\n        createMap(t， value);\n    return value;\n}</code></pre>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><pre><code class=\"java\">public void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}</code></pre>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><ul>\n<li>可能导致内存泄漏</li>\n<li>内存泄漏：某个对象不再有用，但是占用的内存却不能被回收</li>\n<li>ThreadLocalMap中的每个Entry都是一个对key的弱引用，对value的强引用</li>\n<li>正常情况下，线程终止，则保存在ThreadLocalMap里的value会被回收</li>\n<li>但是线程不终止（例如线程池），那么value就不会被回收：key会回收，因为key是弱引用，垃圾回收会回收，key为null、Thread-&gt;ThreadLocalMap-&gt;Entry(key为null)-&gt;value。</li>\n<li>JDK考虑过了，在set、remove、rehash方法中会扫描key为null的Entry，并把value设置为null，但如果一个线程中ThreadLocal不被调用，就不会执行上述操作</li>\n<li>阿里规约：在使用完ThreadLocal之后，主动调用remove方法：UserContextHolder.holder.remove();</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><h3 id=\"SimpleDateFormat\"><a href=\"#SimpleDateFormat\" class=\"headerlink\" title=\"SimpleDateFormat\"></a>SimpleDateFormat</h3><ul>\n<li>初始版本：使用线程池（创建很多个对象，效率低）</li>\n<li>把SimpleDateFormat当静态使用（会出现并发安全问题）</li>\n<li>用ThreadLocal实现</li>\n</ul>\n<pre><code class=\"java\">public class ThreadLocalUsage03 {\n    public static ThreadLocal&lt;SimpleDateFormat&gt; local = new ThreadLocal&lt;SimpleDateFormat&gt;(){\n        @Override\n        protected SimpleDateFormat initialValue() {\n            return new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);\n        }\n    };\n    public static ExecutorService executorService = Executors.newFixedThreadPool(10);\n\n    public String date(int seconds) {\n        //参数单位是ms，从1970.1.1 00:00:00 GMT计时\n        Date date = new Date(1000L * seconds);\n        return local.get().format(date);\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 1000; i++) {\n            int finalI = i;\n            executorService.submit(() -&gt; {\n                String date = new ThreadLocalUsage03().date(finalI);\n                System.out.println(date);\n            });\n        }\n        executorService.shutdown();\n    }\n}</code></pre>\n<h3 id=\"传递用户信息\"><a href=\"#传递用户信息\" class=\"headerlink\" title=\"传递用户信息\"></a>传递用户信息</h3><p>不同请求（不同线程）user对象不同</p>\n<p>即这些信息在同一个线程中相同，但是不同线程中使用的业务内容是不同的</p>\n<p>在线程生命周期内，都可以通过这个静态ThreadLocal实例的get()方法取得自己set过的那个对象，避免了将这个对象（例如user对象）作为参数传递的麻烦</p>\n<pre><code class=\"java\">public class UserContextHolder {\n    public static ThreadLocal&lt;User&gt; holder = new ThreadLocal&lt;&gt;();\n    public static void main(String[] args) {\n        new Service1().process();\n    }\n}\n\nclass Service1 {\n    public void process() {\n        User user = new User(&quot;张三&quot;， &quot;123456&quot;);\n        UserContextHolder.holder.set(user);\n        System.out.println(&quot;Service1:&quot;+user);\n        new Service2().process();\n    }\n}\n\nclass Service2 {\n    public void process() {\n        User user = UserContextHolder.holder.get();\n        System.out.println(&quot;Service2:&quot;+user);\n        new Service3().process();\n    }\n}\nclass Service3 {\n    public void process() {\n        User user = UserContextHolder.holder.get();\n        System.out.println(&quot;Service3:&quot;+user);\n    }\n}</code></pre>\n<h1 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>重用现有的线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销</li>\n<li>当请求到达时，工作线程已经存在，不会由于等待创建线程而延迟任务的执行</li>\n<li>通过适当调整线程池的大小，可以创建足够多的线程使处理器保存忙碌状态，又可以防止过多线程相互竞争资源使得应用程序耗尽内存</li>\n</ul>\n<h3 id=\"继承体系\"><a href=\"#继承体系\" class=\"headerlink\" title=\"继承体系\"></a>继承体系</h3><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201202211516638.png\" alt=\"image-20201202211516638\" style=\"zoom:50%;\" />\n\n<p>ThreadPoolExecutor是实际使用到的类，通过他的构造函数来实例化一个对象，并根据自己需求定制</p>\n<h3 id=\"关闭线程池\"><a href=\"#关闭线程池\" class=\"headerlink\" title=\"关闭线程池\"></a>关闭线程池</h3><ul>\n<li>shutdown：将执行平缓的关闭过程，不再接受新的任务，同时等待已提交任务执行完成，包括那些还未开始执行的任务</li>\n<li>shutdownNow：执行粗暴给关闭过程，立刻关闭！对正在执行的线程执行中断interrupt；不再启动队列中尚未开始的任务，返回在等待中的队列列表</li>\n</ul>\n<h2 id=\"运行规则\"><a href=\"#运行规则\" class=\"headerlink\" title=\"运行规则\"></a>运行规则</h2><ul>\n<li>如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程运行新任务</li>\n<li>如果线程数大于等于corePoolSize，但小于maximumPoolSize，则将任务放入workQueue队列</li>\n<li>如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务</li>\n<li>如果队列已满，并且线程数大于等于maxPoolSize，则拒绝该任务</li>\n<li>当一个线程无事可做，而且超过keepAliveTime，而且当前运行线程数大于corePoolSize则该线程停止。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小</li>\n</ul>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529104616059.png\" alt=\"image-20210529104616059\" style=\"zoom: 67%;\" />\n\n<h2 id=\"七大核心参数\"><a href=\"#七大核心参数\" class=\"headerlink\" title=\"七大核心参数\"></a>七大核心参数</h2><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>具体说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>corePoolSize</td>\n<td>核心线程数</td>\n<td>线程池中的常驻核心线程数，当线程池数量到达corePoolSize后，就会把到达的任务放到缓存队列当中</td>\n</tr>\n<tr>\n<td>maximumPoolSize</td>\n<td>最大线程数</td>\n<td>线程池能够容纳同时执行的最大线程数，必须大于等于1(当corePoolSize满了，workQueue也满了，则会扩容)</td>\n</tr>\n<tr>\n<td>keepAliveTime</td>\n<td>多余线程存活时间</td>\n<td>多余的空闲线程的存活时间，当前线程池数量超过corePoolSize时，当空闲时间到达keepAliveTime值时，会将线程销毁到corePoolSize数量</td>\n</tr>\n<tr>\n<td>TimeUnit unit</td>\n<td>设置时间单位</td>\n<td></td>\n</tr>\n<tr>\n<td>workQueue</td>\n<td>阻塞队列</td>\n<td>BlockingQueue<Runnable> workQueue</td>\n</tr>\n<tr>\n<td>threadFactory</td>\n<td>线程工厂</td>\n<td>ThreadFactory threadFactory，表示生成线程池中工作线程的线程工厂 一般默认即可</td>\n</tr>\n<tr>\n<td>Handler</td>\n<td>拒绝策略</td>\n<td>RejectedExecutionHandler handler 拒绝策略，当maximumPoolSize已经满了，则拒绝</td>\n</tr>\n</tbody></table>\n<h2 id=\"四种拒绝策略\"><a href=\"#四种拒绝策略\" class=\"headerlink\" title=\"四种拒绝策略\"></a>四种拒绝策略</h2><ul>\n<li>如果线程池被关闭则拒绝</li>\n<li>当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时</li>\n</ul>\n<h3 id=\"AbortPolicy（终止）\"><a href=\"#AbortPolicy（终止）\" class=\"headerlink\" title=\"AbortPolicy（终止）\"></a>AbortPolicy（终止）</h3><ul>\n<li>默认的拒绝策略</li>\n<li>抛出未检查的RejectExecution-Exception</li>\n<li>调用者可以捕获这个异常，然后根据需求编写自己的处理代码</li>\n<li>线程池的默认拒绝策略为AbortPolicy，即丢弃任务并抛出RejectedExecutionException异常</li>\n<li>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</li>\n</ul>\n<h3 id=\"DiscardPolicy（抛弃）\"><a href=\"#DiscardPolicy（抛弃）\" class=\"headerlink\" title=\"DiscardPolicy（抛弃）\"></a>DiscardPolicy（抛弃）</h3><ul>\n<li>丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</li>\n<li>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。</li>\n</ul>\n<h3 id=\"DiscardOldestPolicy（抛弃最旧）\"><a href=\"#DiscardOldestPolicy（抛弃最旧）\" class=\"headerlink\" title=\"DiscardOldestPolicy（抛弃最旧）\"></a>DiscardOldestPolicy（抛弃最旧）</h3><ul>\n<li>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li>\n<li>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。</li>\n</ul>\n<h3 id=\"CallerRunsPolicy\"><a href=\"#CallerRunsPolicy\" class=\"headerlink\" title=\"CallerRunsPolicy\"></a>CallerRunsPolicy</h3><p>既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，从而降低新任务的流量</p>\n<p>如果任务被拒绝了，则由调用线程（提交任务的线程）直接执行此任务</p>\n<h2 id=\"自定义线程池\"><a href=\"#自定义线程池\" class=\"headerlink\" title=\"自定义线程池\"></a>自定义线程池</h2><p>不允许在应用中显示创建线程，都是得使用线程池</p>\n<p>生产实践中不允许适用<code>Executors</code>去创建，因为他底层是<code>new LinkedBlockingQueue&lt;Runnable&gt;())</code>是无界队列，如果所有工作行程都处于忙碌状态，那么任务将在队列中等候，如果任务持续快速地到达，并且超过了线程池处理他们的速度，那么队列将无限制增加，可能会堆积大量请求，导致<code>OOM</code></p>\n<h3 id=\"线程池官方实现\"><a href=\"#线程池官方实现\" class=\"headerlink\" title=\"线程池官方实现\"></a>线程池官方实现</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210529110357928.png\" alt=\"image-20210529110357928\"></p>\n<pre><code class=\"java\">//适用于长期执行的任务，性能好很多 阻塞队列可能很大，会OOM\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads， nThreads，\n                                      0L， TimeUnit.MILLISECONDS，\n                                      new LinkedBlockingQueue&lt;Runnable&gt;());\n    }</code></pre>\n<pre><code class=\"java\">//适用于一个任务一个任务执行的场景 阻塞队列可能很大，会OOM\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1， 1，\n                                0L， TimeUnit.MILLISECONDS，\n                                new LinkedBlockingQueue&lt;Runnable&gt;()));\n}</code></pre>\n<pre><code class=\"java\">//适用执行很多短期异步的小程序或负载较轻的服务器\n//任务数量特别多时，就会创建很多的线程，会OOM\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0， Integer.MAX_VALUE，\n                                  60L， TimeUnit.SECONDS，\n                                  new SynchronousQueue&lt;Runnable&gt;());\n}</code></pre>\n<pre><code class=\"java\">// executorService.schedule(()-&gt;{System.out.println(&quot;1&quot;);}, 5, TimeUnit.SECONDS);\n// 支持定时，周期执行任务\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize， Integer.MAX_VALUE， 0， NANOSECONDS，\n              new DelayedWorkQueue());\n    }</code></pre>\n<h3 id=\"设置maximumPoolSize\"><a href=\"#设置maximumPoolSize\" class=\"headerlink\" title=\"设置maximumPoolSize\"></a>设置maximumPoolSize</h3><p>首先分析计算环境、资源预算，例如部署的系统有多少CPU：</p>\n<pre><code>System.out.println(Runtime.getRuntime().availableProcessors());</code></pre>\n<p>系统有多大的内存：计算每个任务对内存的需求量，用总内存/需求量，就得到线程池上限</p>\n<p>是否需像JDBC连接等稀缺资源：如果每个任务都需要一个数据库连接，那么连接池大小限制了线程池的大小</p>\n<p><strong>CPU密集型</strong></p>\n<p>线程池大小应该为处理器个数+1，能实现最优的使用率</p>\n<p>即使线程偶尔由于缺页故障等原因暂停时，额外的线程也能保证CPU的时钟周期不会被浪费</p>\n<p><strong>IO密集型</strong></p>\n<p>并不是一直在执行任务，则应该配置尽可能多的线程，如CPU核数*2</p>\n<p>线程不会一直执行，线程池规模应更大</p>\n<p>必须估算任务的等待时间与计算时间的比值</p>\n<p>线程池最优大小= CPU核数 * CPU利用率 * （1 + 任务等待时间/运行时间）</p>\n<h1 id=\"Future和Callable\"><a href=\"#Future和Callable\" class=\"headerlink\" title=\"Future和Callable\"></a>Future和Callable</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"Callable\"><a href=\"#Callable\" class=\"headerlink\" title=\"Callable\"></a>Callable</h3><ul>\n<li>Runnable不能返回一个返回值</li>\n<li>也不能抛出受查异常，只能try-catch。因为Runnable接口中run()方法没有抛出异常</li>\n<li>Callable接口类似Runnable，代表一个被其他线程执行的任务</li>\n</ul>\n<pre><code class=\"java\">public interface Callable&lt;V&gt; {\n    V call() throws Exception;\n}</code></pre>\n<h3 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h3><ul>\n<li>可以用Future.get()来获取Callable的执行结果；用Future.isDone()来判断任务是否执行完成</li>\n<li>在call()未执行完毕之前，调用get()的线程会被阻塞，直到call()方法返回了结果，future.get()才会得到结果</li>\n<li>Futute是一个存储器，存储了call()这个任务的结果</li>\n<li>例如给线程池提交我们的任务，提交后线程池会立刻返回给我们一个空的Future容器。当线程的任务一旦执行完毕，也就是当我们可以获取结果时，线程池就会把结果填入该Future中，便可以从原先那个Future获得任务执行的结果</li>\n</ul>\n<p><strong>ExecutorService</strong></p>\n<pre><code class=\"java\">public static void main(String[] args) throws ExecutionException, InterruptedException {\n    ExecutorService service = Executors.newFixedThreadPool(10);\n    Future&lt;Integer&gt; future = service.submit(new CallableTask());\n    System.out.println(future.get()); // 会阻塞3秒\n    service.shutdown();\n\n}\n\nstatic class CallableTask implements Callable&lt;Integer&gt; {\n    @Override\n    public Integer call() throws Exception {\n        Thread.sleep(3000);\n        return new Random().nextInt();\n    }\n}</code></pre>\n<p><strong>FutureTask</strong></p>\n<pre><code class=\"java\">public static void main(String[] args) throws ExecutionException, InterruptedException {\n    Task task = new Task();\n    FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task);\n    new Thread(futureTask).start();\n    System.out.println(futureTask.get());\n}\n\nstatic class Task implements Callable&lt;Integer&gt; {\n    @Override\n    public Integer call() throws Exception {\n        Thread.sleep(3000);\n        return new Random().nextInt();\n    }\n}</code></pre>\n"},{"title":"垃圾收集器","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习Java虚拟机笔记，包括可达性分析算法、垃圾收集算法、经典垃圾收集器等。","abbrlink":"6158ee9c","date":"2021-02-15T16:00:00.000Z","_content":"\n\n\n# 判定对象消亡\n\n## 引用计数算法\n\n无法解决循环引用的问题，即实际上这两个对象已经不可能被访问了，但因为它们互相引用着对方，导致它们的引用计数都不为零，引用计数算法就无法回收它们\n\n## 可达性分析算法\n\n+ 通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链\n+ 如果从GC Roots到某个对象不可达，则将把他们判定为可回收对象\n\n### GC Roots\n\n+ 在虚拟机栈(栈帧中的局部变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量\n+ 在方法区中类静态属性引用的对象，Java类的引用类型静态变量\n+ 在方法区中常量引用的对象，例如字符串常量池(String Table)里的引用\n+ 在本地方法栈中JNI(即Native方法)引用的对象\n+ 虚拟机内部的引用，如基本数据对应的Class对象、常驻的异常对象如NullPointException、OutOfMemoryError、系统类加载器\n+ 被同步锁（synchronized）持有的对象\n+ 反映虚拟机内部情况的本地代码缓存等\n+ 分代收集和局部回收（Partial GC）。如果只针对Java堆中某块区域发起垃圾收集时（如只针对新生代的垃圾收集），这个区域里的对象有可能被位于堆中其他区域的对象所引用。需要将关联区域的对象也一并加入到GC Roots集合中\n\n## 引用\n\n### 强引用\n\n- 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，那么该reference数据是代表某个对象的引用\n- 类似Object object = new Object();\n- 只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象\n\n### 软引用\n\n+ 只被软引用关联着的对象，在系统将要发生内存溢出异常之前，会将这些对象纳入回收范围进行二次回收\n+ 如果这次回收还没有足够的内存，才会抛出内存溢出异常\n+ SoftReference\n+ 缓存功能，一类对象，当内存空间足够时，能保存在内存中，如果内存空间在进行垃圾收集时仍然非常紧张，则可以抛弃这些对象\n\n### 弱引用\n\n+ 强度被软引用更弱\n+ 只能生存到下一次垃圾收集发生为止\n+ 无论内存是否充足，都会回收掉只被弱引用关联的对象\n\n### 虚引用\n\n+ 又称幽灵引用或幻影引用\n+ 是否有虚引用完全不会对其生命周期构成影响，也无法通过虚引用获取一个对象实例\n+ 唯一目的是为了能在这个对象被回收时收到一个系统通知\n\n## 回收方法区\n\n+ 主要回收废弃的常量和不再使用的类型\n+ 回收常量池，例如已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量，如果此时进行内存回收，而且确实有必要，则该常量将被系统清理出常量池\n+ 回收类。在大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义类加载器的场景，通常需要JVM具备类型卸载的能力\n    + 该类的所有的实例都已经被回收，Java堆中不存在该类及其任何派生子类的实例\n    + 加载该类的类加载器已经被回收，除非是精心设计的可替换类加载器的场景，否则很难达成\n    + 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问这个类的方法\n\n# 垃圾收集算法\n\n## 分代收集理论\n\n**分代收集**\n\n+ 弱分代假说：绝大多数对象都是朝生夕灭\n+ 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡\n+ 跨代引用假说：跨代引用相对于同代引用来说仅占极少数\n\n**设计原则**\n\n+ 将Java堆划分出不同的区域，根据回收对象年龄（即熬过垃圾收集的次数）分配到不同的区域中存储\n+ 划分不同区域后，垃圾收集器可以每次只回收其中一部分区域，根据不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法\n\n**新生代**\n\n+ 每次垃圾收集时都有大批对象死去，而每次回收后存活的少量对象，将会逐步晋身到老年代中存放\n+ 如果只进行Minor GC，但新生代对象可能被老年代引用，为了找出存活对象，不得不再固定GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性\n+ 依据假说，不应为了少量的跨带引用去扫描整个老年代，只需要在新生代上建立一个全局的数据结构（记忆集），这个结构把老年代分成若干小块，标识出老年代哪一块内存会存在跨带引用\n+ 此后Minor GC，只有包含了跨带引用的小块内存里的对象才会被加入GC Roots中进行扫描\n\n## 算法\n\n### 标记-清除算法\n\n+ 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象\n+ 执行效率不稳定，标记和清除两个过程的执行效率都随对象数量增长而降低\n+ 会产生大量不连续的内存碎片，导致只会程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作\n\n### 标记-复制算法(针对新生代)\n\n+ 半区复制，将可用内存按容量划分成大小相等的两块，每次只使用其中一块，如果这一块内存用完了，就将存活的对象复制到另外一块上，再把已使用过的内存空间清理掉\n+ 对于多数对象是可回收的情况，算法需要复制的只是占少数的存活对象，无碎片空间问题\n+ 代价是可用内存缩小为原来一半\n+ Appel式回收\n    + 把新生代分为Eden，和Survivor0，Survivor1区，大小为8:1:1\n    + 每次分配内存只使用Eden和Survivor0区\n    + 将Eden和Survivor0中存活对象一次性复制到Survivor1区\n    + 当Survivor空间不足以容纳一次Minor GC之后存活的对象，就通过分配担保机制直接进入老年代\n\n现在的商业虚拟机都采用复制收集算法来回收新生代，有研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，并不能保证每次回收都只有10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行**分配担保**（Handle Promotion）。即如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。\n\n### 标记-整理算法(针对老年代)\n\n+ 先标记，然后让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存\n+ 移动存活对象并更新所有引用这些对象的地方必须暂停用户应用程序才能进行(Stop the World)\n+ 但如果不管空间碎片化问题，则直接影响应用程序的吞吐量\n+ 关注吞吐量的Parallel Scavenge基于标记-整理\n+ 关注延迟的CMS基于标记-清除：在空间碎片过多，影响到对象分配时，再采用标记整理算法收集一次\n\n# HotSpot算法细节\n\n## 根节点枚举\n\n+ 固定可作为GC Roots的节点主要是全局性的引用(例如常量或类静态属性)与执行上下文(例如堆栈中的本地变量表)\n+ 所有收集器在根节点枚举这一步骤都是必须暂停用户线程的\n+ 必须在一个能保障一致性的快照中才得以进行，整个枚举期间，执行子系统看起来就像是冻结在某个时间点上\n+ 用户线程停顿之后，不需要一个不漏地检查完所有执行上下文和全局的引用位置。可以使用一组称为OopMap的数据结构直接得到哪些地方存在着对象引用\n\n## 安全点\n\n+ 通过OopMap，HotSpot可以快速完成GC Roots的枚举，但不可能每条指令都生成OopMap，只是在特定的地方记录了这些位置，即安全点\n+ 用户程序执行时并非在代码指令流的任意位置都能停顿下来开始垃圾收集，而是强制要求必须执行到达安全点才能够暂停\n+ 安全点的选择一般是以能否让程序长时间执行的特征为标准选定的，一般是指令序列的复用，例如方法调用、循环跳转、异常跳转等才会产生安全点\n+ 还要考虑如何让垃圾收集发生时让所有线程都跑到最近的安全点，并停顿\n+ 抢先式中断\n    + 在垃圾收集发生时，系统首先把所有线程中断，如果发现用户线程中断地方不再安全点上，就恢复线程继续执行，让它一会再中断，直到跑到安全点。\n    + 几乎没有虚拟机使用\n+ 主动式中断\n    + 设置一个标志位，各个线程执行过程中不停地主动轮询这个标志，一旦发现标志为真就自己在最近的安全点上主动中断挂起\n    + 使用内存保护陷阱的方式，把轮询操作精简到只有一条汇编指令\n    + 仅通过一条汇编指令就完成安全点轮询和触发线程中断\n\n## 安全区域\n\n+ 如果用户线程处于Sleep状态或Blocked状态，即没有分配处理器时间。此时线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己。\n+ 安全区域是指能够确保某一段程序代码中，引用关系不会发生改变，因此，在这个区域从任意地方开始垃圾收集都是安全的\n+ 当用户线程执行到安全区域里面的代码，首先标识自己已经进入了安全区域，这段时间如果发生垃圾收集JVM不会管这些已经声明在安全区域里面的代码。当要离开安全区域时，它要检查JVM是否完成了根节点枚举，如果完成则继续执行，如果没完成，则一直等待直到收到可以离开安全区域的信号为止\n\n## 记忆集和卡表\n\n+ 为解决对象跨带引用的问题，使用记忆集来避免把整个老年代加入GC Roots的扫描范围\n+ 记忆集是一种用来记录从非收集区域指向收集区域的指针集合的数据结构，最简单是用非收集区域中所有含跨带引用的对象数组来实现，但是空间占用太高\n+ 收集者只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可，可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本\n\n### 卡表（card table)\n\n+ 每个记录精确到一块内存区域，该区域内有对象含有跨带引用\n+ 卡表是记忆集的一种具体实现\n+ 使用字节数组，因为速度上现在计算机硬件是按字节编址\n+ CARD_TABLE[this.address >> 9] = 0\n+ 每一个元素都对应着其标识的内存区域中一块特定大小的内存块\n+ 一个卡页（512字节）的内存中通常不止包含一个对象，只要里面有一个存在跨带指针，就置为1，元素变脏。\n+ 在垃圾收集时，只要筛选出变脏的元素，就能知道哪有跨带指针，就加入GC Roots\n\n## 写屏障\n\n+ 变脏时间点应该发生在引用类型字段赋值的那一刻，如何在此时更新维护卡表\n+ 必须找到一个在机器码层面的手段，把维护卡表的动作放在每一个赋值操作之中\n+ 使用写屏障技术维护卡表状态，可以看作是虚拟机层面对“引用类型赋值”这个动作的AOP切面，在引用对象赋值时产生一个环绕通知，供程序执行额外的操作。应用了写后屏障\n+ 伪共享问题\n    + 缓存系统以缓存行为单位存储，如果多个线程修改互相独立的变量，而这些变量恰好在共享同一个缓存行，就彼此影响\n    + 可以先检查卡表标记，只有当卡表元素没有被标记时才标记为变脏\n\n## 并发的可达性分析\n\n+ 从GC Roots再继续往下遍历对象图的时间与堆容量成正比\n\n+ 三色标记法，如果收集器再对象图上标记颜色，同时用户线程在修改引用关系（对象图的结构）\n\n+ 两种可能：\n\n    + 把原本消亡的对象误标记为存活，可以接受。只是产生了逃过本次收集的浮动垃圾\n    + 把原本存活的对象误标记为消亡，非常致命\n\n+ 对象消亡两个条件\n\n    + 新增了黑色到白色对象的新引用。\n    + 删除了灰色到该白色对象的所有引用\n\n+ 两种解决，破坏两个条件之一即可。都是通过写屏障实现\n\n    + 增量更新。理解为当黑色对象一旦插入了指向白色对象的引用后，它就变回灰色对象。\n    + 原始快照。无论引用对象删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。\n\n    \n\n# 经典垃圾收集器\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/abcd.png)\n\n## Young generation\n\n### Serial收集器\n\n+ 单线程工作的收集器\n+ 在进行垃圾收集时，必须先暂停其他所有线程，直到它收集结束\n+ 客户端模式下默认的新生代收集器，简单而高效\n+ 对于内存资源受限的环境下，是所有收集器里额外内存消耗最小的\n+ 对于单核处理器或核心较少的环境收集效率最高\n\n### ParNew收集器\n\n+ 是Serial收集器的多线程并发版本\n+ 除了Serial收集器，只有它能和CMS收集器配合\n+ 在单线程环境下不比Serial收集器好\n+ 也是需要STW，只是多线程一起并发收集罢了\n\n### Parallel Scavenge收集器\n\n+ 同样基于标记-复制算法，同样并行收集的多线程收集器\n+ 称作吞吐量优先收集器\n+ 可以达到一个可控制的吞吐量，即处理器用于运行用户代码的时间/处理器总消耗时间\n+ 垃圾收集的自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或最大吞吐量\n\n## Tenured generation\n\n### Serial Old收集器\n\n+ 单线程收集器，使用标记-整理算法\n+ 供客户端模式使用\n+ 可作为CMS收集器发生失败时的后备预案\n+ 可以配合Parallel Scavenge收集器\n\n### Parallel Old收集器\n\n+ 支持多线程并发收集\n+ 使用标记-整理算法\n+ 吞吐量优先收集器有了比较好的组合：Parallel Scavenge收集器+ Parallel Old收集器\n\n### CMS收集器\n\n+ Concurrent Mark Sweep\n+ 以最短回收停顿时间为目标的收集器\n+ 并发收集，低停顿\n+ 基于标记-清除算法\n+ 互联网网站等Java项目通常较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验\n\n**步骤**\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/Rc4defd801698e946aa0b9bc91d8fc4f6)\n\n+ 初始标记：标记一下GC Roots能直接关联的对象，速度很快。需要STW\n+ 并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长，但不需要停顿用户线程\n+ 重新标记：需要STW，修改并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，使用增量更新\n+ 并发清除：可以与用户线程同时并发的，清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象。时间较长\n\n**缺点**\n\n+ 对处理器资源非常敏感：并发阶段，占用一部分线程导致应用程序变慢，降低总吞吐量\n+ 无法处理浮动垃圾\n    + 由于垃圾收集阶段用户线程需要持续运行，程序运行自然还会伴随有新的垃圾对象产生，而且这些垃圾对象是出现在标记过程结束之后，CMS无法在当次收集中处理掉他们，只好留待下一次垃圾收集时再清理掉，即浮动垃圾。\n    + 而且用户线程需要持续运行，所以需要预留足够的内存空间给用户线程使用(默认92%)\n    + 如果运行期间预留的内存无法满足程序分配新对象的需要，可能出现Concurrent Mode Failure(并发失败)\n    + 则不得不启动后背方案：冻结用户线程的执行，临时启用Serial Old收集器来进行老年代的垃圾收集\n+ 基于标记清除算法，会产生大量的空间碎片：无法找到足够大的连续空间来分配给当前对象，不得不提前Full GC\n\n## Garbage First收集器\n\n+ 面向局部收集，基于Region的内存布局，全功能垃圾收集器\n+ 主要面向服务器应用，服务器模式下默认的垃圾收集器\n+ 建立停顿时间模型，支持指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒\n+ Mixed GC模式：面向堆的任何部分来组成回收集，衡量哪块内存中存放的垃圾数量最多，回收收益最大\n+ 非常精确地控制停顿\n\n### 实现\n\n+ 把连续的Java堆划分为多个大小相等的独立区域\n+ 每个Region可以扮演新生代的Eden、Survivor或老年代空间\n+ Humongous区域，专门存储大对象：大小超过Region容量一半的对象、超级大对象放在连续的Humongous区域、把Humongous区域看作老年代\n+ 将Region作为单位回收的最小单元，每次回收Region的整数倍\n+ 让G1去跟踪各个Region里面垃圾的价值大小（回收所获得的空间大小以及回收所需时间的经验值）\n+ 在后台维护一个优先级列表，优先处理回收价值收益最大的region\n\n### 细节\n\n+ 跨Region引用对象\n\n    + 每个Region都维护自己的记忆集\n    + 记录别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内\n    + 是一个哈希表，Key是别的Region起始地址，Value是卡表索引号集合\n    + 至少要耗费堆的10%-20%额外内存来维持收集器工作\n\n+ 并发标记阶段\n\n    + 对象引用关系改变，不打破原有对象图。使用原始快照（SATB）算法\n    + 新对象创建：设计两个指针，名为TAMS(Top at Mark Start)，把Region中一部分空间划分出来用于并发回收过程中的新对象分配，新分配对象必须在两个指针位置以上，默认这些对象是存活的，如果内存回收速度赶不上内存分配速度，也要STW的Full GC。\n\n+ 建立可靠的停顿预测模型\n\n    + 记录每个Region的回收耗时、记忆集中脏卡数量等成本，计算统计信息\n\n    + 比普通平均值更容易收到新数据的影响，衰减平均值更准确的代表最近的平均状态\n\n    + Region的统计状态越新越能决定其回收价值\n\n    + 通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高收益\n\n        \n\n### 步骤\n\n+ 初始标记\n    + 标记GC Roots能直接关联到的对象\n    + 修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用Region上分配新对象\n    + 需要停顿线程，但耗时短，而且是借用Minor GC同步完成的，没有额外停顿\n+ 并发标记\n    + 堆中对象的可达性分析，递归扫描整个堆中对象图\n    + 耗时长，能与用户线程并发执行\n    + 处理在SATB记录下的在并发时有引用变动的对象\n+ 最终标记\n    + 对用户线程做另一个短暂暂停，处理并发阶段结束后遗留下来的最后那少量的SATB记录\n+ 筛选回收\n    + 更新Region的统计数据\n    + 对Region的回收价值和成本排序\n    + 根据用户所期望的停顿时间制定回收计划\n    + 把决定回收的Region的存活对象复制到空Region中，清理旧Region的全部空间\n    + 必须STW，由多条垃圾收集器线程并发完成\n\n### 特点\n\n+ 在延迟可控的情况下获得尽可能高的吞吐量\n\n+ 取得关注吞吐量和关注延迟之间的最佳平衡\n\n+ 如果停顿时间过短，会导致每次筛选出来的回收集只占堆内存很小一部分，最终占满堆引发Full GC降低性能，停顿时间设置在100-300ms之间比较合理\n\n+ 整体是基于标记-整理的\n\n+ 局部是基于标记-复制的\n\n+ 不会产生内存空间碎片，收集后能提供规整的可用内存\n\n+ 使用写后屏障进行卡表维护操作\n\n+ 使用写前屏障来跟踪并发时的指针变化，实现SATB算法\n\n+ 小内存上CMS大概率优于G1（6-8GB为平衡点）\n\n    \n\n# 垃圾收集实战\n\n+ 实验环境：HotSpot、客户端模式、Serial+Serial Old\n+ 对象的内存分配：大部分堆上分配，极小部分经过即时编译后拆散为标量类型并间接栈上分配\n+ 新生对象通常分配新生代，少数情况（对象大小超过阈值）直接分配老年代\n\n## 对象优先在Eden分配\n\n+ 大多数情况下，对象在Eden区分配，如果Eden区没有足够空间分配，将发起Minor GC\n+ MinGC中，如果Survivor放不下Eden存活的，则通过对象担保机制，把存活的放入老年代\n+ -Xms20M -Xmx20M：堆大小20M，不可扩展\n+ -Xmn10M：10MB分配给新生代\n+ -XX:SurvivorRatio=8：Eden：Survivor = 8：1，新生代总可用区间9216KB(Eden+一个Survivor)\n+ -XX:+PrintGCDetails\n\n```\nVM参数:\n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:SurvivorRatio=8 \n-XX:+PrintGCDetails\n```\n\n```java\npublic class Main{\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1， allocation2， allocation3， allocation4;\n        allocation1 = new byte[2 * _1MB];\n        allocation2 = new byte[2 * _1MB];\n        allocation3 = new byte[2 * _1MB];\n        allocation4 = new byte[4 * _1MB]; //出现Minor GC\n    }\n}\n```\n\n```java\n[GC (Allocation Failure) [DefNew: 8159K->626K(9216K)， 0.0041610 secs] 8159K->6770K(19456K)， 0.0042168 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \nHeap\n def new generation   total 9216K， used 4888K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  52% used [0x00000000fec00000， 0x00000000ff029840， 0x00000000ff400000)\n  from space 1024K，  61% used [0x00000000ff500000， 0x00000000ff59c960， 0x00000000ff600000)\n  to   space 1024K，   0% used [0x00000000ff400000， 0x00000000ff400000， 0x00000000ff500000)\n tenured generation   total 10240K， used 6144K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  60% used [0x00000000ff600000， 0x00000000ffc00030， 0x00000000ffc00200， 0x0000000100000000)\n Metaspace       used 3253K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 353K， capacity 388K， committed 512K， reserved 1048576K\n\nProcess finished with exit code 0\n\n```\n\n## 大对象直接进入老年代\n\n+ 大对象就是需要连续内存空间的Java对象\n+ 很长的字符串或者元素数量很庞大的数组\n+ 在程序中避免出现一群朝生夕灭的短命大对象\n+ 他容易导致内存明明还有不少空间就提前触发了垃圾收集，以获取足够的连续空间才能安置好他们\n+ 当复制对象时，大对象意味着高额的内存复制开销\n+ -XX:PretenureSizeThreshold=3145728\n+ 可设置参数，指定大于设定值的对象直接在老年代分配，避免在Eden区以及两个Survivor区来回复制，产生大量的内存复制操作\n\n```java\n-XX:PretenureSizeThreshold=3145728 \n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC \n-XX:SurvivorRatio=8 -XX:+PrintGCDetails\n```\n\n\n\n```java\npublic class Main{\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1;\n        allocation1 = new byte[4 * _1MB];//直接分配在老年代\n    }\n}\n```\n\n```java\nHeap\n def new generation   total 9216K， used 2015K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  24% used [0x00000000fec00000， 0x00000000fedf7e90， 0x00000000ff400000)\n  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff400000， 0x00000000ff500000)\n  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)\n tenured generation   total 10240K， used 4096K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  40% used [0x00000000ff600000， 0x00000000ffa00010， 0x00000000ffa00200， 0x0000000100000000)\n Metaspace       used 3210K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 352K， capacity 388K， committed 512K， reserved 1048576K\n```\n\n## 长期存活的对象将进入老年代\n\n+ 每个对象对象头定义了一个对象年龄计数器\n+ 对象通常在Eden区诞生，如果经过第一次Minor GC仍然存活，并且能被Survivor容纳，则被移动到Survivor空间中，并且年龄设置为1\n+ 对象在Survivor区每熬过一次Minor GC，年龄+1\n+ 增长到15时，就会被晋升到老年代，晋升阈值通过-XX:MaxTenuringThreshold设置\n+ 当-XX:MaxTenuringThreshold设置为1时，allocation1在第二次GC发生时进入老年代\n\n```java\n-XX:+PrintTenuringDistribution -XX:MaxTenuringThreshold=1 \n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC \n-XX:SurvivorRatio=8 -XX:+PrintGCDetails\n```\n\n```java\npublic class Main {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1， allocation2， allocation3;\n        allocation1 = new byte[_1MB / 4];//什么时候进入老年代决定于-XX:MaxTenuringThreshold设置\n        allocation2 = new byte[4 * _1MB];\n        allocation3 = new byte[4 * _1MB];\n        allocation3 = null;\n        allocation3 = new byte[4 * _1MB];\n    }\n}\n```\n\n```java\n[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 1 (max 1)\n- age   1:     886440 bytes，     886440 total\n: 6367K->865K(9216K)， 0.0055780 secs] 6367K->4961K(19456K)， 0.0056123 secs] [Times: user=0.00 sys=0.00， real=0.01 secs] \n[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 1 (max 1)\n- age   1:        680 bytes，        680 total\n: 5045K->0K(9216K)， 0.0012428 secs] 9141K->4958K(19456K)， 0.0012696 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \nHeap\n def new generation   total 9216K， used 4235K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  51% used [0x00000000fec00000， 0x00000000ff022a70， 0x00000000ff400000)\n  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff4002a8， 0x00000000ff500000)\n  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)\n tenured generation   total 10240K， used 4958K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  48% used [0x00000000ff600000， 0x00000000ffad7800， 0x00000000ffad7800， 0x0000000100000000)\n Metaspace       used 3286K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 357K， capacity 388K， committed 512K， reserved 1048576K\n```\n\n## 动态对象年龄判断\n\n如果在Survivor空间中相同年龄所有对象大小的总和大于Survovor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代\n\n```java\n-XX:+PrintTenuringDistribution -XX:MaxTenuringThreshold=1 \n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC \n-XX:SurvivorRatio=8 -XX:+PrintGCDetails\n```\n\n```java\npublic class Main {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1， allocation2， allocation3， allocation4;\n        allocation1 = new byte[_1MB / 4];//allocation1 + allocation2 大于 survivor空间的一半了\n        allocation2 = new byte[_1MB / 4];\n        allocation3 = new byte[4 * _1MB];\n        allocation4 = new byte[4 * _1MB];\n        allocation4 = null;\n        allocation4 = new byte[4 * _1MB];\n    }\n}\n```\n\n```java\n[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 1 (max 15)\n- age   1:    1048576 bytes，    1048576 total\n: 6623K->1024K(9216K)， 0.0039616 secs] 6623K->5234K(19456K)， 0.0040033 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \n[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 15 (max 15)\n- age   1:        176 bytes，        176 total\n: 5204K->0K(9216K)， 0.0011999 secs] 9414K->5234K(19456K)， 0.0012304 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \nHeap\n def new generation   total 9216K， used 4234K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  51% used [0x00000000fec00000， 0x00000000ff0227f0， 0x00000000ff400000)\n  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff4000b0， 0x00000000ff500000)\n  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)\n tenured generation   total 10240K， used 5234K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  51% used [0x00000000ff600000， 0x00000000ffb1c9a0， 0x00000000ffb1ca00， 0x0000000100000000)\n Metaspace       used 3247K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 353K， capacity 388K， committed 512K， reserved 1048576K\n```\n\n## 空间分配担保\n\n+ 在Minor GC前，检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果成立，则这次Minor GC安全。\n+ 否则要看是否允许担保失败。如果允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的平均大小，如果大于，将尝试进行一次Minor GC。如果小于，或者不允许担保，则Full GC。\n+ 新生代中，当出现大量对象在Minor GC后仍然存活的情况，就把Survivor无法容纳的对象直接送入老年代，担保前提是老年代本身有容纳这些对象的剩余空间。\n+ 但一共有多少对象会在这次回收中存活下来在实际回收完成之前是无法明确知道的，只能取之前每一次回收晋升老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间\n+ 担保失败则又得Full GC，绕的圈子最大，但一般打开，避免Full GC过于频繁\n+ 在JDK7及之后。不能设置参数影响空间分配担保策略。只要老年代最大可用连续空间大于新生代的所有对象空间，或者大于历次晋升到老年代的平均大小，就进行Minor GC，负责Full GC（相当于一定会冒险）\n\n","source":"_posts/Java语言/Java虚拟机/2.垃圾收集器.md","raw":"---\ntitle: 垃圾收集器\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 学习Java虚拟机笔记，包括可达性分析算法、垃圾收集算法、经典垃圾收集器等。\ncategories: Java虚拟机\ntags:\n  - 引用\n  - 算法\n  - 垃圾收集器\nabbrlink: 6158ee9c\ndate: 2021-02-16 00:00:00\n---\n\n\n\n# 判定对象消亡\n\n## 引用计数算法\n\n无法解决循环引用的问题，即实际上这两个对象已经不可能被访问了，但因为它们互相引用着对方，导致它们的引用计数都不为零，引用计数算法就无法回收它们\n\n## 可达性分析算法\n\n+ 通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链\n+ 如果从GC Roots到某个对象不可达，则将把他们判定为可回收对象\n\n### GC Roots\n\n+ 在虚拟机栈(栈帧中的局部变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量\n+ 在方法区中类静态属性引用的对象，Java类的引用类型静态变量\n+ 在方法区中常量引用的对象，例如字符串常量池(String Table)里的引用\n+ 在本地方法栈中JNI(即Native方法)引用的对象\n+ 虚拟机内部的引用，如基本数据对应的Class对象、常驻的异常对象如NullPointException、OutOfMemoryError、系统类加载器\n+ 被同步锁（synchronized）持有的对象\n+ 反映虚拟机内部情况的本地代码缓存等\n+ 分代收集和局部回收（Partial GC）。如果只针对Java堆中某块区域发起垃圾收集时（如只针对新生代的垃圾收集），这个区域里的对象有可能被位于堆中其他区域的对象所引用。需要将关联区域的对象也一并加入到GC Roots集合中\n\n## 引用\n\n### 强引用\n\n- 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，那么该reference数据是代表某个对象的引用\n- 类似Object object = new Object();\n- 只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象\n\n### 软引用\n\n+ 只被软引用关联着的对象，在系统将要发生内存溢出异常之前，会将这些对象纳入回收范围进行二次回收\n+ 如果这次回收还没有足够的内存，才会抛出内存溢出异常\n+ SoftReference\n+ 缓存功能，一类对象，当内存空间足够时，能保存在内存中，如果内存空间在进行垃圾收集时仍然非常紧张，则可以抛弃这些对象\n\n### 弱引用\n\n+ 强度被软引用更弱\n+ 只能生存到下一次垃圾收集发生为止\n+ 无论内存是否充足，都会回收掉只被弱引用关联的对象\n\n### 虚引用\n\n+ 又称幽灵引用或幻影引用\n+ 是否有虚引用完全不会对其生命周期构成影响，也无法通过虚引用获取一个对象实例\n+ 唯一目的是为了能在这个对象被回收时收到一个系统通知\n\n## 回收方法区\n\n+ 主要回收废弃的常量和不再使用的类型\n+ 回收常量池，例如已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量，如果此时进行内存回收，而且确实有必要，则该常量将被系统清理出常量池\n+ 回收类。在大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义类加载器的场景，通常需要JVM具备类型卸载的能力\n    + 该类的所有的实例都已经被回收，Java堆中不存在该类及其任何派生子类的实例\n    + 加载该类的类加载器已经被回收，除非是精心设计的可替换类加载器的场景，否则很难达成\n    + 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问这个类的方法\n\n# 垃圾收集算法\n\n## 分代收集理论\n\n**分代收集**\n\n+ 弱分代假说：绝大多数对象都是朝生夕灭\n+ 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡\n+ 跨代引用假说：跨代引用相对于同代引用来说仅占极少数\n\n**设计原则**\n\n+ 将Java堆划分出不同的区域，根据回收对象年龄（即熬过垃圾收集的次数）分配到不同的区域中存储\n+ 划分不同区域后，垃圾收集器可以每次只回收其中一部分区域，根据不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法\n\n**新生代**\n\n+ 每次垃圾收集时都有大批对象死去，而每次回收后存活的少量对象，将会逐步晋身到老年代中存放\n+ 如果只进行Minor GC，但新生代对象可能被老年代引用，为了找出存活对象，不得不再固定GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性\n+ 依据假说，不应为了少量的跨带引用去扫描整个老年代，只需要在新生代上建立一个全局的数据结构（记忆集），这个结构把老年代分成若干小块，标识出老年代哪一块内存会存在跨带引用\n+ 此后Minor GC，只有包含了跨带引用的小块内存里的对象才会被加入GC Roots中进行扫描\n\n## 算法\n\n### 标记-清除算法\n\n+ 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象\n+ 执行效率不稳定，标记和清除两个过程的执行效率都随对象数量增长而降低\n+ 会产生大量不连续的内存碎片，导致只会程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作\n\n### 标记-复制算法(针对新生代)\n\n+ 半区复制，将可用内存按容量划分成大小相等的两块，每次只使用其中一块，如果这一块内存用完了，就将存活的对象复制到另外一块上，再把已使用过的内存空间清理掉\n+ 对于多数对象是可回收的情况，算法需要复制的只是占少数的存活对象，无碎片空间问题\n+ 代价是可用内存缩小为原来一半\n+ Appel式回收\n    + 把新生代分为Eden，和Survivor0，Survivor1区，大小为8:1:1\n    + 每次分配内存只使用Eden和Survivor0区\n    + 将Eden和Survivor0中存活对象一次性复制到Survivor1区\n    + 当Survivor空间不足以容纳一次Minor GC之后存活的对象，就通过分配担保机制直接进入老年代\n\n现在的商业虚拟机都采用复制收集算法来回收新生代，有研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，并不能保证每次回收都只有10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行**分配担保**（Handle Promotion）。即如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。\n\n### 标记-整理算法(针对老年代)\n\n+ 先标记，然后让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存\n+ 移动存活对象并更新所有引用这些对象的地方必须暂停用户应用程序才能进行(Stop the World)\n+ 但如果不管空间碎片化问题，则直接影响应用程序的吞吐量\n+ 关注吞吐量的Parallel Scavenge基于标记-整理\n+ 关注延迟的CMS基于标记-清除：在空间碎片过多，影响到对象分配时，再采用标记整理算法收集一次\n\n# HotSpot算法细节\n\n## 根节点枚举\n\n+ 固定可作为GC Roots的节点主要是全局性的引用(例如常量或类静态属性)与执行上下文(例如堆栈中的本地变量表)\n+ 所有收集器在根节点枚举这一步骤都是必须暂停用户线程的\n+ 必须在一个能保障一致性的快照中才得以进行，整个枚举期间，执行子系统看起来就像是冻结在某个时间点上\n+ 用户线程停顿之后，不需要一个不漏地检查完所有执行上下文和全局的引用位置。可以使用一组称为OopMap的数据结构直接得到哪些地方存在着对象引用\n\n## 安全点\n\n+ 通过OopMap，HotSpot可以快速完成GC Roots的枚举，但不可能每条指令都生成OopMap，只是在特定的地方记录了这些位置，即安全点\n+ 用户程序执行时并非在代码指令流的任意位置都能停顿下来开始垃圾收集，而是强制要求必须执行到达安全点才能够暂停\n+ 安全点的选择一般是以能否让程序长时间执行的特征为标准选定的，一般是指令序列的复用，例如方法调用、循环跳转、异常跳转等才会产生安全点\n+ 还要考虑如何让垃圾收集发生时让所有线程都跑到最近的安全点，并停顿\n+ 抢先式中断\n    + 在垃圾收集发生时，系统首先把所有线程中断，如果发现用户线程中断地方不再安全点上，就恢复线程继续执行，让它一会再中断，直到跑到安全点。\n    + 几乎没有虚拟机使用\n+ 主动式中断\n    + 设置一个标志位，各个线程执行过程中不停地主动轮询这个标志，一旦发现标志为真就自己在最近的安全点上主动中断挂起\n    + 使用内存保护陷阱的方式，把轮询操作精简到只有一条汇编指令\n    + 仅通过一条汇编指令就完成安全点轮询和触发线程中断\n\n## 安全区域\n\n+ 如果用户线程处于Sleep状态或Blocked状态，即没有分配处理器时间。此时线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己。\n+ 安全区域是指能够确保某一段程序代码中，引用关系不会发生改变，因此，在这个区域从任意地方开始垃圾收集都是安全的\n+ 当用户线程执行到安全区域里面的代码，首先标识自己已经进入了安全区域，这段时间如果发生垃圾收集JVM不会管这些已经声明在安全区域里面的代码。当要离开安全区域时，它要检查JVM是否完成了根节点枚举，如果完成则继续执行，如果没完成，则一直等待直到收到可以离开安全区域的信号为止\n\n## 记忆集和卡表\n\n+ 为解决对象跨带引用的问题，使用记忆集来避免把整个老年代加入GC Roots的扫描范围\n+ 记忆集是一种用来记录从非收集区域指向收集区域的指针集合的数据结构，最简单是用非收集区域中所有含跨带引用的对象数组来实现，但是空间占用太高\n+ 收集者只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可，可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本\n\n### 卡表（card table)\n\n+ 每个记录精确到一块内存区域，该区域内有对象含有跨带引用\n+ 卡表是记忆集的一种具体实现\n+ 使用字节数组，因为速度上现在计算机硬件是按字节编址\n+ CARD_TABLE[this.address >> 9] = 0\n+ 每一个元素都对应着其标识的内存区域中一块特定大小的内存块\n+ 一个卡页（512字节）的内存中通常不止包含一个对象，只要里面有一个存在跨带指针，就置为1，元素变脏。\n+ 在垃圾收集时，只要筛选出变脏的元素，就能知道哪有跨带指针，就加入GC Roots\n\n## 写屏障\n\n+ 变脏时间点应该发生在引用类型字段赋值的那一刻，如何在此时更新维护卡表\n+ 必须找到一个在机器码层面的手段，把维护卡表的动作放在每一个赋值操作之中\n+ 使用写屏障技术维护卡表状态，可以看作是虚拟机层面对“引用类型赋值”这个动作的AOP切面，在引用对象赋值时产生一个环绕通知，供程序执行额外的操作。应用了写后屏障\n+ 伪共享问题\n    + 缓存系统以缓存行为单位存储，如果多个线程修改互相独立的变量，而这些变量恰好在共享同一个缓存行，就彼此影响\n    + 可以先检查卡表标记，只有当卡表元素没有被标记时才标记为变脏\n\n## 并发的可达性分析\n\n+ 从GC Roots再继续往下遍历对象图的时间与堆容量成正比\n\n+ 三色标记法，如果收集器再对象图上标记颜色，同时用户线程在修改引用关系（对象图的结构）\n\n+ 两种可能：\n\n    + 把原本消亡的对象误标记为存活，可以接受。只是产生了逃过本次收集的浮动垃圾\n    + 把原本存活的对象误标记为消亡，非常致命\n\n+ 对象消亡两个条件\n\n    + 新增了黑色到白色对象的新引用。\n    + 删除了灰色到该白色对象的所有引用\n\n+ 两种解决，破坏两个条件之一即可。都是通过写屏障实现\n\n    + 增量更新。理解为当黑色对象一旦插入了指向白色对象的引用后，它就变回灰色对象。\n    + 原始快照。无论引用对象删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。\n\n    \n\n# 经典垃圾收集器\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/abcd.png)\n\n## Young generation\n\n### Serial收集器\n\n+ 单线程工作的收集器\n+ 在进行垃圾收集时，必须先暂停其他所有线程，直到它收集结束\n+ 客户端模式下默认的新生代收集器，简单而高效\n+ 对于内存资源受限的环境下，是所有收集器里额外内存消耗最小的\n+ 对于单核处理器或核心较少的环境收集效率最高\n\n### ParNew收集器\n\n+ 是Serial收集器的多线程并发版本\n+ 除了Serial收集器，只有它能和CMS收集器配合\n+ 在单线程环境下不比Serial收集器好\n+ 也是需要STW，只是多线程一起并发收集罢了\n\n### Parallel Scavenge收集器\n\n+ 同样基于标记-复制算法，同样并行收集的多线程收集器\n+ 称作吞吐量优先收集器\n+ 可以达到一个可控制的吞吐量，即处理器用于运行用户代码的时间/处理器总消耗时间\n+ 垃圾收集的自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或最大吞吐量\n\n## Tenured generation\n\n### Serial Old收集器\n\n+ 单线程收集器，使用标记-整理算法\n+ 供客户端模式使用\n+ 可作为CMS收集器发生失败时的后备预案\n+ 可以配合Parallel Scavenge收集器\n\n### Parallel Old收集器\n\n+ 支持多线程并发收集\n+ 使用标记-整理算法\n+ 吞吐量优先收集器有了比较好的组合：Parallel Scavenge收集器+ Parallel Old收集器\n\n### CMS收集器\n\n+ Concurrent Mark Sweep\n+ 以最短回收停顿时间为目标的收集器\n+ 并发收集，低停顿\n+ 基于标记-清除算法\n+ 互联网网站等Java项目通常较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验\n\n**步骤**\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/Rc4defd801698e946aa0b9bc91d8fc4f6)\n\n+ 初始标记：标记一下GC Roots能直接关联的对象，速度很快。需要STW\n+ 并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长，但不需要停顿用户线程\n+ 重新标记：需要STW，修改并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，使用增量更新\n+ 并发清除：可以与用户线程同时并发的，清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象。时间较长\n\n**缺点**\n\n+ 对处理器资源非常敏感：并发阶段，占用一部分线程导致应用程序变慢，降低总吞吐量\n+ 无法处理浮动垃圾\n    + 由于垃圾收集阶段用户线程需要持续运行，程序运行自然还会伴随有新的垃圾对象产生，而且这些垃圾对象是出现在标记过程结束之后，CMS无法在当次收集中处理掉他们，只好留待下一次垃圾收集时再清理掉，即浮动垃圾。\n    + 而且用户线程需要持续运行，所以需要预留足够的内存空间给用户线程使用(默认92%)\n    + 如果运行期间预留的内存无法满足程序分配新对象的需要，可能出现Concurrent Mode Failure(并发失败)\n    + 则不得不启动后背方案：冻结用户线程的执行，临时启用Serial Old收集器来进行老年代的垃圾收集\n+ 基于标记清除算法，会产生大量的空间碎片：无法找到足够大的连续空间来分配给当前对象，不得不提前Full GC\n\n## Garbage First收集器\n\n+ 面向局部收集，基于Region的内存布局，全功能垃圾收集器\n+ 主要面向服务器应用，服务器模式下默认的垃圾收集器\n+ 建立停顿时间模型，支持指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒\n+ Mixed GC模式：面向堆的任何部分来组成回收集，衡量哪块内存中存放的垃圾数量最多，回收收益最大\n+ 非常精确地控制停顿\n\n### 实现\n\n+ 把连续的Java堆划分为多个大小相等的独立区域\n+ 每个Region可以扮演新生代的Eden、Survivor或老年代空间\n+ Humongous区域，专门存储大对象：大小超过Region容量一半的对象、超级大对象放在连续的Humongous区域、把Humongous区域看作老年代\n+ 将Region作为单位回收的最小单元，每次回收Region的整数倍\n+ 让G1去跟踪各个Region里面垃圾的价值大小（回收所获得的空间大小以及回收所需时间的经验值）\n+ 在后台维护一个优先级列表，优先处理回收价值收益最大的region\n\n### 细节\n\n+ 跨Region引用对象\n\n    + 每个Region都维护自己的记忆集\n    + 记录别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内\n    + 是一个哈希表，Key是别的Region起始地址，Value是卡表索引号集合\n    + 至少要耗费堆的10%-20%额外内存来维持收集器工作\n\n+ 并发标记阶段\n\n    + 对象引用关系改变，不打破原有对象图。使用原始快照（SATB）算法\n    + 新对象创建：设计两个指针，名为TAMS(Top at Mark Start)，把Region中一部分空间划分出来用于并发回收过程中的新对象分配，新分配对象必须在两个指针位置以上，默认这些对象是存活的，如果内存回收速度赶不上内存分配速度，也要STW的Full GC。\n\n+ 建立可靠的停顿预测模型\n\n    + 记录每个Region的回收耗时、记忆集中脏卡数量等成本，计算统计信息\n\n    + 比普通平均值更容易收到新数据的影响，衰减平均值更准确的代表最近的平均状态\n\n    + Region的统计状态越新越能决定其回收价值\n\n    + 通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高收益\n\n        \n\n### 步骤\n\n+ 初始标记\n    + 标记GC Roots能直接关联到的对象\n    + 修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用Region上分配新对象\n    + 需要停顿线程，但耗时短，而且是借用Minor GC同步完成的，没有额外停顿\n+ 并发标记\n    + 堆中对象的可达性分析，递归扫描整个堆中对象图\n    + 耗时长，能与用户线程并发执行\n    + 处理在SATB记录下的在并发时有引用变动的对象\n+ 最终标记\n    + 对用户线程做另一个短暂暂停，处理并发阶段结束后遗留下来的最后那少量的SATB记录\n+ 筛选回收\n    + 更新Region的统计数据\n    + 对Region的回收价值和成本排序\n    + 根据用户所期望的停顿时间制定回收计划\n    + 把决定回收的Region的存活对象复制到空Region中，清理旧Region的全部空间\n    + 必须STW，由多条垃圾收集器线程并发完成\n\n### 特点\n\n+ 在延迟可控的情况下获得尽可能高的吞吐量\n\n+ 取得关注吞吐量和关注延迟之间的最佳平衡\n\n+ 如果停顿时间过短，会导致每次筛选出来的回收集只占堆内存很小一部分，最终占满堆引发Full GC降低性能，停顿时间设置在100-300ms之间比较合理\n\n+ 整体是基于标记-整理的\n\n+ 局部是基于标记-复制的\n\n+ 不会产生内存空间碎片，收集后能提供规整的可用内存\n\n+ 使用写后屏障进行卡表维护操作\n\n+ 使用写前屏障来跟踪并发时的指针变化，实现SATB算法\n\n+ 小内存上CMS大概率优于G1（6-8GB为平衡点）\n\n    \n\n# 垃圾收集实战\n\n+ 实验环境：HotSpot、客户端模式、Serial+Serial Old\n+ 对象的内存分配：大部分堆上分配，极小部分经过即时编译后拆散为标量类型并间接栈上分配\n+ 新生对象通常分配新生代，少数情况（对象大小超过阈值）直接分配老年代\n\n## 对象优先在Eden分配\n\n+ 大多数情况下，对象在Eden区分配，如果Eden区没有足够空间分配，将发起Minor GC\n+ MinGC中，如果Survivor放不下Eden存活的，则通过对象担保机制，把存活的放入老年代\n+ -Xms20M -Xmx20M：堆大小20M，不可扩展\n+ -Xmn10M：10MB分配给新生代\n+ -XX:SurvivorRatio=8：Eden：Survivor = 8：1，新生代总可用区间9216KB(Eden+一个Survivor)\n+ -XX:+PrintGCDetails\n\n```\nVM参数:\n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:SurvivorRatio=8 \n-XX:+PrintGCDetails\n```\n\n```java\npublic class Main{\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1， allocation2， allocation3， allocation4;\n        allocation1 = new byte[2 * _1MB];\n        allocation2 = new byte[2 * _1MB];\n        allocation3 = new byte[2 * _1MB];\n        allocation4 = new byte[4 * _1MB]; //出现Minor GC\n    }\n}\n```\n\n```java\n[GC (Allocation Failure) [DefNew: 8159K->626K(9216K)， 0.0041610 secs] 8159K->6770K(19456K)， 0.0042168 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \nHeap\n def new generation   total 9216K， used 4888K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  52% used [0x00000000fec00000， 0x00000000ff029840， 0x00000000ff400000)\n  from space 1024K，  61% used [0x00000000ff500000， 0x00000000ff59c960， 0x00000000ff600000)\n  to   space 1024K，   0% used [0x00000000ff400000， 0x00000000ff400000， 0x00000000ff500000)\n tenured generation   total 10240K， used 6144K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  60% used [0x00000000ff600000， 0x00000000ffc00030， 0x00000000ffc00200， 0x0000000100000000)\n Metaspace       used 3253K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 353K， capacity 388K， committed 512K， reserved 1048576K\n\nProcess finished with exit code 0\n\n```\n\n## 大对象直接进入老年代\n\n+ 大对象就是需要连续内存空间的Java对象\n+ 很长的字符串或者元素数量很庞大的数组\n+ 在程序中避免出现一群朝生夕灭的短命大对象\n+ 他容易导致内存明明还有不少空间就提前触发了垃圾收集，以获取足够的连续空间才能安置好他们\n+ 当复制对象时，大对象意味着高额的内存复制开销\n+ -XX:PretenureSizeThreshold=3145728\n+ 可设置参数，指定大于设定值的对象直接在老年代分配，避免在Eden区以及两个Survivor区来回复制，产生大量的内存复制操作\n\n```java\n-XX:PretenureSizeThreshold=3145728 \n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC \n-XX:SurvivorRatio=8 -XX:+PrintGCDetails\n```\n\n\n\n```java\npublic class Main{\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1;\n        allocation1 = new byte[4 * _1MB];//直接分配在老年代\n    }\n}\n```\n\n```java\nHeap\n def new generation   total 9216K， used 2015K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  24% used [0x00000000fec00000， 0x00000000fedf7e90， 0x00000000ff400000)\n  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff400000， 0x00000000ff500000)\n  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)\n tenured generation   total 10240K， used 4096K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  40% used [0x00000000ff600000， 0x00000000ffa00010， 0x00000000ffa00200， 0x0000000100000000)\n Metaspace       used 3210K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 352K， capacity 388K， committed 512K， reserved 1048576K\n```\n\n## 长期存活的对象将进入老年代\n\n+ 每个对象对象头定义了一个对象年龄计数器\n+ 对象通常在Eden区诞生，如果经过第一次Minor GC仍然存活，并且能被Survivor容纳，则被移动到Survivor空间中，并且年龄设置为1\n+ 对象在Survivor区每熬过一次Minor GC，年龄+1\n+ 增长到15时，就会被晋升到老年代，晋升阈值通过-XX:MaxTenuringThreshold设置\n+ 当-XX:MaxTenuringThreshold设置为1时，allocation1在第二次GC发生时进入老年代\n\n```java\n-XX:+PrintTenuringDistribution -XX:MaxTenuringThreshold=1 \n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC \n-XX:SurvivorRatio=8 -XX:+PrintGCDetails\n```\n\n```java\npublic class Main {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1， allocation2， allocation3;\n        allocation1 = new byte[_1MB / 4];//什么时候进入老年代决定于-XX:MaxTenuringThreshold设置\n        allocation2 = new byte[4 * _1MB];\n        allocation3 = new byte[4 * _1MB];\n        allocation3 = null;\n        allocation3 = new byte[4 * _1MB];\n    }\n}\n```\n\n```java\n[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 1 (max 1)\n- age   1:     886440 bytes，     886440 total\n: 6367K->865K(9216K)， 0.0055780 secs] 6367K->4961K(19456K)， 0.0056123 secs] [Times: user=0.00 sys=0.00， real=0.01 secs] \n[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 1 (max 1)\n- age   1:        680 bytes，        680 total\n: 5045K->0K(9216K)， 0.0012428 secs] 9141K->4958K(19456K)， 0.0012696 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \nHeap\n def new generation   total 9216K， used 4235K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  51% used [0x00000000fec00000， 0x00000000ff022a70， 0x00000000ff400000)\n  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff4002a8， 0x00000000ff500000)\n  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)\n tenured generation   total 10240K， used 4958K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  48% used [0x00000000ff600000， 0x00000000ffad7800， 0x00000000ffad7800， 0x0000000100000000)\n Metaspace       used 3286K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 357K， capacity 388K， committed 512K， reserved 1048576K\n```\n\n## 动态对象年龄判断\n\n如果在Survivor空间中相同年龄所有对象大小的总和大于Survovor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代\n\n```java\n-XX:+PrintTenuringDistribution -XX:MaxTenuringThreshold=1 \n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC \n-XX:SurvivorRatio=8 -XX:+PrintGCDetails\n```\n\n```java\npublic class Main {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1， allocation2， allocation3， allocation4;\n        allocation1 = new byte[_1MB / 4];//allocation1 + allocation2 大于 survivor空间的一半了\n        allocation2 = new byte[_1MB / 4];\n        allocation3 = new byte[4 * _1MB];\n        allocation4 = new byte[4 * _1MB];\n        allocation4 = null;\n        allocation4 = new byte[4 * _1MB];\n    }\n}\n```\n\n```java\n[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 1 (max 15)\n- age   1:    1048576 bytes，    1048576 total\n: 6623K->1024K(9216K)， 0.0039616 secs] 6623K->5234K(19456K)， 0.0040033 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \n[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 15 (max 15)\n- age   1:        176 bytes，        176 total\n: 5204K->0K(9216K)， 0.0011999 secs] 9414K->5234K(19456K)， 0.0012304 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \nHeap\n def new generation   total 9216K， used 4234K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  51% used [0x00000000fec00000， 0x00000000ff0227f0， 0x00000000ff400000)\n  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff4000b0， 0x00000000ff500000)\n  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)\n tenured generation   total 10240K， used 5234K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  51% used [0x00000000ff600000， 0x00000000ffb1c9a0， 0x00000000ffb1ca00， 0x0000000100000000)\n Metaspace       used 3247K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 353K， capacity 388K， committed 512K， reserved 1048576K\n```\n\n## 空间分配担保\n\n+ 在Minor GC前，检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果成立，则这次Minor GC安全。\n+ 否则要看是否允许担保失败。如果允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的平均大小，如果大于，将尝试进行一次Minor GC。如果小于，或者不允许担保，则Full GC。\n+ 新生代中，当出现大量对象在Minor GC后仍然存活的情况，就把Survivor无法容纳的对象直接送入老年代，担保前提是老年代本身有容纳这些对象的剩余空间。\n+ 但一共有多少对象会在这次回收中存活下来在实际回收完成之前是无法明确知道的，只能取之前每一次回收晋升老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间\n+ 担保失败则又得Full GC，绕的圈子最大，但一般打开，避免Full GC过于频繁\n+ 在JDK7及之后。不能设置参数影响空间分配担保策略。只要老年代最大可用连续空间大于新生代的所有对象空间，或者大于历次晋升到老年代的平均大小，就进行Minor GC，负责Full GC（相当于一定会冒险）\n\n","slug":"Java语言/Java虚拟机/2.垃圾收集器","published":1,"updated":"2021-06-08T03:35:00.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq50s000bz0tp4a2hbf8y","content":"<h1 id=\"判定对象消亡\"><a href=\"#判定对象消亡\" class=\"headerlink\" title=\"判定对象消亡\"></a>判定对象消亡</h1><h2 id=\"引用计数算法\"><a href=\"#引用计数算法\" class=\"headerlink\" title=\"引用计数算法\"></a>引用计数算法</h2><p>无法解决循环引用的问题，即实际上这两个对象已经不可能被访问了，但因为它们互相引用着对方，导致它们的引用计数都不为零，引用计数算法就无法回收它们</p>\n<h2 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h2><ul>\n<li>通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链</li>\n<li>如果从GC Roots到某个对象不可达，则将把他们判定为可回收对象</li>\n</ul>\n<h3 id=\"GC-Roots\"><a href=\"#GC-Roots\" class=\"headerlink\" title=\"GC Roots\"></a>GC Roots</h3><ul>\n<li>在虚拟机栈(栈帧中的局部变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量</li>\n<li>在方法区中类静态属性引用的对象，Java类的引用类型静态变量</li>\n<li>在方法区中常量引用的对象，例如字符串常量池(String Table)里的引用</li>\n<li>在本地方法栈中JNI(即Native方法)引用的对象</li>\n<li>虚拟机内部的引用，如基本数据对应的Class对象、常驻的异常对象如NullPointException、OutOfMemoryError、系统类加载器</li>\n<li>被同步锁（synchronized）持有的对象</li>\n<li>反映虚拟机内部情况的本地代码缓存等</li>\n<li>分代收集和局部回收（Partial GC）。如果只针对Java堆中某块区域发起垃圾收集时（如只针对新生代的垃圾收集），这个区域里的对象有可能被位于堆中其他区域的对象所引用。需要将关联区域的对象也一并加入到GC Roots集合中</li>\n</ul>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><ul>\n<li>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，那么该reference数据是代表某个对象的引用</li>\n<li>类似Object object = new Object();</li>\n<li>只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象</li>\n</ul>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><ul>\n<li>只被软引用关联着的对象，在系统将要发生内存溢出异常之前，会将这些对象纳入回收范围进行二次回收</li>\n<li>如果这次回收还没有足够的内存，才会抛出内存溢出异常</li>\n<li>SoftReference</li>\n<li>缓存功能，一类对象，当内存空间足够时，能保存在内存中，如果内存空间在进行垃圾收集时仍然非常紧张，则可以抛弃这些对象</li>\n</ul>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><ul>\n<li>强度被软引用更弱</li>\n<li>只能生存到下一次垃圾收集发生为止</li>\n<li>无论内存是否充足，都会回收掉只被弱引用关联的对象</li>\n</ul>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><ul>\n<li>又称幽灵引用或幻影引用</li>\n<li>是否有虚引用完全不会对其生命周期构成影响，也无法通过虚引用获取一个对象实例</li>\n<li>唯一目的是为了能在这个对象被回收时收到一个系统通知</li>\n</ul>\n<h2 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h2><ul>\n<li>主要回收废弃的常量和不再使用的类型</li>\n<li>回收常量池，例如已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量，如果此时进行内存回收，而且确实有必要，则该常量将被系统清理出常量池</li>\n<li>回收类。在大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义类加载器的场景，通常需要JVM具备类型卸载的能力<ul>\n<li>该类的所有的实例都已经被回收，Java堆中不存在该类及其任何派生子类的实例</li>\n<li>加载该类的类加载器已经被回收，除非是精心设计的可替换类加载器的场景，否则很难达成</li>\n<li>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问这个类的方法</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h1><h2 id=\"分代收集理论\"><a href=\"#分代收集理论\" class=\"headerlink\" title=\"分代收集理论\"></a>分代收集理论</h2><p><strong>分代收集</strong></p>\n<ul>\n<li>弱分代假说：绝大多数对象都是朝生夕灭</li>\n<li>强分代假说：熬过越多次垃圾收集过程的对象就越难消亡</li>\n<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数</li>\n</ul>\n<p><strong>设计原则</strong></p>\n<ul>\n<li>将Java堆划分出不同的区域，根据回收对象年龄（即熬过垃圾收集的次数）分配到不同的区域中存储</li>\n<li>划分不同区域后，垃圾收集器可以每次只回收其中一部分区域，根据不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法</li>\n</ul>\n<p><strong>新生代</strong></p>\n<ul>\n<li>每次垃圾收集时都有大批对象死去，而每次回收后存活的少量对象，将会逐步晋身到老年代中存放</li>\n<li>如果只进行Minor GC，但新生代对象可能被老年代引用，为了找出存活对象，不得不再固定GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性</li>\n<li>依据假说，不应为了少量的跨带引用去扫描整个老年代，只需要在新生代上建立一个全局的数据结构（记忆集），这个结构把老年代分成若干小块，标识出老年代哪一块内存会存在跨带引用</li>\n<li>此后Minor GC，只有包含了跨带引用的小块内存里的对象才会被加入GC Roots中进行扫描</li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><ul>\n<li>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象</li>\n<li>执行效率不稳定，标记和清除两个过程的执行效率都随对象数量增长而降低</li>\n<li>会产生大量不连续的内存碎片，导致只会程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作</li>\n</ul>\n<h3 id=\"标记-复制算法-针对新生代\"><a href=\"#标记-复制算法-针对新生代\" class=\"headerlink\" title=\"标记-复制算法(针对新生代)\"></a>标记-复制算法(针对新生代)</h3><ul>\n<li>半区复制，将可用内存按容量划分成大小相等的两块，每次只使用其中一块，如果这一块内存用完了，就将存活的对象复制到另外一块上，再把已使用过的内存空间清理掉</li>\n<li>对于多数对象是可回收的情况，算法需要复制的只是占少数的存活对象，无碎片空间问题</li>\n<li>代价是可用内存缩小为原来一半</li>\n<li>Appel式回收<ul>\n<li>把新生代分为Eden，和Survivor0，Survivor1区，大小为8:1:1</li>\n<li>每次分配内存只使用Eden和Survivor0区</li>\n<li>将Eden和Survivor0中存活对象一次性复制到Survivor1区</li>\n<li>当Survivor空间不足以容纳一次Minor GC之后存活的对象，就通过分配担保机制直接进入老年代</li>\n</ul>\n</li>\n</ul>\n<p>现在的商业虚拟机都采用复制收集算法来回收新生代，有研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，并不能保证每次回收都只有10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行<strong>分配担保</strong>（Handle Promotion）。即如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p>\n<h3 id=\"标记-整理算法-针对老年代\"><a href=\"#标记-整理算法-针对老年代\" class=\"headerlink\" title=\"标记-整理算法(针对老年代)\"></a>标记-整理算法(针对老年代)</h3><ul>\n<li>先标记，然后让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存</li>\n<li>移动存活对象并更新所有引用这些对象的地方必须暂停用户应用程序才能进行(Stop the World)</li>\n<li>但如果不管空间碎片化问题，则直接影响应用程序的吞吐量</li>\n<li>关注吞吐量的Parallel Scavenge基于标记-整理</li>\n<li>关注延迟的CMS基于标记-清除：在空间碎片过多，影响到对象分配时，再采用标记整理算法收集一次</li>\n</ul>\n<h1 id=\"HotSpot算法细节\"><a href=\"#HotSpot算法细节\" class=\"headerlink\" title=\"HotSpot算法细节\"></a>HotSpot算法细节</h1><h2 id=\"根节点枚举\"><a href=\"#根节点枚举\" class=\"headerlink\" title=\"根节点枚举\"></a>根节点枚举</h2><ul>\n<li>固定可作为GC Roots的节点主要是全局性的引用(例如常量或类静态属性)与执行上下文(例如堆栈中的本地变量表)</li>\n<li>所有收集器在根节点枚举这一步骤都是必须暂停用户线程的</li>\n<li>必须在一个能保障一致性的快照中才得以进行，整个枚举期间，执行子系统看起来就像是冻结在某个时间点上</li>\n<li>用户线程停顿之后，不需要一个不漏地检查完所有执行上下文和全局的引用位置。可以使用一组称为OopMap的数据结构直接得到哪些地方存在着对象引用</li>\n</ul>\n<h2 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h2><ul>\n<li>通过OopMap，HotSpot可以快速完成GC Roots的枚举，但不可能每条指令都生成OopMap，只是在特定的地方记录了这些位置，即安全点</li>\n<li>用户程序执行时并非在代码指令流的任意位置都能停顿下来开始垃圾收集，而是强制要求必须执行到达安全点才能够暂停</li>\n<li>安全点的选择一般是以能否让程序长时间执行的特征为标准选定的，一般是指令序列的复用，例如方法调用、循环跳转、异常跳转等才会产生安全点</li>\n<li>还要考虑如何让垃圾收集发生时让所有线程都跑到最近的安全点，并停顿</li>\n<li>抢先式中断<ul>\n<li>在垃圾收集发生时，系统首先把所有线程中断，如果发现用户线程中断地方不再安全点上，就恢复线程继续执行，让它一会再中断，直到跑到安全点。</li>\n<li>几乎没有虚拟机使用</li>\n</ul>\n</li>\n<li>主动式中断<ul>\n<li>设置一个标志位，各个线程执行过程中不停地主动轮询这个标志，一旦发现标志为真就自己在最近的安全点上主动中断挂起</li>\n<li>使用内存保护陷阱的方式，把轮询操作精简到只有一条汇编指令</li>\n<li>仅通过一条汇编指令就完成安全点轮询和触发线程中断</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h2><ul>\n<li>如果用户线程处于Sleep状态或Blocked状态，即没有分配处理器时间。此时线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己。</li>\n<li>安全区域是指能够确保某一段程序代码中，引用关系不会发生改变，因此，在这个区域从任意地方开始垃圾收集都是安全的</li>\n<li>当用户线程执行到安全区域里面的代码，首先标识自己已经进入了安全区域，这段时间如果发生垃圾收集JVM不会管这些已经声明在安全区域里面的代码。当要离开安全区域时，它要检查JVM是否完成了根节点枚举，如果完成则继续执行，如果没完成，则一直等待直到收到可以离开安全区域的信号为止</li>\n</ul>\n<h2 id=\"记忆集和卡表\"><a href=\"#记忆集和卡表\" class=\"headerlink\" title=\"记忆集和卡表\"></a>记忆集和卡表</h2><ul>\n<li>为解决对象跨带引用的问题，使用记忆集来避免把整个老年代加入GC Roots的扫描范围</li>\n<li>记忆集是一种用来记录从非收集区域指向收集区域的指针集合的数据结构，最简单是用非收集区域中所有含跨带引用的对象数组来实现，但是空间占用太高</li>\n<li>收集者只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可，可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本</li>\n</ul>\n<h3 id=\"卡表（card-table\"><a href=\"#卡表（card-table\" class=\"headerlink\" title=\"卡表（card table)\"></a>卡表（card table)</h3><ul>\n<li>每个记录精确到一块内存区域，该区域内有对象含有跨带引用</li>\n<li>卡表是记忆集的一种具体实现</li>\n<li>使用字节数组，因为速度上现在计算机硬件是按字节编址</li>\n<li>CARD_TABLE[this.address &gt;&gt; 9] = 0</li>\n<li>每一个元素都对应着其标识的内存区域中一块特定大小的内存块</li>\n<li>一个卡页（512字节）的内存中通常不止包含一个对象，只要里面有一个存在跨带指针，就置为1，元素变脏。</li>\n<li>在垃圾收集时，只要筛选出变脏的元素，就能知道哪有跨带指针，就加入GC Roots</li>\n</ul>\n<h2 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h2><ul>\n<li>变脏时间点应该发生在引用类型字段赋值的那一刻，如何在此时更新维护卡表</li>\n<li>必须找到一个在机器码层面的手段，把维护卡表的动作放在每一个赋值操作之中</li>\n<li>使用写屏障技术维护卡表状态，可以看作是虚拟机层面对“引用类型赋值”这个动作的AOP切面，在引用对象赋值时产生一个环绕通知，供程序执行额外的操作。应用了写后屏障</li>\n<li>伪共享问题<ul>\n<li>缓存系统以缓存行为单位存储，如果多个线程修改互相独立的变量，而这些变量恰好在共享同一个缓存行，就彼此影响</li>\n<li>可以先检查卡表标记，只有当卡表元素没有被标记时才标记为变脏</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"并发的可达性分析\"><a href=\"#并发的可达性分析\" class=\"headerlink\" title=\"并发的可达性分析\"></a>并发的可达性分析</h2><ul>\n<li><p>从GC Roots再继续往下遍历对象图的时间与堆容量成正比</p>\n</li>\n<li><p>三色标记法，如果收集器再对象图上标记颜色，同时用户线程在修改引用关系（对象图的结构）</p>\n</li>\n<li><p>两种可能：</p>\n<ul>\n<li>把原本消亡的对象误标记为存活，可以接受。只是产生了逃过本次收集的浮动垃圾</li>\n<li>把原本存活的对象误标记为消亡，非常致命</li>\n</ul>\n</li>\n<li><p>对象消亡两个条件</p>\n<ul>\n<li>新增了黑色到白色对象的新引用。</li>\n<li>删除了灰色到该白色对象的所有引用</li>\n</ul>\n</li>\n<li><p>两种解决，破坏两个条件之一即可。都是通过写屏障实现</p>\n<ul>\n<li>增量更新。理解为当黑色对象一旦插入了指向白色对象的引用后，它就变回灰色对象。</li>\n<li>原始快照。无论引用对象删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"经典垃圾收集器\"><a href=\"#经典垃圾收集器\" class=\"headerlink\" title=\"经典垃圾收集器\"></a>经典垃圾收集器</h1><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/abcd.png\" alt=\"img\"></p>\n<h2 id=\"Young-generation\"><a href=\"#Young-generation\" class=\"headerlink\" title=\"Young generation\"></a>Young generation</h2><h3 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h3><ul>\n<li>单线程工作的收集器</li>\n<li>在进行垃圾收集时，必须先暂停其他所有线程，直到它收集结束</li>\n<li>客户端模式下默认的新生代收集器，简单而高效</li>\n<li>对于内存资源受限的环境下，是所有收集器里额外内存消耗最小的</li>\n<li>对于单核处理器或核心较少的环境收集效率最高</li>\n</ul>\n<h3 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h3><ul>\n<li>是Serial收集器的多线程并发版本</li>\n<li>除了Serial收集器，只有它能和CMS收集器配合</li>\n<li>在单线程环境下不比Serial收集器好</li>\n<li>也是需要STW，只是多线程一起并发收集罢了</li>\n</ul>\n<h3 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h3><ul>\n<li>同样基于标记-复制算法，同样并行收集的多线程收集器</li>\n<li>称作吞吐量优先收集器</li>\n<li>可以达到一个可控制的吞吐量，即处理器用于运行用户代码的时间/处理器总消耗时间</li>\n<li>垃圾收集的自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或最大吞吐量</li>\n</ul>\n<h2 id=\"Tenured-generation\"><a href=\"#Tenured-generation\" class=\"headerlink\" title=\"Tenured generation\"></a>Tenured generation</h2><h3 id=\"Serial-Old收集器\"><a href=\"#Serial-Old收集器\" class=\"headerlink\" title=\"Serial Old收集器\"></a>Serial Old收集器</h3><ul>\n<li>单线程收集器，使用标记-整理算法</li>\n<li>供客户端模式使用</li>\n<li>可作为CMS收集器发生失败时的后备预案</li>\n<li>可以配合Parallel Scavenge收集器</li>\n</ul>\n<h3 id=\"Parallel-Old收集器\"><a href=\"#Parallel-Old收集器\" class=\"headerlink\" title=\"Parallel Old收集器\"></a>Parallel Old收集器</h3><ul>\n<li>支持多线程并发收集</li>\n<li>使用标记-整理算法</li>\n<li>吞吐量优先收集器有了比较好的组合：Parallel Scavenge收集器+ Parallel Old收集器</li>\n</ul>\n<h3 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h3><ul>\n<li>Concurrent Mark Sweep</li>\n<li>以最短回收停顿时间为目标的收集器</li>\n<li>并发收集，低停顿</li>\n<li>基于标记-清除算法</li>\n<li>互联网网站等Java项目通常较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验</li>\n</ul>\n<p><strong>步骤</strong></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/Rc4defd801698e946aa0b9bc91d8fc4f6\"></p>\n<ul>\n<li>初始标记：标记一下GC Roots能直接关联的对象，速度很快。需要STW</li>\n<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长，但不需要停顿用户线程</li>\n<li>重新标记：需要STW，修改并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，使用增量更新</li>\n<li>并发清除：可以与用户线程同时并发的，清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象。时间较长</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>对处理器资源非常敏感：并发阶段，占用一部分线程导致应用程序变慢，降低总吞吐量</li>\n<li>无法处理浮动垃圾<ul>\n<li>由于垃圾收集阶段用户线程需要持续运行，程序运行自然还会伴随有新的垃圾对象产生，而且这些垃圾对象是出现在标记过程结束之后，CMS无法在当次收集中处理掉他们，只好留待下一次垃圾收集时再清理掉，即浮动垃圾。</li>\n<li>而且用户线程需要持续运行，所以需要预留足够的内存空间给用户线程使用(默认92%)</li>\n<li>如果运行期间预留的内存无法满足程序分配新对象的需要，可能出现Concurrent Mode Failure(并发失败)</li>\n<li>则不得不启动后背方案：冻结用户线程的执行，临时启用Serial Old收集器来进行老年代的垃圾收集</li>\n</ul>\n</li>\n<li>基于标记清除算法，会产生大量的空间碎片：无法找到足够大的连续空间来分配给当前对象，不得不提前Full GC</li>\n</ul>\n<h2 id=\"Garbage-First收集器\"><a href=\"#Garbage-First收集器\" class=\"headerlink\" title=\"Garbage First收集器\"></a>Garbage First收集器</h2><ul>\n<li>面向局部收集，基于Region的内存布局，全功能垃圾收集器</li>\n<li>主要面向服务器应用，服务器模式下默认的垃圾收集器</li>\n<li>建立停顿时间模型，支持指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒</li>\n<li>Mixed GC模式：面向堆的任何部分来组成回收集，衡量哪块内存中存放的垃圾数量最多，回收收益最大</li>\n<li>非常精确地控制停顿</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ul>\n<li>把连续的Java堆划分为多个大小相等的独立区域</li>\n<li>每个Region可以扮演新生代的Eden、Survivor或老年代空间</li>\n<li>Humongous区域，专门存储大对象：大小超过Region容量一半的对象、超级大对象放在连续的Humongous区域、把Humongous区域看作老年代</li>\n<li>将Region作为单位回收的最小单元，每次回收Region的整数倍</li>\n<li>让G1去跟踪各个Region里面垃圾的价值大小（回收所获得的空间大小以及回收所需时间的经验值）</li>\n<li>在后台维护一个优先级列表，优先处理回收价值收益最大的region</li>\n</ul>\n<h3 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h3><ul>\n<li><p>跨Region引用对象</p>\n<ul>\n<li>每个Region都维护自己的记忆集</li>\n<li>记录别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内</li>\n<li>是一个哈希表，Key是别的Region起始地址，Value是卡表索引号集合</li>\n<li>至少要耗费堆的10%-20%额外内存来维持收集器工作</li>\n</ul>\n</li>\n<li><p>并发标记阶段</p>\n<ul>\n<li>对象引用关系改变，不打破原有对象图。使用原始快照（SATB）算法</li>\n<li>新对象创建：设计两个指针，名为TAMS(Top at Mark Start)，把Region中一部分空间划分出来用于并发回收过程中的新对象分配，新分配对象必须在两个指针位置以上，默认这些对象是存活的，如果内存回收速度赶不上内存分配速度，也要STW的Full GC。</li>\n</ul>\n</li>\n<li><p>建立可靠的停顿预测模型</p>\n<ul>\n<li><p>记录每个Region的回收耗时、记忆集中脏卡数量等成本，计算统计信息</p>\n</li>\n<li><p>比普通平均值更容易收到新数据的影响，衰减平均值更准确的代表最近的平均状态</p>\n</li>\n<li><p>Region的统计状态越新越能决定其回收价值</p>\n</li>\n<li><p>通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高收益</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ul>\n<li>初始标记<ul>\n<li>标记GC Roots能直接关联到的对象</li>\n<li>修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用Region上分配新对象</li>\n<li>需要停顿线程，但耗时短，而且是借用Minor GC同步完成的，没有额外停顿</li>\n</ul>\n</li>\n<li>并发标记<ul>\n<li>堆中对象的可达性分析，递归扫描整个堆中对象图</li>\n<li>耗时长，能与用户线程并发执行</li>\n<li>处理在SATB记录下的在并发时有引用变动的对象</li>\n</ul>\n</li>\n<li>最终标记<ul>\n<li>对用户线程做另一个短暂暂停，处理并发阶段结束后遗留下来的最后那少量的SATB记录</li>\n</ul>\n</li>\n<li>筛选回收<ul>\n<li>更新Region的统计数据</li>\n<li>对Region的回收价值和成本排序</li>\n<li>根据用户所期望的停顿时间制定回收计划</li>\n<li>把决定回收的Region的存活对象复制到空Region中，清理旧Region的全部空间</li>\n<li>必须STW，由多条垃圾收集器线程并发完成</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li><p>在延迟可控的情况下获得尽可能高的吞吐量</p>\n</li>\n<li><p>取得关注吞吐量和关注延迟之间的最佳平衡</p>\n</li>\n<li><p>如果停顿时间过短，会导致每次筛选出来的回收集只占堆内存很小一部分，最终占满堆引发Full GC降低性能，停顿时间设置在100-300ms之间比较合理</p>\n</li>\n<li><p>整体是基于标记-整理的</p>\n</li>\n<li><p>局部是基于标记-复制的</p>\n</li>\n<li><p>不会产生内存空间碎片，收集后能提供规整的可用内存</p>\n</li>\n<li><p>使用写后屏障进行卡表维护操作</p>\n</li>\n<li><p>使用写前屏障来跟踪并发时的指针变化，实现SATB算法</p>\n</li>\n<li><p>小内存上CMS大概率优于G1（6-8GB为平衡点）</p>\n</li>\n</ul>\n<h1 id=\"垃圾收集实战\"><a href=\"#垃圾收集实战\" class=\"headerlink\" title=\"垃圾收集实战\"></a>垃圾收集实战</h1><ul>\n<li>实验环境：HotSpot、客户端模式、Serial+Serial Old</li>\n<li>对象的内存分配：大部分堆上分配，极小部分经过即时编译后拆散为标量类型并间接栈上分配</li>\n<li>新生对象通常分配新生代，少数情况（对象大小超过阈值）直接分配老年代</li>\n</ul>\n<h2 id=\"对象优先在Eden分配\"><a href=\"#对象优先在Eden分配\" class=\"headerlink\" title=\"对象优先在Eden分配\"></a>对象优先在Eden分配</h2><ul>\n<li>大多数情况下，对象在Eden区分配，如果Eden区没有足够空间分配，将发起Minor GC</li>\n<li>MinGC中，如果Survivor放不下Eden存活的，则通过对象担保机制，把存活的放入老年代</li>\n<li>-Xms20M -Xmx20M：堆大小20M，不可扩展</li>\n<li>-Xmn10M：10MB分配给新生代</li>\n<li>-XX:SurvivorRatio=8：Eden：Survivor = 8：1，新生代总可用区间9216KB(Eden+一个Survivor)</li>\n<li>-XX:+PrintGCDetails</li>\n</ul>\n<pre><code>VM参数:\n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:SurvivorRatio=8 \n-XX:+PrintGCDetails</code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> _1MB <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> allocation1， allocation2， allocation3， allocation4<span class=\"token punctuation\">;</span>\n        allocation1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> _1MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        allocation2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> _1MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        allocation3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> _1MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        allocation4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span> <span class=\"token operator\">*</span> _1MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//出现Minor GC</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token function\">GC</span> <span class=\"token punctuation\">(</span>Allocation Failure<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span>DefNew<span class=\"token operator\">:</span> 8159K<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">626K</span><span class=\"token punctuation\">(</span>9216K<span class=\"token punctuation\">)</span>， <span class=\"token number\">0.0041610</span> secs<span class=\"token punctuation\">]</span> 8159K<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">6770K</span><span class=\"token punctuation\">(</span>19456K<span class=\"token punctuation\">)</span>， <span class=\"token number\">0.0042168</span> secs<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>Times<span class=\"token operator\">:</span> user<span class=\"token operator\">=</span><span class=\"token number\">0.00</span> sys<span class=\"token operator\">=</span><span class=\"token number\">0.00</span>， real<span class=\"token operator\">=</span><span class=\"token number\">0.00</span> secs<span class=\"token punctuation\">]</span> \nHeap\n def <span class=\"token keyword\">new</span> <span class=\"token class-name\">generation</span>   total 9216K， used 4888K <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000fec00000</span>， <span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x00000000ff600000</span><span class=\"token punctuation\">)</span>\n  eden space 8192K，  <span class=\"token number\">52</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000fec00000</span>， <span class=\"token number\">0x00000000ff029840</span>， <span class=\"token number\">0x00000000ff400000</span><span class=\"token punctuation\">)</span>\n  from space 1024K，  <span class=\"token number\">61</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff500000</span>， <span class=\"token number\">0x00000000ff59c960</span>， <span class=\"token number\">0x00000000ff600000</span><span class=\"token punctuation\">)</span>\n  to   space 1024K，   <span class=\"token number\">0</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff400000</span>， <span class=\"token number\">0x00000000ff400000</span>， <span class=\"token number\">0x00000000ff500000</span><span class=\"token punctuation\">)</span>\n tenured generation   total 10240K， used 6144K <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x0000000100000000</span>， <span class=\"token number\">0x0000000100000000</span><span class=\"token punctuation\">)</span>\n   the space 10240K，  <span class=\"token number\">60</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x00000000ffc00030</span>， <span class=\"token number\">0x00000000ffc00200</span>， <span class=\"token number\">0x0000000100000000</span><span class=\"token punctuation\">)</span>\n Metaspace       used 3253K， capacity 4496K， committed 4864K， reserved 1056768K\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">space</span>    used 353K， capacity 388K， committed 512K， reserved 1048576K\n\nProcess finished with exit code <span class=\"token number\">0</span>\n</code></pre>\n<h2 id=\"大对象直接进入老年代\"><a href=\"#大对象直接进入老年代\" class=\"headerlink\" title=\"大对象直接进入老年代\"></a>大对象直接进入老年代</h2><ul>\n<li>大对象就是需要连续内存空间的Java对象</li>\n<li>很长的字符串或者元素数量很庞大的数组</li>\n<li>在程序中避免出现一群朝生夕灭的短命大对象</li>\n<li>他容易导致内存明明还有不少空间就提前触发了垃圾收集，以获取足够的连续空间才能安置好他们</li>\n<li>当复制对象时，大对象意味着高额的内存复制开销</li>\n<li>-XX:PretenureSizeThreshold=3145728</li>\n<li>可设置参数，指定大于设定值的对象直接在老年代分配，避免在Eden区以及两个Survivor区来回复制，产生大量的内存复制操作</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span>PretenureSizeThreshold<span class=\"token operator\">=</span><span class=\"token number\">3145728</span> \n<span class=\"token operator\">-</span>verbose<span class=\"token operator\">:</span>gc <span class=\"token operator\">-</span>Xms20M <span class=\"token operator\">-</span>Xmx20M <span class=\"token operator\">-</span>Xmn10M <span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span><span class=\"token operator\">+</span>UseSerialGC \n<span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span>SurvivorRatio<span class=\"token operator\">=</span><span class=\"token number\">8</span> <span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span><span class=\"token operator\">+</span>PrintGCDetails</code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> _1MB <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> allocation1<span class=\"token punctuation\">;</span>\n        allocation1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span> <span class=\"token operator\">*</span> _1MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//直接分配在老年代</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">Heap\n def <span class=\"token keyword\">new</span> <span class=\"token class-name\">generation</span>   total 9216K， used 2015K <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000fec00000</span>， <span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x00000000ff600000</span><span class=\"token punctuation\">)</span>\n  eden space 8192K，  <span class=\"token number\">24</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000fec00000</span>， <span class=\"token number\">0x00000000fedf7e90</span>， <span class=\"token number\">0x00000000ff400000</span><span class=\"token punctuation\">)</span>\n  from space 1024K，   <span class=\"token number\">0</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff400000</span>， <span class=\"token number\">0x00000000ff400000</span>， <span class=\"token number\">0x00000000ff500000</span><span class=\"token punctuation\">)</span>\n  to   space 1024K，   <span class=\"token number\">0</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff500000</span>， <span class=\"token number\">0x00000000ff500000</span>， <span class=\"token number\">0x00000000ff600000</span><span class=\"token punctuation\">)</span>\n tenured generation   total 10240K， used 4096K <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x0000000100000000</span>， <span class=\"token number\">0x0000000100000000</span><span class=\"token punctuation\">)</span>\n   the space 10240K，  <span class=\"token number\">40</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x00000000ffa00010</span>， <span class=\"token number\">0x00000000ffa00200</span>， <span class=\"token number\">0x0000000100000000</span><span class=\"token punctuation\">)</span>\n Metaspace       used 3210K， capacity 4496K， committed 4864K， reserved 1056768K\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">space</span>    used 352K， capacity 388K， committed 512K， reserved 1048576K</code></pre>\n<h2 id=\"长期存活的对象将进入老年代\"><a href=\"#长期存活的对象将进入老年代\" class=\"headerlink\" title=\"长期存活的对象将进入老年代\"></a>长期存活的对象将进入老年代</h2><ul>\n<li>每个对象对象头定义了一个对象年龄计数器</li>\n<li>对象通常在Eden区诞生，如果经过第一次Minor GC仍然存活，并且能被Survivor容纳，则被移动到Survivor空间中，并且年龄设置为1</li>\n<li>对象在Survivor区每熬过一次Minor GC，年龄+1</li>\n<li>增长到15时，就会被晋升到老年代，晋升阈值通过-XX:MaxTenuringThreshold设置</li>\n<li>当-XX:MaxTenuringThreshold设置为1时，allocation1在第二次GC发生时进入老年代</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span><span class=\"token operator\">+</span>PrintTenuringDistribution <span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span>MaxTenuringThreshold<span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token operator\">-</span>verbose<span class=\"token operator\">:</span>gc <span class=\"token operator\">-</span>Xms20M <span class=\"token operator\">-</span>Xmx20M <span class=\"token operator\">-</span>Xmn10M <span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span><span class=\"token operator\">+</span>UseSerialGC \n<span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span>SurvivorRatio<span class=\"token operator\">=</span><span class=\"token number\">8</span> <span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span><span class=\"token operator\">+</span>PrintGCDetails</code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> _1MB <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> allocation1， allocation2， allocation3<span class=\"token punctuation\">;</span>\n        allocation1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span>_1MB <span class=\"token operator\">/</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//什么时候进入老年代决定于-XX:MaxTenuringThreshold设置</span>\n        allocation2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span> <span class=\"token operator\">*</span> _1MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        allocation3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span> <span class=\"token operator\">*</span> _1MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        allocation3 <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        allocation3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span> <span class=\"token operator\">*</span> _1MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token function\">GC</span> <span class=\"token punctuation\">(</span>Allocation Failure<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span>DefNew\nDesired survivor size <span class=\"token number\">524288</span> bytes， <span class=\"token keyword\">new</span> <span class=\"token class-name\">threshold</span> <span class=\"token function\">1</span> <span class=\"token punctuation\">(</span>max <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">-</span> age   <span class=\"token number\">1</span><span class=\"token operator\">:</span>     <span class=\"token number\">886440</span> bytes，     <span class=\"token number\">886440</span> total\n<span class=\"token operator\">:</span> 6367K<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">865K</span><span class=\"token punctuation\">(</span>9216K<span class=\"token punctuation\">)</span>， <span class=\"token number\">0.0055780</span> secs<span class=\"token punctuation\">]</span> 6367K<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">4961K</span><span class=\"token punctuation\">(</span>19456K<span class=\"token punctuation\">)</span>， <span class=\"token number\">0.0056123</span> secs<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>Times<span class=\"token operator\">:</span> user<span class=\"token operator\">=</span><span class=\"token number\">0.00</span> sys<span class=\"token operator\">=</span><span class=\"token number\">0.00</span>， real<span class=\"token operator\">=</span><span class=\"token number\">0.01</span> secs<span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">[</span><span class=\"token function\">GC</span> <span class=\"token punctuation\">(</span>Allocation Failure<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span>DefNew\nDesired survivor size <span class=\"token number\">524288</span> bytes， <span class=\"token keyword\">new</span> <span class=\"token class-name\">threshold</span> <span class=\"token function\">1</span> <span class=\"token punctuation\">(</span>max <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">-</span> age   <span class=\"token number\">1</span><span class=\"token operator\">:</span>        <span class=\"token number\">680</span> bytes，        <span class=\"token number\">680</span> total\n<span class=\"token operator\">:</span> 5045K<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">0K</span><span class=\"token punctuation\">(</span>9216K<span class=\"token punctuation\">)</span>， <span class=\"token number\">0.0012428</span> secs<span class=\"token punctuation\">]</span> 9141K<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">4958K</span><span class=\"token punctuation\">(</span>19456K<span class=\"token punctuation\">)</span>， <span class=\"token number\">0.0012696</span> secs<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>Times<span class=\"token operator\">:</span> user<span class=\"token operator\">=</span><span class=\"token number\">0.00</span> sys<span class=\"token operator\">=</span><span class=\"token number\">0.00</span>， real<span class=\"token operator\">=</span><span class=\"token number\">0.00</span> secs<span class=\"token punctuation\">]</span> \nHeap\n def <span class=\"token keyword\">new</span> <span class=\"token class-name\">generation</span>   total 9216K， used 4235K <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000fec00000</span>， <span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x00000000ff600000</span><span class=\"token punctuation\">)</span>\n  eden space 8192K，  <span class=\"token number\">51</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000fec00000</span>， <span class=\"token number\">0x00000000ff022a70</span>， <span class=\"token number\">0x00000000ff400000</span><span class=\"token punctuation\">)</span>\n  from space 1024K，   <span class=\"token number\">0</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff400000</span>， <span class=\"token number\">0x00000000ff4002a8</span>， <span class=\"token number\">0x00000000ff500000</span><span class=\"token punctuation\">)</span>\n  to   space 1024K，   <span class=\"token number\">0</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff500000</span>， <span class=\"token number\">0x00000000ff500000</span>， <span class=\"token number\">0x00000000ff600000</span><span class=\"token punctuation\">)</span>\n tenured generation   total 10240K， used 4958K <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x0000000100000000</span>， <span class=\"token number\">0x0000000100000000</span><span class=\"token punctuation\">)</span>\n   the space 10240K，  <span class=\"token number\">48</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x00000000ffad7800</span>， <span class=\"token number\">0x00000000ffad7800</span>， <span class=\"token number\">0x0000000100000000</span><span class=\"token punctuation\">)</span>\n Metaspace       used 3286K， capacity 4496K， committed 4864K， reserved 1056768K\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">space</span>    used 357K， capacity 388K， committed 512K， reserved 1048576K</code></pre>\n<h2 id=\"动态对象年龄判断\"><a href=\"#动态对象年龄判断\" class=\"headerlink\" title=\"动态对象年龄判断\"></a>动态对象年龄判断</h2><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survovor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span><span class=\"token operator\">+</span>PrintTenuringDistribution <span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span>MaxTenuringThreshold<span class=\"token operator\">=</span><span class=\"token number\">1</span> \n<span class=\"token operator\">-</span>verbose<span class=\"token operator\">:</span>gc <span class=\"token operator\">-</span>Xms20M <span class=\"token operator\">-</span>Xmx20M <span class=\"token operator\">-</span>Xmn10M <span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span><span class=\"token operator\">+</span>UseSerialGC \n<span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span>SurvivorRatio<span class=\"token operator\">=</span><span class=\"token number\">8</span> <span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span><span class=\"token operator\">+</span>PrintGCDetails</code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> _1MB <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> allocation1， allocation2， allocation3， allocation4<span class=\"token punctuation\">;</span>\n        allocation1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span>_1MB <span class=\"token operator\">/</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//allocation1 + allocation2 大于 survivor空间的一半了</span>\n        allocation2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span>_1MB <span class=\"token operator\">/</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        allocation3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span> <span class=\"token operator\">*</span> _1MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        allocation4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span> <span class=\"token operator\">*</span> _1MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        allocation4 <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        allocation4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span> <span class=\"token operator\">*</span> _1MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token function\">GC</span> <span class=\"token punctuation\">(</span>Allocation Failure<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span>DefNew\nDesired survivor size <span class=\"token number\">524288</span> bytes， <span class=\"token keyword\">new</span> <span class=\"token class-name\">threshold</span> <span class=\"token function\">1</span> <span class=\"token punctuation\">(</span>max <span class=\"token number\">15</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">-</span> age   <span class=\"token number\">1</span><span class=\"token operator\">:</span>    <span class=\"token number\">1048576</span> bytes，    <span class=\"token number\">1048576</span> total\n<span class=\"token operator\">:</span> 6623K<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">1024K</span><span class=\"token punctuation\">(</span>9216K<span class=\"token punctuation\">)</span>， <span class=\"token number\">0.0039616</span> secs<span class=\"token punctuation\">]</span> 6623K<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">5234K</span><span class=\"token punctuation\">(</span>19456K<span class=\"token punctuation\">)</span>， <span class=\"token number\">0.0040033</span> secs<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>Times<span class=\"token operator\">:</span> user<span class=\"token operator\">=</span><span class=\"token number\">0.00</span> sys<span class=\"token operator\">=</span><span class=\"token number\">0.00</span>， real<span class=\"token operator\">=</span><span class=\"token number\">0.00</span> secs<span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">[</span><span class=\"token function\">GC</span> <span class=\"token punctuation\">(</span>Allocation Failure<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span>DefNew\nDesired survivor size <span class=\"token number\">524288</span> bytes， <span class=\"token keyword\">new</span> <span class=\"token class-name\">threshold</span> <span class=\"token function\">15</span> <span class=\"token punctuation\">(</span>max <span class=\"token number\">15</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">-</span> age   <span class=\"token number\">1</span><span class=\"token operator\">:</span>        <span class=\"token number\">176</span> bytes，        <span class=\"token number\">176</span> total\n<span class=\"token operator\">:</span> 5204K<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">0K</span><span class=\"token punctuation\">(</span>9216K<span class=\"token punctuation\">)</span>， <span class=\"token number\">0.0011999</span> secs<span class=\"token punctuation\">]</span> 9414K<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">5234K</span><span class=\"token punctuation\">(</span>19456K<span class=\"token punctuation\">)</span>， <span class=\"token number\">0.0012304</span> secs<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>Times<span class=\"token operator\">:</span> user<span class=\"token operator\">=</span><span class=\"token number\">0.00</span> sys<span class=\"token operator\">=</span><span class=\"token number\">0.00</span>， real<span class=\"token operator\">=</span><span class=\"token number\">0.00</span> secs<span class=\"token punctuation\">]</span> \nHeap\n def <span class=\"token keyword\">new</span> <span class=\"token class-name\">generation</span>   total 9216K， used 4234K <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000fec00000</span>， <span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x00000000ff600000</span><span class=\"token punctuation\">)</span>\n  eden space 8192K，  <span class=\"token number\">51</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000fec00000</span>， <span class=\"token number\">0x00000000ff0227f0</span>， <span class=\"token number\">0x00000000ff400000</span><span class=\"token punctuation\">)</span>\n  from space 1024K，   <span class=\"token number\">0</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff400000</span>， <span class=\"token number\">0x00000000ff4000b0</span>， <span class=\"token number\">0x00000000ff500000</span><span class=\"token punctuation\">)</span>\n  to   space 1024K，   <span class=\"token number\">0</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff500000</span>， <span class=\"token number\">0x00000000ff500000</span>， <span class=\"token number\">0x00000000ff600000</span><span class=\"token punctuation\">)</span>\n tenured generation   total 10240K， used 5234K <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x0000000100000000</span>， <span class=\"token number\">0x0000000100000000</span><span class=\"token punctuation\">)</span>\n   the space 10240K，  <span class=\"token number\">51</span><span class=\"token operator\">%</span> used <span class=\"token punctuation\">[</span><span class=\"token number\">0x00000000ff600000</span>， <span class=\"token number\">0x00000000ffb1c9a0</span>， <span class=\"token number\">0x00000000ffb1ca00</span>， <span class=\"token number\">0x0000000100000000</span><span class=\"token punctuation\">)</span>\n Metaspace       used 3247K， capacity 4496K， committed 4864K， reserved 1056768K\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">space</span>    used 353K， capacity 388K， committed 512K， reserved 1048576K</code></pre>\n<h2 id=\"空间分配担保\"><a href=\"#空间分配担保\" class=\"headerlink\" title=\"空间分配担保\"></a>空间分配担保</h2><ul>\n<li>在Minor GC前，检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果成立，则这次Minor GC安全。</li>\n<li>否则要看是否允许担保失败。如果允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的平均大小，如果大于，将尝试进行一次Minor GC。如果小于，或者不允许担保，则Full GC。</li>\n<li>新生代中，当出现大量对象在Minor GC后仍然存活的情况，就把Survivor无法容纳的对象直接送入老年代，担保前提是老年代本身有容纳这些对象的剩余空间。</li>\n<li>但一共有多少对象会在这次回收中存活下来在实际回收完成之前是无法明确知道的，只能取之前每一次回收晋升老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间</li>\n<li>担保失败则又得Full GC，绕的圈子最大，但一般打开，避免Full GC过于频繁</li>\n<li>在JDK7及之后。不能设置参数影响空间分配担保策略。只要老年代最大可用连续空间大于新生代的所有对象空间，或者大于历次晋升到老年代的平均大小，就进行Minor GC，负责Full GC（相当于一定会冒险）</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"判定对象消亡\"><a href=\"#判定对象消亡\" class=\"headerlink\" title=\"判定对象消亡\"></a>判定对象消亡</h1><h2 id=\"引用计数算法\"><a href=\"#引用计数算法\" class=\"headerlink\" title=\"引用计数算法\"></a>引用计数算法</h2><p>无法解决循环引用的问题，即实际上这两个对象已经不可能被访问了，但因为它们互相引用着对方，导致它们的引用计数都不为零，引用计数算法就无法回收它们</p>\n<h2 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h2><ul>\n<li>通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链</li>\n<li>如果从GC Roots到某个对象不可达，则将把他们判定为可回收对象</li>\n</ul>\n<h3 id=\"GC-Roots\"><a href=\"#GC-Roots\" class=\"headerlink\" title=\"GC Roots\"></a>GC Roots</h3><ul>\n<li>在虚拟机栈(栈帧中的局部变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量</li>\n<li>在方法区中类静态属性引用的对象，Java类的引用类型静态变量</li>\n<li>在方法区中常量引用的对象，例如字符串常量池(String Table)里的引用</li>\n<li>在本地方法栈中JNI(即Native方法)引用的对象</li>\n<li>虚拟机内部的引用，如基本数据对应的Class对象、常驻的异常对象如NullPointException、OutOfMemoryError、系统类加载器</li>\n<li>被同步锁（synchronized）持有的对象</li>\n<li>反映虚拟机内部情况的本地代码缓存等</li>\n<li>分代收集和局部回收（Partial GC）。如果只针对Java堆中某块区域发起垃圾收集时（如只针对新生代的垃圾收集），这个区域里的对象有可能被位于堆中其他区域的对象所引用。需要将关联区域的对象也一并加入到GC Roots集合中</li>\n</ul>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><ul>\n<li>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，那么该reference数据是代表某个对象的引用</li>\n<li>类似Object object = new Object();</li>\n<li>只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象</li>\n</ul>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><ul>\n<li>只被软引用关联着的对象，在系统将要发生内存溢出异常之前，会将这些对象纳入回收范围进行二次回收</li>\n<li>如果这次回收还没有足够的内存，才会抛出内存溢出异常</li>\n<li>SoftReference</li>\n<li>缓存功能，一类对象，当内存空间足够时，能保存在内存中，如果内存空间在进行垃圾收集时仍然非常紧张，则可以抛弃这些对象</li>\n</ul>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><ul>\n<li>强度被软引用更弱</li>\n<li>只能生存到下一次垃圾收集发生为止</li>\n<li>无论内存是否充足，都会回收掉只被弱引用关联的对象</li>\n</ul>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><ul>\n<li>又称幽灵引用或幻影引用</li>\n<li>是否有虚引用完全不会对其生命周期构成影响，也无法通过虚引用获取一个对象实例</li>\n<li>唯一目的是为了能在这个对象被回收时收到一个系统通知</li>\n</ul>\n<h2 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h2><ul>\n<li>主要回收废弃的常量和不再使用的类型</li>\n<li>回收常量池，例如已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量，如果此时进行内存回收，而且确实有必要，则该常量将被系统清理出常量池</li>\n<li>回收类。在大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义类加载器的场景，通常需要JVM具备类型卸载的能力<ul>\n<li>该类的所有的实例都已经被回收，Java堆中不存在该类及其任何派生子类的实例</li>\n<li>加载该类的类加载器已经被回收，除非是精心设计的可替换类加载器的场景，否则很难达成</li>\n<li>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问这个类的方法</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h1><h2 id=\"分代收集理论\"><a href=\"#分代收集理论\" class=\"headerlink\" title=\"分代收集理论\"></a>分代收集理论</h2><p><strong>分代收集</strong></p>\n<ul>\n<li>弱分代假说：绝大多数对象都是朝生夕灭</li>\n<li>强分代假说：熬过越多次垃圾收集过程的对象就越难消亡</li>\n<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数</li>\n</ul>\n<p><strong>设计原则</strong></p>\n<ul>\n<li>将Java堆划分出不同的区域，根据回收对象年龄（即熬过垃圾收集的次数）分配到不同的区域中存储</li>\n<li>划分不同区域后，垃圾收集器可以每次只回收其中一部分区域，根据不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法</li>\n</ul>\n<p><strong>新生代</strong></p>\n<ul>\n<li>每次垃圾收集时都有大批对象死去，而每次回收后存活的少量对象，将会逐步晋身到老年代中存放</li>\n<li>如果只进行Minor GC，但新生代对象可能被老年代引用，为了找出存活对象，不得不再固定GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性</li>\n<li>依据假说，不应为了少量的跨带引用去扫描整个老年代，只需要在新生代上建立一个全局的数据结构（记忆集），这个结构把老年代分成若干小块，标识出老年代哪一块内存会存在跨带引用</li>\n<li>此后Minor GC，只有包含了跨带引用的小块内存里的对象才会被加入GC Roots中进行扫描</li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><ul>\n<li>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象</li>\n<li>执行效率不稳定，标记和清除两个过程的执行效率都随对象数量增长而降低</li>\n<li>会产生大量不连续的内存碎片，导致只会程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作</li>\n</ul>\n<h3 id=\"标记-复制算法-针对新生代\"><a href=\"#标记-复制算法-针对新生代\" class=\"headerlink\" title=\"标记-复制算法(针对新生代)\"></a>标记-复制算法(针对新生代)</h3><ul>\n<li>半区复制，将可用内存按容量划分成大小相等的两块，每次只使用其中一块，如果这一块内存用完了，就将存活的对象复制到另外一块上，再把已使用过的内存空间清理掉</li>\n<li>对于多数对象是可回收的情况，算法需要复制的只是占少数的存活对象，无碎片空间问题</li>\n<li>代价是可用内存缩小为原来一半</li>\n<li>Appel式回收<ul>\n<li>把新生代分为Eden，和Survivor0，Survivor1区，大小为8:1:1</li>\n<li>每次分配内存只使用Eden和Survivor0区</li>\n<li>将Eden和Survivor0中存活对象一次性复制到Survivor1区</li>\n<li>当Survivor空间不足以容纳一次Minor GC之后存活的对象，就通过分配担保机制直接进入老年代</li>\n</ul>\n</li>\n</ul>\n<p>现在的商业虚拟机都采用复制收集算法来回收新生代，有研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，并不能保证每次回收都只有10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行<strong>分配担保</strong>（Handle Promotion）。即如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p>\n<h3 id=\"标记-整理算法-针对老年代\"><a href=\"#标记-整理算法-针对老年代\" class=\"headerlink\" title=\"标记-整理算法(针对老年代)\"></a>标记-整理算法(针对老年代)</h3><ul>\n<li>先标记，然后让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存</li>\n<li>移动存活对象并更新所有引用这些对象的地方必须暂停用户应用程序才能进行(Stop the World)</li>\n<li>但如果不管空间碎片化问题，则直接影响应用程序的吞吐量</li>\n<li>关注吞吐量的Parallel Scavenge基于标记-整理</li>\n<li>关注延迟的CMS基于标记-清除：在空间碎片过多，影响到对象分配时，再采用标记整理算法收集一次</li>\n</ul>\n<h1 id=\"HotSpot算法细节\"><a href=\"#HotSpot算法细节\" class=\"headerlink\" title=\"HotSpot算法细节\"></a>HotSpot算法细节</h1><h2 id=\"根节点枚举\"><a href=\"#根节点枚举\" class=\"headerlink\" title=\"根节点枚举\"></a>根节点枚举</h2><ul>\n<li>固定可作为GC Roots的节点主要是全局性的引用(例如常量或类静态属性)与执行上下文(例如堆栈中的本地变量表)</li>\n<li>所有收集器在根节点枚举这一步骤都是必须暂停用户线程的</li>\n<li>必须在一个能保障一致性的快照中才得以进行，整个枚举期间，执行子系统看起来就像是冻结在某个时间点上</li>\n<li>用户线程停顿之后，不需要一个不漏地检查完所有执行上下文和全局的引用位置。可以使用一组称为OopMap的数据结构直接得到哪些地方存在着对象引用</li>\n</ul>\n<h2 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h2><ul>\n<li>通过OopMap，HotSpot可以快速完成GC Roots的枚举，但不可能每条指令都生成OopMap，只是在特定的地方记录了这些位置，即安全点</li>\n<li>用户程序执行时并非在代码指令流的任意位置都能停顿下来开始垃圾收集，而是强制要求必须执行到达安全点才能够暂停</li>\n<li>安全点的选择一般是以能否让程序长时间执行的特征为标准选定的，一般是指令序列的复用，例如方法调用、循环跳转、异常跳转等才会产生安全点</li>\n<li>还要考虑如何让垃圾收集发生时让所有线程都跑到最近的安全点，并停顿</li>\n<li>抢先式中断<ul>\n<li>在垃圾收集发生时，系统首先把所有线程中断，如果发现用户线程中断地方不再安全点上，就恢复线程继续执行，让它一会再中断，直到跑到安全点。</li>\n<li>几乎没有虚拟机使用</li>\n</ul>\n</li>\n<li>主动式中断<ul>\n<li>设置一个标志位，各个线程执行过程中不停地主动轮询这个标志，一旦发现标志为真就自己在最近的安全点上主动中断挂起</li>\n<li>使用内存保护陷阱的方式，把轮询操作精简到只有一条汇编指令</li>\n<li>仅通过一条汇编指令就完成安全点轮询和触发线程中断</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h2><ul>\n<li>如果用户线程处于Sleep状态或Blocked状态，即没有分配处理器时间。此时线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己。</li>\n<li>安全区域是指能够确保某一段程序代码中，引用关系不会发生改变，因此，在这个区域从任意地方开始垃圾收集都是安全的</li>\n<li>当用户线程执行到安全区域里面的代码，首先标识自己已经进入了安全区域，这段时间如果发生垃圾收集JVM不会管这些已经声明在安全区域里面的代码。当要离开安全区域时，它要检查JVM是否完成了根节点枚举，如果完成则继续执行，如果没完成，则一直等待直到收到可以离开安全区域的信号为止</li>\n</ul>\n<h2 id=\"记忆集和卡表\"><a href=\"#记忆集和卡表\" class=\"headerlink\" title=\"记忆集和卡表\"></a>记忆集和卡表</h2><ul>\n<li>为解决对象跨带引用的问题，使用记忆集来避免把整个老年代加入GC Roots的扫描范围</li>\n<li>记忆集是一种用来记录从非收集区域指向收集区域的指针集合的数据结构，最简单是用非收集区域中所有含跨带引用的对象数组来实现，但是空间占用太高</li>\n<li>收集者只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可，可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本</li>\n</ul>\n<h3 id=\"卡表（card-table\"><a href=\"#卡表（card-table\" class=\"headerlink\" title=\"卡表（card table)\"></a>卡表（card table)</h3><ul>\n<li>每个记录精确到一块内存区域，该区域内有对象含有跨带引用</li>\n<li>卡表是记忆集的一种具体实现</li>\n<li>使用字节数组，因为速度上现在计算机硬件是按字节编址</li>\n<li>CARD_TABLE[this.address &gt;&gt; 9] = 0</li>\n<li>每一个元素都对应着其标识的内存区域中一块特定大小的内存块</li>\n<li>一个卡页（512字节）的内存中通常不止包含一个对象，只要里面有一个存在跨带指针，就置为1，元素变脏。</li>\n<li>在垃圾收集时，只要筛选出变脏的元素，就能知道哪有跨带指针，就加入GC Roots</li>\n</ul>\n<h2 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h2><ul>\n<li>变脏时间点应该发生在引用类型字段赋值的那一刻，如何在此时更新维护卡表</li>\n<li>必须找到一个在机器码层面的手段，把维护卡表的动作放在每一个赋值操作之中</li>\n<li>使用写屏障技术维护卡表状态，可以看作是虚拟机层面对“引用类型赋值”这个动作的AOP切面，在引用对象赋值时产生一个环绕通知，供程序执行额外的操作。应用了写后屏障</li>\n<li>伪共享问题<ul>\n<li>缓存系统以缓存行为单位存储，如果多个线程修改互相独立的变量，而这些变量恰好在共享同一个缓存行，就彼此影响</li>\n<li>可以先检查卡表标记，只有当卡表元素没有被标记时才标记为变脏</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"并发的可达性分析\"><a href=\"#并发的可达性分析\" class=\"headerlink\" title=\"并发的可达性分析\"></a>并发的可达性分析</h2><ul>\n<li><p>从GC Roots再继续往下遍历对象图的时间与堆容量成正比</p>\n</li>\n<li><p>三色标记法，如果收集器再对象图上标记颜色，同时用户线程在修改引用关系（对象图的结构）</p>\n</li>\n<li><p>两种可能：</p>\n<ul>\n<li>把原本消亡的对象误标记为存活，可以接受。只是产生了逃过本次收集的浮动垃圾</li>\n<li>把原本存活的对象误标记为消亡，非常致命</li>\n</ul>\n</li>\n<li><p>对象消亡两个条件</p>\n<ul>\n<li>新增了黑色到白色对象的新引用。</li>\n<li>删除了灰色到该白色对象的所有引用</li>\n</ul>\n</li>\n<li><p>两种解决，破坏两个条件之一即可。都是通过写屏障实现</p>\n<ul>\n<li>增量更新。理解为当黑色对象一旦插入了指向白色对象的引用后，它就变回灰色对象。</li>\n<li>原始快照。无论引用对象删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"经典垃圾收集器\"><a href=\"#经典垃圾收集器\" class=\"headerlink\" title=\"经典垃圾收集器\"></a>经典垃圾收集器</h1><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/abcd.png\" alt=\"img\"></p>\n<h2 id=\"Young-generation\"><a href=\"#Young-generation\" class=\"headerlink\" title=\"Young generation\"></a>Young generation</h2><h3 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h3><ul>\n<li>单线程工作的收集器</li>\n<li>在进行垃圾收集时，必须先暂停其他所有线程，直到它收集结束</li>\n<li>客户端模式下默认的新生代收集器，简单而高效</li>\n<li>对于内存资源受限的环境下，是所有收集器里额外内存消耗最小的</li>\n<li>对于单核处理器或核心较少的环境收集效率最高</li>\n</ul>\n<h3 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h3><ul>\n<li>是Serial收集器的多线程并发版本</li>\n<li>除了Serial收集器，只有它能和CMS收集器配合</li>\n<li>在单线程环境下不比Serial收集器好</li>\n<li>也是需要STW，只是多线程一起并发收集罢了</li>\n</ul>\n<h3 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h3><ul>\n<li>同样基于标记-复制算法，同样并行收集的多线程收集器</li>\n<li>称作吞吐量优先收集器</li>\n<li>可以达到一个可控制的吞吐量，即处理器用于运行用户代码的时间/处理器总消耗时间</li>\n<li>垃圾收集的自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或最大吞吐量</li>\n</ul>\n<h2 id=\"Tenured-generation\"><a href=\"#Tenured-generation\" class=\"headerlink\" title=\"Tenured generation\"></a>Tenured generation</h2><h3 id=\"Serial-Old收集器\"><a href=\"#Serial-Old收集器\" class=\"headerlink\" title=\"Serial Old收集器\"></a>Serial Old收集器</h3><ul>\n<li>单线程收集器，使用标记-整理算法</li>\n<li>供客户端模式使用</li>\n<li>可作为CMS收集器发生失败时的后备预案</li>\n<li>可以配合Parallel Scavenge收集器</li>\n</ul>\n<h3 id=\"Parallel-Old收集器\"><a href=\"#Parallel-Old收集器\" class=\"headerlink\" title=\"Parallel Old收集器\"></a>Parallel Old收集器</h3><ul>\n<li>支持多线程并发收集</li>\n<li>使用标记-整理算法</li>\n<li>吞吐量优先收集器有了比较好的组合：Parallel Scavenge收集器+ Parallel Old收集器</li>\n</ul>\n<h3 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h3><ul>\n<li>Concurrent Mark Sweep</li>\n<li>以最短回收停顿时间为目标的收集器</li>\n<li>并发收集，低停顿</li>\n<li>基于标记-清除算法</li>\n<li>互联网网站等Java项目通常较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验</li>\n</ul>\n<p><strong>步骤</strong></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/Rc4defd801698e946aa0b9bc91d8fc4f6\"></p>\n<ul>\n<li>初始标记：标记一下GC Roots能直接关联的对象，速度很快。需要STW</li>\n<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长，但不需要停顿用户线程</li>\n<li>重新标记：需要STW，修改并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，使用增量更新</li>\n<li>并发清除：可以与用户线程同时并发的，清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象。时间较长</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>对处理器资源非常敏感：并发阶段，占用一部分线程导致应用程序变慢，降低总吞吐量</li>\n<li>无法处理浮动垃圾<ul>\n<li>由于垃圾收集阶段用户线程需要持续运行，程序运行自然还会伴随有新的垃圾对象产生，而且这些垃圾对象是出现在标记过程结束之后，CMS无法在当次收集中处理掉他们，只好留待下一次垃圾收集时再清理掉，即浮动垃圾。</li>\n<li>而且用户线程需要持续运行，所以需要预留足够的内存空间给用户线程使用(默认92%)</li>\n<li>如果运行期间预留的内存无法满足程序分配新对象的需要，可能出现Concurrent Mode Failure(并发失败)</li>\n<li>则不得不启动后背方案：冻结用户线程的执行，临时启用Serial Old收集器来进行老年代的垃圾收集</li>\n</ul>\n</li>\n<li>基于标记清除算法，会产生大量的空间碎片：无法找到足够大的连续空间来分配给当前对象，不得不提前Full GC</li>\n</ul>\n<h2 id=\"Garbage-First收集器\"><a href=\"#Garbage-First收集器\" class=\"headerlink\" title=\"Garbage First收集器\"></a>Garbage First收集器</h2><ul>\n<li>面向局部收集，基于Region的内存布局，全功能垃圾收集器</li>\n<li>主要面向服务器应用，服务器模式下默认的垃圾收集器</li>\n<li>建立停顿时间模型，支持指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒</li>\n<li>Mixed GC模式：面向堆的任何部分来组成回收集，衡量哪块内存中存放的垃圾数量最多，回收收益最大</li>\n<li>非常精确地控制停顿</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ul>\n<li>把连续的Java堆划分为多个大小相等的独立区域</li>\n<li>每个Region可以扮演新生代的Eden、Survivor或老年代空间</li>\n<li>Humongous区域，专门存储大对象：大小超过Region容量一半的对象、超级大对象放在连续的Humongous区域、把Humongous区域看作老年代</li>\n<li>将Region作为单位回收的最小单元，每次回收Region的整数倍</li>\n<li>让G1去跟踪各个Region里面垃圾的价值大小（回收所获得的空间大小以及回收所需时间的经验值）</li>\n<li>在后台维护一个优先级列表，优先处理回收价值收益最大的region</li>\n</ul>\n<h3 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h3><ul>\n<li><p>跨Region引用对象</p>\n<ul>\n<li>每个Region都维护自己的记忆集</li>\n<li>记录别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内</li>\n<li>是一个哈希表，Key是别的Region起始地址，Value是卡表索引号集合</li>\n<li>至少要耗费堆的10%-20%额外内存来维持收集器工作</li>\n</ul>\n</li>\n<li><p>并发标记阶段</p>\n<ul>\n<li>对象引用关系改变，不打破原有对象图。使用原始快照（SATB）算法</li>\n<li>新对象创建：设计两个指针，名为TAMS(Top at Mark Start)，把Region中一部分空间划分出来用于并发回收过程中的新对象分配，新分配对象必须在两个指针位置以上，默认这些对象是存活的，如果内存回收速度赶不上内存分配速度，也要STW的Full GC。</li>\n</ul>\n</li>\n<li><p>建立可靠的停顿预测模型</p>\n<ul>\n<li><p>记录每个Region的回收耗时、记忆集中脏卡数量等成本，计算统计信息</p>\n</li>\n<li><p>比普通平均值更容易收到新数据的影响，衰减平均值更准确的代表最近的平均状态</p>\n</li>\n<li><p>Region的统计状态越新越能决定其回收价值</p>\n</li>\n<li><p>通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高收益</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ul>\n<li>初始标记<ul>\n<li>标记GC Roots能直接关联到的对象</li>\n<li>修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用Region上分配新对象</li>\n<li>需要停顿线程，但耗时短，而且是借用Minor GC同步完成的，没有额外停顿</li>\n</ul>\n</li>\n<li>并发标记<ul>\n<li>堆中对象的可达性分析，递归扫描整个堆中对象图</li>\n<li>耗时长，能与用户线程并发执行</li>\n<li>处理在SATB记录下的在并发时有引用变动的对象</li>\n</ul>\n</li>\n<li>最终标记<ul>\n<li>对用户线程做另一个短暂暂停，处理并发阶段结束后遗留下来的最后那少量的SATB记录</li>\n</ul>\n</li>\n<li>筛选回收<ul>\n<li>更新Region的统计数据</li>\n<li>对Region的回收价值和成本排序</li>\n<li>根据用户所期望的停顿时间制定回收计划</li>\n<li>把决定回收的Region的存活对象复制到空Region中，清理旧Region的全部空间</li>\n<li>必须STW，由多条垃圾收集器线程并发完成</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li><p>在延迟可控的情况下获得尽可能高的吞吐量</p>\n</li>\n<li><p>取得关注吞吐量和关注延迟之间的最佳平衡</p>\n</li>\n<li><p>如果停顿时间过短，会导致每次筛选出来的回收集只占堆内存很小一部分，最终占满堆引发Full GC降低性能，停顿时间设置在100-300ms之间比较合理</p>\n</li>\n<li><p>整体是基于标记-整理的</p>\n</li>\n<li><p>局部是基于标记-复制的</p>\n</li>\n<li><p>不会产生内存空间碎片，收集后能提供规整的可用内存</p>\n</li>\n<li><p>使用写后屏障进行卡表维护操作</p>\n</li>\n<li><p>使用写前屏障来跟踪并发时的指针变化，实现SATB算法</p>\n</li>\n<li><p>小内存上CMS大概率优于G1（6-8GB为平衡点）</p>\n</li>\n</ul>\n<h1 id=\"垃圾收集实战\"><a href=\"#垃圾收集实战\" class=\"headerlink\" title=\"垃圾收集实战\"></a>垃圾收集实战</h1><ul>\n<li>实验环境：HotSpot、客户端模式、Serial+Serial Old</li>\n<li>对象的内存分配：大部分堆上分配，极小部分经过即时编译后拆散为标量类型并间接栈上分配</li>\n<li>新生对象通常分配新生代，少数情况（对象大小超过阈值）直接分配老年代</li>\n</ul>\n<h2 id=\"对象优先在Eden分配\"><a href=\"#对象优先在Eden分配\" class=\"headerlink\" title=\"对象优先在Eden分配\"></a>对象优先在Eden分配</h2><ul>\n<li>大多数情况下，对象在Eden区分配，如果Eden区没有足够空间分配，将发起Minor GC</li>\n<li>MinGC中，如果Survivor放不下Eden存活的，则通过对象担保机制，把存活的放入老年代</li>\n<li>-Xms20M -Xmx20M：堆大小20M，不可扩展</li>\n<li>-Xmn10M：10MB分配给新生代</li>\n<li>-XX:SurvivorRatio=8：Eden：Survivor = 8：1，新生代总可用区间9216KB(Eden+一个Survivor)</li>\n<li>-XX:+PrintGCDetails</li>\n</ul>\n<pre><code>VM参数:\n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:SurvivorRatio=8 \n-XX:+PrintGCDetails</code></pre>\n<pre><code class=\"java\">public class Main{\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1， allocation2， allocation3， allocation4;\n        allocation1 = new byte[2 * _1MB];\n        allocation2 = new byte[2 * _1MB];\n        allocation3 = new byte[2 * _1MB];\n        allocation4 = new byte[4 * _1MB]; //出现Minor GC\n    }\n}</code></pre>\n<pre><code class=\"java\">[GC (Allocation Failure) [DefNew: 8159K-&gt;626K(9216K)， 0.0041610 secs] 8159K-&gt;6770K(19456K)， 0.0042168 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \nHeap\n def new generation   total 9216K， used 4888K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  52% used [0x00000000fec00000， 0x00000000ff029840， 0x00000000ff400000)\n  from space 1024K，  61% used [0x00000000ff500000， 0x00000000ff59c960， 0x00000000ff600000)\n  to   space 1024K，   0% used [0x00000000ff400000， 0x00000000ff400000， 0x00000000ff500000)\n tenured generation   total 10240K， used 6144K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  60% used [0x00000000ff600000， 0x00000000ffc00030， 0x00000000ffc00200， 0x0000000100000000)\n Metaspace       used 3253K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 353K， capacity 388K， committed 512K， reserved 1048576K\n\nProcess finished with exit code 0\n</code></pre>\n<h2 id=\"大对象直接进入老年代\"><a href=\"#大对象直接进入老年代\" class=\"headerlink\" title=\"大对象直接进入老年代\"></a>大对象直接进入老年代</h2><ul>\n<li>大对象就是需要连续内存空间的Java对象</li>\n<li>很长的字符串或者元素数量很庞大的数组</li>\n<li>在程序中避免出现一群朝生夕灭的短命大对象</li>\n<li>他容易导致内存明明还有不少空间就提前触发了垃圾收集，以获取足够的连续空间才能安置好他们</li>\n<li>当复制对象时，大对象意味着高额的内存复制开销</li>\n<li>-XX:PretenureSizeThreshold=3145728</li>\n<li>可设置参数，指定大于设定值的对象直接在老年代分配，避免在Eden区以及两个Survivor区来回复制，产生大量的内存复制操作</li>\n</ul>\n<pre><code class=\"java\">-XX:PretenureSizeThreshold=3145728 \n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC \n-XX:SurvivorRatio=8 -XX:+PrintGCDetails</code></pre>\n<pre><code class=\"java\">public class Main{\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1;\n        allocation1 = new byte[4 * _1MB];//直接分配在老年代\n    }\n}</code></pre>\n<pre><code class=\"java\">Heap\n def new generation   total 9216K， used 2015K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  24% used [0x00000000fec00000， 0x00000000fedf7e90， 0x00000000ff400000)\n  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff400000， 0x00000000ff500000)\n  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)\n tenured generation   total 10240K， used 4096K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  40% used [0x00000000ff600000， 0x00000000ffa00010， 0x00000000ffa00200， 0x0000000100000000)\n Metaspace       used 3210K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 352K， capacity 388K， committed 512K， reserved 1048576K</code></pre>\n<h2 id=\"长期存活的对象将进入老年代\"><a href=\"#长期存活的对象将进入老年代\" class=\"headerlink\" title=\"长期存活的对象将进入老年代\"></a>长期存活的对象将进入老年代</h2><ul>\n<li>每个对象对象头定义了一个对象年龄计数器</li>\n<li>对象通常在Eden区诞生，如果经过第一次Minor GC仍然存活，并且能被Survivor容纳，则被移动到Survivor空间中，并且年龄设置为1</li>\n<li>对象在Survivor区每熬过一次Minor GC，年龄+1</li>\n<li>增长到15时，就会被晋升到老年代，晋升阈值通过-XX:MaxTenuringThreshold设置</li>\n<li>当-XX:MaxTenuringThreshold设置为1时，allocation1在第二次GC发生时进入老年代</li>\n</ul>\n<pre><code class=\"java\">-XX:+PrintTenuringDistribution -XX:MaxTenuringThreshold=1 \n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC \n-XX:SurvivorRatio=8 -XX:+PrintGCDetails</code></pre>\n<pre><code class=\"java\">public class Main {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1， allocation2， allocation3;\n        allocation1 = new byte[_1MB / 4];//什么时候进入老年代决定于-XX:MaxTenuringThreshold设置\n        allocation2 = new byte[4 * _1MB];\n        allocation3 = new byte[4 * _1MB];\n        allocation3 = null;\n        allocation3 = new byte[4 * _1MB];\n    }\n}</code></pre>\n<pre><code class=\"java\">[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 1 (max 1)\n- age   1:     886440 bytes，     886440 total\n: 6367K-&gt;865K(9216K)， 0.0055780 secs] 6367K-&gt;4961K(19456K)， 0.0056123 secs] [Times: user=0.00 sys=0.00， real=0.01 secs] \n[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 1 (max 1)\n- age   1:        680 bytes，        680 total\n: 5045K-&gt;0K(9216K)， 0.0012428 secs] 9141K-&gt;4958K(19456K)， 0.0012696 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \nHeap\n def new generation   total 9216K， used 4235K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  51% used [0x00000000fec00000， 0x00000000ff022a70， 0x00000000ff400000)\n  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff4002a8， 0x00000000ff500000)\n  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)\n tenured generation   total 10240K， used 4958K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  48% used [0x00000000ff600000， 0x00000000ffad7800， 0x00000000ffad7800， 0x0000000100000000)\n Metaspace       used 3286K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 357K， capacity 388K， committed 512K， reserved 1048576K</code></pre>\n<h2 id=\"动态对象年龄判断\"><a href=\"#动态对象年龄判断\" class=\"headerlink\" title=\"动态对象年龄判断\"></a>动态对象年龄判断</h2><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survovor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代</p>\n<pre><code class=\"java\">-XX:+PrintTenuringDistribution -XX:MaxTenuringThreshold=1 \n-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC \n-XX:SurvivorRatio=8 -XX:+PrintGCDetails</code></pre>\n<pre><code class=\"java\">public class Main {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1， allocation2， allocation3， allocation4;\n        allocation1 = new byte[_1MB / 4];//allocation1 + allocation2 大于 survivor空间的一半了\n        allocation2 = new byte[_1MB / 4];\n        allocation3 = new byte[4 * _1MB];\n        allocation4 = new byte[4 * _1MB];\n        allocation4 = null;\n        allocation4 = new byte[4 * _1MB];\n    }\n}</code></pre>\n<pre><code class=\"java\">[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 1 (max 15)\n- age   1:    1048576 bytes，    1048576 total\n: 6623K-&gt;1024K(9216K)， 0.0039616 secs] 6623K-&gt;5234K(19456K)， 0.0040033 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \n[GC (Allocation Failure) [DefNew\nDesired survivor size 524288 bytes， new threshold 15 (max 15)\n- age   1:        176 bytes，        176 total\n: 5204K-&gt;0K(9216K)， 0.0011999 secs] 9414K-&gt;5234K(19456K)， 0.0012304 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] \nHeap\n def new generation   total 9216K， used 4234K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)\n  eden space 8192K，  51% used [0x00000000fec00000， 0x00000000ff0227f0， 0x00000000ff400000)\n  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff4000b0， 0x00000000ff500000)\n  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)\n tenured generation   total 10240K， used 5234K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)\n   the space 10240K，  51% used [0x00000000ff600000， 0x00000000ffb1c9a0， 0x00000000ffb1ca00， 0x0000000100000000)\n Metaspace       used 3247K， capacity 4496K， committed 4864K， reserved 1056768K\n  class space    used 353K， capacity 388K， committed 512K， reserved 1048576K</code></pre>\n<h2 id=\"空间分配担保\"><a href=\"#空间分配担保\" class=\"headerlink\" title=\"空间分配担保\"></a>空间分配担保</h2><ul>\n<li>在Minor GC前，检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果成立，则这次Minor GC安全。</li>\n<li>否则要看是否允许担保失败。如果允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的平均大小，如果大于，将尝试进行一次Minor GC。如果小于，或者不允许担保，则Full GC。</li>\n<li>新生代中，当出现大量对象在Minor GC后仍然存活的情况，就把Survivor无法容纳的对象直接送入老年代，担保前提是老年代本身有容纳这些对象的剩余空间。</li>\n<li>但一共有多少对象会在这次回收中存活下来在实际回收完成之前是无法明确知道的，只能取之前每一次回收晋升老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间</li>\n<li>担保失败则又得Full GC，绕的圈子最大，但一般打开，避免Full GC过于频繁</li>\n<li>在JDK7及之后。不能设置参数影响空间分配担保策略。只要老年代最大可用连续空间大于新生代的所有对象空间，或者大于历次晋升到老年代的平均大小，就进行Minor GC，负责Full GC（相当于一定会冒险）</li>\n</ul>\n"},{"title":"集合基础","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"集合基础知识，包括集合安全、迭代器机制(快速失败、安全失败机制)、LRU算法等","abbrlink":"ca057823","date":"2020-12-03T16:00:00.000Z","_content":"\n\n\n# 概述\n\n+ HashMap快，TreeMap按照比较结果的升序保存键，LinkedHashMap按照插入顺序保存键，还保留了HashMap的查询速度\n+ HashSet快，TreeSet按比较结果升序排列，LinkedHashSet按照被添加顺序保存对象\n+ ArrayList，LinkedList按照被插入的顺序保存元素，使用LinkedList来实现queue，stack\n+ AbstractCollection是提供Collection部分实现的抽象类\n+ 如果除了在末尾外不能在其他位置插入或者删除元素，那么ArrayList效率更高，如果需要经常插入或者删除元素，就选择LinkedList\n\n# 集合安全\n\n+ 提供了包装器工厂方法(例如Collections.synchronizedList等)。他们将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象中，使得每次只有一个线程能访问容器的状态\n+ CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ArrayBlockingQueue、LinkedBlockingQueue、ConcurrentLinkedQueue、ConcurrentLinkedDeque\n+ 尽管Vector线程安全，仍然需要用synchronized保护复合操作。同步容器类是线程安全的，但复合操作仍然需要额外的客户端加锁来保护，例如迭代\n\n## Collections.synchronizedMap(Map)\n\n```java\n//在SynchronizedMap内部维护了⼀个普通对象Map，还有排斥锁mutex\nprivate final Map<K,V> m;     // Backing Map\nfinal Object      mutex; \n\n\n/*\n我们在调⽤这个⽅法的时候就需要传⼊⼀个Map，可以看到有两个构造器，如果你传⼊了mutex参数，则将对象排斥锁赋值为传⼊的对象。如果没有，则将对象排斥锁赋值为this，即调⽤synchronizedMap的对象，就是上⾯的Map\n*/\nSynchronizedMap(Map<K,V> m) {\n    this.m = Objects.requireNonNull(m);\n    mutex = this;\n}\n\nSynchronizedMap(Map<K,V> m, Object mutex) {\n    this.m = m;\n    this.mutex = mutex;\n}\n\n//创建出synchronizedMap之后，再操作map的时候，就会对⽅法上锁\npublic int size() {\n\tsynchronized (mutex) {return m.size();}\n}\npublic boolean isEmpty() {\n\tsynchronized (mutex) {return m.isEmpty();}\n}\n```\n\n# 迭代器机制\n\n+ 用迭代器来表示容器之间的共性，实现Collection就意味着需要提供iterator()方法，因为Collection继承了Iterable接口\n+ 创建了任何实现Iterable接口的类，都可以用于foreach语句中\n+ 数组也能使用foreach，但是不存在任何从数组到Iterable的自动转换\n\n## 快速失败（fail-fast）\n\n+ 如果采用快速失败机制，那么在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行增加、删除、修改，或者 A 线程在遍历过程中对集合进行增加、删除、修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。\n\n- 原因是迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。\n- 每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历。\n- java.util 包下的集合类都是快速失败的。\n\n\n\n+ 快速失败（fail—fast）是java集合中的一种机制，在用迭代器遍历一个集合对象时，如果遍历过程中有另一个线程对集合对象的内容进行了修改，则会抛出ConcurrentModificationException\n\n+ 迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。\n\n+ 每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。\n\n+ java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）\n\n+ 隐式的迭代器，就是没有显示调用，但是也用到了迭代器，例如直接打印集合System.out.println(set)\n\n+ 会快速失败的方法：put()，remove()，clear()，resize()\n\n+ 解决办法\n\n    + 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized\n    + 使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。\n    + 如果不希望在迭代过程中加锁，可以选择克隆容器，并在副本上进行迭代，但是克隆时还是要对容器进行加锁\n    + List<String> list=Collections.synchronizedList(new ArrayList<>());\n    + List<String> list = new CopyOnWriteArrayList<>(); //写时复制 \n\n    \n\n## 安全失败（fail—safe）\n\n- 那么在遍历时不是直接在集合内容上访问，而是先复制原有集合内容，在拷贝的集合上进行遍历。\n- 由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常。\n- java.util.concurrent 包下的并发容器都是安全失败的。\n\n\n\n+ fail-safe允许在遍历的过程中对容器中的数据进行修改\n+ 这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历\n+ java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。\n+ 常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList\n+ 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。\n+ 基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。\n+ 所得到的Iterator中的elements只是CopyOnWriteArrayList中array的拷贝，当对CopyOnWriteArrayList中array操作时并不会影响到Iterator中的elements，因此永远都不会抛出安全失败的异常。但也是因为这个，无法保证读取的数据是目前原始数据结构中的数据。\n\n# LRU\n\n最近最少使用缓存机制\n\n算法核心是哈希+链表\n\n本质就是HashMap+DoubleLinkedList\n\n时间复杂度`O(1)`\n\n## LinkedHashMap\n\n```java\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main<K，V> extends LinkedHashMap<K，V> {\n    private int capacity;\n\n    public Main(int capacity) {\n        super(capacity，0.75F，true);\n        this.capacity = capacity;\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K， V> eldest) {\n        return super.size() > capacity;\n    }\n\n    public static void main(String[] args) {\n        Main main = new Main(3);\n        main.put(1， \"a\");\n        main.put(2， \"b\");\n        main.put(3， \"c\");\n        main.get(1);\n        main.put(4， \"d\");\n        //[3， 1， 4]\n        System.out.println(main.keySet());\n    }\n}\n```\n\n## 使用HashMap实现\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main<K, V> {\n    private class Node<K, V> {\n        private K key;\n        private V val;\n        private Node<K, V> prev;\n        private Node<K, V> next;\n\n        public Node(K key, V val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public Node() {\n\n        }\n    }\n\n    private class DoubleLinkedList<K, V> {\n        //为了方便，他们本身不指向任何实际值\n        Node<K, V> head;\n        Node<K, V> tail;\n\n        public DoubleLinkedList() {\n            head = new Node<>();\n            tail = new Node<>();\n            head.next = tail;\n            tail.prev = head;\n        }\n\n        public Node<K, V> getLast() {\n            if (isEmpty()) throw new RuntimeException();\n            return tail.prev;\n        }\n\n        public void addFirst(Node<K, V> node) {\n            Node<K, V> oldFirst = head.next;\n            node.next = oldFirst;\n            oldFirst.prev = node;\n            head.next = node;\n            node.prev = head;\n        }\n\n        public void remove(Node<K, V> node) {\n            Node<K, V> preNode = node.prev;\n            Node<K, V> nextNode = node.next;\n            preNode.next = nextNode;\n            nextNode.prev = preNode;\n            node.prev = null;\n            node.next = null;\n        }\n\n        public boolean isEmpty() {\n            return head == tail;\n        }\n\n        public void print() {\n            for (Node<K, V> x = head.next; x != tail; x = x.next) {\n                System.out.println(x.key + \":\" + x.val);\n            }\n        }\n    }\n\n\n    private int cacheSize;\n    private Map<K, Node<K, V>> map;\n    private DoubleLinkedList<K, V> doubleLinkedList;\n\n    public Main(int cacheSize) {\n        this.cacheSize = cacheSize;\n        map = new HashMap<>();\n        doubleLinkedList = new DoubleLinkedList<>();\n    }\n\n    public void put(K key, V value) {\n        if (map.containsKey(key)) {\n\n        } else {\n            if (map.size() == cacheSize) {\n                //需要删除该元素\n                Node<K, V> node = doubleLinkedList.getLast();\n                //Map中要同时删除\n                map.remove(node.key);\n                doubleLinkedList.remove(node);\n            }\n            Node<K, V> node = new Node<>(key, value);\n            map.put(key, node);\n            doubleLinkedList.addFirst(node);\n        }\n    }\n\n    public V get(K key) {\n        if (map.containsKey(key)) {\n            //为了好操作，应该使用节点来操作\n            //所以map中应该存储key,Node<key,value>\n            Node<K, V> node = map.get(key);\n            doubleLinkedList.remove(node);\n            doubleLinkedList.addFirst(node);\n            return node.val;\n        }\n        return null;\n    }\n\n    public void print() {\n        doubleLinkedList.print();\n    }\n\n\n    public static void main(String[] args) {\n        Main<Integer, String> main = new Main<>(3);\n        main.put(1, \"a\");\n        main.put(2, \"a\");\n        main.put(3, \"a\");\n        main.get(1);\n        main.put(4, \"a\");\n        main.print();\n    }\n}\n```\n\n","source":"_posts/Java语言/Java集合/1.集合基础.md","raw":"---\ntitle: 集合基础\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 集合基础知识，包括集合安全、迭代器机制(快速失败、安全失败机制)、LRU算法等\ncategories: Java集合\ntags:\n  - 集合安全\n  - 迭代器机制\n  - LRU算法\nabbrlink: ca057823\ndate: 2020-12-04 00:00:00\n---\n\n\n\n# 概述\n\n+ HashMap快，TreeMap按照比较结果的升序保存键，LinkedHashMap按照插入顺序保存键，还保留了HashMap的查询速度\n+ HashSet快，TreeSet按比较结果升序排列，LinkedHashSet按照被添加顺序保存对象\n+ ArrayList，LinkedList按照被插入的顺序保存元素，使用LinkedList来实现queue，stack\n+ AbstractCollection是提供Collection部分实现的抽象类\n+ 如果除了在末尾外不能在其他位置插入或者删除元素，那么ArrayList效率更高，如果需要经常插入或者删除元素，就选择LinkedList\n\n# 集合安全\n\n+ 提供了包装器工厂方法(例如Collections.synchronizedList等)。他们将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象中，使得每次只有一个线程能访问容器的状态\n+ CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ArrayBlockingQueue、LinkedBlockingQueue、ConcurrentLinkedQueue、ConcurrentLinkedDeque\n+ 尽管Vector线程安全，仍然需要用synchronized保护复合操作。同步容器类是线程安全的，但复合操作仍然需要额外的客户端加锁来保护，例如迭代\n\n## Collections.synchronizedMap(Map)\n\n```java\n//在SynchronizedMap内部维护了⼀个普通对象Map，还有排斥锁mutex\nprivate final Map<K,V> m;     // Backing Map\nfinal Object      mutex; \n\n\n/*\n我们在调⽤这个⽅法的时候就需要传⼊⼀个Map，可以看到有两个构造器，如果你传⼊了mutex参数，则将对象排斥锁赋值为传⼊的对象。如果没有，则将对象排斥锁赋值为this，即调⽤synchronizedMap的对象，就是上⾯的Map\n*/\nSynchronizedMap(Map<K,V> m) {\n    this.m = Objects.requireNonNull(m);\n    mutex = this;\n}\n\nSynchronizedMap(Map<K,V> m, Object mutex) {\n    this.m = m;\n    this.mutex = mutex;\n}\n\n//创建出synchronizedMap之后，再操作map的时候，就会对⽅法上锁\npublic int size() {\n\tsynchronized (mutex) {return m.size();}\n}\npublic boolean isEmpty() {\n\tsynchronized (mutex) {return m.isEmpty();}\n}\n```\n\n# 迭代器机制\n\n+ 用迭代器来表示容器之间的共性，实现Collection就意味着需要提供iterator()方法，因为Collection继承了Iterable接口\n+ 创建了任何实现Iterable接口的类，都可以用于foreach语句中\n+ 数组也能使用foreach，但是不存在任何从数组到Iterable的自动转换\n\n## 快速失败（fail-fast）\n\n+ 如果采用快速失败机制，那么在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行增加、删除、修改，或者 A 线程在遍历过程中对集合进行增加、删除、修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。\n\n- 原因是迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。\n- 每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历。\n- java.util 包下的集合类都是快速失败的。\n\n\n\n+ 快速失败（fail—fast）是java集合中的一种机制，在用迭代器遍历一个集合对象时，如果遍历过程中有另一个线程对集合对象的内容进行了修改，则会抛出ConcurrentModificationException\n\n+ 迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。\n\n+ 每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。\n\n+ java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）\n\n+ 隐式的迭代器，就是没有显示调用，但是也用到了迭代器，例如直接打印集合System.out.println(set)\n\n+ 会快速失败的方法：put()，remove()，clear()，resize()\n\n+ 解决办法\n\n    + 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized\n    + 使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。\n    + 如果不希望在迭代过程中加锁，可以选择克隆容器，并在副本上进行迭代，但是克隆时还是要对容器进行加锁\n    + List<String> list=Collections.synchronizedList(new ArrayList<>());\n    + List<String> list = new CopyOnWriteArrayList<>(); //写时复制 \n\n    \n\n## 安全失败（fail—safe）\n\n- 那么在遍历时不是直接在集合内容上访问，而是先复制原有集合内容，在拷贝的集合上进行遍历。\n- 由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常。\n- java.util.concurrent 包下的并发容器都是安全失败的。\n\n\n\n+ fail-safe允许在遍历的过程中对容器中的数据进行修改\n+ 这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历\n+ java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。\n+ 常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList\n+ 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。\n+ 基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。\n+ 所得到的Iterator中的elements只是CopyOnWriteArrayList中array的拷贝，当对CopyOnWriteArrayList中array操作时并不会影响到Iterator中的elements，因此永远都不会抛出安全失败的异常。但也是因为这个，无法保证读取的数据是目前原始数据结构中的数据。\n\n# LRU\n\n最近最少使用缓存机制\n\n算法核心是哈希+链表\n\n本质就是HashMap+DoubleLinkedList\n\n时间复杂度`O(1)`\n\n## LinkedHashMap\n\n```java\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main<K，V> extends LinkedHashMap<K，V> {\n    private int capacity;\n\n    public Main(int capacity) {\n        super(capacity，0.75F，true);\n        this.capacity = capacity;\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K， V> eldest) {\n        return super.size() > capacity;\n    }\n\n    public static void main(String[] args) {\n        Main main = new Main(3);\n        main.put(1， \"a\");\n        main.put(2， \"b\");\n        main.put(3， \"c\");\n        main.get(1);\n        main.put(4， \"d\");\n        //[3， 1， 4]\n        System.out.println(main.keySet());\n    }\n}\n```\n\n## 使用HashMap实现\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main<K, V> {\n    private class Node<K, V> {\n        private K key;\n        private V val;\n        private Node<K, V> prev;\n        private Node<K, V> next;\n\n        public Node(K key, V val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public Node() {\n\n        }\n    }\n\n    private class DoubleLinkedList<K, V> {\n        //为了方便，他们本身不指向任何实际值\n        Node<K, V> head;\n        Node<K, V> tail;\n\n        public DoubleLinkedList() {\n            head = new Node<>();\n            tail = new Node<>();\n            head.next = tail;\n            tail.prev = head;\n        }\n\n        public Node<K, V> getLast() {\n            if (isEmpty()) throw new RuntimeException();\n            return tail.prev;\n        }\n\n        public void addFirst(Node<K, V> node) {\n            Node<K, V> oldFirst = head.next;\n            node.next = oldFirst;\n            oldFirst.prev = node;\n            head.next = node;\n            node.prev = head;\n        }\n\n        public void remove(Node<K, V> node) {\n            Node<K, V> preNode = node.prev;\n            Node<K, V> nextNode = node.next;\n            preNode.next = nextNode;\n            nextNode.prev = preNode;\n            node.prev = null;\n            node.next = null;\n        }\n\n        public boolean isEmpty() {\n            return head == tail;\n        }\n\n        public void print() {\n            for (Node<K, V> x = head.next; x != tail; x = x.next) {\n                System.out.println(x.key + \":\" + x.val);\n            }\n        }\n    }\n\n\n    private int cacheSize;\n    private Map<K, Node<K, V>> map;\n    private DoubleLinkedList<K, V> doubleLinkedList;\n\n    public Main(int cacheSize) {\n        this.cacheSize = cacheSize;\n        map = new HashMap<>();\n        doubleLinkedList = new DoubleLinkedList<>();\n    }\n\n    public void put(K key, V value) {\n        if (map.containsKey(key)) {\n\n        } else {\n            if (map.size() == cacheSize) {\n                //需要删除该元素\n                Node<K, V> node = doubleLinkedList.getLast();\n                //Map中要同时删除\n                map.remove(node.key);\n                doubleLinkedList.remove(node);\n            }\n            Node<K, V> node = new Node<>(key, value);\n            map.put(key, node);\n            doubleLinkedList.addFirst(node);\n        }\n    }\n\n    public V get(K key) {\n        if (map.containsKey(key)) {\n            //为了好操作，应该使用节点来操作\n            //所以map中应该存储key,Node<key,value>\n            Node<K, V> node = map.get(key);\n            doubleLinkedList.remove(node);\n            doubleLinkedList.addFirst(node);\n            return node.val;\n        }\n        return null;\n    }\n\n    public void print() {\n        doubleLinkedList.print();\n    }\n\n\n    public static void main(String[] args) {\n        Main<Integer, String> main = new Main<>(3);\n        main.put(1, \"a\");\n        main.put(2, \"a\");\n        main.put(3, \"a\");\n        main.get(1);\n        main.put(4, \"a\");\n        main.print();\n    }\n}\n```\n\n","slug":"Java语言/Java集合/1.集合基础","published":1,"updated":"2021-06-08T03:35:00.520Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq50t000cz0tp5g6l84rk","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><ul>\n<li>HashMap快，TreeMap按照比较结果的升序保存键，LinkedHashMap按照插入顺序保存键，还保留了HashMap的查询速度</li>\n<li>HashSet快，TreeSet按比较结果升序排列，LinkedHashSet按照被添加顺序保存对象</li>\n<li>ArrayList，LinkedList按照被插入的顺序保存元素，使用LinkedList来实现queue，stack</li>\n<li>AbstractCollection是提供Collection部分实现的抽象类</li>\n<li>如果除了在末尾外不能在其他位置插入或者删除元素，那么ArrayList效率更高，如果需要经常插入或者删除元素，就选择LinkedList</li>\n</ul>\n<h1 id=\"集合安全\"><a href=\"#集合安全\" class=\"headerlink\" title=\"集合安全\"></a>集合安全</h1><ul>\n<li>提供了包装器工厂方法(例如Collections.synchronizedList等)。他们将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象中，使得每次只有一个线程能访问容器的状态</li>\n<li>CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ArrayBlockingQueue、LinkedBlockingQueue、ConcurrentLinkedQueue、ConcurrentLinkedDeque</li>\n<li>尽管Vector线程安全，仍然需要用synchronized保护复合操作。同步容器类是线程安全的，但复合操作仍然需要额外的客户端加锁来保护，例如迭代</li>\n</ul>\n<h2 id=\"Collections-synchronizedMap-Map\"><a href=\"#Collections-synchronizedMap-Map\" class=\"headerlink\" title=\"Collections.synchronizedMap(Map)\"></a>Collections.synchronizedMap(Map)</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//在SynchronizedMap内部维护了⼀个普通对象Map，还有排斥锁mutex</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Map<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> m<span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// Backing Map</span>\n<span class=\"token keyword\">final</span> Object      mutex<span class=\"token punctuation\">;</span> \n\n\n<span class=\"token comment\" spellcheck=\"true\">/*\n我们在调⽤这个⽅法的时候就需要传⼊⼀个Map，可以看到有两个构造器，如果你传⼊了mutex参数，则将对象排斥锁赋值为传⼊的对象。如果没有，则将对象排斥锁赋值为this，即调⽤synchronizedMap的对象，就是上⾯的Map\n*/</span>\n<span class=\"token function\">SynchronizedMap</span><span class=\"token punctuation\">(</span>Map<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>m <span class=\"token operator\">=</span> Objects<span class=\"token punctuation\">.</span><span class=\"token function\">requireNonNull</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    mutex <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">SynchronizedMap</span><span class=\"token punctuation\">(</span>Map<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> m<span class=\"token punctuation\">,</span> Object mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>m <span class=\"token operator\">=</span> m<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mutex <span class=\"token operator\">=</span> mutex<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//创建出synchronizedMap之后，再操作map的时候，就会对⽅法上锁</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> m<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> m<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"迭代器机制\"><a href=\"#迭代器机制\" class=\"headerlink\" title=\"迭代器机制\"></a>迭代器机制</h1><ul>\n<li>用迭代器来表示容器之间的共性，实现Collection就意味着需要提供iterator()方法，因为Collection继承了Iterable接口</li>\n<li>创建了任何实现Iterable接口的类，都可以用于foreach语句中</li>\n<li>数组也能使用foreach，但是不存在任何从数组到Iterable的自动转换</li>\n</ul>\n<h2 id=\"快速失败（fail-fast）\"><a href=\"#快速失败（fail-fast）\" class=\"headerlink\" title=\"快速失败（fail-fast）\"></a>快速失败（fail-fast）</h2><ul>\n<li>如果采用快速失败机制，那么在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行增加、删除、修改，或者 A 线程在遍历过程中对集合进行增加、删除、修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。</li>\n</ul>\n<ul>\n<li>原因是迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。</li>\n<li>每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</li>\n<li>java.util 包下的集合类都是快速失败的。</li>\n</ul>\n<ul>\n<li><p>快速失败（fail—fast）是java集合中的一种机制，在用迭代器遍历一个集合对象时，如果遍历过程中有另一个线程对集合对象的内容进行了修改，则会抛出ConcurrentModificationException</p>\n</li>\n<li><p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。</p>\n</li>\n<li><p>每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>\n</li>\n<li><p>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）</p>\n</li>\n<li><p>隐式的迭代器，就是没有显示调用，但是也用到了迭代器，例如直接打印集合System.out.println(set)</p>\n</li>\n<li><p>会快速失败的方法：put()，remove()，clear()，resize()</p>\n</li>\n<li><p>解决办法</p>\n<ul>\n<li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized</li>\n<li>使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</li>\n<li>如果不希望在迭代过程中加锁，可以选择克隆容器，并在副本上进行迭代，但是克隆时还是要对容器进行加锁</li>\n<li>List<String> list=Collections.synchronizedList(new ArrayList&lt;&gt;());</li>\n<li>List<String> list = new CopyOnWriteArrayList&lt;&gt;(); //写时复制 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安全失败（fail—safe）\"><a href=\"#安全失败（fail—safe）\" class=\"headerlink\" title=\"安全失败（fail—safe）\"></a>安全失败（fail—safe）</h2><ul>\n<li>那么在遍历时不是直接在集合内容上访问，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li>\n<li>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常。</li>\n<li>java.util.concurrent 包下的并发容器都是安全失败的。</li>\n</ul>\n<ul>\n<li>fail-safe允许在遍历的过程中对容器中的数据进行修改</li>\n<li>这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历</li>\n<li>java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。</li>\n<li>常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList</li>\n<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li>\n<li>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li>\n<li>所得到的Iterator中的elements只是CopyOnWriteArrayList中array的拷贝，当对CopyOnWriteArrayList中array操作时并不会影响到Iterator中的elements，因此永远都不会抛出安全失败的异常。但也是因为这个，无法保证读取的数据是目前原始数据结构中的数据。</li>\n</ul>\n<h1 id=\"LRU\"><a href=\"#LRU\" class=\"headerlink\" title=\"LRU\"></a>LRU</h1><p>最近最少使用缓存机制</p>\n<p>算法核心是哈希+链表</p>\n<p>本质就是HashMap+DoubleLinkedList</p>\n<p>时间复杂度<code>O(1)</code></p>\n<h2 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>LinkedHashMap<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Map<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span><span class=\"token operator\">&lt;</span>K，V<span class=\"token operator\">></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">LinkedHashMap</span><span class=\"token operator\">&lt;</span>K，V<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>capacity，<span class=\"token number\">0.75F</span>，<span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>capacity <span class=\"token operator\">=</span> capacity<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">removeEldestEntry</span><span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token operator\">&lt;</span>K， V<span class=\"token operator\">></span> eldest<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> capacity<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Main main <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Main</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        main<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span>， <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        main<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span>， <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        main<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span>， <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        main<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        main<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span>， <span class=\"token string\">\"d\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//[3， 1， 4]</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"使用HashMap实现\"><a href=\"#使用HashMap实现\" class=\"headerlink\" title=\"使用HashMap实现\"></a>使用HashMap实现</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>HashMap<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Map<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> K key<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> V val<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> prev<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> next<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span>K key<span class=\"token punctuation\">,</span> V val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>val <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DoubleLinkedList</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//为了方便，他们本身不指向任何实际值</span>\n        Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> head<span class=\"token punctuation\">;</span>\n        Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> tail<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token function\">DoubleLinkedList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            head <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            tail <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            head<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">;</span>\n            tail<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> <span class=\"token function\">getLast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> tail<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addFirst</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> oldFirst <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            node<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> oldFirst<span class=\"token punctuation\">;</span>\n            oldFirst<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n            head<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n            node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> preNode <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n            Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> nextNode <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            preNode<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> nextNode<span class=\"token punctuation\">;</span>\n            nextNode<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> preNode<span class=\"token punctuation\">;</span>\n            node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n            node<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> head <span class=\"token operator\">==</span> tail<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> x <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span> x <span class=\"token operator\">!=</span> tail<span class=\"token punctuation\">;</span> x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>key <span class=\"token operator\">+</span> <span class=\"token string\">\":\"</span> <span class=\"token operator\">+</span> x<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> cacheSize<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> Map<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">>></span> map<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> DoubleLinkedList<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> doubleLinkedList<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> cacheSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>cacheSize <span class=\"token operator\">=</span> cacheSize<span class=\"token punctuation\">;</span>\n        map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        doubleLinkedList <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DoubleLinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>K key<span class=\"token punctuation\">,</span> V value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> cacheSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//需要删除该元素</span>\n                Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> node <span class=\"token operator\">=</span> doubleLinkedList<span class=\"token punctuation\">.</span><span class=\"token function\">getLast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//Map中要同时删除</span>\n                map<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                doubleLinkedList<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> node <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            doubleLinkedList<span class=\"token punctuation\">.</span><span class=\"token function\">addFirst</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> V <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>K key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//为了好操作，应该使用节点来操作</span>\n            <span class=\"token comment\" spellcheck=\"true\">//所以map中应该存储key,Node&lt;key,value></span>\n            Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> node <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            doubleLinkedList<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            doubleLinkedList<span class=\"token punctuation\">.</span><span class=\"token function\">addFirst</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        doubleLinkedList<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Main<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> main <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Main</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        main<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        main<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        main<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        main<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        main<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        main<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><ul>\n<li>HashMap快，TreeMap按照比较结果的升序保存键，LinkedHashMap按照插入顺序保存键，还保留了HashMap的查询速度</li>\n<li>HashSet快，TreeSet按比较结果升序排列，LinkedHashSet按照被添加顺序保存对象</li>\n<li>ArrayList，LinkedList按照被插入的顺序保存元素，使用LinkedList来实现queue，stack</li>\n<li>AbstractCollection是提供Collection部分实现的抽象类</li>\n<li>如果除了在末尾外不能在其他位置插入或者删除元素，那么ArrayList效率更高，如果需要经常插入或者删除元素，就选择LinkedList</li>\n</ul>\n<h1 id=\"集合安全\"><a href=\"#集合安全\" class=\"headerlink\" title=\"集合安全\"></a>集合安全</h1><ul>\n<li>提供了包装器工厂方法(例如Collections.synchronizedList等)。他们将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象中，使得每次只有一个线程能访问容器的状态</li>\n<li>CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ArrayBlockingQueue、LinkedBlockingQueue、ConcurrentLinkedQueue、ConcurrentLinkedDeque</li>\n<li>尽管Vector线程安全，仍然需要用synchronized保护复合操作。同步容器类是线程安全的，但复合操作仍然需要额外的客户端加锁来保护，例如迭代</li>\n</ul>\n<h2 id=\"Collections-synchronizedMap-Map\"><a href=\"#Collections-synchronizedMap-Map\" class=\"headerlink\" title=\"Collections.synchronizedMap(Map)\"></a>Collections.synchronizedMap(Map)</h2><pre><code class=\"java\">//在SynchronizedMap内部维护了⼀个普通对象Map，还有排斥锁mutex\nprivate final Map&lt;K,V&gt; m;     // Backing Map\nfinal Object      mutex; \n\n\n/*\n我们在调⽤这个⽅法的时候就需要传⼊⼀个Map，可以看到有两个构造器，如果你传⼊了mutex参数，则将对象排斥锁赋值为传⼊的对象。如果没有，则将对象排斥锁赋值为this，即调⽤synchronizedMap的对象，就是上⾯的Map\n*/\nSynchronizedMap(Map&lt;K,V&gt; m) {\n    this.m = Objects.requireNonNull(m);\n    mutex = this;\n}\n\nSynchronizedMap(Map&lt;K,V&gt; m, Object mutex) {\n    this.m = m;\n    this.mutex = mutex;\n}\n\n//创建出synchronizedMap之后，再操作map的时候，就会对⽅法上锁\npublic int size() {\n    synchronized (mutex) {return m.size();}\n}\npublic boolean isEmpty() {\n    synchronized (mutex) {return m.isEmpty();}\n}</code></pre>\n<h1 id=\"迭代器机制\"><a href=\"#迭代器机制\" class=\"headerlink\" title=\"迭代器机制\"></a>迭代器机制</h1><ul>\n<li>用迭代器来表示容器之间的共性，实现Collection就意味着需要提供iterator()方法，因为Collection继承了Iterable接口</li>\n<li>创建了任何实现Iterable接口的类，都可以用于foreach语句中</li>\n<li>数组也能使用foreach，但是不存在任何从数组到Iterable的自动转换</li>\n</ul>\n<h2 id=\"快速失败（fail-fast）\"><a href=\"#快速失败（fail-fast）\" class=\"headerlink\" title=\"快速失败（fail-fast）\"></a>快速失败（fail-fast）</h2><ul>\n<li>如果采用快速失败机制，那么在使用迭代器对集合对象进行遍历的时候，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行增加、删除、修改，或者 A 线程在遍历过程中对集合进行增加、删除、修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。</li>\n</ul>\n<ul>\n<li>原因是迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。</li>\n<li>每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</li>\n<li>java.util 包下的集合类都是快速失败的。</li>\n</ul>\n<ul>\n<li><p>快速失败（fail—fast）是java集合中的一种机制，在用迭代器遍历一个集合对象时，如果遍历过程中有另一个线程对集合对象的内容进行了修改，则会抛出ConcurrentModificationException</p>\n</li>\n<li><p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。</p>\n</li>\n<li><p>每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>\n</li>\n<li><p>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）</p>\n</li>\n<li><p>隐式的迭代器，就是没有显示调用，但是也用到了迭代器，例如直接打印集合System.out.println(set)</p>\n</li>\n<li><p>会快速失败的方法：put()，remove()，clear()，resize()</p>\n</li>\n<li><p>解决办法</p>\n<ul>\n<li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized</li>\n<li>使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</li>\n<li>如果不希望在迭代过程中加锁，可以选择克隆容器，并在副本上进行迭代，但是克隆时还是要对容器进行加锁</li>\n<li>List<String> list=Collections.synchronizedList(new ArrayList&lt;&gt;());</li>\n<li>List<String> list = new CopyOnWriteArrayList&lt;&gt;(); //写时复制 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安全失败（fail—safe）\"><a href=\"#安全失败（fail—safe）\" class=\"headerlink\" title=\"安全失败（fail—safe）\"></a>安全失败（fail—safe）</h2><ul>\n<li>那么在遍历时不是直接在集合内容上访问，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li>\n<li>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常。</li>\n<li>java.util.concurrent 包下的并发容器都是安全失败的。</li>\n</ul>\n<ul>\n<li>fail-safe允许在遍历的过程中对容器中的数据进行修改</li>\n<li>这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历</li>\n<li>java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。</li>\n<li>常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList</li>\n<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li>\n<li>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li>\n<li>所得到的Iterator中的elements只是CopyOnWriteArrayList中array的拷贝，当对CopyOnWriteArrayList中array操作时并不会影响到Iterator中的elements，因此永远都不会抛出安全失败的异常。但也是因为这个，无法保证读取的数据是目前原始数据结构中的数据。</li>\n</ul>\n<h1 id=\"LRU\"><a href=\"#LRU\" class=\"headerlink\" title=\"LRU\"></a>LRU</h1><p>最近最少使用缓存机制</p>\n<p>算法核心是哈希+链表</p>\n<p>本质就是HashMap+DoubleLinkedList</p>\n<p>时间复杂度<code>O(1)</code></p>\n<h2 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h2><pre><code class=\"java\">import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main&lt;K，V&gt; extends LinkedHashMap&lt;K，V&gt; {\n    private int capacity;\n\n    public Main(int capacity) {\n        super(capacity，0.75F，true);\n        this.capacity = capacity;\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry&lt;K， V&gt; eldest) {\n        return super.size() &gt; capacity;\n    }\n\n    public static void main(String[] args) {\n        Main main = new Main(3);\n        main.put(1， &quot;a&quot;);\n        main.put(2， &quot;b&quot;);\n        main.put(3， &quot;c&quot;);\n        main.get(1);\n        main.put(4， &quot;d&quot;);\n        //[3， 1， 4]\n        System.out.println(main.keySet());\n    }\n}</code></pre>\n<h2 id=\"使用HashMap实现\"><a href=\"#使用HashMap实现\" class=\"headerlink\" title=\"使用HashMap实现\"></a>使用HashMap实现</h2><pre><code class=\"java\">import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main&lt;K, V&gt; {\n    private class Node&lt;K, V&gt; {\n        private K key;\n        private V val;\n        private Node&lt;K, V&gt; prev;\n        private Node&lt;K, V&gt; next;\n\n        public Node(K key, V val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public Node() {\n\n        }\n    }\n\n    private class DoubleLinkedList&lt;K, V&gt; {\n        //为了方便，他们本身不指向任何实际值\n        Node&lt;K, V&gt; head;\n        Node&lt;K, V&gt; tail;\n\n        public DoubleLinkedList() {\n            head = new Node&lt;&gt;();\n            tail = new Node&lt;&gt;();\n            head.next = tail;\n            tail.prev = head;\n        }\n\n        public Node&lt;K, V&gt; getLast() {\n            if (isEmpty()) throw new RuntimeException();\n            return tail.prev;\n        }\n\n        public void addFirst(Node&lt;K, V&gt; node) {\n            Node&lt;K, V&gt; oldFirst = head.next;\n            node.next = oldFirst;\n            oldFirst.prev = node;\n            head.next = node;\n            node.prev = head;\n        }\n\n        public void remove(Node&lt;K, V&gt; node) {\n            Node&lt;K, V&gt; preNode = node.prev;\n            Node&lt;K, V&gt; nextNode = node.next;\n            preNode.next = nextNode;\n            nextNode.prev = preNode;\n            node.prev = null;\n            node.next = null;\n        }\n\n        public boolean isEmpty() {\n            return head == tail;\n        }\n\n        public void print() {\n            for (Node&lt;K, V&gt; x = head.next; x != tail; x = x.next) {\n                System.out.println(x.key + &quot;:&quot; + x.val);\n            }\n        }\n    }\n\n\n    private int cacheSize;\n    private Map&lt;K, Node&lt;K, V&gt;&gt; map;\n    private DoubleLinkedList&lt;K, V&gt; doubleLinkedList;\n\n    public Main(int cacheSize) {\n        this.cacheSize = cacheSize;\n        map = new HashMap&lt;&gt;();\n        doubleLinkedList = new DoubleLinkedList&lt;&gt;();\n    }\n\n    public void put(K key, V value) {\n        if (map.containsKey(key)) {\n\n        } else {\n            if (map.size() == cacheSize) {\n                //需要删除该元素\n                Node&lt;K, V&gt; node = doubleLinkedList.getLast();\n                //Map中要同时删除\n                map.remove(node.key);\n                doubleLinkedList.remove(node);\n            }\n            Node&lt;K, V&gt; node = new Node&lt;&gt;(key, value);\n            map.put(key, node);\n            doubleLinkedList.addFirst(node);\n        }\n    }\n\n    public V get(K key) {\n        if (map.containsKey(key)) {\n            //为了好操作，应该使用节点来操作\n            //所以map中应该存储key,Node&lt;key,value&gt;\n            Node&lt;K, V&gt; node = map.get(key);\n            doubleLinkedList.remove(node);\n            doubleLinkedList.addFirst(node);\n            return node.val;\n        }\n        return null;\n    }\n\n    public void print() {\n        doubleLinkedList.print();\n    }\n\n\n    public static void main(String[] args) {\n        Main&lt;Integer, String&gt; main = new Main&lt;&gt;(3);\n        main.put(1, &quot;a&quot;);\n        main.put(2, &quot;a&quot;);\n        main.put(3, &quot;a&quot;);\n        main.get(1);\n        main.put(4, &quot;a&quot;);\n        main.print();\n    }\n}</code></pre>\n"},{"title":"AQS相关","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习Java多线程所做的笔记，包括阻塞队列、AQS原理、并发工具类等。","abbrlink":"6ab5c4a5","date":"2021-06-07T16:00:00.000Z","_content":"\n# 阻塞队列\n\n## 概述\n\n### 简介\n\n阻塞队列是线程池的重要组成部分\n\n如果队列为空，则取数据会一直阻塞；如果队列满了，则插入数据会一直阻塞。其实体现了生产者消费者模式\n\n阻塞队列是具有阻塞功能的队列，通常阻塞队列的一端给生产者放数据用，另一端给消费者拿数据用。阻塞队列是线程安全的，生产者消费者都可以是多线程的。\n\n![image-20210606153219428](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153219428.png)\n\n### 继承体系图\n\n![image-20210606153040648](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153040648.png)\n\n## 常用方法\n\n### 抛出异常方法\n\n```java\nBlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3); // 该队列最大为3\nSystem.out.println(blockingQueue.add(\"a\"));\nSystem.out.println(blockingQueue.add(\"b\"));\nSystem.out.println(blockingQueue.add(\"c\"));\n//抛出异常:java.lang.IllegalStateException: Queue full\nSystem.out.println(blockingQueue.add(\"x\"));\n```\n\n### 返回特殊值方法\n\n```java\nBlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);\nSystem.out.println(blockingQueue.offer(\"a\"));\nSystem.out.println(blockingQueue.offer(\"b\"));\nSystem.out.println(blockingQueue.offer(\"c\"));\nSystem.out.println(blockingQueue.offer(\"d\")); // false\n```\n\n### 阻塞方法\n\n+ take()方法：获取并移除队列的头节点，一旦执行take的时候，队列里无数据，则阻塞，直到队列里有数据\n+ put()方法：插入数据。如果队列已满，就无法插入，即阻塞，直到队列里有了空闲空间\n\n```java\nBlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);\nblockingQueue.put(\"a\");\nblockingQueue.put(\"b\");\nblockingQueue.put(\"c\");\n//blockingQueue.put(\"d\"); //队列满了，该线程会等待\nblockingQueue.take();\nblockingQueue.take();\nblockingQueue.take();\n//不消费完线程，就阻塞掉\nblockingQueue.take();\n```\n\n### 超时方法\n\n```java\nBlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);\nSystem.out.println(blockingQueue.offer(\"a\"， 2L， TimeUnit.SECONDS));\nSystem.out.println(blockingQueue.offer(\"a\"， 2L， TimeUnit.SECONDS));\nSystem.out.println(blockingQueue.offer(\"a\"， 2L， TimeUnit.SECONDS));\n//只阻塞2s，就会返回false\nSystem.out.println(blockingQueue.offer(\"a\"， 2L， TimeUnit.SECONDS));\n```\n\n## 常见类\n\n### ArrayBlockingQueue\n\n- 有界阻塞队列，创建时需要指定容量\n\n```java\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length)\n            notFull.await();\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n**公平性**\n\n默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以 按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程 是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的 线程最后才访问队列。为了保证公平性，通常会降低吞吐量。\n\n```java\nArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000, true); // 公平\n```\n\n访问者的公平性是使用可重入锁实现的\n\n```java\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n     if (capacity <= 0) throw new IllegalArgumentException();\n     this.items = new Object[capacity];\n     lock = new ReentrantLock(fair);\n     notEmpty = lock.newCondition();\n     notFull = lock.newCondition();\n}\n```\n\n\n\n### LinkedBlockingQueue\n\nLinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度 为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。\n\n### SynchronousQueue\n\nSynchronousQueue 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。\n\n 它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用构造方法可以创建公平性访问的 SynchronousQueue，如果设置为 true，则等待的线程会采用 先进先出的顺序访问队列。 \n\nSynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递 给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。\n\n+ 容量为0，不需要存储元素，没有头节点，也就没有了peek()方法\n+ 直接传递的并发数据结构\n+ 是线程池Executors.newCachedThreadPool()使用的阻塞队列\n\n```java\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.SynchronousQueue;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main{\n    public static void main(String[] args) {\n        //同步队列不存储，只能生产一个就消费一个\n        BlockingQueue<String> blockingQueue = new SynchronousQueue<>();\n        new Thread(() -> {\n            try {\n                System.out.println(Thread.currentThread().getName()+\" put\");\n                blockingQueue.put(\"1\");\n                System.out.println(Thread.currentThread().getName()+\" put\");\n                blockingQueue.put(\"2\");\n                System.out.println(Thread.currentThread().getName()+\" put\");\n                blockingQueue.put(\"3\");\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }，\"t1\").start();\n        new Thread(()->{\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            try {\n                System.out.println(blockingQueue.take());\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }，\"t2\").start();\n    }\n}\n```\n\n### PriorityBlockingQueue\n\nPriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采取自然 顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是 不能保证同优先级元素的顺序。\n\n## 实现\n\n使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞 住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。\n\n其实是使用了Condition实现\n\n当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park(this)来实现。\n\n```java\nprivate final Condition notFull;\nprivate final Condition notEmpty;\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n     notEmpty = lock.newCondition();\n     notFull = lock.newCondition();\n}\n\npublic void put(E e) throws InterruptedException {\n     checkNotNull(e);\n     final ReentrantLock lock = this.lock;\n     lock.lockInterruptibly();\n     try {\n         while (count == items.length) notFull.await();\n         insert(e);\n     } finally {\n     \tlock.unlock();\n     }\n}\npublic E take() throws InterruptedException {\n     final ReentrantLock lock = this.lock;\n     lock.lockInterruptibly();\n     try {\n     \twhile (count == 0) notEmpty.await();\n     \treturn extract();\n     } finally {\n     \tlock.unlock();\n     }\n}\nprivate void insert(E x) {\n     items[putIndex] = x;\n     putIndex = inc(putIndex);\n     ++count;\n     notEmpty.signal();\n}\n\npublic final void await() throws InterruptedException {\n     if (Thread.interrupted()) throw new InterruptedException();\n     Node node = addConditionWaiter();\n     int savedState = fullyRelease(node);\n     int interruptMode = 0;\n     while (!isOnSyncQueue(node)) {\n         LockSupport.park(this);\n         if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break;\n     }\n     if (acquireQueued(node, savedState) && interruptMode != THROW_IE) \n\t\t interruptMode = REINTERRUPT;\n     if (node.nextWaiter != null) // clean up if cancelled\n     \t unlinkCancelledWaiters();\n     if (interruptMode != 0) reportInterruptAfterWait(interruptMode);\n}\n```\n\n\n\n# LockSupport\n\n当需要阻塞或唤醒一个线程的时候，都会使用 LockSupport 工具类来完 成相应工作。LockSupport 定义了一组的公共静态方法，这些方法提供了最基本的线程阻 塞和唤醒功能，而 LockSupport 也成为构建同步组件的基础工具。\n\nLockSupport 定义了一组以 park 开头的方法用来阻塞当前线程，以及 unpark(Thread thread) 方法来唤醒一个被阻塞的线程。\n\n![image-20210608091632079](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608091632079.png)\n\n# AQS\n\n## 概述\n\n抽象的队列同步器\n\n是用来构建锁或者其他同步器组件的重量级基础框架及整个JUC体系的基石。通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类型变量表示持有锁的状态\n\n基本上CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock、CyclicBarrier都和AQS有关\n\n如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。\n\n**AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。**\n\n用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。\n\n**注意：AQS是自旋锁：**在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功\n\n![image-20210607214750830](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210607214750830.png)\n\nAQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：\ngetState();setState();compareAndSetState();\n\nAQS 定义了两种资源共享方式：\n1.**Exclusive**：独占，只有一个线程能执行，如ReentrantLock\n2.**Share**：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier\n\n不同的自定义的同步器争用共享资源的方式也不同。\n\n\n\n`AQS`即`AbstractQueuedSynchronizer`的缩写，这个是个内部实现了两个队列的抽象类，分别是**同步队列**和**条件队列**。其中**同步队列**是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而**条件队列**是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，`AQS`所做的就是管理这两个队列里面线程之间的**等待状态-唤醒**的工作。\n 在同步队列中，还存在`2`中模式，分别是**独占模式**和**共享模式**，这两种模式的区别就在于`AQS`在唤醒线程节点的时候是不是传递唤醒，这两种模式分别对应**独占锁**和**共享锁**。\n `AQS`是一个抽象类，所以不能直接实例化，当我们需要实现一个自定义锁的时候可以去继承`AQS`然后重写**获取锁的方式**和**释放锁的方式**还有**管理state**，而`ReentrantLock`就是通过重写了`AQS`的`tryAcquire`和`tryRelease`方法实现的`lock`和`unlock`。\n\n\n\n**应用**\n\n```java\n// 实现一个非独占锁，当有线程调用await时陷入阻塞，只有某个线程调用了signal时才全部放行\npublic class MyLock {\n    private final Sync sync = new Sync();\n\n    private static final class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected int tryAcquireShared(int arg) {\n            return getState() == 1 ? 1 : -1; //  state初始化为0，代表会阻塞，为1时代表线程放行\n        }\n\n        @Override\n        protected boolean tryReleaseShared(int arg) {\n            setState(1); // 后面获取锁的线程不需要阻塞了\n            return true; // 把之前等待的线程唤醒\n        }\n    }\n\n    public void await() {\n        sync.acquireShared(0);\n    }\n\n    public void signal() {\n        sync.releaseShared(0);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        MyLock myLock = new MyLock();\n        for (int i = 0; i < 10; i++) {\n            new Thread(() -> {\n                System.out.println(\"尝试获取锁\");\n                myLock.await();\n                System.out.println(\"获取成功，开始执行！\");\n            }).start();\n        }\n        TimeUnit.SECONDS.sleep(3);\n        myLock.signal();\n    }\n}\n```\n\n同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：\n\n1. 使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）\n2. 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\n\n自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的时候主要实现下面几种方法：\n\n+ isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。\n+ tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n+ tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n+ tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n+ tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n**ReentrantLock**：（可重入独占式锁）：state初始化为0，表示未锁定状态，A线程lock()时，会调用tryAcquire()独占锁并将state+1.之后其他线程再想tryAcquire的时候就会失败，直到A线程unlock（）到state=0为止，其他线程才有机会获取该锁。A释放锁之前，自己也是可以重复获取此锁（state累加），这就是可重入的概念。\n注意：获取多少次锁就要释放多少次锁，保证state是能回到零态的。\n\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时**实现独占和共享两种方式，如ReentrantReadWriteLock。**\n　在acquire() acquireShared()两种方式下，线程在等待队列中都是忽略中断的，**acquireInterruptibly()/acquireSharedInterruptibly()是支持响应中断**的。\n\n![image-20210608090003077](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090003077.png)\n\n## state\n\n```java\nprivate volatile int state;\n```\n\n会被并发地修改，所以所有修改state的方法都需要保证线程安全\n\n```java\nprotected final boolean compareAndSetState(int expect, int update) {\n        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n    }\n```\n\n在ReentrantLock中，state代表锁的占有情况，包括**可重入计数**\n\n当state为0时，标识该Lock不被任何线程所占有\n\n AbstractQueuedSynchronizer维护了一个volatile int类型的变量，用户表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。\n\n## FIFO队列\n\n- 这个队列用来存放等待的线程，AQS就是一个排队管理器，当多个线程争用同一把锁时，必须有一个排队机制把那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁\n- AQS会维护一个等待的线程队列，把线程都放在这个队列里\n- head是拿到锁的线程：\n\n![image-20210607145130742](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210607145130742.png)\n\n同步器依赖内部的同步队列（一个 FIFO 双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点 （Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。\n\n![image-20210608090235159](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090235159.png)\n\n同步器提供了一个基于 CAS 的设置尾节点的方法： compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当 前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。\n\n同步器将节点加入到同步队列的过程：\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090428446.png\" alt=\"image-20210608090428446\" style=\"zoom:67%;\" />\n\n同步队列遵循 FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步 状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证，它只 需要将首节点设置成为原首节点的后继节点并断开原首节点的 next 引用即可。\n\n## 重要方法\n\n### 独占式\n\n获取操作会依赖state变量，经常会阻塞（比如获取不到锁的时候）\n\n#### acquire(int)\n\n前驱节点为头节点且能够获取同步状态的判断条件和线程进入等待状 态是获取同步状态的自旋过程。当同步状态获取成功之后，当前线程从 acquire(int arg)方 法返回，如果对于锁这种并发组件而言，代表着当前线程获取了锁。\n\n![image-20210608091041981](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608091041981.png)\n\nacquire是一种以独占方式获取资源，如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。该方法是独占模式下线程获取共享资源的顶层入口。获取到资源后，线程就可以去执行其临界区代码了\n\n通过调用同步器的 acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也 就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程 不会从同步队列中移出\n\n首先调用自定义同步器实现的 tryAcquire(int arg)方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点 （独占式 Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过 addWaiter(Node node) 方法将该节点加入到同步队列的尾部，最后调用 acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如 果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞 线程被中断来实现。\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\nacquire方法是一种互斥模式，且忽略中断。该方法至少执行一次`tryAcquire(int)`方法，如果tryAcquire(int)方法返回true，则acquire直接返回，否则当前线程需要进入队列进行排队。函数流程如下：\n\n- tryAcquire()尝试直接去获取资源，如果成功则直接返回；\n- addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；\n- acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。\n- 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。\n\n##### tryAcquire(int)\n\ntryAcquire尝试以独占的方式获取资源，如果获取成功，则直接返回true，否则直接返回false。该方法可以用于实现Lock中的tryLock()方法。该方法的默认实现是抛出`UnsupportedOperationException`，具体实现由自定义的扩展了AQS的同步类来实现。AQS在这里只负责定义了一个公共的方法框架。\n\n这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。\n\n```java\nprotected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n```\n\n##### addWaiter(Node)\n\n该方法用于将当前线程根据不同的模式（`Node.EXCLUSIVE`互斥模式、`Node.SHARED`共享模式）加入到等待队列的队尾，并返回当前线程所在的结点。如果队列不为空，则以通过`compareAndSetTail`方法以CAS的方式将当前线程节点加入到等待队列的末尾。\n\n如果CAS失败或者队列为空，则通过enq(node)方法初始化一个等待队列，并返回当前节点。\n\n```java\n\tprivate Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        Node pred = tail;\n        if (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\n                pred.next = node;\n                return node;\n            }\n        }\n        enq(node);\n        return node;\n    }\n```\n\n##### enq(node)\n\n`enq(node)`用于将当前节点插入等待队列，如果队列为空，则初始化当前队列。整个过程以CAS自旋的方式进行，直到成功加入队尾为止。\n\n```java\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            if (t == null) { \n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else {\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n\n##### acquireQueued(Node, int)\n\n `acquireQueued()`用于队列中的线程自旋地以独占且不可中断的方式获取同步状态（acquire），直到拿到锁之后再返回。该方法的实现分成两部分：如果当前节点前一个节点已经成为头结点，尝试获取锁（tryAcquire）成功，然后返回；否则检查当前节点是否应该被park，然后将该线程park并且检查当前线程是否被可以被中断。\n\n- 调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；\n- 没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；\n- acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。\n- 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。\n\n\n\n在 acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中尝试获取同 步状态，而只有前驱节点是头节点才能够尝试获取同步状态\n\n第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之 后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头 节点。 第二，维护同步队列的 FIFO 原则。该方法中，节点自旋获取同步状态的行为\n\n由于非首节点线程前驱节点出队或者被中断而从等待状态返回，随后检 查自己的前驱是否是头节点，如果是则尝试获取同步状态。可以看到节点和节点之 间在循环检查的过程中基本不相互通信，而是简单地判断自己的前驱是否为头节 点，这样就使得节点的释放规则符合 FIFO，并且也便于对过早通知的处理（过早 通知是指前驱节点不是头节点的线程由于中断而被唤醒）。\n\n![image-20210608090945214](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090945214.png)\n\n```java\n    final boolean acquireQueued(final Node node, int arg) {\n        //标记是否成功拿到资源，默认false\n        boolean failed = true;\n        try {\n            boolean interrupted = false; // 标记等待过程中是否被中断过\n            for (;;) {\n                // 如果前一个节点p是头节点，那么又尝试获取锁，获取到了则返回interrupted\n                final Node p = node.predecessor();\n                if (p == head && tryAcquire(arg)) {\n                    setHead(node);\n                    p.next = null; // help GC\n                    failed = false;\n                    return interrupted;\n                }\n                if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n\n##### shouldParkAfterFailedAcquire(Node, Node)\n\n shouldParkAfterFailedAcquire方法通过对当前节点的前一个节点的状态进行判断，对当前节点做出不同的操作\n\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n            return true;\n        if (ws > 0) {\n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n```\n\n##### parkAndCheckInterrupt()\n\n该方法让线程去休息，真正进入等待状态。park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n        LockSupport.park(this);\n        return Thread.interrupted();\n    }\n```\n\n#### release(int)\n\n该方法执行时，会唤醒头节点的后继节点线程，unparkSuccessor(Node node)方法使 用 LockSupport（在后面的章节会专门介绍）来唤醒处于等待状态的线程。 分析了独占式同步状态获取和释放过程后，适当做个总结：在获取同步状态时，同 步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自 旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释 放同步状态时，同步器调用 tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后 继节点。\n\n\n\n  `release(int)`方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。\n\n与acquire()方法中的tryAcquire()类似，tryRelease()方法也是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。\n\n`unparkSuccessor(Node)`方法用于唤醒等待队列中下一个线程。这里要注意的是，下一个线程并不一定是当前节点的next节点，而是下一个可以用来唤醒的线程，如果这个节点存在，调用`unpark()`方法唤醒。\n  总之，release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。\n\n```java\n public final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n    \n    protected boolean tryRelease(int arg) {\n        throw new UnsupportedOperationException();\n    }\n    \n    private void unparkSuccessor(Node node) {\n        /*\n         * If status is negative (i.e., possibly needing signal) try\n         * to clear in anticipation of signalling.  It is OK if this\n         * fails or if status is changed by waiting thread.\n         */\n        int ws = node.waitStatus;\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n\n        /*\n         * Thread to unpark is held in successor, which is normally\n         * just the next node.  But if cancelled or apparently null,\n         * traverse backwards from tail to find the actual\n         * non-cancelled successor.\n         */\n        Node s = node.next;\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);\n    }\n```\n\n### 共享式\n\n共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同 步状态。以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该 文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而 读操作可以是共享式访问，两种不同的访问模式在同一时刻对文件或资源的访问情况\n\n\n\n#### acquireShared(int)\n\n- tryAcquireShared()尝试获取资源，成功则直接返回；\n- 失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。\n\n\n\n`acquireShared(int)`方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。\n\n```java\npublic final void acquireShared(int arg) {\n        if (tryAcquireShared(arg) < 0)\n            doAcquireShared(arg);\n    }\n```\n\n##### doAcquireShared(int)\n\n  将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。\n\n```java\nprivate void doAcquireShared(int arg) {\n        final Node node = addWaiter(Node.SHARED);\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head) {\n                    int r = tryAcquireShared(arg);\n                    if (r >= 0) {\n                        setHeadAndPropagate(node, r);\n                        p.next = null; // help GC\n                        if (interrupted)\n                            selfInterrupt();\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n\n跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。\n\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n        Node h = head; // Record old head for check below\n        setHead(node);\n        /*\n         * Try to signal next queued node if:\n         *   Propagation was indicated by caller,\n         *     or was recorded (as h.waitStatus either before\n         *     or after setHead) by a previous operation\n         *     (note: this uses sign-check of waitStatus because\n         *      PROPAGATE status may transition to SIGNAL.)\n         * and\n         *   The next node is waiting in shared mode,\n         *     or we don't know, because it appears null\n         *\n         * The conservatism in both of these checks may cause\n         * unnecessary wake-ups, but only when there are multiple\n         * racing acquires/releases, so most need signals now or soon\n         * anyway.\n         */\n        if (propagate > 0 || h == null || h.waitStatus < 0 ||\n            (h = head) == null || h.waitStatus < 0) {\n            Node s = node.next;\n            if (s == null || s.isShared())\n                doReleaseShared();\n        }\n    }\n```\n\n此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！\n\n#### releaseShared(int)\n\n  `releaseShared(int)`方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。\n\n```java\npublic final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n\n此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。\n\n```java\nprivate void doReleaseShared() {\n        /*\n         * Ensure that a release propagates, even if there are other\n         * in-progress acquires/releases.  This proceeds in the usual\n         * way of trying to unparkSuccessor of head if it needs\n         * signal. But if it does not, status is set to PROPAGATE to\n         * ensure that upon release, propagation continues.\n         * Additionally, we must loop in case a new node is added\n         * while we are doing this. Also, unlike other uses of\n         * unparkSuccessor, we need to know if CAS to reset status\n         * fails, if so rechecking.\n         */\n        for (;;) {\n            Node h = head;\n            if (h != null && h != tail) {\n                int ws = h.waitStatus;\n                if (ws == Node.SIGNAL) {\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h);\n                }\n                else if (ws == 0 &&\n                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            if (h == head)                   // loop if head changed\n                break;\n        }\n    }\n```\n\n\n\n# 并发工具类\n\n## CountDownLatch\n\n+ 线程调用`countDown`方法会将计数器减一(调用`countDown`不会阻塞)\n+ 当一个或多个线程调用`await`方法时，调用线程会被阻塞\n+ 当计数器为零时，因为调用了`await`方法而被阻塞的线程会被唤醒，继续执行\n+ CountDownLatch不能重用\n\n用法一：一个线程等待多个线程都执行完毕，再继续自己的工作\n\n```java\n//例如启动程序，对外发布服务时，应该所有的都检查完毕（检查数据有没有完毕等前置流程）才进入下一个环节\n//主线程等待所有线程都执行完毕才结束\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch countDownLatch = new CountDownLatch(6);\n    for (int i = 0; i < 6; i++) {\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \" 离开\");\n            countDownLatch.countDown();\n        }， String.valueOf(i)).start();\n    }\n    countDownLatch.await(); // 必须要减到0才能解除\n    System.out.println(\"全部结束咯\");\n}\n```\n\n用法二：多个线程等待某一个线程的信号，同时开始执行。\n\n```java\n// 例如进行压测，创建很多线程应该先等待，再一个统一的时间再过去\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch countDownLatch = new CountDownLatch(1);\n    ExecutorService executorService = Executors.newFixedThreadPool(5);\n    for (int i = 0; i < 5; i++) {\n        int finalI = i;\n        executorService.submit(() -> {\n            System.out.println(finalI + \"准备完毕\");\n            try {\n                countDownLatch.await();\n                System.out.println(finalI + \"开始跑步\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n    TimeUnit.SECONDS.sleep(5);         // 检查场地等\n    System.out.println(\"比赛开始！\");\n    countDownLatch.countDown();\n}\n```\n\n## Semaphore\n\n+ 可以用来限制或管理数量有限资源的使用情况。实际上就相当于PV操作\n+ 当一个线程调用acquire（获取），要么成功获得信号量（信号量-1），要么阻塞到有线程释放信号量\n+ release（释放），实际会将信号量的值+1，然后唤醒等待的线程\n+ 可以选择公平或者非公平实现：`public Semaphore(int permits, boolean fair)`\n\n```java\nSemaphore semaphore = new Semaphore(3);\nfor (int i = 0; i < 6; i++) {\n    new Thread(()->{\n        try {\n            semaphore.acquire();\n            System.out.println(Thread.currentThread().getName()+\" 抢到车位\");\n            TimeUnit.SECONDS.sleep(2);\n            System.out.println(Thread.currentThread().getName()+\" 离开车位\");\n        }\n        catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        finally {\n            semaphore.release();\n        }\n    }，String.valueOf(i)).start();\n}\n```\n\n## CyclicBarrier\n\n+ 可循环(`Cyclic`)使用的屏障(`Barrier`)\n+ 让一组线程到达一个屏障(同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续干活\n+ 线程进入屏障是通过`CyclicBarrier`的`await()`方法\n\n```java\npublic static void main(String[] args) {\n    CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {\n        System.out.println(\"大威天龙!\");\n    });\n    for (int i = 0; i < 7; i++) {\n        int finalI = i+1;\n        new Thread(()->{\n            System.out.println(Thread.currentThread().getName()+ \" 收集龙珠\"+finalI );\n            try {\n                cyclicBarrier.await();\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        },\"thread\"+String.valueOf(i)).start();\n    }\n}\n```\n\n","source":"_posts/Java语言/Java多线程/4.AQS与应用.md","raw":"---\ntitle: AQS相关\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 学习Java多线程所做的笔记，包括阻塞队列、AQS原理、并发工具类等。\ncategories: Java多线程\ntags:\n  - 阻塞队列\n  - 并发\n  - AQS\nabbrlink: 6ab5c4a5\ndate: 2021-06-08 00:00:00\n---\n\n# 阻塞队列\n\n## 概述\n\n### 简介\n\n阻塞队列是线程池的重要组成部分\n\n如果队列为空，则取数据会一直阻塞；如果队列满了，则插入数据会一直阻塞。其实体现了生产者消费者模式\n\n阻塞队列是具有阻塞功能的队列，通常阻塞队列的一端给生产者放数据用，另一端给消费者拿数据用。阻塞队列是线程安全的，生产者消费者都可以是多线程的。\n\n![image-20210606153219428](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153219428.png)\n\n### 继承体系图\n\n![image-20210606153040648](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153040648.png)\n\n## 常用方法\n\n### 抛出异常方法\n\n```java\nBlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3); // 该队列最大为3\nSystem.out.println(blockingQueue.add(\"a\"));\nSystem.out.println(blockingQueue.add(\"b\"));\nSystem.out.println(blockingQueue.add(\"c\"));\n//抛出异常:java.lang.IllegalStateException: Queue full\nSystem.out.println(blockingQueue.add(\"x\"));\n```\n\n### 返回特殊值方法\n\n```java\nBlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);\nSystem.out.println(blockingQueue.offer(\"a\"));\nSystem.out.println(blockingQueue.offer(\"b\"));\nSystem.out.println(blockingQueue.offer(\"c\"));\nSystem.out.println(blockingQueue.offer(\"d\")); // false\n```\n\n### 阻塞方法\n\n+ take()方法：获取并移除队列的头节点，一旦执行take的时候，队列里无数据，则阻塞，直到队列里有数据\n+ put()方法：插入数据。如果队列已满，就无法插入，即阻塞，直到队列里有了空闲空间\n\n```java\nBlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);\nblockingQueue.put(\"a\");\nblockingQueue.put(\"b\");\nblockingQueue.put(\"c\");\n//blockingQueue.put(\"d\"); //队列满了，该线程会等待\nblockingQueue.take();\nblockingQueue.take();\nblockingQueue.take();\n//不消费完线程，就阻塞掉\nblockingQueue.take();\n```\n\n### 超时方法\n\n```java\nBlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);\nSystem.out.println(blockingQueue.offer(\"a\"， 2L， TimeUnit.SECONDS));\nSystem.out.println(blockingQueue.offer(\"a\"， 2L， TimeUnit.SECONDS));\nSystem.out.println(blockingQueue.offer(\"a\"， 2L， TimeUnit.SECONDS));\n//只阻塞2s，就会返回false\nSystem.out.println(blockingQueue.offer(\"a\"， 2L， TimeUnit.SECONDS));\n```\n\n## 常见类\n\n### ArrayBlockingQueue\n\n- 有界阻塞队列，创建时需要指定容量\n\n```java\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length)\n            notFull.await();\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n**公平性**\n\n默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以 按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程 是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的 线程最后才访问队列。为了保证公平性，通常会降低吞吐量。\n\n```java\nArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000, true); // 公平\n```\n\n访问者的公平性是使用可重入锁实现的\n\n```java\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n     if (capacity <= 0) throw new IllegalArgumentException();\n     this.items = new Object[capacity];\n     lock = new ReentrantLock(fair);\n     notEmpty = lock.newCondition();\n     notFull = lock.newCondition();\n}\n```\n\n\n\n### LinkedBlockingQueue\n\nLinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度 为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。\n\n### SynchronousQueue\n\nSynchronousQueue 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。\n\n 它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用构造方法可以创建公平性访问的 SynchronousQueue，如果设置为 true，则等待的线程会采用 先进先出的顺序访问队列。 \n\nSynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递 给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。\n\n+ 容量为0，不需要存储元素，没有头节点，也就没有了peek()方法\n+ 直接传递的并发数据结构\n+ 是线程池Executors.newCachedThreadPool()使用的阻塞队列\n\n```java\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.SynchronousQueue;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main{\n    public static void main(String[] args) {\n        //同步队列不存储，只能生产一个就消费一个\n        BlockingQueue<String> blockingQueue = new SynchronousQueue<>();\n        new Thread(() -> {\n            try {\n                System.out.println(Thread.currentThread().getName()+\" put\");\n                blockingQueue.put(\"1\");\n                System.out.println(Thread.currentThread().getName()+\" put\");\n                blockingQueue.put(\"2\");\n                System.out.println(Thread.currentThread().getName()+\" put\");\n                blockingQueue.put(\"3\");\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }，\"t1\").start();\n        new Thread(()->{\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            try {\n                System.out.println(blockingQueue.take());\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }，\"t2\").start();\n    }\n}\n```\n\n### PriorityBlockingQueue\n\nPriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采取自然 顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是 不能保证同优先级元素的顺序。\n\n## 实现\n\n使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞 住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。\n\n其实是使用了Condition实现\n\n当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park(this)来实现。\n\n```java\nprivate final Condition notFull;\nprivate final Condition notEmpty;\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n     notEmpty = lock.newCondition();\n     notFull = lock.newCondition();\n}\n\npublic void put(E e) throws InterruptedException {\n     checkNotNull(e);\n     final ReentrantLock lock = this.lock;\n     lock.lockInterruptibly();\n     try {\n         while (count == items.length) notFull.await();\n         insert(e);\n     } finally {\n     \tlock.unlock();\n     }\n}\npublic E take() throws InterruptedException {\n     final ReentrantLock lock = this.lock;\n     lock.lockInterruptibly();\n     try {\n     \twhile (count == 0) notEmpty.await();\n     \treturn extract();\n     } finally {\n     \tlock.unlock();\n     }\n}\nprivate void insert(E x) {\n     items[putIndex] = x;\n     putIndex = inc(putIndex);\n     ++count;\n     notEmpty.signal();\n}\n\npublic final void await() throws InterruptedException {\n     if (Thread.interrupted()) throw new InterruptedException();\n     Node node = addConditionWaiter();\n     int savedState = fullyRelease(node);\n     int interruptMode = 0;\n     while (!isOnSyncQueue(node)) {\n         LockSupport.park(this);\n         if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break;\n     }\n     if (acquireQueued(node, savedState) && interruptMode != THROW_IE) \n\t\t interruptMode = REINTERRUPT;\n     if (node.nextWaiter != null) // clean up if cancelled\n     \t unlinkCancelledWaiters();\n     if (interruptMode != 0) reportInterruptAfterWait(interruptMode);\n}\n```\n\n\n\n# LockSupport\n\n当需要阻塞或唤醒一个线程的时候，都会使用 LockSupport 工具类来完 成相应工作。LockSupport 定义了一组的公共静态方法，这些方法提供了最基本的线程阻 塞和唤醒功能，而 LockSupport 也成为构建同步组件的基础工具。\n\nLockSupport 定义了一组以 park 开头的方法用来阻塞当前线程，以及 unpark(Thread thread) 方法来唤醒一个被阻塞的线程。\n\n![image-20210608091632079](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608091632079.png)\n\n# AQS\n\n## 概述\n\n抽象的队列同步器\n\n是用来构建锁或者其他同步器组件的重量级基础框架及整个JUC体系的基石。通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类型变量表示持有锁的状态\n\n基本上CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock、CyclicBarrier都和AQS有关\n\n如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。\n\n**AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。**\n\n用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。\n\n**注意：AQS是自旋锁：**在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功\n\n![image-20210607214750830](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210607214750830.png)\n\nAQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：\ngetState();setState();compareAndSetState();\n\nAQS 定义了两种资源共享方式：\n1.**Exclusive**：独占，只有一个线程能执行，如ReentrantLock\n2.**Share**：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier\n\n不同的自定义的同步器争用共享资源的方式也不同。\n\n\n\n`AQS`即`AbstractQueuedSynchronizer`的缩写，这个是个内部实现了两个队列的抽象类，分别是**同步队列**和**条件队列**。其中**同步队列**是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而**条件队列**是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，`AQS`所做的就是管理这两个队列里面线程之间的**等待状态-唤醒**的工作。\n 在同步队列中，还存在`2`中模式，分别是**独占模式**和**共享模式**，这两种模式的区别就在于`AQS`在唤醒线程节点的时候是不是传递唤醒，这两种模式分别对应**独占锁**和**共享锁**。\n `AQS`是一个抽象类，所以不能直接实例化，当我们需要实现一个自定义锁的时候可以去继承`AQS`然后重写**获取锁的方式**和**释放锁的方式**还有**管理state**，而`ReentrantLock`就是通过重写了`AQS`的`tryAcquire`和`tryRelease`方法实现的`lock`和`unlock`。\n\n\n\n**应用**\n\n```java\n// 实现一个非独占锁，当有线程调用await时陷入阻塞，只有某个线程调用了signal时才全部放行\npublic class MyLock {\n    private final Sync sync = new Sync();\n\n    private static final class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected int tryAcquireShared(int arg) {\n            return getState() == 1 ? 1 : -1; //  state初始化为0，代表会阻塞，为1时代表线程放行\n        }\n\n        @Override\n        protected boolean tryReleaseShared(int arg) {\n            setState(1); // 后面获取锁的线程不需要阻塞了\n            return true; // 把之前等待的线程唤醒\n        }\n    }\n\n    public void await() {\n        sync.acquireShared(0);\n    }\n\n    public void signal() {\n        sync.releaseShared(0);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        MyLock myLock = new MyLock();\n        for (int i = 0; i < 10; i++) {\n            new Thread(() -> {\n                System.out.println(\"尝试获取锁\");\n                myLock.await();\n                System.out.println(\"获取成功，开始执行！\");\n            }).start();\n        }\n        TimeUnit.SECONDS.sleep(3);\n        myLock.signal();\n    }\n}\n```\n\n同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：\n\n1. 使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）\n2. 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\n\n自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的时候主要实现下面几种方法：\n\n+ isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。\n+ tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n+ tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n+ tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n+ tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n**ReentrantLock**：（可重入独占式锁）：state初始化为0，表示未锁定状态，A线程lock()时，会调用tryAcquire()独占锁并将state+1.之后其他线程再想tryAcquire的时候就会失败，直到A线程unlock（）到state=0为止，其他线程才有机会获取该锁。A释放锁之前，自己也是可以重复获取此锁（state累加），这就是可重入的概念。\n注意：获取多少次锁就要释放多少次锁，保证state是能回到零态的。\n\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时**实现独占和共享两种方式，如ReentrantReadWriteLock。**\n　在acquire() acquireShared()两种方式下，线程在等待队列中都是忽略中断的，**acquireInterruptibly()/acquireSharedInterruptibly()是支持响应中断**的。\n\n![image-20210608090003077](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090003077.png)\n\n## state\n\n```java\nprivate volatile int state;\n```\n\n会被并发地修改，所以所有修改state的方法都需要保证线程安全\n\n```java\nprotected final boolean compareAndSetState(int expect, int update) {\n        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n    }\n```\n\n在ReentrantLock中，state代表锁的占有情况，包括**可重入计数**\n\n当state为0时，标识该Lock不被任何线程所占有\n\n AbstractQueuedSynchronizer维护了一个volatile int类型的变量，用户表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。\n\n## FIFO队列\n\n- 这个队列用来存放等待的线程，AQS就是一个排队管理器，当多个线程争用同一把锁时，必须有一个排队机制把那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁\n- AQS会维护一个等待的线程队列，把线程都放在这个队列里\n- head是拿到锁的线程：\n\n![image-20210607145130742](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210607145130742.png)\n\n同步器依赖内部的同步队列（一个 FIFO 双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点 （Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。\n\n![image-20210608090235159](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090235159.png)\n\n同步器提供了一个基于 CAS 的设置尾节点的方法： compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当 前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。\n\n同步器将节点加入到同步队列的过程：\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090428446.png\" alt=\"image-20210608090428446\" style=\"zoom:67%;\" />\n\n同步队列遵循 FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步 状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证，它只 需要将首节点设置成为原首节点的后继节点并断开原首节点的 next 引用即可。\n\n## 重要方法\n\n### 独占式\n\n获取操作会依赖state变量，经常会阻塞（比如获取不到锁的时候）\n\n#### acquire(int)\n\n前驱节点为头节点且能够获取同步状态的判断条件和线程进入等待状 态是获取同步状态的自旋过程。当同步状态获取成功之后，当前线程从 acquire(int arg)方 法返回，如果对于锁这种并发组件而言，代表着当前线程获取了锁。\n\n![image-20210608091041981](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608091041981.png)\n\nacquire是一种以独占方式获取资源，如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。该方法是独占模式下线程获取共享资源的顶层入口。获取到资源后，线程就可以去执行其临界区代码了\n\n通过调用同步器的 acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也 就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程 不会从同步队列中移出\n\n首先调用自定义同步器实现的 tryAcquire(int arg)方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点 （独占式 Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过 addWaiter(Node node) 方法将该节点加入到同步队列的尾部，最后调用 acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如 果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞 线程被中断来实现。\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\nacquire方法是一种互斥模式，且忽略中断。该方法至少执行一次`tryAcquire(int)`方法，如果tryAcquire(int)方法返回true，则acquire直接返回，否则当前线程需要进入队列进行排队。函数流程如下：\n\n- tryAcquire()尝试直接去获取资源，如果成功则直接返回；\n- addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；\n- acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。\n- 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。\n\n##### tryAcquire(int)\n\ntryAcquire尝试以独占的方式获取资源，如果获取成功，则直接返回true，否则直接返回false。该方法可以用于实现Lock中的tryLock()方法。该方法的默认实现是抛出`UnsupportedOperationException`，具体实现由自定义的扩展了AQS的同步类来实现。AQS在这里只负责定义了一个公共的方法框架。\n\n这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。\n\n```java\nprotected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n```\n\n##### addWaiter(Node)\n\n该方法用于将当前线程根据不同的模式（`Node.EXCLUSIVE`互斥模式、`Node.SHARED`共享模式）加入到等待队列的队尾，并返回当前线程所在的结点。如果队列不为空，则以通过`compareAndSetTail`方法以CAS的方式将当前线程节点加入到等待队列的末尾。\n\n如果CAS失败或者队列为空，则通过enq(node)方法初始化一个等待队列，并返回当前节点。\n\n```java\n\tprivate Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        Node pred = tail;\n        if (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\n                pred.next = node;\n                return node;\n            }\n        }\n        enq(node);\n        return node;\n    }\n```\n\n##### enq(node)\n\n`enq(node)`用于将当前节点插入等待队列，如果队列为空，则初始化当前队列。整个过程以CAS自旋的方式进行，直到成功加入队尾为止。\n\n```java\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            if (t == null) { \n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else {\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n\n##### acquireQueued(Node, int)\n\n `acquireQueued()`用于队列中的线程自旋地以独占且不可中断的方式获取同步状态（acquire），直到拿到锁之后再返回。该方法的实现分成两部分：如果当前节点前一个节点已经成为头结点，尝试获取锁（tryAcquire）成功，然后返回；否则检查当前节点是否应该被park，然后将该线程park并且检查当前线程是否被可以被中断。\n\n- 调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；\n- 没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；\n- acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。\n- 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。\n\n\n\n在 acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中尝试获取同 步状态，而只有前驱节点是头节点才能够尝试获取同步状态\n\n第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之 后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头 节点。 第二，维护同步队列的 FIFO 原则。该方法中，节点自旋获取同步状态的行为\n\n由于非首节点线程前驱节点出队或者被中断而从等待状态返回，随后检 查自己的前驱是否是头节点，如果是则尝试获取同步状态。可以看到节点和节点之 间在循环检查的过程中基本不相互通信，而是简单地判断自己的前驱是否为头节 点，这样就使得节点的释放规则符合 FIFO，并且也便于对过早通知的处理（过早 通知是指前驱节点不是头节点的线程由于中断而被唤醒）。\n\n![image-20210608090945214](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090945214.png)\n\n```java\n    final boolean acquireQueued(final Node node, int arg) {\n        //标记是否成功拿到资源，默认false\n        boolean failed = true;\n        try {\n            boolean interrupted = false; // 标记等待过程中是否被中断过\n            for (;;) {\n                // 如果前一个节点p是头节点，那么又尝试获取锁，获取到了则返回interrupted\n                final Node p = node.predecessor();\n                if (p == head && tryAcquire(arg)) {\n                    setHead(node);\n                    p.next = null; // help GC\n                    failed = false;\n                    return interrupted;\n                }\n                if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n\n##### shouldParkAfterFailedAcquire(Node, Node)\n\n shouldParkAfterFailedAcquire方法通过对当前节点的前一个节点的状态进行判断，对当前节点做出不同的操作\n\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n            return true;\n        if (ws > 0) {\n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n```\n\n##### parkAndCheckInterrupt()\n\n该方法让线程去休息，真正进入等待状态。park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n        LockSupport.park(this);\n        return Thread.interrupted();\n    }\n```\n\n#### release(int)\n\n该方法执行时，会唤醒头节点的后继节点线程，unparkSuccessor(Node node)方法使 用 LockSupport（在后面的章节会专门介绍）来唤醒处于等待状态的线程。 分析了独占式同步状态获取和释放过程后，适当做个总结：在获取同步状态时，同 步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自 旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释 放同步状态时，同步器调用 tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后 继节点。\n\n\n\n  `release(int)`方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。\n\n与acquire()方法中的tryAcquire()类似，tryRelease()方法也是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。\n\n`unparkSuccessor(Node)`方法用于唤醒等待队列中下一个线程。这里要注意的是，下一个线程并不一定是当前节点的next节点，而是下一个可以用来唤醒的线程，如果这个节点存在，调用`unpark()`方法唤醒。\n  总之，release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。\n\n```java\n public final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n    \n    protected boolean tryRelease(int arg) {\n        throw new UnsupportedOperationException();\n    }\n    \n    private void unparkSuccessor(Node node) {\n        /*\n         * If status is negative (i.e., possibly needing signal) try\n         * to clear in anticipation of signalling.  It is OK if this\n         * fails or if status is changed by waiting thread.\n         */\n        int ws = node.waitStatus;\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n\n        /*\n         * Thread to unpark is held in successor, which is normally\n         * just the next node.  But if cancelled or apparently null,\n         * traverse backwards from tail to find the actual\n         * non-cancelled successor.\n         */\n        Node s = node.next;\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);\n    }\n```\n\n### 共享式\n\n共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同 步状态。以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该 文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而 读操作可以是共享式访问，两种不同的访问模式在同一时刻对文件或资源的访问情况\n\n\n\n#### acquireShared(int)\n\n- tryAcquireShared()尝试获取资源，成功则直接返回；\n- 失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。\n\n\n\n`acquireShared(int)`方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。\n\n```java\npublic final void acquireShared(int arg) {\n        if (tryAcquireShared(arg) < 0)\n            doAcquireShared(arg);\n    }\n```\n\n##### doAcquireShared(int)\n\n  将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。\n\n```java\nprivate void doAcquireShared(int arg) {\n        final Node node = addWaiter(Node.SHARED);\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head) {\n                    int r = tryAcquireShared(arg);\n                    if (r >= 0) {\n                        setHeadAndPropagate(node, r);\n                        p.next = null; // help GC\n                        if (interrupted)\n                            selfInterrupt();\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n\n跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。\n\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n        Node h = head; // Record old head for check below\n        setHead(node);\n        /*\n         * Try to signal next queued node if:\n         *   Propagation was indicated by caller,\n         *     or was recorded (as h.waitStatus either before\n         *     or after setHead) by a previous operation\n         *     (note: this uses sign-check of waitStatus because\n         *      PROPAGATE status may transition to SIGNAL.)\n         * and\n         *   The next node is waiting in shared mode,\n         *     or we don't know, because it appears null\n         *\n         * The conservatism in both of these checks may cause\n         * unnecessary wake-ups, but only when there are multiple\n         * racing acquires/releases, so most need signals now or soon\n         * anyway.\n         */\n        if (propagate > 0 || h == null || h.waitStatus < 0 ||\n            (h = head) == null || h.waitStatus < 0) {\n            Node s = node.next;\n            if (s == null || s.isShared())\n                doReleaseShared();\n        }\n    }\n```\n\n此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！\n\n#### releaseShared(int)\n\n  `releaseShared(int)`方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。\n\n```java\npublic final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n\n此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。\n\n```java\nprivate void doReleaseShared() {\n        /*\n         * Ensure that a release propagates, even if there are other\n         * in-progress acquires/releases.  This proceeds in the usual\n         * way of trying to unparkSuccessor of head if it needs\n         * signal. But if it does not, status is set to PROPAGATE to\n         * ensure that upon release, propagation continues.\n         * Additionally, we must loop in case a new node is added\n         * while we are doing this. Also, unlike other uses of\n         * unparkSuccessor, we need to know if CAS to reset status\n         * fails, if so rechecking.\n         */\n        for (;;) {\n            Node h = head;\n            if (h != null && h != tail) {\n                int ws = h.waitStatus;\n                if (ws == Node.SIGNAL) {\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h);\n                }\n                else if (ws == 0 &&\n                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            if (h == head)                   // loop if head changed\n                break;\n        }\n    }\n```\n\n\n\n# 并发工具类\n\n## CountDownLatch\n\n+ 线程调用`countDown`方法会将计数器减一(调用`countDown`不会阻塞)\n+ 当一个或多个线程调用`await`方法时，调用线程会被阻塞\n+ 当计数器为零时，因为调用了`await`方法而被阻塞的线程会被唤醒，继续执行\n+ CountDownLatch不能重用\n\n用法一：一个线程等待多个线程都执行完毕，再继续自己的工作\n\n```java\n//例如启动程序，对外发布服务时，应该所有的都检查完毕（检查数据有没有完毕等前置流程）才进入下一个环节\n//主线程等待所有线程都执行完毕才结束\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch countDownLatch = new CountDownLatch(6);\n    for (int i = 0; i < 6; i++) {\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \" 离开\");\n            countDownLatch.countDown();\n        }， String.valueOf(i)).start();\n    }\n    countDownLatch.await(); // 必须要减到0才能解除\n    System.out.println(\"全部结束咯\");\n}\n```\n\n用法二：多个线程等待某一个线程的信号，同时开始执行。\n\n```java\n// 例如进行压测，创建很多线程应该先等待，再一个统一的时间再过去\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch countDownLatch = new CountDownLatch(1);\n    ExecutorService executorService = Executors.newFixedThreadPool(5);\n    for (int i = 0; i < 5; i++) {\n        int finalI = i;\n        executorService.submit(() -> {\n            System.out.println(finalI + \"准备完毕\");\n            try {\n                countDownLatch.await();\n                System.out.println(finalI + \"开始跑步\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n    TimeUnit.SECONDS.sleep(5);         // 检查场地等\n    System.out.println(\"比赛开始！\");\n    countDownLatch.countDown();\n}\n```\n\n## Semaphore\n\n+ 可以用来限制或管理数量有限资源的使用情况。实际上就相当于PV操作\n+ 当一个线程调用acquire（获取），要么成功获得信号量（信号量-1），要么阻塞到有线程释放信号量\n+ release（释放），实际会将信号量的值+1，然后唤醒等待的线程\n+ 可以选择公平或者非公平实现：`public Semaphore(int permits, boolean fair)`\n\n```java\nSemaphore semaphore = new Semaphore(3);\nfor (int i = 0; i < 6; i++) {\n    new Thread(()->{\n        try {\n            semaphore.acquire();\n            System.out.println(Thread.currentThread().getName()+\" 抢到车位\");\n            TimeUnit.SECONDS.sleep(2);\n            System.out.println(Thread.currentThread().getName()+\" 离开车位\");\n        }\n        catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        finally {\n            semaphore.release();\n        }\n    }，String.valueOf(i)).start();\n}\n```\n\n## CyclicBarrier\n\n+ 可循环(`Cyclic`)使用的屏障(`Barrier`)\n+ 让一组线程到达一个屏障(同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续干活\n+ 线程进入屏障是通过`CyclicBarrier`的`await()`方法\n\n```java\npublic static void main(String[] args) {\n    CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {\n        System.out.println(\"大威天龙!\");\n    });\n    for (int i = 0; i < 7; i++) {\n        int finalI = i+1;\n        new Thread(()->{\n            System.out.println(Thread.currentThread().getName()+ \" 收集龙珠\"+finalI );\n            try {\n                cyclicBarrier.await();\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        },\"thread\"+String.valueOf(i)).start();\n    }\n}\n```\n\n","slug":"Java语言/Java多线程/4.AQS与应用","published":1,"updated":"2021-06-08T03:35:00.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq50v000fz0tp6s726hha","content":"<h1 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>阻塞队列是线程池的重要组成部分</p>\n<p>如果队列为空，则取数据会一直阻塞；如果队列满了，则插入数据会一直阻塞。其实体现了生产者消费者模式</p>\n<p>阻塞队列是具有阻塞功能的队列，通常阻塞队列的一端给生产者放数据用，另一端给消费者拿数据用。阻塞队列是线程安全的，生产者消费者都可以是多线程的。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153219428.png\" alt=\"image-20210606153219428\"></p>\n<h3 id=\"继承体系图\"><a href=\"#继承体系图\" class=\"headerlink\" title=\"继承体系图\"></a>继承体系图</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153040648.png\" alt=\"image-20210606153040648\"></p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"抛出异常方法\"><a href=\"#抛出异常方法\" class=\"headerlink\" title=\"抛出异常方法\"></a>抛出异常方法</h3><pre class=\" language-java\"><code class=\"language-java\">BlockingQueue<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> blockingQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 该队列最大为3</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//抛出异常:java.lang.IllegalStateException: Queue full</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"x\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"返回特殊值方法\"><a href=\"#返回特殊值方法\" class=\"headerlink\" title=\"返回特殊值方法\"></a>返回特殊值方法</h3><pre class=\" language-java\"><code class=\"language-java\">BlockingQueue<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> blockingQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"d\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// false</span></code></pre>\n<h3 id=\"阻塞方法\"><a href=\"#阻塞方法\" class=\"headerlink\" title=\"阻塞方法\"></a>阻塞方法</h3><ul>\n<li>take()方法：获取并移除队列的头节点，一旦执行take的时候，队列里无数据，则阻塞，直到队列里有数据</li>\n<li>put()方法：插入数据。如果队列已满，就无法插入，即阻塞，直到队列里有了空闲空间</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\">BlockingQueue<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> blockingQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nblockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nblockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nblockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//blockingQueue.put(\"d\"); //队列满了，该线程会等待</span>\nblockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nblockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nblockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//不消费完线程，就阻塞掉</span>\nblockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"超时方法\"><a href=\"#超时方法\" class=\"headerlink\" title=\"超时方法\"></a>超时方法</h3><pre class=\" language-java\"><code class=\"language-java\">BlockingQueue<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> blockingQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span>， 2L， TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span>， 2L， TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span>， 2L， TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//只阻塞2s，就会返回false</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span>， 2L， TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"常见类\"><a href=\"#常见类\" class=\"headerlink\" title=\"常见类\"></a>常见类</h2><h3 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h3><ul>\n<li>有界阻塞队列，创建时需要指定容量</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">checkNotNull</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> ReentrantLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> items<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span>\n            notFull<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>公平性</strong></p>\n<p>默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以 按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程 是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的 线程最后才访问队列。为了保证公平性，通常会降低吞吐量。</p>\n<pre class=\" language-java\"><code class=\"language-java\">ArrayBlockingQueue fairQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 公平</span></code></pre>\n<p>访问者的公平性是使用可重入锁实现的</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">ArrayBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> fair<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>capacity <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>items <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span>capacity<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n     lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span>fair<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     notEmpty <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     notFull <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度 为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p>\n<h3 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a>SynchronousQueue</h3><p>SynchronousQueue 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。</p>\n<p> 它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用构造方法可以创建公平性访问的 SynchronousQueue，如果设置为 true，则等待的线程会采用 先进先出的顺序访问队列。 </p>\n<p>SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递 给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。</p>\n<ul>\n<li>容量为0，不需要存储元素，没有头节点，也就没有了peek()方法</li>\n<li>直接传递的并发数据结构</li>\n<li>是线程池Executors.newCachedThreadPool()使用的阻塞队列</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>BlockingQueue<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>SynchronousQueue<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//同步队列不存储，只能生产一个就消费一个</span>\n        BlockingQueue<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> blockingQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SynchronousQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" put\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" put\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" put\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>，<span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>，<span class=\"token string\">\"t2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采取自然 顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是 不能保证同优先级元素的顺序。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞 住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p>\n<p>其实是使用了Condition实现</p>\n<p>当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park(this)来实现。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Condition notFull<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Condition notEmpty<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token function\">ArrayBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> fair<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     notEmpty <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     notFull <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n     <span class=\"token function\">checkNotNull</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">final</span> ReentrantLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span>\n     lock<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> items<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> notFull<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n         lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> E <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">final</span> ReentrantLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span>\n     lock<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> notEmpty<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">return</span> <span class=\"token function\">extract</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n         lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>E x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     items<span class=\"token punctuation\">[</span>putIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n     putIndex <span class=\"token operator\">=</span> <span class=\"token function\">inc</span><span class=\"token punctuation\">(</span>putIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token operator\">++</span>count<span class=\"token punctuation\">;</span>\n     notEmpty<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     Node node <span class=\"token operator\">=</span> <span class=\"token function\">addConditionWaiter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">int</span> savedState <span class=\"token operator\">=</span> <span class=\"token function\">fullyRelease</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">int</span> interruptMode <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isOnSyncQueue</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         LockSupport<span class=\"token punctuation\">.</span><span class=\"token function\">park</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>interruptMode <span class=\"token operator\">=</span> <span class=\"token function\">checkInterruptWhileWaiting</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">acquireQueued</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> savedState<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> interruptMode <span class=\"token operator\">!=</span> THROW_IE<span class=\"token punctuation\">)</span> \n         interruptMode <span class=\"token operator\">=</span> REINTERRUPT<span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>nextWaiter <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// clean up if cancelled</span>\n          <span class=\"token function\">unlinkCancelledWaiters</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>interruptMode <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token function\">reportInterruptAfterWait</span><span class=\"token punctuation\">(</span>interruptMode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"LockSupport\"><a href=\"#LockSupport\" class=\"headerlink\" title=\"LockSupport\"></a>LockSupport</h1><p>当需要阻塞或唤醒一个线程的时候，都会使用 LockSupport 工具类来完 成相应工作。LockSupport 定义了一组的公共静态方法，这些方法提供了最基本的线程阻 塞和唤醒功能，而 LockSupport 也成为构建同步组件的基础工具。</p>\n<p>LockSupport 定义了一组以 park 开头的方法用来阻塞当前线程，以及 unpark(Thread thread) 方法来唤醒一个被阻塞的线程。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608091632079.png\" alt=\"image-20210608091632079\"></p>\n<h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>抽象的队列同步器</p>\n<p>是用来构建锁或者其他同步器组件的重量级基础框架及整个JUC体系的基石。通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类型变量表示持有锁的状态</p>\n<p>基本上CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock、CyclicBarrier都和AQS有关</p>\n<p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>\n<p><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</strong></p>\n<p>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p>\n<p><strong>注意：AQS是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210607214750830.png\" alt=\"image-20210607214750830\"></p>\n<p>AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：<br>getState();setState();compareAndSetState();</p>\n<p>AQS 定义了两种资源共享方式：<br>1.<strong>Exclusive</strong>：独占，只有一个线程能执行，如ReentrantLock<br>2.<strong>Share</strong>：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p>\n<p>不同的自定义的同步器争用共享资源的方式也不同。</p>\n<p><code>AQS</code>即<code>AbstractQueuedSynchronizer</code>的缩写，这个是个内部实现了两个队列的抽象类，分别是<strong>同步队列</strong>和<strong>条件队列</strong>。其中<strong>同步队列</strong>是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而<strong>条件队列</strong>是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，<code>AQS</code>所做的就是管理这两个队列里面线程之间的<strong>等待状态-唤醒</strong>的工作。<br> 在同步队列中，还存在<code>2</code>中模式，分别是<strong>独占模式</strong>和<strong>共享模式</strong>，这两种模式的区别就在于<code>AQS</code>在唤醒线程节点的时候是不是传递唤醒，这两种模式分别对应<strong>独占锁</strong>和<strong>共享锁</strong>。<br> <code>AQS</code>是一个抽象类，所以不能直接实例化，当我们需要实现一个自定义锁的时候可以去继承<code>AQS</code>然后重写<strong>获取锁的方式</strong>和<strong>释放锁的方式</strong>还有<strong>管理state</strong>，而<code>ReentrantLock</code>就是通过重写了<code>AQS</code>的<code>tryAcquire</code>和<code>tryRelease</code>方法实现的<code>lock</code>和<code>unlock</code>。</p>\n<p><strong>应用</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 实现一个非独占锁，当有线程调用await时陷入阻塞，只有某个线程调用了signal时才全部放行</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyLock</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Sync sync <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Sync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Sync</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractQueuedSynchronizer</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token keyword\">int</span> <span class=\"token function\">tryAcquireShared</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//  state初始化为0，代表会阻塞，为1时代表线程放行</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryReleaseShared</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 后面获取锁的线程不需要阻塞了</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 把之前等待的线程唤醒</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        sync<span class=\"token punctuation\">.</span><span class=\"token function\">acquireShared</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        sync<span class=\"token punctuation\">.</span><span class=\"token function\">releaseShared</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        MyLock myLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"尝试获取锁\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                myLock<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"获取成功，开始执行！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        myLock<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>\n<ol>\n<li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li>\n<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>\n</ol>\n<p>自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的时候主要实现下面几种方法：</p>\n<ul>\n<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>\n<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>\n<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>\n<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>\n<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>\n</ul>\n<p><strong>ReentrantLock</strong>：（可重入独占式锁）：state初始化为0，表示未锁定状态，A线程lock()时，会调用tryAcquire()独占锁并将state+1.之后其他线程再想tryAcquire的时候就会失败，直到A线程unlock（）到state=0为止，其他线程才有机会获取该锁。A释放锁之前，自己也是可以重复获取此锁（state累加），这就是可重入的概念。<br>注意：获取多少次锁就要释放多少次锁，保证state是能回到零态的。</p>\n<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时<strong>实现独占和共享两种方式，如ReentrantReadWriteLock。</strong><br>　在acquire() acquireShared()两种方式下，线程在等待队列中都是忽略中断的，<strong>acquireInterruptibly()/acquireSharedInterruptibly()是支持响应中断</strong>的。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090003077.png\" alt=\"image-20210608090003077\"></p>\n<h2 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> state<span class=\"token punctuation\">;</span></code></pre>\n<p>会被并发地修改，所以所有修改state的方法都需要保证线程安全</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> expect<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> stateOffset<span class=\"token punctuation\">,</span> expect<span class=\"token punctuation\">,</span> update<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>在ReentrantLock中，state代表锁的占有情况，包括<strong>可重入计数</strong></p>\n<p>当state为0时，标识该Lock不被任何线程所占有</p>\n<p> AbstractQueuedSynchronizer维护了一个volatile int类型的变量，用户表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。</p>\n<h2 id=\"FIFO队列\"><a href=\"#FIFO队列\" class=\"headerlink\" title=\"FIFO队列\"></a>FIFO队列</h2><ul>\n<li>这个队列用来存放等待的线程，AQS就是一个排队管理器，当多个线程争用同一把锁时，必须有一个排队机制把那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁</li>\n<li>AQS会维护一个等待的线程队列，把线程都放在这个队列里</li>\n<li>head是拿到锁的线程：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210607145130742.png\" alt=\"image-20210607145130742\"></p>\n<p>同步器依赖内部的同步队列（一个 FIFO 双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点 （Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090235159.png\" alt=\"image-20210608090235159\"></p>\n<p>同步器提供了一个基于 CAS 的设置尾节点的方法： compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当 前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>\n<p>同步器将节点加入到同步队列的过程：</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090428446.png\" alt=\"image-20210608090428446\" style=\"zoom:67%;\" />\n\n<p>同步队列遵循 FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步 状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证，它只 需要将首节点设置成为原首节点的后继节点并断开原首节点的 next 引用即可。</p>\n<h2 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h2><h3 id=\"独占式\"><a href=\"#独占式\" class=\"headerlink\" title=\"独占式\"></a>独占式</h3><p>获取操作会依赖state变量，经常会阻塞（比如获取不到锁的时候）</p>\n<h4 id=\"acquire-int\"><a href=\"#acquire-int\" class=\"headerlink\" title=\"acquire(int)\"></a>acquire(int)</h4><p>前驱节点为头节点且能够获取同步状态的判断条件和线程进入等待状 态是获取同步状态的自旋过程。当同步状态获取成功之后，当前线程从 acquire(int arg)方 法返回，如果对于锁这种并发组件而言，代表着当前线程获取了锁。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608091041981.png\" alt=\"image-20210608091041981\"></p>\n<p>acquire是一种以独占方式获取资源，如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。该方法是独占模式下线程获取共享资源的顶层入口。获取到资源后，线程就可以去执行其临界区代码了</p>\n<p>通过调用同步器的 acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也 就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程 不会从同步队列中移出</p>\n<p>首先调用自定义同步器实现的 tryAcquire(int arg)方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点 （独占式 Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过 addWaiter(Node node) 方法将该节点加入到同步队列的尾部，最后调用 acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如 果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞 线程被中断来实现。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">acquireQueued</span><span class=\"token punctuation\">(</span><span class=\"token function\">addWaiter</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">.</span>EXCLUSIVE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">selfInterrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>acquire方法是一种互斥模式，且忽略中断。该方法至少执行一次<code>tryAcquire(int)</code>方法，如果tryAcquire(int)方法返回true，则acquire直接返回，否则当前线程需要进入队列进行排队。函数流程如下：</p>\n<ul>\n<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>\n<li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>\n<li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>\n<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>\n</ul>\n<h5 id=\"tryAcquire-int\"><a href=\"#tryAcquire-int\" class=\"headerlink\" title=\"tryAcquire(int)\"></a>tryAcquire(int)</h5><p>tryAcquire尝试以独占的方式获取资源，如果获取成功，则直接返回true，否则直接返回false。该方法可以用于实现Lock中的tryLock()方法。该方法的默认实现是抛出<code>UnsupportedOperationException</code>，具体实现由自定义的扩展了AQS的同步类来实现。AQS在这里只负责定义了一个公共的方法框架。</p>\n<p>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UnsupportedOperationException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"addWaiter-Node\"><a href=\"#addWaiter-Node\" class=\"headerlink\" title=\"addWaiter(Node)\"></a>addWaiter(Node)</h5><p>该方法用于将当前线程根据不同的模式（<code>Node.EXCLUSIVE</code>互斥模式、<code>Node.SHARED</code>共享模式）加入到等待队列的队尾，并返回当前线程所在的结点。如果队列不为空，则以通过<code>compareAndSetTail</code>方法以CAS的方式将当前线程节点加入到等待队列的末尾。</p>\n<p>如果CAS失败或者队列为空，则通过enq(node)方法初始化一个等待队列，并返回当前节点。</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">private</span> Node <span class=\"token function\">addWaiter</span><span class=\"token punctuation\">(</span>Node mode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Node node <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Node pred <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pred <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> pred<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetTail</span><span class=\"token punctuation\">(</span>pred<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                pred<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">enq</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"enq-node\"><a href=\"#enq-node\" class=\"headerlink\" title=\"enq(node)\"></a>enq(node)</h5><p><code>enq(node)</code>用于将当前节点插入等待队列，如果队列为空，则初始化当前队列。整个过程以CAS自旋的方式进行，直到成功加入队尾为止。</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">private</span> Node <span class=\"token function\">enq</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Node node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Node t <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetHead</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    tail <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetTail</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    t<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> t<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"acquireQueued-Node-int\"><a href=\"#acquireQueued-Node-int\" class=\"headerlink\" title=\"acquireQueued(Node, int)\"></a>acquireQueued(Node, int)</h5><p> <code>acquireQueued()</code>用于队列中的线程自旋地以独占且不可中断的方式获取同步状态（acquire），直到拿到锁之后再返回。该方法的实现分成两部分：如果当前节点前一个节点已经成为头结点，尝试获取锁（tryAcquire）成功，然后返回；否则检查当前节点是否应该被park，然后将该线程park并且检查当前线程是否被可以被中断。</p>\n<ul>\n<li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>\n<li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>\n<li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>\n<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>\n</ul>\n<p>在 acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中尝试获取同 步状态，而只有前驱节点是头节点才能够尝试获取同步状态</p>\n<p>第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之 后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头 节点。 第二，维护同步队列的 FIFO 原则。该方法中，节点自旋获取同步状态的行为</p>\n<p>由于非首节点线程前驱节点出队或者被中断而从等待状态返回，随后检 查自己的前驱是否是头节点，如果是则尝试获取同步状态。可以看到节点和节点之 间在循环检查的过程中基本不相互通信，而是简单地判断自己的前驱是否为头节 点，这样就使得节点的释放规则符合 FIFO，并且也便于对过早通知的处理（过早 通知是指前驱节点不是头节点的线程由于中断而被唤醒）。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090945214.png\" alt=\"image-20210608090945214\"></p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">acquireQueued</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Node node<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//标记是否成功拿到资源，默认false</span>\n        <span class=\"token keyword\">boolean</span> failed <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">boolean</span> interrupted <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 标记等待过程中是否被中断过</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 如果前一个节点p是头节点，那么又尝试获取锁，获取到了则返回interrupted</span>\n                <span class=\"token keyword\">final</span> Node p <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span><span class=\"token function\">predecessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">==</span> head <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">setHead</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    p<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// help GC</span>\n                    failed <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> interrupted<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">shouldParkAfterFailedAcquire</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">parkAndCheckInterrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    interrupted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>failed<span class=\"token punctuation\">)</span>\n                <span class=\"token function\">cancelAcquire</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"shouldParkAfterFailedAcquire-Node-Node\"><a href=\"#shouldParkAfterFailedAcquire-Node-Node\" class=\"headerlink\" title=\"shouldParkAfterFailedAcquire(Node, Node)\"></a>shouldParkAfterFailedAcquire(Node, Node)</h5><p> shouldParkAfterFailedAcquire方法通过对当前节点的前一个节点的状态进行判断，对当前节点做出不同的操作</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">shouldParkAfterFailedAcquire</span><span class=\"token punctuation\">(</span>Node pred<span class=\"token punctuation\">,</span> Node node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> ws <span class=\"token operator\">=</span> pred<span class=\"token punctuation\">.</span>waitStatus<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ws <span class=\"token operator\">==</span> Node<span class=\"token punctuation\">.</span>SIGNAL<span class=\"token punctuation\">)</span>\n            <span class=\"token comment\" spellcheck=\"true\">/*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ws <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">/*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */</span>\n            <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n                node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> pred <span class=\"token operator\">=</span> pred<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>pred<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            pred<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">/*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */</span>\n            <span class=\"token function\">compareAndSetWaitStatus</span><span class=\"token punctuation\">(</span>pred<span class=\"token punctuation\">,</span> ws<span class=\"token punctuation\">,</span> Node<span class=\"token punctuation\">.</span>SIGNAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"parkAndCheckInterrupt\"><a href=\"#parkAndCheckInterrupt\" class=\"headerlink\" title=\"parkAndCheckInterrupt()\"></a>parkAndCheckInterrupt()</h5><p>该方法让线程去休息，真正进入等待状态。park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">parkAndCheckInterrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        LockSupport<span class=\"token punctuation\">.</span><span class=\"token function\">park</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"release-int\"><a href=\"#release-int\" class=\"headerlink\" title=\"release(int)\"></a>release(int)</h4><p>该方法执行时，会唤醒头节点的后继节点线程，unparkSuccessor(Node node)方法使 用 LockSupport（在后面的章节会专门介绍）来唤醒处于等待状态的线程。 分析了独占式同步状态获取和释放过程后，适当做个总结：在获取同步状态时，同 步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自 旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释 放同步状态时，同步器调用 tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后 继节点。</p>\n<p>  <code>release(int)</code>方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。</p>\n<p>与acquire()方法中的tryAcquire()类似，tryRelease()方法也是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p>\n<p><code>unparkSuccessor(Node)</code>方法用于唤醒等待队列中下一个线程。这里要注意的是，下一个线程并不一定是当前节点的next节点，而是下一个可以用来唤醒的线程，如果这个节点存在，调用<code>unpark()</code>方法唤醒。<br>  总之，release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p>\n<pre class=\" language-java\"><code class=\"language-java\"> <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tryRelease</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Node h <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> h<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                <span class=\"token function\">unparkSuccessor</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryRelease</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UnsupportedOperationException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">unparkSuccessor</span><span class=\"token punctuation\">(</span>Node node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * If status is negative (i.e., possibly needing signal) try\n         * to clear in anticipation of signalling.  It is OK if this\n         * fails or if status is changed by waiting thread.\n         */</span>\n        <span class=\"token keyword\">int</span> ws <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>waitStatus<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ws <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">compareAndSetWaitStatus</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> ws<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * Thread to unpark is held in successor, which is normally\n         * just the next node.  But if cancelled or apparently null,\n         * traverse backwards from tail to find the actual\n         * non-cancelled successor.\n         */</span>\n        Node s <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> s<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            s <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Node t <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">;</span> t <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> t <span class=\"token operator\">!=</span> node<span class=\"token punctuation\">;</span> t <span class=\"token operator\">=</span> t<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                    s <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n            LockSupport<span class=\"token punctuation\">.</span><span class=\"token function\">unpark</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>thread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"共享式\"><a href=\"#共享式\" class=\"headerlink\" title=\"共享式\"></a>共享式</h3><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同 步状态。以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该 文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而 读操作可以是共享式访问，两种不同的访问模式在同一时刻对文件或资源的访问情况</p>\n<h4 id=\"acquireShared-int\"><a href=\"#acquireShared-int\" class=\"headerlink\" title=\"acquireShared(int)\"></a>acquireShared(int)</h4><ul>\n<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>\n<li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</li>\n</ul>\n<p><code>acquireShared(int)</code>方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">acquireShared</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tryAcquireShared</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">doAcquireShared</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"doAcquireShared-int\"><a href=\"#doAcquireShared-int\" class=\"headerlink\" title=\"doAcquireShared(int)\"></a>doAcquireShared(int)</h5><p>  将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doAcquireShared</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">final</span> Node node <span class=\"token operator\">=</span> <span class=\"token function\">addWaiter</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">.</span>SHARED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">boolean</span> failed <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">boolean</span> interrupted <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">final</span> Node p <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span><span class=\"token function\">predecessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">==</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">int</span> r <span class=\"token operator\">=</span> <span class=\"token function\">tryAcquireShared</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token function\">setHeadAndPropagate</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        p<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// help GC</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>interrupted<span class=\"token punctuation\">)</span>\n                            <span class=\"token function\">selfInterrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        failed <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">shouldParkAfterFailedAcquire</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n                    <span class=\"token function\">parkAndCheckInterrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    interrupted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>failed<span class=\"token punctuation\">)</span>\n                <span class=\"token function\">cancelAcquire</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setHeadAndPropagate</span><span class=\"token punctuation\">(</span>Node node<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> propagate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Node h <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Record old head for check below</span>\n        <span class=\"token function\">setHead</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * Try to signal next queued node if:\n         *   Propagation was indicated by caller,\n         *     or was recorded (as h.waitStatus either before\n         *     or after setHead) by a previous operation\n         *     (note: this uses sign-check of waitStatus because\n         *      PROPAGATE status may transition to SIGNAL.)\n         * and\n         *   The next node is waiting in shared mode,\n         *     or we don't know, because it appears null\n         *\n         * The conservatism in both of these checks may cause\n         * unnecessary wake-ups, but only when there are multiple\n         * racing acquires/releases, so most need signals now or soon\n         * anyway.\n         */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>propagate <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> h <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> h<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span>\n            <span class=\"token punctuation\">(</span>h <span class=\"token operator\">=</span> head<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> h<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Node s <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">isShared</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token function\">doReleaseShared</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p>\n<h4 id=\"releaseShared-int\"><a href=\"#releaseShared-int\" class=\"headerlink\" title=\"releaseShared(int)\"></a>releaseShared(int)</h4><p>  <code>releaseShared(int)</code>方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">releaseShared</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tryReleaseShared</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">doReleaseShared</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doReleaseShared</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n         * Ensure that a release propagates, even if there are other\n         * in-progress acquires/releases.  This proceeds in the usual\n         * way of trying to unparkSuccessor of head if it needs\n         * signal. But if it does not, status is set to PROPAGATE to\n         * ensure that upon release, propagation continues.\n         * Additionally, we must loop in case a new node is added\n         * while we are doing this. Also, unlike other uses of\n         * unparkSuccessor, we need to know if CAS to reset status\n         * fails, if so rechecking.\n         */</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Node h <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> h <span class=\"token operator\">!=</span> tail<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> ws <span class=\"token operator\">=</span> h<span class=\"token punctuation\">.</span>waitStatus<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ws <span class=\"token operator\">==</span> Node<span class=\"token punctuation\">.</span>SIGNAL<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">compareAndSetWaitStatus</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> Node<span class=\"token punctuation\">.</span>SIGNAL<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\" spellcheck=\"true\">// loop to recheck cases</span>\n                    <span class=\"token function\">unparkSuccessor</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ws <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span>\n                         <span class=\"token operator\">!</span><span class=\"token function\">compareAndSetWaitStatus</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> Node<span class=\"token punctuation\">.</span>PROPAGATE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>                <span class=\"token comment\" spellcheck=\"true\">// loop on failed CAS</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">==</span> head<span class=\"token punctuation\">)</span>                   <span class=\"token comment\" spellcheck=\"true\">// loop if head changed</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"并发工具类\"><a href=\"#并发工具类\" class=\"headerlink\" title=\"并发工具类\"></a>并发工具类</h1><h2 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h2><ul>\n<li>线程调用<code>countDown</code>方法会将计数器减一(调用<code>countDown</code>不会阻塞)</li>\n<li>当一个或多个线程调用<code>await</code>方法时，调用线程会被阻塞</li>\n<li>当计数器为零时，因为调用了<code>await</code>方法而被阻塞的线程会被唤醒，继续执行</li>\n<li>CountDownLatch不能重用</li>\n</ul>\n<p>用法一：一个线程等待多个线程都执行完毕，再继续自己的工作</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//例如启动程序，对外发布服务时，应该所有的都检查完毕（检查数据有没有完毕等前置流程）才进入下一个环节</span>\n<span class=\"token comment\" spellcheck=\"true\">//主线程等待所有线程都执行完毕才结束</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    CountDownLatch countDownLatch <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CountDownLatch</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" 离开\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">countDown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>， String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 必须要减到0才能解除</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"全部结束咯\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>用法二：多个线程等待某一个线程的信号，同时开始执行。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 例如进行压测，创建很多线程应该先等待，再一个统一的时间再过去</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    CountDownLatch countDownLatch <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CountDownLatch</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ExecutorService executorService <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> finalI <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>finalI <span class=\"token operator\">+</span> <span class=\"token string\">\"准备完毕\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>finalI <span class=\"token operator\">+</span> <span class=\"token string\">\"开始跑步\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\" spellcheck=\"true\">// 检查场地等</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"比赛开始！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">countDown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h2><ul>\n<li>可以用来限制或管理数量有限资源的使用情况。实际上就相当于PV操作</li>\n<li>当一个线程调用acquire（获取），要么成功获得信号量（信号量-1），要么阻塞到有线程释放信号量</li>\n<li>release（释放），实际会将信号量的值+1，然后唤醒等待的线程</li>\n<li>可以选择公平或者非公平实现：<code>public Semaphore(int permits, boolean fair)</code></li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\">Semaphore semaphore <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Semaphore</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            semaphore<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" 抢到车位\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" 离开车位\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            semaphore<span class=\"token punctuation\">.</span><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>，String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h2><ul>\n<li>可循环(<code>Cyclic</code>)使用的屏障(<code>Barrier</code>)</li>\n<li>让一组线程到达一个屏障(同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续干活</li>\n<li>线程进入屏障是通过<code>CyclicBarrier</code>的<code>await()</code>方法</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    CyclicBarrier cyclicBarrier <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CyclicBarrier</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"大威天龙!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> finalI <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span> <span class=\"token string\">\" 收集龙珠\"</span><span class=\"token operator\">+</span>finalI <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                cyclicBarrier<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BrokenBarrierException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"thread\"</span><span class=\"token operator\">+</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>阻塞队列是线程池的重要组成部分</p>\n<p>如果队列为空，则取数据会一直阻塞；如果队列满了，则插入数据会一直阻塞。其实体现了生产者消费者模式</p>\n<p>阻塞队列是具有阻塞功能的队列，通常阻塞队列的一端给生产者放数据用，另一端给消费者拿数据用。阻塞队列是线程安全的，生产者消费者都可以是多线程的。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153219428.png\" alt=\"image-20210606153219428\"></p>\n<h3 id=\"继承体系图\"><a href=\"#继承体系图\" class=\"headerlink\" title=\"继承体系图\"></a>继承体系图</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153040648.png\" alt=\"image-20210606153040648\"></p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"抛出异常方法\"><a href=\"#抛出异常方法\" class=\"headerlink\" title=\"抛出异常方法\"></a>抛出异常方法</h3><pre><code class=\"java\">BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); // 该队列最大为3\nSystem.out.println(blockingQueue.add(&quot;a&quot;));\nSystem.out.println(blockingQueue.add(&quot;b&quot;));\nSystem.out.println(blockingQueue.add(&quot;c&quot;));\n//抛出异常:java.lang.IllegalStateException: Queue full\nSystem.out.println(blockingQueue.add(&quot;x&quot;));</code></pre>\n<h3 id=\"返回特殊值方法\"><a href=\"#返回特殊值方法\" class=\"headerlink\" title=\"返回特殊值方法\"></a>返回特殊值方法</h3><pre><code class=\"java\">BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);\nSystem.out.println(blockingQueue.offer(&quot;a&quot;));\nSystem.out.println(blockingQueue.offer(&quot;b&quot;));\nSystem.out.println(blockingQueue.offer(&quot;c&quot;));\nSystem.out.println(blockingQueue.offer(&quot;d&quot;)); // false</code></pre>\n<h3 id=\"阻塞方法\"><a href=\"#阻塞方法\" class=\"headerlink\" title=\"阻塞方法\"></a>阻塞方法</h3><ul>\n<li>take()方法：获取并移除队列的头节点，一旦执行take的时候，队列里无数据，则阻塞，直到队列里有数据</li>\n<li>put()方法：插入数据。如果队列已满，就无法插入，即阻塞，直到队列里有了空闲空间</li>\n</ul>\n<pre><code class=\"java\">BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);\nblockingQueue.put(&quot;a&quot;);\nblockingQueue.put(&quot;b&quot;);\nblockingQueue.put(&quot;c&quot;);\n//blockingQueue.put(&quot;d&quot;); //队列满了，该线程会等待\nblockingQueue.take();\nblockingQueue.take();\nblockingQueue.take();\n//不消费完线程，就阻塞掉\nblockingQueue.take();</code></pre>\n<h3 id=\"超时方法\"><a href=\"#超时方法\" class=\"headerlink\" title=\"超时方法\"></a>超时方法</h3><pre><code class=\"java\">BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);\nSystem.out.println(blockingQueue.offer(&quot;a&quot;， 2L， TimeUnit.SECONDS));\nSystem.out.println(blockingQueue.offer(&quot;a&quot;， 2L， TimeUnit.SECONDS));\nSystem.out.println(blockingQueue.offer(&quot;a&quot;， 2L， TimeUnit.SECONDS));\n//只阻塞2s，就会返回false\nSystem.out.println(blockingQueue.offer(&quot;a&quot;， 2L， TimeUnit.SECONDS));</code></pre>\n<h2 id=\"常见类\"><a href=\"#常见类\" class=\"headerlink\" title=\"常见类\"></a>常见类</h2><h3 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h3><ul>\n<li>有界阻塞队列，创建时需要指定容量</li>\n</ul>\n<pre><code class=\"java\">public void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length)\n            notFull.await();\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}</code></pre>\n<p><strong>公平性</strong></p>\n<p>默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以 按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程 是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的 线程最后才访问队列。为了保证公平性，通常会降低吞吐量。</p>\n<pre><code class=\"java\">ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000, true); // 公平</code></pre>\n<p>访问者的公平性是使用可重入锁实现的</p>\n<pre><code class=\"java\">public ArrayBlockingQueue(int capacity, boolean fair) {\n     if (capacity &lt;= 0) throw new IllegalArgumentException();\n     this.items = new Object[capacity];\n     lock = new ReentrantLock(fair);\n     notEmpty = lock.newCondition();\n     notFull = lock.newCondition();\n}</code></pre>\n<h3 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度 为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p>\n<h3 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a>SynchronousQueue</h3><p>SynchronousQueue 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。</p>\n<p> 它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用构造方法可以创建公平性访问的 SynchronousQueue，如果设置为 true，则等待的线程会采用 先进先出的顺序访问队列。 </p>\n<p>SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递 给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。</p>\n<ul>\n<li>容量为0，不需要存储元素，没有头节点，也就没有了peek()方法</li>\n<li>直接传递的并发数据结构</li>\n<li>是线程池Executors.newCachedThreadPool()使用的阻塞队列</li>\n</ul>\n<pre><code class=\"java\">import java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.SynchronousQueue;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main{\n    public static void main(String[] args) {\n        //同步队列不存储，只能生产一个就消费一个\n        BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;();\n        new Thread(() -&gt; {\n            try {\n                System.out.println(Thread.currentThread().getName()+&quot; put&quot;);\n                blockingQueue.put(&quot;1&quot;);\n                System.out.println(Thread.currentThread().getName()+&quot; put&quot;);\n                blockingQueue.put(&quot;2&quot;);\n                System.out.println(Thread.currentThread().getName()+&quot; put&quot;);\n                blockingQueue.put(&quot;3&quot;);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }，&quot;t1&quot;).start();\n        new Thread(()-&gt;{\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            try {\n                System.out.println(blockingQueue.take());\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }，&quot;t2&quot;).start();\n    }\n}</code></pre>\n<h3 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采取自然 顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是 不能保证同优先级元素的顺序。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞 住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p>\n<p>其实是使用了Condition实现</p>\n<p>当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park(this)来实现。</p>\n<pre><code class=\"java\">private final Condition notFull;\nprivate final Condition notEmpty;\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n     notEmpty = lock.newCondition();\n     notFull = lock.newCondition();\n}\n\npublic void put(E e) throws InterruptedException {\n     checkNotNull(e);\n     final ReentrantLock lock = this.lock;\n     lock.lockInterruptibly();\n     try {\n         while (count == items.length) notFull.await();\n         insert(e);\n     } finally {\n         lock.unlock();\n     }\n}\npublic E take() throws InterruptedException {\n     final ReentrantLock lock = this.lock;\n     lock.lockInterruptibly();\n     try {\n         while (count == 0) notEmpty.await();\n         return extract();\n     } finally {\n         lock.unlock();\n     }\n}\nprivate void insert(E x) {\n     items[putIndex] = x;\n     putIndex = inc(putIndex);\n     ++count;\n     notEmpty.signal();\n}\n\npublic final void await() throws InterruptedException {\n     if (Thread.interrupted()) throw new InterruptedException();\n     Node node = addConditionWaiter();\n     int savedState = fullyRelease(node);\n     int interruptMode = 0;\n     while (!isOnSyncQueue(node)) {\n         LockSupport.park(this);\n         if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break;\n     }\n     if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) \n         interruptMode = REINTERRUPT;\n     if (node.nextWaiter != null) // clean up if cancelled\n          unlinkCancelledWaiters();\n     if (interruptMode != 0) reportInterruptAfterWait(interruptMode);\n}</code></pre>\n<h1 id=\"LockSupport\"><a href=\"#LockSupport\" class=\"headerlink\" title=\"LockSupport\"></a>LockSupport</h1><p>当需要阻塞或唤醒一个线程的时候，都会使用 LockSupport 工具类来完 成相应工作。LockSupport 定义了一组的公共静态方法，这些方法提供了最基本的线程阻 塞和唤醒功能，而 LockSupport 也成为构建同步组件的基础工具。</p>\n<p>LockSupport 定义了一组以 park 开头的方法用来阻塞当前线程，以及 unpark(Thread thread) 方法来唤醒一个被阻塞的线程。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608091632079.png\" alt=\"image-20210608091632079\"></p>\n<h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>抽象的队列同步器</p>\n<p>是用来构建锁或者其他同步器组件的重量级基础框架及整个JUC体系的基石。通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类型变量表示持有锁的状态</p>\n<p>基本上CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock、CyclicBarrier都和AQS有关</p>\n<p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>\n<p><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</strong></p>\n<p>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p>\n<p><strong>注意：AQS是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210607214750830.png\" alt=\"image-20210607214750830\"></p>\n<p>AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：<br>getState();setState();compareAndSetState();</p>\n<p>AQS 定义了两种资源共享方式：<br>1.<strong>Exclusive</strong>：独占，只有一个线程能执行，如ReentrantLock<br>2.<strong>Share</strong>：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p>\n<p>不同的自定义的同步器争用共享资源的方式也不同。</p>\n<p><code>AQS</code>即<code>AbstractQueuedSynchronizer</code>的缩写，这个是个内部实现了两个队列的抽象类，分别是<strong>同步队列</strong>和<strong>条件队列</strong>。其中<strong>同步队列</strong>是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而<strong>条件队列</strong>是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，<code>AQS</code>所做的就是管理这两个队列里面线程之间的<strong>等待状态-唤醒</strong>的工作。<br> 在同步队列中，还存在<code>2</code>中模式，分别是<strong>独占模式</strong>和<strong>共享模式</strong>，这两种模式的区别就在于<code>AQS</code>在唤醒线程节点的时候是不是传递唤醒，这两种模式分别对应<strong>独占锁</strong>和<strong>共享锁</strong>。<br> <code>AQS</code>是一个抽象类，所以不能直接实例化，当我们需要实现一个自定义锁的时候可以去继承<code>AQS</code>然后重写<strong>获取锁的方式</strong>和<strong>释放锁的方式</strong>还有<strong>管理state</strong>，而<code>ReentrantLock</code>就是通过重写了<code>AQS</code>的<code>tryAcquire</code>和<code>tryRelease</code>方法实现的<code>lock</code>和<code>unlock</code>。</p>\n<p><strong>应用</strong></p>\n<pre><code class=\"java\">// 实现一个非独占锁，当有线程调用await时陷入阻塞，只有某个线程调用了signal时才全部放行\npublic class MyLock {\n    private final Sync sync = new Sync();\n\n    private static final class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected int tryAcquireShared(int arg) {\n            return getState() == 1 ? 1 : -1; //  state初始化为0，代表会阻塞，为1时代表线程放行\n        }\n\n        @Override\n        protected boolean tryReleaseShared(int arg) {\n            setState(1); // 后面获取锁的线程不需要阻塞了\n            return true; // 把之前等待的线程唤醒\n        }\n    }\n\n    public void await() {\n        sync.acquireShared(0);\n    }\n\n    public void signal() {\n        sync.releaseShared(0);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        MyLock myLock = new MyLock();\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(() -&gt; {\n                System.out.println(&quot;尝试获取锁&quot;);\n                myLock.await();\n                System.out.println(&quot;获取成功，开始执行！&quot;);\n            }).start();\n        }\n        TimeUnit.SECONDS.sleep(3);\n        myLock.signal();\n    }\n}</code></pre>\n<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>\n<ol>\n<li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li>\n<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>\n</ol>\n<p>自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的时候主要实现下面几种方法：</p>\n<ul>\n<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>\n<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>\n<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>\n<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>\n<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>\n</ul>\n<p><strong>ReentrantLock</strong>：（可重入独占式锁）：state初始化为0，表示未锁定状态，A线程lock()时，会调用tryAcquire()独占锁并将state+1.之后其他线程再想tryAcquire的时候就会失败，直到A线程unlock（）到state=0为止，其他线程才有机会获取该锁。A释放锁之前，自己也是可以重复获取此锁（state累加），这就是可重入的概念。<br>注意：获取多少次锁就要释放多少次锁，保证state是能回到零态的。</p>\n<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时<strong>实现独占和共享两种方式，如ReentrantReadWriteLock。</strong><br>　在acquire() acquireShared()两种方式下，线程在等待队列中都是忽略中断的，<strong>acquireInterruptibly()/acquireSharedInterruptibly()是支持响应中断</strong>的。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090003077.png\" alt=\"image-20210608090003077\"></p>\n<h2 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h2><pre><code class=\"java\">private volatile int state;</code></pre>\n<p>会被并发地修改，所以所有修改state的方法都需要保证线程安全</p>\n<pre><code class=\"java\">protected final boolean compareAndSetState(int expect, int update) {\n        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n    }</code></pre>\n<p>在ReentrantLock中，state代表锁的占有情况，包括<strong>可重入计数</strong></p>\n<p>当state为0时，标识该Lock不被任何线程所占有</p>\n<p> AbstractQueuedSynchronizer维护了一个volatile int类型的变量，用户表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。</p>\n<h2 id=\"FIFO队列\"><a href=\"#FIFO队列\" class=\"headerlink\" title=\"FIFO队列\"></a>FIFO队列</h2><ul>\n<li>这个队列用来存放等待的线程，AQS就是一个排队管理器，当多个线程争用同一把锁时，必须有一个排队机制把那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁</li>\n<li>AQS会维护一个等待的线程队列，把线程都放在这个队列里</li>\n<li>head是拿到锁的线程：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210607145130742.png\" alt=\"image-20210607145130742\"></p>\n<p>同步器依赖内部的同步队列（一个 FIFO 双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点 （Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090235159.png\" alt=\"image-20210608090235159\"></p>\n<p>同步器提供了一个基于 CAS 的设置尾节点的方法： compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当 前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>\n<p>同步器将节点加入到同步队列的过程：</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090428446.png\" alt=\"image-20210608090428446\" style=\"zoom:67%;\" />\n\n<p>同步队列遵循 FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步 状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证，它只 需要将首节点设置成为原首节点的后继节点并断开原首节点的 next 引用即可。</p>\n<h2 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h2><h3 id=\"独占式\"><a href=\"#独占式\" class=\"headerlink\" title=\"独占式\"></a>独占式</h3><p>获取操作会依赖state变量，经常会阻塞（比如获取不到锁的时候）</p>\n<h4 id=\"acquire-int\"><a href=\"#acquire-int\" class=\"headerlink\" title=\"acquire(int)\"></a>acquire(int)</h4><p>前驱节点为头节点且能够获取同步状态的判断条件和线程进入等待状 态是获取同步状态的自旋过程。当同步状态获取成功之后，当前线程从 acquire(int arg)方 法返回，如果对于锁这种并发组件而言，代表着当前线程获取了锁。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608091041981.png\" alt=\"image-20210608091041981\"></p>\n<p>acquire是一种以独占方式获取资源，如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。该方法是独占模式下线程获取共享资源的顶层入口。获取到资源后，线程就可以去执行其临界区代码了</p>\n<p>通过调用同步器的 acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也 就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程 不会从同步队列中移出</p>\n<p>首先调用自定义同步器实现的 tryAcquire(int arg)方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点 （独占式 Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过 addWaiter(Node node) 方法将该节点加入到同步队列的尾部，最后调用 acquireQueued(Node node,int arg)方法，使得该节点以“死循环”的方式获取同步状态。如 果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞 线程被中断来实现。</p>\n<pre><code class=\"java\">public final void acquire(int arg) {\n    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}</code></pre>\n<p>acquire方法是一种互斥模式，且忽略中断。该方法至少执行一次<code>tryAcquire(int)</code>方法，如果tryAcquire(int)方法返回true，则acquire直接返回，否则当前线程需要进入队列进行排队。函数流程如下：</p>\n<ul>\n<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>\n<li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>\n<li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>\n<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>\n</ul>\n<h5 id=\"tryAcquire-int\"><a href=\"#tryAcquire-int\" class=\"headerlink\" title=\"tryAcquire(int)\"></a>tryAcquire(int)</h5><p>tryAcquire尝试以独占的方式获取资源，如果获取成功，则直接返回true，否则直接返回false。该方法可以用于实现Lock中的tryLock()方法。该方法的默认实现是抛出<code>UnsupportedOperationException</code>，具体实现由自定义的扩展了AQS的同步类来实现。AQS在这里只负责定义了一个公共的方法框架。</p>\n<p>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。</p>\n<pre><code class=\"java\">protected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}</code></pre>\n<h5 id=\"addWaiter-Node\"><a href=\"#addWaiter-Node\" class=\"headerlink\" title=\"addWaiter(Node)\"></a>addWaiter(Node)</h5><p>该方法用于将当前线程根据不同的模式（<code>Node.EXCLUSIVE</code>互斥模式、<code>Node.SHARED</code>共享模式）加入到等待队列的队尾，并返回当前线程所在的结点。如果队列不为空，则以通过<code>compareAndSetTail</code>方法以CAS的方式将当前线程节点加入到等待队列的末尾。</p>\n<p>如果CAS失败或者队列为空，则通过enq(node)方法初始化一个等待队列，并返回当前节点。</p>\n<pre><code class=\"java\">    private Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        Node pred = tail;\n        if (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\n                pred.next = node;\n                return node;\n            }\n        }\n        enq(node);\n        return node;\n    }</code></pre>\n<h5 id=\"enq-node\"><a href=\"#enq-node\" class=\"headerlink\" title=\"enq(node)\"></a>enq(node)</h5><p><code>enq(node)</code>用于将当前节点插入等待队列，如果队列为空，则初始化当前队列。整个过程以CAS自旋的方式进行，直到成功加入队尾为止。</p>\n<pre><code class=\"java\">    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            if (t == null) { \n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else {\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }</code></pre>\n<h5 id=\"acquireQueued-Node-int\"><a href=\"#acquireQueued-Node-int\" class=\"headerlink\" title=\"acquireQueued(Node, int)\"></a>acquireQueued(Node, int)</h5><p> <code>acquireQueued()</code>用于队列中的线程自旋地以独占且不可中断的方式获取同步状态（acquire），直到拿到锁之后再返回。该方法的实现分成两部分：如果当前节点前一个节点已经成为头结点，尝试获取锁（tryAcquire）成功，然后返回；否则检查当前节点是否应该被park，然后将该线程park并且检查当前线程是否被可以被中断。</p>\n<ul>\n<li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>\n<li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>\n<li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>\n<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>\n</ul>\n<p>在 acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中尝试获取同 步状态，而只有前驱节点是头节点才能够尝试获取同步状态</p>\n<p>第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之 后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头 节点。 第二，维护同步队列的 FIFO 原则。该方法中，节点自旋获取同步状态的行为</p>\n<p>由于非首节点线程前驱节点出队或者被中断而从等待状态返回，随后检 查自己的前驱是否是头节点，如果是则尝试获取同步状态。可以看到节点和节点之 间在循环检查的过程中基本不相互通信，而是简单地判断自己的前驱是否为头节 点，这样就使得节点的释放规则符合 FIFO，并且也便于对过早通知的处理（过早 通知是指前驱节点不是头节点的线程由于中断而被唤醒）。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210608090945214.png\" alt=\"image-20210608090945214\"></p>\n<pre><code class=\"java\">    final boolean acquireQueued(final Node node, int arg) {\n        //标记是否成功拿到资源，默认false\n        boolean failed = true;\n        try {\n            boolean interrupted = false; // 标记等待过程中是否被中断过\n            for (;;) {\n                // 如果前一个节点p是头节点，那么又尝试获取锁，获取到了则返回interrupted\n                final Node p = node.predecessor();\n                if (p == head &amp;&amp; tryAcquire(arg)) {\n                    setHead(node);\n                    p.next = null; // help GC\n                    failed = false;\n                    return interrupted;\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }</code></pre>\n<h5 id=\"shouldParkAfterFailedAcquire-Node-Node\"><a href=\"#shouldParkAfterFailedAcquire-Node-Node\" class=\"headerlink\" title=\"shouldParkAfterFailedAcquire(Node, Node)\"></a>shouldParkAfterFailedAcquire(Node, Node)</h5><p> shouldParkAfterFailedAcquire方法通过对当前节点的前一个节点的状态进行判断，对当前节点做出不同的操作</p>\n<pre><code class=\"java\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n            return true;\n        if (ws &gt; 0) {\n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus &gt; 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don&#39;t park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }</code></pre>\n<h5 id=\"parkAndCheckInterrupt\"><a href=\"#parkAndCheckInterrupt\" class=\"headerlink\" title=\"parkAndCheckInterrupt()\"></a>parkAndCheckInterrupt()</h5><p>该方法让线程去休息，真正进入等待状态。park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。</p>\n<pre><code class=\"java\">private final boolean parkAndCheckInterrupt() {\n        LockSupport.park(this);\n        return Thread.interrupted();\n    }</code></pre>\n<h4 id=\"release-int\"><a href=\"#release-int\" class=\"headerlink\" title=\"release(int)\"></a>release(int)</h4><p>该方法执行时，会唤醒头节点的后继节点线程，unparkSuccessor(Node node)方法使 用 LockSupport（在后面的章节会专门介绍）来唤醒处于等待状态的线程。 分析了独占式同步状态获取和释放过程后，适当做个总结：在获取同步状态时，同 步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自 旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释 放同步状态时，同步器调用 tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后 继节点。</p>\n<p>  <code>release(int)</code>方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。</p>\n<p>与acquire()方法中的tryAcquire()类似，tryRelease()方法也是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p>\n<p><code>unparkSuccessor(Node)</code>方法用于唤醒等待队列中下一个线程。这里要注意的是，下一个线程并不一定是当前节点的next节点，而是下一个可以用来唤醒的线程，如果这个节点存在，调用<code>unpark()</code>方法唤醒。<br>  总之，release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p>\n<pre><code class=\"java\"> public final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            if (h != null &amp;&amp; h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n\n    protected boolean tryRelease(int arg) {\n        throw new UnsupportedOperationException();\n    }\n\n    private void unparkSuccessor(Node node) {\n        /*\n         * If status is negative (i.e., possibly needing signal) try\n         * to clear in anticipation of signalling.  It is OK if this\n         * fails or if status is changed by waiting thread.\n         */\n        int ws = node.waitStatus;\n        if (ws &lt; 0)\n            compareAndSetWaitStatus(node, ws, 0);\n\n        /*\n         * Thread to unpark is held in successor, which is normally\n         * just the next node.  But if cancelled or apparently null,\n         * traverse backwards from tail to find the actual\n         * non-cancelled successor.\n         */\n        Node s = node.next;\n        if (s == null || s.waitStatus &gt; 0) {\n            s = null;\n            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)\n                if (t.waitStatus &lt;= 0)\n                    s = t;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);\n    }</code></pre>\n<h3 id=\"共享式\"><a href=\"#共享式\" class=\"headerlink\" title=\"共享式\"></a>共享式</h3><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同 步状态。以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该 文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而 读操作可以是共享式访问，两种不同的访问模式在同一时刻对文件或资源的访问情况</p>\n<h4 id=\"acquireShared-int\"><a href=\"#acquireShared-int\" class=\"headerlink\" title=\"acquireShared(int)\"></a>acquireShared(int)</h4><ul>\n<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>\n<li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</li>\n</ul>\n<p><code>acquireShared(int)</code>方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。</p>\n<pre><code class=\"java\">public final void acquireShared(int arg) {\n        if (tryAcquireShared(arg) &lt; 0)\n            doAcquireShared(arg);\n    }</code></pre>\n<h5 id=\"doAcquireShared-int\"><a href=\"#doAcquireShared-int\" class=\"headerlink\" title=\"doAcquireShared(int)\"></a>doAcquireShared(int)</h5><p>  将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。</p>\n<pre><code class=\"java\">private void doAcquireShared(int arg) {\n        final Node node = addWaiter(Node.SHARED);\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head) {\n                    int r = tryAcquireShared(arg);\n                    if (r &gt;= 0) {\n                        setHeadAndPropagate(node, r);\n                        p.next = null; // help GC\n                        if (interrupted)\n                            selfInterrupt();\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                    parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }</code></pre>\n<p>跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p>\n<pre><code class=\"java\">private void setHeadAndPropagate(Node node, int propagate) {\n        Node h = head; // Record old head for check below\n        setHead(node);\n        /*\n         * Try to signal next queued node if:\n         *   Propagation was indicated by caller,\n         *     or was recorded (as h.waitStatus either before\n         *     or after setHead) by a previous operation\n         *     (note: this uses sign-check of waitStatus because\n         *      PROPAGATE status may transition to SIGNAL.)\n         * and\n         *   The next node is waiting in shared mode,\n         *     or we don&#39;t know, because it appears null\n         *\n         * The conservatism in both of these checks may cause\n         * unnecessary wake-ups, but only when there are multiple\n         * racing acquires/releases, so most need signals now or soon\n         * anyway.\n         */\n        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||\n            (h = head) == null || h.waitStatus &lt; 0) {\n            Node s = node.next;\n            if (s == null || s.isShared())\n                doReleaseShared();\n        }\n    }</code></pre>\n<p>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p>\n<h4 id=\"releaseShared-int\"><a href=\"#releaseShared-int\" class=\"headerlink\" title=\"releaseShared(int)\"></a>releaseShared(int)</h4><p>  <code>releaseShared(int)</code>方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。</p>\n<pre><code class=\"java\">public final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }</code></pre>\n<p>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。</p>\n<pre><code class=\"java\">private void doReleaseShared() {\n        /*\n         * Ensure that a release propagates, even if there are other\n         * in-progress acquires/releases.  This proceeds in the usual\n         * way of trying to unparkSuccessor of head if it needs\n         * signal. But if it does not, status is set to PROPAGATE to\n         * ensure that upon release, propagation continues.\n         * Additionally, we must loop in case a new node is added\n         * while we are doing this. Also, unlike other uses of\n         * unparkSuccessor, we need to know if CAS to reset status\n         * fails, if so rechecking.\n         */\n        for (;;) {\n            Node h = head;\n            if (h != null &amp;&amp; h != tail) {\n                int ws = h.waitStatus;\n                if (ws == Node.SIGNAL) {\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h);\n                }\n                else if (ws == 0 &amp;&amp;\n                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            if (h == head)                   // loop if head changed\n                break;\n        }\n    }</code></pre>\n<h1 id=\"并发工具类\"><a href=\"#并发工具类\" class=\"headerlink\" title=\"并发工具类\"></a>并发工具类</h1><h2 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h2><ul>\n<li>线程调用<code>countDown</code>方法会将计数器减一(调用<code>countDown</code>不会阻塞)</li>\n<li>当一个或多个线程调用<code>await</code>方法时，调用线程会被阻塞</li>\n<li>当计数器为零时，因为调用了<code>await</code>方法而被阻塞的线程会被唤醒，继续执行</li>\n<li>CountDownLatch不能重用</li>\n</ul>\n<p>用法一：一个线程等待多个线程都执行完毕，再继续自己的工作</p>\n<pre><code class=\"java\">//例如启动程序，对外发布服务时，应该所有的都检查完毕（检查数据有没有完毕等前置流程）才进入下一个环节\n//主线程等待所有线程都执行完毕才结束\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch countDownLatch = new CountDownLatch(6);\n    for (int i = 0; i &lt; 6; i++) {\n        new Thread(() -&gt; {\n            System.out.println(Thread.currentThread().getName() + &quot; 离开&quot;);\n            countDownLatch.countDown();\n        }， String.valueOf(i)).start();\n    }\n    countDownLatch.await(); // 必须要减到0才能解除\n    System.out.println(&quot;全部结束咯&quot;);\n}</code></pre>\n<p>用法二：多个线程等待某一个线程的信号，同时开始执行。</p>\n<pre><code class=\"java\">// 例如进行压测，创建很多线程应该先等待，再一个统一的时间再过去\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch countDownLatch = new CountDownLatch(1);\n    ExecutorService executorService = Executors.newFixedThreadPool(5);\n    for (int i = 0; i &lt; 5; i++) {\n        int finalI = i;\n        executorService.submit(() -&gt; {\n            System.out.println(finalI + &quot;准备完毕&quot;);\n            try {\n                countDownLatch.await();\n                System.out.println(finalI + &quot;开始跑步&quot;);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n    TimeUnit.SECONDS.sleep(5);         // 检查场地等\n    System.out.println(&quot;比赛开始！&quot;);\n    countDownLatch.countDown();\n}</code></pre>\n<h2 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h2><ul>\n<li>可以用来限制或管理数量有限资源的使用情况。实际上就相当于PV操作</li>\n<li>当一个线程调用acquire（获取），要么成功获得信号量（信号量-1），要么阻塞到有线程释放信号量</li>\n<li>release（释放），实际会将信号量的值+1，然后唤醒等待的线程</li>\n<li>可以选择公平或者非公平实现：<code>public Semaphore(int permits, boolean fair)</code></li>\n</ul>\n<pre><code class=\"java\">Semaphore semaphore = new Semaphore(3);\nfor (int i = 0; i &lt; 6; i++) {\n    new Thread(()-&gt;{\n        try {\n            semaphore.acquire();\n            System.out.println(Thread.currentThread().getName()+&quot; 抢到车位&quot;);\n            TimeUnit.SECONDS.sleep(2);\n            System.out.println(Thread.currentThread().getName()+&quot; 离开车位&quot;);\n        }\n        catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        finally {\n            semaphore.release();\n        }\n    }，String.valueOf(i)).start();\n}</code></pre>\n<h2 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h2><ul>\n<li>可循环(<code>Cyclic</code>)使用的屏障(<code>Barrier</code>)</li>\n<li>让一组线程到达一个屏障(同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续干活</li>\n<li>线程进入屏障是通过<code>CyclicBarrier</code>的<code>await()</code>方法</li>\n</ul>\n<pre><code class=\"java\">public static void main(String[] args) {\n    CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; {\n        System.out.println(&quot;大威天龙!&quot;);\n    });\n    for (int i = 0; i &lt; 7; i++) {\n        int finalI = i+1;\n        new Thread(()-&gt;{\n            System.out.println(Thread.currentThread().getName()+ &quot; 收集龙珠&quot;+finalI );\n            try {\n                cyclicBarrier.await();\n            }\n            catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        },&quot;thread&quot;+String.valueOf(i)).start();\n    }\n}</code></pre>\n"},{"title":"运行时数据区","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"包括Java运行时数据区、对象内存布局、异常演示、故障处理工具等","abbrlink":"11595de","date":"2021-01-31T16:00:00.000Z","_content":"\n# 内存区域\n\n## 运行时数据区域\n\n### 程序计数器\n\n+ 当前线程所执行字节码的行号指示器\n+ 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令\n+ 某一刻，一个处理器只会执行一个线程中的指令\n+ 为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器\n+ 即线程私有的内存\n+ Java方法，则记录正在执行的虚拟机字节码指令的地址\n+ Native方法，则计数器值为空\n+ 唯一一个没有OutOfMemoryError情况的区域\n\n### 虚拟机栈\n\n+ 线程私有，生命周期与线程相同\n+ 每个方法被调用直到执行完毕的过程，就对应一个栈帧从入栈到出栈的过程\n+ 每个方法被执行时，JVM都会创建一个栈帧\n\n**栈帧**\n\n+ 局部变量表\n    + 存储编译器可知的数据：基本数据类型、对象引用（可能是一个指向对象起始地址的引用指针、也可能是指向一个代表对象的句柄）、returnAddress类型（指向一条字节码指令的地址）\n    + 以局部变量槽存储，其中64位的long和double占用两个变量槽\n    + 所需的内存空间在编译期间完成分配\n    + 进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间完全确定\n+ 操作数栈\n+ 动态连接\n+ 方法出口\n\n**异常**\n\n+ StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度\n+ OutOfMemoryError异常\n    + 如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时\n    + HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM\n\n### 本地方法栈\n\n+ 虚拟机栈是为JVM执行Java方法（字节码）服务\n+ 本地方法栈是为了使用Native方法服务\n+ HotSpot虚拟机把虚拟机栈，本地方法栈合二为一了\n\n### 堆\n\n+ Java堆是被所有线程共享的一块内存区域，在JVM启动时创建\n+ 用于存放对象实例\n+ 几乎所有对象实例都在这里分配内存\n    + 所有的对象实例以及数组都应在堆上分配\n    + 由于逃逸分析技术，一些优化手段如栈上分配、标量替换等，使得对象实例都分配在堆上不是这么绝对\n+ 是垃圾收集器管理的内存区域\n+ 可以划分出多个线程私有的分配缓冲区以提升对象分配时的效率：Thread Local Allocation Buffer(TLAB)\n+ 可以处于物理上不连续的内存空间中，但在逻辑上是连续的。但对于大对象，例如数组对象，多数虚拟机都处于实现简单、存储高效的考虑，可能要求连续的内存空间\n+ 可扩展，通过参数-Xms、-Xmx设定\n+ 如果堆中没有内存完成实例分配，并且堆无法扩展，则OOM异常\n\n**字符串常量池**\n\n字符串池/字符串常量池/字符串对象池/String Pool/String Table 都可以看作一个东西。\n\n### 方法区\n\n**理解**\n\n+ 是各个线程共享的内存区域\n+ 存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存数据等\n+ 内存回收目标主要是针对常量池的回收和类型的卸载\n+ 方法区无法满足新的内存分配需求时，抛出OOM异常\n\n**结构**\n\n+ 运行时常量池\n    + 保存Class文件中描述的符号引用\n    + 由符号引用翻译出来的直接引用\n    + 与Class文件常量池区别是局部动态性。即常量不一定只有编译期产生，即并不是预置于Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以把新的常量放入池中，例如String的intern（）方法。\n    + 无法满足新的内存分配需求时，抛出OOM异常\n+ class文件信息\n    + 类的版本、字段、方法、接口等\n    + 常量池表：存放编译期生成的各种字面量与符号引用，在类加载后存放到方法区的运行时常量池中\n\n**元空间**\n\n+ 元空间” 和 “方法区”，一个是HotSpot 的具体实现技术，一个是JVM规范的抽象定义；\n+ 类型信息全部移到元空间中\n+ 元空间是使用本地内存（Native Memory）实现的，也就是说它的内存是不在虚拟机内的，所以可以理论上物理机器还有多个内存就可以分配，而不用再受限于JVM本身分配的内存了。\n\n### 直接内存\n\n+ 不是运行时数据区的一部分，但是频繁使用到，也会OOM\n+ NIO引入了基于管道与缓冲区的IO方式，可以使用Native函数库直接分配堆外内存\n+ 直接内存的分配不会受到堆的大小限制，但受到本机总内存限制\n\n## 对象\t\n\n### 对象创建\n\n+ 能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过。没有则执行类加载过程\n+ 为新生对象分配内存，类加载完成时即可确定对象所需的内存大小\n    + **堆中内存分配**\n        + 绝对规整则采用**指针碰撞**，所有被使用过的内存都被放在一边，空闲的内存在另一边，中间放这一个指针作为分界点的指示器。分配内存就是把那个指针向空闲空间方向挪动一段和对象内存大小相等的距离\n        + 否则**空闲列表**：在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录\n        + 是否规整由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定：Serial、ParNew带压缩整理、CMS基于清除（Sweep）算法，不带压缩整理\n    + **分配内存有并发性**\n        + 可以对分配内存空间的动作进行同步处理，采用**CAS配上失败重试**来保证更新操作的原子性\n        + 或把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在堆中预先分配一小块内存，称为本地线程分配缓存**TLAB**，哪个线程需要分配内存，就在他的TLAB中分配，本地缓冲区用完才需要同步锁定。\n+ 为分配到的内存空间（不包括对象头）都初始化为零值，保证了对象的实例字段在代码中可以不赋初始值即可使用\n+ 对对象进行相应设置（存放在对象头中）：这个对象是哪个类的实例、如何能找到类的元数据信息、对象的哈希码（延后到真正调用Object::HashCode()方法才计算）、对象的GC分代年龄\n+ 构造函数<init>()方法，按照程序员的意愿对对象进行初始化\n\n### 对象的内存布局\n\n+ 对象头(Header)\n    + **Mark Word**\n        + 存储自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳\n        + 在32位和64位（未开启压缩指针）虚拟机中分别位32比特和64比特\n        + 有着动态定义的数据结构，根据对象的状态复用自己的存储空间\n    + **类型指针**\n        + 指向对象的类型元数据的指针\n        + 查找对象的元数据信息并不一定要经过对象本身\n    + **记录数组长度的数据**\n        + 虚拟机可以通过元数据信息确定Java对象的大小，但是如果数组的长度不确定，无法通过元数据信息推断数组的大小\n+ 实例数据（Instance Data)\n    + 对象真正存储的有效信息，即定义的各种类型的字段内容\n    + 无论是从父类继承的还是子类中定义的都记录\n    + 存储顺序策略\n        + longs/doubles、ints、shorts、chars、bytes/booleans、oops（Ordinary Object Pointers）\n        + 相同宽度的字段分配在一起存放\n        + 满足上面情况下，父类中定义的变量在子类之前\n+ 对齐填充（Padding）\n    + 对象起始地址必须是8字节的整数倍\n    + 对象头已经是8字节的整数倍了（1倍或两倍）\n\n### 对象访问定位\n\n+ 通过栈上的reference数据来操作堆上的具体对象\n+ 访问堆对象具体位置\n    + 句柄访问\n        + 划分一部分为句柄池\n        + reference中存储对象的句柄地址\n        + 句柄中包含对象实例数据和类型数据各自具体的地址\n        + 存储的是稳定句柄地址，对象移动只改变句柄，不需要改变reference\n    + 直接指针访问\n        + reference中直接存储对象地址\n        + 速度更快，节省了一次指针定位的时间开销\n        + HotSpot采用直接指针访问\n\n\n\n# 异常演示\n\n## Java堆异常\n\n只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，总容量触及最大堆容量限制即OOM\n\n设置堆最小值 -Xms参数和堆最大值参数 -Xmx一样即可避免堆自动扩展\n\n-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机再出现内存溢出异常时Dump出当前内存堆存储快照以便事后分析\n\n```\n-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError\n```\n\n```java\npackage com.tongji.test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HeapOOM {\n    static class OOMObject{\n\n    }\n\n    public static void main(String[] args) {\n        List<OOMObject> list = new ArrayList<>();\n        while (true) {\n            list.add(new OOMObject());\n        }\n    }\n}\n```\n\n```java\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n```\n\n**处理方法**\n\n+ 通过内存映像分析工具对Dump出来的堆存储快照进行分析\n+ 首先确认内存中导致OOM的对象是否有必要存在,即是出现内存泄漏,还是内存溢出\n    + 内存泄漏,则查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收他们\n    + 内存溢出，则内存中对象确实是必须存活的，就应该检查堆参数设置（-Xms -Xmx），与机器内存对比，是否有向上调整的空间，再从代码中检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设置不合理等，尽量减少程序运行期的内存消耗\n\n## 虚拟机栈和本地方法栈溢出 \n\n**原理**\n\n+ 线程请求的栈深度大于虚拟机所允许的深度抛出StackOverflowError异常，例如调用的方法太多（递归）\n+ 如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时抛出OutOfMemoryError异常\n    + HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM\n    + 否则线程运行时不会因为扩展而导致内存溢出，只会因为栈容量无法容纳新的栈帧导致StackOverflowError异常\n+ 写一个死递归程序触发\n\n**实验**\n\n+ 使用-Xss减少栈内存容量\n+ 定义大量本地变量，增大次方法帧中本地变量表的长度\n+ 无论是栈帧太大还是虚拟机容量太小，当新的栈帧内存无法分配时，抛出的都是StackOverflowError异常\n+ 有明确的错误栈帧可供分析，栈深度达到1000-2000完全没问题，对于正常的方法调用完全足够了\n\n**使用-Xss减少栈内存容量**\n\n```\n-Xss128k\n```\n\n```java\npackage com.tongji.test;\n\npublic class StackSOF {\n    private int stackLength = 1;\n\n    private void stackLeak() {\n        stackLength++;\n        stackLeak();\n    }\n\n    public static void main(String[] args) {\n        StackSOF oom = new StackSOF();\n        try\n        {\n            oom.stackLeak();\n        }\n        catch (Throwable e)\n        {\n            System.out.println(\"stack length:\"+oom.stackLength);\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```\nstack length:985\njava.lang.StackOverflowError\n```\n\n**定义大量本地变量，增大次方法帧中本地变量表的长度**\n\n```java\npackage com.tongji.test;\n\npublic class StackSOF {\n    private int stackLength = 1;\n\n    private void stackLeak() {\n        long unused0, unused1, unused2, unused3;\n        long unused10, unused11, unused12, unused13;\n        long unused20, unused21, unused22, unused23;\n        stackLength++;\n        stackLeak();\n        unused0 = unused1 = unused2 = unused3 =\n                unused10 = unused11 = unused12 = unused13 =\n                        unused20 = unused21 = unused22 = unused23 = 0;\n    }\n\n    public static void main(String[] args) {\n        StackSOF oom = new StackSOF();\n        try {\n            oom.stackLeak();\n        }\n        catch (Throwable e) {\n            System.out.println(\"stack length:\" + oom.stackLength);\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```\nstack length:311\njava.lang.StackOverflowError\n```\n\n\n\n## 方法区和运行时常量池的溢出\n\n+ 基本思路是运行时产生大量的类去填满方法区直到溢出为止\n+ 许多框架如Spring，都会使用CGLib这类字节码技术\n+ 当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存\n+ 方法区是常见的内存溢出异常，因为一个类如果要被垃圾收集器回收，要达成的条件比较苛刻。在经常运行生成大量动态类的应用场景中，就应该特别关注这些类的回收状况\n+ JDK8后，使用了元空间,正常的动态创建新类型的测试用例很难迫使虚拟机产生方法区的溢出异常了\n+ -XX:MaxMetaspaceSize设置元空间最大值，默认是-1，即不限制，或者说只限制与本地内存大小\n+ -XX:MetaspaceSize指定元空间初始空间大小，以字节为单位，达到该值则触发垃圾收集进行类型卸载\n+ -XX:MinMetaspaceFreeRatio在垃圾收集之后控制最小的元空间剩余容量百分比，可以减少因为元空间不足导致的垃圾收集的频率\n\n```java\npackage com.tongji.test;\n\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\n\npublic class JavaMethodAreaOOM {\n    static class OOMObject {\n\n    }\n\n    public static void main(String[] args) {\n        while (true) {\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() {\n                @Override\n                public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                    return methodProxy.invokeSuper(objects, args);\n                }\n            });\n        }\n    }\n}\n```\n\n## 本地直接内存溢出\n\n+ 容量大小通过-XX:MaxDirectMemorySize指定,默认与Java堆最大值(-Xmx)一致\n+ 由直接内存溢出明显特征是Heap Dump中看不见什么异常情况,如果发现内存溢出后Dump文件很小,而又使用了DirectMemory(如NIO),则可以重点检查下直接内存方面的原因\n+ 通过反射获取Unsafe类，并不断分配内存给静态常量\n\n```java\npackage com.tongji.test;\n\nimport sun.misc.Unsafe;\n\nimport java.lang.reflect.Field;\n\npublic class DirectMemoryOOM {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) throws IllegalAccessException {\n        Field unsafeField = Unsafe.class.getDeclaredFields()[0];\n        unsafeField.setAccessible(true);\n        Unsafe unsafe = (Unsafe) unsafeField.get(null);\n        while (true) {\n            unsafe.allocateMemory(_1MB);\n        }\n    }\n\n}\n```\n\n```java\nException in thread \"main\" java.lang.OutOfMemoryError\n\tat sun.misc.Unsafe.allocateMemory(Native Method)\n\tat com.tongji.test.DirectMemoryOOM.main(DirectMemoryOOM.java:15)\n```\n\n# 基础故障处理工具\n\n+ 这些命令行工具大多仅是一层薄包装，真正的功能代码是实现在JDK的工具类库里\n+ 借助这些工具类库，应用程序部署生产环境后，开发者可以选择直接在应用程序中提供功能强大的监控分析功能\n\n## jps\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608769939_1.png)\n\n+ JVM Process Status\n+ 虚拟机进程状况工具\n+ 是使用频率最高的JDK命令行工具\n+ 列出正在运行的虚拟机进程\n+ 显示虚拟机执行主类名称（main()方法所在的类）、这些进程的本地虚拟机唯一ID（LVMID） Local Virtual Machine Identifier\n+ 其他JDK工具需要他查询到的LVMID来确定要监控的是哪一个虚拟机进程\n+ 对于本地虚拟机进程，LVMID与PID一致；ps指令也可以查询到虚拟机进程的LVMID，但如果同时启动多个虚拟机进程，则必须依赖jps命令显示主类的功能\n\n**参数**\n\njps -l\n\n输出主类的全名，如果进程执行的是JAR包，则输出JAR的路径\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770201_2.png)\n\njps -v\n\n输出虚拟机进程启动时的JVM参数\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770291_3.png)\n\n## jstat\n\n+ 虚拟机统计信息监视工具\n+ JVM Statistics Monitoring Tool\n+ 用于监视虚拟机各种运行状态信息的命令行工具\n+ 显示本地或远程虚拟机进程中的类加载，内存，垃圾回收，即时编译器等运行时数据\n+ 在只提供控制台环境的服务器，他是运行期定位虚拟机性能问题的常用工具\n\n**参数**\n\n+ jstat [ option vmid [interval [s|ms] [count] ] ]\n+ 本地虚拟机进程，则VMID与LVMID一致\n+ interval和count代表查询间隔和次数，忽略则只查询一次\n+ 例如 jstat -gc 4218 250 5\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770710_4.png)\n\n+ jstat -gcutil 4218\n    + 输出已使用空间占总空间百分比\n    + Eden使用了78.74%，S0为空，S1使用32.88%\n    + 老年代（O）使用了61.65%\n    + 元空间（M）使用了94.75\n    + 程序运行以来Minor GC（YGC）发生了603次，用了4.85s\n    + 发生Full GC(FGC)5次，用了1.611s\n    + 所有GC总耗时（GCT）为6.462s\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770952_6.png)\n\n## jmap\n\n+ Java内存映像工具\n+ Memory Map for Java\n+ jmap -dump:live,format=b,file=a.log 4218\n    + 用于生成堆转储快照\n    + 再把生成的a.log进行分析\n+ jmap -heap 4218\n    + 显示Java堆详细详细，如使用哪种回收器，参数配置，分代情况等\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772363_7.png)\n\n## jstack\n\n+ Java堆栈跟踪工具\n+ Stack Trace for Java\n+ 用于生成虚拟机当前时刻的线程快照\n    + 即当前虚拟机内每一条线程正在执行的方法堆栈的集合\n    + 目的是定位线程出现长时间停顿的原因\n    + 如线程间死锁、死循环、请求外部资源导致的长时间挂起等\n    + 线程出现停顿时，通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做什么事情，或者等待什么资源\n+ jstack -l 4218 ：-l 除堆栈外，显示关于锁的附加信息\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772914_8.png)\n\n# 可视化故障处理工具\n\n## JConsole\n\n+ Java监视与管理控制台\n+ 通过JDK/bin命令下的jconsole.exe启动JConsole\n+ 他会自动搜索出本机运行的所有虚拟机进程，即完成jps的功能\n\n### 内存监控\n\n+ 相当于可视化的jstat命令\n+ 用于监视被收集器管理的虚拟机内存\n\n```java\n//-Xms100m -Xmx100m -XX:+UseSerialGC\n\npublic class Main {\n    //内存占位符对象,一个OOM大约64KB\n    static class OOMObject {\n        public byte[] placeholder = new byte[64 * 1024];\n    }\n    public static void fillHeap(int num) throws InterruptedException {\n        List<OOMObject> list = new ArrayList<>();\n        for (int i = 0; i < num; i++) {\n            //让监视曲线变化更加明显\n            Thread.sleep(50);\n            list.add(new OOMObject());\n        }\n\t\tSystem.gc();\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        fillHeap(1000);\n    }\n}\n```\n\n+ Eden区的运行趋势呈折现状\n+ 整个堆曲线平滑向上增长\n+ 在System.GC后，Eden与Survivor区被清空，但是老年代的保持峰值，说明被填充进堆中的数据在System.gc（）后仍然存活\n+ 在System.gc();时，list对象仍然处于作用域之内，就不会回收，如果把System.gc();移动到方法外调用即可回收掉全部内存\n\n### 线程监控\n\n+ 相当于jstack，遇到线程停顿的时候用\n\n**案例**\n\n```java\npublic class Main {\n    //线程死循环演示\n    public static void createBusyThread() {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (true) { //第12行\n\n                }\n            }\n        }, \"testBusyThread\").start();\n    }\n\n    //线程锁等待演示\n    public static void createLockThread(final Object lock) {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                synchronized (lock) {\n                    try {\n                        lock.wait();\n                    }\n                    catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }, \"testLockThread\").start();\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        bufferedReader.readLine();\n        createBusyThread();\n        bufferedReader.readLine();\n        Object object = new Object();\n        createLockThread(object);\n    }\n}\n```\n\n+ 首先在线程页签中选择main线程\n    + 堆栈追踪显示BufferedReader的readBytes()方法正在等待System.in的键盘输入\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775371_11.png)\n+ 接着监控testBusyThread线程\n    + 他一直在执行空循环\n    + 一直在第14行停留，即while(true)\n    + 线程为Runnable状态，而且没有归还线程执行令牌的动作，所以会在空循环耗尽操作系统分配给他的执行时间，直到线程切换为止\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775349_10.png)\n+ testLockThread\n    + 在等待lock对象的notify()或notifyAll()方法的出现\n    + 处于WAITING状态，在重新唤醒前不会被分配执行时间\n    + 处于正常的活锁等待，lock对象的notify()或notifyAll()方法被调用这个线程便能继续执行\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775531_12.png)\n\n**死锁案例**\n\n```java\npublic class Main {\n    static class SynAddRunnable implements Runnable {\n        int a, b;\n\n        public SynAddRunnable(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public void run() {\n            synchronized (Integer.valueOf(a)) {\n                synchronized (Integer.valueOf(b)) {\n                    System.out.println(a + b);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 100; i++) {\n            new Thread(new SynAddRunnable(1, 2)).start();\n            new Thread(new SynAddRunnable(2, 1)).start();\n        }\n    }\n}\n```\n\n根本原因是Integer.valueOf()会对[-128,127]对象进行缓存，如果valueOf()传入的参数在范围内，则直接返回缓存中的对象\n\n假设线程A在两个synchronized块之间发生了一次线程切换，就会出现线程A等待线程B持有的Integer.valueOf(1),线程B又在等待被线程A持有的Integer.valueOf(2)\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608776488_13.png)","source":"_posts/Java语言/Java虚拟机/1.运行时数据区.md","raw":"---\ntitle: 运行时数据区\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 包括Java运行时数据区、对象内存布局、异常演示、故障处理工具等\ncategories: Java虚拟机\ntags:\n  - 运行时数据区\n  - 异常\n  - 工具\nabbrlink: 11595de\ndate: 2021-02-01 00:00:00\n---\n\n# 内存区域\n\n## 运行时数据区域\n\n### 程序计数器\n\n+ 当前线程所执行字节码的行号指示器\n+ 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令\n+ 某一刻，一个处理器只会执行一个线程中的指令\n+ 为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器\n+ 即线程私有的内存\n+ Java方法，则记录正在执行的虚拟机字节码指令的地址\n+ Native方法，则计数器值为空\n+ 唯一一个没有OutOfMemoryError情况的区域\n\n### 虚拟机栈\n\n+ 线程私有，生命周期与线程相同\n+ 每个方法被调用直到执行完毕的过程，就对应一个栈帧从入栈到出栈的过程\n+ 每个方法被执行时，JVM都会创建一个栈帧\n\n**栈帧**\n\n+ 局部变量表\n    + 存储编译器可知的数据：基本数据类型、对象引用（可能是一个指向对象起始地址的引用指针、也可能是指向一个代表对象的句柄）、returnAddress类型（指向一条字节码指令的地址）\n    + 以局部变量槽存储，其中64位的long和double占用两个变量槽\n    + 所需的内存空间在编译期间完成分配\n    + 进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间完全确定\n+ 操作数栈\n+ 动态连接\n+ 方法出口\n\n**异常**\n\n+ StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度\n+ OutOfMemoryError异常\n    + 如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时\n    + HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM\n\n### 本地方法栈\n\n+ 虚拟机栈是为JVM执行Java方法（字节码）服务\n+ 本地方法栈是为了使用Native方法服务\n+ HotSpot虚拟机把虚拟机栈，本地方法栈合二为一了\n\n### 堆\n\n+ Java堆是被所有线程共享的一块内存区域，在JVM启动时创建\n+ 用于存放对象实例\n+ 几乎所有对象实例都在这里分配内存\n    + 所有的对象实例以及数组都应在堆上分配\n    + 由于逃逸分析技术，一些优化手段如栈上分配、标量替换等，使得对象实例都分配在堆上不是这么绝对\n+ 是垃圾收集器管理的内存区域\n+ 可以划分出多个线程私有的分配缓冲区以提升对象分配时的效率：Thread Local Allocation Buffer(TLAB)\n+ 可以处于物理上不连续的内存空间中，但在逻辑上是连续的。但对于大对象，例如数组对象，多数虚拟机都处于实现简单、存储高效的考虑，可能要求连续的内存空间\n+ 可扩展，通过参数-Xms、-Xmx设定\n+ 如果堆中没有内存完成实例分配，并且堆无法扩展，则OOM异常\n\n**字符串常量池**\n\n字符串池/字符串常量池/字符串对象池/String Pool/String Table 都可以看作一个东西。\n\n### 方法区\n\n**理解**\n\n+ 是各个线程共享的内存区域\n+ 存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存数据等\n+ 内存回收目标主要是针对常量池的回收和类型的卸载\n+ 方法区无法满足新的内存分配需求时，抛出OOM异常\n\n**结构**\n\n+ 运行时常量池\n    + 保存Class文件中描述的符号引用\n    + 由符号引用翻译出来的直接引用\n    + 与Class文件常量池区别是局部动态性。即常量不一定只有编译期产生，即并不是预置于Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以把新的常量放入池中，例如String的intern（）方法。\n    + 无法满足新的内存分配需求时，抛出OOM异常\n+ class文件信息\n    + 类的版本、字段、方法、接口等\n    + 常量池表：存放编译期生成的各种字面量与符号引用，在类加载后存放到方法区的运行时常量池中\n\n**元空间**\n\n+ 元空间” 和 “方法区”，一个是HotSpot 的具体实现技术，一个是JVM规范的抽象定义；\n+ 类型信息全部移到元空间中\n+ 元空间是使用本地内存（Native Memory）实现的，也就是说它的内存是不在虚拟机内的，所以可以理论上物理机器还有多个内存就可以分配，而不用再受限于JVM本身分配的内存了。\n\n### 直接内存\n\n+ 不是运行时数据区的一部分，但是频繁使用到，也会OOM\n+ NIO引入了基于管道与缓冲区的IO方式，可以使用Native函数库直接分配堆外内存\n+ 直接内存的分配不会受到堆的大小限制，但受到本机总内存限制\n\n## 对象\t\n\n### 对象创建\n\n+ 能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过。没有则执行类加载过程\n+ 为新生对象分配内存，类加载完成时即可确定对象所需的内存大小\n    + **堆中内存分配**\n        + 绝对规整则采用**指针碰撞**，所有被使用过的内存都被放在一边，空闲的内存在另一边，中间放这一个指针作为分界点的指示器。分配内存就是把那个指针向空闲空间方向挪动一段和对象内存大小相等的距离\n        + 否则**空闲列表**：在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录\n        + 是否规整由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定：Serial、ParNew带压缩整理、CMS基于清除（Sweep）算法，不带压缩整理\n    + **分配内存有并发性**\n        + 可以对分配内存空间的动作进行同步处理，采用**CAS配上失败重试**来保证更新操作的原子性\n        + 或把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在堆中预先分配一小块内存，称为本地线程分配缓存**TLAB**，哪个线程需要分配内存，就在他的TLAB中分配，本地缓冲区用完才需要同步锁定。\n+ 为分配到的内存空间（不包括对象头）都初始化为零值，保证了对象的实例字段在代码中可以不赋初始值即可使用\n+ 对对象进行相应设置（存放在对象头中）：这个对象是哪个类的实例、如何能找到类的元数据信息、对象的哈希码（延后到真正调用Object::HashCode()方法才计算）、对象的GC分代年龄\n+ 构造函数<init>()方法，按照程序员的意愿对对象进行初始化\n\n### 对象的内存布局\n\n+ 对象头(Header)\n    + **Mark Word**\n        + 存储自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳\n        + 在32位和64位（未开启压缩指针）虚拟机中分别位32比特和64比特\n        + 有着动态定义的数据结构，根据对象的状态复用自己的存储空间\n    + **类型指针**\n        + 指向对象的类型元数据的指针\n        + 查找对象的元数据信息并不一定要经过对象本身\n    + **记录数组长度的数据**\n        + 虚拟机可以通过元数据信息确定Java对象的大小，但是如果数组的长度不确定，无法通过元数据信息推断数组的大小\n+ 实例数据（Instance Data)\n    + 对象真正存储的有效信息，即定义的各种类型的字段内容\n    + 无论是从父类继承的还是子类中定义的都记录\n    + 存储顺序策略\n        + longs/doubles、ints、shorts、chars、bytes/booleans、oops（Ordinary Object Pointers）\n        + 相同宽度的字段分配在一起存放\n        + 满足上面情况下，父类中定义的变量在子类之前\n+ 对齐填充（Padding）\n    + 对象起始地址必须是8字节的整数倍\n    + 对象头已经是8字节的整数倍了（1倍或两倍）\n\n### 对象访问定位\n\n+ 通过栈上的reference数据来操作堆上的具体对象\n+ 访问堆对象具体位置\n    + 句柄访问\n        + 划分一部分为句柄池\n        + reference中存储对象的句柄地址\n        + 句柄中包含对象实例数据和类型数据各自具体的地址\n        + 存储的是稳定句柄地址，对象移动只改变句柄，不需要改变reference\n    + 直接指针访问\n        + reference中直接存储对象地址\n        + 速度更快，节省了一次指针定位的时间开销\n        + HotSpot采用直接指针访问\n\n\n\n# 异常演示\n\n## Java堆异常\n\n只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，总容量触及最大堆容量限制即OOM\n\n设置堆最小值 -Xms参数和堆最大值参数 -Xmx一样即可避免堆自动扩展\n\n-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机再出现内存溢出异常时Dump出当前内存堆存储快照以便事后分析\n\n```\n-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError\n```\n\n```java\npackage com.tongji.test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HeapOOM {\n    static class OOMObject{\n\n    }\n\n    public static void main(String[] args) {\n        List<OOMObject> list = new ArrayList<>();\n        while (true) {\n            list.add(new OOMObject());\n        }\n    }\n}\n```\n\n```java\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n```\n\n**处理方法**\n\n+ 通过内存映像分析工具对Dump出来的堆存储快照进行分析\n+ 首先确认内存中导致OOM的对象是否有必要存在,即是出现内存泄漏,还是内存溢出\n    + 内存泄漏,则查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收他们\n    + 内存溢出，则内存中对象确实是必须存活的，就应该检查堆参数设置（-Xms -Xmx），与机器内存对比，是否有向上调整的空间，再从代码中检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设置不合理等，尽量减少程序运行期的内存消耗\n\n## 虚拟机栈和本地方法栈溢出 \n\n**原理**\n\n+ 线程请求的栈深度大于虚拟机所允许的深度抛出StackOverflowError异常，例如调用的方法太多（递归）\n+ 如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时抛出OutOfMemoryError异常\n    + HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM\n    + 否则线程运行时不会因为扩展而导致内存溢出，只会因为栈容量无法容纳新的栈帧导致StackOverflowError异常\n+ 写一个死递归程序触发\n\n**实验**\n\n+ 使用-Xss减少栈内存容量\n+ 定义大量本地变量，增大次方法帧中本地变量表的长度\n+ 无论是栈帧太大还是虚拟机容量太小，当新的栈帧内存无法分配时，抛出的都是StackOverflowError异常\n+ 有明确的错误栈帧可供分析，栈深度达到1000-2000完全没问题，对于正常的方法调用完全足够了\n\n**使用-Xss减少栈内存容量**\n\n```\n-Xss128k\n```\n\n```java\npackage com.tongji.test;\n\npublic class StackSOF {\n    private int stackLength = 1;\n\n    private void stackLeak() {\n        stackLength++;\n        stackLeak();\n    }\n\n    public static void main(String[] args) {\n        StackSOF oom = new StackSOF();\n        try\n        {\n            oom.stackLeak();\n        }\n        catch (Throwable e)\n        {\n            System.out.println(\"stack length:\"+oom.stackLength);\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```\nstack length:985\njava.lang.StackOverflowError\n```\n\n**定义大量本地变量，增大次方法帧中本地变量表的长度**\n\n```java\npackage com.tongji.test;\n\npublic class StackSOF {\n    private int stackLength = 1;\n\n    private void stackLeak() {\n        long unused0, unused1, unused2, unused3;\n        long unused10, unused11, unused12, unused13;\n        long unused20, unused21, unused22, unused23;\n        stackLength++;\n        stackLeak();\n        unused0 = unused1 = unused2 = unused3 =\n                unused10 = unused11 = unused12 = unused13 =\n                        unused20 = unused21 = unused22 = unused23 = 0;\n    }\n\n    public static void main(String[] args) {\n        StackSOF oom = new StackSOF();\n        try {\n            oom.stackLeak();\n        }\n        catch (Throwable e) {\n            System.out.println(\"stack length:\" + oom.stackLength);\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```\nstack length:311\njava.lang.StackOverflowError\n```\n\n\n\n## 方法区和运行时常量池的溢出\n\n+ 基本思路是运行时产生大量的类去填满方法区直到溢出为止\n+ 许多框架如Spring，都会使用CGLib这类字节码技术\n+ 当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存\n+ 方法区是常见的内存溢出异常，因为一个类如果要被垃圾收集器回收，要达成的条件比较苛刻。在经常运行生成大量动态类的应用场景中，就应该特别关注这些类的回收状况\n+ JDK8后，使用了元空间,正常的动态创建新类型的测试用例很难迫使虚拟机产生方法区的溢出异常了\n+ -XX:MaxMetaspaceSize设置元空间最大值，默认是-1，即不限制，或者说只限制与本地内存大小\n+ -XX:MetaspaceSize指定元空间初始空间大小，以字节为单位，达到该值则触发垃圾收集进行类型卸载\n+ -XX:MinMetaspaceFreeRatio在垃圾收集之后控制最小的元空间剩余容量百分比，可以减少因为元空间不足导致的垃圾收集的频率\n\n```java\npackage com.tongji.test;\n\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\n\npublic class JavaMethodAreaOOM {\n    static class OOMObject {\n\n    }\n\n    public static void main(String[] args) {\n        while (true) {\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() {\n                @Override\n                public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                    return methodProxy.invokeSuper(objects, args);\n                }\n            });\n        }\n    }\n}\n```\n\n## 本地直接内存溢出\n\n+ 容量大小通过-XX:MaxDirectMemorySize指定,默认与Java堆最大值(-Xmx)一致\n+ 由直接内存溢出明显特征是Heap Dump中看不见什么异常情况,如果发现内存溢出后Dump文件很小,而又使用了DirectMemory(如NIO),则可以重点检查下直接内存方面的原因\n+ 通过反射获取Unsafe类，并不断分配内存给静态常量\n\n```java\npackage com.tongji.test;\n\nimport sun.misc.Unsafe;\n\nimport java.lang.reflect.Field;\n\npublic class DirectMemoryOOM {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) throws IllegalAccessException {\n        Field unsafeField = Unsafe.class.getDeclaredFields()[0];\n        unsafeField.setAccessible(true);\n        Unsafe unsafe = (Unsafe) unsafeField.get(null);\n        while (true) {\n            unsafe.allocateMemory(_1MB);\n        }\n    }\n\n}\n```\n\n```java\nException in thread \"main\" java.lang.OutOfMemoryError\n\tat sun.misc.Unsafe.allocateMemory(Native Method)\n\tat com.tongji.test.DirectMemoryOOM.main(DirectMemoryOOM.java:15)\n```\n\n# 基础故障处理工具\n\n+ 这些命令行工具大多仅是一层薄包装，真正的功能代码是实现在JDK的工具类库里\n+ 借助这些工具类库，应用程序部署生产环境后，开发者可以选择直接在应用程序中提供功能强大的监控分析功能\n\n## jps\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608769939_1.png)\n\n+ JVM Process Status\n+ 虚拟机进程状况工具\n+ 是使用频率最高的JDK命令行工具\n+ 列出正在运行的虚拟机进程\n+ 显示虚拟机执行主类名称（main()方法所在的类）、这些进程的本地虚拟机唯一ID（LVMID） Local Virtual Machine Identifier\n+ 其他JDK工具需要他查询到的LVMID来确定要监控的是哪一个虚拟机进程\n+ 对于本地虚拟机进程，LVMID与PID一致；ps指令也可以查询到虚拟机进程的LVMID，但如果同时启动多个虚拟机进程，则必须依赖jps命令显示主类的功能\n\n**参数**\n\njps -l\n\n输出主类的全名，如果进程执行的是JAR包，则输出JAR的路径\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770201_2.png)\n\njps -v\n\n输出虚拟机进程启动时的JVM参数\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770291_3.png)\n\n## jstat\n\n+ 虚拟机统计信息监视工具\n+ JVM Statistics Monitoring Tool\n+ 用于监视虚拟机各种运行状态信息的命令行工具\n+ 显示本地或远程虚拟机进程中的类加载，内存，垃圾回收，即时编译器等运行时数据\n+ 在只提供控制台环境的服务器，他是运行期定位虚拟机性能问题的常用工具\n\n**参数**\n\n+ jstat [ option vmid [interval [s|ms] [count] ] ]\n+ 本地虚拟机进程，则VMID与LVMID一致\n+ interval和count代表查询间隔和次数，忽略则只查询一次\n+ 例如 jstat -gc 4218 250 5\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770710_4.png)\n\n+ jstat -gcutil 4218\n    + 输出已使用空间占总空间百分比\n    + Eden使用了78.74%，S0为空，S1使用32.88%\n    + 老年代（O）使用了61.65%\n    + 元空间（M）使用了94.75\n    + 程序运行以来Minor GC（YGC）发生了603次，用了4.85s\n    + 发生Full GC(FGC)5次，用了1.611s\n    + 所有GC总耗时（GCT）为6.462s\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770952_6.png)\n\n## jmap\n\n+ Java内存映像工具\n+ Memory Map for Java\n+ jmap -dump:live,format=b,file=a.log 4218\n    + 用于生成堆转储快照\n    + 再把生成的a.log进行分析\n+ jmap -heap 4218\n    + 显示Java堆详细详细，如使用哪种回收器，参数配置，分代情况等\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772363_7.png)\n\n## jstack\n\n+ Java堆栈跟踪工具\n+ Stack Trace for Java\n+ 用于生成虚拟机当前时刻的线程快照\n    + 即当前虚拟机内每一条线程正在执行的方法堆栈的集合\n    + 目的是定位线程出现长时间停顿的原因\n    + 如线程间死锁、死循环、请求外部资源导致的长时间挂起等\n    + 线程出现停顿时，通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做什么事情，或者等待什么资源\n+ jstack -l 4218 ：-l 除堆栈外，显示关于锁的附加信息\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772914_8.png)\n\n# 可视化故障处理工具\n\n## JConsole\n\n+ Java监视与管理控制台\n+ 通过JDK/bin命令下的jconsole.exe启动JConsole\n+ 他会自动搜索出本机运行的所有虚拟机进程，即完成jps的功能\n\n### 内存监控\n\n+ 相当于可视化的jstat命令\n+ 用于监视被收集器管理的虚拟机内存\n\n```java\n//-Xms100m -Xmx100m -XX:+UseSerialGC\n\npublic class Main {\n    //内存占位符对象,一个OOM大约64KB\n    static class OOMObject {\n        public byte[] placeholder = new byte[64 * 1024];\n    }\n    public static void fillHeap(int num) throws InterruptedException {\n        List<OOMObject> list = new ArrayList<>();\n        for (int i = 0; i < num; i++) {\n            //让监视曲线变化更加明显\n            Thread.sleep(50);\n            list.add(new OOMObject());\n        }\n\t\tSystem.gc();\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        fillHeap(1000);\n    }\n}\n```\n\n+ Eden区的运行趋势呈折现状\n+ 整个堆曲线平滑向上增长\n+ 在System.GC后，Eden与Survivor区被清空，但是老年代的保持峰值，说明被填充进堆中的数据在System.gc（）后仍然存活\n+ 在System.gc();时，list对象仍然处于作用域之内，就不会回收，如果把System.gc();移动到方法外调用即可回收掉全部内存\n\n### 线程监控\n\n+ 相当于jstack，遇到线程停顿的时候用\n\n**案例**\n\n```java\npublic class Main {\n    //线程死循环演示\n    public static void createBusyThread() {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (true) { //第12行\n\n                }\n            }\n        }, \"testBusyThread\").start();\n    }\n\n    //线程锁等待演示\n    public static void createLockThread(final Object lock) {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                synchronized (lock) {\n                    try {\n                        lock.wait();\n                    }\n                    catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }, \"testLockThread\").start();\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        bufferedReader.readLine();\n        createBusyThread();\n        bufferedReader.readLine();\n        Object object = new Object();\n        createLockThread(object);\n    }\n}\n```\n\n+ 首先在线程页签中选择main线程\n    + 堆栈追踪显示BufferedReader的readBytes()方法正在等待System.in的键盘输入\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775371_11.png)\n+ 接着监控testBusyThread线程\n    + 他一直在执行空循环\n    + 一直在第14行停留，即while(true)\n    + 线程为Runnable状态，而且没有归还线程执行令牌的动作，所以会在空循环耗尽操作系统分配给他的执行时间，直到线程切换为止\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775349_10.png)\n+ testLockThread\n    + 在等待lock对象的notify()或notifyAll()方法的出现\n    + 处于WAITING状态，在重新唤醒前不会被分配执行时间\n    + 处于正常的活锁等待，lock对象的notify()或notifyAll()方法被调用这个线程便能继续执行\n    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775531_12.png)\n\n**死锁案例**\n\n```java\npublic class Main {\n    static class SynAddRunnable implements Runnable {\n        int a, b;\n\n        public SynAddRunnable(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public void run() {\n            synchronized (Integer.valueOf(a)) {\n                synchronized (Integer.valueOf(b)) {\n                    System.out.println(a + b);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 100; i++) {\n            new Thread(new SynAddRunnable(1, 2)).start();\n            new Thread(new SynAddRunnable(2, 1)).start();\n        }\n    }\n}\n```\n\n根本原因是Integer.valueOf()会对[-128,127]对象进行缓存，如果valueOf()传入的参数在范围内，则直接返回缓存中的对象\n\n假设线程A在两个synchronized块之间发生了一次线程切换，就会出现线程A等待线程B持有的Integer.valueOf(1),线程B又在等待被线程A持有的Integer.valueOf(2)\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608776488_13.png)","slug":"Java语言/Java虚拟机/1.运行时数据区","published":1,"updated":"2021-06-08T03:35:00.518Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq50w000gz0tp66fg7o2b","content":"<h1 id=\"内存区域\"><a href=\"#内存区域\" class=\"headerlink\" title=\"内存区域\"></a>内存区域</h1><h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><ul>\n<li>当前线程所执行字节码的行号指示器</li>\n<li>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>\n<li>某一刻，一个处理器只会执行一个线程中的指令</li>\n<li>为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器</li>\n<li>即线程私有的内存</li>\n<li>Java方法，则记录正在执行的虚拟机字节码指令的地址</li>\n<li>Native方法，则计数器值为空</li>\n<li>唯一一个没有OutOfMemoryError情况的区域</li>\n</ul>\n<h3 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h3><ul>\n<li>线程私有，生命周期与线程相同</li>\n<li>每个方法被调用直到执行完毕的过程，就对应一个栈帧从入栈到出栈的过程</li>\n<li>每个方法被执行时，JVM都会创建一个栈帧</li>\n</ul>\n<p><strong>栈帧</strong></p>\n<ul>\n<li>局部变量表<ul>\n<li>存储编译器可知的数据：基本数据类型、对象引用（可能是一个指向对象起始地址的引用指针、也可能是指向一个代表对象的句柄）、returnAddress类型（指向一条字节码指令的地址）</li>\n<li>以局部变量槽存储，其中64位的long和double占用两个变量槽</li>\n<li>所需的内存空间在编译期间完成分配</li>\n<li>进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间完全确定</li>\n</ul>\n</li>\n<li>操作数栈</li>\n<li>动态连接</li>\n<li>方法出口</li>\n</ul>\n<p><strong>异常</strong></p>\n<ul>\n<li>StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度</li>\n<li>OutOfMemoryError异常<ul>\n<li>如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时</li>\n<li>HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><ul>\n<li>虚拟机栈是为JVM执行Java方法（字节码）服务</li>\n<li>本地方法栈是为了使用Native方法服务</li>\n<li>HotSpot虚拟机把虚拟机栈，本地方法栈合二为一了</li>\n</ul>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><ul>\n<li>Java堆是被所有线程共享的一块内存区域，在JVM启动时创建</li>\n<li>用于存放对象实例</li>\n<li>几乎所有对象实例都在这里分配内存<ul>\n<li>所有的对象实例以及数组都应在堆上分配</li>\n<li>由于逃逸分析技术，一些优化手段如栈上分配、标量替换等，使得对象实例都分配在堆上不是这么绝对</li>\n</ul>\n</li>\n<li>是垃圾收集器管理的内存区域</li>\n<li>可以划分出多个线程私有的分配缓冲区以提升对象分配时的效率：Thread Local Allocation Buffer(TLAB)</li>\n<li>可以处于物理上不连续的内存空间中，但在逻辑上是连续的。但对于大对象，例如数组对象，多数虚拟机都处于实现简单、存储高效的考虑，可能要求连续的内存空间</li>\n<li>可扩展，通过参数-Xms、-Xmx设定</li>\n<li>如果堆中没有内存完成实例分配，并且堆无法扩展，则OOM异常</li>\n</ul>\n<p><strong>字符串常量池</strong></p>\n<p>字符串池/字符串常量池/字符串对象池/String Pool/String Table 都可以看作一个东西。</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p><strong>理解</strong></p>\n<ul>\n<li>是各个线程共享的内存区域</li>\n<li>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存数据等</li>\n<li>内存回收目标主要是针对常量池的回收和类型的卸载</li>\n<li>方法区无法满足新的内存分配需求时，抛出OOM异常</li>\n</ul>\n<p><strong>结构</strong></p>\n<ul>\n<li>运行时常量池<ul>\n<li>保存Class文件中描述的符号引用</li>\n<li>由符号引用翻译出来的直接引用</li>\n<li>与Class文件常量池区别是局部动态性。即常量不一定只有编译期产生，即并不是预置于Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以把新的常量放入池中，例如String的intern（）方法。</li>\n<li>无法满足新的内存分配需求时，抛出OOM异常</li>\n</ul>\n</li>\n<li>class文件信息<ul>\n<li>类的版本、字段、方法、接口等</li>\n<li>常量池表：存放编译期生成的各种字面量与符号引用，在类加载后存放到方法区的运行时常量池中</li>\n</ul>\n</li>\n</ul>\n<p><strong>元空间</strong></p>\n<ul>\n<li>元空间” 和 “方法区”，一个是HotSpot 的具体实现技术，一个是JVM规范的抽象定义；</li>\n<li>类型信息全部移到元空间中</li>\n<li>元空间是使用本地内存（Native Memory）实现的，也就是说它的内存是不在虚拟机内的，所以可以理论上物理机器还有多个内存就可以分配，而不用再受限于JVM本身分配的内存了。</li>\n</ul>\n<h3 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h3><ul>\n<li>不是运行时数据区的一部分，但是频繁使用到，也会OOM</li>\n<li>NIO引入了基于管道与缓冲区的IO方式，可以使用Native函数库直接分配堆外内存</li>\n<li>直接内存的分配不会受到堆的大小限制，但受到本机总内存限制</li>\n</ul>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"对象创建\"><a href=\"#对象创建\" class=\"headerlink\" title=\"对象创建\"></a>对象创建</h3><ul>\n<li>能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过。没有则执行类加载过程</li>\n<li>为新生对象分配内存，类加载完成时即可确定对象所需的内存大小<ul>\n<li><strong>堆中内存分配</strong><ul>\n<li>绝对规整则采用<strong>指针碰撞</strong>，所有被使用过的内存都被放在一边，空闲的内存在另一边，中间放这一个指针作为分界点的指示器。分配内存就是把那个指针向空闲空间方向挪动一段和对象内存大小相等的距离</li>\n<li>否则<strong>空闲列表</strong>：在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li>\n<li>是否规整由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定：Serial、ParNew带压缩整理、CMS基于清除（Sweep）算法，不带压缩整理</li>\n</ul>\n</li>\n<li><strong>分配内存有并发性</strong><ul>\n<li>可以对分配内存空间的动作进行同步处理，采用<strong>CAS配上失败重试</strong>来保证更新操作的原子性</li>\n<li>或把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在堆中预先分配一小块内存，称为本地线程分配缓存<strong>TLAB</strong>，哪个线程需要分配内存，就在他的TLAB中分配，本地缓冲区用完才需要同步锁定。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>为分配到的内存空间（不包括对象头）都初始化为零值，保证了对象的实例字段在代码中可以不赋初始值即可使用</li>\n<li>对对象进行相应设置（存放在对象头中）：这个对象是哪个类的实例、如何能找到类的元数据信息、对象的哈希码（延后到真正调用Object::HashCode()方法才计算）、对象的GC分代年龄</li>\n<li>构造函数<init>()方法，按照程序员的意愿对对象进行初始化</li>\n</ul>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><ul>\n<li>对象头(Header)<ul>\n<li><strong>Mark Word</strong><ul>\n<li>存储自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</li>\n<li>在32位和64位（未开启压缩指针）虚拟机中分别位32比特和64比特</li>\n<li>有着动态定义的数据结构，根据对象的状态复用自己的存储空间</li>\n</ul>\n</li>\n<li><strong>类型指针</strong><ul>\n<li>指向对象的类型元数据的指针</li>\n<li>查找对象的元数据信息并不一定要经过对象本身</li>\n</ul>\n</li>\n<li><strong>记录数组长度的数据</strong><ul>\n<li>虚拟机可以通过元数据信息确定Java对象的大小，但是如果数组的长度不确定，无法通过元数据信息推断数组的大小</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>实例数据（Instance Data)<ul>\n<li>对象真正存储的有效信息，即定义的各种类型的字段内容</li>\n<li>无论是从父类继承的还是子类中定义的都记录</li>\n<li>存储顺序策略<ul>\n<li>longs/doubles、ints、shorts、chars、bytes/booleans、oops（Ordinary Object Pointers）</li>\n<li>相同宽度的字段分配在一起存放</li>\n<li>满足上面情况下，父类中定义的变量在子类之前</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>对齐填充（Padding）<ul>\n<li>对象起始地址必须是8字节的整数倍</li>\n<li>对象头已经是8字节的整数倍了（1倍或两倍）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"对象访问定位\"><a href=\"#对象访问定位\" class=\"headerlink\" title=\"对象访问定位\"></a>对象访问定位</h3><ul>\n<li>通过栈上的reference数据来操作堆上的具体对象</li>\n<li>访问堆对象具体位置<ul>\n<li>句柄访问<ul>\n<li>划分一部分为句柄池</li>\n<li>reference中存储对象的句柄地址</li>\n<li>句柄中包含对象实例数据和类型数据各自具体的地址</li>\n<li>存储的是稳定句柄地址，对象移动只改变句柄，不需要改变reference</li>\n</ul>\n</li>\n<li>直接指针访问<ul>\n<li>reference中直接存储对象地址</li>\n<li>速度更快，节省了一次指针定位的时间开销</li>\n<li>HotSpot采用直接指针访问</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"异常演示\"><a href=\"#异常演示\" class=\"headerlink\" title=\"异常演示\"></a>异常演示</h1><h2 id=\"Java堆异常\"><a href=\"#Java堆异常\" class=\"headerlink\" title=\"Java堆异常\"></a>Java堆异常</h2><p>只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，总容量触及最大堆容量限制即OOM</p>\n<p>设置堆最小值 -Xms参数和堆最大值参数 -Xmx一样即可避免堆自动扩展</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机再出现内存溢出异常时Dump出当前内存堆存储快照以便事后分析</p>\n<pre><code>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> com<span class=\"token punctuation\">.</span>tongji<span class=\"token punctuation\">.</span>test<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>ArrayList<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>List<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HeapOOM</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OOMObject</span><span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        List<span class=\"token operator\">&lt;</span>OOMObject<span class=\"token operator\">></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">OOMObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">Exception in thread <span class=\"token string\">\"main\"</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>OutOfMemoryError<span class=\"token operator\">:</span> Java heap space</code></pre>\n<p><strong>处理方法</strong></p>\n<ul>\n<li>通过内存映像分析工具对Dump出来的堆存储快照进行分析</li>\n<li>首先确认内存中导致OOM的对象是否有必要存在,即是出现内存泄漏,还是内存溢出<ul>\n<li>内存泄漏,则查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收他们</li>\n<li>内存溢出，则内存中对象确实是必须存活的，就应该检查堆参数设置（-Xms -Xmx），与机器内存对比，是否有向上调整的空间，再从代码中检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设置不合理等，尽量减少程序运行期的内存消耗</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"虚拟机栈和本地方法栈溢出\"><a href=\"#虚拟机栈和本地方法栈溢出\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈溢出\"></a>虚拟机栈和本地方法栈溢出</h2><p><strong>原理</strong></p>\n<ul>\n<li>线程请求的栈深度大于虚拟机所允许的深度抛出StackOverflowError异常，例如调用的方法太多（递归）</li>\n<li>如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时抛出OutOfMemoryError异常<ul>\n<li>HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM</li>\n<li>否则线程运行时不会因为扩展而导致内存溢出，只会因为栈容量无法容纳新的栈帧导致StackOverflowError异常</li>\n</ul>\n</li>\n<li>写一个死递归程序触发</li>\n</ul>\n<p><strong>实验</strong></p>\n<ul>\n<li>使用-Xss减少栈内存容量</li>\n<li>定义大量本地变量，增大次方法帧中本地变量表的长度</li>\n<li>无论是栈帧太大还是虚拟机容量太小，当新的栈帧内存无法分配时，抛出的都是StackOverflowError异常</li>\n<li>有明确的错误栈帧可供分析，栈深度达到1000-2000完全没问题，对于正常的方法调用完全足够了</li>\n</ul>\n<p><strong>使用-Xss减少栈内存容量</strong></p>\n<pre><code>-Xss128k</code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> com<span class=\"token punctuation\">.</span>tongji<span class=\"token punctuation\">.</span>test<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StackSOF</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> stackLength <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">stackLeak</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        stackLength<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">stackLeak</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        StackSOF oom <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StackSOF</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span>\n        <span class=\"token punctuation\">{</span>\n            oom<span class=\"token punctuation\">.</span><span class=\"token function\">stackLeak</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> e<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"stack length:\"</span><span class=\"token operator\">+</span>oom<span class=\"token punctuation\">.</span>stackLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre><code>stack length:985\njava.lang.StackOverflowError</code></pre>\n<p><strong>定义大量本地变量，增大次方法帧中本地变量表的长度</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> com<span class=\"token punctuation\">.</span>tongji<span class=\"token punctuation\">.</span>test<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StackSOF</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> stackLength <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">stackLeak</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">long</span> unused0<span class=\"token punctuation\">,</span> unused1<span class=\"token punctuation\">,</span> unused2<span class=\"token punctuation\">,</span> unused3<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">long</span> unused10<span class=\"token punctuation\">,</span> unused11<span class=\"token punctuation\">,</span> unused12<span class=\"token punctuation\">,</span> unused13<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">long</span> unused20<span class=\"token punctuation\">,</span> unused21<span class=\"token punctuation\">,</span> unused22<span class=\"token punctuation\">,</span> unused23<span class=\"token punctuation\">;</span>\n        stackLength<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">stackLeak</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        unused0 <span class=\"token operator\">=</span> unused1 <span class=\"token operator\">=</span> unused2 <span class=\"token operator\">=</span> unused3 <span class=\"token operator\">=</span>\n                unused10 <span class=\"token operator\">=</span> unused11 <span class=\"token operator\">=</span> unused12 <span class=\"token operator\">=</span> unused13 <span class=\"token operator\">=</span>\n                        unused20 <span class=\"token operator\">=</span> unused21 <span class=\"token operator\">=</span> unused22 <span class=\"token operator\">=</span> unused23 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        StackSOF oom <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StackSOF</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            oom<span class=\"token punctuation\">.</span><span class=\"token function\">stackLeak</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"stack length:\"</span> <span class=\"token operator\">+</span> oom<span class=\"token punctuation\">.</span>stackLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre><code>stack length:311\njava.lang.StackOverflowError</code></pre>\n<h2 id=\"方法区和运行时常量池的溢出\"><a href=\"#方法区和运行时常量池的溢出\" class=\"headerlink\" title=\"方法区和运行时常量池的溢出\"></a>方法区和运行时常量池的溢出</h2><ul>\n<li>基本思路是运行时产生大量的类去填满方法区直到溢出为止</li>\n<li>许多框架如Spring，都会使用CGLib这类字节码技术</li>\n<li>当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存</li>\n<li>方法区是常见的内存溢出异常，因为一个类如果要被垃圾收集器回收，要达成的条件比较苛刻。在经常运行生成大量动态类的应用场景中，就应该特别关注这些类的回收状况</li>\n<li>JDK8后，使用了元空间,正常的动态创建新类型的测试用例很难迫使虚拟机产生方法区的溢出异常了</li>\n<li>-XX:MaxMetaspaceSize设置元空间最大值，默认是-1，即不限制，或者说只限制与本地内存大小</li>\n<li>-XX:MetaspaceSize指定元空间初始空间大小，以字节为单位，达到该值则触发垃圾收集进行类型卸载</li>\n<li>-XX:MinMetaspaceFreeRatio在垃圾收集之后控制最小的元空间剩余容量百分比，可以减少因为元空间不足导致的垃圾收集的频率</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> com<span class=\"token punctuation\">.</span>tongji<span class=\"token punctuation\">.</span>test<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>cglib<span class=\"token punctuation\">.</span>proxy<span class=\"token punctuation\">.</span>Enhancer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>cglib<span class=\"token punctuation\">.</span>proxy<span class=\"token punctuation\">.</span>MethodInterceptor<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>cglib<span class=\"token punctuation\">.</span>proxy<span class=\"token punctuation\">.</span>MethodProxy<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span>Method<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JavaMethodAreaOOM</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OOMObject</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Enhancer enhancer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Enhancer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            enhancer<span class=\"token punctuation\">.</span><span class=\"token function\">setSuperclass</span><span class=\"token punctuation\">(</span>OOMObject<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            enhancer<span class=\"token punctuation\">.</span><span class=\"token function\">setUseCache</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            enhancer<span class=\"token punctuation\">.</span><span class=\"token function\">setCallback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">MethodInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token annotation punctuation\">@Override</span>\n                <span class=\"token keyword\">public</span> Object <span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span>Object o<span class=\"token punctuation\">,</span> Method method<span class=\"token punctuation\">,</span> Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> objects<span class=\"token punctuation\">,</span> MethodProxy methodProxy<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Throwable <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">return</span> methodProxy<span class=\"token punctuation\">.</span><span class=\"token function\">invokeSuper</span><span class=\"token punctuation\">(</span>objects<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"本地直接内存溢出\"><a href=\"#本地直接内存溢出\" class=\"headerlink\" title=\"本地直接内存溢出\"></a>本地直接内存溢出</h2><ul>\n<li>容量大小通过-XX:MaxDirectMemorySize指定,默认与Java堆最大值(-Xmx)一致</li>\n<li>由直接内存溢出明显特征是Heap Dump中看不见什么异常情况,如果发现内存溢出后Dump文件很小,而又使用了DirectMemory(如NIO),则可以重点检查下直接内存方面的原因</li>\n<li>通过反射获取Unsafe类，并不断分配内存给静态常量</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> com<span class=\"token punctuation\">.</span>tongji<span class=\"token punctuation\">.</span>test<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span>Unsafe<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span>Field<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DirectMemoryOOM</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> _1MB <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IllegalAccessException <span class=\"token punctuation\">{</span>\n        Field unsafeField <span class=\"token operator\">=</span> Unsafe<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredFields</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        unsafeField<span class=\"token punctuation\">.</span><span class=\"token function\">setAccessible</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Unsafe unsafe <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Unsafe<span class=\"token punctuation\">)</span> unsafeField<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">allocateMemory</span><span class=\"token punctuation\">(</span>_1MB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">Exception in thread <span class=\"token string\">\"main\"</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>OutOfMemoryError\n    at sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span>Unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">allocateMemory</span><span class=\"token punctuation\">(</span>Native Method<span class=\"token punctuation\">)</span>\n    at com<span class=\"token punctuation\">.</span>tongji<span class=\"token punctuation\">.</span>test<span class=\"token punctuation\">.</span>DirectMemoryOOM<span class=\"token punctuation\">.</span><span class=\"token function\">main</span><span class=\"token punctuation\">(</span>DirectMemoryOOM<span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">15</span><span class=\"token punctuation\">)</span></code></pre>\n<h1 id=\"基础故障处理工具\"><a href=\"#基础故障处理工具\" class=\"headerlink\" title=\"基础故障处理工具\"></a>基础故障处理工具</h1><ul>\n<li>这些命令行工具大多仅是一层薄包装，真正的功能代码是实现在JDK的工具类库里</li>\n<li>借助这些工具类库，应用程序部署生产环境后，开发者可以选择直接在应用程序中提供功能强大的监控分析功能</li>\n</ul>\n<h2 id=\"jps\"><a href=\"#jps\" class=\"headerlink\" title=\"jps\"></a>jps</h2><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608769939_1.png\" alt=\"img\"></p>\n<ul>\n<li>JVM Process Status</li>\n<li>虚拟机进程状况工具</li>\n<li>是使用频率最高的JDK命令行工具</li>\n<li>列出正在运行的虚拟机进程</li>\n<li>显示虚拟机执行主类名称（main()方法所在的类）、这些进程的本地虚拟机唯一ID（LVMID） Local Virtual Machine Identifier</li>\n<li>其他JDK工具需要他查询到的LVMID来确定要监控的是哪一个虚拟机进程</li>\n<li>对于本地虚拟机进程，LVMID与PID一致；ps指令也可以查询到虚拟机进程的LVMID，但如果同时启动多个虚拟机进程，则必须依赖jps命令显示主类的功能</li>\n</ul>\n<p><strong>参数</strong></p>\n<p>jps -l</p>\n<p>输出主类的全名，如果进程执行的是JAR包，则输出JAR的路径</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770201_2.png\" alt=\"img\"></p>\n<p>jps -v</p>\n<p>输出虚拟机进程启动时的JVM参数</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770291_3.png\" alt=\"img\"></p>\n<h2 id=\"jstat\"><a href=\"#jstat\" class=\"headerlink\" title=\"jstat\"></a>jstat</h2><ul>\n<li>虚拟机统计信息监视工具</li>\n<li>JVM Statistics Monitoring Tool</li>\n<li>用于监视虚拟机各种运行状态信息的命令行工具</li>\n<li>显示本地或远程虚拟机进程中的类加载，内存，垃圾回收，即时编译器等运行时数据</li>\n<li>在只提供控制台环境的服务器，他是运行期定位虚拟机性能问题的常用工具</li>\n</ul>\n<p><strong>参数</strong></p>\n<ul>\n<li><p>jstat [ option vmid [interval [s|ms] [count] ] ]</p>\n</li>\n<li><p>本地虚拟机进程，则VMID与LVMID一致</p>\n</li>\n<li><p>interval和count代表查询间隔和次数，忽略则只查询一次</p>\n</li>\n<li><p>例如 jstat -gc 4218 250 5</p>\n<ul>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770710_4.png\" alt=\"img\"></li>\n</ul>\n</li>\n<li><p>jstat -gcutil 4218</p>\n<ul>\n<li>输出已使用空间占总空间百分比</li>\n<li>Eden使用了78.74%，S0为空，S1使用32.88%</li>\n<li>老年代（O）使用了61.65%</li>\n<li>元空间（M）使用了94.75</li>\n<li>程序运行以来Minor GC（YGC）发生了603次，用了4.85s</li>\n<li>发生Full GC(FGC)5次，用了1.611s</li>\n<li>所有GC总耗时（GCT）为6.462s</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770952_6.png\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"jmap\"><a href=\"#jmap\" class=\"headerlink\" title=\"jmap\"></a>jmap</h2><ul>\n<li>Java内存映像工具</li>\n<li>Memory Map for Java</li>\n<li>jmap -dump:live,format=b,file=a.log 4218<ul>\n<li>用于生成堆转储快照</li>\n<li>再把生成的a.log进行分析</li>\n</ul>\n</li>\n<li>jmap -heap 4218<ul>\n<li>显示Java堆详细详细，如使用哪种回收器，参数配置，分代情况等</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772363_7.png\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"jstack\"><a href=\"#jstack\" class=\"headerlink\" title=\"jstack\"></a>jstack</h2><ul>\n<li>Java堆栈跟踪工具</li>\n<li>Stack Trace for Java</li>\n<li>用于生成虚拟机当前时刻的线程快照<ul>\n<li>即当前虚拟机内每一条线程正在执行的方法堆栈的集合</li>\n<li>目的是定位线程出现长时间停顿的原因</li>\n<li>如线程间死锁、死循环、请求外部资源导致的长时间挂起等</li>\n<li>线程出现停顿时，通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做什么事情，或者等待什么资源</li>\n</ul>\n</li>\n<li>jstack -l 4218 ：-l 除堆栈外，显示关于锁的附加信息<ul>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772914_8.png\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"可视化故障处理工具\"><a href=\"#可视化故障处理工具\" class=\"headerlink\" title=\"可视化故障处理工具\"></a>可视化故障处理工具</h1><h2 id=\"JConsole\"><a href=\"#JConsole\" class=\"headerlink\" title=\"JConsole\"></a>JConsole</h2><ul>\n<li>Java监视与管理控制台</li>\n<li>通过JDK/bin命令下的jconsole.exe启动JConsole</li>\n<li>他会自动搜索出本机运行的所有虚拟机进程，即完成jps的功能</li>\n</ul>\n<h3 id=\"内存监控\"><a href=\"#内存监控\" class=\"headerlink\" title=\"内存监控\"></a>内存监控</h3><ul>\n<li>相当于可视化的jstat命令</li>\n<li>用于监视被收集器管理的虚拟机内存</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//-Xms100m -Xmx100m -XX:+UseSerialGC</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//内存占位符对象,一个OOM大约64KB</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OOMObject</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> placeholder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">64</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fillHeap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        List<span class=\"token operator\">&lt;</span>OOMObject<span class=\"token operator\">></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//让监视曲线变化更加明显</span>\n            Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">OOMObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        System<span class=\"token punctuation\">.</span><span class=\"token function\">gc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">fillHeap</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>Eden区的运行趋势呈折现状</li>\n<li>整个堆曲线平滑向上增长</li>\n<li>在System.GC后，Eden与Survivor区被清空，但是老年代的保持峰值，说明被填充进堆中的数据在System.gc（）后仍然存活</li>\n<li>在System.gc();时，list对象仍然处于作用域之内，就不会回收，如果把System.gc();移动到方法外调用即可回收掉全部内存</li>\n</ul>\n<h3 id=\"线程监控\"><a href=\"#线程监控\" class=\"headerlink\" title=\"线程监控\"></a>线程监控</h3><ul>\n<li>相当于jstack，遇到线程停顿的时候用</li>\n</ul>\n<p><strong>案例</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//线程死循环演示</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">createBusyThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//第12行</span>\n\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"testBusyThread\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//线程锁等待演示</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">createLockThread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Object lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                        lock<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"testLockThread\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        BufferedReader bufferedReader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        bufferedReader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">createBusyThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        bufferedReader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Object object <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">createLockThread</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>首先在线程页签中选择main线程<ul>\n<li>堆栈追踪显示BufferedReader的readBytes()方法正在等待System.in的键盘输入</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775371_11.png\" alt=\"img\"></li>\n</ul>\n</li>\n<li>接着监控testBusyThread线程<ul>\n<li>他一直在执行空循环</li>\n<li>一直在第14行停留，即while(true)</li>\n<li>线程为Runnable状态，而且没有归还线程执行令牌的动作，所以会在空循环耗尽操作系统分配给他的执行时间，直到线程切换为止</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775349_10.png\" alt=\"img\"></li>\n</ul>\n</li>\n<li>testLockThread<ul>\n<li>在等待lock对象的notify()或notifyAll()方法的出现</li>\n<li>处于WAITING状态，在重新唤醒前不会被分配执行时间</li>\n<li>处于正常的活锁等待，lock对象的notify()或notifyAll()方法被调用这个线程便能继续执行</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775531_12.png\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n<p><strong>死锁案例</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SynAddRunnable</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token function\">SynAddRunnable</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>Integer<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>Integer<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">SynAddRunnable</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">SynAddRunnable</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>根本原因是Integer.valueOf()会对[-128,127]对象进行缓存，如果valueOf()传入的参数在范围内，则直接返回缓存中的对象</p>\n<p>假设线程A在两个synchronized块之间发生了一次线程切换，就会出现线程A等待线程B持有的Integer.valueOf(1),线程B又在等待被线程A持有的Integer.valueOf(2)</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608776488_13.png\" alt=\"img\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"内存区域\"><a href=\"#内存区域\" class=\"headerlink\" title=\"内存区域\"></a>内存区域</h1><h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><ul>\n<li>当前线程所执行字节码的行号指示器</li>\n<li>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>\n<li>某一刻，一个处理器只会执行一个线程中的指令</li>\n<li>为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器</li>\n<li>即线程私有的内存</li>\n<li>Java方法，则记录正在执行的虚拟机字节码指令的地址</li>\n<li>Native方法，则计数器值为空</li>\n<li>唯一一个没有OutOfMemoryError情况的区域</li>\n</ul>\n<h3 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h3><ul>\n<li>线程私有，生命周期与线程相同</li>\n<li>每个方法被调用直到执行完毕的过程，就对应一个栈帧从入栈到出栈的过程</li>\n<li>每个方法被执行时，JVM都会创建一个栈帧</li>\n</ul>\n<p><strong>栈帧</strong></p>\n<ul>\n<li>局部变量表<ul>\n<li>存储编译器可知的数据：基本数据类型、对象引用（可能是一个指向对象起始地址的引用指针、也可能是指向一个代表对象的句柄）、returnAddress类型（指向一条字节码指令的地址）</li>\n<li>以局部变量槽存储，其中64位的long和double占用两个变量槽</li>\n<li>所需的内存空间在编译期间完成分配</li>\n<li>进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间完全确定</li>\n</ul>\n</li>\n<li>操作数栈</li>\n<li>动态连接</li>\n<li>方法出口</li>\n</ul>\n<p><strong>异常</strong></p>\n<ul>\n<li>StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度</li>\n<li>OutOfMemoryError异常<ul>\n<li>如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时</li>\n<li>HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><ul>\n<li>虚拟机栈是为JVM执行Java方法（字节码）服务</li>\n<li>本地方法栈是为了使用Native方法服务</li>\n<li>HotSpot虚拟机把虚拟机栈，本地方法栈合二为一了</li>\n</ul>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><ul>\n<li>Java堆是被所有线程共享的一块内存区域，在JVM启动时创建</li>\n<li>用于存放对象实例</li>\n<li>几乎所有对象实例都在这里分配内存<ul>\n<li>所有的对象实例以及数组都应在堆上分配</li>\n<li>由于逃逸分析技术，一些优化手段如栈上分配、标量替换等，使得对象实例都分配在堆上不是这么绝对</li>\n</ul>\n</li>\n<li>是垃圾收集器管理的内存区域</li>\n<li>可以划分出多个线程私有的分配缓冲区以提升对象分配时的效率：Thread Local Allocation Buffer(TLAB)</li>\n<li>可以处于物理上不连续的内存空间中，但在逻辑上是连续的。但对于大对象，例如数组对象，多数虚拟机都处于实现简单、存储高效的考虑，可能要求连续的内存空间</li>\n<li>可扩展，通过参数-Xms、-Xmx设定</li>\n<li>如果堆中没有内存完成实例分配，并且堆无法扩展，则OOM异常</li>\n</ul>\n<p><strong>字符串常量池</strong></p>\n<p>字符串池/字符串常量池/字符串对象池/String Pool/String Table 都可以看作一个东西。</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p><strong>理解</strong></p>\n<ul>\n<li>是各个线程共享的内存区域</li>\n<li>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存数据等</li>\n<li>内存回收目标主要是针对常量池的回收和类型的卸载</li>\n<li>方法区无法满足新的内存分配需求时，抛出OOM异常</li>\n</ul>\n<p><strong>结构</strong></p>\n<ul>\n<li>运行时常量池<ul>\n<li>保存Class文件中描述的符号引用</li>\n<li>由符号引用翻译出来的直接引用</li>\n<li>与Class文件常量池区别是局部动态性。即常量不一定只有编译期产生，即并不是预置于Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以把新的常量放入池中，例如String的intern（）方法。</li>\n<li>无法满足新的内存分配需求时，抛出OOM异常</li>\n</ul>\n</li>\n<li>class文件信息<ul>\n<li>类的版本、字段、方法、接口等</li>\n<li>常量池表：存放编译期生成的各种字面量与符号引用，在类加载后存放到方法区的运行时常量池中</li>\n</ul>\n</li>\n</ul>\n<p><strong>元空间</strong></p>\n<ul>\n<li>元空间” 和 “方法区”，一个是HotSpot 的具体实现技术，一个是JVM规范的抽象定义；</li>\n<li>类型信息全部移到元空间中</li>\n<li>元空间是使用本地内存（Native Memory）实现的，也就是说它的内存是不在虚拟机内的，所以可以理论上物理机器还有多个内存就可以分配，而不用再受限于JVM本身分配的内存了。</li>\n</ul>\n<h3 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h3><ul>\n<li>不是运行时数据区的一部分，但是频繁使用到，也会OOM</li>\n<li>NIO引入了基于管道与缓冲区的IO方式，可以使用Native函数库直接分配堆外内存</li>\n<li>直接内存的分配不会受到堆的大小限制，但受到本机总内存限制</li>\n</ul>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"对象创建\"><a href=\"#对象创建\" class=\"headerlink\" title=\"对象创建\"></a>对象创建</h3><ul>\n<li>能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过。没有则执行类加载过程</li>\n<li>为新生对象分配内存，类加载完成时即可确定对象所需的内存大小<ul>\n<li><strong>堆中内存分配</strong><ul>\n<li>绝对规整则采用<strong>指针碰撞</strong>，所有被使用过的内存都被放在一边，空闲的内存在另一边，中间放这一个指针作为分界点的指示器。分配内存就是把那个指针向空闲空间方向挪动一段和对象内存大小相等的距离</li>\n<li>否则<strong>空闲列表</strong>：在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li>\n<li>是否规整由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定：Serial、ParNew带压缩整理、CMS基于清除（Sweep）算法，不带压缩整理</li>\n</ul>\n</li>\n<li><strong>分配内存有并发性</strong><ul>\n<li>可以对分配内存空间的动作进行同步处理，采用<strong>CAS配上失败重试</strong>来保证更新操作的原子性</li>\n<li>或把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在堆中预先分配一小块内存，称为本地线程分配缓存<strong>TLAB</strong>，哪个线程需要分配内存，就在他的TLAB中分配，本地缓冲区用完才需要同步锁定。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>为分配到的内存空间（不包括对象头）都初始化为零值，保证了对象的实例字段在代码中可以不赋初始值即可使用</li>\n<li>对对象进行相应设置（存放在对象头中）：这个对象是哪个类的实例、如何能找到类的元数据信息、对象的哈希码（延后到真正调用Object::HashCode()方法才计算）、对象的GC分代年龄</li>\n<li>构造函数<init>()方法，按照程序员的意愿对对象进行初始化</li>\n</ul>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><ul>\n<li>对象头(Header)<ul>\n<li><strong>Mark Word</strong><ul>\n<li>存储自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</li>\n<li>在32位和64位（未开启压缩指针）虚拟机中分别位32比特和64比特</li>\n<li>有着动态定义的数据结构，根据对象的状态复用自己的存储空间</li>\n</ul>\n</li>\n<li><strong>类型指针</strong><ul>\n<li>指向对象的类型元数据的指针</li>\n<li>查找对象的元数据信息并不一定要经过对象本身</li>\n</ul>\n</li>\n<li><strong>记录数组长度的数据</strong><ul>\n<li>虚拟机可以通过元数据信息确定Java对象的大小，但是如果数组的长度不确定，无法通过元数据信息推断数组的大小</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>实例数据（Instance Data)<ul>\n<li>对象真正存储的有效信息，即定义的各种类型的字段内容</li>\n<li>无论是从父类继承的还是子类中定义的都记录</li>\n<li>存储顺序策略<ul>\n<li>longs/doubles、ints、shorts、chars、bytes/booleans、oops（Ordinary Object Pointers）</li>\n<li>相同宽度的字段分配在一起存放</li>\n<li>满足上面情况下，父类中定义的变量在子类之前</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>对齐填充（Padding）<ul>\n<li>对象起始地址必须是8字节的整数倍</li>\n<li>对象头已经是8字节的整数倍了（1倍或两倍）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"对象访问定位\"><a href=\"#对象访问定位\" class=\"headerlink\" title=\"对象访问定位\"></a>对象访问定位</h3><ul>\n<li>通过栈上的reference数据来操作堆上的具体对象</li>\n<li>访问堆对象具体位置<ul>\n<li>句柄访问<ul>\n<li>划分一部分为句柄池</li>\n<li>reference中存储对象的句柄地址</li>\n<li>句柄中包含对象实例数据和类型数据各自具体的地址</li>\n<li>存储的是稳定句柄地址，对象移动只改变句柄，不需要改变reference</li>\n</ul>\n</li>\n<li>直接指针访问<ul>\n<li>reference中直接存储对象地址</li>\n<li>速度更快，节省了一次指针定位的时间开销</li>\n<li>HotSpot采用直接指针访问</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"异常演示\"><a href=\"#异常演示\" class=\"headerlink\" title=\"异常演示\"></a>异常演示</h1><h2 id=\"Java堆异常\"><a href=\"#Java堆异常\" class=\"headerlink\" title=\"Java堆异常\"></a>Java堆异常</h2><p>只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，总容量触及最大堆容量限制即OOM</p>\n<p>设置堆最小值 -Xms参数和堆最大值参数 -Xmx一样即可避免堆自动扩展</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机再出现内存溢出异常时Dump出当前内存堆存储快照以便事后分析</p>\n<pre><code>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</code></pre>\n<pre><code class=\"java\">package com.tongji.test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HeapOOM {\n    static class OOMObject{\n\n    }\n\n    public static void main(String[] args) {\n        List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();\n        while (true) {\n            list.add(new OOMObject());\n        }\n    }\n}</code></pre>\n<pre><code class=\"java\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</code></pre>\n<p><strong>处理方法</strong></p>\n<ul>\n<li>通过内存映像分析工具对Dump出来的堆存储快照进行分析</li>\n<li>首先确认内存中导致OOM的对象是否有必要存在,即是出现内存泄漏,还是内存溢出<ul>\n<li>内存泄漏,则查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收他们</li>\n<li>内存溢出，则内存中对象确实是必须存活的，就应该检查堆参数设置（-Xms -Xmx），与机器内存对比，是否有向上调整的空间，再从代码中检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设置不合理等，尽量减少程序运行期的内存消耗</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"虚拟机栈和本地方法栈溢出\"><a href=\"#虚拟机栈和本地方法栈溢出\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈溢出\"></a>虚拟机栈和本地方法栈溢出</h2><p><strong>原理</strong></p>\n<ul>\n<li>线程请求的栈深度大于虚拟机所允许的深度抛出StackOverflowError异常，例如调用的方法太多（递归）</li>\n<li>如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时抛出OutOfMemoryError异常<ul>\n<li>HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM</li>\n<li>否则线程运行时不会因为扩展而导致内存溢出，只会因为栈容量无法容纳新的栈帧导致StackOverflowError异常</li>\n</ul>\n</li>\n<li>写一个死递归程序触发</li>\n</ul>\n<p><strong>实验</strong></p>\n<ul>\n<li>使用-Xss减少栈内存容量</li>\n<li>定义大量本地变量，增大次方法帧中本地变量表的长度</li>\n<li>无论是栈帧太大还是虚拟机容量太小，当新的栈帧内存无法分配时，抛出的都是StackOverflowError异常</li>\n<li>有明确的错误栈帧可供分析，栈深度达到1000-2000完全没问题，对于正常的方法调用完全足够了</li>\n</ul>\n<p><strong>使用-Xss减少栈内存容量</strong></p>\n<pre><code>-Xss128k</code></pre>\n<pre><code class=\"java\">package com.tongji.test;\n\npublic class StackSOF {\n    private int stackLength = 1;\n\n    private void stackLeak() {\n        stackLength++;\n        stackLeak();\n    }\n\n    public static void main(String[] args) {\n        StackSOF oom = new StackSOF();\n        try\n        {\n            oom.stackLeak();\n        }\n        catch (Throwable e)\n        {\n            System.out.println(&quot;stack length:&quot;+oom.stackLength);\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<pre><code>stack length:985\njava.lang.StackOverflowError</code></pre>\n<p><strong>定义大量本地变量，增大次方法帧中本地变量表的长度</strong></p>\n<pre><code class=\"java\">package com.tongji.test;\n\npublic class StackSOF {\n    private int stackLength = 1;\n\n    private void stackLeak() {\n        long unused0, unused1, unused2, unused3;\n        long unused10, unused11, unused12, unused13;\n        long unused20, unused21, unused22, unused23;\n        stackLength++;\n        stackLeak();\n        unused0 = unused1 = unused2 = unused3 =\n                unused10 = unused11 = unused12 = unused13 =\n                        unused20 = unused21 = unused22 = unused23 = 0;\n    }\n\n    public static void main(String[] args) {\n        StackSOF oom = new StackSOF();\n        try {\n            oom.stackLeak();\n        }\n        catch (Throwable e) {\n            System.out.println(&quot;stack length:&quot; + oom.stackLength);\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<pre><code>stack length:311\njava.lang.StackOverflowError</code></pre>\n<h2 id=\"方法区和运行时常量池的溢出\"><a href=\"#方法区和运行时常量池的溢出\" class=\"headerlink\" title=\"方法区和运行时常量池的溢出\"></a>方法区和运行时常量池的溢出</h2><ul>\n<li>基本思路是运行时产生大量的类去填满方法区直到溢出为止</li>\n<li>许多框架如Spring，都会使用CGLib这类字节码技术</li>\n<li>当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存</li>\n<li>方法区是常见的内存溢出异常，因为一个类如果要被垃圾收集器回收，要达成的条件比较苛刻。在经常运行生成大量动态类的应用场景中，就应该特别关注这些类的回收状况</li>\n<li>JDK8后，使用了元空间,正常的动态创建新类型的测试用例很难迫使虚拟机产生方法区的溢出异常了</li>\n<li>-XX:MaxMetaspaceSize设置元空间最大值，默认是-1，即不限制，或者说只限制与本地内存大小</li>\n<li>-XX:MetaspaceSize指定元空间初始空间大小，以字节为单位，达到该值则触发垃圾收集进行类型卸载</li>\n<li>-XX:MinMetaspaceFreeRatio在垃圾收集之后控制最小的元空间剩余容量百分比，可以减少因为元空间不足导致的垃圾收集的频率</li>\n</ul>\n<pre><code class=\"java\">package com.tongji.test;\n\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\n\npublic class JavaMethodAreaOOM {\n    static class OOMObject {\n\n    }\n\n    public static void main(String[] args) {\n        while (true) {\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() {\n                @Override\n                public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                    return methodProxy.invokeSuper(objects, args);\n                }\n            });\n        }\n    }\n}</code></pre>\n<h2 id=\"本地直接内存溢出\"><a href=\"#本地直接内存溢出\" class=\"headerlink\" title=\"本地直接内存溢出\"></a>本地直接内存溢出</h2><ul>\n<li>容量大小通过-XX:MaxDirectMemorySize指定,默认与Java堆最大值(-Xmx)一致</li>\n<li>由直接内存溢出明显特征是Heap Dump中看不见什么异常情况,如果发现内存溢出后Dump文件很小,而又使用了DirectMemory(如NIO),则可以重点检查下直接内存方面的原因</li>\n<li>通过反射获取Unsafe类，并不断分配内存给静态常量</li>\n</ul>\n<pre><code class=\"java\">package com.tongji.test;\n\nimport sun.misc.Unsafe;\n\nimport java.lang.reflect.Field;\n\npublic class DirectMemoryOOM {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) throws IllegalAccessException {\n        Field unsafeField = Unsafe.class.getDeclaredFields()[0];\n        unsafeField.setAccessible(true);\n        Unsafe unsafe = (Unsafe) unsafeField.get(null);\n        while (true) {\n            unsafe.allocateMemory(_1MB);\n        }\n    }\n\n}</code></pre>\n<pre><code class=\"java\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError\n    at sun.misc.Unsafe.allocateMemory(Native Method)\n    at com.tongji.test.DirectMemoryOOM.main(DirectMemoryOOM.java:15)</code></pre>\n<h1 id=\"基础故障处理工具\"><a href=\"#基础故障处理工具\" class=\"headerlink\" title=\"基础故障处理工具\"></a>基础故障处理工具</h1><ul>\n<li>这些命令行工具大多仅是一层薄包装，真正的功能代码是实现在JDK的工具类库里</li>\n<li>借助这些工具类库，应用程序部署生产环境后，开发者可以选择直接在应用程序中提供功能强大的监控分析功能</li>\n</ul>\n<h2 id=\"jps\"><a href=\"#jps\" class=\"headerlink\" title=\"jps\"></a>jps</h2><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608769939_1.png\" alt=\"img\"></p>\n<ul>\n<li>JVM Process Status</li>\n<li>虚拟机进程状况工具</li>\n<li>是使用频率最高的JDK命令行工具</li>\n<li>列出正在运行的虚拟机进程</li>\n<li>显示虚拟机执行主类名称（main()方法所在的类）、这些进程的本地虚拟机唯一ID（LVMID） Local Virtual Machine Identifier</li>\n<li>其他JDK工具需要他查询到的LVMID来确定要监控的是哪一个虚拟机进程</li>\n<li>对于本地虚拟机进程，LVMID与PID一致；ps指令也可以查询到虚拟机进程的LVMID，但如果同时启动多个虚拟机进程，则必须依赖jps命令显示主类的功能</li>\n</ul>\n<p><strong>参数</strong></p>\n<p>jps -l</p>\n<p>输出主类的全名，如果进程执行的是JAR包，则输出JAR的路径</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770201_2.png\" alt=\"img\"></p>\n<p>jps -v</p>\n<p>输出虚拟机进程启动时的JVM参数</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770291_3.png\" alt=\"img\"></p>\n<h2 id=\"jstat\"><a href=\"#jstat\" class=\"headerlink\" title=\"jstat\"></a>jstat</h2><ul>\n<li>虚拟机统计信息监视工具</li>\n<li>JVM Statistics Monitoring Tool</li>\n<li>用于监视虚拟机各种运行状态信息的命令行工具</li>\n<li>显示本地或远程虚拟机进程中的类加载，内存，垃圾回收，即时编译器等运行时数据</li>\n<li>在只提供控制台环境的服务器，他是运行期定位虚拟机性能问题的常用工具</li>\n</ul>\n<p><strong>参数</strong></p>\n<ul>\n<li><p>jstat [ option vmid [interval [s|ms] [count] ] ]</p>\n</li>\n<li><p>本地虚拟机进程，则VMID与LVMID一致</p>\n</li>\n<li><p>interval和count代表查询间隔和次数，忽略则只查询一次</p>\n</li>\n<li><p>例如 jstat -gc 4218 250 5</p>\n<ul>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770710_4.png\" alt=\"img\"></li>\n</ul>\n</li>\n<li><p>jstat -gcutil 4218</p>\n<ul>\n<li>输出已使用空间占总空间百分比</li>\n<li>Eden使用了78.74%，S0为空，S1使用32.88%</li>\n<li>老年代（O）使用了61.65%</li>\n<li>元空间（M）使用了94.75</li>\n<li>程序运行以来Minor GC（YGC）发生了603次，用了4.85s</li>\n<li>发生Full GC(FGC)5次，用了1.611s</li>\n<li>所有GC总耗时（GCT）为6.462s</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770952_6.png\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"jmap\"><a href=\"#jmap\" class=\"headerlink\" title=\"jmap\"></a>jmap</h2><ul>\n<li>Java内存映像工具</li>\n<li>Memory Map for Java</li>\n<li>jmap -dump:live,format=b,file=a.log 4218<ul>\n<li>用于生成堆转储快照</li>\n<li>再把生成的a.log进行分析</li>\n</ul>\n</li>\n<li>jmap -heap 4218<ul>\n<li>显示Java堆详细详细，如使用哪种回收器，参数配置，分代情况等</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772363_7.png\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"jstack\"><a href=\"#jstack\" class=\"headerlink\" title=\"jstack\"></a>jstack</h2><ul>\n<li>Java堆栈跟踪工具</li>\n<li>Stack Trace for Java</li>\n<li>用于生成虚拟机当前时刻的线程快照<ul>\n<li>即当前虚拟机内每一条线程正在执行的方法堆栈的集合</li>\n<li>目的是定位线程出现长时间停顿的原因</li>\n<li>如线程间死锁、死循环、请求外部资源导致的长时间挂起等</li>\n<li>线程出现停顿时，通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做什么事情，或者等待什么资源</li>\n</ul>\n</li>\n<li>jstack -l 4218 ：-l 除堆栈外，显示关于锁的附加信息<ul>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772914_8.png\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"可视化故障处理工具\"><a href=\"#可视化故障处理工具\" class=\"headerlink\" title=\"可视化故障处理工具\"></a>可视化故障处理工具</h1><h2 id=\"JConsole\"><a href=\"#JConsole\" class=\"headerlink\" title=\"JConsole\"></a>JConsole</h2><ul>\n<li>Java监视与管理控制台</li>\n<li>通过JDK/bin命令下的jconsole.exe启动JConsole</li>\n<li>他会自动搜索出本机运行的所有虚拟机进程，即完成jps的功能</li>\n</ul>\n<h3 id=\"内存监控\"><a href=\"#内存监控\" class=\"headerlink\" title=\"内存监控\"></a>内存监控</h3><ul>\n<li>相当于可视化的jstat命令</li>\n<li>用于监视被收集器管理的虚拟机内存</li>\n</ul>\n<pre><code class=\"java\">//-Xms100m -Xmx100m -XX:+UseSerialGC\n\npublic class Main {\n    //内存占位符对象,一个OOM大约64KB\n    static class OOMObject {\n        public byte[] placeholder = new byte[64 * 1024];\n    }\n    public static void fillHeap(int num) throws InterruptedException {\n        List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; num; i++) {\n            //让监视曲线变化更加明显\n            Thread.sleep(50);\n            list.add(new OOMObject());\n        }\n        System.gc();\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        fillHeap(1000);\n    }\n}</code></pre>\n<ul>\n<li>Eden区的运行趋势呈折现状</li>\n<li>整个堆曲线平滑向上增长</li>\n<li>在System.GC后，Eden与Survivor区被清空，但是老年代的保持峰值，说明被填充进堆中的数据在System.gc（）后仍然存活</li>\n<li>在System.gc();时，list对象仍然处于作用域之内，就不会回收，如果把System.gc();移动到方法外调用即可回收掉全部内存</li>\n</ul>\n<h3 id=\"线程监控\"><a href=\"#线程监控\" class=\"headerlink\" title=\"线程监控\"></a>线程监控</h3><ul>\n<li>相当于jstack，遇到线程停顿的时候用</li>\n</ul>\n<p><strong>案例</strong></p>\n<pre><code class=\"java\">public class Main {\n    //线程死循环演示\n    public static void createBusyThread() {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (true) { //第12行\n\n                }\n            }\n        }, &quot;testBusyThread&quot;).start();\n    }\n\n    //线程锁等待演示\n    public static void createLockThread(final Object lock) {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                synchronized (lock) {\n                    try {\n                        lock.wait();\n                    }\n                    catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }, &quot;testLockThread&quot;).start();\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        bufferedReader.readLine();\n        createBusyThread();\n        bufferedReader.readLine();\n        Object object = new Object();\n        createLockThread(object);\n    }\n}</code></pre>\n<ul>\n<li>首先在线程页签中选择main线程<ul>\n<li>堆栈追踪显示BufferedReader的readBytes()方法正在等待System.in的键盘输入</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775371_11.png\" alt=\"img\"></li>\n</ul>\n</li>\n<li>接着监控testBusyThread线程<ul>\n<li>他一直在执行空循环</li>\n<li>一直在第14行停留，即while(true)</li>\n<li>线程为Runnable状态，而且没有归还线程执行令牌的动作，所以会在空循环耗尽操作系统分配给他的执行时间，直到线程切换为止</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775349_10.png\" alt=\"img\"></li>\n</ul>\n</li>\n<li>testLockThread<ul>\n<li>在等待lock对象的notify()或notifyAll()方法的出现</li>\n<li>处于WAITING状态，在重新唤醒前不会被分配执行时间</li>\n<li>处于正常的活锁等待，lock对象的notify()或notifyAll()方法被调用这个线程便能继续执行</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775531_12.png\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n<p><strong>死锁案例</strong></p>\n<pre><code class=\"java\">public class Main {\n    static class SynAddRunnable implements Runnable {\n        int a, b;\n\n        public SynAddRunnable(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public void run() {\n            synchronized (Integer.valueOf(a)) {\n                synchronized (Integer.valueOf(b)) {\n                    System.out.println(a + b);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 100; i++) {\n            new Thread(new SynAddRunnable(1, 2)).start();\n            new Thread(new SynAddRunnable(2, 1)).start();\n        }\n    }\n}</code></pre>\n<p>根本原因是Integer.valueOf()会对[-128,127]对象进行缓存，如果valueOf()传入的参数在范围内，则直接返回缓存中的对象</p>\n<p>假设线程A在两个synchronized块之间发生了一次线程切换，就会出现线程A等待线程B持有的Integer.valueOf(1),线程B又在等待被线程A持有的Integer.valueOf(2)</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608776488_13.png\" alt=\"img\"></p>\n"},{"title":"类加载机制","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习Java虚拟机，包括类生命周期、类加载器、双亲委派模型等。","abbrlink":"cd1d308","date":"2021-02-26T16:00:00.000Z","_content":"\n\n\n# 简介\n\n+ JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程就是类加载机制\n+ 在程序运行时完成的\n+ 动态扩展的语言特性就是依赖于运行期动态加载和动态连接，例如编写一个面向接口的程序，可以等到运行时再指定其实际的实现类\n\n\n\n# 生命周期\n\n+ 解析阶段某些情况可以再初始化阶段之后才开始（为了支持运行时绑定特性）\n+ 这些阶段通常相互交叉地混合进行，会在一个阶段执行的过程中调用、激活另一个阶段\n\n## 加载\n\n+ 通过一个类的全限定名获取定义此类的二进制字节流\n    + 从ZIP压缩包中读取，JAR的基础\n    + 从网络中读取，Web Applet\n    + 运行时计算生成，动态代理技术\n    + 从加密文件中获取，防Class文件被反编译的保护措施\n+ 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构\n+ 在Java堆内存中实例化生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口\n+ 数组加载\n    + 数组类本身不通过类加载器创建，由JVM直接在内存中动态构造出来\n    + 如果数组的组件类型是引用类型，递归采用加载过程去加载该组件类型，数组将标识在加载该组件类型的类加载器的类名称空间上\n    + 如果数组的组件类型是基本类型，数组将标识为与引导类加载器关联\n\n## 连接\n\n### 验证\n\n+ 目的是确保Class文件的字节流中包含的信息符合全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全\n+ 文件格式验证\n    + 验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理\n    + 保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求\n    + 基于二进制字节流进行的\n    + 后面的三个验证阶段全部基于方法区的存储结构了\n+ 元数据验证\n    + 对字节码描述的信息进行语义分析\n    + 是否有父类（除Object应都有父类）\n    + 是否继承了final类\n    + 是否实现了父类或接口要求实现的所有方法\n    + 类中字段、方法是否与父类产生矛盾\n+ 字节码验证\n    + 通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的\n    + 对类的方法体（Class文件中的Code属性）进行校验分析\n    + 保证被校验类的方法在运行时不会做出危害虚拟机安全的行为\n    + 保证任何跳转指令都不会跳转到方法体之外的字节码指令\n    + 保证类型转换都是有效的\n+ 符号引用验证\n    + 发生在符号引用转化为直接引用的时候，即解析阶段\n    + 验证该类是否缺少或被禁止访问他依赖的某些外部类、方法、字段等\n    + 验证符合引用中通过字符串描述的全限定名称是否能找到对应的类\n    + 验证在指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段\n    + 符号引用中类、字段、方法的可访问性\n\n### 准备\n\n+ 正式为类中静态变量分配内存并设置初始值\n+ 概念上是放在方法区，但是方法区是逻辑上的概念\n+ JDK8后，类变量随着Class对象一起存放在Java堆中\n+ 不包括实例变量，实例变量会在对象实例化时随对象一起分配在java堆中\n+ 如果字段属性表中存在ConstantValue属性，则直接被初始化为ConstantValue属性所指定的初始值，例如public static final int value = 123;\n\n### 解析\n\n+ 将常量池内的符号引用转换为直接引用的过程\n+ 虚拟机可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，避免重复解析\n+ 符号引用\n    + 以一组符合来描述所引用的目标，可以是任何形式的字面量\n    + 与JVM的内存布局无关\n    + 引用的目标不一定是已加载到虚拟机内存的内容\n+ 直接引用\n    + 可以直接指向目标的指针、相对偏移量或者句柄\n    + 和JVM实现的内存布局相关\n    + 引用的目标必定已经在虚拟机内存中\n+ 类或接口的解析\n    + 假设当前代码所处的类为D，要把从未解析过的符号引用N解析为一个类或接口C\n    + 如果C不是一个数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C\n    + 如果C是一个数组类型，并且数组的元素类型为对象，会先按上面的方法加载数组元素类型，再由虚拟机生成一个代表该数组维度和元素的数组对象\n    + 在解析完成之前，要进行符号引用验证，确认D是否具备对C的访问权限\n\n## 初始化\n\n+ JVM真正执行类中编写的Java代码，将主导权移交给应用程序\n\n+ 初始化类变量和其他资源，即执行类构造器<clinit>的过程，是编译器自动生成的方法\n\n+ 由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并而成的。收集的顺序由在源文件出现的顺序决定\n\n+ 静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，只能赋值，不能访问\n\n    + ```java\n        static {\n                i = 0; //给变量赋值可以正常编译通过\n                System.out.println(i); //提示非法前向引用\n            }\n        \n            static int i = 1;\n        ```\n\n        \n\n+ <clinit>不需要显式调用父类构造器，虚拟机保证父类的已经执行完毕，因此ＪＶＭ第一个被执行的<clinit>方法肯定是Object\n\n+ 父类的`<clinit>()`先执行，所以父类中定义的静态语句块优先于之类的变量赋值操作\n\n+ ```java\n    public class Main {\n        static class Parent {\n            public static int A = 1;\n            static{\n                A = 2;\n            }\n        }\n    \n        static class SubClass extends Parent{\n            public static int B = A;\n        }\n    \n        public static void main(String[] args) {\n            System.out.println(SubClass.B);\n        }\n    }\n    \n    //２\n    ```\n\n+ <clinit>()不是必须的，如果没有静态语句块和对变量的赋值操作，就不生成\n\n+ 虚拟机保证一个类的<clinit>()在多线程环境中被正确加锁同步，如果多个线程同时去初始化一个类，那么只有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待\n\n### 立即初始化情况\n\n+ 遇到new、getstatic、putstatic、invokestatic字节码指令时\n    + 使用new实例化对象\n    + 读取一个类型的静态字段（已在编译期把结果放入常量池的静态字段除外）\n    + 调用一个类型的静态方法\n+ 使用reflect包对类型进行反射调用\n+ 初始化类，发现父类还没有进行过初始化\n    + 则先触发其父类的初始化\n    + 一个接口在初始化时，并不要求其父类全部已经初始化过，只有真正使用到父接口时（如引用接口中定义的常量）才会初始化\n+ JVM启动时，指定执行主类则JVM会先初始化这个主类\n+ 使用动态语言支持，使用MethodHandle\n+ 接口定义了默认方法（default方法)，该接口的实现类初始化，则该接口也要初始化\n\n**被动引用**\n\n除上面主动引用的情况外，所有引用类型的方式都不会触发初始化\n\n**例子1**\n\n+ 非主动使用类字段\n\n+ 对于静态字段，只有直接定义这个字段的类才会被初始化\n\n+ 因此通过其子类来引用父类中定义的静态字段，只会触发其父类的初始化而不会触发子类的初始化\n\n    ```java\n    public class SuperClass {\n        public static int value = 123;\n        static {\n            System.out.println(\"SuperClass init!\");\n        }\n    }\n    \n    public class SubClass extends SuperClass {\n        static {\n            System.out.println(\"SubClass init!\");\n        }\n    }\n    \n    public class Main {\n    \n        public static void main(String[] args) {\n            System.out.println(SubClass.value);\n        }\n    }\n    /*\n    SuperClass init!\n            123\n    */\n    ```\n\n**例子2**\n\n+ SuperClass[] superClasses = new SuperClass[10];\n+ 没有触发SuperClass的初始化\n+ 触发了[SuperClass的初始化\n    + 由虚拟机自动生成的\n    + 直接继承Object的子类\n    + 由newarray字节码触发\n    + 代表了元素类型为SuperClass的一维数组\n    + 数组越界则抛出ArrayIndexOutOfBoundsException\n\n**例子3**\n\n```java\npublic class ConstClass {\n    static {\n        System.out.println(\"ConstClass init\");\n    }\n\n    public static final String HELLO = \"hello world\";\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(ConstClass.HELLO);\n    }\n}\n\n//hello world\n```\n\n+ 常量在编译阶段会存入调用类的常量池中，本质没有引用到定义常量的类，因此不会触发定义常量的类的初始化\n+ 编译阶段的常量传播优化，将常量的值直接存储到Main类的常量池中，对他的引用全部转为对自身常量池的引用\n+ Main的Class文件没有ConstClass的符号引用入口，这两个类在编译成Class文件后不存在任何关系了\n\n# 类加载器\n\n## 概述\n\n+ 类加载器：通过一个类的全限定名来获取描述该类的二进制字节流\n+ 对于任意一个类，都必须由他的类加载器和这个类的本身一同确立他的唯一性\n+ 每一个类加载器，都拥有一个独立的类名称空间\n+ 比较两个类是否相等，只有他们在同一个类加载器下才有意义，否则就算他们来自同一个Class文件，被同一个虚拟机加载，只要他们类加载器不同，他们就不是同一个类\n+ 所指的相等，包括equals()方法，instanceof关键字的判断\n+ 保持着三层类加载器、双亲委派的类加载结构\n\n## 启动类加载器\n\n+ Bootstrap ClassLoader\n+ 使用C++语言实现\n+ 是虚拟机自身的一部分\n+ 负责加载<JAVA_HOME>\\lib目录\n+ 启动类加载器无法被Java程序直接引用，如果需要把加载请求委派给启动类加载器处理，则用null代替\n\n## 其他所有的类加载器\n\n+ 由Java语言实现\n+ 独立在虚拟机外部\n+ 全部继承抽象类java.lang.ClassLoader\n+ 扩展类加载器(Extension ClassLoader)\n    + 负责加载<JAVA_HOME>\\lib\\ext目录下类库\n    + 是一种Java系统类库的扩展机制\n    + 允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能\n\n+ 应用程序类加载器(Application ClassLoader)\n    + 也称为系统类加载器。\n    + 负责加载用户类路径（ClassPath)上所有的类库。如果没有定义自己的类加载器，则它就是程序默认的类加载器\n\n## 双亲委派模型\n\n+ 除了顶层的启动类加载器，其余的类加载器都应有自己的父类加载器，通常使用组合关系来复用父加载器的代码\n+ 如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载\n+ 类随着他的类加载器一起具备了一种带有优先级的层次关系\n+ 例如Object类，无论哪个类加载器去加载他，都会委派到启动类加载器进行执行，因此Object类在不同的类加载器环境下都能保证是同一个类\n+ 如果没有双亲委派模型，用户自定义java.lang.Object类，系统就会出现多个不同的Object类，代码将一片混乱\n+ 先检查请求加载的类型是否已经被加载过，若没有则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器，如果父类加载器加载失败，抛出异常了，才调用自己的findClass()方法尝试进行加载\n\n```java\nprotected Class<?> loadClass(String name， boolean resolve)\n        throws ClassNotFoundException\n    {\n            // 首先，检查是否已经被类加载器加载过\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                try {\n            // 存在父加载器，递归的交由父加载器\n                    if (parent != null) {\n                        c = parent.loadClass(name， false);\n                    } else {\n                // 直到最上面的Bootstrap类加载器\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // 如果父类加载器抛出ClassNotFoundException\n                    // f说明父类加载器无法完成加载请求\n                }\n\n                if (c == null) {\n                    // 在父类加载器无法加载时\n                    // 再调用自身的findClass方法来进行类加载\n                    c = findClass(name);\n                }\n            }\n            return c;\n    }\n```\n\n## 打破双亲委派机制\n\n### 重写loadclass方法\n\n打破双亲委派机制，即在类加载的时候不是传递到父类加载器中加载，而是由自己加载。\n\n此时需要自定义一个类加载器，继承ClassLoader类，然后重写父类的findClass方法和loadClass方法。\n\n这里最主要的是重写loadclass方法，因为双亲委派机制的实现都是通过这个方法实现的，先找父加载器进行加载，如果父加载器无法加载再由自己来进行加载，源码里会直接找到根加载器，重写了这个方法以后就能自己定义加载的方式了\n\n### 线程上下文类加载器\n\n通过给当前线程设置上下文类加载器，就可以设置的上下文类加载器来实现对于接口实现类的加载。\n\n解决父类加载器去请求子类加载器完成类加载的行为\n\n### OSGi实现模块化热部署\n\n代码热替换、模块热部署等，机器不用重启，只要部署上就能用。\n\nOSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构","source":"_posts/Java语言/Java虚拟机/3.类加载机制.md","raw":"---\ntitle: 类加载机制\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 学习Java虚拟机，包括类生命周期、类加载器、双亲委派模型等。\ncategories: Java虚拟机\ntags:\n  - 双亲委派模型\n  - 生命周期\n  - 类加载器\nabbrlink: cd1d308\ndate: 2021-02-27 00:00:00\n---\n\n\n\n# 简介\n\n+ JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程就是类加载机制\n+ 在程序运行时完成的\n+ 动态扩展的语言特性就是依赖于运行期动态加载和动态连接，例如编写一个面向接口的程序，可以等到运行时再指定其实际的实现类\n\n\n\n# 生命周期\n\n+ 解析阶段某些情况可以再初始化阶段之后才开始（为了支持运行时绑定特性）\n+ 这些阶段通常相互交叉地混合进行，会在一个阶段执行的过程中调用、激活另一个阶段\n\n## 加载\n\n+ 通过一个类的全限定名获取定义此类的二进制字节流\n    + 从ZIP压缩包中读取，JAR的基础\n    + 从网络中读取，Web Applet\n    + 运行时计算生成，动态代理技术\n    + 从加密文件中获取，防Class文件被反编译的保护措施\n+ 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构\n+ 在Java堆内存中实例化生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口\n+ 数组加载\n    + 数组类本身不通过类加载器创建，由JVM直接在内存中动态构造出来\n    + 如果数组的组件类型是引用类型，递归采用加载过程去加载该组件类型，数组将标识在加载该组件类型的类加载器的类名称空间上\n    + 如果数组的组件类型是基本类型，数组将标识为与引导类加载器关联\n\n## 连接\n\n### 验证\n\n+ 目的是确保Class文件的字节流中包含的信息符合全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全\n+ 文件格式验证\n    + 验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理\n    + 保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求\n    + 基于二进制字节流进行的\n    + 后面的三个验证阶段全部基于方法区的存储结构了\n+ 元数据验证\n    + 对字节码描述的信息进行语义分析\n    + 是否有父类（除Object应都有父类）\n    + 是否继承了final类\n    + 是否实现了父类或接口要求实现的所有方法\n    + 类中字段、方法是否与父类产生矛盾\n+ 字节码验证\n    + 通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的\n    + 对类的方法体（Class文件中的Code属性）进行校验分析\n    + 保证被校验类的方法在运行时不会做出危害虚拟机安全的行为\n    + 保证任何跳转指令都不会跳转到方法体之外的字节码指令\n    + 保证类型转换都是有效的\n+ 符号引用验证\n    + 发生在符号引用转化为直接引用的时候，即解析阶段\n    + 验证该类是否缺少或被禁止访问他依赖的某些外部类、方法、字段等\n    + 验证符合引用中通过字符串描述的全限定名称是否能找到对应的类\n    + 验证在指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段\n    + 符号引用中类、字段、方法的可访问性\n\n### 准备\n\n+ 正式为类中静态变量分配内存并设置初始值\n+ 概念上是放在方法区，但是方法区是逻辑上的概念\n+ JDK8后，类变量随着Class对象一起存放在Java堆中\n+ 不包括实例变量，实例变量会在对象实例化时随对象一起分配在java堆中\n+ 如果字段属性表中存在ConstantValue属性，则直接被初始化为ConstantValue属性所指定的初始值，例如public static final int value = 123;\n\n### 解析\n\n+ 将常量池内的符号引用转换为直接引用的过程\n+ 虚拟机可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，避免重复解析\n+ 符号引用\n    + 以一组符合来描述所引用的目标，可以是任何形式的字面量\n    + 与JVM的内存布局无关\n    + 引用的目标不一定是已加载到虚拟机内存的内容\n+ 直接引用\n    + 可以直接指向目标的指针、相对偏移量或者句柄\n    + 和JVM实现的内存布局相关\n    + 引用的目标必定已经在虚拟机内存中\n+ 类或接口的解析\n    + 假设当前代码所处的类为D，要把从未解析过的符号引用N解析为一个类或接口C\n    + 如果C不是一个数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C\n    + 如果C是一个数组类型，并且数组的元素类型为对象，会先按上面的方法加载数组元素类型，再由虚拟机生成一个代表该数组维度和元素的数组对象\n    + 在解析完成之前，要进行符号引用验证，确认D是否具备对C的访问权限\n\n## 初始化\n\n+ JVM真正执行类中编写的Java代码，将主导权移交给应用程序\n\n+ 初始化类变量和其他资源，即执行类构造器<clinit>的过程，是编译器自动生成的方法\n\n+ 由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并而成的。收集的顺序由在源文件出现的顺序决定\n\n+ 静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，只能赋值，不能访问\n\n    + ```java\n        static {\n                i = 0; //给变量赋值可以正常编译通过\n                System.out.println(i); //提示非法前向引用\n            }\n        \n            static int i = 1;\n        ```\n\n        \n\n+ <clinit>不需要显式调用父类构造器，虚拟机保证父类的已经执行完毕，因此ＪＶＭ第一个被执行的<clinit>方法肯定是Object\n\n+ 父类的`<clinit>()`先执行，所以父类中定义的静态语句块优先于之类的变量赋值操作\n\n+ ```java\n    public class Main {\n        static class Parent {\n            public static int A = 1;\n            static{\n                A = 2;\n            }\n        }\n    \n        static class SubClass extends Parent{\n            public static int B = A;\n        }\n    \n        public static void main(String[] args) {\n            System.out.println(SubClass.B);\n        }\n    }\n    \n    //２\n    ```\n\n+ <clinit>()不是必须的，如果没有静态语句块和对变量的赋值操作，就不生成\n\n+ 虚拟机保证一个类的<clinit>()在多线程环境中被正确加锁同步，如果多个线程同时去初始化一个类，那么只有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待\n\n### 立即初始化情况\n\n+ 遇到new、getstatic、putstatic、invokestatic字节码指令时\n    + 使用new实例化对象\n    + 读取一个类型的静态字段（已在编译期把结果放入常量池的静态字段除外）\n    + 调用一个类型的静态方法\n+ 使用reflect包对类型进行反射调用\n+ 初始化类，发现父类还没有进行过初始化\n    + 则先触发其父类的初始化\n    + 一个接口在初始化时，并不要求其父类全部已经初始化过，只有真正使用到父接口时（如引用接口中定义的常量）才会初始化\n+ JVM启动时，指定执行主类则JVM会先初始化这个主类\n+ 使用动态语言支持，使用MethodHandle\n+ 接口定义了默认方法（default方法)，该接口的实现类初始化，则该接口也要初始化\n\n**被动引用**\n\n除上面主动引用的情况外，所有引用类型的方式都不会触发初始化\n\n**例子1**\n\n+ 非主动使用类字段\n\n+ 对于静态字段，只有直接定义这个字段的类才会被初始化\n\n+ 因此通过其子类来引用父类中定义的静态字段，只会触发其父类的初始化而不会触发子类的初始化\n\n    ```java\n    public class SuperClass {\n        public static int value = 123;\n        static {\n            System.out.println(\"SuperClass init!\");\n        }\n    }\n    \n    public class SubClass extends SuperClass {\n        static {\n            System.out.println(\"SubClass init!\");\n        }\n    }\n    \n    public class Main {\n    \n        public static void main(String[] args) {\n            System.out.println(SubClass.value);\n        }\n    }\n    /*\n    SuperClass init!\n            123\n    */\n    ```\n\n**例子2**\n\n+ SuperClass[] superClasses = new SuperClass[10];\n+ 没有触发SuperClass的初始化\n+ 触发了[SuperClass的初始化\n    + 由虚拟机自动生成的\n    + 直接继承Object的子类\n    + 由newarray字节码触发\n    + 代表了元素类型为SuperClass的一维数组\n    + 数组越界则抛出ArrayIndexOutOfBoundsException\n\n**例子3**\n\n```java\npublic class ConstClass {\n    static {\n        System.out.println(\"ConstClass init\");\n    }\n\n    public static final String HELLO = \"hello world\";\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(ConstClass.HELLO);\n    }\n}\n\n//hello world\n```\n\n+ 常量在编译阶段会存入调用类的常量池中，本质没有引用到定义常量的类，因此不会触发定义常量的类的初始化\n+ 编译阶段的常量传播优化，将常量的值直接存储到Main类的常量池中，对他的引用全部转为对自身常量池的引用\n+ Main的Class文件没有ConstClass的符号引用入口，这两个类在编译成Class文件后不存在任何关系了\n\n# 类加载器\n\n## 概述\n\n+ 类加载器：通过一个类的全限定名来获取描述该类的二进制字节流\n+ 对于任意一个类，都必须由他的类加载器和这个类的本身一同确立他的唯一性\n+ 每一个类加载器，都拥有一个独立的类名称空间\n+ 比较两个类是否相等，只有他们在同一个类加载器下才有意义，否则就算他们来自同一个Class文件，被同一个虚拟机加载，只要他们类加载器不同，他们就不是同一个类\n+ 所指的相等，包括equals()方法，instanceof关键字的判断\n+ 保持着三层类加载器、双亲委派的类加载结构\n\n## 启动类加载器\n\n+ Bootstrap ClassLoader\n+ 使用C++语言实现\n+ 是虚拟机自身的一部分\n+ 负责加载<JAVA_HOME>\\lib目录\n+ 启动类加载器无法被Java程序直接引用，如果需要把加载请求委派给启动类加载器处理，则用null代替\n\n## 其他所有的类加载器\n\n+ 由Java语言实现\n+ 独立在虚拟机外部\n+ 全部继承抽象类java.lang.ClassLoader\n+ 扩展类加载器(Extension ClassLoader)\n    + 负责加载<JAVA_HOME>\\lib\\ext目录下类库\n    + 是一种Java系统类库的扩展机制\n    + 允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能\n\n+ 应用程序类加载器(Application ClassLoader)\n    + 也称为系统类加载器。\n    + 负责加载用户类路径（ClassPath)上所有的类库。如果没有定义自己的类加载器，则它就是程序默认的类加载器\n\n## 双亲委派模型\n\n+ 除了顶层的启动类加载器，其余的类加载器都应有自己的父类加载器，通常使用组合关系来复用父加载器的代码\n+ 如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载\n+ 类随着他的类加载器一起具备了一种带有优先级的层次关系\n+ 例如Object类，无论哪个类加载器去加载他，都会委派到启动类加载器进行执行，因此Object类在不同的类加载器环境下都能保证是同一个类\n+ 如果没有双亲委派模型，用户自定义java.lang.Object类，系统就会出现多个不同的Object类，代码将一片混乱\n+ 先检查请求加载的类型是否已经被加载过，若没有则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器，如果父类加载器加载失败，抛出异常了，才调用自己的findClass()方法尝试进行加载\n\n```java\nprotected Class<?> loadClass(String name， boolean resolve)\n        throws ClassNotFoundException\n    {\n            // 首先，检查是否已经被类加载器加载过\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                try {\n            // 存在父加载器，递归的交由父加载器\n                    if (parent != null) {\n                        c = parent.loadClass(name， false);\n                    } else {\n                // 直到最上面的Bootstrap类加载器\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // 如果父类加载器抛出ClassNotFoundException\n                    // f说明父类加载器无法完成加载请求\n                }\n\n                if (c == null) {\n                    // 在父类加载器无法加载时\n                    // 再调用自身的findClass方法来进行类加载\n                    c = findClass(name);\n                }\n            }\n            return c;\n    }\n```\n\n## 打破双亲委派机制\n\n### 重写loadclass方法\n\n打破双亲委派机制，即在类加载的时候不是传递到父类加载器中加载，而是由自己加载。\n\n此时需要自定义一个类加载器，继承ClassLoader类，然后重写父类的findClass方法和loadClass方法。\n\n这里最主要的是重写loadclass方法，因为双亲委派机制的实现都是通过这个方法实现的，先找父加载器进行加载，如果父加载器无法加载再由自己来进行加载，源码里会直接找到根加载器，重写了这个方法以后就能自己定义加载的方式了\n\n### 线程上下文类加载器\n\n通过给当前线程设置上下文类加载器，就可以设置的上下文类加载器来实现对于接口实现类的加载。\n\n解决父类加载器去请求子类加载器完成类加载的行为\n\n### OSGi实现模块化热部署\n\n代码热替换、模块热部署等，机器不用重启，只要部署上就能用。\n\nOSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构","slug":"Java语言/Java虚拟机/3.类加载机制","published":1,"updated":"2021-06-08T03:35:00.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq50y000kz0tpayvugbgz","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><ul>\n<li>JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程就是类加载机制</li>\n<li>在程序运行时完成的</li>\n<li>动态扩展的语言特性就是依赖于运行期动态加载和动态连接，例如编写一个面向接口的程序，可以等到运行时再指定其实际的实现类</li>\n</ul>\n<h1 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h1><ul>\n<li>解析阶段某些情况可以再初始化阶段之后才开始（为了支持运行时绑定特性）</li>\n<li>这些阶段通常相互交叉地混合进行，会在一个阶段执行的过程中调用、激活另一个阶段</li>\n</ul>\n<h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><ul>\n<li>通过一个类的全限定名获取定义此类的二进制字节流<ul>\n<li>从ZIP压缩包中读取，JAR的基础</li>\n<li>从网络中读取，Web Applet</li>\n<li>运行时计算生成，动态代理技术</li>\n<li>从加密文件中获取，防Class文件被反编译的保护措施</li>\n</ul>\n</li>\n<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>\n<li>在Java堆内存中实例化生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口</li>\n<li>数组加载<ul>\n<li>数组类本身不通过类加载器创建，由JVM直接在内存中动态构造出来</li>\n<li>如果数组的组件类型是引用类型，递归采用加载过程去加载该组件类型，数组将标识在加载该组件类型的类加载器的类名称空间上</li>\n<li>如果数组的组件类型是基本类型，数组将标识为与引导类加载器关联</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><ul>\n<li>目的是确保Class文件的字节流中包含的信息符合全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</li>\n<li>文件格式验证<ul>\n<li>验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理</li>\n<li>保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求</li>\n<li>基于二进制字节流进行的</li>\n<li>后面的三个验证阶段全部基于方法区的存储结构了</li>\n</ul>\n</li>\n<li>元数据验证<ul>\n<li>对字节码描述的信息进行语义分析</li>\n<li>是否有父类（除Object应都有父类）</li>\n<li>是否继承了final类</li>\n<li>是否实现了父类或接口要求实现的所有方法</li>\n<li>类中字段、方法是否与父类产生矛盾</li>\n</ul>\n</li>\n<li>字节码验证<ul>\n<li>通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的</li>\n<li>对类的方法体（Class文件中的Code属性）进行校验分析</li>\n<li>保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</li>\n<li>保证任何跳转指令都不会跳转到方法体之外的字节码指令</li>\n<li>保证类型转换都是有效的</li>\n</ul>\n</li>\n<li>符号引用验证<ul>\n<li>发生在符号引用转化为直接引用的时候，即解析阶段</li>\n<li>验证该类是否缺少或被禁止访问他依赖的某些外部类、方法、字段等</li>\n<li>验证符合引用中通过字符串描述的全限定名称是否能找到对应的类</li>\n<li>验证在指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段</li>\n<li>符号引用中类、字段、方法的可访问性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><ul>\n<li>正式为类中静态变量分配内存并设置初始值</li>\n<li>概念上是放在方法区，但是方法区是逻辑上的概念</li>\n<li>JDK8后，类变量随着Class对象一起存放在Java堆中</li>\n<li>不包括实例变量，实例变量会在对象实例化时随对象一起分配在java堆中</li>\n<li>如果字段属性表中存在ConstantValue属性，则直接被初始化为ConstantValue属性所指定的初始值，例如public static final int value = 123;</li>\n</ul>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><ul>\n<li>将常量池内的符号引用转换为直接引用的过程</li>\n<li>虚拟机可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，避免重复解析</li>\n<li>符号引用<ul>\n<li>以一组符合来描述所引用的目标，可以是任何形式的字面量</li>\n<li>与JVM的内存布局无关</li>\n<li>引用的目标不一定是已加载到虚拟机内存的内容</li>\n</ul>\n</li>\n<li>直接引用<ul>\n<li>可以直接指向目标的指针、相对偏移量或者句柄</li>\n<li>和JVM实现的内存布局相关</li>\n<li>引用的目标必定已经在虚拟机内存中</li>\n</ul>\n</li>\n<li>类或接口的解析<ul>\n<li>假设当前代码所处的类为D，要把从未解析过的符号引用N解析为一个类或接口C</li>\n<li>如果C不是一个数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C</li>\n<li>如果C是一个数组类型，并且数组的元素类型为对象，会先按上面的方法加载数组元素类型，再由虚拟机生成一个代表该数组维度和元素的数组对象</li>\n<li>在解析完成之前，要进行符号引用验证，确认D是否具备对C的访问权限</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><ul>\n<li><p>JVM真正执行类中编写的Java代码，将主导权移交给应用程序</p>\n</li>\n<li><p>初始化类变量和其他资源，即执行类构造器<clinit>的过程，是编译器自动生成的方法</p>\n</li>\n<li><p>由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并而成的。收集的顺序由在源文件出现的顺序决定</p>\n</li>\n<li><p>静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，只能赋值，不能访问</p>\n<ul>\n<li><pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n          i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//给变量赋值可以正常编译通过</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//提示非法前向引用</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><clinit>不需要显式调用父类构造器，虚拟机保证父类的已经执行完毕，因此ＪＶＭ第一个被执行的<clinit>方法肯定是Object</p>\n</li>\n<li><p>父类的<code>&lt;clinit&gt;()</code>先执行，所以父类中定义的静态语句块优先于之类的变量赋值操作</p>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Parent</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> A <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">static</span><span class=\"token punctuation\">{</span>\n              A <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SubClass</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> B <span class=\"token operator\">=</span> A<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>SubClass<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">//２</span></code></pre>\n</li>\n<li><p><clinit>()不是必须的，如果没有静态语句块和对变量的赋值操作，就不生成</p>\n</li>\n<li><p>虚拟机保证一个类的<clinit>()在多线程环境中被正确加锁同步，如果多个线程同时去初始化一个类，那么只有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待</p>\n</li>\n</ul>\n<h3 id=\"立即初始化情况\"><a href=\"#立即初始化情况\" class=\"headerlink\" title=\"立即初始化情况\"></a>立即初始化情况</h3><ul>\n<li>遇到new、getstatic、putstatic、invokestatic字节码指令时<ul>\n<li>使用new实例化对象</li>\n<li>读取一个类型的静态字段（已在编译期把结果放入常量池的静态字段除外）</li>\n<li>调用一个类型的静态方法</li>\n</ul>\n</li>\n<li>使用reflect包对类型进行反射调用</li>\n<li>初始化类，发现父类还没有进行过初始化<ul>\n<li>则先触发其父类的初始化</li>\n<li>一个接口在初始化时，并不要求其父类全部已经初始化过，只有真正使用到父接口时（如引用接口中定义的常量）才会初始化</li>\n</ul>\n</li>\n<li>JVM启动时，指定执行主类则JVM会先初始化这个主类</li>\n<li>使用动态语言支持，使用MethodHandle</li>\n<li>接口定义了默认方法（default方法)，该接口的实现类初始化，则该接口也要初始化</li>\n</ul>\n<p><strong>被动引用</strong></p>\n<p>除上面主动引用的情况外，所有引用类型的方式都不会触发初始化</p>\n<p><strong>例子1</strong></p>\n<ul>\n<li><p>非主动使用类字段</p>\n</li>\n<li><p>对于静态字段，只有直接定义这个字段的类才会被初始化</p>\n</li>\n<li><p>因此通过其子类来引用父类中定义的静态字段，只会触发其父类的初始化而不会触发子类的初始化</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SuperClass</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SuperClass init!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SubClass</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SuperClass</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SubClass init!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>SubClass<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/*\nSuperClass init!\n        123\n*/</span></code></pre>\n</li>\n</ul>\n<p><strong>例子2</strong></p>\n<ul>\n<li>SuperClass[] superClasses = new SuperClass[10];</li>\n<li>没有触发SuperClass的初始化</li>\n<li>触发了[SuperClass的初始化<ul>\n<li>由虚拟机自动生成的</li>\n<li>直接继承Object的子类</li>\n<li>由newarray字节码触发</li>\n<li>代表了元素类型为SuperClass的一维数组</li>\n<li>数组越界则抛出ArrayIndexOutOfBoundsException</li>\n</ul>\n</li>\n</ul>\n<p><strong>例子3</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ConstClass</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ConstClass init\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String HELLO <span class=\"token operator\">=</span> <span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>ConstClass<span class=\"token punctuation\">.</span>HELLO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//hello world</span></code></pre>\n<ul>\n<li>常量在编译阶段会存入调用类的常量池中，本质没有引用到定义常量的类，因此不会触发定义常量的类的初始化</li>\n<li>编译阶段的常量传播优化，将常量的值直接存储到Main类的常量池中，对他的引用全部转为对自身常量池的引用</li>\n<li>Main的Class文件没有ConstClass的符号引用入口，这两个类在编译成Class文件后不存在任何关系了</li>\n</ul>\n<h1 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li>类加载器：通过一个类的全限定名来获取描述该类的二进制字节流</li>\n<li>对于任意一个类，都必须由他的类加载器和这个类的本身一同确立他的唯一性</li>\n<li>每一个类加载器，都拥有一个独立的类名称空间</li>\n<li>比较两个类是否相等，只有他们在同一个类加载器下才有意义，否则就算他们来自同一个Class文件，被同一个虚拟机加载，只要他们类加载器不同，他们就不是同一个类</li>\n<li>所指的相等，包括equals()方法，instanceof关键字的判断</li>\n<li>保持着三层类加载器、双亲委派的类加载结构</li>\n</ul>\n<h2 id=\"启动类加载器\"><a href=\"#启动类加载器\" class=\"headerlink\" title=\"启动类加载器\"></a>启动类加载器</h2><ul>\n<li>Bootstrap ClassLoader</li>\n<li>使用C++语言实现</li>\n<li>是虚拟机自身的一部分</li>\n<li>负责加载<JAVA_HOME>\\lib目录</li>\n<li>启动类加载器无法被Java程序直接引用，如果需要把加载请求委派给启动类加载器处理，则用null代替</li>\n</ul>\n<h2 id=\"其他所有的类加载器\"><a href=\"#其他所有的类加载器\" class=\"headerlink\" title=\"其他所有的类加载器\"></a>其他所有的类加载器</h2><ul>\n<li><p>由Java语言实现</p>\n</li>\n<li><p>独立在虚拟机外部</p>\n</li>\n<li><p>全部继承抽象类java.lang.ClassLoader</p>\n</li>\n<li><p>扩展类加载器(Extension ClassLoader)</p>\n<ul>\n<li>负责加载<JAVA_HOME>\\lib\\ext目录下类库</li>\n<li>是一种Java系统类库的扩展机制</li>\n<li>允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能</li>\n</ul>\n</li>\n<li><p>应用程序类加载器(Application ClassLoader)</p>\n<ul>\n<li>也称为系统类加载器。</li>\n<li>负责加载用户类路径（ClassPath)上所有的类库。如果没有定义自己的类加载器，则它就是程序默认的类加载器</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h2><ul>\n<li>除了顶层的启动类加载器，其余的类加载器都应有自己的父类加载器，通常使用组合关系来复用父加载器的代码</li>\n<li>如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载</li>\n<li>类随着他的类加载器一起具备了一种带有优先级的层次关系</li>\n<li>例如Object类，无论哪个类加载器去加载他，都会委派到启动类加载器进行执行，因此Object类在不同的类加载器环境下都能保证是同一个类</li>\n<li>如果没有双亲委派模型，用户自定义java.lang.Object类，系统就会出现多个不同的Object类，代码将一片混乱</li>\n<li>先检查请求加载的类型是否已经被加载过，若没有则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器，如果父类加载器加载失败，抛出异常了，才调用自己的findClass()方法尝试进行加载</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> <span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>String name， <span class=\"token keyword\">boolean</span> resolve<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throws</span> ClassNotFoundException\n    <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 首先，检查是否已经被类加载器加载过</span>\n            Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> c <span class=\"token operator\">=</span> <span class=\"token function\">findLoadedClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 存在父加载器，递归的交由父加载器</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        c <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">.</span><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>name， <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 直到最上面的Bootstrap类加载器</span>\n                        c <span class=\"token operator\">=</span> <span class=\"token function\">findBootstrapClassOrNull</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果父类加载器抛出ClassNotFoundException</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// f说明父类加载器无法完成加载请求</span>\n                <span class=\"token punctuation\">}</span>\n\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 在父类加载器无法加载时</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 再调用自身的findClass方法来进行类加载</span>\n                    c <span class=\"token operator\">=</span> <span class=\"token function\">findClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"打破双亲委派机制\"><a href=\"#打破双亲委派机制\" class=\"headerlink\" title=\"打破双亲委派机制\"></a>打破双亲委派机制</h2><h3 id=\"重写loadclass方法\"><a href=\"#重写loadclass方法\" class=\"headerlink\" title=\"重写loadclass方法\"></a>重写loadclass方法</h3><p>打破双亲委派机制，即在类加载的时候不是传递到父类加载器中加载，而是由自己加载。</p>\n<p>此时需要自定义一个类加载器，继承ClassLoader类，然后重写父类的findClass方法和loadClass方法。</p>\n<p>这里最主要的是重写loadclass方法，因为双亲委派机制的实现都是通过这个方法实现的，先找父加载器进行加载，如果父加载器无法加载再由自己来进行加载，源码里会直接找到根加载器，重写了这个方法以后就能自己定义加载的方式了</p>\n<h3 id=\"线程上下文类加载器\"><a href=\"#线程上下文类加载器\" class=\"headerlink\" title=\"线程上下文类加载器\"></a>线程上下文类加载器</h3><p>通过给当前线程设置上下文类加载器，就可以设置的上下文类加载器来实现对于接口实现类的加载。</p>\n<p>解决父类加载器去请求子类加载器完成类加载的行为</p>\n<h3 id=\"OSGi实现模块化热部署\"><a href=\"#OSGi实现模块化热部署\" class=\"headerlink\" title=\"OSGi实现模块化热部署\"></a>OSGi实现模块化热部署</h3><p>代码热替换、模块热部署等，机器不用重启，只要部署上就能用。</p>\n<p>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><ul>\n<li>JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程就是类加载机制</li>\n<li>在程序运行时完成的</li>\n<li>动态扩展的语言特性就是依赖于运行期动态加载和动态连接，例如编写一个面向接口的程序，可以等到运行时再指定其实际的实现类</li>\n</ul>\n<h1 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h1><ul>\n<li>解析阶段某些情况可以再初始化阶段之后才开始（为了支持运行时绑定特性）</li>\n<li>这些阶段通常相互交叉地混合进行，会在一个阶段执行的过程中调用、激活另一个阶段</li>\n</ul>\n<h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><ul>\n<li>通过一个类的全限定名获取定义此类的二进制字节流<ul>\n<li>从ZIP压缩包中读取，JAR的基础</li>\n<li>从网络中读取，Web Applet</li>\n<li>运行时计算生成，动态代理技术</li>\n<li>从加密文件中获取，防Class文件被反编译的保护措施</li>\n</ul>\n</li>\n<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>\n<li>在Java堆内存中实例化生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口</li>\n<li>数组加载<ul>\n<li>数组类本身不通过类加载器创建，由JVM直接在内存中动态构造出来</li>\n<li>如果数组的组件类型是引用类型，递归采用加载过程去加载该组件类型，数组将标识在加载该组件类型的类加载器的类名称空间上</li>\n<li>如果数组的组件类型是基本类型，数组将标识为与引导类加载器关联</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><ul>\n<li>目的是确保Class文件的字节流中包含的信息符合全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</li>\n<li>文件格式验证<ul>\n<li>验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理</li>\n<li>保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求</li>\n<li>基于二进制字节流进行的</li>\n<li>后面的三个验证阶段全部基于方法区的存储结构了</li>\n</ul>\n</li>\n<li>元数据验证<ul>\n<li>对字节码描述的信息进行语义分析</li>\n<li>是否有父类（除Object应都有父类）</li>\n<li>是否继承了final类</li>\n<li>是否实现了父类或接口要求实现的所有方法</li>\n<li>类中字段、方法是否与父类产生矛盾</li>\n</ul>\n</li>\n<li>字节码验证<ul>\n<li>通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的</li>\n<li>对类的方法体（Class文件中的Code属性）进行校验分析</li>\n<li>保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</li>\n<li>保证任何跳转指令都不会跳转到方法体之外的字节码指令</li>\n<li>保证类型转换都是有效的</li>\n</ul>\n</li>\n<li>符号引用验证<ul>\n<li>发生在符号引用转化为直接引用的时候，即解析阶段</li>\n<li>验证该类是否缺少或被禁止访问他依赖的某些外部类、方法、字段等</li>\n<li>验证符合引用中通过字符串描述的全限定名称是否能找到对应的类</li>\n<li>验证在指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段</li>\n<li>符号引用中类、字段、方法的可访问性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><ul>\n<li>正式为类中静态变量分配内存并设置初始值</li>\n<li>概念上是放在方法区，但是方法区是逻辑上的概念</li>\n<li>JDK8后，类变量随着Class对象一起存放在Java堆中</li>\n<li>不包括实例变量，实例变量会在对象实例化时随对象一起分配在java堆中</li>\n<li>如果字段属性表中存在ConstantValue属性，则直接被初始化为ConstantValue属性所指定的初始值，例如public static final int value = 123;</li>\n</ul>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><ul>\n<li>将常量池内的符号引用转换为直接引用的过程</li>\n<li>虚拟机可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，避免重复解析</li>\n<li>符号引用<ul>\n<li>以一组符合来描述所引用的目标，可以是任何形式的字面量</li>\n<li>与JVM的内存布局无关</li>\n<li>引用的目标不一定是已加载到虚拟机内存的内容</li>\n</ul>\n</li>\n<li>直接引用<ul>\n<li>可以直接指向目标的指针、相对偏移量或者句柄</li>\n<li>和JVM实现的内存布局相关</li>\n<li>引用的目标必定已经在虚拟机内存中</li>\n</ul>\n</li>\n<li>类或接口的解析<ul>\n<li>假设当前代码所处的类为D，要把从未解析过的符号引用N解析为一个类或接口C</li>\n<li>如果C不是一个数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C</li>\n<li>如果C是一个数组类型，并且数组的元素类型为对象，会先按上面的方法加载数组元素类型，再由虚拟机生成一个代表该数组维度和元素的数组对象</li>\n<li>在解析完成之前，要进行符号引用验证，确认D是否具备对C的访问权限</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><ul>\n<li><p>JVM真正执行类中编写的Java代码，将主导权移交给应用程序</p>\n</li>\n<li><p>初始化类变量和其他资源，即执行类构造器<clinit>的过程，是编译器自动生成的方法</p>\n</li>\n<li><p>由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并而成的。收集的顺序由在源文件出现的顺序决定</p>\n</li>\n<li><p>静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，只能赋值，不能访问</p>\n<ul>\n<li><pre><code class=\"java\">  static {\n          i = 0; //给变量赋值可以正常编译通过\n          System.out.println(i); //提示非法前向引用\n      }\n\n      static int i = 1;</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><clinit>不需要显式调用父类构造器，虚拟机保证父类的已经执行完毕，因此ＪＶＭ第一个被执行的<clinit>方法肯定是Object</p>\n</li>\n<li><p>父类的<code>&lt;clinit&gt;()</code>先执行，所以父类中定义的静态语句块优先于之类的变量赋值操作</p>\n</li>\n<li><pre><code class=\"java\">  public class Main {\n      static class Parent {\n          public static int A = 1;\n          static{\n              A = 2;\n          }\n      }\n\n      static class SubClass extends Parent{\n          public static int B = A;\n      }\n\n      public static void main(String[] args) {\n          System.out.println(SubClass.B);\n      }\n  }\n\n  //２</code></pre>\n</li>\n<li><p><clinit>()不是必须的，如果没有静态语句块和对变量的赋值操作，就不生成</p>\n</li>\n<li><p>虚拟机保证一个类的<clinit>()在多线程环境中被正确加锁同步，如果多个线程同时去初始化一个类，那么只有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待</p>\n</li>\n</ul>\n<h3 id=\"立即初始化情况\"><a href=\"#立即初始化情况\" class=\"headerlink\" title=\"立即初始化情况\"></a>立即初始化情况</h3><ul>\n<li>遇到new、getstatic、putstatic、invokestatic字节码指令时<ul>\n<li>使用new实例化对象</li>\n<li>读取一个类型的静态字段（已在编译期把结果放入常量池的静态字段除外）</li>\n<li>调用一个类型的静态方法</li>\n</ul>\n</li>\n<li>使用reflect包对类型进行反射调用</li>\n<li>初始化类，发现父类还没有进行过初始化<ul>\n<li>则先触发其父类的初始化</li>\n<li>一个接口在初始化时，并不要求其父类全部已经初始化过，只有真正使用到父接口时（如引用接口中定义的常量）才会初始化</li>\n</ul>\n</li>\n<li>JVM启动时，指定执行主类则JVM会先初始化这个主类</li>\n<li>使用动态语言支持，使用MethodHandle</li>\n<li>接口定义了默认方法（default方法)，该接口的实现类初始化，则该接口也要初始化</li>\n</ul>\n<p><strong>被动引用</strong></p>\n<p>除上面主动引用的情况外，所有引用类型的方式都不会触发初始化</p>\n<p><strong>例子1</strong></p>\n<ul>\n<li><p>非主动使用类字段</p>\n</li>\n<li><p>对于静态字段，只有直接定义这个字段的类才会被初始化</p>\n</li>\n<li><p>因此通过其子类来引用父类中定义的静态字段，只会触发其父类的初始化而不会触发子类的初始化</p>\n<pre><code class=\"java\">public class SuperClass {\n    public static int value = 123;\n    static {\n        System.out.println(&quot;SuperClass init!&quot;);\n    }\n}\n\npublic class SubClass extends SuperClass {\n    static {\n        System.out.println(&quot;SubClass init!&quot;);\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(SubClass.value);\n    }\n}\n/*\nSuperClass init!\n        123\n*/</code></pre>\n</li>\n</ul>\n<p><strong>例子2</strong></p>\n<ul>\n<li>SuperClass[] superClasses = new SuperClass[10];</li>\n<li>没有触发SuperClass的初始化</li>\n<li>触发了[SuperClass的初始化<ul>\n<li>由虚拟机自动生成的</li>\n<li>直接继承Object的子类</li>\n<li>由newarray字节码触发</li>\n<li>代表了元素类型为SuperClass的一维数组</li>\n<li>数组越界则抛出ArrayIndexOutOfBoundsException</li>\n</ul>\n</li>\n</ul>\n<p><strong>例子3</strong></p>\n<pre><code class=\"java\">public class ConstClass {\n    static {\n        System.out.println(&quot;ConstClass init&quot;);\n    }\n\n    public static final String HELLO = &quot;hello world&quot;;\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(ConstClass.HELLO);\n    }\n}\n\n//hello world</code></pre>\n<ul>\n<li>常量在编译阶段会存入调用类的常量池中，本质没有引用到定义常量的类，因此不会触发定义常量的类的初始化</li>\n<li>编译阶段的常量传播优化，将常量的值直接存储到Main类的常量池中，对他的引用全部转为对自身常量池的引用</li>\n<li>Main的Class文件没有ConstClass的符号引用入口，这两个类在编译成Class文件后不存在任何关系了</li>\n</ul>\n<h1 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li>类加载器：通过一个类的全限定名来获取描述该类的二进制字节流</li>\n<li>对于任意一个类，都必须由他的类加载器和这个类的本身一同确立他的唯一性</li>\n<li>每一个类加载器，都拥有一个独立的类名称空间</li>\n<li>比较两个类是否相等，只有他们在同一个类加载器下才有意义，否则就算他们来自同一个Class文件，被同一个虚拟机加载，只要他们类加载器不同，他们就不是同一个类</li>\n<li>所指的相等，包括equals()方法，instanceof关键字的判断</li>\n<li>保持着三层类加载器、双亲委派的类加载结构</li>\n</ul>\n<h2 id=\"启动类加载器\"><a href=\"#启动类加载器\" class=\"headerlink\" title=\"启动类加载器\"></a>启动类加载器</h2><ul>\n<li>Bootstrap ClassLoader</li>\n<li>使用C++语言实现</li>\n<li>是虚拟机自身的一部分</li>\n<li>负责加载<JAVA_HOME>\\lib目录</li>\n<li>启动类加载器无法被Java程序直接引用，如果需要把加载请求委派给启动类加载器处理，则用null代替</li>\n</ul>\n<h2 id=\"其他所有的类加载器\"><a href=\"#其他所有的类加载器\" class=\"headerlink\" title=\"其他所有的类加载器\"></a>其他所有的类加载器</h2><ul>\n<li><p>由Java语言实现</p>\n</li>\n<li><p>独立在虚拟机外部</p>\n</li>\n<li><p>全部继承抽象类java.lang.ClassLoader</p>\n</li>\n<li><p>扩展类加载器(Extension ClassLoader)</p>\n<ul>\n<li>负责加载<JAVA_HOME>\\lib\\ext目录下类库</li>\n<li>是一种Java系统类库的扩展机制</li>\n<li>允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能</li>\n</ul>\n</li>\n<li><p>应用程序类加载器(Application ClassLoader)</p>\n<ul>\n<li>也称为系统类加载器。</li>\n<li>负责加载用户类路径（ClassPath)上所有的类库。如果没有定义自己的类加载器，则它就是程序默认的类加载器</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h2><ul>\n<li>除了顶层的启动类加载器，其余的类加载器都应有自己的父类加载器，通常使用组合关系来复用父加载器的代码</li>\n<li>如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载</li>\n<li>类随着他的类加载器一起具备了一种带有优先级的层次关系</li>\n<li>例如Object类，无论哪个类加载器去加载他，都会委派到启动类加载器进行执行，因此Object类在不同的类加载器环境下都能保证是同一个类</li>\n<li>如果没有双亲委派模型，用户自定义java.lang.Object类，系统就会出现多个不同的Object类，代码将一片混乱</li>\n<li>先检查请求加载的类型是否已经被加载过，若没有则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器，如果父类加载器加载失败，抛出异常了，才调用自己的findClass()方法尝试进行加载</li>\n</ul>\n<pre><code class=\"java\">protected Class&lt;?&gt; loadClass(String name， boolean resolve)\n        throws ClassNotFoundException\n    {\n            // 首先，检查是否已经被类加载器加载过\n            Class&lt;?&gt; c = findLoadedClass(name);\n            if (c == null) {\n                try {\n            // 存在父加载器，递归的交由父加载器\n                    if (parent != null) {\n                        c = parent.loadClass(name， false);\n                    } else {\n                // 直到最上面的Bootstrap类加载器\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // 如果父类加载器抛出ClassNotFoundException\n                    // f说明父类加载器无法完成加载请求\n                }\n\n                if (c == null) {\n                    // 在父类加载器无法加载时\n                    // 再调用自身的findClass方法来进行类加载\n                    c = findClass(name);\n                }\n            }\n            return c;\n    }</code></pre>\n<h2 id=\"打破双亲委派机制\"><a href=\"#打破双亲委派机制\" class=\"headerlink\" title=\"打破双亲委派机制\"></a>打破双亲委派机制</h2><h3 id=\"重写loadclass方法\"><a href=\"#重写loadclass方法\" class=\"headerlink\" title=\"重写loadclass方法\"></a>重写loadclass方法</h3><p>打破双亲委派机制，即在类加载的时候不是传递到父类加载器中加载，而是由自己加载。</p>\n<p>此时需要自定义一个类加载器，继承ClassLoader类，然后重写父类的findClass方法和loadClass方法。</p>\n<p>这里最主要的是重写loadclass方法，因为双亲委派机制的实现都是通过这个方法实现的，先找父加载器进行加载，如果父加载器无法加载再由自己来进行加载，源码里会直接找到根加载器，重写了这个方法以后就能自己定义加载的方式了</p>\n<h3 id=\"线程上下文类加载器\"><a href=\"#线程上下文类加载器\" class=\"headerlink\" title=\"线程上下文类加载器\"></a>线程上下文类加载器</h3><p>通过给当前线程设置上下文类加载器，就可以设置的上下文类加载器来实现对于接口实现类的加载。</p>\n<p>解决父类加载器去请求子类加载器完成类加载的行为</p>\n<h3 id=\"OSGi实现模块化热部署\"><a href=\"#OSGi实现模块化热部署\" class=\"headerlink\" title=\"OSGi实现模块化热部署\"></a>OSGi实现模块化热部署</h3><p>代码热替换、模块热部署等，机器不用重启，只要部署上就能用。</p>\n<p>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构</p>\n"},{"title":"Map集合","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"List集合相关，包括HashMap(JDK7、JDK8对比)、ConcurrentHashMap、Set等","abbrlink":"5b59a61f","date":"2020-12-27T16:00:00.000Z","_content":"\n# HashMap\n\n## 概览\n\n### 继承体系\n\n![image-20210601175023607](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601175023607.png)\n\n+ HashMap：不保证遍历顺序，非线程安全\n+ LinkedHashMap：HashMap的子类，保持了记录插入顺序，遍历会得到先插入的Node，也可以按照访问顺序排列，实现LRU算法\n+ TreeMap：默认按照key升序排列\n+ Hashtable：线程安全，效率低，所有方法加synchronized修饰，需要线程安全场景用ConcurrentHashMap即可\n\n### 数据结构\n\n数组+链表+红黑树\n\n![image-20210601212902002](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601212902002.png)\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n}\n\nNode<K,V>[] table; // 第一次put时初始化，length总是2的幂次倍\nint size; // HashMap中实际存在的键值对数量\nint modCount; // 记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。\nint threshold; // 所能容纳的最大Node(键值对)个数。threshold = length * Load factor,超过这个数目就重新resize(扩容)\nfinal float loadFactor; \ntransient Set<Map.Entry<K， V>> entrySet;\n\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 默认初始容量\nstatic final int MAXIMUM_CAPACITY = 1 << 30; // 最大数组容量\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认负载因子为0.75\nstatic final int TREEIFY_THRESHOLD = 8;  // 单个Node下的值的个数大于8时候，会将链表转换成为红黑树。\nstatic final int UNTREEIFY_THRESHOLD = 6; // 单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。\nstatic final int MIN_TREEIFY_CAPACITY = 64; // 树化的最小数组容量\n```\n\n### 特性\n\n+ 运行key为null（hash为null），存放在entry数组的第0个位置上\n\n+ 如果put操作中，只改变了value，则modCount不变\n\n+ 要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了（因为put和get都需要靠hashCode找到他的索引下标）。\n\n+ 当同一个索引位置的节点在增加后达到8个时，并且此时数组的长度大于等于 64，则则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。\n\n    当单个桶中元素数量小于6时，进行反树化\n\n+ HashMap查找添加元素的时间复杂度都为O(1)。数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数\n\n+ 为它的子类LinkedHashMap提供一些钩子方法\n\n## 基本流程\n\n### put()\n\n1. 计算key对应的hashCode\n2. 在entry数组较小时也能让高位也参与hash的运算：`hash = (h = key.hashCode()) ^ (h >>> 16)`\n3. 如果table不存在，则先初始化\n4. 如果索引`i = (n - 1) & hash`的位置为null，则直接新建节点\n5. 看table[i]首节点是否和key相同，相同则覆盖value，返回oldValue，判断是否相同的方法：hash相同，并且equals方法也相同\n6. 如果是红黑树节点，调用红黑树节点的插入方法\n7. 遍历下拉链表，如果找到了value就覆盖，找到链表尾部就新建Node，并且查看是否需要进行树化\n8. 插入成功后查看是否需要扩容、modCount++、提供钩子方法等\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n// 核心部分\nfinal V putVal(int hash, K key, V value) {\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null); // 尾插法\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n**注意事项**\n\n+ 当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。\n\n### get()\n\n+ 获取对应hash\n+ 看table是否存在，以及`tab[(n - 1) & hash]`是否存在\n+ 检查索引下的第一个节点的hash、equals是否相同\n+ 如果是红黑树节点，调用红黑树节点方法搜索\n+ 在下拉链表中搜索\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n        if (first.hash == hash && \n                ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        if ((e = first.next) != null) {\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            do {\n                if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n**注意事项**\n\n+ 两种情况会返回null：value不存在、put的value是null\n\n### resize()\n\n如果没有初始化，则首先执行初始化，否则执行正常的扩容操作。将容量变成原来的两倍\n\n遍历原Entry数组，把所有的Entry重新Hash到新数组\n\n```java\nfinal Node<K, V>[] resize() {\n    Node<K, V>[] newTab = (Node<K, V>[]) new Node[newCap];\n    for (int j = 0; j < oldCap; ++j) {\n        Node<K, V> e;\n        if ((e = oldTab[j]) != null)\n        {\n            oldTab[j] = null; // 将老表的节点设置为空, 以便垃圾收集器回收空间\n            if (e.next == null) // 只有一个节点,直接散列\n                newTab[e.hash & (newCap - 1)] = e;\n            else if (e instanceof TreeNode) // 调用红黑树的重新散列\n                ((TreeNode<K, V>) e).split(this, newTab, j, oldCap);\n            else {\n                Node<K, V> loHead = null, loTail = null;\n                Node<K, V> hiHead = null, hiTail = null;\n                Node<K, V> next;\n                do {\n                    next = e.next;\n                    if ((e.hash & oldCap) == 0) { // 分成两条链表，使用尾插法\n                        if (loTail == null)\n                            loHead = e;\n                        else\n                            loTail.next = e;\n                        loTail = e;\n                    } else {\n                        if (hiTail == null)\n                            hiHead = e;\n                        else\n                            hiTail.next = e;\n                        hiTail = e;\n                    }\n                } while ((e = next) != null);\n                if (loTail != null) {\n                    loTail.next = null;\n                    newTab[j] = loHead;\n                }\n                if (hiTail != null) {\n                    hiTail.next = null;\n                    newTab[j + oldCap] = hiHead;\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n例如00011,10011，如果oldCap=10000(16)\n00011 & 10000 = 0\n10011 & 10000 = 10000 != 0\n将原本在一个索引的节点分成两条链表，一个放在原位置处，一个放在[原位置 + oldCap]处\n\n\n\n### 初始化\n\n第一次put时才真正创建数组，分配空间\n\n**tableSizeFor（）**\n\n得到第一个大于等于cap的二的幂次方\n\n用于从构造函数中获取用户输入，并且保证了 table 数组的长度总是 2 的次幂\n\n无符号右移：就是右移之后，无论该数为正还是为负，右移之后左边都是补上0\n\n```java\npublic HashMap(int initialCapacity, float loadFactor) {\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\n}\nstatic final int tableSizeFor(int cap) {\n    int n = cap - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n```\n\n例如10001(17)\n首先cap-1:     10000\nn |= n >>> 1: n=(10000 | 01000) =11000\nn |= n >>> 2: n=(11000 | 00110) =11110\nn |= n >>> 4: n=(11110 | 00001) =11111\nn |= n >>> 8: n=(11111 | 00000) =11111\nn |= n >>> 16: n=(11111 | 00000) =11111\nreturn n+1:100000(32)\n...\n因为int为32位,所以为了保证结果,最后右移16位结束\n使得要求的数字1开始的后面全为1\n\n### 迭代器HashIterator\n\n+ 初始化记录modCount当前值，并让next指向第一个非空元素，而current=null\n+ nextNode方法，首先查看modCount值以决定是否fail-fast\n+ 然后检查当前元素是否为空，为空则抛出NoSuchElementException异常\n+ 最后让current等于当前元素，next继续指向下一个非空元素\n+ hasNext方法则简单判断next是否为空即可\n+ remove方法首先判断当前节点是否为空，为空则抛出IllegalStateException异常\n+ 随后查看modCount值决定是否fail-fast\n+ 删除该节点，且修改expectedModCount，即迭代器中的remove方法不会导致fail-fast\n\n```java\nabstract class HashIterator\n{\n    Node<K， V> next;        \n    Node<K， V> current;     \n    int expectedModCount;  // for fast-fail\n    int index;             \n\n    HashIterator()\n    {\n        expectedModCount = modCount;\n        Node<K， V>[] t = table;\n        current = next = null;\n        index = 0;\n        if (t != null && size > 0)\n        { \n            do\n            {\n            } while (index < t.length && (next = t[index++]) == null);\n            // 让next能指向第一个非空的元素\n        }\n    }\n\n    public final boolean hasNext()\n    {\n        return next != null;\n    }\n\n    final Node<K， V> nextNode()\n    {\n        Node<K， V>[] t;\n        Node<K， V> e = next;\n        if (modCount != expectedModCount) // fail-fast机制\n            throw new ConcurrentModificationException();\n        if (e == null)\n            throw new NoSuchElementException();\n        //找到下一个非空元素\n        if ((next = (current = e).next) == null && (t = table) != null)\n        {\n            do\n            {\n            } while (index < t.length && (next = t[index++]) == null);\n        }\n        return e;\n    }\n\n    public final void remove()\n    {\n        Node<K， V> p = current;\n        if (p == null)\n            throw new IllegalStateException();\n        if (modCount != expectedModCount) // 依然是fail-fast\n            throw new ConcurrentModificationException();\n        current = null;\n        K key = p.key;\n        removeNode(hash(key)， key， null， false， false);\n        expectedModCount = modCount; // 此处remove不会触发fail-fast\n    }\n}\n```\n\n## 扩展\n\n### JDK1.7和JDK1.8中HashMap有什么区别？\n\n+ 数据结构上：JDK1.8中当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。\n+ 插入数据方式上：\n    + JDK1.7使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环（导致死循环的主要原因是扩容后，节点的顺序会反掉）。\n    + JDK1.8使用尾插法插入元素（直接插入到链表尾部/红黑树），解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。\n\n### HashMap线程安全问题\n\n例如两个线程同时调用put操作，他们同时进入到了if语句后，先写入的Node会被后写入的Node覆盖掉\n\n```java\nif ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n```\n\n### 为什么不直接用红黑树？\n\n红黑树节点的大小是普通节点的两倍、红黑树需要进行左旋，右旋，变色这些操作来保持平衡，新增节点的效率低，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度。\n\n**为什么链表改为红黑树的阈值是 8?**\n\n理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循**泊松分布**，按照泊松分布的计算公式计算出桶中元素个数和概率的对照表，链表中元素个数为 8 时的概率非常小。\n\n**默认加载因子为什么是 0.75？**\n\n作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷，是对空间和时间效率的一个平衡选择。较高的值会降低空间开销，但提高查找成本。较低的值浪费空间。\n\n### HashTable与HashMap的区别\n\n+ 比HashMap多了个线程安全，直接在方法上锁，并发度很低，最多同时允许一个线程访问，效率比较低下\n\n+ 如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。也就是说对于Hashtable而言，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占。相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下。\n\n+ Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。Hashtable在我们put 空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理。\n\n+ 初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。\n\n+ HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。\n\n    ```java\n    int hash = key.hashCode();\n    int index = (hash & 0x7FFFFFFF) % tab.length;\n    ```\n\n+ 迭代器不同：HashMap 中的 Iterator 迭代器是 fail-fast 的，⽽ Hashtable 的 Enumerator是安全失败机制（fail-safe），这种机制会使你此次读到的数据不⼀定是最新的数据。\n\n### JDK1.7死循环\n\n+ 扩容操作中，把旧表中所有Node重新计算索引下标并散列到新表对应索引处(采用头插法)\n+ 把新表的引用赋值给table\n\n\n\n首先会导致链表反转：\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601204630630.png\" alt=\"image-20210601204630630\" style=\"zoom: 67%;\" />\n\n如果线程1、线程2同时操作，线程2执行到e = A、next = B时切换到线程1，线程1执行完resize导致链表反转成C->B->A->null。\n\n线程2继续执行以下代码，则产生了死循环：\n\n```\ne.next = newTable[i];\nnewTable[i] = e;\ne = next;\n```\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601205841811.png\" alt=\"image-20210601205841811\" style=\"zoom:67%;\" />\n\n```java\nvoid resize(int newCapacity)\n{\n    Entry[] oldTable = table;\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable);\n    table = newTable;\n}\n\nvoid transfer(Entry[] newTable)\n{\n    for (Entry<K, V> e : table)  // 遍历旧表中每个Entry\n    {\n        while (null != e) // 对不为空的(链表)进行操作\n        {\n            Entry<K, V> next = e.next;\n            e.hash = null == e.key ? 0 : hash(e.key);\n            int i = indexFor(e.hash, newCapacity); // 通过新的容量大小散列得到新的索引\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n```\n\n### **hashCode与equals**\n\n**equals**\n\n在未重写equals方法我们是继承了Object的equals方法，默认比较两个对象的内存地址\n\n+ 对于值对象，==比较的是两个对象的值\n+ 对于引用对象，==比较的是两个对象的地址\n\n```java\n// 默认情况是:\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n// 一般会重写equals方法以比较两个对象的内容\npublic boolean equals(Object obj){\n    if(this==obj) return true;\n    if(obj==null) return false;\n    if(getClass()!=obj.getClass()) return false;\n\n    Person person = (Person) obj;\n    return Objects.equals(name， person.name) &&Objects.equals(age， person.age);\n}\n所以基本数据类型用==判断相等，引用数据类型都用equals()进行判断(String也是引用类型)\n即==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同\n==指引用是否相同 equals()指的是值是否相同\n```\n\n**hashcode**\n\n```java\n因为HashSet或HashMap等集合中判断元素是否相等用到了hashcode是否相等，所以为避免我们认为相等但是逻辑判断却不相等的情况出现，自定义类重写equals必须重写hashcode方法\npublic native int hashCode();\n\n无论何时覆盖该方法，通常需要覆盖`hashCode`方法，以便维护`hashCode`方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。\n\n@Override\npublic int hashCode()\n{\n    return Objects.hash(username， age);\n}\n```\n\n+ 如果两个对象相等，则hashcode一定也是相同的\n\n+ 两个对象相等，对两个equals方法返回true\n\n+ 两个对象有相同的hashcode值，它们也不一定是相等的\n\n+ hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。\n\n**例子**\n\n使用Set存放学生信息，此时不小心对同一个人录入了两次（学号和姓名相同，但不是同一个对象）（我们逻辑上认为是同一个人，并且已重写了equals()方法，但是没有重写hashcode()方法）。这时Set中按逻辑应该只有一个学生，但是实际上却有两个\n\n这是因为我们没有重写父类（Object）的hashcode方法，Object的hashcode方法会根据两个对象的地址生成对相应的hashcode；s1和s2是分别new出来的，那么他们的地址肯定是不一样的，自然hashcode值也会不一样。\n\nSet区别对象的标准是，两个对象hashcode是不是一样，再判定两个对象是否equals；此时因为hashCode不一样，所以Set判定他们不是同一个对象，在Set中该学生信息就出现了两次\n\n# ConcurrentHashMap\n\n## 数据结构\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    volatile V val;\n    volatile Node<K,V> next;\n}\n\n// 在扩容时发挥作用，hash值为MOVED(-1)，存储nextTable的引用\nfinal class ForwardingNode<K,V> extends Node<K,V> {\n    final Node<K,V>[] nextTable;\n    ForwardingNode(Node<K,V>[] tab) {\n        super(MOVED, null, null, null);\n        this.nextTable = tab;\n    }\n}\n\nvolatile Node<K,V>[] table;\nvolatile Node<K,V>[] nextTable; // 默认为null，扩容时新生成的数组，其大小为原数组的两倍。\nvolatile int sizeCtl; // 控制初始化和扩容的\n\n\nstatic final int MOVED     = -1;  // 表示正在扩容\n```\n\n+ Node节点设置了volatile关键字修饰，致使它每次获取的都是**最新**设置的值\n+ 抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构。\n+ 在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。\n+ ConcurrentHashMap不允许key或value为null值\n\n\n\n- 在集合**新建而未初始化**时，sizeCtl用于记录初始容量大小\n- 在集合**初始化过程中**，sizeCtl值设置为 -1 表示集合正在初始化中，其他线程发现该值为 -1 时会让出CPU资源以便初始化操作尽快完成 。\n- 集合**初始化完成后**，sizeCtl 用于记录当前集合的负载容量值，也就是触发集合扩容的极限值 。\n- 集合**正在扩容时**，sizeCtl 用于记录当前扩容的并发线程数情况，该状态下 sizeCtl < 0 。\n\n## 常用方法\n\n### put\n\nConcurrentHashMap添加数据时，采取了CAS+synchronize结合策略。首先会判断该节点是否为null，如果为null，尝试使用CAS添加节点；如果添加失败，说明发生了并发冲突，再对节点进行上锁并插入数据。在并发较低的情景下无需加锁，可以显著提高性能。同时只会CAS尝试一次，也不会造成线程长时间等待浪费cpu时间的情况。\n\n```java\nfinal V putVal(K key, V value) {\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))\n                break;                   \n        }\n        else if ((fh = f.hash) == MOVED) \n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            synchronized (f) { // f是要插入的索引下标上的首节点\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) {\n                        // 尾查法往链表添加节点\n                    }\n                    else if (f instanceof TreeBin) {\n                        // 调用红黑树添加节点方法\n                    }\n                }\n            }\n            if (binCount != 0) {\n                if (binCount >= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n\nstatic final int spread(int h) {\n    return (h ^ (h >>> 16)) & HASH_BITS; // 0x7fffff\n}\n```\n\n+ 判断键值是否为`null`，为`null`抛出异常。\n+ 调用`spread()`方法计算key的hashCode()获得哈希地址\n+ 如果当前table为空，则初始化table，需要注意的是这里并没有加`synchronized`，也就是允许多个线程去**尝试**初始化table，但是在初始化函数里面使用了`CAS`保证只有一个线程去执行初始化过程。\n+ 使用`i = (n - 1) & hash`计算出待插入键值的下标，如果该下标上的bucket为`null`，则直接调用实现`CAS`原子性操作的`casTabAt()`方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。\n+ 如果该下标上的节点(头节点)的哈希地址为MOVED(-1)，说明当前f是ForwardingNode节点，意味有其它线程正在扩容，该线程执行`helpTransfer()`方法协助扩容。\n+ 如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时**使用synchroized锁住这个bucket**，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket\n+ 进入到bucket里面，首先判断这个bucket存储的是红黑树还是链表。\n+ 如果是**链表**，则遍历链表看看是否有hash和equals相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点**插入到链表尾部**。如果是**红黑树**，则将节点插入。到这里**解锁**。\n+ 最后判断该bucket上的链表长度是否大于**链表转红黑树的阈值(8)**，大于则将链表转成红黑树。\n+ 调用`addCount()`方法，将键值对数量+1，并检查是否需要扩容。\n\n### get\n\n```java\npublic V get(Object key) {\n    int h = spread(key.hashCode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n            (e = tabAt(tab, (n - 1) & h)) != null) {\n        if ((eh = e.hash) == h) { // 头节点寻找\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        else if (eh < 0) \n            // 红黑树中寻找\n        while ((e = e.next) != null) { \n            // 链表中寻找\n        }\n    }\n    return null;\n}\n```\n\n1. 调用`spread()`方法计算key的hashCode()获得哈希地址。\n2. 如果table不为空，对应key所在bucket不为空：`tabAt(tab, (n - 1) & h))`，则到bucket中查找。\n3. 如果头节点hash、equals相同，则返回头节点值\n4. 如果bucket的头节点的hash小于0，则代表这个bucket存储的是红黑树，则在红黑树中查找。\n5. 如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，找到则返回该键key的值，找不到则返回null。\n\n### remove\n\n1. 调用`spread()`方法计算出键key的哈希地址。\n2. 计算出键key所在的数组下标，如果table为空或者bucket为空，则返回`null`。\n3. 判断当前table是否正在扩容，如果在扩容则调用helpTransfer方法协助扩容。\n4. 如果table和bucket都不为空，table也不处于在扩容状态，则**锁住当前bucket**，对bucket进行操作。\n5. 根据bucket的头结点判断bucket是链表还是红黑树。\n6. 在链表或者红黑树中移除哈希地址、键key相同的节点。\n7. 调用`addCount`方法，将当前table存储的键值对数量-1。\n\n### 初始化\n\n```java\npublic ConcurrentHashMap(int initialCapacity) {\n    int cap = tableSizeFor(initialCapacity);\n    this.sizeCtl = cap;\n}\n\n// 第一次put时才调用\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        if ((sc = sizeCtl) < 0)\n            Thread.yield(); \n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            if ((tab = table) == null || tab.length == 0) {\n                table = (Node<K,V>[])new Node<?,?>[n];\n                sizeCtl = n - (n >>> 2);\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n\n+ table的初始化只能由一个线程完成，但是每个线程都可以争抢去初始化table。\n+ 首先，判断table是否为null，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。\n+ 如果table为null，进入到while循环，如果`sizeCtl`小于0(其他线程正在对table初始化)，那么该线程调用`Thread.yield()`挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为`null`，则继续while循环。\n+ 如果table为null且`sizeCtl`不小于0，则调用实现`CAS`原子性操作的`compareAndSwap()`方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的。并设置sizeCtl的值为数组长度的3/4（`threshold`的作用），当ConcurrentHashMap储存的键值对数量大于这个阈值，就会发生扩容。\n\n### 扩容\n\n**触发扩容**\n\n1. 添加新元素后，元素个数达到扩容阈值触发扩容。\n2. 调用 putAll 方法，发现容量不足以容纳所有元素时候触发扩容。\n\n3. 某个槽内的链表长度达到 8，但是数组长度小于 64 时候触发扩容。\n\n**扩容操作**\n\n- 构建一个nextTable，大小为table的两倍。这个过程只能只有单个线程进行nextTable的初始化（通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable）\n- 将原来table里面的内容复制到nextTable中，这个步骤是允许**多线程**操作的，所以性能得到提升，减少了扩容的时间消耗。\n\n**扩容时其他操作**\n\n扩容状态下其他线程对集合进行插入、修改、删除等操作时遇到 ForwardingNode 节点会调用helpTransfer方法帮助扩容\n\n## 扩展\n\n### JDK1.7的ConcurrentHashMap\n\n+ 基本思想是将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\n+ Segment 是一个ReentrantLock，每一个Segment元素存储的是HashEntry数组+链表，每一个Segment其实就相当于一个HashMap\n+ put操作需要加锁，get操作不用加锁（通过使用volatile和巧妙的操作保证同步）\n+ ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部\n\n![20216212](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216212.png)\n\n```java\nfinal Segment<K,V>[] segments;\n\nstatic final class Segment<K,V> extends ReentrantLock {\n\tvolatile HashEntry<K,V>[] table;\n\tint count;\n\tint modCount;\n\tint threshold;\n\tfloat loadFactor;\n}\nstatic final class HashEntry<K,V> { \n    final K key; \n    final int hash; \n    volatile V value; \n    final HashEntry<K,V> next; \n}\n```\n\n### ConcurrentHashMap不允许key或value为null值\n\nput操作中有相应的判断：\n\n```java\nif (key == null || value == null) throw new NullPointerException();\n```\n\n但这样设计的原因是避免二义性：假定ConcurrentHashMap也可以存放value为null的值。那调用map.get(key)时如果返回了null，有两重含义:\n\n**1.这个key从来没有在map中映射过。**\n\n**2.这个key的value在设置的时候，就是null。**\n\n对于HashMap来说，它的正确使用场景是在单线程下使用。所以在单线程中，当我们得到的value是null的时候，可以用hashMap.containsKey(key)方法来区分上面说的两重含义。\n\n而ConcurrentHashMap的使用场景为多线程。假设concurrentHashMap允许存放值为null的value。这时有A、B两个线程。线程A调用concurrentHashMap.get(key)方法，返回为null，我们还是不知道这个null是没有映射的null还是存的值就是null。\n\n假设此时返回null的真实情况是因为这个key没有在map里面映射过。用concurrentHashMap.containsKey(key)来验证假设是否成立，期望的结果是返回false。\n\n但是在我们调用concurrentHashMap.get(key)方法之后，containsKey方法之前，有一个线程B执行了concurrentHashMap.put(key,null)的操作。那么我们调用containsKey方法返回的就是true了。这就与我们的假设的真实情况不符合了。\t\n\n# Set\n\n## HashSet\n\n+ 不保证集合顺序\n+ 允许null值\n+ HashSet 不允许重复的值\n\n```java\n//底层使用HashMap来保存HashSet中所有元素\nprivate transient HashMap<E，Object> map;\n\n//定义一个虚拟的Object对象作为HashMap的value\nprivate static final Object PRESENT = new Object();\n\npublic boolean add(E e) {\n\n    //因为put会返回原Value，如果放入相同的，则返回就不为null\n\n    //则该方法返回false，代表添加不成功，代表已经有了元素\n\t//HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT\n    return map.put(e， PRESENT)==null;\n\n}\n```\n\n## LinkedHashSet\n\n+ LinkedHashSet 内部是通过 LinkedHashMap 来实现的。\n+ 继承HashSet\n+ LinkedHashSet的构造器调用父类HashSet的其中一个构造器，将map初始化为LinkedHashMap，所以再调用方法时，就会有LinkedHashMap的调用效果\n+ 用双向链表维持元素的插入顺序\n+ 重新插入时不会影响顺序","source":"_posts/Java语言/Java集合/3.Map集合.md","raw":"---\ntitle: Map集合\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: List集合相关，包括HashMap(JDK7、JDK8对比)、ConcurrentHashMap、Set等\ncategories: Java集合\ntags:\n  - HashMap\n  - ConcurrentHashMap\n  - Set\nabbrlink: 5b59a61f\ndate: 2020-12-28 00:00:00\n---\n\n# HashMap\n\n## 概览\n\n### 继承体系\n\n![image-20210601175023607](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601175023607.png)\n\n+ HashMap：不保证遍历顺序，非线程安全\n+ LinkedHashMap：HashMap的子类，保持了记录插入顺序，遍历会得到先插入的Node，也可以按照访问顺序排列，实现LRU算法\n+ TreeMap：默认按照key升序排列\n+ Hashtable：线程安全，效率低，所有方法加synchronized修饰，需要线程安全场景用ConcurrentHashMap即可\n\n### 数据结构\n\n数组+链表+红黑树\n\n![image-20210601212902002](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601212902002.png)\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n}\n\nNode<K,V>[] table; // 第一次put时初始化，length总是2的幂次倍\nint size; // HashMap中实际存在的键值对数量\nint modCount; // 记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。\nint threshold; // 所能容纳的最大Node(键值对)个数。threshold = length * Load factor,超过这个数目就重新resize(扩容)\nfinal float loadFactor; \ntransient Set<Map.Entry<K， V>> entrySet;\n\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 默认初始容量\nstatic final int MAXIMUM_CAPACITY = 1 << 30; // 最大数组容量\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认负载因子为0.75\nstatic final int TREEIFY_THRESHOLD = 8;  // 单个Node下的值的个数大于8时候，会将链表转换成为红黑树。\nstatic final int UNTREEIFY_THRESHOLD = 6; // 单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。\nstatic final int MIN_TREEIFY_CAPACITY = 64; // 树化的最小数组容量\n```\n\n### 特性\n\n+ 运行key为null（hash为null），存放在entry数组的第0个位置上\n\n+ 如果put操作中，只改变了value，则modCount不变\n\n+ 要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了（因为put和get都需要靠hashCode找到他的索引下标）。\n\n+ 当同一个索引位置的节点在增加后达到8个时，并且此时数组的长度大于等于 64，则则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。\n\n    当单个桶中元素数量小于6时，进行反树化\n\n+ HashMap查找添加元素的时间复杂度都为O(1)。数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数\n\n+ 为它的子类LinkedHashMap提供一些钩子方法\n\n## 基本流程\n\n### put()\n\n1. 计算key对应的hashCode\n2. 在entry数组较小时也能让高位也参与hash的运算：`hash = (h = key.hashCode()) ^ (h >>> 16)`\n3. 如果table不存在，则先初始化\n4. 如果索引`i = (n - 1) & hash`的位置为null，则直接新建节点\n5. 看table[i]首节点是否和key相同，相同则覆盖value，返回oldValue，判断是否相同的方法：hash相同，并且equals方法也相同\n6. 如果是红黑树节点，调用红黑树节点的插入方法\n7. 遍历下拉链表，如果找到了value就覆盖，找到链表尾部就新建Node，并且查看是否需要进行树化\n8. 插入成功后查看是否需要扩容、modCount++、提供钩子方法等\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n// 核心部分\nfinal V putVal(int hash, K key, V value) {\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null); // 尾插法\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n**注意事项**\n\n+ 当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。\n\n### get()\n\n+ 获取对应hash\n+ 看table是否存在，以及`tab[(n - 1) & hash]`是否存在\n+ 检查索引下的第一个节点的hash、equals是否相同\n+ 如果是红黑树节点，调用红黑树节点方法搜索\n+ 在下拉链表中搜索\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n        if (first.hash == hash && \n                ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        if ((e = first.next) != null) {\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            do {\n                if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n**注意事项**\n\n+ 两种情况会返回null：value不存在、put的value是null\n\n### resize()\n\n如果没有初始化，则首先执行初始化，否则执行正常的扩容操作。将容量变成原来的两倍\n\n遍历原Entry数组，把所有的Entry重新Hash到新数组\n\n```java\nfinal Node<K, V>[] resize() {\n    Node<K, V>[] newTab = (Node<K, V>[]) new Node[newCap];\n    for (int j = 0; j < oldCap; ++j) {\n        Node<K, V> e;\n        if ((e = oldTab[j]) != null)\n        {\n            oldTab[j] = null; // 将老表的节点设置为空, 以便垃圾收集器回收空间\n            if (e.next == null) // 只有一个节点,直接散列\n                newTab[e.hash & (newCap - 1)] = e;\n            else if (e instanceof TreeNode) // 调用红黑树的重新散列\n                ((TreeNode<K, V>) e).split(this, newTab, j, oldCap);\n            else {\n                Node<K, V> loHead = null, loTail = null;\n                Node<K, V> hiHead = null, hiTail = null;\n                Node<K, V> next;\n                do {\n                    next = e.next;\n                    if ((e.hash & oldCap) == 0) { // 分成两条链表，使用尾插法\n                        if (loTail == null)\n                            loHead = e;\n                        else\n                            loTail.next = e;\n                        loTail = e;\n                    } else {\n                        if (hiTail == null)\n                            hiHead = e;\n                        else\n                            hiTail.next = e;\n                        hiTail = e;\n                    }\n                } while ((e = next) != null);\n                if (loTail != null) {\n                    loTail.next = null;\n                    newTab[j] = loHead;\n                }\n                if (hiTail != null) {\n                    hiTail.next = null;\n                    newTab[j + oldCap] = hiHead;\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n例如00011,10011，如果oldCap=10000(16)\n00011 & 10000 = 0\n10011 & 10000 = 10000 != 0\n将原本在一个索引的节点分成两条链表，一个放在原位置处，一个放在[原位置 + oldCap]处\n\n\n\n### 初始化\n\n第一次put时才真正创建数组，分配空间\n\n**tableSizeFor（）**\n\n得到第一个大于等于cap的二的幂次方\n\n用于从构造函数中获取用户输入，并且保证了 table 数组的长度总是 2 的次幂\n\n无符号右移：就是右移之后，无论该数为正还是为负，右移之后左边都是补上0\n\n```java\npublic HashMap(int initialCapacity, float loadFactor) {\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\n}\nstatic final int tableSizeFor(int cap) {\n    int n = cap - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n```\n\n例如10001(17)\n首先cap-1:     10000\nn |= n >>> 1: n=(10000 | 01000) =11000\nn |= n >>> 2: n=(11000 | 00110) =11110\nn |= n >>> 4: n=(11110 | 00001) =11111\nn |= n >>> 8: n=(11111 | 00000) =11111\nn |= n >>> 16: n=(11111 | 00000) =11111\nreturn n+1:100000(32)\n...\n因为int为32位,所以为了保证结果,最后右移16位结束\n使得要求的数字1开始的后面全为1\n\n### 迭代器HashIterator\n\n+ 初始化记录modCount当前值，并让next指向第一个非空元素，而current=null\n+ nextNode方法，首先查看modCount值以决定是否fail-fast\n+ 然后检查当前元素是否为空，为空则抛出NoSuchElementException异常\n+ 最后让current等于当前元素，next继续指向下一个非空元素\n+ hasNext方法则简单判断next是否为空即可\n+ remove方法首先判断当前节点是否为空，为空则抛出IllegalStateException异常\n+ 随后查看modCount值决定是否fail-fast\n+ 删除该节点，且修改expectedModCount，即迭代器中的remove方法不会导致fail-fast\n\n```java\nabstract class HashIterator\n{\n    Node<K， V> next;        \n    Node<K， V> current;     \n    int expectedModCount;  // for fast-fail\n    int index;             \n\n    HashIterator()\n    {\n        expectedModCount = modCount;\n        Node<K， V>[] t = table;\n        current = next = null;\n        index = 0;\n        if (t != null && size > 0)\n        { \n            do\n            {\n            } while (index < t.length && (next = t[index++]) == null);\n            // 让next能指向第一个非空的元素\n        }\n    }\n\n    public final boolean hasNext()\n    {\n        return next != null;\n    }\n\n    final Node<K， V> nextNode()\n    {\n        Node<K， V>[] t;\n        Node<K， V> e = next;\n        if (modCount != expectedModCount) // fail-fast机制\n            throw new ConcurrentModificationException();\n        if (e == null)\n            throw new NoSuchElementException();\n        //找到下一个非空元素\n        if ((next = (current = e).next) == null && (t = table) != null)\n        {\n            do\n            {\n            } while (index < t.length && (next = t[index++]) == null);\n        }\n        return e;\n    }\n\n    public final void remove()\n    {\n        Node<K， V> p = current;\n        if (p == null)\n            throw new IllegalStateException();\n        if (modCount != expectedModCount) // 依然是fail-fast\n            throw new ConcurrentModificationException();\n        current = null;\n        K key = p.key;\n        removeNode(hash(key)， key， null， false， false);\n        expectedModCount = modCount; // 此处remove不会触发fail-fast\n    }\n}\n```\n\n## 扩展\n\n### JDK1.7和JDK1.8中HashMap有什么区别？\n\n+ 数据结构上：JDK1.8中当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。\n+ 插入数据方式上：\n    + JDK1.7使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环（导致死循环的主要原因是扩容后，节点的顺序会反掉）。\n    + JDK1.8使用尾插法插入元素（直接插入到链表尾部/红黑树），解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。\n\n### HashMap线程安全问题\n\n例如两个线程同时调用put操作，他们同时进入到了if语句后，先写入的Node会被后写入的Node覆盖掉\n\n```java\nif ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n```\n\n### 为什么不直接用红黑树？\n\n红黑树节点的大小是普通节点的两倍、红黑树需要进行左旋，右旋，变色这些操作来保持平衡，新增节点的效率低，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度。\n\n**为什么链表改为红黑树的阈值是 8?**\n\n理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循**泊松分布**，按照泊松分布的计算公式计算出桶中元素个数和概率的对照表，链表中元素个数为 8 时的概率非常小。\n\n**默认加载因子为什么是 0.75？**\n\n作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷，是对空间和时间效率的一个平衡选择。较高的值会降低空间开销，但提高查找成本。较低的值浪费空间。\n\n### HashTable与HashMap的区别\n\n+ 比HashMap多了个线程安全，直接在方法上锁，并发度很低，最多同时允许一个线程访问，效率比较低下\n\n+ 如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。也就是说对于Hashtable而言，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占。相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下。\n\n+ Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。Hashtable在我们put 空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理。\n\n+ 初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。\n\n+ HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。\n\n    ```java\n    int hash = key.hashCode();\n    int index = (hash & 0x7FFFFFFF) % tab.length;\n    ```\n\n+ 迭代器不同：HashMap 中的 Iterator 迭代器是 fail-fast 的，⽽ Hashtable 的 Enumerator是安全失败机制（fail-safe），这种机制会使你此次读到的数据不⼀定是最新的数据。\n\n### JDK1.7死循环\n\n+ 扩容操作中，把旧表中所有Node重新计算索引下标并散列到新表对应索引处(采用头插法)\n+ 把新表的引用赋值给table\n\n\n\n首先会导致链表反转：\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601204630630.png\" alt=\"image-20210601204630630\" style=\"zoom: 67%;\" />\n\n如果线程1、线程2同时操作，线程2执行到e = A、next = B时切换到线程1，线程1执行完resize导致链表反转成C->B->A->null。\n\n线程2继续执行以下代码，则产生了死循环：\n\n```\ne.next = newTable[i];\nnewTable[i] = e;\ne = next;\n```\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601205841811.png\" alt=\"image-20210601205841811\" style=\"zoom:67%;\" />\n\n```java\nvoid resize(int newCapacity)\n{\n    Entry[] oldTable = table;\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable);\n    table = newTable;\n}\n\nvoid transfer(Entry[] newTable)\n{\n    for (Entry<K, V> e : table)  // 遍历旧表中每个Entry\n    {\n        while (null != e) // 对不为空的(链表)进行操作\n        {\n            Entry<K, V> next = e.next;\n            e.hash = null == e.key ? 0 : hash(e.key);\n            int i = indexFor(e.hash, newCapacity); // 通过新的容量大小散列得到新的索引\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n```\n\n### **hashCode与equals**\n\n**equals**\n\n在未重写equals方法我们是继承了Object的equals方法，默认比较两个对象的内存地址\n\n+ 对于值对象，==比较的是两个对象的值\n+ 对于引用对象，==比较的是两个对象的地址\n\n```java\n// 默认情况是:\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n// 一般会重写equals方法以比较两个对象的内容\npublic boolean equals(Object obj){\n    if(this==obj) return true;\n    if(obj==null) return false;\n    if(getClass()!=obj.getClass()) return false;\n\n    Person person = (Person) obj;\n    return Objects.equals(name， person.name) &&Objects.equals(age， person.age);\n}\n所以基本数据类型用==判断相等，引用数据类型都用equals()进行判断(String也是引用类型)\n即==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同\n==指引用是否相同 equals()指的是值是否相同\n```\n\n**hashcode**\n\n```java\n因为HashSet或HashMap等集合中判断元素是否相等用到了hashcode是否相等，所以为避免我们认为相等但是逻辑判断却不相等的情况出现，自定义类重写equals必须重写hashcode方法\npublic native int hashCode();\n\n无论何时覆盖该方法，通常需要覆盖`hashCode`方法，以便维护`hashCode`方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。\n\n@Override\npublic int hashCode()\n{\n    return Objects.hash(username， age);\n}\n```\n\n+ 如果两个对象相等，则hashcode一定也是相同的\n\n+ 两个对象相等，对两个equals方法返回true\n\n+ 两个对象有相同的hashcode值，它们也不一定是相等的\n\n+ hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。\n\n**例子**\n\n使用Set存放学生信息，此时不小心对同一个人录入了两次（学号和姓名相同，但不是同一个对象）（我们逻辑上认为是同一个人，并且已重写了equals()方法，但是没有重写hashcode()方法）。这时Set中按逻辑应该只有一个学生，但是实际上却有两个\n\n这是因为我们没有重写父类（Object）的hashcode方法，Object的hashcode方法会根据两个对象的地址生成对相应的hashcode；s1和s2是分别new出来的，那么他们的地址肯定是不一样的，自然hashcode值也会不一样。\n\nSet区别对象的标准是，两个对象hashcode是不是一样，再判定两个对象是否equals；此时因为hashCode不一样，所以Set判定他们不是同一个对象，在Set中该学生信息就出现了两次\n\n# ConcurrentHashMap\n\n## 数据结构\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    volatile V val;\n    volatile Node<K,V> next;\n}\n\n// 在扩容时发挥作用，hash值为MOVED(-1)，存储nextTable的引用\nfinal class ForwardingNode<K,V> extends Node<K,V> {\n    final Node<K,V>[] nextTable;\n    ForwardingNode(Node<K,V>[] tab) {\n        super(MOVED, null, null, null);\n        this.nextTable = tab;\n    }\n}\n\nvolatile Node<K,V>[] table;\nvolatile Node<K,V>[] nextTable; // 默认为null，扩容时新生成的数组，其大小为原数组的两倍。\nvolatile int sizeCtl; // 控制初始化和扩容的\n\n\nstatic final int MOVED     = -1;  // 表示正在扩容\n```\n\n+ Node节点设置了volatile关键字修饰，致使它每次获取的都是**最新**设置的值\n+ 抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构。\n+ 在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。\n+ ConcurrentHashMap不允许key或value为null值\n\n\n\n- 在集合**新建而未初始化**时，sizeCtl用于记录初始容量大小\n- 在集合**初始化过程中**，sizeCtl值设置为 -1 表示集合正在初始化中，其他线程发现该值为 -1 时会让出CPU资源以便初始化操作尽快完成 。\n- 集合**初始化完成后**，sizeCtl 用于记录当前集合的负载容量值，也就是触发集合扩容的极限值 。\n- 集合**正在扩容时**，sizeCtl 用于记录当前扩容的并发线程数情况，该状态下 sizeCtl < 0 。\n\n## 常用方法\n\n### put\n\nConcurrentHashMap添加数据时，采取了CAS+synchronize结合策略。首先会判断该节点是否为null，如果为null，尝试使用CAS添加节点；如果添加失败，说明发生了并发冲突，再对节点进行上锁并插入数据。在并发较低的情景下无需加锁，可以显著提高性能。同时只会CAS尝试一次，也不会造成线程长时间等待浪费cpu时间的情况。\n\n```java\nfinal V putVal(K key, V value) {\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))\n                break;                   \n        }\n        else if ((fh = f.hash) == MOVED) \n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            synchronized (f) { // f是要插入的索引下标上的首节点\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) {\n                        // 尾查法往链表添加节点\n                    }\n                    else if (f instanceof TreeBin) {\n                        // 调用红黑树添加节点方法\n                    }\n                }\n            }\n            if (binCount != 0) {\n                if (binCount >= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n\nstatic final int spread(int h) {\n    return (h ^ (h >>> 16)) & HASH_BITS; // 0x7fffff\n}\n```\n\n+ 判断键值是否为`null`，为`null`抛出异常。\n+ 调用`spread()`方法计算key的hashCode()获得哈希地址\n+ 如果当前table为空，则初始化table，需要注意的是这里并没有加`synchronized`，也就是允许多个线程去**尝试**初始化table，但是在初始化函数里面使用了`CAS`保证只有一个线程去执行初始化过程。\n+ 使用`i = (n - 1) & hash`计算出待插入键值的下标，如果该下标上的bucket为`null`，则直接调用实现`CAS`原子性操作的`casTabAt()`方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。\n+ 如果该下标上的节点(头节点)的哈希地址为MOVED(-1)，说明当前f是ForwardingNode节点，意味有其它线程正在扩容，该线程执行`helpTransfer()`方法协助扩容。\n+ 如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时**使用synchroized锁住这个bucket**，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket\n+ 进入到bucket里面，首先判断这个bucket存储的是红黑树还是链表。\n+ 如果是**链表**，则遍历链表看看是否有hash和equals相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点**插入到链表尾部**。如果是**红黑树**，则将节点插入。到这里**解锁**。\n+ 最后判断该bucket上的链表长度是否大于**链表转红黑树的阈值(8)**，大于则将链表转成红黑树。\n+ 调用`addCount()`方法，将键值对数量+1，并检查是否需要扩容。\n\n### get\n\n```java\npublic V get(Object key) {\n    int h = spread(key.hashCode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n            (e = tabAt(tab, (n - 1) & h)) != null) {\n        if ((eh = e.hash) == h) { // 头节点寻找\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        else if (eh < 0) \n            // 红黑树中寻找\n        while ((e = e.next) != null) { \n            // 链表中寻找\n        }\n    }\n    return null;\n}\n```\n\n1. 调用`spread()`方法计算key的hashCode()获得哈希地址。\n2. 如果table不为空，对应key所在bucket不为空：`tabAt(tab, (n - 1) & h))`，则到bucket中查找。\n3. 如果头节点hash、equals相同，则返回头节点值\n4. 如果bucket的头节点的hash小于0，则代表这个bucket存储的是红黑树，则在红黑树中查找。\n5. 如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，找到则返回该键key的值，找不到则返回null。\n\n### remove\n\n1. 调用`spread()`方法计算出键key的哈希地址。\n2. 计算出键key所在的数组下标，如果table为空或者bucket为空，则返回`null`。\n3. 判断当前table是否正在扩容，如果在扩容则调用helpTransfer方法协助扩容。\n4. 如果table和bucket都不为空，table也不处于在扩容状态，则**锁住当前bucket**，对bucket进行操作。\n5. 根据bucket的头结点判断bucket是链表还是红黑树。\n6. 在链表或者红黑树中移除哈希地址、键key相同的节点。\n7. 调用`addCount`方法，将当前table存储的键值对数量-1。\n\n### 初始化\n\n```java\npublic ConcurrentHashMap(int initialCapacity) {\n    int cap = tableSizeFor(initialCapacity);\n    this.sizeCtl = cap;\n}\n\n// 第一次put时才调用\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        if ((sc = sizeCtl) < 0)\n            Thread.yield(); \n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            if ((tab = table) == null || tab.length == 0) {\n                table = (Node<K,V>[])new Node<?,?>[n];\n                sizeCtl = n - (n >>> 2);\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n\n+ table的初始化只能由一个线程完成，但是每个线程都可以争抢去初始化table。\n+ 首先，判断table是否为null，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。\n+ 如果table为null，进入到while循环，如果`sizeCtl`小于0(其他线程正在对table初始化)，那么该线程调用`Thread.yield()`挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为`null`，则继续while循环。\n+ 如果table为null且`sizeCtl`不小于0，则调用实现`CAS`原子性操作的`compareAndSwap()`方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的。并设置sizeCtl的值为数组长度的3/4（`threshold`的作用），当ConcurrentHashMap储存的键值对数量大于这个阈值，就会发生扩容。\n\n### 扩容\n\n**触发扩容**\n\n1. 添加新元素后，元素个数达到扩容阈值触发扩容。\n2. 调用 putAll 方法，发现容量不足以容纳所有元素时候触发扩容。\n\n3. 某个槽内的链表长度达到 8，但是数组长度小于 64 时候触发扩容。\n\n**扩容操作**\n\n- 构建一个nextTable，大小为table的两倍。这个过程只能只有单个线程进行nextTable的初始化（通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable）\n- 将原来table里面的内容复制到nextTable中，这个步骤是允许**多线程**操作的，所以性能得到提升，减少了扩容的时间消耗。\n\n**扩容时其他操作**\n\n扩容状态下其他线程对集合进行插入、修改、删除等操作时遇到 ForwardingNode 节点会调用helpTransfer方法帮助扩容\n\n## 扩展\n\n### JDK1.7的ConcurrentHashMap\n\n+ 基本思想是将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\n+ Segment 是一个ReentrantLock，每一个Segment元素存储的是HashEntry数组+链表，每一个Segment其实就相当于一个HashMap\n+ put操作需要加锁，get操作不用加锁（通过使用volatile和巧妙的操作保证同步）\n+ ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部\n\n![20216212](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216212.png)\n\n```java\nfinal Segment<K,V>[] segments;\n\nstatic final class Segment<K,V> extends ReentrantLock {\n\tvolatile HashEntry<K,V>[] table;\n\tint count;\n\tint modCount;\n\tint threshold;\n\tfloat loadFactor;\n}\nstatic final class HashEntry<K,V> { \n    final K key; \n    final int hash; \n    volatile V value; \n    final HashEntry<K,V> next; \n}\n```\n\n### ConcurrentHashMap不允许key或value为null值\n\nput操作中有相应的判断：\n\n```java\nif (key == null || value == null) throw new NullPointerException();\n```\n\n但这样设计的原因是避免二义性：假定ConcurrentHashMap也可以存放value为null的值。那调用map.get(key)时如果返回了null，有两重含义:\n\n**1.这个key从来没有在map中映射过。**\n\n**2.这个key的value在设置的时候，就是null。**\n\n对于HashMap来说，它的正确使用场景是在单线程下使用。所以在单线程中，当我们得到的value是null的时候，可以用hashMap.containsKey(key)方法来区分上面说的两重含义。\n\n而ConcurrentHashMap的使用场景为多线程。假设concurrentHashMap允许存放值为null的value。这时有A、B两个线程。线程A调用concurrentHashMap.get(key)方法，返回为null，我们还是不知道这个null是没有映射的null还是存的值就是null。\n\n假设此时返回null的真实情况是因为这个key没有在map里面映射过。用concurrentHashMap.containsKey(key)来验证假设是否成立，期望的结果是返回false。\n\n但是在我们调用concurrentHashMap.get(key)方法之后，containsKey方法之前，有一个线程B执行了concurrentHashMap.put(key,null)的操作。那么我们调用containsKey方法返回的就是true了。这就与我们的假设的真实情况不符合了。\t\n\n# Set\n\n## HashSet\n\n+ 不保证集合顺序\n+ 允许null值\n+ HashSet 不允许重复的值\n\n```java\n//底层使用HashMap来保存HashSet中所有元素\nprivate transient HashMap<E，Object> map;\n\n//定义一个虚拟的Object对象作为HashMap的value\nprivate static final Object PRESENT = new Object();\n\npublic boolean add(E e) {\n\n    //因为put会返回原Value，如果放入相同的，则返回就不为null\n\n    //则该方法返回false，代表添加不成功，代表已经有了元素\n\t//HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT\n    return map.put(e， PRESENT)==null;\n\n}\n```\n\n## LinkedHashSet\n\n+ LinkedHashSet 内部是通过 LinkedHashMap 来实现的。\n+ 继承HashSet\n+ LinkedHashSet的构造器调用父类HashSet的其中一个构造器，将map初始化为LinkedHashMap，所以再调用方法时，就会有LinkedHashMap的调用效果\n+ 用双向链表维持元素的插入顺序\n+ 重新插入时不会影响顺序","slug":"Java语言/Java集合/3.Map集合","published":1,"updated":"2021-06-08T03:35:00.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq50z000lz0tpdarqenfc","content":"<h1 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h1><h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><h3 id=\"继承体系\"><a href=\"#继承体系\" class=\"headerlink\" title=\"继承体系\"></a>继承体系</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601175023607.png\" alt=\"image-20210601175023607\"></p>\n<ul>\n<li>HashMap：不保证遍历顺序，非线程安全</li>\n<li>LinkedHashMap：HashMap的子类，保持了记录插入顺序，遍历会得到先插入的Node，也可以按照访问顺序排列，实现LRU算法</li>\n<li>TreeMap：默认按照key升序排列</li>\n<li>Hashtable：线程安全，效率低，所有方法加synchronized修饰，需要线程安全场景用ConcurrentHashMap即可</li>\n</ul>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>数组+链表+红黑树</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601212902002.png\" alt=\"image-20210601212902002\"></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> K key<span class=\"token punctuation\">;</span>\n    V value<span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nNode<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> table<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 第一次put时初始化，length总是2的幂次倍</span>\n<span class=\"token keyword\">int</span> size<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// HashMap中实际存在的键值对数量</span>\n<span class=\"token keyword\">int</span> modCount<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。</span>\n<span class=\"token keyword\">int</span> threshold<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 所能容纳的最大Node(键值对)个数。threshold = length * Load factor,超过这个数目就重新resize(扩容)</span>\n<span class=\"token keyword\">final</span> <span class=\"token keyword\">float</span> loadFactor<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">transient</span> Set<span class=\"token operator\">&lt;</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token operator\">&lt;</span>K， V<span class=\"token operator\">>></span> entrySet<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> DEFAULT_INITIAL_CAPACITY <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 默认初始容量</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MAXIMUM_CAPACITY <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 最大数组容量</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">float</span> DEFAULT_LOAD_FACTOR <span class=\"token operator\">=</span> <span class=\"token number\">0.75f</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 默认负载因子为0.75</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> TREEIFY_THRESHOLD <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 单个Node下的值的个数大于8时候，会将链表转换成为红黑树。</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> UNTREEIFY_THRESHOLD <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MIN_TREEIFY_CAPACITY <span class=\"token operator\">=</span> <span class=\"token number\">64</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 树化的最小数组容量</span></code></pre>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ul>\n<li><p>运行key为null（hash为null），存放在entry数组的第0个位置上</p>\n</li>\n<li><p>如果put操作中，只改变了value，则modCount不变</p>\n</li>\n<li><p>要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了（因为put和get都需要靠hashCode找到他的索引下标）。</p>\n</li>\n<li><p>当同一个索引位置的节点在增加后达到8个时，并且此时数组的长度大于等于 64，则则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。</p>\n<p>  当单个桶中元素数量小于6时，进行反树化</p>\n</li>\n<li><p>HashMap查找添加元素的时间复杂度都为O(1)。数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数</p>\n</li>\n<li><p>为它的子类LinkedHashMap提供一些钩子方法</p>\n</li>\n</ul>\n<h2 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h2><h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h3><ol>\n<li>计算key对应的hashCode</li>\n<li>在entry数组较小时也能让高位也参与hash的运算：<code>hash = (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li>\n<li>如果table不存在，则先初始化</li>\n<li>如果索引<code>i = (n - 1) &amp; hash</code>的位置为null，则直接新建节点</li>\n<li>看table[i]首节点是否和key相同，相同则覆盖value，返回oldValue，判断是否相同的方法：hash相同，并且equals方法也相同</li>\n<li>如果是红黑树节点，调用红黑树节点的插入方法</li>\n<li>遍历下拉链表，如果找到了value就覆盖，找到链表尾部就新建Node，并且查看是否需要进行树化</li>\n<li>插入成功后查看是否需要扩容、modCount++、提供钩子方法等</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> V <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>K key<span class=\"token punctuation\">,</span> V value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>Object key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 核心部分</span>\n<span class=\"token keyword\">final</span> V <span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">,</span> K key<span class=\"token punctuation\">,</span> V value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        n <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">[</span>i <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> hash<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n        tab<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">newNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> e<span class=\"token punctuation\">;</span> K k<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            e <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">)</span>\n            e <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">putTreeVal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> tab<span class=\"token punctuation\">,</span> hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> binCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>binCount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    p<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token function\">newNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 尾插法</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>binCount <span class=\"token operator\">>=</span> TREEIFY_THRESHOLD <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// -1 for 1st</span>\n                        <span class=\"token function\">treeifyBin</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> hash<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span>\n                    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                p <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// existing mapping for key</span>\n            V oldValue <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n            e<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">afterNodeAccess</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> oldValue<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">++</span>modCount<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>size <span class=\"token operator\">></span> threshold<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">afterNodeInsertion</span><span class=\"token punctuation\">(</span>evict<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</li>\n</ul>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><ul>\n<li>获取对应hash</li>\n<li>看table是否存在，以及<code>tab[(n - 1) &amp; hash]</code>是否存在</li>\n<li>检查索引下的第一个节点的hash、equals是否相同</li>\n<li>如果是红黑树节点，调用红黑树节点方法搜索</li>\n<li>在下拉链表中搜索</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> V <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>Object key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> e<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> <span class=\"token function\">getNode</span><span class=\"token punctuation\">(</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null <span class=\"token operator\">?</span> null <span class=\"token operator\">:</span> e<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token function\">getNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">,</span> Object key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab<span class=\"token punctuation\">;</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> first<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">;</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span> K k<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span>\n            <span class=\"token punctuation\">(</span>first <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> hash<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span> \n                <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> first<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> first<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> first<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTreeNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span>\n                        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>两种情况会返回null：value不存在、put的value是null</li>\n</ul>\n<h3 id=\"resize\"><a href=\"#resize\" class=\"headerlink\" title=\"resize()\"></a>resize()</h3><p>如果没有初始化，则首先执行初始化，否则执行正常的扩容操作。将容量变成原来的两倍</p>\n<p>遍历原Entry数组，把所有的Entry重新Hash到新数组</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newTab <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">[</span>newCap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> oldCap<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> e<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> oldTab<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            oldTab<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 将老表的节点设置为空, 以便垃圾收集器回收空间</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 只有一个节点,直接散列</span>\n                newTab<span class=\"token punctuation\">[</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>newCap <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 调用红黑树的重新散列</span>\n                <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> newTab<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> oldCap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> loHead <span class=\"token operator\">=</span> null<span class=\"token punctuation\">,</span> loTail <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> hiHead <span class=\"token operator\">=</span> null<span class=\"token punctuation\">,</span> hiTail <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> next<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n                    next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">&amp;</span> oldCap<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 分成两条链表，使用尾插法</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loTail <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n                            loHead <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">else</span>\n                            loTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                        loTail <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hiTail <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n                            hiHead <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">else</span>\n                            hiTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                        hiTail <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loTail <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    loTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                    newTab<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> loHead<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hiTail <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    hiTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                    newTab<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> oldCap<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> hiHead<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> newTab<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>例如00011,10011，如果oldCap=10000(16)<br>00011 &amp; 10000 = 0<br>10011 &amp; 10000 = 10000 != 0<br>将原本在一个索引的节点分成两条链表，一个放在原位置处，一个放在[原位置 + oldCap]处</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>第一次put时才真正创建数组，分配空间</p>\n<p><strong>tableSizeFor（）</strong></p>\n<p>得到第一个大于等于cap的二的幂次方</p>\n<p>用于从构造函数中获取用户输入，并且保证了 table 数组的长度总是 2 的次幂</p>\n<p>无符号右移：就是右移之后，无论该数为正还是为负，右移之后左边都是补上0</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">HashMap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> initialCapacity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> loadFactor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>loadFactor <span class=\"token operator\">=</span> loadFactor<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>threshold <span class=\"token operator\">=</span> <span class=\"token function\">tableSizeFor</span><span class=\"token punctuation\">(</span>initialCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">tableSizeFor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> cap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> cap <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    n <span class=\"token operator\">|=</span> n <span class=\"token operator\">>>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    n <span class=\"token operator\">|=</span> n <span class=\"token operator\">>>></span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    n <span class=\"token operator\">|=</span> n <span class=\"token operator\">>>></span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    n <span class=\"token operator\">|=</span> n <span class=\"token operator\">>>></span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n    n <span class=\"token operator\">|=</span> n <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">>=</span> MAXIMUM_CAPACITY<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> MAXIMUM_CAPACITY <span class=\"token operator\">:</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>例如10001(17)<br>首先cap-1:     10000<br>n |= n &gt;&gt;&gt; 1: n=(10000 | 01000) =11000<br>n |= n &gt;&gt;&gt; 2: n=(11000 | 00110) =11110<br>n |= n &gt;&gt;&gt; 4: n=(11110 | 00001) =11111<br>n |= n &gt;&gt;&gt; 8: n=(11111 | 00000) =11111<br>n |= n &gt;&gt;&gt; 16: n=(11111 | 00000) =11111<br>return n+1:100000(32)<br>…<br>因为int为32位,所以为了保证结果,最后右移16位结束<br>使得要求的数字1开始的后面全为1</p>\n<h3 id=\"迭代器HashIterator\"><a href=\"#迭代器HashIterator\" class=\"headerlink\" title=\"迭代器HashIterator\"></a>迭代器HashIterator</h3><ul>\n<li>初始化记录modCount当前值，并让next指向第一个非空元素，而current=null</li>\n<li>nextNode方法，首先查看modCount值以决定是否fail-fast</li>\n<li>然后检查当前元素是否为空，为空则抛出NoSuchElementException异常</li>\n<li>最后让current等于当前元素，next继续指向下一个非空元素</li>\n<li>hasNext方法则简单判断next是否为空即可</li>\n<li>remove方法首先判断当前节点是否为空，为空则抛出IllegalStateException异常</li>\n<li>随后查看modCount值决定是否fail-fast</li>\n<li>删除该节点，且修改expectedModCount，即迭代器中的remove方法不会导致fail-fast</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HashIterator</span>\n<span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span>K， V<span class=\"token operator\">></span> next<span class=\"token punctuation\">;</span>        \n    Node<span class=\"token operator\">&lt;</span>K， V<span class=\"token operator\">></span> current<span class=\"token punctuation\">;</span>     \n    <span class=\"token keyword\">int</span> expectedModCount<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// for fast-fail</span>\n    <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">;</span>             \n\n    <span class=\"token function\">HashIterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        expectedModCount <span class=\"token operator\">=</span> modCount<span class=\"token punctuation\">;</span>\n        Node<span class=\"token operator\">&lt;</span>K， V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> t <span class=\"token operator\">=</span> table<span class=\"token punctuation\">;</span>\n        current <span class=\"token operator\">=</span> next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> size <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span> \n            <span class=\"token keyword\">do</span>\n            <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> t<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>next <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 让next能指向第一个非空的元素</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> next <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>K， V<span class=\"token operator\">></span> <span class=\"token function\">nextNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Node<span class=\"token operator\">&lt;</span>K， V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> t<span class=\"token punctuation\">;</span>\n        Node<span class=\"token operator\">&lt;</span>K， V<span class=\"token operator\">></span> e <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>modCount <span class=\"token operator\">!=</span> expectedModCount<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// fail-fast机制</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentModificationException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NoSuchElementException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//找到下一个非空元素</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>next <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">=</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">do</span>\n            <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> t<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>next <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Node<span class=\"token operator\">&lt;</span>K， V<span class=\"token operator\">></span> p <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>modCount <span class=\"token operator\">!=</span> expectedModCount<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 依然是fail-fast</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentModificationException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        current <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        K key <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">removeNode</span><span class=\"token punctuation\">(</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>， key， null， <span class=\"token boolean\">false</span>， <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        expectedModCount <span class=\"token operator\">=</span> modCount<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 此处remove不会触发fail-fast</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><h3 id=\"JDK1-7和JDK1-8中HashMap有什么区别？\"><a href=\"#JDK1-7和JDK1-8中HashMap有什么区别？\" class=\"headerlink\" title=\"JDK1.7和JDK1.8中HashMap有什么区别？\"></a>JDK1.7和JDK1.8中HashMap有什么区别？</h3><ul>\n<li>数据结构上：JDK1.8中当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li>\n<li>插入数据方式上：<ul>\n<li>JDK1.7使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环（导致死循环的主要原因是扩容后，节点的顺序会反掉）。</li>\n<li>JDK1.8使用尾插法插入元素（直接插入到链表尾部/红黑树），解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HashMap线程安全问题\"><a href=\"#HashMap线程安全问题\" class=\"headerlink\" title=\"HashMap线程安全问题\"></a>HashMap线程安全问题</h3><p>例如两个线程同时调用put操作，他们同时进入到了if语句后，先写入的Node会被后写入的Node覆盖掉</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">[</span>i <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> hash<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            tab<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">newNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"为什么不直接用红黑树？\"><a href=\"#为什么不直接用红黑树？\" class=\"headerlink\" title=\"为什么不直接用红黑树？\"></a>为什么不直接用红黑树？</h3><p>红黑树节点的大小是普通节点的两倍、红黑树需要进行左旋，右旋，变色这些操作来保持平衡，新增节点的效率低，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度。</p>\n<p><strong>为什么链表改为红黑树的阈值是 8?</strong></p>\n<p>理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循<strong>泊松分布</strong>，按照泊松分布的计算公式计算出桶中元素个数和概率的对照表，链表中元素个数为 8 时的概率非常小。</p>\n<p><strong>默认加载因子为什么是 0.75？</strong></p>\n<p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷，是对空间和时间效率的一个平衡选择。较高的值会降低空间开销，但提高查找成本。较低的值浪费空间。</p>\n<h3 id=\"HashTable与HashMap的区别\"><a href=\"#HashTable与HashMap的区别\" class=\"headerlink\" title=\"HashTable与HashMap的区别\"></a>HashTable与HashMap的区别</h3><ul>\n<li><p>比HashMap多了个线程安全，直接在方法上锁，并发度很低，最多同时允许一个线程访问，效率比较低下</p>\n</li>\n<li><p>如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。也就是说对于Hashtable而言，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占。相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下。</p>\n</li>\n<li><p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。Hashtable在我们put 空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理。</p>\n</li>\n<li><p>初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p>\n</li>\n<li><p>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> hash <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>hash <span class=\"token operator\">&amp;</span> <span class=\"token number\">0x7FFFFFFF</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>迭代器不同：HashMap 中的 Iterator 迭代器是 fail-fast 的，⽽ Hashtable 的 Enumerator是安全失败机制（fail-safe），这种机制会使你此次读到的数据不⼀定是最新的数据。</p>\n</li>\n</ul>\n<h3 id=\"JDK1-7死循环\"><a href=\"#JDK1-7死循环\" class=\"headerlink\" title=\"JDK1.7死循环\"></a>JDK1.7死循环</h3><ul>\n<li>扩容操作中，把旧表中所有Node重新计算索引下标并散列到新表对应索引处(采用头插法)</li>\n<li>把新表的引用赋值给table</li>\n</ul>\n<p>首先会导致链表反转：</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601204630630.png\" alt=\"image-20210601204630630\" style=\"zoom: 67%;\" />\n\n<p>如果线程1、线程2同时操作，线程2执行到e = A、next = B时切换到线程1，线程1执行完resize导致链表反转成C-&gt;B-&gt;A-&gt;null。</p>\n<p>线程2继续执行以下代码，则产生了死循环：</p>\n<pre><code>e.next = newTable[i];\nnewTable[i] = e;\ne = next;</code></pre>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601205841811.png\" alt=\"image-20210601205841811\" style=\"zoom:67%;\" />\n\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> newCapacity<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Entry<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> oldTable <span class=\"token operator\">=</span> table<span class=\"token punctuation\">;</span>\n    Entry<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newTable <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span>newCapacity<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span>newTable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    table <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span>Entry<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newTable<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Entry<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> e <span class=\"token operator\">:</span> table<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 遍历旧表中每个Entry</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>null <span class=\"token operator\">!=</span> e<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 对不为空的(链表)进行操作</span>\n        <span class=\"token punctuation\">{</span>\n            Entry<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">=</span> null <span class=\"token operator\">==</span> e<span class=\"token punctuation\">.</span>key <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token function\">indexFor</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">,</span> newCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 通过新的容量大小散列得到新的索引</span>\n            e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> newTable<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            newTable<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n            e <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"hashCode与equals\"><a href=\"#hashCode与equals\" class=\"headerlink\" title=\"hashCode与equals\"></a><strong>hashCode与equals</strong></h3><p><strong>equals</strong></p>\n<p>在未重写equals方法我们是继承了Object的equals方法，默认比较两个对象的内存地址</p>\n<ul>\n<li>对于值对象，==比较的是两个对象的值</li>\n<li>对于引用对象，==比较的是两个对象的地址</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 默认情况是:</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>Object obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 一般会重写equals方法以比较两个对象的内容</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>Object obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token operator\">==</span>obj<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>obj<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!=</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n    Person person <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Person<span class=\"token punctuation\">)</span> obj<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Objects<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>name， person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>Objects<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>age， person<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n所以基本数据类型用<span class=\"token operator\">==</span>判断相等，引用数据类型都用<span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>进行判断<span class=\"token punctuation\">(</span>String也是引用类型<span class=\"token punctuation\">)</span>\n即<span class=\"token operator\">==</span>是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同\n<span class=\"token operator\">==</span>指引用是否相同 <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>指的是值是否相同</code></pre>\n<p><strong>hashcode</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\">因为HashSet或HashMap等集合中判断元素是否相等用到了hashcode是否相等，所以为避免我们认为相等但是逻辑判断却不相等的情况出现，自定义类重写equals必须重写hashcode方法\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">native</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n无论何时覆盖该方法，通常需要覆盖`hashCode`方法，以便维护`hashCode`方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。\n\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Objects<span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>username， age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li><p>如果两个对象相等，则hashcode一定也是相同的</p>\n</li>\n<li><p>两个对象相等，对两个equals方法返回true</p>\n</li>\n<li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p>\n</li>\n<li><p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>\n</li>\n</ul>\n<p><strong>例子</strong></p>\n<p>使用Set存放学生信息，此时不小心对同一个人录入了两次（学号和姓名相同，但不是同一个对象）（我们逻辑上认为是同一个人，并且已重写了equals()方法，但是没有重写hashcode()方法）。这时Set中按逻辑应该只有一个学生，但是实际上却有两个</p>\n<p>这是因为我们没有重写父类（Object）的hashcode方法，Object的hashcode方法会根据两个对象的地址生成对相应的hashcode；s1和s2是分别new出来的，那么他们的地址肯定是不一样的，自然hashcode值也会不一样。</p>\n<p>Set区别对象的标准是，两个对象hashcode是不是一样，再判定两个对象是否equals；此时因为hashCode不一样，所以Set判定他们不是同一个对象，在Set中该学生信息就出现了两次</p>\n<h1 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h1><h2 id=\"数据结构-1\"><a href=\"#数据结构-1\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> K key<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">volatile</span> V val<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">volatile</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 在扩容时发挥作用，hash值为MOVED(-1)，存储nextTable的引用</span>\n<span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ForwardingNode</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nextTable<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">ForwardingNode</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>MOVED<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nextTable <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">volatile</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> table<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">volatile</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nextTable<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 默认为null，扩容时新生成的数组，其大小为原数组的两倍。</span>\n<span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> sizeCtl<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 控制初始化和扩容的</span>\n\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MOVED     <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 表示正在扩容</span></code></pre>\n<ul>\n<li>Node节点设置了volatile关键字修饰，致使它每次获取的都是<strong>最新</strong>设置的值</li>\n<li>抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构。</li>\n<li>在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。</li>\n<li>ConcurrentHashMap不允许key或value为null值</li>\n</ul>\n<ul>\n<li>在集合<strong>新建而未初始化</strong>时，sizeCtl用于记录初始容量大小</li>\n<li>在集合<strong>初始化过程中</strong>，sizeCtl值设置为 -1 表示集合正在初始化中，其他线程发现该值为 -1 时会让出CPU资源以便初始化操作尽快完成 。</li>\n<li>集合<strong>初始化完成后</strong>，sizeCtl 用于记录当前集合的负载容量值，也就是触发集合扩容的极限值 。</li>\n<li>集合<strong>正在扩容时</strong>，sizeCtl 用于记录当前扩容的并发线程数情况，该状态下 sizeCtl &lt; 0 。</li>\n</ul>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"put-1\"><a href=\"#put-1\" class=\"headerlink\" title=\"put\"></a>put</h3><p>ConcurrentHashMap添加数据时，采取了CAS+synchronize结合策略。首先会判断该节点是否为null，如果为null，尝试使用CAS添加节点；如果添加失败，说明发生了并发冲突，再对节点进行上锁并插入数据。在并发较低的情景下无需加锁，可以显著提高性能。同时只会CAS尝试一次，也不会造成线程长时间等待浪费cpu时间的情况。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> V <span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span>K key<span class=\"token punctuation\">,</span> V value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> value <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> hash <span class=\"token operator\">=</span> <span class=\"token function\">spread</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> binCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> f<span class=\"token punctuation\">;</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> fh<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tab <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            tab <span class=\"token operator\">=</span> <span class=\"token function\">initTable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>f <span class=\"token operator\">=</span> <span class=\"token function\">tabAt</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> i <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> hash<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">casTabAt</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>                   \n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>fh <span class=\"token operator\">=</span> f<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> MOVED<span class=\"token punctuation\">)</span> \n            tab <span class=\"token operator\">=</span> <span class=\"token function\">helpTransfer</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            V oldVal <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// f是要插入的索引下标上的首节点</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tabAt</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> f<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fh <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token comment\" spellcheck=\"true\">// 尾查法往链表添加节点</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>f <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeBin</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token comment\" spellcheck=\"true\">// 调用红黑树添加节点方法</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>binCount <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>binCount <span class=\"token operator\">>=</span> TREEIFY_THRESHOLD<span class=\"token punctuation\">)</span>\n                    <span class=\"token function\">treeifyBin</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldVal <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">return</span> oldVal<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">addCount</span><span class=\"token punctuation\">(</span>1L<span class=\"token punctuation\">,</span> binCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">spread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> h<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> HASH_BITS<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 0x7fffff</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>判断键值是否为<code>null</code>，为<code>null</code>抛出异常。</li>\n<li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址</li>\n<li>如果当前table为空，则初始化table，需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong>尝试</strong>初始化table，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程。</li>\n<li>使用<code>i = (n - 1) &amp; hash</code>计算出待插入键值的下标，如果该下标上的bucket为<code>null</code>，则直接调用实现<code>CAS</code>原子性操作的<code>casTabAt()</code>方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。</li>\n<li>如果该下标上的节点(头节点)的哈希地址为MOVED(-1)，说明当前f是ForwardingNode节点，意味有其它线程正在扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li>\n<li>如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时<strong>使用synchroized锁住这个bucket</strong>，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket</li>\n<li>进入到bucket里面，首先判断这个bucket存储的是红黑树还是链表。</li>\n<li>如果是<strong>链表</strong>，则遍历链表看看是否有hash和equals相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点<strong>插入到链表尾部</strong>。如果是<strong>红黑树</strong>，则将节点插入。到这里<strong>解锁</strong>。</li>\n<li>最后判断该bucket上的链表长度是否大于**链表转红黑树的阈值(8)**，大于则将链表转成红黑树。</li>\n<li>调用<code>addCount()</code>方法，将键值对数量+1，并检查是否需要扩容。</li>\n</ul>\n<h3 id=\"get-1\"><a href=\"#get-1\" class=\"headerlink\" title=\"get\"></a>get</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> V <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>Object key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> h <span class=\"token operator\">=</span> <span class=\"token function\">spread</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span>\n            <span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> <span class=\"token function\">tabAt</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>eh <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> h<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 头节点寻找</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ek <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>ek <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>ek<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>eh <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n            <span class=\"token comment\" spellcheck=\"true\">// 红黑树中寻找</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n            <span class=\"token comment\" spellcheck=\"true\">// 链表中寻找</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ol>\n<li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址。</li>\n<li>如果table不为空，对应key所在bucket不为空：<code>tabAt(tab, (n - 1) &amp; h))</code>，则到bucket中查找。</li>\n<li>如果头节点hash、equals相同，则返回头节点值</li>\n<li>如果bucket的头节点的hash小于0，则代表这个bucket存储的是红黑树，则在红黑树中查找。</li>\n<li>如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，找到则返回该键key的值，找不到则返回null。</li>\n</ol>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h3><ol>\n<li>调用<code>spread()</code>方法计算出键key的哈希地址。</li>\n<li>计算出键key所在的数组下标，如果table为空或者bucket为空，则返回<code>null</code>。</li>\n<li>判断当前table是否正在扩容，如果在扩容则调用helpTransfer方法协助扩容。</li>\n<li>如果table和bucket都不为空，table也不处于在扩容状态，则<strong>锁住当前bucket</strong>，对bucket进行操作。</li>\n<li>根据bucket的头结点判断bucket是链表还是红黑树。</li>\n<li>在链表或者红黑树中移除哈希地址、键key相同的节点。</li>\n<li>调用<code>addCount</code>方法，将当前table存储的键值对数量-1。</li>\n</ol>\n<h3 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">ConcurrentHashMap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> initialCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> cap <span class=\"token operator\">=</span> <span class=\"token function\">tableSizeFor</span><span class=\"token punctuation\">(</span>initialCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sizeCtl <span class=\"token operator\">=</span> cap<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 第一次put时才调用</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">initTable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab<span class=\"token punctuation\">;</span> <span class=\"token keyword\">int</span> sc<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> tab<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sc <span class=\"token operator\">=</span> sizeCtl<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            Thread<span class=\"token punctuation\">.</span><span class=\"token function\">yield</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>U<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> SIZECTL<span class=\"token punctuation\">,</span> sc<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> tab<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                table <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span><span class=\"token operator\">?</span><span class=\"token operator\">></span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                sizeCtl <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">>>></span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> tab<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>table的初始化只能由一个线程完成，但是每个线程都可以争抢去初始化table。</li>\n<li>首先，判断table是否为null，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。</li>\n<li>如果table为null，进入到while循环，如果<code>sizeCtl</code>小于0(其他线程正在对table初始化)，那么该线程调用<code>Thread.yield()</code>挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为<code>null</code>，则继续while循环。</li>\n<li>如果table为null且<code>sizeCtl</code>不小于0，则调用实现<code>CAS</code>原子性操作的<code>compareAndSwap()</code>方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的。并设置sizeCtl的值为数组长度的3/4（<code>threshold</code>的作用），当ConcurrentHashMap储存的键值对数量大于这个阈值，就会发生扩容。</li>\n</ul>\n<h3 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h3><p><strong>触发扩容</strong></p>\n<ol>\n<li><p>添加新元素后，元素个数达到扩容阈值触发扩容。</p>\n</li>\n<li><p>调用 putAll 方法，发现容量不足以容纳所有元素时候触发扩容。</p>\n</li>\n<li><p>某个槽内的链表长度达到 8，但是数组长度小于 64 时候触发扩容。</p>\n</li>\n</ol>\n<p><strong>扩容操作</strong></p>\n<ul>\n<li>构建一个nextTable，大小为table的两倍。这个过程只能只有单个线程进行nextTable的初始化（通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable）</li>\n<li>将原来table里面的内容复制到nextTable中，这个步骤是允许<strong>多线程</strong>操作的，所以性能得到提升，减少了扩容的时间消耗。</li>\n</ul>\n<p><strong>扩容时其他操作</strong></p>\n<p>扩容状态下其他线程对集合进行插入、修改、删除等操作时遇到 ForwardingNode 节点会调用helpTransfer方法帮助扩容</p>\n<h2 id=\"扩展-1\"><a href=\"#扩展-1\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><h3 id=\"JDK1-7的ConcurrentHashMap\"><a href=\"#JDK1-7的ConcurrentHashMap\" class=\"headerlink\" title=\"JDK1.7的ConcurrentHashMap\"></a>JDK1.7的ConcurrentHashMap</h3><ul>\n<li>基本思想是将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</li>\n<li>Segment 是一个ReentrantLock，每一个Segment元素存储的是HashEntry数组+链表，每一个Segment其实就相当于一个HashMap</li>\n<li>put操作需要加锁，get操作不用加锁（通过使用volatile和巧妙的操作保证同步）</li>\n<li>ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216212.png\" alt=\"20216212\"></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> Segment<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> segments<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Segment</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ReentrantLock</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">volatile</span> HashEntry<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> table<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> count<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> modCount<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> threshold<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">float</span> loadFactor<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HashEntry</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">final</span> K key<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">volatile</span> V value<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">final</span> HashEntry<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> next<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"ConcurrentHashMap不允许key或value为null值\"><a href=\"#ConcurrentHashMap不允许key或value为null值\" class=\"headerlink\" title=\"ConcurrentHashMap不允许key或value为null值\"></a>ConcurrentHashMap不允许key或value为null值</h3><p>put操作中有相应的判断：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> value <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>但这样设计的原因是避免二义性：假定ConcurrentHashMap也可以存放value为null的值。那调用map.get(key)时如果返回了null，有两重含义:</p>\n<p><strong>1.这个key从来没有在map中映射过。</strong></p>\n<p><strong>2.这个key的value在设置的时候，就是null。</strong></p>\n<p>对于HashMap来说，它的正确使用场景是在单线程下使用。所以在单线程中，当我们得到的value是null的时候，可以用hashMap.containsKey(key)方法来区分上面说的两重含义。</p>\n<p>而ConcurrentHashMap的使用场景为多线程。假设concurrentHashMap允许存放值为null的value。这时有A、B两个线程。线程A调用concurrentHashMap.get(key)方法，返回为null，我们还是不知道这个null是没有映射的null还是存的值就是null。</p>\n<p>假设此时返回null的真实情况是因为这个key没有在map里面映射过。用concurrentHashMap.containsKey(key)来验证假设是否成立，期望的结果是返回false。</p>\n<p>但是在我们调用concurrentHashMap.get(key)方法之后，containsKey方法之前，有一个线程B执行了concurrentHashMap.put(key,null)的操作。那么我们调用containsKey方法返回的就是true了。这就与我们的假设的真实情况不符合了。    </p>\n<h1 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h1><h2 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h2><ul>\n<li>不保证集合顺序</li>\n<li>允许null值</li>\n<li>HashSet 不允许重复的值</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//底层使用HashMap来保存HashSet中所有元素</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> HashMap<span class=\"token operator\">&lt;</span>E，Object<span class=\"token operator\">></span> map<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//定义一个虚拟的Object对象作为HashMap的value</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Object PRESENT <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//因为put会返回原Value，如果放入相同的，则返回就不为null</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//则该方法返回false，代表添加不成功，代表已经有了元素</span>\n    <span class=\"token comment\" spellcheck=\"true\">//HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT</span>\n    <span class=\"token keyword\">return</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>e， PRESENT<span class=\"token punctuation\">)</span><span class=\"token operator\">==</span>null<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"LinkedHashSet\"><a href=\"#LinkedHashSet\" class=\"headerlink\" title=\"LinkedHashSet\"></a>LinkedHashSet</h2><ul>\n<li>LinkedHashSet 内部是通过 LinkedHashMap 来实现的。</li>\n<li>继承HashSet</li>\n<li>LinkedHashSet的构造器调用父类HashSet的其中一个构造器，将map初始化为LinkedHashMap，所以再调用方法时，就会有LinkedHashMap的调用效果</li>\n<li>用双向链表维持元素的插入顺序</li>\n<li>重新插入时不会影响顺序</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h1><h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><h3 id=\"继承体系\"><a href=\"#继承体系\" class=\"headerlink\" title=\"继承体系\"></a>继承体系</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601175023607.png\" alt=\"image-20210601175023607\"></p>\n<ul>\n<li>HashMap：不保证遍历顺序，非线程安全</li>\n<li>LinkedHashMap：HashMap的子类，保持了记录插入顺序，遍历会得到先插入的Node，也可以按照访问顺序排列，实现LRU算法</li>\n<li>TreeMap：默认按照key升序排列</li>\n<li>Hashtable：线程安全，效率低，所有方法加synchronized修饰，需要线程安全场景用ConcurrentHashMap即可</li>\n</ul>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>数组+链表+红黑树</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601212902002.png\" alt=\"image-20210601212902002\"></p>\n<pre><code class=\"java\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n    final int hash;\n    final K key;\n    V value;\n    Node&lt;K,V&gt; next;\n}\n\nNode&lt;K,V&gt;[] table; // 第一次put时初始化，length总是2的幂次倍\nint size; // HashMap中实际存在的键值对数量\nint modCount; // 记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。\nint threshold; // 所能容纳的最大Node(键值对)个数。threshold = length * Load factor,超过这个数目就重新resize(扩容)\nfinal float loadFactor; \ntransient Set&lt;Map.Entry&lt;K， V&gt;&gt; entrySet;\n\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 默认初始容量\nstatic final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 最大数组容量\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认负载因子为0.75\nstatic final int TREEIFY_THRESHOLD = 8;  // 单个Node下的值的个数大于8时候，会将链表转换成为红黑树。\nstatic final int UNTREEIFY_THRESHOLD = 6; // 单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。\nstatic final int MIN_TREEIFY_CAPACITY = 64; // 树化的最小数组容量</code></pre>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ul>\n<li><p>运行key为null（hash为null），存放在entry数组的第0个位置上</p>\n</li>\n<li><p>如果put操作中，只改变了value，则modCount不变</p>\n</li>\n<li><p>要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了（因为put和get都需要靠hashCode找到他的索引下标）。</p>\n</li>\n<li><p>当同一个索引位置的节点在增加后达到8个时，并且此时数组的长度大于等于 64，则则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。</p>\n<p>  当单个桶中元素数量小于6时，进行反树化</p>\n</li>\n<li><p>HashMap查找添加元素的时间复杂度都为O(1)。数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数</p>\n</li>\n<li><p>为它的子类LinkedHashMap提供一些钩子方法</p>\n</li>\n</ul>\n<h2 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h2><h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h3><ol>\n<li>计算key对应的hashCode</li>\n<li>在entry数组较小时也能让高位也参与hash的运算：<code>hash = (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li>\n<li>如果table不存在，则先初始化</li>\n<li>如果索引<code>i = (n - 1) &amp; hash</code>的位置为null，则直接新建节点</li>\n<li>看table[i]首节点是否和key相同，相同则覆盖value，返回oldValue，判断是否相同的方法：hash相同，并且equals方法也相同</li>\n<li>如果是红黑树节点，调用红黑树节点的插入方法</li>\n<li>遍历下拉链表，如果找到了value就覆盖，找到链表尾部就新建Node，并且查看是否需要进行树化</li>\n<li>插入成功后查看是否需要扩容、modCount++、提供钩子方法等</li>\n</ol>\n<pre><code class=\"java\">public V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n}\n\n// 核心部分\nfinal V putVal(int hash, K key, V value) {\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    if ((p = tab[i = (n - 1) &amp; hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node&lt;K,V&gt; e; K k;\n        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n            e = p;\n        else if (p instanceof TreeNode)\n            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null); // 尾插法\n                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &amp;&amp;\n                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}</code></pre>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</li>\n</ul>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><ul>\n<li>获取对应hash</li>\n<li>看table是否存在，以及<code>tab[(n - 1) &amp; hash]</code>是否存在</li>\n<li>检查索引下的第一个节点的hash、equals是否相同</li>\n<li>如果是红黑树节点，调用红黑树节点方法搜索</li>\n<li>在下拉链表中搜索</li>\n</ul>\n<pre><code class=\"java\">public V get(Object key) {\n    Node&lt;K,V&gt; e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\nfinal Node&lt;K,V&gt; getNode(int hash, Object key) {\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;\n            (first = tab[(n - 1) &amp; hash]) != null) {\n        if (first.hash == hash &amp;&amp; \n                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))\n            return first;\n        if ((e = first.next) != null) {\n            if (first instanceof TreeNode)\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n            do {\n                if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}</code></pre>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>两种情况会返回null：value不存在、put的value是null</li>\n</ul>\n<h3 id=\"resize\"><a href=\"#resize\" class=\"headerlink\" title=\"resize()\"></a>resize()</h3><p>如果没有初始化，则首先执行初始化，否则执行正常的扩容操作。将容量变成原来的两倍</p>\n<p>遍历原Entry数组，把所有的Entry重新Hash到新数组</p>\n<pre><code class=\"java\">final Node&lt;K, V&gt;[] resize() {\n    Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) new Node[newCap];\n    for (int j = 0; j &lt; oldCap; ++j) {\n        Node&lt;K, V&gt; e;\n        if ((e = oldTab[j]) != null)\n        {\n            oldTab[j] = null; // 将老表的节点设置为空, 以便垃圾收集器回收空间\n            if (e.next == null) // 只有一个节点,直接散列\n                newTab[e.hash &amp; (newCap - 1)] = e;\n            else if (e instanceof TreeNode) // 调用红黑树的重新散列\n                ((TreeNode&lt;K, V&gt;) e).split(this, newTab, j, oldCap);\n            else {\n                Node&lt;K, V&gt; loHead = null, loTail = null;\n                Node&lt;K, V&gt; hiHead = null, hiTail = null;\n                Node&lt;K, V&gt; next;\n                do {\n                    next = e.next;\n                    if ((e.hash &amp; oldCap) == 0) { // 分成两条链表，使用尾插法\n                        if (loTail == null)\n                            loHead = e;\n                        else\n                            loTail.next = e;\n                        loTail = e;\n                    } else {\n                        if (hiTail == null)\n                            hiHead = e;\n                        else\n                            hiTail.next = e;\n                        hiTail = e;\n                    }\n                } while ((e = next) != null);\n                if (loTail != null) {\n                    loTail.next = null;\n                    newTab[j] = loHead;\n                }\n                if (hiTail != null) {\n                    hiTail.next = null;\n                    newTab[j + oldCap] = hiHead;\n                }\n            }\n        }\n    }\n    return newTab;\n}</code></pre>\n<p>例如00011,10011，如果oldCap=10000(16)<br>00011 &amp; 10000 = 0<br>10011 &amp; 10000 = 10000 != 0<br>将原本在一个索引的节点分成两条链表，一个放在原位置处，一个放在[原位置 + oldCap]处</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>第一次put时才真正创建数组，分配空间</p>\n<p><strong>tableSizeFor（）</strong></p>\n<p>得到第一个大于等于cap的二的幂次方</p>\n<p>用于从构造函数中获取用户输入，并且保证了 table 数组的长度总是 2 的次幂</p>\n<p>无符号右移：就是右移之后，无论该数为正还是为负，右移之后左边都是补上0</p>\n<pre><code class=\"java\">public HashMap(int initialCapacity, float loadFactor) {\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\n}\nstatic final int tableSizeFor(int cap) {\n    int n = cap - 1;\n    n |= n &gt;&gt;&gt; 1;\n    n |= n &gt;&gt;&gt; 2;\n    n |= n &gt;&gt;&gt; 4;\n    n |= n &gt;&gt;&gt; 8;\n    n |= n &gt;&gt;&gt; 16;\n    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}</code></pre>\n<p>例如10001(17)<br>首先cap-1:     10000<br>n |= n &gt;&gt;&gt; 1: n=(10000 | 01000) =11000<br>n |= n &gt;&gt;&gt; 2: n=(11000 | 00110) =11110<br>n |= n &gt;&gt;&gt; 4: n=(11110 | 00001) =11111<br>n |= n &gt;&gt;&gt; 8: n=(11111 | 00000) =11111<br>n |= n &gt;&gt;&gt; 16: n=(11111 | 00000) =11111<br>return n+1:100000(32)<br>…<br>因为int为32位,所以为了保证结果,最后右移16位结束<br>使得要求的数字1开始的后面全为1</p>\n<h3 id=\"迭代器HashIterator\"><a href=\"#迭代器HashIterator\" class=\"headerlink\" title=\"迭代器HashIterator\"></a>迭代器HashIterator</h3><ul>\n<li>初始化记录modCount当前值，并让next指向第一个非空元素，而current=null</li>\n<li>nextNode方法，首先查看modCount值以决定是否fail-fast</li>\n<li>然后检查当前元素是否为空，为空则抛出NoSuchElementException异常</li>\n<li>最后让current等于当前元素，next继续指向下一个非空元素</li>\n<li>hasNext方法则简单判断next是否为空即可</li>\n<li>remove方法首先判断当前节点是否为空，为空则抛出IllegalStateException异常</li>\n<li>随后查看modCount值决定是否fail-fast</li>\n<li>删除该节点，且修改expectedModCount，即迭代器中的remove方法不会导致fail-fast</li>\n</ul>\n<pre><code class=\"java\">abstract class HashIterator\n{\n    Node&lt;K， V&gt; next;        \n    Node&lt;K， V&gt; current;     \n    int expectedModCount;  // for fast-fail\n    int index;             \n\n    HashIterator()\n    {\n        expectedModCount = modCount;\n        Node&lt;K， V&gt;[] t = table;\n        current = next = null;\n        index = 0;\n        if (t != null &amp;&amp; size &gt; 0)\n        { \n            do\n            {\n            } while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);\n            // 让next能指向第一个非空的元素\n        }\n    }\n\n    public final boolean hasNext()\n    {\n        return next != null;\n    }\n\n    final Node&lt;K， V&gt; nextNode()\n    {\n        Node&lt;K， V&gt;[] t;\n        Node&lt;K， V&gt; e = next;\n        if (modCount != expectedModCount) // fail-fast机制\n            throw new ConcurrentModificationException();\n        if (e == null)\n            throw new NoSuchElementException();\n        //找到下一个非空元素\n        if ((next = (current = e).next) == null &amp;&amp; (t = table) != null)\n        {\n            do\n            {\n            } while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);\n        }\n        return e;\n    }\n\n    public final void remove()\n    {\n        Node&lt;K， V&gt; p = current;\n        if (p == null)\n            throw new IllegalStateException();\n        if (modCount != expectedModCount) // 依然是fail-fast\n            throw new ConcurrentModificationException();\n        current = null;\n        K key = p.key;\n        removeNode(hash(key)， key， null， false， false);\n        expectedModCount = modCount; // 此处remove不会触发fail-fast\n    }\n}</code></pre>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><h3 id=\"JDK1-7和JDK1-8中HashMap有什么区别？\"><a href=\"#JDK1-7和JDK1-8中HashMap有什么区别？\" class=\"headerlink\" title=\"JDK1.7和JDK1.8中HashMap有什么区别？\"></a>JDK1.7和JDK1.8中HashMap有什么区别？</h3><ul>\n<li>数据结构上：JDK1.8中当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li>\n<li>插入数据方式上：<ul>\n<li>JDK1.7使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环（导致死循环的主要原因是扩容后，节点的顺序会反掉）。</li>\n<li>JDK1.8使用尾插法插入元素（直接插入到链表尾部/红黑树），解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HashMap线程安全问题\"><a href=\"#HashMap线程安全问题\" class=\"headerlink\" title=\"HashMap线程安全问题\"></a>HashMap线程安全问题</h3><p>例如两个线程同时调用put操作，他们同时进入到了if语句后，先写入的Node会被后写入的Node覆盖掉</p>\n<pre><code class=\"java\">if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);</code></pre>\n<h3 id=\"为什么不直接用红黑树？\"><a href=\"#为什么不直接用红黑树？\" class=\"headerlink\" title=\"为什么不直接用红黑树？\"></a>为什么不直接用红黑树？</h3><p>红黑树节点的大小是普通节点的两倍、红黑树需要进行左旋，右旋，变色这些操作来保持平衡，新增节点的效率低，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度。</p>\n<p><strong>为什么链表改为红黑树的阈值是 8?</strong></p>\n<p>理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循<strong>泊松分布</strong>，按照泊松分布的计算公式计算出桶中元素个数和概率的对照表，链表中元素个数为 8 时的概率非常小。</p>\n<p><strong>默认加载因子为什么是 0.75？</strong></p>\n<p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷，是对空间和时间效率的一个平衡选择。较高的值会降低空间开销，但提高查找成本。较低的值浪费空间。</p>\n<h3 id=\"HashTable与HashMap的区别\"><a href=\"#HashTable与HashMap的区别\" class=\"headerlink\" title=\"HashTable与HashMap的区别\"></a>HashTable与HashMap的区别</h3><ul>\n<li><p>比HashMap多了个线程安全，直接在方法上锁，并发度很低，最多同时允许一个线程访问，效率比较低下</p>\n</li>\n<li><p>如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。也就是说对于Hashtable而言，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占。相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下。</p>\n</li>\n<li><p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。Hashtable在我们put 空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理。</p>\n</li>\n<li><p>初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p>\n</li>\n<li><p>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</p>\n<pre><code class=\"java\">int hash = key.hashCode();\nint index = (hash &amp; 0x7FFFFFFF) % tab.length;</code></pre>\n</li>\n<li><p>迭代器不同：HashMap 中的 Iterator 迭代器是 fail-fast 的，⽽ Hashtable 的 Enumerator是安全失败机制（fail-safe），这种机制会使你此次读到的数据不⼀定是最新的数据。</p>\n</li>\n</ul>\n<h3 id=\"JDK1-7死循环\"><a href=\"#JDK1-7死循环\" class=\"headerlink\" title=\"JDK1.7死循环\"></a>JDK1.7死循环</h3><ul>\n<li>扩容操作中，把旧表中所有Node重新计算索引下标并散列到新表对应索引处(采用头插法)</li>\n<li>把新表的引用赋值给table</li>\n</ul>\n<p>首先会导致链表反转：</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601204630630.png\" alt=\"image-20210601204630630\" style=\"zoom: 67%;\" />\n\n<p>如果线程1、线程2同时操作，线程2执行到e = A、next = B时切换到线程1，线程1执行完resize导致链表反转成C-&gt;B-&gt;A-&gt;null。</p>\n<p>线程2继续执行以下代码，则产生了死循环：</p>\n<pre><code>e.next = newTable[i];\nnewTable[i] = e;\ne = next;</code></pre>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210601205841811.png\" alt=\"image-20210601205841811\" style=\"zoom:67%;\" />\n\n<pre><code class=\"java\">void resize(int newCapacity)\n{\n    Entry[] oldTable = table;\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable);\n    table = newTable;\n}\n\nvoid transfer(Entry[] newTable)\n{\n    for (Entry&lt;K, V&gt; e : table)  // 遍历旧表中每个Entry\n    {\n        while (null != e) // 对不为空的(链表)进行操作\n        {\n            Entry&lt;K, V&gt; next = e.next;\n            e.hash = null == e.key ? 0 : hash(e.key);\n            int i = indexFor(e.hash, newCapacity); // 通过新的容量大小散列得到新的索引\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}</code></pre>\n<h3 id=\"hashCode与equals\"><a href=\"#hashCode与equals\" class=\"headerlink\" title=\"hashCode与equals\"></a><strong>hashCode与equals</strong></h3><p><strong>equals</strong></p>\n<p>在未重写equals方法我们是继承了Object的equals方法，默认比较两个对象的内存地址</p>\n<ul>\n<li>对于值对象，==比较的是两个对象的值</li>\n<li>对于引用对象，==比较的是两个对象的地址</li>\n</ul>\n<pre><code class=\"java\">// 默认情况是:\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n// 一般会重写equals方法以比较两个对象的内容\npublic boolean equals(Object obj){\n    if(this==obj) return true;\n    if(obj==null) return false;\n    if(getClass()!=obj.getClass()) return false;\n\n    Person person = (Person) obj;\n    return Objects.equals(name， person.name) &amp;&amp;Objects.equals(age， person.age);\n}\n所以基本数据类型用==判断相等，引用数据类型都用equals()进行判断(String也是引用类型)\n即==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同\n==指引用是否相同 equals()指的是值是否相同</code></pre>\n<p><strong>hashcode</strong></p>\n<pre><code class=\"java\">因为HashSet或HashMap等集合中判断元素是否相等用到了hashcode是否相等，所以为避免我们认为相等但是逻辑判断却不相等的情况出现，自定义类重写equals必须重写hashcode方法\npublic native int hashCode();\n\n无论何时覆盖该方法，通常需要覆盖`hashCode`方法，以便维护`hashCode`方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。\n\n@Override\npublic int hashCode()\n{\n    return Objects.hash(username， age);\n}</code></pre>\n<ul>\n<li><p>如果两个对象相等，则hashcode一定也是相同的</p>\n</li>\n<li><p>两个对象相等，对两个equals方法返回true</p>\n</li>\n<li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p>\n</li>\n<li><p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>\n</li>\n</ul>\n<p><strong>例子</strong></p>\n<p>使用Set存放学生信息，此时不小心对同一个人录入了两次（学号和姓名相同，但不是同一个对象）（我们逻辑上认为是同一个人，并且已重写了equals()方法，但是没有重写hashcode()方法）。这时Set中按逻辑应该只有一个学生，但是实际上却有两个</p>\n<p>这是因为我们没有重写父类（Object）的hashcode方法，Object的hashcode方法会根据两个对象的地址生成对相应的hashcode；s1和s2是分别new出来的，那么他们的地址肯定是不一样的，自然hashcode值也会不一样。</p>\n<p>Set区别对象的标准是，两个对象hashcode是不是一样，再判定两个对象是否equals；此时因为hashCode不一样，所以Set判定他们不是同一个对象，在Set中该学生信息就出现了两次</p>\n<h1 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h1><h2 id=\"数据结构-1\"><a href=\"#数据结构-1\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><pre><code class=\"java\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n    final int hash;\n    final K key;\n    volatile V val;\n    volatile Node&lt;K,V&gt; next;\n}\n\n// 在扩容时发挥作用，hash值为MOVED(-1)，存储nextTable的引用\nfinal class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; {\n    final Node&lt;K,V&gt;[] nextTable;\n    ForwardingNode(Node&lt;K,V&gt;[] tab) {\n        super(MOVED, null, null, null);\n        this.nextTable = tab;\n    }\n}\n\nvolatile Node&lt;K,V&gt;[] table;\nvolatile Node&lt;K,V&gt;[] nextTable; // 默认为null，扩容时新生成的数组，其大小为原数组的两倍。\nvolatile int sizeCtl; // 控制初始化和扩容的\n\n\nstatic final int MOVED     = -1;  // 表示正在扩容</code></pre>\n<ul>\n<li>Node节点设置了volatile关键字修饰，致使它每次获取的都是<strong>最新</strong>设置的值</li>\n<li>抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构。</li>\n<li>在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。</li>\n<li>ConcurrentHashMap不允许key或value为null值</li>\n</ul>\n<ul>\n<li>在集合<strong>新建而未初始化</strong>时，sizeCtl用于记录初始容量大小</li>\n<li>在集合<strong>初始化过程中</strong>，sizeCtl值设置为 -1 表示集合正在初始化中，其他线程发现该值为 -1 时会让出CPU资源以便初始化操作尽快完成 。</li>\n<li>集合<strong>初始化完成后</strong>，sizeCtl 用于记录当前集合的负载容量值，也就是触发集合扩容的极限值 。</li>\n<li>集合<strong>正在扩容时</strong>，sizeCtl 用于记录当前扩容的并发线程数情况，该状态下 sizeCtl &lt; 0 。</li>\n</ul>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"put-1\"><a href=\"#put-1\" class=\"headerlink\" title=\"put\"></a>put</h3><p>ConcurrentHashMap添加数据时，采取了CAS+synchronize结合策略。首先会判断该节点是否为null，如果为null，尝试使用CAS添加节点；如果添加失败，说明发生了并发冲突，再对节点进行上锁并插入数据。在并发较低的情景下无需加锁，可以显著提高性能。同时只会CAS尝试一次，也不会造成线程长时间等待浪费cpu时间的情况。</p>\n<pre><code class=\"java\">final V putVal(K key, V value) {\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n\n    for (Node&lt;K,V&gt;[] tab = table;;) {\n        Node&lt;K,V&gt; f; int n, i, fh;\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {\n            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))\n                break;                   \n        }\n        else if ((fh = f.hash) == MOVED) \n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            synchronized (f) { // f是要插入的索引下标上的首节点\n                if (tabAt(tab, i) == f) {\n                    if (fh &gt;= 0) {\n                        // 尾查法往链表添加节点\n                    }\n                    else if (f instanceof TreeBin) {\n                        // 调用红黑树添加节点方法\n                    }\n                }\n            }\n            if (binCount != 0) {\n                if (binCount &gt;= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n\nstatic final int spread(int h) {\n    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS; // 0x7fffff\n}</code></pre>\n<ul>\n<li>判断键值是否为<code>null</code>，为<code>null</code>抛出异常。</li>\n<li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址</li>\n<li>如果当前table为空，则初始化table，需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong>尝试</strong>初始化table，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程。</li>\n<li>使用<code>i = (n - 1) &amp; hash</code>计算出待插入键值的下标，如果该下标上的bucket为<code>null</code>，则直接调用实现<code>CAS</code>原子性操作的<code>casTabAt()</code>方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。</li>\n<li>如果该下标上的节点(头节点)的哈希地址为MOVED(-1)，说明当前f是ForwardingNode节点，意味有其它线程正在扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li>\n<li>如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时<strong>使用synchroized锁住这个bucket</strong>，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket</li>\n<li>进入到bucket里面，首先判断这个bucket存储的是红黑树还是链表。</li>\n<li>如果是<strong>链表</strong>，则遍历链表看看是否有hash和equals相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点<strong>插入到链表尾部</strong>。如果是<strong>红黑树</strong>，则将节点插入。到这里<strong>解锁</strong>。</li>\n<li>最后判断该bucket上的链表长度是否大于**链表转红黑树的阈值(8)**，大于则将链表转成红黑树。</li>\n<li>调用<code>addCount()</code>方法，将键值对数量+1，并检查是否需要扩容。</li>\n</ul>\n<h3 id=\"get-1\"><a href=\"#get-1\" class=\"headerlink\" title=\"get\"></a>get</h3><pre><code class=\"java\">public V get(Object key) {\n    int h = spread(key.hashCode());\n    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;\n            (e = tabAt(tab, (n - 1) &amp; h)) != null) {\n        if ((eh = e.hash) == h) { // 头节点寻找\n            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))\n                return e.val;\n        }\n        else if (eh &lt; 0) \n            // 红黑树中寻找\n        while ((e = e.next) != null) { \n            // 链表中寻找\n        }\n    }\n    return null;\n}</code></pre>\n<ol>\n<li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址。</li>\n<li>如果table不为空，对应key所在bucket不为空：<code>tabAt(tab, (n - 1) &amp; h))</code>，则到bucket中查找。</li>\n<li>如果头节点hash、equals相同，则返回头节点值</li>\n<li>如果bucket的头节点的hash小于0，则代表这个bucket存储的是红黑树，则在红黑树中查找。</li>\n<li>如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，找到则返回该键key的值，找不到则返回null。</li>\n</ol>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h3><ol>\n<li>调用<code>spread()</code>方法计算出键key的哈希地址。</li>\n<li>计算出键key所在的数组下标，如果table为空或者bucket为空，则返回<code>null</code>。</li>\n<li>判断当前table是否正在扩容，如果在扩容则调用helpTransfer方法协助扩容。</li>\n<li>如果table和bucket都不为空，table也不处于在扩容状态，则<strong>锁住当前bucket</strong>，对bucket进行操作。</li>\n<li>根据bucket的头结点判断bucket是链表还是红黑树。</li>\n<li>在链表或者红黑树中移除哈希地址、键key相同的节点。</li>\n<li>调用<code>addCount</code>方法，将当前table存储的键值对数量-1。</li>\n</ol>\n<h3 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><pre><code class=\"java\">public ConcurrentHashMap(int initialCapacity) {\n    int cap = tableSizeFor(initialCapacity);\n    this.sizeCtl = cap;\n}\n\n// 第一次put时才调用\nprivate final Node&lt;K,V&gt;[] initTable() {\n    Node&lt;K,V&gt;[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        if ((sc = sizeCtl) &lt; 0)\n            Thread.yield(); \n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            if ((tab = table) == null || tab.length == 0) {\n                table = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];\n                sizeCtl = n - (n &gt;&gt;&gt; 2);\n            }\n            break;\n        }\n    }\n    return tab;\n}</code></pre>\n<ul>\n<li>table的初始化只能由一个线程完成，但是每个线程都可以争抢去初始化table。</li>\n<li>首先，判断table是否为null，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。</li>\n<li>如果table为null，进入到while循环，如果<code>sizeCtl</code>小于0(其他线程正在对table初始化)，那么该线程调用<code>Thread.yield()</code>挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为<code>null</code>，则继续while循环。</li>\n<li>如果table为null且<code>sizeCtl</code>不小于0，则调用实现<code>CAS</code>原子性操作的<code>compareAndSwap()</code>方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的。并设置sizeCtl的值为数组长度的3/4（<code>threshold</code>的作用），当ConcurrentHashMap储存的键值对数量大于这个阈值，就会发生扩容。</li>\n</ul>\n<h3 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h3><p><strong>触发扩容</strong></p>\n<ol>\n<li><p>添加新元素后，元素个数达到扩容阈值触发扩容。</p>\n</li>\n<li><p>调用 putAll 方法，发现容量不足以容纳所有元素时候触发扩容。</p>\n</li>\n<li><p>某个槽内的链表长度达到 8，但是数组长度小于 64 时候触发扩容。</p>\n</li>\n</ol>\n<p><strong>扩容操作</strong></p>\n<ul>\n<li>构建一个nextTable，大小为table的两倍。这个过程只能只有单个线程进行nextTable的初始化（通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable）</li>\n<li>将原来table里面的内容复制到nextTable中，这个步骤是允许<strong>多线程</strong>操作的，所以性能得到提升，减少了扩容的时间消耗。</li>\n</ul>\n<p><strong>扩容时其他操作</strong></p>\n<p>扩容状态下其他线程对集合进行插入、修改、删除等操作时遇到 ForwardingNode 节点会调用helpTransfer方法帮助扩容</p>\n<h2 id=\"扩展-1\"><a href=\"#扩展-1\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><h3 id=\"JDK1-7的ConcurrentHashMap\"><a href=\"#JDK1-7的ConcurrentHashMap\" class=\"headerlink\" title=\"JDK1.7的ConcurrentHashMap\"></a>JDK1.7的ConcurrentHashMap</h3><ul>\n<li>基本思想是将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</li>\n<li>Segment 是一个ReentrantLock，每一个Segment元素存储的是HashEntry数组+链表，每一个Segment其实就相当于一个HashMap</li>\n<li>put操作需要加锁，get操作不用加锁（通过使用volatile和巧妙的操作保证同步）</li>\n<li>ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20216212.png\" alt=\"20216212\"></p>\n<pre><code class=\"java\">final Segment&lt;K,V&gt;[] segments;\n\nstatic final class Segment&lt;K,V&gt; extends ReentrantLock {\n    volatile HashEntry&lt;K,V&gt;[] table;\n    int count;\n    int modCount;\n    int threshold;\n    float loadFactor;\n}\nstatic final class HashEntry&lt;K,V&gt; { \n    final K key; \n    final int hash; \n    volatile V value; \n    final HashEntry&lt;K,V&gt; next; \n}</code></pre>\n<h3 id=\"ConcurrentHashMap不允许key或value为null值\"><a href=\"#ConcurrentHashMap不允许key或value为null值\" class=\"headerlink\" title=\"ConcurrentHashMap不允许key或value为null值\"></a>ConcurrentHashMap不允许key或value为null值</h3><p>put操作中有相应的判断：</p>\n<pre><code class=\"java\">if (key == null || value == null) throw new NullPointerException();</code></pre>\n<p>但这样设计的原因是避免二义性：假定ConcurrentHashMap也可以存放value为null的值。那调用map.get(key)时如果返回了null，有两重含义:</p>\n<p><strong>1.这个key从来没有在map中映射过。</strong></p>\n<p><strong>2.这个key的value在设置的时候，就是null。</strong></p>\n<p>对于HashMap来说，它的正确使用场景是在单线程下使用。所以在单线程中，当我们得到的value是null的时候，可以用hashMap.containsKey(key)方法来区分上面说的两重含义。</p>\n<p>而ConcurrentHashMap的使用场景为多线程。假设concurrentHashMap允许存放值为null的value。这时有A、B两个线程。线程A调用concurrentHashMap.get(key)方法，返回为null，我们还是不知道这个null是没有映射的null还是存的值就是null。</p>\n<p>假设此时返回null的真实情况是因为这个key没有在map里面映射过。用concurrentHashMap.containsKey(key)来验证假设是否成立，期望的结果是返回false。</p>\n<p>但是在我们调用concurrentHashMap.get(key)方法之后，containsKey方法之前，有一个线程B执行了concurrentHashMap.put(key,null)的操作。那么我们调用containsKey方法返回的就是true了。这就与我们的假设的真实情况不符合了。    </p>\n<h1 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h1><h2 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h2><ul>\n<li>不保证集合顺序</li>\n<li>允许null值</li>\n<li>HashSet 不允许重复的值</li>\n</ul>\n<pre><code class=\"java\">//底层使用HashMap来保存HashSet中所有元素\nprivate transient HashMap&lt;E，Object&gt; map;\n\n//定义一个虚拟的Object对象作为HashMap的value\nprivate static final Object PRESENT = new Object();\n\npublic boolean add(E e) {\n\n    //因为put会返回原Value，如果放入相同的，则返回就不为null\n\n    //则该方法返回false，代表添加不成功，代表已经有了元素\n    //HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT\n    return map.put(e， PRESENT)==null;\n\n}</code></pre>\n<h2 id=\"LinkedHashSet\"><a href=\"#LinkedHashSet\" class=\"headerlink\" title=\"LinkedHashSet\"></a>LinkedHashSet</h2><ul>\n<li>LinkedHashSet 内部是通过 LinkedHashMap 来实现的。</li>\n<li>继承HashSet</li>\n<li>LinkedHashSet的构造器调用父类HashSet的其中一个构造器，将map初始化为LinkedHashMap，所以再调用方法时，就会有LinkedHashMap的调用效果</li>\n<li>用双向链表维持元素的插入顺序</li>\n<li>重新插入时不会影响顺序</li>\n</ul>\n"},{"title":"List集合","author":"tongji4m3","top":false,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"List集合相关，包括ArrayList、LinkedList、CopyOnWriteArrayList等","abbrlink":"cf90fc03","date":"2020-12-14T16:00:00.000Z","_content":"\n# ArrayList\n\n## 概述\n\n+ 底层实现是数组Object[] elementData\n+ 查询效率高，增删效率低，线程不安全。使用频率很高\n+ 正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果你需要线程安全就使用Vector\n+ 遍历快，由于内存的连续性，CPU内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销\n+ 不适合做队列，因为尾部插入，首部删除，会涉及数组的数据搬迁，耗费性能。可以采用定长的环形数组实现队列\n+ 可以做堆栈，因为push/pop不涉及数据移动操作\n+ 将`ArrayList`作为默认首选,只有因为经常从表中间插入删除而导致性能下降时,才选择`LinkedList`\n\n\n\n```\n可扩容数组\n允许null值\nadd()的均摊开销是常数级别\n在分配大量元素前,使用ensureCapacity减少重新分配的次数\nList list = Collections.synchronizedList(new ArrayList(...))\nfail-fast\n```\n\nadd均摊花费为O(1)\n\n接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方法，正是利用了这一点，\n让AbstractList是实现接口中一些通用的方法，而具体的类，如ArrayList就继承这个AbstractList类，\n拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更简洁，就继承结构最底层的类中通用的方法都抽取出来\n\nRandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。\n如果是实现了这个接口的 List，那么使用for循环的方式获取数据会优于用迭代器获取数据。\n\n\n\n //元素第一次被添加时,扩展到DEFAULT_CAPACITY\n    //底层依然是用Object类型的数组,只有在需要取出的时候,才转型为T\n    transient Object[] elementData; // non-private to simplify nested class access\n\n### 性质\n\n+ 可扩容数组\n+ 允许null值\n+ add()的均摊开销是常数级别，均摊花费为O(1)\n+ 在分配大量元素前,使用ensureCapacity减少重新分配的次数\n\n## 常用方法\n\n### 扩容\n\n+ ArrayList可以通过构造⽅法在初始化的时候指定底层数组的⼤⼩\n+ 通过⽆参构造⽅法的⽅式ArrayList()初始化，则赋值底层数Object[] elementData为⼀个默认空数组Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}所以数组容量为0，只有真正对数据进⾏添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。\n+ 他会重新定义⼀个⻓度为10+10/2的数组也就是新增⼀个⻓度为15的数组\n+ 然后把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数的地址换到新数组，\n+ 在使⽤ArrayList的时候⼀般不会设置初始值的⼤⼩，那ArrayList默认的⼤⼩就刚好是10。\n\n### add\n\n他有指定index新增，也有直接新增的，在这之前他会有⼀步校验⻓度的判断\n\nensureCapacityInternal，就是说如果⻓度不够，是需要扩容的。\n\n```java\n /*\n    如果new ArrayList(),就马上调用add\n    则会接着调用ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    此时elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n    calculateCapacity(elementData, minCapacity)则会return Math.max(DEFAULT_CAPACITY, minCapacity);  即10\n    接下来调用grow(int minCapacity)\n    创建elementData数组,容量为max(minCapacity,oldCapacity + (oldCapacity >> 1))\n    即max(10,1)\n    所以创建了容量为1的数组\n\n    不管怎么样,调用了add,都会使得modCount++;\n     */\n    //如果是new ArrayList(),那么第一次add(),ensureCapacityInternal方法里面就会自动初始化容量为10\n    public boolean add(E e) {\n        //扩容至少要求size+1\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //如果不够,则要扩容 modCount也会增加\n        elementData[size++] = e;\n        return true;\n    }\n\n    /*\n    检查index是否合法\n    检查是否需要扩容\n    将index开始的元素往后移一位\n    将index处赋值\n    ++size\n     */\n    public void add(int index, E element) {\n        //必须 [0,size]\n        rangeCheckForAdd(index);//查看是否越界\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //源数组,源数组中起始copy的position,目标数组,目标数组的位置,复制的长度\n        System.arraycopy(elementData, index, elementData, index + 1,\n                size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n\n\n\n### remove\n\n```java\n//把目标之后的数组元素复制到删除那块\npublic E remove(int index) {\n    rangeCheck(index);\n\n    modCount++;\n    E oldValue = elementData(index);\n\n    int numMoved = size - index - 1;\n    //要移除的不是最后一个元素,则把后面的往前面拷贝\n    if (numMoved > 0)\n        System.arraycopy(elementData, index + 1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n\n    return oldValue;\n}\n```\n\n### toArray()\n\n```java\n    //某种程度上是安全的,因为创建了一个新的数组\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * 如果a的length不够大,就新建一个同样类型的数组\n     * a.length够大,则把值赋值到a中,并且把多余的部分赋值为null,然后返回传入的那个a(末尾没用到的元素为null)\n     * 只能说数组是不重复的,但是把toArray里面元素内容改变了,arrayList的也变化,他们里面存储的是相同的引用\n     * 除非是把toArray里面的元素引用换掉,就没问题\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a's runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n```\n\n## 扩展\n\n### Vector和ArrayList的区别\n\n- Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。**只要是关键性的操作，方法前面都加了synchronized关键字，来保证线程的安全性**。\n\n- 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。\n\n- ```java\n    //ArrayList\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    ```\n\n    \n\n### ArrayList和Linkedlist的区别\n\n**优缺点**\n\n- ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合。\n- 对于随机index访问的get和set方法，一般ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。LinkedList集合不支持高效的随机访问（RandomAccess）\n- 新增和删除元素，一般LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，要移动数据来填补被删除的对象的空间，甚至可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。\n- ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。\n\n**适用场景**\n\n+ 如果应用程序对数据有较多的随机访问，ArrayList对象要优于LinkedList对象；\n+ 如果应用程序有更多的插入或者删除操作，较少的随机访问，LinkedList对象要优于ArrayList对象；\n+ 不过ArrayList的插入，删除操作也不一定比LinkedList慢，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快。\n+ LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向队列 ，栈\n\n+ \n\n# LinkedList\n\n+ 双向循环链表，有first、last指针\n+ 允许null值\n+ 如果找索引，则先判断从头找快还是从尾找快\n+ 存储元素的节点需要额外的空间存储前驱和后继的引用\n\n+ 实现接口Deque(double ended queue)、Deque 又继承自 Queue 接口。所以LinkedList实现队列、栈行为\n\n## 源码\n\n```java\n/**\n * 对首部的操作:\n * getFirst()\n * removeFirst()\n * addFirst(E e)\n * peek()//获取首部元素\n * peekFirst()\n * element()\n * poll() //获取并删除首部元素\n * pollFirst()\n * remove()\n * offerFirst(E e)\n * push(E e)//调用addFirst(e);\n * pop() //调用removeFirst();\n *\n * 对尾部的操作:\n * getLast()\n * removeLast()\n * addLast(E e)\n * add(E e) //调用linkLast(e);\n * offer(E e)//调用add(e);\n * addAll(Collection<? extends E> c)  //return addAll(size， c); 在尾部添加\n * offerLast(E e)\n * peekLast()\n * pollLast()\n *\n * 索引操作\n * addAll(int index， Collection<? extends E> c)\n * add(int index， E element)\n *\n *\n *      都是往index对应的node节点前面进行添加，而如果index==size，就会往最后添加\n *     假设开始有0，1，2   size=3\n *     addAll(3，Arrays.asList(5， 6， 7))，则变成 0，1，2，5，6，7\n *     addAll(1，Arrays.asList(5， 6， 7))，则变成 0，5，6，7，1，2\n *     即0，1，2 在1处插入，则pred=node(0)，succ=node(1)，会在pred与succ直接构建那几个链表节点\n *\n */\n\n/**\n * 双向链表\n * 允许null值\n * 如果找索引，则先判断从头找快还是从尾找快\n * List list = Collections.synchronizedList(new LinkedList(...));\n * fail-fast的迭代器，抛出 ConcurrentModificationException\n */\n/*\n\nAbstractSequentialList 只支持按次序访问，提供了一套基于顺序访问的接口。\n通过继承此类，子类仅需实现部分代码即可拥有完整的一套访问某种序列表（比如链表）的接口\n需要实现的方法：\npublic abstract ListIterator<E> listIterator(int index);\n对于随机访问集合类一般建议继承 AbstractList 而不是 AbstractSequentialList。\n\n实现了 Deque (double ended queue)，Deque 又继承自 Queue 接口。这样 LinkedList 就具备了队列的功能。\n\n实现栈等\n\nLinkedList 存储元素的节点需要额外的空间存储前驱和后继的引用\nLinkedList 在链表头部和尾部插入效率比较高，但在指定位置进行插入时，效率一般。\nLinkedList 是非线程安全的集合类，并发环境下，多个线程同时操作 LinkedList，会引发不可预知的错误。\n */\n\n    //在链表首部加一个元素\n    //基本实现都是比较套路的，最好记下来，自己写时也比较好实现:\n    /*\n    用一个引用f指向(old)first\n    新增一个节点，并且指向f(此时就算f为null也无所谓，只是指向了个null而已)\n    更新first到新的引用上\n    此时要判断f(oldFirst)是否为null，为null说明插入的是第一个元素，直接让last=first(new)，不为null则更新引用\n     */\n    private void linkFirst(E e) {\n        final Node<E> f = first;\n        final Node<E> newNode = new Node<>(null， e， f);\n        first = newNode;\n        if (f == null)\n            last = newNode;\n        else\n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n\n    \n    \n    //删除根据对象是否为null来进行删除操作\n    //调用equals来进行对比\n    //只会删除遇到的第一个元素\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n   \n    //根据索引找节点，而且根据index与size/2的大小决定从哪里开始找\n    //也是从0开始的\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n\n    //从头开始找该对象，而且索引从0开始，找不到则返回-1\n    public int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n\n    \n    //从尾部开始找链表的索引，last处索引为size-1\n    public int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }\n```\n\n# \tCopyOnWriteArrayList\n\n+ 写时复制容器，往一个容器中添加元素的时候，不直接往当前容器的Object[]添加，而是将当前容器Object[]进行拷贝，复制出一个新的`Object[] newElements`，然后往新的`newElements`中添加元素` setArray(newElements)`\n+ 可以对`CopyOnWrite`容器进行并发的读而不需要加锁，因为当前容器不会添加任何元素\n+ 是一种读写分离的思想，读和写不同的元素，适用于读多写少\n+ 最后再将原容器的引用指向新的容器\n\n## 简介\n\n+ 用来代替Vector、Collections.synchronizedList()的，因为他们两个锁粒度太大，线程并发度不高\n+ 适用于读操作要尽可能快，而写操作慢一些也没关系。即读多写少的情况\n+ 读写规则：读取是完全不用加锁的，写入也不会阻塞读取操作。只有写写之间需要同步等待\n+ 可以在迭代过程中进行修改（调用集合的remove方法，而不是迭代器的remove）\n+ 写时复制，读写分离。读和写在不同的容器。\n+ 如果使用了迭代器，而又突然进行写操作，不会报错，因为迭代器使用的是原来的，迭代的数据可能是过期的。\n\n**缺点**\n\n+ 数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。如果希望写入的数据实时读取到，则不要使用\n+ 内存占用问题：因为写时复制操作，在进行写操作时，内存会同时驻扎两个对象的内存\n\n## 常用方法\n\n### add()\n\n```java\npublic boolean add(E e) {\n    // 读操作会上锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        // 复制出一个新的数组\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e; // 加到新数组\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n\nfinal void setArray(Object[] a) {\n    array = a;\n}\n```\n\n### get()\n\n整个过程没有任何加锁的操作\n\n```java\nprivate E get(Object[] a, int index) {\n\treturn (E) a[index];\n}\n```\n\n","source":"_posts/Java语言/Java集合/2.List集合.md","raw":"---\ntitle: List集合\nauthor: tongji4m3\ntop: false\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: List集合相关，包括ArrayList、LinkedList、CopyOnWriteArrayList等\ncategories: Java集合\ntags:\n  - ArrayList\n  - LinkedList\n  - CopyOnWriteArrayList\nabbrlink: cf90fc03\ndate: 2020-12-15 00:00:00\n---\n\n# ArrayList\n\n## 概述\n\n+ 底层实现是数组Object[] elementData\n+ 查询效率高，增删效率低，线程不安全。使用频率很高\n+ 正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果你需要线程安全就使用Vector\n+ 遍历快，由于内存的连续性，CPU内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销\n+ 不适合做队列，因为尾部插入，首部删除，会涉及数组的数据搬迁，耗费性能。可以采用定长的环形数组实现队列\n+ 可以做堆栈，因为push/pop不涉及数据移动操作\n+ 将`ArrayList`作为默认首选,只有因为经常从表中间插入删除而导致性能下降时,才选择`LinkedList`\n\n\n\n```\n可扩容数组\n允许null值\nadd()的均摊开销是常数级别\n在分配大量元素前,使用ensureCapacity减少重新分配的次数\nList list = Collections.synchronizedList(new ArrayList(...))\nfail-fast\n```\n\nadd均摊花费为O(1)\n\n接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方法，正是利用了这一点，\n让AbstractList是实现接口中一些通用的方法，而具体的类，如ArrayList就继承这个AbstractList类，\n拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更简洁，就继承结构最底层的类中通用的方法都抽取出来\n\nRandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。\n如果是实现了这个接口的 List，那么使用for循环的方式获取数据会优于用迭代器获取数据。\n\n\n\n //元素第一次被添加时,扩展到DEFAULT_CAPACITY\n    //底层依然是用Object类型的数组,只有在需要取出的时候,才转型为T\n    transient Object[] elementData; // non-private to simplify nested class access\n\n### 性质\n\n+ 可扩容数组\n+ 允许null值\n+ add()的均摊开销是常数级别，均摊花费为O(1)\n+ 在分配大量元素前,使用ensureCapacity减少重新分配的次数\n\n## 常用方法\n\n### 扩容\n\n+ ArrayList可以通过构造⽅法在初始化的时候指定底层数组的⼤⼩\n+ 通过⽆参构造⽅法的⽅式ArrayList()初始化，则赋值底层数Object[] elementData为⼀个默认空数组Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}所以数组容量为0，只有真正对数据进⾏添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。\n+ 他会重新定义⼀个⻓度为10+10/2的数组也就是新增⼀个⻓度为15的数组\n+ 然后把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数的地址换到新数组，\n+ 在使⽤ArrayList的时候⼀般不会设置初始值的⼤⼩，那ArrayList默认的⼤⼩就刚好是10。\n\n### add\n\n他有指定index新增，也有直接新增的，在这之前他会有⼀步校验⻓度的判断\n\nensureCapacityInternal，就是说如果⻓度不够，是需要扩容的。\n\n```java\n /*\n    如果new ArrayList(),就马上调用add\n    则会接着调用ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    此时elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n    calculateCapacity(elementData, minCapacity)则会return Math.max(DEFAULT_CAPACITY, minCapacity);  即10\n    接下来调用grow(int minCapacity)\n    创建elementData数组,容量为max(minCapacity,oldCapacity + (oldCapacity >> 1))\n    即max(10,1)\n    所以创建了容量为1的数组\n\n    不管怎么样,调用了add,都会使得modCount++;\n     */\n    //如果是new ArrayList(),那么第一次add(),ensureCapacityInternal方法里面就会自动初始化容量为10\n    public boolean add(E e) {\n        //扩容至少要求size+1\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //如果不够,则要扩容 modCount也会增加\n        elementData[size++] = e;\n        return true;\n    }\n\n    /*\n    检查index是否合法\n    检查是否需要扩容\n    将index开始的元素往后移一位\n    将index处赋值\n    ++size\n     */\n    public void add(int index, E element) {\n        //必须 [0,size]\n        rangeCheckForAdd(index);//查看是否越界\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //源数组,源数组中起始copy的position,目标数组,目标数组的位置,复制的长度\n        System.arraycopy(elementData, index, elementData, index + 1,\n                size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n\n\n\n### remove\n\n```java\n//把目标之后的数组元素复制到删除那块\npublic E remove(int index) {\n    rangeCheck(index);\n\n    modCount++;\n    E oldValue = elementData(index);\n\n    int numMoved = size - index - 1;\n    //要移除的不是最后一个元素,则把后面的往前面拷贝\n    if (numMoved > 0)\n        System.arraycopy(elementData, index + 1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n\n    return oldValue;\n}\n```\n\n### toArray()\n\n```java\n    //某种程度上是安全的,因为创建了一个新的数组\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * 如果a的length不够大,就新建一个同样类型的数组\n     * a.length够大,则把值赋值到a中,并且把多余的部分赋值为null,然后返回传入的那个a(末尾没用到的元素为null)\n     * 只能说数组是不重复的,但是把toArray里面元素内容改变了,arrayList的也变化,他们里面存储的是相同的引用\n     * 除非是把toArray里面的元素引用换掉,就没问题\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a's runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n```\n\n## 扩展\n\n### Vector和ArrayList的区别\n\n- Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。**只要是关键性的操作，方法前面都加了synchronized关键字，来保证线程的安全性**。\n\n- 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。\n\n- ```java\n    //ArrayList\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    ```\n\n    \n\n### ArrayList和Linkedlist的区别\n\n**优缺点**\n\n- ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合。\n- 对于随机index访问的get和set方法，一般ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。LinkedList集合不支持高效的随机访问（RandomAccess）\n- 新增和删除元素，一般LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，要移动数据来填补被删除的对象的空间，甚至可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。\n- ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。\n\n**适用场景**\n\n+ 如果应用程序对数据有较多的随机访问，ArrayList对象要优于LinkedList对象；\n+ 如果应用程序有更多的插入或者删除操作，较少的随机访问，LinkedList对象要优于ArrayList对象；\n+ 不过ArrayList的插入，删除操作也不一定比LinkedList慢，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快。\n+ LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向队列 ，栈\n\n+ \n\n# LinkedList\n\n+ 双向循环链表，有first、last指针\n+ 允许null值\n+ 如果找索引，则先判断从头找快还是从尾找快\n+ 存储元素的节点需要额外的空间存储前驱和后继的引用\n\n+ 实现接口Deque(double ended queue)、Deque 又继承自 Queue 接口。所以LinkedList实现队列、栈行为\n\n## 源码\n\n```java\n/**\n * 对首部的操作:\n * getFirst()\n * removeFirst()\n * addFirst(E e)\n * peek()//获取首部元素\n * peekFirst()\n * element()\n * poll() //获取并删除首部元素\n * pollFirst()\n * remove()\n * offerFirst(E e)\n * push(E e)//调用addFirst(e);\n * pop() //调用removeFirst();\n *\n * 对尾部的操作:\n * getLast()\n * removeLast()\n * addLast(E e)\n * add(E e) //调用linkLast(e);\n * offer(E e)//调用add(e);\n * addAll(Collection<? extends E> c)  //return addAll(size， c); 在尾部添加\n * offerLast(E e)\n * peekLast()\n * pollLast()\n *\n * 索引操作\n * addAll(int index， Collection<? extends E> c)\n * add(int index， E element)\n *\n *\n *      都是往index对应的node节点前面进行添加，而如果index==size，就会往最后添加\n *     假设开始有0，1，2   size=3\n *     addAll(3，Arrays.asList(5， 6， 7))，则变成 0，1，2，5，6，7\n *     addAll(1，Arrays.asList(5， 6， 7))，则变成 0，5，6，7，1，2\n *     即0，1，2 在1处插入，则pred=node(0)，succ=node(1)，会在pred与succ直接构建那几个链表节点\n *\n */\n\n/**\n * 双向链表\n * 允许null值\n * 如果找索引，则先判断从头找快还是从尾找快\n * List list = Collections.synchronizedList(new LinkedList(...));\n * fail-fast的迭代器，抛出 ConcurrentModificationException\n */\n/*\n\nAbstractSequentialList 只支持按次序访问，提供了一套基于顺序访问的接口。\n通过继承此类，子类仅需实现部分代码即可拥有完整的一套访问某种序列表（比如链表）的接口\n需要实现的方法：\npublic abstract ListIterator<E> listIterator(int index);\n对于随机访问集合类一般建议继承 AbstractList 而不是 AbstractSequentialList。\n\n实现了 Deque (double ended queue)，Deque 又继承自 Queue 接口。这样 LinkedList 就具备了队列的功能。\n\n实现栈等\n\nLinkedList 存储元素的节点需要额外的空间存储前驱和后继的引用\nLinkedList 在链表头部和尾部插入效率比较高，但在指定位置进行插入时，效率一般。\nLinkedList 是非线程安全的集合类，并发环境下，多个线程同时操作 LinkedList，会引发不可预知的错误。\n */\n\n    //在链表首部加一个元素\n    //基本实现都是比较套路的，最好记下来，自己写时也比较好实现:\n    /*\n    用一个引用f指向(old)first\n    新增一个节点，并且指向f(此时就算f为null也无所谓，只是指向了个null而已)\n    更新first到新的引用上\n    此时要判断f(oldFirst)是否为null，为null说明插入的是第一个元素，直接让last=first(new)，不为null则更新引用\n     */\n    private void linkFirst(E e) {\n        final Node<E> f = first;\n        final Node<E> newNode = new Node<>(null， e， f);\n        first = newNode;\n        if (f == null)\n            last = newNode;\n        else\n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n\n    \n    \n    //删除根据对象是否为null来进行删除操作\n    //调用equals来进行对比\n    //只会删除遇到的第一个元素\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n   \n    //根据索引找节点，而且根据index与size/2的大小决定从哪里开始找\n    //也是从0开始的\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n\n    //从头开始找该对象，而且索引从0开始，找不到则返回-1\n    public int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n\n    \n    //从尾部开始找链表的索引，last处索引为size-1\n    public int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }\n```\n\n# \tCopyOnWriteArrayList\n\n+ 写时复制容器，往一个容器中添加元素的时候，不直接往当前容器的Object[]添加，而是将当前容器Object[]进行拷贝，复制出一个新的`Object[] newElements`，然后往新的`newElements`中添加元素` setArray(newElements)`\n+ 可以对`CopyOnWrite`容器进行并发的读而不需要加锁，因为当前容器不会添加任何元素\n+ 是一种读写分离的思想，读和写不同的元素，适用于读多写少\n+ 最后再将原容器的引用指向新的容器\n\n## 简介\n\n+ 用来代替Vector、Collections.synchronizedList()的，因为他们两个锁粒度太大，线程并发度不高\n+ 适用于读操作要尽可能快，而写操作慢一些也没关系。即读多写少的情况\n+ 读写规则：读取是完全不用加锁的，写入也不会阻塞读取操作。只有写写之间需要同步等待\n+ 可以在迭代过程中进行修改（调用集合的remove方法，而不是迭代器的remove）\n+ 写时复制，读写分离。读和写在不同的容器。\n+ 如果使用了迭代器，而又突然进行写操作，不会报错，因为迭代器使用的是原来的，迭代的数据可能是过期的。\n\n**缺点**\n\n+ 数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。如果希望写入的数据实时读取到，则不要使用\n+ 内存占用问题：因为写时复制操作，在进行写操作时，内存会同时驻扎两个对象的内存\n\n## 常用方法\n\n### add()\n\n```java\npublic boolean add(E e) {\n    // 读操作会上锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        // 复制出一个新的数组\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e; // 加到新数组\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n\nfinal void setArray(Object[] a) {\n    array = a;\n}\n```\n\n### get()\n\n整个过程没有任何加锁的操作\n\n```java\nprivate E get(Object[] a, int index) {\n\treturn (E) a[index];\n}\n```\n\n","slug":"Java语言/Java集合/2.List集合","published":1,"updated":"2021-06-08T03:35:00.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq511000pz0tp0ix385q4","content":"<h1 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li>底层实现是数组Object[] elementData</li>\n<li>查询效率高，增删效率低，线程不安全。使用频率很高</li>\n<li>正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果你需要线程安全就使用Vector</li>\n<li>遍历快，由于内存的连续性，CPU内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销</li>\n<li>不适合做队列，因为尾部插入，首部删除，会涉及数组的数据搬迁，耗费性能。可以采用定长的环形数组实现队列</li>\n<li>可以做堆栈，因为push/pop不涉及数据移动操作</li>\n<li>将<code>ArrayList</code>作为默认首选,只有因为经常从表中间插入删除而导致性能下降时,才选择<code>LinkedList</code></li>\n</ul>\n<pre><code>可扩容数组\n允许null值\nadd()的均摊开销是常数级别\n在分配大量元素前,使用ensureCapacity减少重新分配的次数\nList list = Collections.synchronizedList(new ArrayList(...))\nfail-fast</code></pre>\n<p>add均摊花费为O(1)</p>\n<p>接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方法，正是利用了这一点，<br>让AbstractList是实现接口中一些通用的方法，而具体的类，如ArrayList就继承这个AbstractList类，<br>拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更简洁，就继承结构最底层的类中通用的方法都抽取出来</p>\n<p>RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。<br>如果是实现了这个接口的 List，那么使用for循环的方式获取数据会优于用迭代器获取数据。</p>\n<p> //元素第一次被添加时,扩展到DEFAULT_CAPACITY<br>    //底层依然是用Object类型的数组,只有在需要取出的时候,才转型为T<br>    transient Object[] elementData; // non-private to simplify nested class access</p>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><ul>\n<li>可扩容数组</li>\n<li>允许null值</li>\n<li>add()的均摊开销是常数级别，均摊花费为O(1)</li>\n<li>在分配大量元素前,使用ensureCapacity减少重新分配的次数</li>\n</ul>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h3><ul>\n<li>ArrayList可以通过构造⽅法在初始化的时候指定底层数组的⼤⼩</li>\n<li>通过⽆参构造⽅法的⽅式ArrayList()初始化，则赋值底层数Object[] elementData为⼀个默认空数组Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}所以数组容量为0，只有真正对数据进⾏添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</li>\n<li>他会重新定义⼀个⻓度为10+10/2的数组也就是新增⼀个⻓度为15的数组</li>\n<li>然后把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数的地址换到新数组，</li>\n<li>在使⽤ArrayList的时候⼀般不会设置初始值的⼤⼩，那ArrayList默认的⼤⼩就刚好是10。</li>\n</ul>\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><p>他有指定index新增，也有直接新增的，在这之前他会有⼀步校验⻓度的判断</p>\n<p>ensureCapacityInternal，就是说如果⻓度不够，是需要扩容的。</p>\n<pre class=\" language-java\"><code class=\"language-java\"> <span class=\"token comment\" spellcheck=\"true\">/*\n    如果new ArrayList(),就马上调用add\n    则会接着调用ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    此时elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n    calculateCapacity(elementData, minCapacity)则会return Math.max(DEFAULT_CAPACITY, minCapacity);  即10\n    接下来调用grow(int minCapacity)\n    创建elementData数组,容量为max(minCapacity,oldCapacity + (oldCapacity >> 1))\n    即max(10,1)\n    所以创建了容量为1的数组\n\n    不管怎么样,调用了add,都会使得modCount++;\n     */</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果是new ArrayList(),那么第一次add(),ensureCapacityInternal方法里面就会自动初始化容量为10</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//扩容至少要求size+1</span>\n        <span class=\"token function\">ensureCapacityInternal</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// Increments modCount!!</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果不够,则要扩容 modCount也会增加</span>\n        elementData<span class=\"token punctuation\">[</span>size<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    检查index是否合法\n    检查是否需要扩容\n    将index开始的元素往后移一位\n    将index处赋值\n    ++size\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> E element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//必须 [0,size]</span>\n        <span class=\"token function\">rangeCheckForAdd</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//查看是否越界</span>\n\n        <span class=\"token function\">ensureCapacityInternal</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// Increments modCount!!</span>\n        <span class=\"token comment\" spellcheck=\"true\">//源数组,源数组中起始copy的position,目标数组,目标数组的位置,复制的长度</span>\n        System<span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> elementData<span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n                size <span class=\"token operator\">-</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        elementData<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> element<span class=\"token punctuation\">;</span>\n        size<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//把目标之后的数组元素复制到删除那块</span>\n<span class=\"token keyword\">public</span> E <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">rangeCheck</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    E oldValue <span class=\"token operator\">=</span> <span class=\"token function\">elementData</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> numMoved <span class=\"token operator\">=</span> size <span class=\"token operator\">-</span> index <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//要移除的不是最后一个元素,则把后面的往前面拷贝</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numMoved <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        System<span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> elementData<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span>\n                         numMoved<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    elementData<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>size<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// clear to let GC do its work</span>\n\n    <span class=\"token keyword\">return</span> oldValue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"toArray\"><a href=\"#toArray\" class=\"headerlink\" title=\"toArray()\"></a>toArray()</h3><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token comment\" spellcheck=\"true\">//某种程度上是安全的,因为创建了一个新的数组</span>\n    <span class=\"token keyword\">public</span> Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 如果a的length不够大,就新建一个同样类型的数组\n     * a.length够大,则把值赋值到a中,并且把多余的部分赋值为null,然后返回传入的那个a(末尾没用到的元素为null)\n     * 只能说数组是不重复的,但是把toArray里面元素内容改变了,arrayList的也变化,他们里面存储的是相同的引用\n     * 除非是把toArray里面的元素引用换掉,就没问题\n     */</span>\n    <span class=\"token annotation punctuation\">@SuppressWarnings</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unchecked\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> size<span class=\"token punctuation\">)</span>\n            <span class=\"token comment\" spellcheck=\"true\">// Make a new array of a's runtime type, but my contents:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> size<span class=\"token punctuation\">)</span>\n            a<span class=\"token punctuation\">[</span>size<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><h3 id=\"Vector和ArrayList的区别\"><a href=\"#Vector和ArrayList的区别\" class=\"headerlink\" title=\"Vector和ArrayList的区别\"></a>Vector和ArrayList的区别</h3><ul>\n<li><p>Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。<strong>只要是关键性的操作，方法前面都加了synchronized关键字，来保证线程的安全性</strong>。</p>\n</li>\n<li><p>当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。</p>\n</li>\n<li><pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token comment\" spellcheck=\"true\">//ArrayList</span>\n  <span class=\"token keyword\">int</span> newCapacity <span class=\"token operator\">=</span> oldCapacity <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>oldCapacity <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n<h3 id=\"ArrayList和Linkedlist的区别\"><a href=\"#ArrayList和Linkedlist的区别\" class=\"headerlink\" title=\"ArrayList和Linkedlist的区别\"></a>ArrayList和Linkedlist的区别</h3><p><strong>优缺点</strong></p>\n<ul>\n<li>ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合。</li>\n<li>对于随机index访问的get和set方法，一般ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。LinkedList集合不支持高效的随机访问（RandomAccess）</li>\n<li>新增和删除元素，一般LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，要移动数据来填补被删除的对象的空间，甚至可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。</li>\n<li>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li><p>如果应用程序对数据有较多的随机访问，ArrayList对象要优于LinkedList对象；</p>\n</li>\n<li><p>如果应用程序有更多的插入或者删除操作，较少的随机访问，LinkedList对象要优于ArrayList对象；</p>\n</li>\n<li><p>不过ArrayList的插入，删除操作也不一定比LinkedList慢，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快。</p>\n</li>\n<li><p>LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向队列 ，栈</p>\n</li>\n<li></li>\n</ul>\n<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h1><ul>\n<li><p>双向循环链表，有first、last指针</p>\n</li>\n<li><p>允许null值</p>\n</li>\n<li><p>如果找索引，则先判断从头找快还是从尾找快</p>\n</li>\n<li><p>存储元素的节点需要额外的空间存储前驱和后继的引用</p>\n</li>\n<li><p>实现接口Deque(double ended queue)、Deque 又继承自 Queue 接口。所以LinkedList实现队列、栈行为</p>\n</li>\n</ul>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * 对首部的操作:\n * getFirst()\n * removeFirst()\n * addFirst(E e)\n * peek()//获取首部元素\n * peekFirst()\n * element()\n * poll() //获取并删除首部元素\n * pollFirst()\n * remove()\n * offerFirst(E e)\n * push(E e)//调用addFirst(e);\n * pop() //调用removeFirst();\n *\n * 对尾部的操作:\n * getLast()\n * removeLast()\n * addLast(E e)\n * add(E e) //调用linkLast(e);\n * offer(E e)//调用add(e);\n * addAll(Collection&lt;? extends E> c)  //return addAll(size， c); 在尾部添加\n * offerLast(E e)\n * peekLast()\n * pollLast()\n *\n * 索引操作\n * addAll(int index， Collection&lt;? extends E> c)\n * add(int index， E element)\n *\n *\n *      都是往index对应的node节点前面进行添加，而如果index==size，就会往最后添加\n *     假设开始有0，1，2   size=3\n *     addAll(3，Arrays.asList(5， 6， 7))，则变成 0，1，2，5，6，7\n *     addAll(1，Arrays.asList(5， 6， 7))，则变成 0，5，6，7，1，2\n *     即0，1，2 在1处插入，则pred=node(0)，succ=node(1)，会在pred与succ直接构建那几个链表节点\n *\n */</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 双向链表\n * 允许null值\n * 如果找索引，则先判断从头找快还是从尾找快\n * List list = Collections.synchronizedList(new LinkedList(...));\n * fail-fast的迭代器，抛出 ConcurrentModificationException\n */</span>\n<span class=\"token comment\" spellcheck=\"true\">/*\n\nAbstractSequentialList 只支持按次序访问，提供了一套基于顺序访问的接口。\n通过继承此类，子类仅需实现部分代码即可拥有完整的一套访问某种序列表（比如链表）的接口\n需要实现的方法：\npublic abstract ListIterator&lt;E> listIterator(int index);\n对于随机访问集合类一般建议继承 AbstractList 而不是 AbstractSequentialList。\n\n实现了 Deque (double ended queue)，Deque 又继承自 Queue 接口。这样 LinkedList 就具备了队列的功能。\n\n实现栈等\n\nLinkedList 存储元素的节点需要额外的空间存储前驱和后继的引用\nLinkedList 在链表头部和尾部插入效率比较高，但在指定位置进行插入时，效率一般。\nLinkedList 是非线程安全的集合类，并发环境下，多个线程同时操作 LinkedList，会引发不可预知的错误。\n */</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//在链表首部加一个元素</span>\n    <span class=\"token comment\" spellcheck=\"true\">//基本实现都是比较套路的，最好记下来，自己写时也比较好实现:</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    用一个引用f指向(old)first\n    新增一个节点，并且指向f(此时就算f为null也无所谓，只是指向了个null而已)\n    更新first到新的引用上\n    此时要判断f(oldFirst)是否为null，为null说明插入的是第一个元素，直接让last=first(new)，不为null则更新引用\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">linkFirst</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> f <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> newNode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>null， e， f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        first <span class=\"token operator\">=</span> newNode<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>f <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            last <span class=\"token operator\">=</span> newNode<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            f<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> newNode<span class=\"token punctuation\">;</span>\n        size<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n\n    <span class=\"token comment\" spellcheck=\"true\">//删除根据对象是否为null来进行删除操作</span>\n    <span class=\"token comment\" spellcheck=\"true\">//调用equals来进行对比</span>\n    <span class=\"token comment\" spellcheck=\"true\">//只会删除遇到的第一个元素</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>Object o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> x <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span> x <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">;</span> x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>item <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">unlink</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> x <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span> x <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">;</span> x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">unlink</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token comment\" spellcheck=\"true\">//根据索引找节点，而且根据index与size/2的大小决定从哪里开始找</span>\n    <span class=\"token comment\" spellcheck=\"true\">//也是从0开始的</span>\n    Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> <span class=\"token function\">node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// assert isElementIndex(index);</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> x <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n                x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> x <span class=\"token operator\">=</span> last<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> size <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n                x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//从头开始找该对象，而且索引从0开始，找不到则返回-1</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>Object o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> x <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span> x <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">;</span> x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>item <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">return</span> index<span class=\"token punctuation\">;</span>\n                index<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> x <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span> x <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">;</span> x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">return</span> index<span class=\"token punctuation\">;</span>\n                index<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token comment\" spellcheck=\"true\">//从尾部开始找链表的索引，last处索引为size-1</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">lastIndexOf</span><span class=\"token punctuation\">(</span>Object o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> x <span class=\"token operator\">=</span> last<span class=\"token punctuation\">;</span> x <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">;</span> x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                index<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>item <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">return</span> index<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> x <span class=\"token operator\">=</span> last<span class=\"token punctuation\">;</span> x <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">;</span> x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                index<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">return</span> index<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h1><ul>\n<li>写时复制容器，往一个容器中添加元素的时候，不直接往当前容器的Object[]添加，而是将当前容器Object[]进行拷贝，复制出一个新的<code>Object[] newElements</code>，然后往新的<code>newElements</code>中添加元素<code> setArray(newElements)</code></li>\n<li>可以对<code>CopyOnWrite</code>容器进行并发的读而不需要加锁，因为当前容器不会添加任何元素</li>\n<li>是一种读写分离的思想，读和写不同的元素，适用于读多写少</li>\n<li>最后再将原容器的引用指向新的容器</li>\n</ul>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>用来代替Vector、Collections.synchronizedList()的，因为他们两个锁粒度太大，线程并发度不高</li>\n<li>适用于读操作要尽可能快，而写操作慢一些也没关系。即读多写少的情况</li>\n<li>读写规则：读取是完全不用加锁的，写入也不会阻塞读取操作。只有写写之间需要同步等待</li>\n<li>可以在迭代过程中进行修改（调用集合的remove方法，而不是迭代器的remove）</li>\n<li>写时复制，读写分离。读和写在不同的容器。</li>\n<li>如果使用了迭代器，而又突然进行写操作，不会报错，因为迭代器使用的是原来的，迭代的数据可能是过期的。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。如果希望写入的数据实时读取到，则不要使用</li>\n<li>内存占用问题：因为写时复制操作，在进行写操作时，内存会同时驻扎两个对象的内存</li>\n</ul>\n<h2 id=\"常用方法-1\"><a href=\"#常用方法-1\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"add-1\"><a href=\"#add-1\" class=\"headerlink\" title=\"add()\"></a>add()</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 读操作会上锁</span>\n    <span class=\"token keyword\">final</span> ReentrantLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> elements <span class=\"token operator\">=</span> <span class=\"token function\">getArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> elements<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 复制出一个新的数组</span>\n        Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newElements <span class=\"token operator\">=</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elements<span class=\"token punctuation\">,</span> len <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        newElements<span class=\"token punctuation\">[</span>len<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 加到新数组</span>\n        <span class=\"token function\">setArray</span><span class=\"token punctuation\">(</span>newElements<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setArray</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    array <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><p>整个过程没有任何加锁的操作</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> E <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>E<span class=\"token punctuation\">)</span> a<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li>底层实现是数组Object[] elementData</li>\n<li>查询效率高，增删效率低，线程不安全。使用频率很高</li>\n<li>正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果你需要线程安全就使用Vector</li>\n<li>遍历快，由于内存的连续性，CPU内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销</li>\n<li>不适合做队列，因为尾部插入，首部删除，会涉及数组的数据搬迁，耗费性能。可以采用定长的环形数组实现队列</li>\n<li>可以做堆栈，因为push/pop不涉及数据移动操作</li>\n<li>将<code>ArrayList</code>作为默认首选,只有因为经常从表中间插入删除而导致性能下降时,才选择<code>LinkedList</code></li>\n</ul>\n<pre><code>可扩容数组\n允许null值\nadd()的均摊开销是常数级别\n在分配大量元素前,使用ensureCapacity减少重新分配的次数\nList list = Collections.synchronizedList(new ArrayList(...))\nfail-fast</code></pre>\n<p>add均摊花费为O(1)</p>\n<p>接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方法，正是利用了这一点，<br>让AbstractList是实现接口中一些通用的方法，而具体的类，如ArrayList就继承这个AbstractList类，<br>拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更简洁，就继承结构最底层的类中通用的方法都抽取出来</p>\n<p>RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。<br>如果是实现了这个接口的 List，那么使用for循环的方式获取数据会优于用迭代器获取数据。</p>\n<p> //元素第一次被添加时,扩展到DEFAULT_CAPACITY<br>    //底层依然是用Object类型的数组,只有在需要取出的时候,才转型为T<br>    transient Object[] elementData; // non-private to simplify nested class access</p>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><ul>\n<li>可扩容数组</li>\n<li>允许null值</li>\n<li>add()的均摊开销是常数级别，均摊花费为O(1)</li>\n<li>在分配大量元素前,使用ensureCapacity减少重新分配的次数</li>\n</ul>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h3><ul>\n<li>ArrayList可以通过构造⽅法在初始化的时候指定底层数组的⼤⼩</li>\n<li>通过⽆参构造⽅法的⽅式ArrayList()初始化，则赋值底层数Object[] elementData为⼀个默认空数组Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}所以数组容量为0，只有真正对数据进⾏添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</li>\n<li>他会重新定义⼀个⻓度为10+10/2的数组也就是新增⼀个⻓度为15的数组</li>\n<li>然后把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数的地址换到新数组，</li>\n<li>在使⽤ArrayList的时候⼀般不会设置初始值的⼤⼩，那ArrayList默认的⼤⼩就刚好是10。</li>\n</ul>\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><p>他有指定index新增，也有直接新增的，在这之前他会有⼀步校验⻓度的判断</p>\n<p>ensureCapacityInternal，就是说如果⻓度不够，是需要扩容的。</p>\n<pre><code class=\"java\"> /*\n    如果new ArrayList(),就马上调用add\n    则会接着调用ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    此时elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n    calculateCapacity(elementData, minCapacity)则会return Math.max(DEFAULT_CAPACITY, minCapacity);  即10\n    接下来调用grow(int minCapacity)\n    创建elementData数组,容量为max(minCapacity,oldCapacity + (oldCapacity &gt;&gt; 1))\n    即max(10,1)\n    所以创建了容量为1的数组\n\n    不管怎么样,调用了add,都会使得modCount++;\n     */\n    //如果是new ArrayList(),那么第一次add(),ensureCapacityInternal方法里面就会自动初始化容量为10\n    public boolean add(E e) {\n        //扩容至少要求size+1\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //如果不够,则要扩容 modCount也会增加\n        elementData[size++] = e;\n        return true;\n    }\n\n    /*\n    检查index是否合法\n    检查是否需要扩容\n    将index开始的元素往后移一位\n    将index处赋值\n    ++size\n     */\n    public void add(int index, E element) {\n        //必须 [0,size]\n        rangeCheckForAdd(index);//查看是否越界\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //源数组,源数组中起始copy的position,目标数组,目标数组的位置,复制的长度\n        System.arraycopy(elementData, index, elementData, index + 1,\n                size - index);\n        elementData[index] = element;\n        size++;\n    }</code></pre>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h3><pre><code class=\"java\">//把目标之后的数组元素复制到删除那块\npublic E remove(int index) {\n    rangeCheck(index);\n\n    modCount++;\n    E oldValue = elementData(index);\n\n    int numMoved = size - index - 1;\n    //要移除的不是最后一个元素,则把后面的往前面拷贝\n    if (numMoved &gt; 0)\n        System.arraycopy(elementData, index + 1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n\n    return oldValue;\n}</code></pre>\n<h3 id=\"toArray\"><a href=\"#toArray\" class=\"headerlink\" title=\"toArray()\"></a>toArray()</h3><pre><code class=\"java\">    //某种程度上是安全的,因为创建了一个新的数组\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * 如果a的length不够大,就新建一个同样类型的数组\n     * a.length够大,则把值赋值到a中,并且把多余的部分赋值为null,然后返回传入的那个a(末尾没用到的元素为null)\n     * 只能说数组是不重复的,但是把toArray里面元素内容改变了,arrayList的也变化,他们里面存储的是相同的引用\n     * 除非是把toArray里面的元素引用换掉,就没问题\n     */\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public &lt;T&gt; T[] toArray(T[] a) {\n        if (a.length &lt; size)\n            // Make a new array of a&#39;s runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length &gt; size)\n            a[size] = null;\n        return a;\n    }</code></pre>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><h3 id=\"Vector和ArrayList的区别\"><a href=\"#Vector和ArrayList的区别\" class=\"headerlink\" title=\"Vector和ArrayList的区别\"></a>Vector和ArrayList的区别</h3><ul>\n<li><p>Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。<strong>只要是关键性的操作，方法前面都加了synchronized关键字，来保证线程的安全性</strong>。</p>\n</li>\n<li><p>当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。</p>\n</li>\n<li><pre><code class=\"java\">  //ArrayList\n  int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code></pre>\n</li>\n</ul>\n<h3 id=\"ArrayList和Linkedlist的区别\"><a href=\"#ArrayList和Linkedlist的区别\" class=\"headerlink\" title=\"ArrayList和Linkedlist的区别\"></a>ArrayList和Linkedlist的区别</h3><p><strong>优缺点</strong></p>\n<ul>\n<li>ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合。</li>\n<li>对于随机index访问的get和set方法，一般ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。LinkedList集合不支持高效的随机访问（RandomAccess）</li>\n<li>新增和删除元素，一般LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，要移动数据来填补被删除的对象的空间，甚至可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。</li>\n<li>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li><p>如果应用程序对数据有较多的随机访问，ArrayList对象要优于LinkedList对象；</p>\n</li>\n<li><p>如果应用程序有更多的插入或者删除操作，较少的随机访问，LinkedList对象要优于ArrayList对象；</p>\n</li>\n<li><p>不过ArrayList的插入，删除操作也不一定比LinkedList慢，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快。</p>\n</li>\n<li><p>LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向队列 ，栈</p>\n</li>\n<li></li>\n</ul>\n<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h1><ul>\n<li><p>双向循环链表，有first、last指针</p>\n</li>\n<li><p>允许null值</p>\n</li>\n<li><p>如果找索引，则先判断从头找快还是从尾找快</p>\n</li>\n<li><p>存储元素的节点需要额外的空间存储前驱和后继的引用</p>\n</li>\n<li><p>实现接口Deque(double ended queue)、Deque 又继承自 Queue 接口。所以LinkedList实现队列、栈行为</p>\n</li>\n</ul>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><pre><code class=\"java\">/**\n * 对首部的操作:\n * getFirst()\n * removeFirst()\n * addFirst(E e)\n * peek()//获取首部元素\n * peekFirst()\n * element()\n * poll() //获取并删除首部元素\n * pollFirst()\n * remove()\n * offerFirst(E e)\n * push(E e)//调用addFirst(e);\n * pop() //调用removeFirst();\n *\n * 对尾部的操作:\n * getLast()\n * removeLast()\n * addLast(E e)\n * add(E e) //调用linkLast(e);\n * offer(E e)//调用add(e);\n * addAll(Collection&lt;? extends E&gt; c)  //return addAll(size， c); 在尾部添加\n * offerLast(E e)\n * peekLast()\n * pollLast()\n *\n * 索引操作\n * addAll(int index， Collection&lt;? extends E&gt; c)\n * add(int index， E element)\n *\n *\n *      都是往index对应的node节点前面进行添加，而如果index==size，就会往最后添加\n *     假设开始有0，1，2   size=3\n *     addAll(3，Arrays.asList(5， 6， 7))，则变成 0，1，2，5，6，7\n *     addAll(1，Arrays.asList(5， 6， 7))，则变成 0，5，6，7，1，2\n *     即0，1，2 在1处插入，则pred=node(0)，succ=node(1)，会在pred与succ直接构建那几个链表节点\n *\n */\n\n/**\n * 双向链表\n * 允许null值\n * 如果找索引，则先判断从头找快还是从尾找快\n * List list = Collections.synchronizedList(new LinkedList(...));\n * fail-fast的迭代器，抛出 ConcurrentModificationException\n */\n/*\n\nAbstractSequentialList 只支持按次序访问，提供了一套基于顺序访问的接口。\n通过继承此类，子类仅需实现部分代码即可拥有完整的一套访问某种序列表（比如链表）的接口\n需要实现的方法：\npublic abstract ListIterator&lt;E&gt; listIterator(int index);\n对于随机访问集合类一般建议继承 AbstractList 而不是 AbstractSequentialList。\n\n实现了 Deque (double ended queue)，Deque 又继承自 Queue 接口。这样 LinkedList 就具备了队列的功能。\n\n实现栈等\n\nLinkedList 存储元素的节点需要额外的空间存储前驱和后继的引用\nLinkedList 在链表头部和尾部插入效率比较高，但在指定位置进行插入时，效率一般。\nLinkedList 是非线程安全的集合类，并发环境下，多个线程同时操作 LinkedList，会引发不可预知的错误。\n */\n\n    //在链表首部加一个元素\n    //基本实现都是比较套路的，最好记下来，自己写时也比较好实现:\n    /*\n    用一个引用f指向(old)first\n    新增一个节点，并且指向f(此时就算f为null也无所谓，只是指向了个null而已)\n    更新first到新的引用上\n    此时要判断f(oldFirst)是否为null，为null说明插入的是第一个元素，直接让last=first(new)，不为null则更新引用\n     */\n    private void linkFirst(E e) {\n        final Node&lt;E&gt; f = first;\n        final Node&lt;E&gt; newNode = new Node&lt;&gt;(null， e， f);\n        first = newNode;\n        if (f == null)\n            last = newNode;\n        else\n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n\n\n\n    //删除根据对象是否为null来进行删除操作\n    //调用equals来进行对比\n    //只会删除遇到的第一个元素\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n\n    //根据索引找节点，而且根据index与size/2的大小决定从哪里开始找\n    //也是从0开始的\n    Node&lt;E&gt; node(int index) {\n        // assert isElementIndex(index);\n\n        if (index &lt; (size &gt;&gt; 1)) {\n            Node&lt;E&gt; x = first;\n            for (int i = 0; i &lt; index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node&lt;E&gt; x = last;\n            for (int i = size - 1; i &gt; index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n\n    //从头开始找该对象，而且索引从0开始，找不到则返回-1\n    public int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n\n\n    //从尾部开始找链表的索引，last处索引为size-1\n    public int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            for (Node&lt;E&gt; x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            for (Node&lt;E&gt; x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }</code></pre>\n<h1 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h1><ul>\n<li>写时复制容器，往一个容器中添加元素的时候，不直接往当前容器的Object[]添加，而是将当前容器Object[]进行拷贝，复制出一个新的<code>Object[] newElements</code>，然后往新的<code>newElements</code>中添加元素<code> setArray(newElements)</code></li>\n<li>可以对<code>CopyOnWrite</code>容器进行并发的读而不需要加锁，因为当前容器不会添加任何元素</li>\n<li>是一种读写分离的思想，读和写不同的元素，适用于读多写少</li>\n<li>最后再将原容器的引用指向新的容器</li>\n</ul>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>用来代替Vector、Collections.synchronizedList()的，因为他们两个锁粒度太大，线程并发度不高</li>\n<li>适用于读操作要尽可能快，而写操作慢一些也没关系。即读多写少的情况</li>\n<li>读写规则：读取是完全不用加锁的，写入也不会阻塞读取操作。只有写写之间需要同步等待</li>\n<li>可以在迭代过程中进行修改（调用集合的remove方法，而不是迭代器的remove）</li>\n<li>写时复制，读写分离。读和写在不同的容器。</li>\n<li>如果使用了迭代器，而又突然进行写操作，不会报错，因为迭代器使用的是原来的，迭代的数据可能是过期的。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。如果希望写入的数据实时读取到，则不要使用</li>\n<li>内存占用问题：因为写时复制操作，在进行写操作时，内存会同时驻扎两个对象的内存</li>\n</ul>\n<h2 id=\"常用方法-1\"><a href=\"#常用方法-1\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"add-1\"><a href=\"#add-1\" class=\"headerlink\" title=\"add()\"></a>add()</h3><pre><code class=\"java\">public boolean add(E e) {\n    // 读操作会上锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        // 复制出一个新的数组\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e; // 加到新数组\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n\nfinal void setArray(Object[] a) {\n    array = a;\n}</code></pre>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><p>整个过程没有任何加锁的操作</p>\n<pre><code class=\"java\">private E get(Object[] a, int index) {\n    return (E) a[index];\n}</code></pre>\n"},{"title":"代理模式","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"包括静态代理、基于接口的动态代理、基于子类的动态代理等。","abbrlink":"7b510e10","date":"2021-01-13T16:00:00.000Z","_content":"\n\n\n# 代理模式\n\n是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问。\n\n代理模式通俗来讲就是我们生活中常见的中介。\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/8493217-06886049700e73f7.png)\n\nSubject\n 抽象主题角色：可以是抽象类，也可以是接口。抽象主题是一个普通的业务类型，无特殊要求。\n\nRealSubject\n 具体主题角色：也叫做**被委托角色**或**被代理角色**，是业务逻辑的具体执行者。\n\nProxy\n 代理主题角色：也叫做**委托类**或**代理类**。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后处理工作。\n\n\n\n当两个类需要通信时，引入第三方代理类，将两个类的关系解耦，让我们只了解代理类即可，而且代理的出现还可以让我们完成与另一个类之间的关系的统一管理。但是切记，代理类和委托类要实现相同的接口，因为代理真正调用的还是委托类的方法。\n\n**静态代理**\n 由程序员创建或特定工具自动生成源代码，再对其进行编译。**在程序运行之前，代理类.class文件就已经被创建**，代理类和委托类的关系在运行前就确定。\n\n**动态代理**\n 动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。\n\n\n\n# 静态代理\n\n接口\n\n```csharp\npublic interface Subject {\n    /**\n     * 接口方法\n     */\n    public void request();\n}\n```\n\n业务类\n\n```java\npublic class ConcreteSubject implements Subject {\n    /**\n     * 具体的业务逻辑实现\n     */\n    @Override\n    public void request() {\n        //业务处理逻辑\n    }\n}\n```\n\n代理类\n\n```csharp\npublic class Proxy implements Subject {\n\n    /**\n     * 要代理的实现类\n     */\n    private Subject subject = null;\n\n    /**\n     * 默认代理自己\n     */\n    public Proxy() {\n        this.subject = new Proxy();\n    }\n\n    public Proxy(Subject subject) {\n        this.subject = subject;\n    }\n\n    /**\n     * 构造函数，传递委托者\n     *\n     * @param objects 委托者\n     */\n    public Proxy(Object... objects) {\n    }\n\n    /**\n     * 实现接口方法\n     */\n    @Override\n    public void request() {\n        this.before();\n        this.subject.request();\n        this.after();\n    }\n\n    /**\n     * 预处理\n     */\n    private void before() {\n        //do something\n    }\n\n    /**\n     * 后处理\n     */\n    private void after() {\n        //do something\n    }\n}\n```\n\n使用\n\n```cpp\npublic class Client {\n    public static void main(String[] args) {\n        Subject subject = new ConcreteSubject();\n        Proxy proxy = new Proxy(subject);\n        proxy.request();\n    }\n}\n```\n\n业务类只需要关注业务逻辑本身，保证了业务类的重用性。\n\n代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。\n\n# 动态代理\n\n+ 动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。\n+ 字节码随用随创建，随用随加载\n+ 在不修改源码的基础上对方法增强\n+ 代理模式为另外一个对象提供一个替身或占位符以控制这个对象的访问\n+ 动态代理：在运行时动态地创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指定的类\n+ 当代理的方法被调用时，代理就会把这个调用转发给`InvocationHandler`\n+ 动态代理类是根据传入的接口，用**Proxy.newProxyInstance**动态创建的\n\n![image-20201128112905460](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201128112905460.png)\n\n## 基于接口的动态代理\n\n+ JDK提供的Proxy\n+ 被代理对象至少实现一个接口，最终返回的类型可以转型为这个接口\n+ Proxy.newProxyInstance()\n\n```java\n//用户将操作这个共同实现的接口\npublic interface Producer {\n    int sell(int money);\n}\n\n//被代理对象\npublic class ProducerImpl implements Producer {\n    @Override\n    public int sell(int money) {\n        System.out.println(\"ProducerImpl sell:\" + money);\n        return money;\n    }\n}\n\npublic class Main{\n\tpublic static void main(String[] args) {\n        /*\n        ClassLoader:用于加载代理对象的字节码，和被代理对象使用相同的类加载器\n        Class []:用于让代理对象和被代理对象有相同的接口\n        InvocationHandler:用于提供增强的方法\n        */\n        Producer proxyProducer = (Producer) Proxy.newProxyInstance(ProducerImpl.class.getClassLoader()， ProducerImpl.class.getInterfaces()，\n                new InvocationHandler() {\n                    /**\n                     * 执行被代理对象中的任何接口方法都会经过该方法\n                     * @param proxy 代理对象的引用\n                     * @param method 当前执行的方法\n                     * @param args 当前执行方法的参数\n                     * @return 和被代理对象方法有相同的返回值\n                     * @throws Throwable\n                     */\n                    @Override\n                    public Object invoke(Object proxy， Method method， Object[] args) throws Throwable {\n                        Object result = null;\n                        if (\"sell\".equals(method.getName())) {\n                            System.out.println(\"proxy\");\n                            result = (int) method.invoke(new ProducerImpl()， args) * 2;\n                        }\n                        return result;\n                    }\n                });\n        int sell = proxyProducer.sell(100);\n        System.out.println(\"proxyProducer sell:\" + sell);\n        /*\n        proxy\n        ProducerImpl sell:100\n        proxyProducer sell:200\n         */\n    }\n}\n```\n\n## 基于子类的动态代理\n\n+ 使用第三方cglib库(或者有spring依赖)\n+ 被代理类不能是最终类：最终返回的类型可以转型为被代理类\n\n```java\n/*\nClass:指定被代理对象的字节码\nCallback:用于提供增强的方法，一般使用new MethodInterceptor(){}\n*/\nProducerImpl proxyProducerImpl = (ProducerImpl)Enhancer.create(ProducerImpl.class， new MethodInterceptor() {\n            /**\n             *执行被代理对象中的任何接口方法都会经过该方法\n             * @param o 代理对象的引用\n             * @param method 当前执行的方法\n             * @param objects 当前执行方法的参数\n             * @param methodProxy 当前执行方法的代理对象\n             * @return 和被代理对象方法有相同的返回值\n             * @throws Throwable\n             */\n            @Override\n            public Object intercept(Object o， Method method， Object[] objects， MethodProxy methodProxy) throws Throwable {\n                Object result = null;\n                if (\"sell\".equals(method.getName())) {\n                    System.out.println(\"proxy\");\n                    result = (int) method.invoke(new ProducerImpl()， objects) * 2;\n                }\n                return result;\n            }\n        });\n        int sell1 = proxyProducerImpl.sell(200);\n        System.out.println(\"proxyProducerImpl sell:\"+sell1);\n    }\n```\n\n","source":"_posts/计算机基础/设计模式/03.代理模式.md","raw":"---\ntitle: 代理模式\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 包括静态代理、基于接口的动态代理、基于子类的动态代理等。\ncategories: 设计模式\ntags:\n  - 架构\n  - 静态代理\n  - 动态代理\nabbrlink: 7b510e10\ndate: 2021-01-14 00:00:00\n---\n\n\n\n# 代理模式\n\n是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问。\n\n代理模式通俗来讲就是我们生活中常见的中介。\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/8493217-06886049700e73f7.png)\n\nSubject\n 抽象主题角色：可以是抽象类，也可以是接口。抽象主题是一个普通的业务类型，无特殊要求。\n\nRealSubject\n 具体主题角色：也叫做**被委托角色**或**被代理角色**，是业务逻辑的具体执行者。\n\nProxy\n 代理主题角色：也叫做**委托类**或**代理类**。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后处理工作。\n\n\n\n当两个类需要通信时，引入第三方代理类，将两个类的关系解耦，让我们只了解代理类即可，而且代理的出现还可以让我们完成与另一个类之间的关系的统一管理。但是切记，代理类和委托类要实现相同的接口，因为代理真正调用的还是委托类的方法。\n\n**静态代理**\n 由程序员创建或特定工具自动生成源代码，再对其进行编译。**在程序运行之前，代理类.class文件就已经被创建**，代理类和委托类的关系在运行前就确定。\n\n**动态代理**\n 动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。\n\n\n\n# 静态代理\n\n接口\n\n```csharp\npublic interface Subject {\n    /**\n     * 接口方法\n     */\n    public void request();\n}\n```\n\n业务类\n\n```java\npublic class ConcreteSubject implements Subject {\n    /**\n     * 具体的业务逻辑实现\n     */\n    @Override\n    public void request() {\n        //业务处理逻辑\n    }\n}\n```\n\n代理类\n\n```csharp\npublic class Proxy implements Subject {\n\n    /**\n     * 要代理的实现类\n     */\n    private Subject subject = null;\n\n    /**\n     * 默认代理自己\n     */\n    public Proxy() {\n        this.subject = new Proxy();\n    }\n\n    public Proxy(Subject subject) {\n        this.subject = subject;\n    }\n\n    /**\n     * 构造函数，传递委托者\n     *\n     * @param objects 委托者\n     */\n    public Proxy(Object... objects) {\n    }\n\n    /**\n     * 实现接口方法\n     */\n    @Override\n    public void request() {\n        this.before();\n        this.subject.request();\n        this.after();\n    }\n\n    /**\n     * 预处理\n     */\n    private void before() {\n        //do something\n    }\n\n    /**\n     * 后处理\n     */\n    private void after() {\n        //do something\n    }\n}\n```\n\n使用\n\n```cpp\npublic class Client {\n    public static void main(String[] args) {\n        Subject subject = new ConcreteSubject();\n        Proxy proxy = new Proxy(subject);\n        proxy.request();\n    }\n}\n```\n\n业务类只需要关注业务逻辑本身，保证了业务类的重用性。\n\n代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。\n\n# 动态代理\n\n+ 动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。\n+ 字节码随用随创建，随用随加载\n+ 在不修改源码的基础上对方法增强\n+ 代理模式为另外一个对象提供一个替身或占位符以控制这个对象的访问\n+ 动态代理：在运行时动态地创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指定的类\n+ 当代理的方法被调用时，代理就会把这个调用转发给`InvocationHandler`\n+ 动态代理类是根据传入的接口，用**Proxy.newProxyInstance**动态创建的\n\n![image-20201128112905460](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201128112905460.png)\n\n## 基于接口的动态代理\n\n+ JDK提供的Proxy\n+ 被代理对象至少实现一个接口，最终返回的类型可以转型为这个接口\n+ Proxy.newProxyInstance()\n\n```java\n//用户将操作这个共同实现的接口\npublic interface Producer {\n    int sell(int money);\n}\n\n//被代理对象\npublic class ProducerImpl implements Producer {\n    @Override\n    public int sell(int money) {\n        System.out.println(\"ProducerImpl sell:\" + money);\n        return money;\n    }\n}\n\npublic class Main{\n\tpublic static void main(String[] args) {\n        /*\n        ClassLoader:用于加载代理对象的字节码，和被代理对象使用相同的类加载器\n        Class []:用于让代理对象和被代理对象有相同的接口\n        InvocationHandler:用于提供增强的方法\n        */\n        Producer proxyProducer = (Producer) Proxy.newProxyInstance(ProducerImpl.class.getClassLoader()， ProducerImpl.class.getInterfaces()，\n                new InvocationHandler() {\n                    /**\n                     * 执行被代理对象中的任何接口方法都会经过该方法\n                     * @param proxy 代理对象的引用\n                     * @param method 当前执行的方法\n                     * @param args 当前执行方法的参数\n                     * @return 和被代理对象方法有相同的返回值\n                     * @throws Throwable\n                     */\n                    @Override\n                    public Object invoke(Object proxy， Method method， Object[] args) throws Throwable {\n                        Object result = null;\n                        if (\"sell\".equals(method.getName())) {\n                            System.out.println(\"proxy\");\n                            result = (int) method.invoke(new ProducerImpl()， args) * 2;\n                        }\n                        return result;\n                    }\n                });\n        int sell = proxyProducer.sell(100);\n        System.out.println(\"proxyProducer sell:\" + sell);\n        /*\n        proxy\n        ProducerImpl sell:100\n        proxyProducer sell:200\n         */\n    }\n}\n```\n\n## 基于子类的动态代理\n\n+ 使用第三方cglib库(或者有spring依赖)\n+ 被代理类不能是最终类：最终返回的类型可以转型为被代理类\n\n```java\n/*\nClass:指定被代理对象的字节码\nCallback:用于提供增强的方法，一般使用new MethodInterceptor(){}\n*/\nProducerImpl proxyProducerImpl = (ProducerImpl)Enhancer.create(ProducerImpl.class， new MethodInterceptor() {\n            /**\n             *执行被代理对象中的任何接口方法都会经过该方法\n             * @param o 代理对象的引用\n             * @param method 当前执行的方法\n             * @param objects 当前执行方法的参数\n             * @param methodProxy 当前执行方法的代理对象\n             * @return 和被代理对象方法有相同的返回值\n             * @throws Throwable\n             */\n            @Override\n            public Object intercept(Object o， Method method， Object[] objects， MethodProxy methodProxy) throws Throwable {\n                Object result = null;\n                if (\"sell\".equals(method.getName())) {\n                    System.out.println(\"proxy\");\n                    result = (int) method.invoke(new ProducerImpl()， objects) * 2;\n                }\n                return result;\n            }\n        });\n        int sell1 = proxyProducerImpl.sell(200);\n        System.out.println(\"proxyProducerImpl sell:\"+sell1);\n    }\n```\n\n","slug":"计算机基础/设计模式/03.代理模式","published":1,"updated":"2021-06-08T03:35:00.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq512000sz0tp4s92a678","content":"<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问。</p>\n<p>代理模式通俗来讲就是我们生活中常见的中介。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/8493217-06886049700e73f7.png\"></p>\n<p>Subject<br> 抽象主题角色：可以是抽象类，也可以是接口。抽象主题是一个普通的业务类型，无特殊要求。</p>\n<p>RealSubject<br> 具体主题角色：也叫做<strong>被委托角色</strong>或<strong>被代理角色</strong>，是业务逻辑的具体执行者。</p>\n<p>Proxy<br> 代理主题角色：也叫做<strong>委托类</strong>或<strong>代理类</strong>。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后处理工作。</p>\n<p>当两个类需要通信时，引入第三方代理类，将两个类的关系解耦，让我们只了解代理类即可，而且代理的出现还可以让我们完成与另一个类之间的关系的统一管理。但是切记，代理类和委托类要实现相同的接口，因为代理真正调用的还是委托类的方法。</p>\n<p><strong>静态代理</strong><br> 由程序员创建或特定工具自动生成源代码，再对其进行编译。<strong>在程序运行之前，代理类.class文件就已经被创建</strong>，代理类和委托类的关系在运行前就确定。</p>\n<p><strong>动态代理</strong><br> 动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</p>\n<h1 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h1><p>接口</p>\n<pre class=\" language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Subject</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 接口方法\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>业务类</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ConcreteSubject</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Subject</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 具体的业务逻辑实现\n     */</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//业务处理逻辑</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>代理类</p>\n<pre class=\" language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Proxy</span> implements <span class=\"token class-name\">Subject</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 要代理的实现类\n     */</span>\n    <span class=\"token keyword\">private</span> Subject subject <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 默认代理自己\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subject <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Proxy</span><span class=\"token punctuation\">(</span>Subject subject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subject <span class=\"token operator\">=</span> subject<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 构造函数，传递委托者\n     *\n     * @param objects 委托者\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Proxy</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> objects<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 实现接口方法\n     */</span>\n    @Override\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">before</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subject<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">after</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 预处理\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">before</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//do something</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 后处理\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">after</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//do something</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>使用</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Client</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Subject subject <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">ConcreteSubject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Proxy proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">Proxy</span><span class=\"token punctuation\">(</span>subject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        proxy<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>业务类只需要关注业务逻辑本身，保证了业务类的重用性。</p>\n<p>代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。</p>\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><ul>\n<li>动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。</li>\n<li>字节码随用随创建，随用随加载</li>\n<li>在不修改源码的基础上对方法增强</li>\n<li>代理模式为另外一个对象提供一个替身或占位符以控制这个对象的访问</li>\n<li>动态代理：在运行时动态地创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指定的类</li>\n<li>当代理的方法被调用时，代理就会把这个调用转发给<code>InvocationHandler</code></li>\n<li>动态代理类是根据传入的接口，用<strong>Proxy.newProxyInstance</strong>动态创建的</li>\n</ul>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201128112905460.png\" alt=\"image-20201128112905460\"></p>\n<h2 id=\"基于接口的动态代理\"><a href=\"#基于接口的动态代理\" class=\"headerlink\" title=\"基于接口的动态代理\"></a>基于接口的动态代理</h2><ul>\n<li>JDK提供的Proxy</li>\n<li>被代理对象至少实现一个接口，最终返回的类型可以转型为这个接口</li>\n<li>Proxy.newProxyInstance()</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//用户将操作这个共同实现的接口</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Producer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">sell</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> money<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//被代理对象</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ProducerImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Producer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">sell</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> money<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ProducerImpl sell:\"</span> <span class=\"token operator\">+</span> money<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> money<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n        ClassLoader:用于加载代理对象的字节码，和被代理对象使用相同的类加载器\n        Class []:用于让代理对象和被代理对象有相同的接口\n        InvocationHandler:用于提供增强的方法\n        */</span>\n        Producer proxyProducer <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Producer<span class=\"token punctuation\">)</span> Proxy<span class=\"token punctuation\">.</span><span class=\"token function\">newProxyInstance</span><span class=\"token punctuation\">(</span>ProducerImpl<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>， ProducerImpl<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span><span class=\"token function\">getInterfaces</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>，\n                <span class=\"token keyword\">new</span> <span class=\"token class-name\">InvocationHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">/**\n                     * 执行被代理对象中的任何接口方法都会经过该方法\n                     * @param proxy 代理对象的引用\n                     * @param method 当前执行的方法\n                     * @param args 当前执行方法的参数\n                     * @return 和被代理对象方法有相同的返回值\n                     * @throws Throwable\n                     */</span>\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> Object <span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>Object proxy， Method method， Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Throwable <span class=\"token punctuation\">{</span>\n                        Object result <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"sell\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"proxy\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ProducerImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>， args<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> sell <span class=\"token operator\">=</span> proxyProducer<span class=\"token punctuation\">.</span><span class=\"token function\">sell</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"proxyProducer sell:\"</span> <span class=\"token operator\">+</span> sell<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n        proxy\n        ProducerImpl sell:100\n        proxyProducer sell:200\n         */</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"基于子类的动态代理\"><a href=\"#基于子类的动态代理\" class=\"headerlink\" title=\"基于子类的动态代理\"></a>基于子类的动态代理</h2><ul>\n<li>使用第三方cglib库(或者有spring依赖)</li>\n<li>被代理类不能是最终类：最终返回的类型可以转型为被代理类</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/*\nClass:指定被代理对象的字节码\nCallback:用于提供增强的方法，一般使用new MethodInterceptor(){}\n*/</span>\nProducerImpl proxyProducerImpl <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ProducerImpl<span class=\"token punctuation\">)</span>Enhancer<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>ProducerImpl<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span>， <span class=\"token keyword\">new</span> <span class=\"token class-name\">MethodInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">/**\n             *执行被代理对象中的任何接口方法都会经过该方法\n             * @param o 代理对象的引用\n             * @param method 当前执行的方法\n             * @param objects 当前执行方法的参数\n             * @param methodProxy 当前执行方法的代理对象\n             * @return 和被代理对象方法有相同的返回值\n             * @throws Throwable\n             */</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> Object <span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span>Object o， Method method， Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> objects， MethodProxy methodProxy<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Throwable <span class=\"token punctuation\">{</span>\n                Object result <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"sell\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"proxy\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ProducerImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>， objects<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> sell1 <span class=\"token operator\">=</span> proxyProducerImpl<span class=\"token punctuation\">.</span><span class=\"token function\">sell</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"proxyProducerImpl sell:\"</span><span class=\"token operator\">+</span>sell1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问。</p>\n<p>代理模式通俗来讲就是我们生活中常见的中介。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/8493217-06886049700e73f7.png\"></p>\n<p>Subject<br> 抽象主题角色：可以是抽象类，也可以是接口。抽象主题是一个普通的业务类型，无特殊要求。</p>\n<p>RealSubject<br> 具体主题角色：也叫做<strong>被委托角色</strong>或<strong>被代理角色</strong>，是业务逻辑的具体执行者。</p>\n<p>Proxy<br> 代理主题角色：也叫做<strong>委托类</strong>或<strong>代理类</strong>。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后处理工作。</p>\n<p>当两个类需要通信时，引入第三方代理类，将两个类的关系解耦，让我们只了解代理类即可，而且代理的出现还可以让我们完成与另一个类之间的关系的统一管理。但是切记，代理类和委托类要实现相同的接口，因为代理真正调用的还是委托类的方法。</p>\n<p><strong>静态代理</strong><br> 由程序员创建或特定工具自动生成源代码，再对其进行编译。<strong>在程序运行之前，代理类.class文件就已经被创建</strong>，代理类和委托类的关系在运行前就确定。</p>\n<p><strong>动态代理</strong><br> 动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</p>\n<h1 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h1><p>接口</p>\n<pre><code class=\"csharp\">public interface Subject {\n    /**\n     * 接口方法\n     */\n    public void request();\n}</code></pre>\n<p>业务类</p>\n<pre><code class=\"java\">public class ConcreteSubject implements Subject {\n    /**\n     * 具体的业务逻辑实现\n     */\n    @Override\n    public void request() {\n        //业务处理逻辑\n    }\n}</code></pre>\n<p>代理类</p>\n<pre><code class=\"csharp\">public class Proxy implements Subject {\n\n    /**\n     * 要代理的实现类\n     */\n    private Subject subject = null;\n\n    /**\n     * 默认代理自己\n     */\n    public Proxy() {\n        this.subject = new Proxy();\n    }\n\n    public Proxy(Subject subject) {\n        this.subject = subject;\n    }\n\n    /**\n     * 构造函数，传递委托者\n     *\n     * @param objects 委托者\n     */\n    public Proxy(Object... objects) {\n    }\n\n    /**\n     * 实现接口方法\n     */\n    @Override\n    public void request() {\n        this.before();\n        this.subject.request();\n        this.after();\n    }\n\n    /**\n     * 预处理\n     */\n    private void before() {\n        //do something\n    }\n\n    /**\n     * 后处理\n     */\n    private void after() {\n        //do something\n    }\n}</code></pre>\n<p>使用</p>\n<pre><code class=\"cpp\">public class Client {\n    public static void main(String[] args) {\n        Subject subject = new ConcreteSubject();\n        Proxy proxy = new Proxy(subject);\n        proxy.request();\n    }\n}</code></pre>\n<p>业务类只需要关注业务逻辑本身，保证了业务类的重用性。</p>\n<p>代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。</p>\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><ul>\n<li>动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。</li>\n<li>字节码随用随创建，随用随加载</li>\n<li>在不修改源码的基础上对方法增强</li>\n<li>代理模式为另外一个对象提供一个替身或占位符以控制这个对象的访问</li>\n<li>动态代理：在运行时动态地创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指定的类</li>\n<li>当代理的方法被调用时，代理就会把这个调用转发给<code>InvocationHandler</code></li>\n<li>动态代理类是根据传入的接口，用<strong>Proxy.newProxyInstance</strong>动态创建的</li>\n</ul>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201128112905460.png\" alt=\"image-20201128112905460\"></p>\n<h2 id=\"基于接口的动态代理\"><a href=\"#基于接口的动态代理\" class=\"headerlink\" title=\"基于接口的动态代理\"></a>基于接口的动态代理</h2><ul>\n<li>JDK提供的Proxy</li>\n<li>被代理对象至少实现一个接口，最终返回的类型可以转型为这个接口</li>\n<li>Proxy.newProxyInstance()</li>\n</ul>\n<pre><code class=\"java\">//用户将操作这个共同实现的接口\npublic interface Producer {\n    int sell(int money);\n}\n\n//被代理对象\npublic class ProducerImpl implements Producer {\n    @Override\n    public int sell(int money) {\n        System.out.println(&quot;ProducerImpl sell:&quot; + money);\n        return money;\n    }\n}\n\npublic class Main{\n    public static void main(String[] args) {\n        /*\n        ClassLoader:用于加载代理对象的字节码，和被代理对象使用相同的类加载器\n        Class []:用于让代理对象和被代理对象有相同的接口\n        InvocationHandler:用于提供增强的方法\n        */\n        Producer proxyProducer = (Producer) Proxy.newProxyInstance(ProducerImpl.class.getClassLoader()， ProducerImpl.class.getInterfaces()，\n                new InvocationHandler() {\n                    /**\n                     * 执行被代理对象中的任何接口方法都会经过该方法\n                     * @param proxy 代理对象的引用\n                     * @param method 当前执行的方法\n                     * @param args 当前执行方法的参数\n                     * @return 和被代理对象方法有相同的返回值\n                     * @throws Throwable\n                     */\n                    @Override\n                    public Object invoke(Object proxy， Method method， Object[] args) throws Throwable {\n                        Object result = null;\n                        if (&quot;sell&quot;.equals(method.getName())) {\n                            System.out.println(&quot;proxy&quot;);\n                            result = (int) method.invoke(new ProducerImpl()， args) * 2;\n                        }\n                        return result;\n                    }\n                });\n        int sell = proxyProducer.sell(100);\n        System.out.println(&quot;proxyProducer sell:&quot; + sell);\n        /*\n        proxy\n        ProducerImpl sell:100\n        proxyProducer sell:200\n         */\n    }\n}</code></pre>\n<h2 id=\"基于子类的动态代理\"><a href=\"#基于子类的动态代理\" class=\"headerlink\" title=\"基于子类的动态代理\"></a>基于子类的动态代理</h2><ul>\n<li>使用第三方cglib库(或者有spring依赖)</li>\n<li>被代理类不能是最终类：最终返回的类型可以转型为被代理类</li>\n</ul>\n<pre><code class=\"java\">/*\nClass:指定被代理对象的字节码\nCallback:用于提供增强的方法，一般使用new MethodInterceptor(){}\n*/\nProducerImpl proxyProducerImpl = (ProducerImpl)Enhancer.create(ProducerImpl.class， new MethodInterceptor() {\n            /**\n             *执行被代理对象中的任何接口方法都会经过该方法\n             * @param o 代理对象的引用\n             * @param method 当前执行的方法\n             * @param objects 当前执行方法的参数\n             * @param methodProxy 当前执行方法的代理对象\n             * @return 和被代理对象方法有相同的返回值\n             * @throws Throwable\n             */\n            @Override\n            public Object intercept(Object o， Method method， Object[] objects， MethodProxy methodProxy) throws Throwable {\n                Object result = null;\n                if (&quot;sell&quot;.equals(method.getName())) {\n                    System.out.println(&quot;proxy&quot;);\n                    result = (int) method.invoke(new ProducerImpl()， objects) * 2;\n                }\n                return result;\n            }\n        });\n        int sell1 = proxyProducerImpl.sell(200);\n        System.out.println(&quot;proxyProducerImpl sell:&quot;+sell1);\n    }</code></pre>\n"},{"title":"单例模式","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习单例模式所做的笔记，包括单例模式的各种实现方式和实际项目应用等。","abbrlink":"f1601c3e","date":"2021-01-02T16:00:00.000Z","_content":"\n\n\n# 单例模式\n\n## 应用\n\n+ 单例模式是很常用的一个设计模式，它可以确保只有一个实例被创建\n\n+ 无状态的工具类：例如日志工具类，使用单例模式就不用反复创建，节约系统开销\n+ 全局信息类：例如统计网站访问次数。这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，出现不一致性的结果。\n\n## 思路\n\n+ 不能将类的构造函数暴露在外面，所以要将构造函数重写为私有的\n+ 要考虑线程安全，绝对不能多个线程构造出多个对象来。\n\n# 实现方式\n\n## 饿汉式\n\n- 类加载时就实例化instance对象。\n- 它基于 ClassLoader 机制避免了多线程的同步问题\n- 虽然在单例模式中大多数都是调用 getInstance 方法才进行类加载，但是也不能确定有其他的方式导致类装载，这时候初始化 instance 显然没有达到懒加载的效果。浪费内存、资源浪费\n\n```java\npublic class Singleton {\n    private static Singleton instance = new Singleton();\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n## 懒汉式（线程不安全，不可用）\n\n+ 容易线程不安全\n+ 写法复杂\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n\n    }\n\n    //线程不安全\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n## 懒汉式（线程安全，效率低）\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n\n    }\n\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n## DCL（Double Check Lock）\n\nDCL本质上也就是减少了锁粒度，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。\n\n\n\n双重校验锁第二次进行判空原因：假设有两个线程A和B，都进行完第一次判空了，A和B都阻塞在如图所示位置\n\n这个时候A线程获取了类锁，然后B线程被阻塞，A线程新建了一个实例后释放了锁，B线程获取锁，又新建了一个实例，这破坏了单例设计模式的初衷。\n\n```java\npublic class Singleton {\n    private static volatile Singleton instance = null;\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n+ 构建对象：首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧。然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。**分配对象内存空间**\n+ 初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法。**初始化对象**\n+ 引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。**设置instance指向刚分配的内存地址**，此时instance!=null\n\n但是他们不存在数据依赖关系，在单线程下执行结果不变.所以有可能发生指令重排序\n\n所以某个线程在最外层的 if (instance == null) 时，由于指令重排序，他看到的instance!=null\n但是instance实际上尚未初始化完成，让其他的线程拿到了一个空引用，之后就出现NPE，所以出现了线程安全问题\n\n## 静态内部类方式（可用）\n\n- 外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE，延迟了单例的实例化。\n- 由JVM来保证线程安全，即保证单例的唯一性\n\n**JVM保证线程安全**\n\n- 对分配内存空间的动作做同步处理，采用CAS机制，配合失败重试的方式保证更新操作的线程安全性。\n- 每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块\"私有\"内存中分配，当这部分区域用完之后，再分配新的\"私有\"内存。（TLAB分配，即Thread Local Allocation Buffer 这部分Buffer是从堆中划分出来的，但是是本地线程独享的。）TLAB时线程独享的，但是只是在“分配”这个动作上是线程独占的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。\n\n**类加载时机：**\n\n类加载时机：JAVA虚拟机在有且仅有的5种场景下会对类进行初始化。\n1.遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时，对应的java代码场景为：new一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。\n2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。\n3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。\n4.当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。\n5.当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n这5种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是\"有且仅有\"，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。\n\n```java\npublic class Singleton {\n    private Singleton() {\n\n    }\n\n    private static class SingletonInstance{\n        private static final Singleton instance = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return SingletonInstance.instance;\n    }\n}\n```\n\n## 枚举（实践中最佳使用）\n\n《effective java》：单元素的枚举类型已经成为实现Singleton的最佳方法\n\n由于反射可以获取到类的构造函数，包括私有构造函数，因此反射可以生成新的对象。\n\n**Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次**。\n\n```java\npublic enum  EnumSingleton {\n    INSTANCE;\n    public EnumSingleton getInstance(){\n        return INSTANCE;\n    }\n}\n```\n\n","source":"_posts/计算机基础/设计模式/01.单例模式.md","raw":"---\ntitle: 单例模式\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 学习单例模式所做的笔记，包括单例模式的各种实现方式和实际项目应用等。\ncategories: 设计模式\ntags:\n  - volatile\n  - 枚举\n  - 单例模式\nabbrlink: f1601c3e\ndate: 2021-01-03 00:00:00\n---\n\n\n\n# 单例模式\n\n## 应用\n\n+ 单例模式是很常用的一个设计模式，它可以确保只有一个实例被创建\n\n+ 无状态的工具类：例如日志工具类，使用单例模式就不用反复创建，节约系统开销\n+ 全局信息类：例如统计网站访问次数。这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，出现不一致性的结果。\n\n## 思路\n\n+ 不能将类的构造函数暴露在外面，所以要将构造函数重写为私有的\n+ 要考虑线程安全，绝对不能多个线程构造出多个对象来。\n\n# 实现方式\n\n## 饿汉式\n\n- 类加载时就实例化instance对象。\n- 它基于 ClassLoader 机制避免了多线程的同步问题\n- 虽然在单例模式中大多数都是调用 getInstance 方法才进行类加载，但是也不能确定有其他的方式导致类装载，这时候初始化 instance 显然没有达到懒加载的效果。浪费内存、资源浪费\n\n```java\npublic class Singleton {\n    private static Singleton instance = new Singleton();\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n## 懒汉式（线程不安全，不可用）\n\n+ 容易线程不安全\n+ 写法复杂\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n\n    }\n\n    //线程不安全\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n## 懒汉式（线程安全，效率低）\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n\n    }\n\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n## DCL（Double Check Lock）\n\nDCL本质上也就是减少了锁粒度，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。\n\n\n\n双重校验锁第二次进行判空原因：假设有两个线程A和B，都进行完第一次判空了，A和B都阻塞在如图所示位置\n\n这个时候A线程获取了类锁，然后B线程被阻塞，A线程新建了一个实例后释放了锁，B线程获取锁，又新建了一个实例，这破坏了单例设计模式的初衷。\n\n```java\npublic class Singleton {\n    private static volatile Singleton instance = null;\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n+ 构建对象：首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧。然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。**分配对象内存空间**\n+ 初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法。**初始化对象**\n+ 引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。**设置instance指向刚分配的内存地址**，此时instance!=null\n\n但是他们不存在数据依赖关系，在单线程下执行结果不变.所以有可能发生指令重排序\n\n所以某个线程在最外层的 if (instance == null) 时，由于指令重排序，他看到的instance!=null\n但是instance实际上尚未初始化完成，让其他的线程拿到了一个空引用，之后就出现NPE，所以出现了线程安全问题\n\n## 静态内部类方式（可用）\n\n- 外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE，延迟了单例的实例化。\n- 由JVM来保证线程安全，即保证单例的唯一性\n\n**JVM保证线程安全**\n\n- 对分配内存空间的动作做同步处理，采用CAS机制，配合失败重试的方式保证更新操作的线程安全性。\n- 每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块\"私有\"内存中分配，当这部分区域用完之后，再分配新的\"私有\"内存。（TLAB分配，即Thread Local Allocation Buffer 这部分Buffer是从堆中划分出来的，但是是本地线程独享的。）TLAB时线程独享的，但是只是在“分配”这个动作上是线程独占的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。\n\n**类加载时机：**\n\n类加载时机：JAVA虚拟机在有且仅有的5种场景下会对类进行初始化。\n1.遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时，对应的java代码场景为：new一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。\n2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。\n3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。\n4.当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。\n5.当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n这5种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是\"有且仅有\"，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。\n\n```java\npublic class Singleton {\n    private Singleton() {\n\n    }\n\n    private static class SingletonInstance{\n        private static final Singleton instance = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return SingletonInstance.instance;\n    }\n}\n```\n\n## 枚举（实践中最佳使用）\n\n《effective java》：单元素的枚举类型已经成为实现Singleton的最佳方法\n\n由于反射可以获取到类的构造函数，包括私有构造函数，因此反射可以生成新的对象。\n\n**Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次**。\n\n```java\npublic enum  EnumSingleton {\n    INSTANCE;\n    public EnumSingleton getInstance(){\n        return INSTANCE;\n    }\n}\n```\n\n","slug":"计算机基础/设计模式/01.单例模式","published":1,"updated":"2021-06-08T03:35:00.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq513000xz0tpctau5qpn","content":"<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><ul>\n<li><p>单例模式是很常用的一个设计模式，它可以确保只有一个实例被创建</p>\n</li>\n<li><p>无状态的工具类：例如日志工具类，使用单例模式就不用反复创建，节约系统开销</p>\n</li>\n<li><p>全局信息类：例如统计网站访问次数。这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，出现不一致性的结果。</p>\n</li>\n</ul>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><ul>\n<li>不能将类的构造函数暴露在外面，所以要将构造函数重写为私有的</li>\n<li>要考虑线程安全，绝对不能多个线程构造出多个对象来。</li>\n</ul>\n<h1 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h1><h2 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h2><ul>\n<li>类加载时就实例化instance对象。</li>\n<li>它基于 ClassLoader 机制避免了多线程的同步问题</li>\n<li>虽然在单例模式中大多数都是调用 getInstance 方法才进行类加载，但是也不能确定有其他的方式导致类装载，这时候初始化 instance 显然没有达到懒加载的效果。浪费内存、资源浪费</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Singleton instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"懒汉式（线程不安全，不可用）\"><a href=\"#懒汉式（线程不安全，不可用）\" class=\"headerlink\" title=\"懒汉式（线程不安全，不可用）\"></a>懒汉式（线程不安全，不可用）</h2><ul>\n<li>容易线程不安全</li>\n<li>写法复杂</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Singleton instance<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//线程不安全</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"懒汉式（线程安全，效率低）\"><a href=\"#懒汉式（线程安全，效率低）\" class=\"headerlink\" title=\"懒汉式（线程安全，效率低）\"></a>懒汉式（线程安全，效率低）</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Singleton instance<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"DCL（Double-Check-Lock）\"><a href=\"#DCL（Double-Check-Lock）\" class=\"headerlink\" title=\"DCL（Double Check Lock）\"></a>DCL（Double Check Lock）</h2><p>DCL本质上也就是减少了锁粒度，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。</p>\n<p>双重校验锁第二次进行判空原因：假设有两个线程A和B，都进行完第一次判空了，A和B都阻塞在如图所示位置</p>\n<p>这个时候A线程获取了类锁，然后B线程被阻塞，A线程新建了一个实例后释放了锁，B线程获取锁，又新建了一个实例，这破坏了单例设计模式的初衷。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> Singleton instance <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>Singleton<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>构建对象：首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧。然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。<strong>分配对象内存空间</strong></li>\n<li>初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法。<strong>初始化对象</strong></li>\n<li>引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。<strong>设置instance指向刚分配的内存地址</strong>，此时instance!=null</li>\n</ul>\n<p>但是他们不存在数据依赖关系，在单线程下执行结果不变.所以有可能发生指令重排序</p>\n<p>所以某个线程在最外层的 if (instance == null) 时，由于指令重排序，他看到的instance!=null<br>但是instance实际上尚未初始化完成，让其他的线程拿到了一个空引用，之后就出现NPE，所以出现了线程安全问题</p>\n<h2 id=\"静态内部类方式（可用）\"><a href=\"#静态内部类方式（可用）\" class=\"headerlink\" title=\"静态内部类方式（可用）\"></a>静态内部类方式（可用）</h2><ul>\n<li>外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE，延迟了单例的实例化。</li>\n<li>由JVM来保证线程安全，即保证单例的唯一性</li>\n</ul>\n<p><strong>JVM保证线程安全</strong></p>\n<ul>\n<li>对分配内存空间的动作做同步处理，采用CAS机制，配合失败重试的方式保证更新操作的线程安全性。</li>\n<li>每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。（TLAB分配，即Thread Local Allocation Buffer 这部分Buffer是从堆中划分出来的，但是是本地线程独享的。）TLAB时线程独享的，但是只是在“分配”这个动作上是线程独占的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。</li>\n</ul>\n<p><strong>类加载时机：</strong></p>\n<p>类加载时机：JAVA虚拟机在有且仅有的5种场景下会对类进行初始化。<br>1.遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时，对应的java代码场景为：new一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。<br>2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。<br>3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。<br>4.当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。<br>5.当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。<br>这5种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonInstance</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Singleton instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> SingletonInstance<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"枚举（实践中最佳使用）\"><a href=\"#枚举（实践中最佳使用）\" class=\"headerlink\" title=\"枚举（实践中最佳使用）\"></a>枚举（实践中最佳使用）</h2><p>《effective java》：单元素的枚举类型已经成为实现Singleton的最佳方法</p>\n<p>由于反射可以获取到类的构造函数，包括私有构造函数，因此反射可以生成新的对象。</p>\n<p><strong>Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次</strong>。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span>  EnumSingleton <span class=\"token punctuation\">{</span>\n    INSTANCE<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> EnumSingleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> INSTANCE<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><ul>\n<li><p>单例模式是很常用的一个设计模式，它可以确保只有一个实例被创建</p>\n</li>\n<li><p>无状态的工具类：例如日志工具类，使用单例模式就不用反复创建，节约系统开销</p>\n</li>\n<li><p>全局信息类：例如统计网站访问次数。这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，出现不一致性的结果。</p>\n</li>\n</ul>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><ul>\n<li>不能将类的构造函数暴露在外面，所以要将构造函数重写为私有的</li>\n<li>要考虑线程安全，绝对不能多个线程构造出多个对象来。</li>\n</ul>\n<h1 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h1><h2 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h2><ul>\n<li>类加载时就实例化instance对象。</li>\n<li>它基于 ClassLoader 机制避免了多线程的同步问题</li>\n<li>虽然在单例模式中大多数都是调用 getInstance 方法才进行类加载，但是也不能确定有其他的方式导致类装载，这时候初始化 instance 显然没有达到懒加载的效果。浪费内存、资源浪费</li>\n</ul>\n<pre><code class=\"java\">public class Singleton {\n    private static Singleton instance = new Singleton();\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n}</code></pre>\n<h2 id=\"懒汉式（线程不安全，不可用）\"><a href=\"#懒汉式（线程不安全，不可用）\" class=\"headerlink\" title=\"懒汉式（线程不安全，不可用）\"></a>懒汉式（线程不安全，不可用）</h2><ul>\n<li>容易线程不安全</li>\n<li>写法复杂</li>\n</ul>\n<pre><code class=\"java\">public class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n\n    }\n\n    //线程不安全\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}</code></pre>\n<h2 id=\"懒汉式（线程安全，效率低）\"><a href=\"#懒汉式（线程安全，效率低）\" class=\"headerlink\" title=\"懒汉式（线程安全，效率低）\"></a>懒汉式（线程安全，效率低）</h2><pre><code class=\"java\">public class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n\n    }\n\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}</code></pre>\n<h2 id=\"DCL（Double-Check-Lock）\"><a href=\"#DCL（Double-Check-Lock）\" class=\"headerlink\" title=\"DCL（Double Check Lock）\"></a>DCL（Double Check Lock）</h2><p>DCL本质上也就是减少了锁粒度，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。</p>\n<p>双重校验锁第二次进行判空原因：假设有两个线程A和B，都进行完第一次判空了，A和B都阻塞在如图所示位置</p>\n<p>这个时候A线程获取了类锁，然后B线程被阻塞，A线程新建了一个实例后释放了锁，B线程获取锁，又新建了一个实例，这破坏了单例设计模式的初衷。</p>\n<pre><code class=\"java\">public class Singleton {\n    private static volatile Singleton instance = null;\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}</code></pre>\n<ul>\n<li>构建对象：首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧。然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。<strong>分配对象内存空间</strong></li>\n<li>初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法。<strong>初始化对象</strong></li>\n<li>引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。<strong>设置instance指向刚分配的内存地址</strong>，此时instance!=null</li>\n</ul>\n<p>但是他们不存在数据依赖关系，在单线程下执行结果不变.所以有可能发生指令重排序</p>\n<p>所以某个线程在最外层的 if (instance == null) 时，由于指令重排序，他看到的instance!=null<br>但是instance实际上尚未初始化完成，让其他的线程拿到了一个空引用，之后就出现NPE，所以出现了线程安全问题</p>\n<h2 id=\"静态内部类方式（可用）\"><a href=\"#静态内部类方式（可用）\" class=\"headerlink\" title=\"静态内部类方式（可用）\"></a>静态内部类方式（可用）</h2><ul>\n<li>外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE，延迟了单例的实例化。</li>\n<li>由JVM来保证线程安全，即保证单例的唯一性</li>\n</ul>\n<p><strong>JVM保证线程安全</strong></p>\n<ul>\n<li>对分配内存空间的动作做同步处理，采用CAS机制，配合失败重试的方式保证更新操作的线程安全性。</li>\n<li>每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。（TLAB分配，即Thread Local Allocation Buffer 这部分Buffer是从堆中划分出来的，但是是本地线程独享的。）TLAB时线程独享的，但是只是在“分配”这个动作上是线程独占的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。</li>\n</ul>\n<p><strong>类加载时机：</strong></p>\n<p>类加载时机：JAVA虚拟机在有且仅有的5种场景下会对类进行初始化。<br>1.遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时，对应的java代码场景为：new一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。<br>2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。<br>3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。<br>4.当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。<br>5.当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。<br>这5种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</p>\n<pre><code class=\"java\">public class Singleton {\n    private Singleton() {\n\n    }\n\n    private static class SingletonInstance{\n        private static final Singleton instance = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return SingletonInstance.instance;\n    }\n}</code></pre>\n<h2 id=\"枚举（实践中最佳使用）\"><a href=\"#枚举（实践中最佳使用）\" class=\"headerlink\" title=\"枚举（实践中最佳使用）\"></a>枚举（实践中最佳使用）</h2><p>《effective java》：单元素的枚举类型已经成为实现Singleton的最佳方法</p>\n<p>由于反射可以获取到类的构造函数，包括私有构造函数，因此反射可以生成新的对象。</p>\n<p><strong>Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次</strong>。</p>\n<pre><code class=\"java\">public enum  EnumSingleton {\n    INSTANCE;\n    public EnumSingleton getInstance(){\n        return INSTANCE;\n    }\n}</code></pre>\n"},{"title":"Netty","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习Netty所做的笔记，包括线程模型、Reactor模式、Netty源码分析等。","abbrlink":"1c6ba3e2","date":"2021-05-26T16:00:00.000Z","_content":"\n\n\n# 线程模型\n\n介绍完服务器如何基于I/O模型管理连接，获取输入数据，下面介绍基于进程/线程模型，服务器如何处理请求\n\n值得说明的是，具体选择线程还是进程，更多是与平台及编程语言相关，例如C语言使用线程和进程都可以(例如Nginx使用进程，Memcached使用线程)，Java语言一般使用线程(例如Netty)，为了描述方便，下面都使用线程来进程描述\n\n## 3.1 传统阻塞I/O服务模型\n\n\n\n![传统阻塞I/O服务模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae480ba5f)\n\n\n\n**特点**\n\n- 采用阻塞式I/O模型获取输入数据\n- 每个连接都需要独立的线程完成数据输入，业务处理，数据返回的完整操作\n\n**存在问题**\n\n- 当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大\n- 连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费\n\n## 3.2 Reactor模式\n\n针对传统传统阻塞I/O服务模型的2个缺点，比较常见的有如下解决方案：\n\n- 基于I/O复用模型，多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理\n- 基于线程池复用线程资源，不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务\n\nI/O复用结合线程池，这就是Reactor模式基本设计思想\n\n\n\n![Reactor](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae52f75de)\n\n\n\n**Reactor模式**，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I/O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)，是编写高性能网络服务器的必备技术之一\n\nReactor模式中有2个关键组成：\n\n- Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人\n- Handlers 处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作\n\n根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现：\n\n- 单Reactor单线程\n- 单Reactor多线程\n- 主从Reactor多线程\n\n下面详细介绍这3种实现\n\n### 3.2.1 单Reactor单线程\n\n\n\n![单Reactor单线程](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae57487c5)\n\n\n\n其中，select是前面**I/O复用模型**介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求，其他方案示意图类似\n\n**方案说明**\n\n- Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发\n- 如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理\n- 如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应\n- Handler会完成read->业务处理->send的完整业务流程\n\n**优点** 模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成\n\n**缺点**\n\n- 性能问题：只有一个线程，无法完全发挥多核CPU的性能 Handler在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈\n- 可靠性问题：线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障\n\n**使用场景** 客户端的数量有限，业务处理非常快速，比如Redis，业务处理的时间复杂度O(1)\n\n### 3.2.2 单Reactor多线程\n\n\n\n![单Reactor多线程](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae74362df)\n\n\n\n**方案说明**\n\n- Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发\n- 如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的续各种事件\n- 如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应\n- Handler只负责响应事件，不做具体业务处理，通过read读取数据后，会分发给后面的Worker线程池进行业务处理\n- Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理\n- Handler收到响应结果后通过send将响应结果返回给client\n\n**优点** 可以充分利用多核CPU的处理能力\n\n**缺点**\n\n- 多线程数据共享和访问比较复杂\n- Reactor承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈\n\n### 3.2.3 主从Reactor多线程\n\n针对单Reactor多线程模型中，Reactor在单线程中运行，高并发场景下容易成为性能瓶颈，可以让Reactor在多线程中运行\n\n\n\n![主从Reactor多线程](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723b8948bc3f)\n\n\n\n**方案说明**\n\n- Reactor主线程MainReactor对象通过select监控建立连接事件，收到事件后通过Acceptor接收，处理建立连接事件\n- Accepto处理建立连接事件后，MainReactor将连接分配Reactor子线程给SubReactor进行处理\n- SubReactor将连接加入连接队列进行监听，并创建一个Handler用于处理各种连接事件\n- 当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应\n- Handler通过read读取数据后，会分发给后面的Worker线程池进行业务处理\n- Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理\n- Handler收到响应结果后通过send将响应结果返回给client\n\n**优点**\n\n- 父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理\n- 父线程与子线程的数据交互简单，Reactor主线程只需要把新连接传给子线程，子线程无需返回数据\n\n这种模型在许多项目中广泛使用，包括Nginx主从Reactor多进程模型，Memcached主从多线程，Netty主从多线程模型的支持\n\n### 3.2.4 总结\n\n3种模式可以用个比喻来理解： 餐厅常常雇佣接待员负责迎接顾客，当顾客入坐后，侍应生专门为这张桌子服务\n\n- 单Reactor单线程 接待员和侍应生是同一个人，全程为顾客服务\n- 单Reactor多线程 1个接待员，多个侍应生，接待员只负责接待\n- 主从Reactor多线程 多个接待员，多个侍应生\n\nReactor模式具有如下的优点：\n\n- 响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的\n- 编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；\n- 可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源\n- 可复用性，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性\n\n# 概述\n\nNetty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。\n\n## NIO的问题\n\n- NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等\n- 需要熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序\n- 可靠性能力问题，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等\n- JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%\n\n## Netty的特点\n\nNetty的对JDK自带的NIO的API进行封装，解决上述问题，主要特点有：\n\n- 设计优雅 适用于各种传输类型的统一API\n- 高性能 吞吐量更高，延迟更低 减少资源消耗 最小化不必要的内存复制\n- 安全 完整的SSL / TLS和StartTLS支持\n\n## Netty常见使用场景\n\n- 互联网行业 在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高新能的通信框架,往往作为基础通信组件被这些RPC框架使用。 典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。\n- 游戏行业 无论是手游服务端还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈。 非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过Netty进行高性能的通信\n- 大数据领域 经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨界点通信，它的Netty Service基于Netty框架二次封装实现\n\n# 架构\n\n## 理论架构\n\n### I/O复用模型\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfba53c0a)\n\n\n\n在I/O复用模型中，会用到select，这个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这个函数可以同时阻塞多个I/O操作，而且可以同时对多个读/写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数\n\nNetty的非阻塞I/O的实现关键是基于I/O复用模型，这里用Selector对象表示：\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfba32169\" alt=\"Nonblocking I/O\" style=\"zoom:67%;\" />\n\nNetty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端连接。当线程从某客户端Socket通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。\n\n由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁I/O阻塞导致的线程挂起，一个I/O线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞I/O一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。\n\n### 事件驱动模型\n\n通常，我们设计一个事件处理模型的程序有两种思路\n\n- 轮询方式 线程不断轮询访问相关事件发生源有没有发生事件，有发生事件就调用事件处理逻辑。\n- 事件驱动方式 发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑处理事件。事件驱动方式也被称为消息通知方式，其实是设计模式中**观察者模式**的思路。\n\n以GUI的逻辑处理为例，说明两种逻辑的不同：\n\n- 轮询方式 线程不断轮询是否发生按钮点击事件，如果发生，调用处理逻辑\n- 事件驱动方式 发生点击事件把事件放入事件队列，在另外线程消费的事件列表中的事件，根据事件类型调用相关事件处理逻辑\n\n![事件驱动模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfbdf3439)\n\n主要包括4个基本组件：\n\n- 事件队列（event queue）：接收事件的入口，存储待处理事件\n- 分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元\n- 事件通道（event channel）：分发器与处理器之间的联系渠道\n- 事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作\n\n可以看出，相对传统轮询模式，事件驱动有如下优点：\n\n- 可扩展性好，分布式的异步架构，事件处理器之间高度解耦，可以方便扩展事件处理逻辑\n- 高性能，基于队列暂存事件，能方便并行异步处理事件\n\n### Reactor线程模型\n\nReactor是反应堆的意思，Reactor模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的**事件驱动处理模式**。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I/O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)，是编写高性能网络服务器的必备技术之一。\n\nReactor模型中有2个关键组成：\n\n- Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人\n- Handlers 处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作\n\n\n\n![Reactor模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc654d6dc)\n\n\n\n取决于Reactor的数量和Hanndler线程数量的不同，Reactor模型有3个变种\n\n- 单Reactor单线程\n- 单Reactor多线程\n- 主从Reactor多线程\n\n可以这样理解，Reactor就是一个执行while (true) { selector.select(); ...}循环的线程，会源源不断的产生新的事件，称作反应堆很贴切。\n\n### Netty线程模型\n\nNetty主要**基于主从Reactors多线程模型**做了一定的修改，其中主从Reactor多线程模型有多个Reactor：MainReactor和SubReactor：\n\n- MainReactor负责客户端的连接请求，并将请求转交给SubReactor\n- SubReactor负责相应通道的IO读写请求\n- 非IO请求（具体逻辑处理）的任务则会直接写入队列，等待worker threads进行处理\n\n![主从Rreactor多线程模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc698ddd6)\n\n\n\n特别说明的是： 虽然Netty的线程模型基于主从Reactor多线程，借用了MainReactor和SubReactor的结构，但是实际实现上，SubReactor和Worker线程在同一个线程池中：\n\n```java\nEventLoopGroup bossGroup = new NioEventLoopGroup();\nEventLoopGroup workerGroup = new NioEventLoopGroup();\nServerBootstrap server = new ServerBootstrap();\nserver.group(bossGroup, workerGroup)\n .channel(NioServerSocketChannel.class)\n```\n\n上面代码中的bossGroup 和workerGroup是Bootstrap构造方法中传入的两个对象，这两个group均是线程池\n\n- bossGroup线程池则只是在bind某个端口后，获得其中一个线程作为MainReactor，专门处理端口的accept事件，**每个端口对应一个boss线程**\n- workerGroup线程池会被各个SubReactor和worker线程充分利用\n\n### 异步处理\n\n异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。\n\nNetty中的I/O操作是异步的，包括bind、write、connect等操作会简单的返回一个ChannelFuture，调用者并不能立刻获得结果，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。\n\n当future对象刚刚创建时，处于非完成状态，调用者可以通过返回的ChannelFuture来获取操作执行的状态，注册监听函数来执行完成后的操，常见有如下操作：\n\n- 通过isDone方法来判断当前操作是否完成\n- 通过isSuccess方法来判断已完成的当前操作是否成功\n- 通过getCause方法来获取已完成的当前操作失败的原因\n- 通过isCancelled方法来判断已完成的当前操作是否被取消\n- 通过addListener方法来注册监听器，当操作已完成(isDone方法返回完成)，将会通知指定的监听器；如果future对象已完成，则理解通知指定的监听器\n\n例如下面的的代码中绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑\n\n```java\n    serverBootstrap.bind(port).addListener(future -> {\n        if (future.isSuccess()) {\n            System.out.println(new Date() + \": 端口[\" + port + \"]绑定成功!\");\n        } else {\n            System.err.println(\"端口[\" + port + \"]绑定失败!\");\n        }\n    });\n```\n\n相比传统阻塞I/O，执行I/O操作后线程会被阻塞住, 直到操作完成；异步处理的好处是不会造成线程阻塞，线程在I/O操作期间可以执行别的程序，在高并发情形下会更稳定和更高的吞吐量。\n\n## Netty架构设计\n\n### Bootstrap、ServerBootstrap\n\nBootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类。\n\n### Future、ChannelFuture\n\n正如前面介绍，在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理，但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。\n\n​\t\tNetty 中所有的 I/O 操作都是异步的，即操作不会立即得到返回结果，所以 Netty 中定义了一个 ChannelFuture 对象作为这个异步操作的“代言人”，表示异步操作本身。如果想获取到该异步操作的返回值，可以通过该异步操作对象的addListener() 方法为该异步操作添加监 NIO 网络编程框架 Netty 听器，为其注册回调：当结果出来后马上调用执行。\n\n​\t\tNetty 的异步编程模型都是建立在 Future 与回调概念之上的。\n\n### Channel\n\nNetty网络通信的组件，能够用于执行网络I/O操作。 Channel为用户提供：\n\n- 当前网络连接的通道的状态（例如是否打开？是否已连接？）\n- 网络连接的配置参数 （例如接收缓冲区大小）\n- 提供异步的网络I/O操作(如建立连接，读写，绑定端口)，异步调用意味着任何I / O调用都将立即返回，并且不保证在调用结束时所请求的I / O操作已完成。调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以I / O操作成功、失败或取消时回调通知调用方。\n- 支持关联I/O操作与对应的处理程序\n\n不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，下面是一些常用的 Channel 类型\n\n- NioSocketChannel，异步的客户端 TCP Socket 连接\n- NioServerSocketChannel，异步的服务器端 TCP Socket 连接\n- NioDatagramChannel，异步的 UDP 连接\n- NioSctpChannel，异步的客户端 Sctp 连接\n- NioSctpServerChannel，异步的 Sctp 服务器端连接 这些通道涵盖了 UDP 和 TCP网络 IO以及文件 IO.\n\n### Selector\n\nNetty基于Selector对象实现I/O多路复用，通过 Selector, 一个线程可以监听多个连接的Channel事件, 当向一个Selector中注册Channel 后，Selector 内部的机制就可以自动不断地查询(select) 这些注册的Channel是否有已就绪的I/O事件(例如可读, 可写, 网络连接完成等)，这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。\n\n### NioEventLoop\n\nNioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop的run方法，执行I/O任务和非I/O任务：\n\n- I/O任务 即selectionKey中ready的事件，如accept、connect、read、write等，由processSelectedKeys方法触发。\n- 非IO任务 添加到taskQueue中的任务，如register0、bind0等任务，由runAllTasks方法触发。\n\n两种任务的执行时间比由变量ioRatio控制，默认为50，则表示允许非IO任务执行的时间与IO任务的执行时间相等。\n\n EventLoop 定义了Netty的核心抽象，用来处理连接的生命周期中所发生的事件，在内部，将会为每个Channel分配一个EventLoop。\n\n​\t\tNetty 为每个 Channel 分配了一个 EventLoop，用于处理用户连接请求、对用户请求的处理等所有事件。EventLoop 本身只是一个线程驱动，在其生命周期内只会绑定一个线程，让该线程处理一个 Channel 的所有 IO 事件。\n\n​\t\t一个 Channel 一旦与一个 EventLoop 相绑定，那么在 Channel 的整个生命周期内是不能改变的。一个 EventLoop 可以与多个 Channel 绑定。即 Channel 与 EventLoop 的关系是 n:1，而 EventLoop 与线程的关系是 1:1。\n\n\n作者：敖丙\n链接：https://juejin.cn/post/6921858121774137352\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n### NioEventLoopGroup\n\nNioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个Channel上的事件，而一个Channel只对应于一个线程。\n\n### ChannelHandler\n\nChannelHandler是一个接口，处理I / O事件或拦截I / O操作，并将其转发到其ChannelPipeline(业务处理链)中的下一个处理程序。\n\nChannelHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：\n\n- ChannelInboundHandler用于处理入站I / O事件\n- ChannelOutboundHandler用于处理出站I / O操作\n\n或者使用以下适配器类：\n\n- ChannelInboundHandlerAdapter用于处理入站I / O事件\n- ChannelOutboundHandlerAdapter用于处理出站I / O操作\n- ChannelDuplexHandler用于处理入站和出站事件\n\n​\t\tChannelHandler 是对 Channel 中数据的处理器，这些处理器可以是系统本身定义好的编解码器，也可以是用户自定义的。这些处理器会被统一添加到一个 ChannelPipeline 的对象中，然后按照添加的顺序对 Channel 中的数据进行依次处理。\n\n\n\n\n### ChannelHandlerContext\n\n保存Channel相关的所有上下文信息，同时关联一个ChannelHandler对象\n\n### ChannelPipline\n\n保存ChannelHandler的List，用于处理或拦截Channel的入站事件和出站操作。 ChannelPipeline实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及Channel中各个的ChannelHandler如何相互交互。\n\n下图引用Netty的Javadoc4.1中ChannelPipline的说明，描述了ChannelPipeline中ChannelHandler通常如何处理I/O事件。 I/O事件由ChannelInboundHandler或ChannelOutboundHandler处理，并通过调用ChannelHandlerContext中定义的事件传播方法（例如ChannelHandlerContext.fireChannelRead（Object）和ChannelOutboundInvoker.write（Object））转发到其最近的处理程序。\n\n```\n                                                 I/O Request\n                                            via Channel or\n                                        ChannelHandlerContext\n                                                      |\n  +---------------------------------------------------+---------------+\n  |                           ChannelPipeline         |               |\n  |                                                  \\|/              |\n  |    +---------------------+            +-----------+----------+    |\n  |    | Inbound Handler  N  |            | Outbound Handler  1  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  |               |                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  .               |\n  |               .                                   .               |\n  | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|\n  |        [ method call]                       [method call]         |\n  |               .                                   .               |\n  |               .                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  |               |                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler  1  |            | Outbound Handler  M  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  +---------------+-----------------------------------+---------------+\n                  |                                  \\|/\n  +---------------+-----------------------------------+---------------+\n  |               |                                   |               |\n  |       [ Socket.read() ]                    [ Socket.write() ]     |\n  |                                                                   |\n  |  Netty Internal I/O Threads (Transport Implementation)            |\n  +-------------------------------------------------------------------+\n```\n\n入站事件由自下而上方向的入站处理程序处理，如图左侧所示。 入站Handler处理程序通常处理由图底部的I / O线程生成的入站数据。 通常通过实际输入操作（例如SocketChannel.read（ByteBuffer））从远程读取入站数据。\n\n出站事件由上下方向处理，如图右侧所示。 出站Handler处理程序通常会生成或转换出站传输，例如write请求。 I/O线程通常执行实际的输出操作，例如SocketChannel.write（ByteBuffer）。\n\n在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应, 它们的组成关系如下:\n\n\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc8cd1a2f)\n\n\n\n一个 Channel 包含了一个 ChannelPipeline, 而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表, 并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。入站事件和出站事件在一个双向链表中，入站事件会从链表head往后传递到最后一个入站的handler，出站事件会从链表tail往前传递到最前一个出站的handler，两种类型的handler互不干扰。\n\n# 工作流程\n\n初始化并启动Netty服务端过程如下：\n\n```java\n    public static void main(String[] args) {\n        // 创建mainReactor\n        NioEventLoopGroup boosGroup = new NioEventLoopGroup();\n        // 创建工作线程组\n        NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        final ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap \n                 // 组装NioEventLoopGroup \n                .group(boosGroup, workerGroup)\n                 // 设置channel类型为NIO类型\n                .channel(NioServerSocketChannel.class)\n                // 设置连接配置参数\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                // 配置入站、出站事件handler\n                .childHandler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        // 配置入站、出站事件channel\n                        ch.pipeline().addLast(...);\n                        ch.pipeline().addLast(...);\n                    }\n    });\n\n        // 绑定端口\n        int port = 8080;\n        serverBootstrap.bind(port).addListener(future -> {\n            if (future.isSuccess()) {\n                System.out.println(new Date() + \": 端口[\" + port + \"]绑定成功!\");\n            } else {\n                System.err.println(\"端口[\" + port + \"]绑定失败!\");\n            }\n        });\n}\n```\n\n- 基本过程如下：\n- 1 初始化创建2个NioEventLoopGroup，其中boosGroup用于Accetpt连接建立事件并分发请求， workerGroup用于处理I/O读写事件和业务逻辑\n- 2  基于ServerBootstrap(服务端启动引导类)，配置EventLoopGroup、Channel类型，连接参数、配置入站、出站事件handler\n- 3 绑定端口，开始工作\n\n结合上面的介绍的Netty Reactor模型，介绍服务端Netty的工作架构图：\n\n\n\n![服务端Netty Reactor工作架构图](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc9a7cabe)\n\n\n\nserver端包含1个Boss NioEventLoopGroup和1个Worker NioEventLoopGroup，NioEventLoopGroup相当于1个事件循环组，这个组里包含多个事件循环NioEventLoop，每个NioEventLoop包含1个selector和1个事件循环线程。\n\n每个Boss NioEventLoop循环执行的任务包含3步：\n\n- 1 轮询accept事件\n- 2 处理accept I/O事件，与Client建立连接，生成NioSocketChannel，并将NioSocketChannel注册到某个Worker NioEventLoop的Selector上 *3 处理任务队列中的任务，runAllTasks。任务队列中的任务包括用户调用eventloop.execute或schedule执行的任务，或者其它线程提交到该eventloop的任务。\n\n每个Worker NioEventLoop循环执行的任务包含3步：\n\n- 1 轮询read、write事件；\n- 2 处I/O事件，即read、write事件，在NioSocketChannel可读、可写事件发生时进行处理\n- 3 处理任务队列中的任务，runAllTasks。\n\n其中任务队列中的task有3种典型使用场景\n\n- 1 用户程序自定义的普通任务\n\n```java\nctx.channel().eventLoop().execute(new Runnable() {\n    @Override\n    public void run() {\n        //...\n    }\n});\n```\n\n- 2 非当前reactor线程调用channel的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的channel引用，然后调用write类方法向该用户推送消息，就会进入到这种场景。最终的write会提交到任务队列中后被异步消费。\n- 3 用户自定义定时任务\n\n```java\nctx.channel().eventLoop().schedule(new Runnable() {\n    @Override\n    public void run() {\n\n    }\n}, 60, TimeUnit.SECONDS);\n```\n\n## Netty 执行流程\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/f692ce289a3e4c518306820fcb6114d3~tplv-k3u1fbpfcp-zoom-1.image)","source":"_posts/计算机基础/计算机网络/Netty.md","raw":"---\ntitle: Netty\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 学习Netty所做的笔记，包括线程模型、Reactor模式、Netty源码分析等。\ncategories: 计算机网络\ntags:\n  - 线程模型\n  - 设计模式\n  - 开源框架\nabbrlink: 1c6ba3e2\ndate: 2021-05-27 00:00:00\n---\n\n\n\n# 线程模型\n\n介绍完服务器如何基于I/O模型管理连接，获取输入数据，下面介绍基于进程/线程模型，服务器如何处理请求\n\n值得说明的是，具体选择线程还是进程，更多是与平台及编程语言相关，例如C语言使用线程和进程都可以(例如Nginx使用进程，Memcached使用线程)，Java语言一般使用线程(例如Netty)，为了描述方便，下面都使用线程来进程描述\n\n## 3.1 传统阻塞I/O服务模型\n\n\n\n![传统阻塞I/O服务模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae480ba5f)\n\n\n\n**特点**\n\n- 采用阻塞式I/O模型获取输入数据\n- 每个连接都需要独立的线程完成数据输入，业务处理，数据返回的完整操作\n\n**存在问题**\n\n- 当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大\n- 连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费\n\n## 3.2 Reactor模式\n\n针对传统传统阻塞I/O服务模型的2个缺点，比较常见的有如下解决方案：\n\n- 基于I/O复用模型，多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理\n- 基于线程池复用线程资源，不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务\n\nI/O复用结合线程池，这就是Reactor模式基本设计思想\n\n\n\n![Reactor](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae52f75de)\n\n\n\n**Reactor模式**，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I/O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)，是编写高性能网络服务器的必备技术之一\n\nReactor模式中有2个关键组成：\n\n- Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人\n- Handlers 处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作\n\n根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现：\n\n- 单Reactor单线程\n- 单Reactor多线程\n- 主从Reactor多线程\n\n下面详细介绍这3种实现\n\n### 3.2.1 单Reactor单线程\n\n\n\n![单Reactor单线程](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae57487c5)\n\n\n\n其中，select是前面**I/O复用模型**介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求，其他方案示意图类似\n\n**方案说明**\n\n- Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发\n- 如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理\n- 如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应\n- Handler会完成read->业务处理->send的完整业务流程\n\n**优点** 模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成\n\n**缺点**\n\n- 性能问题：只有一个线程，无法完全发挥多核CPU的性能 Handler在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈\n- 可靠性问题：线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障\n\n**使用场景** 客户端的数量有限，业务处理非常快速，比如Redis，业务处理的时间复杂度O(1)\n\n### 3.2.2 单Reactor多线程\n\n\n\n![单Reactor多线程](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae74362df)\n\n\n\n**方案说明**\n\n- Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发\n- 如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的续各种事件\n- 如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应\n- Handler只负责响应事件，不做具体业务处理，通过read读取数据后，会分发给后面的Worker线程池进行业务处理\n- Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理\n- Handler收到响应结果后通过send将响应结果返回给client\n\n**优点** 可以充分利用多核CPU的处理能力\n\n**缺点**\n\n- 多线程数据共享和访问比较复杂\n- Reactor承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈\n\n### 3.2.3 主从Reactor多线程\n\n针对单Reactor多线程模型中，Reactor在单线程中运行，高并发场景下容易成为性能瓶颈，可以让Reactor在多线程中运行\n\n\n\n![主从Reactor多线程](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723b8948bc3f)\n\n\n\n**方案说明**\n\n- Reactor主线程MainReactor对象通过select监控建立连接事件，收到事件后通过Acceptor接收，处理建立连接事件\n- Accepto处理建立连接事件后，MainReactor将连接分配Reactor子线程给SubReactor进行处理\n- SubReactor将连接加入连接队列进行监听，并创建一个Handler用于处理各种连接事件\n- 当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应\n- Handler通过read读取数据后，会分发给后面的Worker线程池进行业务处理\n- Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理\n- Handler收到响应结果后通过send将响应结果返回给client\n\n**优点**\n\n- 父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理\n- 父线程与子线程的数据交互简单，Reactor主线程只需要把新连接传给子线程，子线程无需返回数据\n\n这种模型在许多项目中广泛使用，包括Nginx主从Reactor多进程模型，Memcached主从多线程，Netty主从多线程模型的支持\n\n### 3.2.4 总结\n\n3种模式可以用个比喻来理解： 餐厅常常雇佣接待员负责迎接顾客，当顾客入坐后，侍应生专门为这张桌子服务\n\n- 单Reactor单线程 接待员和侍应生是同一个人，全程为顾客服务\n- 单Reactor多线程 1个接待员，多个侍应生，接待员只负责接待\n- 主从Reactor多线程 多个接待员，多个侍应生\n\nReactor模式具有如下的优点：\n\n- 响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的\n- 编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；\n- 可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源\n- 可复用性，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性\n\n# 概述\n\nNetty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。\n\n## NIO的问题\n\n- NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等\n- 需要熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序\n- 可靠性能力问题，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等\n- JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%\n\n## Netty的特点\n\nNetty的对JDK自带的NIO的API进行封装，解决上述问题，主要特点有：\n\n- 设计优雅 适用于各种传输类型的统一API\n- 高性能 吞吐量更高，延迟更低 减少资源消耗 最小化不必要的内存复制\n- 安全 完整的SSL / TLS和StartTLS支持\n\n## Netty常见使用场景\n\n- 互联网行业 在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高新能的通信框架,往往作为基础通信组件被这些RPC框架使用。 典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。\n- 游戏行业 无论是手游服务端还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈。 非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过Netty进行高性能的通信\n- 大数据领域 经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨界点通信，它的Netty Service基于Netty框架二次封装实现\n\n# 架构\n\n## 理论架构\n\n### I/O复用模型\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfba53c0a)\n\n\n\n在I/O复用模型中，会用到select，这个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这个函数可以同时阻塞多个I/O操作，而且可以同时对多个读/写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数\n\nNetty的非阻塞I/O的实现关键是基于I/O复用模型，这里用Selector对象表示：\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfba32169\" alt=\"Nonblocking I/O\" style=\"zoom:67%;\" />\n\nNetty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端连接。当线程从某客户端Socket通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。\n\n由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁I/O阻塞导致的线程挂起，一个I/O线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞I/O一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。\n\n### 事件驱动模型\n\n通常，我们设计一个事件处理模型的程序有两种思路\n\n- 轮询方式 线程不断轮询访问相关事件发生源有没有发生事件，有发生事件就调用事件处理逻辑。\n- 事件驱动方式 发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑处理事件。事件驱动方式也被称为消息通知方式，其实是设计模式中**观察者模式**的思路。\n\n以GUI的逻辑处理为例，说明两种逻辑的不同：\n\n- 轮询方式 线程不断轮询是否发生按钮点击事件，如果发生，调用处理逻辑\n- 事件驱动方式 发生点击事件把事件放入事件队列，在另外线程消费的事件列表中的事件，根据事件类型调用相关事件处理逻辑\n\n![事件驱动模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfbdf3439)\n\n主要包括4个基本组件：\n\n- 事件队列（event queue）：接收事件的入口，存储待处理事件\n- 分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元\n- 事件通道（event channel）：分发器与处理器之间的联系渠道\n- 事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作\n\n可以看出，相对传统轮询模式，事件驱动有如下优点：\n\n- 可扩展性好，分布式的异步架构，事件处理器之间高度解耦，可以方便扩展事件处理逻辑\n- 高性能，基于队列暂存事件，能方便并行异步处理事件\n\n### Reactor线程模型\n\nReactor是反应堆的意思，Reactor模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的**事件驱动处理模式**。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I/O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)，是编写高性能网络服务器的必备技术之一。\n\nReactor模型中有2个关键组成：\n\n- Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人\n- Handlers 处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作\n\n\n\n![Reactor模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc654d6dc)\n\n\n\n取决于Reactor的数量和Hanndler线程数量的不同，Reactor模型有3个变种\n\n- 单Reactor单线程\n- 单Reactor多线程\n- 主从Reactor多线程\n\n可以这样理解，Reactor就是一个执行while (true) { selector.select(); ...}循环的线程，会源源不断的产生新的事件，称作反应堆很贴切。\n\n### Netty线程模型\n\nNetty主要**基于主从Reactors多线程模型**做了一定的修改，其中主从Reactor多线程模型有多个Reactor：MainReactor和SubReactor：\n\n- MainReactor负责客户端的连接请求，并将请求转交给SubReactor\n- SubReactor负责相应通道的IO读写请求\n- 非IO请求（具体逻辑处理）的任务则会直接写入队列，等待worker threads进行处理\n\n![主从Rreactor多线程模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc698ddd6)\n\n\n\n特别说明的是： 虽然Netty的线程模型基于主从Reactor多线程，借用了MainReactor和SubReactor的结构，但是实际实现上，SubReactor和Worker线程在同一个线程池中：\n\n```java\nEventLoopGroup bossGroup = new NioEventLoopGroup();\nEventLoopGroup workerGroup = new NioEventLoopGroup();\nServerBootstrap server = new ServerBootstrap();\nserver.group(bossGroup, workerGroup)\n .channel(NioServerSocketChannel.class)\n```\n\n上面代码中的bossGroup 和workerGroup是Bootstrap构造方法中传入的两个对象，这两个group均是线程池\n\n- bossGroup线程池则只是在bind某个端口后，获得其中一个线程作为MainReactor，专门处理端口的accept事件，**每个端口对应一个boss线程**\n- workerGroup线程池会被各个SubReactor和worker线程充分利用\n\n### 异步处理\n\n异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。\n\nNetty中的I/O操作是异步的，包括bind、write、connect等操作会简单的返回一个ChannelFuture，调用者并不能立刻获得结果，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。\n\n当future对象刚刚创建时，处于非完成状态，调用者可以通过返回的ChannelFuture来获取操作执行的状态，注册监听函数来执行完成后的操，常见有如下操作：\n\n- 通过isDone方法来判断当前操作是否完成\n- 通过isSuccess方法来判断已完成的当前操作是否成功\n- 通过getCause方法来获取已完成的当前操作失败的原因\n- 通过isCancelled方法来判断已完成的当前操作是否被取消\n- 通过addListener方法来注册监听器，当操作已完成(isDone方法返回完成)，将会通知指定的监听器；如果future对象已完成，则理解通知指定的监听器\n\n例如下面的的代码中绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑\n\n```java\n    serverBootstrap.bind(port).addListener(future -> {\n        if (future.isSuccess()) {\n            System.out.println(new Date() + \": 端口[\" + port + \"]绑定成功!\");\n        } else {\n            System.err.println(\"端口[\" + port + \"]绑定失败!\");\n        }\n    });\n```\n\n相比传统阻塞I/O，执行I/O操作后线程会被阻塞住, 直到操作完成；异步处理的好处是不会造成线程阻塞，线程在I/O操作期间可以执行别的程序，在高并发情形下会更稳定和更高的吞吐量。\n\n## Netty架构设计\n\n### Bootstrap、ServerBootstrap\n\nBootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类。\n\n### Future、ChannelFuture\n\n正如前面介绍，在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理，但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。\n\n​\t\tNetty 中所有的 I/O 操作都是异步的，即操作不会立即得到返回结果，所以 Netty 中定义了一个 ChannelFuture 对象作为这个异步操作的“代言人”，表示异步操作本身。如果想获取到该异步操作的返回值，可以通过该异步操作对象的addListener() 方法为该异步操作添加监 NIO 网络编程框架 Netty 听器，为其注册回调：当结果出来后马上调用执行。\n\n​\t\tNetty 的异步编程模型都是建立在 Future 与回调概念之上的。\n\n### Channel\n\nNetty网络通信的组件，能够用于执行网络I/O操作。 Channel为用户提供：\n\n- 当前网络连接的通道的状态（例如是否打开？是否已连接？）\n- 网络连接的配置参数 （例如接收缓冲区大小）\n- 提供异步的网络I/O操作(如建立连接，读写，绑定端口)，异步调用意味着任何I / O调用都将立即返回，并且不保证在调用结束时所请求的I / O操作已完成。调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以I / O操作成功、失败或取消时回调通知调用方。\n- 支持关联I/O操作与对应的处理程序\n\n不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，下面是一些常用的 Channel 类型\n\n- NioSocketChannel，异步的客户端 TCP Socket 连接\n- NioServerSocketChannel，异步的服务器端 TCP Socket 连接\n- NioDatagramChannel，异步的 UDP 连接\n- NioSctpChannel，异步的客户端 Sctp 连接\n- NioSctpServerChannel，异步的 Sctp 服务器端连接 这些通道涵盖了 UDP 和 TCP网络 IO以及文件 IO.\n\n### Selector\n\nNetty基于Selector对象实现I/O多路复用，通过 Selector, 一个线程可以监听多个连接的Channel事件, 当向一个Selector中注册Channel 后，Selector 内部的机制就可以自动不断地查询(select) 这些注册的Channel是否有已就绪的I/O事件(例如可读, 可写, 网络连接完成等)，这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。\n\n### NioEventLoop\n\nNioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop的run方法，执行I/O任务和非I/O任务：\n\n- I/O任务 即selectionKey中ready的事件，如accept、connect、read、write等，由processSelectedKeys方法触发。\n- 非IO任务 添加到taskQueue中的任务，如register0、bind0等任务，由runAllTasks方法触发。\n\n两种任务的执行时间比由变量ioRatio控制，默认为50，则表示允许非IO任务执行的时间与IO任务的执行时间相等。\n\n EventLoop 定义了Netty的核心抽象，用来处理连接的生命周期中所发生的事件，在内部，将会为每个Channel分配一个EventLoop。\n\n​\t\tNetty 为每个 Channel 分配了一个 EventLoop，用于处理用户连接请求、对用户请求的处理等所有事件。EventLoop 本身只是一个线程驱动，在其生命周期内只会绑定一个线程，让该线程处理一个 Channel 的所有 IO 事件。\n\n​\t\t一个 Channel 一旦与一个 EventLoop 相绑定，那么在 Channel 的整个生命周期内是不能改变的。一个 EventLoop 可以与多个 Channel 绑定。即 Channel 与 EventLoop 的关系是 n:1，而 EventLoop 与线程的关系是 1:1。\n\n\n作者：敖丙\n链接：https://juejin.cn/post/6921858121774137352\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n### NioEventLoopGroup\n\nNioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个Channel上的事件，而一个Channel只对应于一个线程。\n\n### ChannelHandler\n\nChannelHandler是一个接口，处理I / O事件或拦截I / O操作，并将其转发到其ChannelPipeline(业务处理链)中的下一个处理程序。\n\nChannelHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：\n\n- ChannelInboundHandler用于处理入站I / O事件\n- ChannelOutboundHandler用于处理出站I / O操作\n\n或者使用以下适配器类：\n\n- ChannelInboundHandlerAdapter用于处理入站I / O事件\n- ChannelOutboundHandlerAdapter用于处理出站I / O操作\n- ChannelDuplexHandler用于处理入站和出站事件\n\n​\t\tChannelHandler 是对 Channel 中数据的处理器，这些处理器可以是系统本身定义好的编解码器，也可以是用户自定义的。这些处理器会被统一添加到一个 ChannelPipeline 的对象中，然后按照添加的顺序对 Channel 中的数据进行依次处理。\n\n\n\n\n### ChannelHandlerContext\n\n保存Channel相关的所有上下文信息，同时关联一个ChannelHandler对象\n\n### ChannelPipline\n\n保存ChannelHandler的List，用于处理或拦截Channel的入站事件和出站操作。 ChannelPipeline实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及Channel中各个的ChannelHandler如何相互交互。\n\n下图引用Netty的Javadoc4.1中ChannelPipline的说明，描述了ChannelPipeline中ChannelHandler通常如何处理I/O事件。 I/O事件由ChannelInboundHandler或ChannelOutboundHandler处理，并通过调用ChannelHandlerContext中定义的事件传播方法（例如ChannelHandlerContext.fireChannelRead（Object）和ChannelOutboundInvoker.write（Object））转发到其最近的处理程序。\n\n```\n                                                 I/O Request\n                                            via Channel or\n                                        ChannelHandlerContext\n                                                      |\n  +---------------------------------------------------+---------------+\n  |                           ChannelPipeline         |               |\n  |                                                  \\|/              |\n  |    +---------------------+            +-----------+----------+    |\n  |    | Inbound Handler  N  |            | Outbound Handler  1  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  |               |                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  .               |\n  |               .                                   .               |\n  | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|\n  |        [ method call]                       [method call]         |\n  |               .                                   .               |\n  |               .                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  |               |                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler  1  |            | Outbound Handler  M  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  +---------------+-----------------------------------+---------------+\n                  |                                  \\|/\n  +---------------+-----------------------------------+---------------+\n  |               |                                   |               |\n  |       [ Socket.read() ]                    [ Socket.write() ]     |\n  |                                                                   |\n  |  Netty Internal I/O Threads (Transport Implementation)            |\n  +-------------------------------------------------------------------+\n```\n\n入站事件由自下而上方向的入站处理程序处理，如图左侧所示。 入站Handler处理程序通常处理由图底部的I / O线程生成的入站数据。 通常通过实际输入操作（例如SocketChannel.read（ByteBuffer））从远程读取入站数据。\n\n出站事件由上下方向处理，如图右侧所示。 出站Handler处理程序通常会生成或转换出站传输，例如write请求。 I/O线程通常执行实际的输出操作，例如SocketChannel.write（ByteBuffer）。\n\n在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应, 它们的组成关系如下:\n\n\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc8cd1a2f)\n\n\n\n一个 Channel 包含了一个 ChannelPipeline, 而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表, 并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。入站事件和出站事件在一个双向链表中，入站事件会从链表head往后传递到最后一个入站的handler，出站事件会从链表tail往前传递到最前一个出站的handler，两种类型的handler互不干扰。\n\n# 工作流程\n\n初始化并启动Netty服务端过程如下：\n\n```java\n    public static void main(String[] args) {\n        // 创建mainReactor\n        NioEventLoopGroup boosGroup = new NioEventLoopGroup();\n        // 创建工作线程组\n        NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        final ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap \n                 // 组装NioEventLoopGroup \n                .group(boosGroup, workerGroup)\n                 // 设置channel类型为NIO类型\n                .channel(NioServerSocketChannel.class)\n                // 设置连接配置参数\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                // 配置入站、出站事件handler\n                .childHandler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        // 配置入站、出站事件channel\n                        ch.pipeline().addLast(...);\n                        ch.pipeline().addLast(...);\n                    }\n    });\n\n        // 绑定端口\n        int port = 8080;\n        serverBootstrap.bind(port).addListener(future -> {\n            if (future.isSuccess()) {\n                System.out.println(new Date() + \": 端口[\" + port + \"]绑定成功!\");\n            } else {\n                System.err.println(\"端口[\" + port + \"]绑定失败!\");\n            }\n        });\n}\n```\n\n- 基本过程如下：\n- 1 初始化创建2个NioEventLoopGroup，其中boosGroup用于Accetpt连接建立事件并分发请求， workerGroup用于处理I/O读写事件和业务逻辑\n- 2  基于ServerBootstrap(服务端启动引导类)，配置EventLoopGroup、Channel类型，连接参数、配置入站、出站事件handler\n- 3 绑定端口，开始工作\n\n结合上面的介绍的Netty Reactor模型，介绍服务端Netty的工作架构图：\n\n\n\n![服务端Netty Reactor工作架构图](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc9a7cabe)\n\n\n\nserver端包含1个Boss NioEventLoopGroup和1个Worker NioEventLoopGroup，NioEventLoopGroup相当于1个事件循环组，这个组里包含多个事件循环NioEventLoop，每个NioEventLoop包含1个selector和1个事件循环线程。\n\n每个Boss NioEventLoop循环执行的任务包含3步：\n\n- 1 轮询accept事件\n- 2 处理accept I/O事件，与Client建立连接，生成NioSocketChannel，并将NioSocketChannel注册到某个Worker NioEventLoop的Selector上 *3 处理任务队列中的任务，runAllTasks。任务队列中的任务包括用户调用eventloop.execute或schedule执行的任务，或者其它线程提交到该eventloop的任务。\n\n每个Worker NioEventLoop循环执行的任务包含3步：\n\n- 1 轮询read、write事件；\n- 2 处I/O事件，即read、write事件，在NioSocketChannel可读、可写事件发生时进行处理\n- 3 处理任务队列中的任务，runAllTasks。\n\n其中任务队列中的task有3种典型使用场景\n\n- 1 用户程序自定义的普通任务\n\n```java\nctx.channel().eventLoop().execute(new Runnable() {\n    @Override\n    public void run() {\n        //...\n    }\n});\n```\n\n- 2 非当前reactor线程调用channel的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的channel引用，然后调用write类方法向该用户推送消息，就会进入到这种场景。最终的write会提交到任务队列中后被异步消费。\n- 3 用户自定义定时任务\n\n```java\nctx.channel().eventLoop().schedule(new Runnable() {\n    @Override\n    public void run() {\n\n    }\n}, 60, TimeUnit.SECONDS);\n```\n\n## Netty 执行流程\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/f692ce289a3e4c518306820fcb6114d3~tplv-k3u1fbpfcp-zoom-1.image)","slug":"计算机基础/计算机网络/Netty","published":1,"updated":"2021-06-08T03:35:00.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq514000zz0tpf6q7au1y","content":"<h1 id=\"线程模型\"><a href=\"#线程模型\" class=\"headerlink\" title=\"线程模型\"></a>线程模型</h1><p>介绍完服务器如何基于I/O模型管理连接，获取输入数据，下面介绍基于进程/线程模型，服务器如何处理请求</p>\n<p>值得说明的是，具体选择线程还是进程，更多是与平台及编程语言相关，例如C语言使用线程和进程都可以(例如Nginx使用进程，Memcached使用线程)，Java语言一般使用线程(例如Netty)，为了描述方便，下面都使用线程来进程描述</p>\n<h2 id=\"3-1-传统阻塞I-O服务模型\"><a href=\"#3-1-传统阻塞I-O服务模型\" class=\"headerlink\" title=\"3.1 传统阻塞I/O服务模型\"></a>3.1 传统阻塞I/O服务模型</h2><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae480ba5f\" alt=\"传统阻塞I/O服务模型\"></p>\n<p><strong>特点</strong></p>\n<ul>\n<li>采用阻塞式I/O模型获取输入数据</li>\n<li>每个连接都需要独立的线程完成数据输入，业务处理，数据返回的完整操作</li>\n</ul>\n<p><strong>存在问题</strong></p>\n<ul>\n<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li>\n<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费</li>\n</ul>\n<h2 id=\"3-2-Reactor模式\"><a href=\"#3-2-Reactor模式\" class=\"headerlink\" title=\"3.2 Reactor模式\"></a>3.2 Reactor模式</h2><p>针对传统传统阻塞I/O服务模型的2个缺点，比较常见的有如下解决方案：</p>\n<ul>\n<li>基于I/O复用模型，多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理</li>\n<li>基于线程池复用线程资源，不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务</li>\n</ul>\n<p>I/O复用结合线程池，这就是Reactor模式基本设计思想</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae52f75de\" alt=\"Reactor\"></p>\n<p><strong>Reactor模式</strong>，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I/O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)，是编写高性能网络服务器的必备技术之一</p>\n<p>Reactor模式中有2个关键组成：</p>\n<ul>\n<li>Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人</li>\n<li>Handlers 处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作</li>\n</ul>\n<p>根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现：</p>\n<ul>\n<li>单Reactor单线程</li>\n<li>单Reactor多线程</li>\n<li>主从Reactor多线程</li>\n</ul>\n<p>下面详细介绍这3种实现</p>\n<h3 id=\"3-2-1-单Reactor单线程\"><a href=\"#3-2-1-单Reactor单线程\" class=\"headerlink\" title=\"3.2.1 单Reactor单线程\"></a>3.2.1 单Reactor单线程</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae57487c5\" alt=\"单Reactor单线程\"></p>\n<p>其中，select是前面<strong>I/O复用模型</strong>介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求，其他方案示意图类似</p>\n<p><strong>方案说明</strong></p>\n<ul>\n<li>Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发</li>\n<li>如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理</li>\n<li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li>\n<li>Handler会完成read-&gt;业务处理-&gt;send的完整业务流程</li>\n</ul>\n<p><strong>优点</strong> 模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>性能问题：只有一个线程，无法完全发挥多核CPU的性能 Handler在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>\n<li>可靠性问题：线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>\n</ul>\n<p><strong>使用场景</strong> 客户端的数量有限，业务处理非常快速，比如Redis，业务处理的时间复杂度O(1)</p>\n<h3 id=\"3-2-2-单Reactor多线程\"><a href=\"#3-2-2-单Reactor多线程\" class=\"headerlink\" title=\"3.2.2 单Reactor多线程\"></a>3.2.2 单Reactor多线程</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae74362df\" alt=\"单Reactor多线程\"></p>\n<p><strong>方案说明</strong></p>\n<ul>\n<li>Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发</li>\n<li>如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的续各种事件</li>\n<li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li>\n<li>Handler只负责响应事件，不做具体业务处理，通过read读取数据后，会分发给后面的Worker线程池进行业务处理</li>\n<li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li>\n<li>Handler收到响应结果后通过send将响应结果返回给client</li>\n</ul>\n<p><strong>优点</strong> 可以充分利用多核CPU的处理能力</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>多线程数据共享和访问比较复杂</li>\n<li>Reactor承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈</li>\n</ul>\n<h3 id=\"3-2-3-主从Reactor多线程\"><a href=\"#3-2-3-主从Reactor多线程\" class=\"headerlink\" title=\"3.2.3 主从Reactor多线程\"></a>3.2.3 主从Reactor多线程</h3><p>针对单Reactor多线程模型中，Reactor在单线程中运行，高并发场景下容易成为性能瓶颈，可以让Reactor在多线程中运行</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723b8948bc3f\" alt=\"主从Reactor多线程\"></p>\n<p><strong>方案说明</strong></p>\n<ul>\n<li>Reactor主线程MainReactor对象通过select监控建立连接事件，收到事件后通过Acceptor接收，处理建立连接事件</li>\n<li>Accepto处理建立连接事件后，MainReactor将连接分配Reactor子线程给SubReactor进行处理</li>\n<li>SubReactor将连接加入连接队列进行监听，并创建一个Handler用于处理各种连接事件</li>\n<li>当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应</li>\n<li>Handler通过read读取数据后，会分发给后面的Worker线程池进行业务处理</li>\n<li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li>\n<li>Handler收到响应结果后通过send将响应结果返回给client</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</li>\n<li>父线程与子线程的数据交互简单，Reactor主线程只需要把新连接传给子线程，子线程无需返回数据</li>\n</ul>\n<p>这种模型在许多项目中广泛使用，包括Nginx主从Reactor多进程模型，Memcached主从多线程，Netty主从多线程模型的支持</p>\n<h3 id=\"3-2-4-总结\"><a href=\"#3-2-4-总结\" class=\"headerlink\" title=\"3.2.4 总结\"></a>3.2.4 总结</h3><p>3种模式可以用个比喻来理解： 餐厅常常雇佣接待员负责迎接顾客，当顾客入坐后，侍应生专门为这张桌子服务</p>\n<ul>\n<li>单Reactor单线程 接待员和侍应生是同一个人，全程为顾客服务</li>\n<li>单Reactor多线程 1个接待员，多个侍应生，接待员只负责接待</li>\n<li>主从Reactor多线程 多个接待员，多个侍应生</li>\n</ul>\n<p>Reactor模式具有如下的优点：</p>\n<ul>\n<li>响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的</li>\n<li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；</li>\n<li>可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源</li>\n<li>可复用性，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性</li>\n</ul>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</p>\n<h2 id=\"NIO的问题\"><a href=\"#NIO的问题\" class=\"headerlink\" title=\"NIO的问题\"></a>NIO的问题</h2><ul>\n<li>NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等</li>\n<li>需要熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序</li>\n<li>可靠性能力问题，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等</li>\n<li>JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%</li>\n</ul>\n<h2 id=\"Netty的特点\"><a href=\"#Netty的特点\" class=\"headerlink\" title=\"Netty的特点\"></a>Netty的特点</h2><p>Netty的对JDK自带的NIO的API进行封装，解决上述问题，主要特点有：</p>\n<ul>\n<li>设计优雅 适用于各种传输类型的统一API</li>\n<li>高性能 吞吐量更高，延迟更低 减少资源消耗 最小化不必要的内存复制</li>\n<li>安全 完整的SSL / TLS和StartTLS支持</li>\n</ul>\n<h2 id=\"Netty常见使用场景\"><a href=\"#Netty常见使用场景\" class=\"headerlink\" title=\"Netty常见使用场景\"></a>Netty常见使用场景</h2><ul>\n<li>互联网行业 在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高新能的通信框架,往往作为基础通信组件被这些RPC框架使用。 典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</li>\n<li>游戏行业 无论是手游服务端还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈。 非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过Netty进行高性能的通信</li>\n<li>大数据领域 经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨界点通信，它的Netty Service基于Netty框架二次封装实现</li>\n</ul>\n<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><h2 id=\"理论架构\"><a href=\"#理论架构\" class=\"headerlink\" title=\"理论架构\"></a>理论架构</h2><h3 id=\"I-O复用模型\"><a href=\"#I-O复用模型\" class=\"headerlink\" title=\"I/O复用模型\"></a>I/O复用模型</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfba53c0a\" alt=\"img\"></p>\n<p>在I/O复用模型中，会用到select，这个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这个函数可以同时阻塞多个I/O操作，而且可以同时对多个读/写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数</p>\n<p>Netty的非阻塞I/O的实现关键是基于I/O复用模型，这里用Selector对象表示：</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfba32169\" alt=\"Nonblocking I/O\" style=\"zoom:67%;\" />\n\n<p>Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端连接。当线程从某客户端Socket通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。</p>\n<p>由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁I/O阻塞导致的线程挂起，一个I/O线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞I/O一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p>\n<h3 id=\"事件驱动模型\"><a href=\"#事件驱动模型\" class=\"headerlink\" title=\"事件驱动模型\"></a>事件驱动模型</h3><p>通常，我们设计一个事件处理模型的程序有两种思路</p>\n<ul>\n<li>轮询方式 线程不断轮询访问相关事件发生源有没有发生事件，有发生事件就调用事件处理逻辑。</li>\n<li>事件驱动方式 发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑处理事件。事件驱动方式也被称为消息通知方式，其实是设计模式中<strong>观察者模式</strong>的思路。</li>\n</ul>\n<p>以GUI的逻辑处理为例，说明两种逻辑的不同：</p>\n<ul>\n<li>轮询方式 线程不断轮询是否发生按钮点击事件，如果发生，调用处理逻辑</li>\n<li>事件驱动方式 发生点击事件把事件放入事件队列，在另外线程消费的事件列表中的事件，根据事件类型调用相关事件处理逻辑</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfbdf3439\" alt=\"事件驱动模型\"></p>\n<p>主要包括4个基本组件：</p>\n<ul>\n<li>事件队列（event queue）：接收事件的入口，存储待处理事件</li>\n<li>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</li>\n<li>事件通道（event channel）：分发器与处理器之间的联系渠道</li>\n<li>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</li>\n</ul>\n<p>可以看出，相对传统轮询模式，事件驱动有如下优点：</p>\n<ul>\n<li>可扩展性好，分布式的异步架构，事件处理器之间高度解耦，可以方便扩展事件处理逻辑</li>\n<li>高性能，基于队列暂存事件，能方便并行异步处理事件</li>\n</ul>\n<h3 id=\"Reactor线程模型\"><a href=\"#Reactor线程模型\" class=\"headerlink\" title=\"Reactor线程模型\"></a>Reactor线程模型</h3><p>Reactor是反应堆的意思，Reactor模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的<strong>事件驱动处理模式</strong>。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I/O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)，是编写高性能网络服务器的必备技术之一。</p>\n<p>Reactor模型中有2个关键组成：</p>\n<ul>\n<li>Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人</li>\n<li>Handlers 处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc654d6dc\" alt=\"Reactor模型\"></p>\n<p>取决于Reactor的数量和Hanndler线程数量的不同，Reactor模型有3个变种</p>\n<ul>\n<li>单Reactor单线程</li>\n<li>单Reactor多线程</li>\n<li>主从Reactor多线程</li>\n</ul>\n<p>可以这样理解，Reactor就是一个执行while (true) { selector.select(); …}循环的线程，会源源不断的产生新的事件，称作反应堆很贴切。</p>\n<h3 id=\"Netty线程模型\"><a href=\"#Netty线程模型\" class=\"headerlink\" title=\"Netty线程模型\"></a>Netty线程模型</h3><p>Netty主要<strong>基于主从Reactors多线程模型</strong>做了一定的修改，其中主从Reactor多线程模型有多个Reactor：MainReactor和SubReactor：</p>\n<ul>\n<li>MainReactor负责客户端的连接请求，并将请求转交给SubReactor</li>\n<li>SubReactor负责相应通道的IO读写请求</li>\n<li>非IO请求（具体逻辑处理）的任务则会直接写入队列，等待worker threads进行处理</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc698ddd6\" alt=\"主从Rreactor多线程模型\"></p>\n<p>特别说明的是： 虽然Netty的线程模型基于主从Reactor多线程，借用了MainReactor和SubReactor的结构，但是实际实现上，SubReactor和Worker线程在同一个线程池中：</p>\n<pre class=\" language-java\"><code class=\"language-java\">EventLoopGroup bossGroup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NioEventLoopGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nEventLoopGroup workerGroup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NioEventLoopGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nServerBootstrap server <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServerBootstrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">group</span><span class=\"token punctuation\">(</span>bossGroup<span class=\"token punctuation\">,</span> workerGroup<span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span>NioServerSocketChannel<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span></code></pre>\n<p>上面代码中的bossGroup 和workerGroup是Bootstrap构造方法中传入的两个对象，这两个group均是线程池</p>\n<ul>\n<li>bossGroup线程池则只是在bind某个端口后，获得其中一个线程作为MainReactor，专门处理端口的accept事件，<strong>每个端口对应一个boss线程</strong></li>\n<li>workerGroup线程池会被各个SubReactor和worker线程充分利用</li>\n</ul>\n<h3 id=\"异步处理\"><a href=\"#异步处理\" class=\"headerlink\" title=\"异步处理\"></a>异步处理</h3><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>\n<p>Netty中的I/O操作是异步的，包括bind、write、connect等操作会简单的返回一个ChannelFuture，调用者并不能立刻获得结果，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p>\n<p>当future对象刚刚创建时，处于非完成状态，调用者可以通过返回的ChannelFuture来获取操作执行的状态，注册监听函数来执行完成后的操，常见有如下操作：</p>\n<ul>\n<li>通过isDone方法来判断当前操作是否完成</li>\n<li>通过isSuccess方法来判断已完成的当前操作是否成功</li>\n<li>通过getCause方法来获取已完成的当前操作失败的原因</li>\n<li>通过isCancelled方法来判断已完成的当前操作是否被取消</li>\n<li>通过addListener方法来注册监听器，当操作已完成(isDone方法返回完成)，将会通知指定的监听器；如果future对象已完成，则理解通知指定的监听器</li>\n</ul>\n<p>例如下面的的代码中绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>\n<pre class=\" language-java\"><code class=\"language-java\">    serverBootstrap<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addListener</span><span class=\"token punctuation\">(</span>future <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">.</span><span class=\"token function\">isSuccess</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\": 端口[\"</span> <span class=\"token operator\">+</span> port <span class=\"token operator\">+</span> <span class=\"token string\">\"]绑定成功!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"端口[\"</span> <span class=\"token operator\">+</span> port <span class=\"token operator\">+</span> <span class=\"token string\">\"]绑定失败!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>相比传统阻塞I/O，执行I/O操作后线程会被阻塞住, 直到操作完成；异步处理的好处是不会造成线程阻塞，线程在I/O操作期间可以执行别的程序，在高并发情形下会更稳定和更高的吞吐量。</p>\n<h2 id=\"Netty架构设计\"><a href=\"#Netty架构设计\" class=\"headerlink\" title=\"Netty架构设计\"></a>Netty架构设计</h2><h3 id=\"Bootstrap、ServerBootstrap\"><a href=\"#Bootstrap、ServerBootstrap\" class=\"headerlink\" title=\"Bootstrap、ServerBootstrap\"></a>Bootstrap、ServerBootstrap</h3><p>Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类。</p>\n<h3 id=\"Future、ChannelFuture\"><a href=\"#Future、ChannelFuture\" class=\"headerlink\" title=\"Future、ChannelFuture\"></a>Future、ChannelFuture</h3><p>正如前面介绍，在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理，但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p>\n<p>​        Netty 中所有的 I/O 操作都是异步的，即操作不会立即得到返回结果，所以 Netty 中定义了一个 ChannelFuture 对象作为这个异步操作的“代言人”，表示异步操作本身。如果想获取到该异步操作的返回值，可以通过该异步操作对象的addListener() 方法为该异步操作添加监 NIO 网络编程框架 Netty 听器，为其注册回调：当结果出来后马上调用执行。</p>\n<p>​        Netty 的异步编程模型都是建立在 Future 与回调概念之上的。</p>\n<h3 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h3><p>Netty网络通信的组件，能够用于执行网络I/O操作。 Channel为用户提供：</p>\n<ul>\n<li>当前网络连接的通道的状态（例如是否打开？是否已连接？）</li>\n<li>网络连接的配置参数 （例如接收缓冲区大小）</li>\n<li>提供异步的网络I/O操作(如建立连接，读写，绑定端口)，异步调用意味着任何I / O调用都将立即返回，并且不保证在调用结束时所请求的I / O操作已完成。调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以I / O操作成功、失败或取消时回调通知调用方。</li>\n<li>支持关联I/O操作与对应的处理程序</li>\n</ul>\n<p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，下面是一些常用的 Channel 类型</p>\n<ul>\n<li>NioSocketChannel，异步的客户端 TCP Socket 连接</li>\n<li>NioServerSocketChannel，异步的服务器端 TCP Socket 连接</li>\n<li>NioDatagramChannel，异步的 UDP 连接</li>\n<li>NioSctpChannel，异步的客户端 Sctp 连接</li>\n<li>NioSctpServerChannel，异步的 Sctp 服务器端连接 这些通道涵盖了 UDP 和 TCP网络 IO以及文件 IO.</li>\n</ul>\n<h3 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h3><p>Netty基于Selector对象实现I/O多路复用，通过 Selector, 一个线程可以监听多个连接的Channel事件, 当向一个Selector中注册Channel 后，Selector 内部的机制就可以自动不断地查询(select) 这些注册的Channel是否有已就绪的I/O事件(例如可读, 可写, 网络连接完成等)，这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p>\n<h3 id=\"NioEventLoop\"><a href=\"#NioEventLoop\" class=\"headerlink\" title=\"NioEventLoop\"></a>NioEventLoop</h3><p>NioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop的run方法，执行I/O任务和非I/O任务：</p>\n<ul>\n<li>I/O任务 即selectionKey中ready的事件，如accept、connect、read、write等，由processSelectedKeys方法触发。</li>\n<li>非IO任务 添加到taskQueue中的任务，如register0、bind0等任务，由runAllTasks方法触发。</li>\n</ul>\n<p>两种任务的执行时间比由变量ioRatio控制，默认为50，则表示允许非IO任务执行的时间与IO任务的执行时间相等。</p>\n<p> EventLoop 定义了Netty的核心抽象，用来处理连接的生命周期中所发生的事件，在内部，将会为每个Channel分配一个EventLoop。</p>\n<p>​        Netty 为每个 Channel 分配了一个 EventLoop，用于处理用户连接请求、对用户请求的处理等所有事件。EventLoop 本身只是一个线程驱动，在其生命周期内只会绑定一个线程，让该线程处理一个 Channel 的所有 IO 事件。</p>\n<p>​        一个 Channel 一旦与一个 EventLoop 相绑定，那么在 Channel 的整个生命周期内是不能改变的。一个 EventLoop 可以与多个 Channel 绑定。即 Channel 与 EventLoop 的关系是 n:1，而 EventLoop 与线程的关系是 1:1。</p>\n<p>作者：敖丙<br>链接：<a href=\"https://juejin.cn/post/6921858121774137352\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6921858121774137352</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"NioEventLoopGroup\"><a href=\"#NioEventLoopGroup\" class=\"headerlink\" title=\"NioEventLoopGroup\"></a>NioEventLoopGroup</h3><p>NioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个Channel上的事件，而一个Channel只对应于一个线程。</p>\n<h3 id=\"ChannelHandler\"><a href=\"#ChannelHandler\" class=\"headerlink\" title=\"ChannelHandler\"></a>ChannelHandler</h3><p>ChannelHandler是一个接口，处理I / O事件或拦截I / O操作，并将其转发到其ChannelPipeline(业务处理链)中的下一个处理程序。</p>\n<p>ChannelHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p>\n<ul>\n<li>ChannelInboundHandler用于处理入站I / O事件</li>\n<li>ChannelOutboundHandler用于处理出站I / O操作</li>\n</ul>\n<p>或者使用以下适配器类：</p>\n<ul>\n<li>ChannelInboundHandlerAdapter用于处理入站I / O事件</li>\n<li>ChannelOutboundHandlerAdapter用于处理出站I / O操作</li>\n<li>ChannelDuplexHandler用于处理入站和出站事件</li>\n</ul>\n<p>​        ChannelHandler 是对 Channel 中数据的处理器，这些处理器可以是系统本身定义好的编解码器，也可以是用户自定义的。这些处理器会被统一添加到一个 ChannelPipeline 的对象中，然后按照添加的顺序对 Channel 中的数据进行依次处理。</p>\n<h3 id=\"ChannelHandlerContext\"><a href=\"#ChannelHandlerContext\" class=\"headerlink\" title=\"ChannelHandlerContext\"></a>ChannelHandlerContext</h3><p>保存Channel相关的所有上下文信息，同时关联一个ChannelHandler对象</p>\n<h3 id=\"ChannelPipline\"><a href=\"#ChannelPipline\" class=\"headerlink\" title=\"ChannelPipline\"></a>ChannelPipline</h3><p>保存ChannelHandler的List，用于处理或拦截Channel的入站事件和出站操作。 ChannelPipeline实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及Channel中各个的ChannelHandler如何相互交互。</p>\n<p>下图引用Netty的Javadoc4.1中ChannelPipline的说明，描述了ChannelPipeline中ChannelHandler通常如何处理I/O事件。 I/O事件由ChannelInboundHandler或ChannelOutboundHandler处理，并通过调用ChannelHandlerContext中定义的事件传播方法（例如ChannelHandlerContext.fireChannelRead（Object）和ChannelOutboundInvoker.write（Object））转发到其最近的处理程序。</p>\n<pre><code>                                                 I/O Request\n                                            via Channel or\n                                        ChannelHandlerContext\n                                                      |\n  +---------------------------------------------------+---------------+\n  |                           ChannelPipeline         |               |\n  |                                                  \\|/              |\n  |    +---------------------+            +-----------+----------+    |\n  |    | Inbound Handler  N  |            | Outbound Handler  1  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  |               |                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  .               |\n  |               .                                   .               |\n  | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|\n  |        [ method call]                       [method call]         |\n  |               .                                   .               |\n  |               .                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  |               |                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler  1  |            | Outbound Handler  M  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  +---------------+-----------------------------------+---------------+\n                  |                                  \\|/\n  +---------------+-----------------------------------+---------------+\n  |               |                                   |               |\n  |       [ Socket.read() ]                    [ Socket.write() ]     |\n  |                                                                   |\n  |  Netty Internal I/O Threads (Transport Implementation)            |\n  +-------------------------------------------------------------------+</code></pre>\n<p>入站事件由自下而上方向的入站处理程序处理，如图左侧所示。 入站Handler处理程序通常处理由图底部的I / O线程生成的入站数据。 通常通过实际输入操作（例如SocketChannel.read（ByteBuffer））从远程读取入站数据。</p>\n<p>出站事件由上下方向处理，如图右侧所示。 出站Handler处理程序通常会生成或转换出站传输，例如write请求。 I/O线程通常执行实际的输出操作，例如SocketChannel.write（ByteBuffer）。</p>\n<p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应, 它们的组成关系如下:</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc8cd1a2f\" alt=\"img\"></p>\n<p>一个 Channel 包含了一个 ChannelPipeline, 而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表, 并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。入站事件和出站事件在一个双向链表中，入站事件会从链表head往后传递到最后一个入站的handler，出站事件会从链表tail往前传递到最前一个出站的handler，两种类型的handler互不干扰。</p>\n<h1 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h1><p>初始化并启动Netty服务端过程如下：</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 创建mainReactor</span>\n        NioEventLoopGroup boosGroup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NioEventLoopGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 创建工作线程组</span>\n        NioEventLoopGroup workerGroup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NioEventLoopGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">final</span> ServerBootstrap serverBootstrap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServerBootstrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        serverBootstrap \n                 <span class=\"token comment\" spellcheck=\"true\">// 组装NioEventLoopGroup </span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">group</span><span class=\"token punctuation\">(</span>boosGroup<span class=\"token punctuation\">,</span> workerGroup<span class=\"token punctuation\">)</span>\n                 <span class=\"token comment\" spellcheck=\"true\">// 设置channel类型为NIO类型</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span>NioServerSocketChannel<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 设置连接配置参数</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span>ChannelOption<span class=\"token punctuation\">.</span>SO_BACKLOG<span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">childOption</span><span class=\"token punctuation\">(</span>ChannelOption<span class=\"token punctuation\">.</span>SO_KEEPALIVE<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">childOption</span><span class=\"token punctuation\">(</span>ChannelOption<span class=\"token punctuation\">.</span>TCP_NODELAY<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 配置入站、出站事件handler</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">childHandler</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ChannelInitializer</span><span class=\"token operator\">&lt;</span>NioSocketChannel<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initChannel</span><span class=\"token punctuation\">(</span>NioSocketChannel ch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token comment\" spellcheck=\"true\">// 配置入站、出站事件channel</span>\n                        ch<span class=\"token punctuation\">.</span><span class=\"token function\">pipeline</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addLast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        ch<span class=\"token punctuation\">.</span><span class=\"token function\">pipeline</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addLast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 绑定端口</span>\n        <span class=\"token keyword\">int</span> port <span class=\"token operator\">=</span> <span class=\"token number\">8080</span><span class=\"token punctuation\">;</span>\n        serverBootstrap<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addListener</span><span class=\"token punctuation\">(</span>future <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">.</span><span class=\"token function\">isSuccess</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\": 端口[\"</span> <span class=\"token operator\">+</span> port <span class=\"token operator\">+</span> <span class=\"token string\">\"]绑定成功!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"端口[\"</span> <span class=\"token operator\">+</span> port <span class=\"token operator\">+</span> <span class=\"token string\">\"]绑定失败!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>基本过程如下：</li>\n<li>1 初始化创建2个NioEventLoopGroup，其中boosGroup用于Accetpt连接建立事件并分发请求， workerGroup用于处理I/O读写事件和业务逻辑</li>\n<li>2  基于ServerBootstrap(服务端启动引导类)，配置EventLoopGroup、Channel类型，连接参数、配置入站、出站事件handler</li>\n<li>3 绑定端口，开始工作</li>\n</ul>\n<p>结合上面的介绍的Netty Reactor模型，介绍服务端Netty的工作架构图：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc9a7cabe\" alt=\"服务端Netty Reactor工作架构图\"></p>\n<p>server端包含1个Boss NioEventLoopGroup和1个Worker NioEventLoopGroup，NioEventLoopGroup相当于1个事件循环组，这个组里包含多个事件循环NioEventLoop，每个NioEventLoop包含1个selector和1个事件循环线程。</p>\n<p>每个Boss NioEventLoop循环执行的任务包含3步：</p>\n<ul>\n<li>1 轮询accept事件</li>\n<li>2 处理accept I/O事件，与Client建立连接，生成NioSocketChannel，并将NioSocketChannel注册到某个Worker NioEventLoop的Selector上 *3 处理任务队列中的任务，runAllTasks。任务队列中的任务包括用户调用eventloop.execute或schedule执行的任务，或者其它线程提交到该eventloop的任务。</li>\n</ul>\n<p>每个Worker NioEventLoop循环执行的任务包含3步：</p>\n<ul>\n<li>1 轮询read、write事件；</li>\n<li>2 处I/O事件，即read、write事件，在NioSocketChannel可读、可写事件发生时进行处理</li>\n<li>3 处理任务队列中的任务，runAllTasks。</li>\n</ul>\n<p>其中任务队列中的task有3种典型使用场景</p>\n<ul>\n<li>1 用户程序自定义的普通任务</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\">ctx<span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">eventLoop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<ul>\n<li>2 非当前reactor线程调用channel的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的channel引用，然后调用write类方法向该用户推送消息，就会进入到这种场景。最终的write会提交到任务队列中后被异步消费。</li>\n<li>3 用户自定义定时任务</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\">ctx<span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">eventLoop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">60</span><span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"Netty-执行流程\"><a href=\"#Netty-执行流程\" class=\"headerlink\" title=\"Netty 执行流程\"></a>Netty 执行流程</h2><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/f692ce289a3e4c518306820fcb6114d3~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"线程模型\"><a href=\"#线程模型\" class=\"headerlink\" title=\"线程模型\"></a>线程模型</h1><p>介绍完服务器如何基于I/O模型管理连接，获取输入数据，下面介绍基于进程/线程模型，服务器如何处理请求</p>\n<p>值得说明的是，具体选择线程还是进程，更多是与平台及编程语言相关，例如C语言使用线程和进程都可以(例如Nginx使用进程，Memcached使用线程)，Java语言一般使用线程(例如Netty)，为了描述方便，下面都使用线程来进程描述</p>\n<h2 id=\"3-1-传统阻塞I-O服务模型\"><a href=\"#3-1-传统阻塞I-O服务模型\" class=\"headerlink\" title=\"3.1 传统阻塞I/O服务模型\"></a>3.1 传统阻塞I/O服务模型</h2><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae480ba5f\" alt=\"传统阻塞I/O服务模型\"></p>\n<p><strong>特点</strong></p>\n<ul>\n<li>采用阻塞式I/O模型获取输入数据</li>\n<li>每个连接都需要独立的线程完成数据输入，业务处理，数据返回的完整操作</li>\n</ul>\n<p><strong>存在问题</strong></p>\n<ul>\n<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li>\n<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费</li>\n</ul>\n<h2 id=\"3-2-Reactor模式\"><a href=\"#3-2-Reactor模式\" class=\"headerlink\" title=\"3.2 Reactor模式\"></a>3.2 Reactor模式</h2><p>针对传统传统阻塞I/O服务模型的2个缺点，比较常见的有如下解决方案：</p>\n<ul>\n<li>基于I/O复用模型，多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理</li>\n<li>基于线程池复用线程资源，不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务</li>\n</ul>\n<p>I/O复用结合线程池，这就是Reactor模式基本设计思想</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae52f75de\" alt=\"Reactor\"></p>\n<p><strong>Reactor模式</strong>，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I/O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)，是编写高性能网络服务器的必备技术之一</p>\n<p>Reactor模式中有2个关键组成：</p>\n<ul>\n<li>Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人</li>\n<li>Handlers 处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作</li>\n</ul>\n<p>根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现：</p>\n<ul>\n<li>单Reactor单线程</li>\n<li>单Reactor多线程</li>\n<li>主从Reactor多线程</li>\n</ul>\n<p>下面详细介绍这3种实现</p>\n<h3 id=\"3-2-1-单Reactor单线程\"><a href=\"#3-2-1-单Reactor单线程\" class=\"headerlink\" title=\"3.2.1 单Reactor单线程\"></a>3.2.1 单Reactor单线程</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae57487c5\" alt=\"单Reactor单线程\"></p>\n<p>其中，select是前面<strong>I/O复用模型</strong>介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求，其他方案示意图类似</p>\n<p><strong>方案说明</strong></p>\n<ul>\n<li>Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发</li>\n<li>如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理</li>\n<li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li>\n<li>Handler会完成read-&gt;业务处理-&gt;send的完整业务流程</li>\n</ul>\n<p><strong>优点</strong> 模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>性能问题：只有一个线程，无法完全发挥多核CPU的性能 Handler在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>\n<li>可靠性问题：线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>\n</ul>\n<p><strong>使用场景</strong> 客户端的数量有限，业务处理非常快速，比如Redis，业务处理的时间复杂度O(1)</p>\n<h3 id=\"3-2-2-单Reactor多线程\"><a href=\"#3-2-2-单Reactor多线程\" class=\"headerlink\" title=\"3.2.2 单Reactor多线程\"></a>3.2.2 单Reactor多线程</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae74362df\" alt=\"单Reactor多线程\"></p>\n<p><strong>方案说明</strong></p>\n<ul>\n<li>Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发</li>\n<li>如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的续各种事件</li>\n<li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li>\n<li>Handler只负责响应事件，不做具体业务处理，通过read读取数据后，会分发给后面的Worker线程池进行业务处理</li>\n<li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li>\n<li>Handler收到响应结果后通过send将响应结果返回给client</li>\n</ul>\n<p><strong>优点</strong> 可以充分利用多核CPU的处理能力</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>多线程数据共享和访问比较复杂</li>\n<li>Reactor承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈</li>\n</ul>\n<h3 id=\"3-2-3-主从Reactor多线程\"><a href=\"#3-2-3-主从Reactor多线程\" class=\"headerlink\" title=\"3.2.3 主从Reactor多线程\"></a>3.2.3 主从Reactor多线程</h3><p>针对单Reactor多线程模型中，Reactor在单线程中运行，高并发场景下容易成为性能瓶颈，可以让Reactor在多线程中运行</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723b8948bc3f\" alt=\"主从Reactor多线程\"></p>\n<p><strong>方案说明</strong></p>\n<ul>\n<li>Reactor主线程MainReactor对象通过select监控建立连接事件，收到事件后通过Acceptor接收，处理建立连接事件</li>\n<li>Accepto处理建立连接事件后，MainReactor将连接分配Reactor子线程给SubReactor进行处理</li>\n<li>SubReactor将连接加入连接队列进行监听，并创建一个Handler用于处理各种连接事件</li>\n<li>当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应</li>\n<li>Handler通过read读取数据后，会分发给后面的Worker线程池进行业务处理</li>\n<li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li>\n<li>Handler收到响应结果后通过send将响应结果返回给client</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</li>\n<li>父线程与子线程的数据交互简单，Reactor主线程只需要把新连接传给子线程，子线程无需返回数据</li>\n</ul>\n<p>这种模型在许多项目中广泛使用，包括Nginx主从Reactor多进程模型，Memcached主从多线程，Netty主从多线程模型的支持</p>\n<h3 id=\"3-2-4-总结\"><a href=\"#3-2-4-总结\" class=\"headerlink\" title=\"3.2.4 总结\"></a>3.2.4 总结</h3><p>3种模式可以用个比喻来理解： 餐厅常常雇佣接待员负责迎接顾客，当顾客入坐后，侍应生专门为这张桌子服务</p>\n<ul>\n<li>单Reactor单线程 接待员和侍应生是同一个人，全程为顾客服务</li>\n<li>单Reactor多线程 1个接待员，多个侍应生，接待员只负责接待</li>\n<li>主从Reactor多线程 多个接待员，多个侍应生</li>\n</ul>\n<p>Reactor模式具有如下的优点：</p>\n<ul>\n<li>响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的</li>\n<li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；</li>\n<li>可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源</li>\n<li>可复用性，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性</li>\n</ul>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</p>\n<h2 id=\"NIO的问题\"><a href=\"#NIO的问题\" class=\"headerlink\" title=\"NIO的问题\"></a>NIO的问题</h2><ul>\n<li>NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等</li>\n<li>需要熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序</li>\n<li>可靠性能力问题，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等</li>\n<li>JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%</li>\n</ul>\n<h2 id=\"Netty的特点\"><a href=\"#Netty的特点\" class=\"headerlink\" title=\"Netty的特点\"></a>Netty的特点</h2><p>Netty的对JDK自带的NIO的API进行封装，解决上述问题，主要特点有：</p>\n<ul>\n<li>设计优雅 适用于各种传输类型的统一API</li>\n<li>高性能 吞吐量更高，延迟更低 减少资源消耗 最小化不必要的内存复制</li>\n<li>安全 完整的SSL / TLS和StartTLS支持</li>\n</ul>\n<h2 id=\"Netty常见使用场景\"><a href=\"#Netty常见使用场景\" class=\"headerlink\" title=\"Netty常见使用场景\"></a>Netty常见使用场景</h2><ul>\n<li>互联网行业 在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高新能的通信框架,往往作为基础通信组件被这些RPC框架使用。 典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</li>\n<li>游戏行业 无论是手游服务端还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈。 非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过Netty进行高性能的通信</li>\n<li>大数据领域 经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨界点通信，它的Netty Service基于Netty框架二次封装实现</li>\n</ul>\n<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><h2 id=\"理论架构\"><a href=\"#理论架构\" class=\"headerlink\" title=\"理论架构\"></a>理论架构</h2><h3 id=\"I-O复用模型\"><a href=\"#I-O复用模型\" class=\"headerlink\" title=\"I/O复用模型\"></a>I/O复用模型</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfba53c0a\" alt=\"img\"></p>\n<p>在I/O复用模型中，会用到select，这个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这个函数可以同时阻塞多个I/O操作，而且可以同时对多个读/写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数</p>\n<p>Netty的非阻塞I/O的实现关键是基于I/O复用模型，这里用Selector对象表示：</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfba32169\" alt=\"Nonblocking I/O\" style=\"zoom:67%;\" />\n\n<p>Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端连接。当线程从某客户端Socket通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。</p>\n<p>由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁I/O阻塞导致的线程挂起，一个I/O线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞I/O一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p>\n<h3 id=\"事件驱动模型\"><a href=\"#事件驱动模型\" class=\"headerlink\" title=\"事件驱动模型\"></a>事件驱动模型</h3><p>通常，我们设计一个事件处理模型的程序有两种思路</p>\n<ul>\n<li>轮询方式 线程不断轮询访问相关事件发生源有没有发生事件，有发生事件就调用事件处理逻辑。</li>\n<li>事件驱动方式 发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑处理事件。事件驱动方式也被称为消息通知方式，其实是设计模式中<strong>观察者模式</strong>的思路。</li>\n</ul>\n<p>以GUI的逻辑处理为例，说明两种逻辑的不同：</p>\n<ul>\n<li>轮询方式 线程不断轮询是否发生按钮点击事件，如果发生，调用处理逻辑</li>\n<li>事件驱动方式 发生点击事件把事件放入事件队列，在另外线程消费的事件列表中的事件，根据事件类型调用相关事件处理逻辑</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbcfbdf3439\" alt=\"事件驱动模型\"></p>\n<p>主要包括4个基本组件：</p>\n<ul>\n<li>事件队列（event queue）：接收事件的入口，存储待处理事件</li>\n<li>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</li>\n<li>事件通道（event channel）：分发器与处理器之间的联系渠道</li>\n<li>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</li>\n</ul>\n<p>可以看出，相对传统轮询模式，事件驱动有如下优点：</p>\n<ul>\n<li>可扩展性好，分布式的异步架构，事件处理器之间高度解耦，可以方便扩展事件处理逻辑</li>\n<li>高性能，基于队列暂存事件，能方便并行异步处理事件</li>\n</ul>\n<h3 id=\"Reactor线程模型\"><a href=\"#Reactor线程模型\" class=\"headerlink\" title=\"Reactor线程模型\"></a>Reactor线程模型</h3><p>Reactor是反应堆的意思，Reactor模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的<strong>事件驱动处理模式</strong>。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I/O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)，是编写高性能网络服务器的必备技术之一。</p>\n<p>Reactor模型中有2个关键组成：</p>\n<ul>\n<li>Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人</li>\n<li>Handlers 处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc654d6dc\" alt=\"Reactor模型\"></p>\n<p>取决于Reactor的数量和Hanndler线程数量的不同，Reactor模型有3个变种</p>\n<ul>\n<li>单Reactor单线程</li>\n<li>单Reactor多线程</li>\n<li>主从Reactor多线程</li>\n</ul>\n<p>可以这样理解，Reactor就是一个执行while (true) { selector.select(); …}循环的线程，会源源不断的产生新的事件，称作反应堆很贴切。</p>\n<h3 id=\"Netty线程模型\"><a href=\"#Netty线程模型\" class=\"headerlink\" title=\"Netty线程模型\"></a>Netty线程模型</h3><p>Netty主要<strong>基于主从Reactors多线程模型</strong>做了一定的修改，其中主从Reactor多线程模型有多个Reactor：MainReactor和SubReactor：</p>\n<ul>\n<li>MainReactor负责客户端的连接请求，并将请求转交给SubReactor</li>\n<li>SubReactor负责相应通道的IO读写请求</li>\n<li>非IO请求（具体逻辑处理）的任务则会直接写入队列，等待worker threads进行处理</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc698ddd6\" alt=\"主从Rreactor多线程模型\"></p>\n<p>特别说明的是： 虽然Netty的线程模型基于主从Reactor多线程，借用了MainReactor和SubReactor的结构，但是实际实现上，SubReactor和Worker线程在同一个线程池中：</p>\n<pre><code class=\"java\">EventLoopGroup bossGroup = new NioEventLoopGroup();\nEventLoopGroup workerGroup = new NioEventLoopGroup();\nServerBootstrap server = new ServerBootstrap();\nserver.group(bossGroup, workerGroup)\n .channel(NioServerSocketChannel.class)</code></pre>\n<p>上面代码中的bossGroup 和workerGroup是Bootstrap构造方法中传入的两个对象，这两个group均是线程池</p>\n<ul>\n<li>bossGroup线程池则只是在bind某个端口后，获得其中一个线程作为MainReactor，专门处理端口的accept事件，<strong>每个端口对应一个boss线程</strong></li>\n<li>workerGroup线程池会被各个SubReactor和worker线程充分利用</li>\n</ul>\n<h3 id=\"异步处理\"><a href=\"#异步处理\" class=\"headerlink\" title=\"异步处理\"></a>异步处理</h3><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>\n<p>Netty中的I/O操作是异步的，包括bind、write、connect等操作会简单的返回一个ChannelFuture，调用者并不能立刻获得结果，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p>\n<p>当future对象刚刚创建时，处于非完成状态，调用者可以通过返回的ChannelFuture来获取操作执行的状态，注册监听函数来执行完成后的操，常见有如下操作：</p>\n<ul>\n<li>通过isDone方法来判断当前操作是否完成</li>\n<li>通过isSuccess方法来判断已完成的当前操作是否成功</li>\n<li>通过getCause方法来获取已完成的当前操作失败的原因</li>\n<li>通过isCancelled方法来判断已完成的当前操作是否被取消</li>\n<li>通过addListener方法来注册监听器，当操作已完成(isDone方法返回完成)，将会通知指定的监听器；如果future对象已完成，则理解通知指定的监听器</li>\n</ul>\n<p>例如下面的的代码中绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>\n<pre><code class=\"java\">    serverBootstrap.bind(port).addListener(future -&gt; {\n        if (future.isSuccess()) {\n            System.out.println(new Date() + &quot;: 端口[&quot; + port + &quot;]绑定成功!&quot;);\n        } else {\n            System.err.println(&quot;端口[&quot; + port + &quot;]绑定失败!&quot;);\n        }\n    });</code></pre>\n<p>相比传统阻塞I/O，执行I/O操作后线程会被阻塞住, 直到操作完成；异步处理的好处是不会造成线程阻塞，线程在I/O操作期间可以执行别的程序，在高并发情形下会更稳定和更高的吞吐量。</p>\n<h2 id=\"Netty架构设计\"><a href=\"#Netty架构设计\" class=\"headerlink\" title=\"Netty架构设计\"></a>Netty架构设计</h2><h3 id=\"Bootstrap、ServerBootstrap\"><a href=\"#Bootstrap、ServerBootstrap\" class=\"headerlink\" title=\"Bootstrap、ServerBootstrap\"></a>Bootstrap、ServerBootstrap</h3><p>Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类。</p>\n<h3 id=\"Future、ChannelFuture\"><a href=\"#Future、ChannelFuture\" class=\"headerlink\" title=\"Future、ChannelFuture\"></a>Future、ChannelFuture</h3><p>正如前面介绍，在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理，但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p>\n<p>​        Netty 中所有的 I/O 操作都是异步的，即操作不会立即得到返回结果，所以 Netty 中定义了一个 ChannelFuture 对象作为这个异步操作的“代言人”，表示异步操作本身。如果想获取到该异步操作的返回值，可以通过该异步操作对象的addListener() 方法为该异步操作添加监 NIO 网络编程框架 Netty 听器，为其注册回调：当结果出来后马上调用执行。</p>\n<p>​        Netty 的异步编程模型都是建立在 Future 与回调概念之上的。</p>\n<h3 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h3><p>Netty网络通信的组件，能够用于执行网络I/O操作。 Channel为用户提供：</p>\n<ul>\n<li>当前网络连接的通道的状态（例如是否打开？是否已连接？）</li>\n<li>网络连接的配置参数 （例如接收缓冲区大小）</li>\n<li>提供异步的网络I/O操作(如建立连接，读写，绑定端口)，异步调用意味着任何I / O调用都将立即返回，并且不保证在调用结束时所请求的I / O操作已完成。调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以I / O操作成功、失败或取消时回调通知调用方。</li>\n<li>支持关联I/O操作与对应的处理程序</li>\n</ul>\n<p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，下面是一些常用的 Channel 类型</p>\n<ul>\n<li>NioSocketChannel，异步的客户端 TCP Socket 连接</li>\n<li>NioServerSocketChannel，异步的服务器端 TCP Socket 连接</li>\n<li>NioDatagramChannel，异步的 UDP 连接</li>\n<li>NioSctpChannel，异步的客户端 Sctp 连接</li>\n<li>NioSctpServerChannel，异步的 Sctp 服务器端连接 这些通道涵盖了 UDP 和 TCP网络 IO以及文件 IO.</li>\n</ul>\n<h3 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h3><p>Netty基于Selector对象实现I/O多路复用，通过 Selector, 一个线程可以监听多个连接的Channel事件, 当向一个Selector中注册Channel 后，Selector 内部的机制就可以自动不断地查询(select) 这些注册的Channel是否有已就绪的I/O事件(例如可读, 可写, 网络连接完成等)，这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p>\n<h3 id=\"NioEventLoop\"><a href=\"#NioEventLoop\" class=\"headerlink\" title=\"NioEventLoop\"></a>NioEventLoop</h3><p>NioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop的run方法，执行I/O任务和非I/O任务：</p>\n<ul>\n<li>I/O任务 即selectionKey中ready的事件，如accept、connect、read、write等，由processSelectedKeys方法触发。</li>\n<li>非IO任务 添加到taskQueue中的任务，如register0、bind0等任务，由runAllTasks方法触发。</li>\n</ul>\n<p>两种任务的执行时间比由变量ioRatio控制，默认为50，则表示允许非IO任务执行的时间与IO任务的执行时间相等。</p>\n<p> EventLoop 定义了Netty的核心抽象，用来处理连接的生命周期中所发生的事件，在内部，将会为每个Channel分配一个EventLoop。</p>\n<p>​        Netty 为每个 Channel 分配了一个 EventLoop，用于处理用户连接请求、对用户请求的处理等所有事件。EventLoop 本身只是一个线程驱动，在其生命周期内只会绑定一个线程，让该线程处理一个 Channel 的所有 IO 事件。</p>\n<p>​        一个 Channel 一旦与一个 EventLoop 相绑定，那么在 Channel 的整个生命周期内是不能改变的。一个 EventLoop 可以与多个 Channel 绑定。即 Channel 与 EventLoop 的关系是 n:1，而 EventLoop 与线程的关系是 1:1。</p>\n<p>作者：敖丙<br>链接：<a href=\"https://juejin.cn/post/6921858121774137352\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6921858121774137352</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"NioEventLoopGroup\"><a href=\"#NioEventLoopGroup\" class=\"headerlink\" title=\"NioEventLoopGroup\"></a>NioEventLoopGroup</h3><p>NioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个Channel上的事件，而一个Channel只对应于一个线程。</p>\n<h3 id=\"ChannelHandler\"><a href=\"#ChannelHandler\" class=\"headerlink\" title=\"ChannelHandler\"></a>ChannelHandler</h3><p>ChannelHandler是一个接口，处理I / O事件或拦截I / O操作，并将其转发到其ChannelPipeline(业务处理链)中的下一个处理程序。</p>\n<p>ChannelHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p>\n<ul>\n<li>ChannelInboundHandler用于处理入站I / O事件</li>\n<li>ChannelOutboundHandler用于处理出站I / O操作</li>\n</ul>\n<p>或者使用以下适配器类：</p>\n<ul>\n<li>ChannelInboundHandlerAdapter用于处理入站I / O事件</li>\n<li>ChannelOutboundHandlerAdapter用于处理出站I / O操作</li>\n<li>ChannelDuplexHandler用于处理入站和出站事件</li>\n</ul>\n<p>​        ChannelHandler 是对 Channel 中数据的处理器，这些处理器可以是系统本身定义好的编解码器，也可以是用户自定义的。这些处理器会被统一添加到一个 ChannelPipeline 的对象中，然后按照添加的顺序对 Channel 中的数据进行依次处理。</p>\n<h3 id=\"ChannelHandlerContext\"><a href=\"#ChannelHandlerContext\" class=\"headerlink\" title=\"ChannelHandlerContext\"></a>ChannelHandlerContext</h3><p>保存Channel相关的所有上下文信息，同时关联一个ChannelHandler对象</p>\n<h3 id=\"ChannelPipline\"><a href=\"#ChannelPipline\" class=\"headerlink\" title=\"ChannelPipline\"></a>ChannelPipline</h3><p>保存ChannelHandler的List，用于处理或拦截Channel的入站事件和出站操作。 ChannelPipeline实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及Channel中各个的ChannelHandler如何相互交互。</p>\n<p>下图引用Netty的Javadoc4.1中ChannelPipline的说明，描述了ChannelPipeline中ChannelHandler通常如何处理I/O事件。 I/O事件由ChannelInboundHandler或ChannelOutboundHandler处理，并通过调用ChannelHandlerContext中定义的事件传播方法（例如ChannelHandlerContext.fireChannelRead（Object）和ChannelOutboundInvoker.write（Object））转发到其最近的处理程序。</p>\n<pre><code>                                                 I/O Request\n                                            via Channel or\n                                        ChannelHandlerContext\n                                                      |\n  +---------------------------------------------------+---------------+\n  |                           ChannelPipeline         |               |\n  |                                                  \\|/              |\n  |    +---------------------+            +-----------+----------+    |\n  |    | Inbound Handler  N  |            | Outbound Handler  1  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  |               |                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  .               |\n  |               .                                   .               |\n  | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|\n  |        [ method call]                       [method call]         |\n  |               .                                   .               |\n  |               .                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  |               |                                  \\|/              |\n  |    +----------+----------+            +-----------+----------+    |\n  |    | Inbound Handler  1  |            | Outbound Handler  M  |    |\n  |    +----------+----------+            +-----------+----------+    |\n  |              /|\\                                  |               |\n  +---------------+-----------------------------------+---------------+\n                  |                                  \\|/\n  +---------------+-----------------------------------+---------------+\n  |               |                                   |               |\n  |       [ Socket.read() ]                    [ Socket.write() ]     |\n  |                                                                   |\n  |  Netty Internal I/O Threads (Transport Implementation)            |\n  +-------------------------------------------------------------------+</code></pre>\n<p>入站事件由自下而上方向的入站处理程序处理，如图左侧所示。 入站Handler处理程序通常处理由图底部的I / O线程生成的入站数据。 通常通过实际输入操作（例如SocketChannel.read（ByteBuffer））从远程读取入站数据。</p>\n<p>出站事件由上下方向处理，如图右侧所示。 出站Handler处理程序通常会生成或转换出站传输，例如write请求。 I/O线程通常执行实际的输出操作，例如SocketChannel.write（ByteBuffer）。</p>\n<p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应, 它们的组成关系如下:</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc8cd1a2f\" alt=\"img\"></p>\n<p>一个 Channel 包含了一个 ChannelPipeline, 而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表, 并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。入站事件和出站事件在一个双向链表中，入站事件会从链表head往后传递到最后一个入站的handler，出站事件会从链表tail往前传递到最前一个出站的handler，两种类型的handler互不干扰。</p>\n<h1 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h1><p>初始化并启动Netty服务端过程如下：</p>\n<pre><code class=\"java\">    public static void main(String[] args) {\n        // 创建mainReactor\n        NioEventLoopGroup boosGroup = new NioEventLoopGroup();\n        // 创建工作线程组\n        NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        final ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap \n                 // 组装NioEventLoopGroup \n                .group(boosGroup, workerGroup)\n                 // 设置channel类型为NIO类型\n                .channel(NioServerSocketChannel.class)\n                // 设置连接配置参数\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                // 配置入站、出站事件handler\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        // 配置入站、出站事件channel\n                        ch.pipeline().addLast(...);\n                        ch.pipeline().addLast(...);\n                    }\n    });\n\n        // 绑定端口\n        int port = 8080;\n        serverBootstrap.bind(port).addListener(future -&gt; {\n            if (future.isSuccess()) {\n                System.out.println(new Date() + &quot;: 端口[&quot; + port + &quot;]绑定成功!&quot;);\n            } else {\n                System.err.println(&quot;端口[&quot; + port + &quot;]绑定失败!&quot;);\n            }\n        });\n}</code></pre>\n<ul>\n<li>基本过程如下：</li>\n<li>1 初始化创建2个NioEventLoopGroup，其中boosGroup用于Accetpt连接建立事件并分发请求， workerGroup用于处理I/O读写事件和业务逻辑</li>\n<li>2  基于ServerBootstrap(服务端启动引导类)，配置EventLoopGroup、Channel类型，连接参数、配置入站、出站事件handler</li>\n<li>3 绑定端口，开始工作</li>\n</ul>\n<p>结合上面的介绍的Netty Reactor模型，介绍服务端Netty的工作架构图：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/166ccbbdc9a7cabe\" alt=\"服务端Netty Reactor工作架构图\"></p>\n<p>server端包含1个Boss NioEventLoopGroup和1个Worker NioEventLoopGroup，NioEventLoopGroup相当于1个事件循环组，这个组里包含多个事件循环NioEventLoop，每个NioEventLoop包含1个selector和1个事件循环线程。</p>\n<p>每个Boss NioEventLoop循环执行的任务包含3步：</p>\n<ul>\n<li>1 轮询accept事件</li>\n<li>2 处理accept I/O事件，与Client建立连接，生成NioSocketChannel，并将NioSocketChannel注册到某个Worker NioEventLoop的Selector上 *3 处理任务队列中的任务，runAllTasks。任务队列中的任务包括用户调用eventloop.execute或schedule执行的任务，或者其它线程提交到该eventloop的任务。</li>\n</ul>\n<p>每个Worker NioEventLoop循环执行的任务包含3步：</p>\n<ul>\n<li>1 轮询read、write事件；</li>\n<li>2 处I/O事件，即read、write事件，在NioSocketChannel可读、可写事件发生时进行处理</li>\n<li>3 处理任务队列中的任务，runAllTasks。</li>\n</ul>\n<p>其中任务队列中的task有3种典型使用场景</p>\n<ul>\n<li>1 用户程序自定义的普通任务</li>\n</ul>\n<pre><code class=\"java\">ctx.channel().eventLoop().execute(new Runnable() {\n    @Override\n    public void run() {\n        //...\n    }\n});</code></pre>\n<ul>\n<li>2 非当前reactor线程调用channel的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的channel引用，然后调用write类方法向该用户推送消息，就会进入到这种场景。最终的write会提交到任务队列中后被异步消费。</li>\n<li>3 用户自定义定时任务</li>\n</ul>\n<pre><code class=\"java\">ctx.channel().eventLoop().schedule(new Runnable() {\n    @Override\n    public void run() {\n\n    }\n}, 60, TimeUnit.SECONDS);</code></pre>\n<h2 id=\"Netty-执行流程\"><a href=\"#Netty-执行流程\" class=\"headerlink\" title=\"Netty 执行流程\"></a>Netty 执行流程</h2><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/f692ce289a3e4c518306820fcb6114d3~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\"></p>\n"},{"title":"装饰者模式","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习装饰者模式所做的笔记，包括装饰者模式的设计，在Java IO中应用等。","abbrlink":"a708a60d","date":"2021-01-29T16:00:00.000Z","_content":"\n\n\n# 装饰者模式\n\n## 理解\n\n动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案\n\n开闭原则的应用：类应该对扩展开放,对修改关闭；允许类很容易的进行扩展，在不修改代码的情况下就可以搭配新的行为\n\n\n\n![image-20200926170529749](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png)\n\n## 细节\n\n+ 利用继承设计子类的行为，是在编译时静态决定的，而且所有子类都会继承到相同的行为。如果利用组合扩展对象的行为，就能在运行时动态地进行扩展。\n+ 装饰者和被装饰者有相同的超类型\n+ 可以用一个或多个装饰者包装一个对象\n+ 在任何需要原始对象的地方，都可以用装饰过的对象代替它\n+ 装饰者模式意味着一群装饰者类，用来包装具体的组件\n+ 可以用无数的装饰者包装一个组件\n\n# 应用\n\n## IO流\n\n+ I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。\n+ 如果采用装饰者模式，那么类的数目就会大大减少，性能的重复也可以减至最少。\n+ 设计既避免了类爆炸，又可以让用户自己去搭配核心类和装饰类。\n+ 例如：想以缓存的方式从文件中读取字节流。先创建一个FileInputStream，然后把这个FileInputStream放入BufferedInputStream构造函数中去创建BufferedInputStream\n\n### 架构\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/720290-36c8d9a6e8f77e51.png)\n\n### 抽象构件(Component)角色\n\n由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。\n\n### 具体构件(ConcreteComponent)角色\n\n+ FileInputStream 从文件读取数据（字节流）\n+ ByteArrayInputStream 从字节数组读取数据（字节流）\n+ PipedInputStream 处理线程间的输入流\n+ StringBufferInputStream 处理StringBuffer\n+ ObjectInputStream 处理被序列化的对象\n\n### 抽象装饰(Decorator)角色\n\n由FilterInputStream扮演\n\n### 具体装饰(ConcreteDecorator)角色\n\n+ BufferedInputStream\n\n    + 当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据位置。\n    + 缓冲字节输入流\n    + 不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多\n\n+ DataInputStream\n\n    + 把byte转换成Java基本类型\n\n    +  double readDouble() 此输入流的下八个字节，将它们解释为一个 double。\n\n\n# 面试\n\n## 装饰者模式和代理模式的区别\n\n让别人帮助你做你并不关心的事情，叫**代理模式**\n\n为让自己的能力增强，使得增强后的自己能够使用更多的方法，拓展在自己基础之上的功能的，叫**装饰器模式**\n\n\n\n\n\n代理模式，常常自己内部创建被代理的对象。\n\n装饰器模式，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。\n\n\n\n使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。  \n\n代理模式强调的是控制，装饰模式强调的是增强。\n代理模式强调的是透明访问，装饰模式强调的是自由构建。\n\n代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制。\n装饰，偏重对原对象功能的扩展，扩展后的对象仍是是对象本身。\n\n装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。","source":"_posts/计算机基础/设计模式/02.装饰者模式.md","raw":"---\ntitle: 装饰者模式\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 学习装饰者模式所做的笔记，包括装饰者模式的设计，在Java IO中应用等。\ncategories: 设计模式\ntags:\n  - 架构\n  - IO\n  - 装饰者模式\nabbrlink: a708a60d\ndate: 2021-01-30 00:00:00\n---\n\n\n\n# 装饰者模式\n\n## 理解\n\n动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案\n\n开闭原则的应用：类应该对扩展开放,对修改关闭；允许类很容易的进行扩展，在不修改代码的情况下就可以搭配新的行为\n\n\n\n![image-20200926170529749](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png)\n\n## 细节\n\n+ 利用继承设计子类的行为，是在编译时静态决定的，而且所有子类都会继承到相同的行为。如果利用组合扩展对象的行为，就能在运行时动态地进行扩展。\n+ 装饰者和被装饰者有相同的超类型\n+ 可以用一个或多个装饰者包装一个对象\n+ 在任何需要原始对象的地方，都可以用装饰过的对象代替它\n+ 装饰者模式意味着一群装饰者类，用来包装具体的组件\n+ 可以用无数的装饰者包装一个组件\n\n# 应用\n\n## IO流\n\n+ I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。\n+ 如果采用装饰者模式，那么类的数目就会大大减少，性能的重复也可以减至最少。\n+ 设计既避免了类爆炸，又可以让用户自己去搭配核心类和装饰类。\n+ 例如：想以缓存的方式从文件中读取字节流。先创建一个FileInputStream，然后把这个FileInputStream放入BufferedInputStream构造函数中去创建BufferedInputStream\n\n### 架构\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/720290-36c8d9a6e8f77e51.png)\n\n### 抽象构件(Component)角色\n\n由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。\n\n### 具体构件(ConcreteComponent)角色\n\n+ FileInputStream 从文件读取数据（字节流）\n+ ByteArrayInputStream 从字节数组读取数据（字节流）\n+ PipedInputStream 处理线程间的输入流\n+ StringBufferInputStream 处理StringBuffer\n+ ObjectInputStream 处理被序列化的对象\n\n### 抽象装饰(Decorator)角色\n\n由FilterInputStream扮演\n\n### 具体装饰(ConcreteDecorator)角色\n\n+ BufferedInputStream\n\n    + 当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据位置。\n    + 缓冲字节输入流\n    + 不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多\n\n+ DataInputStream\n\n    + 把byte转换成Java基本类型\n\n    +  double readDouble() 此输入流的下八个字节，将它们解释为一个 double。\n\n\n# 面试\n\n## 装饰者模式和代理模式的区别\n\n让别人帮助你做你并不关心的事情，叫**代理模式**\n\n为让自己的能力增强，使得增强后的自己能够使用更多的方法，拓展在自己基础之上的功能的，叫**装饰器模式**\n\n\n\n\n\n代理模式，常常自己内部创建被代理的对象。\n\n装饰器模式，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。\n\n\n\n使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。  \n\n代理模式强调的是控制，装饰模式强调的是增强。\n代理模式强调的是透明访问，装饰模式强调的是自由构建。\n\n代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制。\n装饰，偏重对原对象功能的扩展，扩展后的对象仍是是对象本身。\n\n装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。","slug":"计算机基础/设计模式/02.装饰者模式","published":1,"updated":"2021-06-08T03:35:00.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq5150012z0tp281w39ia","content":"<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案</p>\n<p>开闭原则的应用：类应该对扩展开放,对修改关闭；允许类很容易的进行扩展，在不修改代码的情况下就可以搭配新的行为</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png\" alt=\"image-20200926170529749\"></p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ul>\n<li>利用继承设计子类的行为，是在编译时静态决定的，而且所有子类都会继承到相同的行为。如果利用组合扩展对象的行为，就能在运行时动态地进行扩展。</li>\n<li>装饰者和被装饰者有相同的超类型</li>\n<li>可以用一个或多个装饰者包装一个对象</li>\n<li>在任何需要原始对象的地方，都可以用装饰过的对象代替它</li>\n<li>装饰者模式意味着一群装饰者类，用来包装具体的组件</li>\n<li>可以用无数的装饰者包装一个组件</li>\n</ul>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h2><ul>\n<li>I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。</li>\n<li>如果采用装饰者模式，那么类的数目就会大大减少，性能的重复也可以减至最少。</li>\n<li>设计既避免了类爆炸，又可以让用户自己去搭配核心类和装饰类。</li>\n<li>例如：想以缓存的方式从文件中读取字节流。先创建一个FileInputStream，然后把这个FileInputStream放入BufferedInputStream构造函数中去创建BufferedInputStream</li>\n</ul>\n<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/720290-36c8d9a6e8f77e51.png\"></p>\n<h3 id=\"抽象构件-Component-角色\"><a href=\"#抽象构件-Component-角色\" class=\"headerlink\" title=\"抽象构件(Component)角色\"></a>抽象构件(Component)角色</h3><p>由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</p>\n<h3 id=\"具体构件-ConcreteComponent-角色\"><a href=\"#具体构件-ConcreteComponent-角色\" class=\"headerlink\" title=\"具体构件(ConcreteComponent)角色\"></a>具体构件(ConcreteComponent)角色</h3><ul>\n<li>FileInputStream 从文件读取数据（字节流）</li>\n<li>ByteArrayInputStream 从字节数组读取数据（字节流）</li>\n<li>PipedInputStream 处理线程间的输入流</li>\n<li>StringBufferInputStream 处理StringBuffer</li>\n<li>ObjectInputStream 处理被序列化的对象</li>\n</ul>\n<h3 id=\"抽象装饰-Decorator-角色\"><a href=\"#抽象装饰-Decorator-角色\" class=\"headerlink\" title=\"抽象装饰(Decorator)角色\"></a>抽象装饰(Decorator)角色</h3><p>由FilterInputStream扮演</p>\n<h3 id=\"具体装饰-ConcreteDecorator-角色\"><a href=\"#具体装饰-ConcreteDecorator-角色\" class=\"headerlink\" title=\"具体装饰(ConcreteDecorator)角色\"></a>具体装饰(ConcreteDecorator)角色</h3><ul>\n<li><p>BufferedInputStream</p>\n<ul>\n<li>当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据位置。</li>\n<li>缓冲字节输入流</li>\n<li>不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多</li>\n</ul>\n</li>\n<li><p>DataInputStream</p>\n<ul>\n<li><p>把byte转换成Java基本类型</p>\n</li>\n<li><p>double readDouble() 此输入流的下八个字节，将它们解释为一个 double。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"面试\"><a href=\"#面试\" class=\"headerlink\" title=\"面试\"></a>面试</h1><h2 id=\"装饰者模式和代理模式的区别\"><a href=\"#装饰者模式和代理模式的区别\" class=\"headerlink\" title=\"装饰者模式和代理模式的区别\"></a>装饰者模式和代理模式的区别</h2><p>让别人帮助你做你并不关心的事情，叫<strong>代理模式</strong></p>\n<p>为让自己的能力增强，使得增强后的自己能够使用更多的方法，拓展在自己基础之上的功能的，叫<strong>装饰器模式</strong></p>\n<p>代理模式，常常自己内部创建被代理的对象。</p>\n<p>装饰器模式，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>\n<p>使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。  </p>\n<p>代理模式强调的是控制，装饰模式强调的是增强。<br>代理模式强调的是透明访问，装饰模式强调的是自由构建。</p>\n<p>代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制。<br>装饰，偏重对原对象功能的扩展，扩展后的对象仍是是对象本身。</p>\n<p>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案</p>\n<p>开闭原则的应用：类应该对扩展开放,对修改关闭；允许类很容易的进行扩展，在不修改代码的情况下就可以搭配新的行为</p>\n<p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png\" alt=\"image-20200926170529749\"></p>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ul>\n<li>利用继承设计子类的行为，是在编译时静态决定的，而且所有子类都会继承到相同的行为。如果利用组合扩展对象的行为，就能在运行时动态地进行扩展。</li>\n<li>装饰者和被装饰者有相同的超类型</li>\n<li>可以用一个或多个装饰者包装一个对象</li>\n<li>在任何需要原始对象的地方，都可以用装饰过的对象代替它</li>\n<li>装饰者模式意味着一群装饰者类，用来包装具体的组件</li>\n<li>可以用无数的装饰者包装一个组件</li>\n</ul>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h2><ul>\n<li>I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。</li>\n<li>如果采用装饰者模式，那么类的数目就会大大减少，性能的重复也可以减至最少。</li>\n<li>设计既避免了类爆炸，又可以让用户自己去搭配核心类和装饰类。</li>\n<li>例如：想以缓存的方式从文件中读取字节流。先创建一个FileInputStream，然后把这个FileInputStream放入BufferedInputStream构造函数中去创建BufferedInputStream</li>\n</ul>\n<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/720290-36c8d9a6e8f77e51.png\"></p>\n<h3 id=\"抽象构件-Component-角色\"><a href=\"#抽象构件-Component-角色\" class=\"headerlink\" title=\"抽象构件(Component)角色\"></a>抽象构件(Component)角色</h3><p>由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</p>\n<h3 id=\"具体构件-ConcreteComponent-角色\"><a href=\"#具体构件-ConcreteComponent-角色\" class=\"headerlink\" title=\"具体构件(ConcreteComponent)角色\"></a>具体构件(ConcreteComponent)角色</h3><ul>\n<li>FileInputStream 从文件读取数据（字节流）</li>\n<li>ByteArrayInputStream 从字节数组读取数据（字节流）</li>\n<li>PipedInputStream 处理线程间的输入流</li>\n<li>StringBufferInputStream 处理StringBuffer</li>\n<li>ObjectInputStream 处理被序列化的对象</li>\n</ul>\n<h3 id=\"抽象装饰-Decorator-角色\"><a href=\"#抽象装饰-Decorator-角色\" class=\"headerlink\" title=\"抽象装饰(Decorator)角色\"></a>抽象装饰(Decorator)角色</h3><p>由FilterInputStream扮演</p>\n<h3 id=\"具体装饰-ConcreteDecorator-角色\"><a href=\"#具体装饰-ConcreteDecorator-角色\" class=\"headerlink\" title=\"具体装饰(ConcreteDecorator)角色\"></a>具体装饰(ConcreteDecorator)角色</h3><ul>\n<li><p>BufferedInputStream</p>\n<ul>\n<li>当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据位置。</li>\n<li>缓冲字节输入流</li>\n<li>不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多</li>\n</ul>\n</li>\n<li><p>DataInputStream</p>\n<ul>\n<li><p>把byte转换成Java基本类型</p>\n</li>\n<li><p>double readDouble() 此输入流的下八个字节，将它们解释为一个 double。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"面试\"><a href=\"#面试\" class=\"headerlink\" title=\"面试\"></a>面试</h1><h2 id=\"装饰者模式和代理模式的区别\"><a href=\"#装饰者模式和代理模式的区别\" class=\"headerlink\" title=\"装饰者模式和代理模式的区别\"></a>装饰者模式和代理模式的区别</h2><p>让别人帮助你做你并不关心的事情，叫<strong>代理模式</strong></p>\n<p>为让自己的能力增强，使得增强后的自己能够使用更多的方法，拓展在自己基础之上的功能的，叫<strong>装饰器模式</strong></p>\n<p>代理模式，常常自己内部创建被代理的对象。</p>\n<p>装饰器模式，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>\n<p>使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。  </p>\n<p>代理模式强调的是控制，装饰模式强调的是增强。<br>代理模式强调的是透明访问，装饰模式强调的是自由构建。</p>\n<p>代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制。<br>装饰，偏重对原对象功能的扩展，扩展后的对象仍是是对象本身。</p>\n<p>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。</p>\n"},{"title":"MySQL慢查询与优化","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"MySQL慢查询与优化笔记，包括慢日志、对explain的各种字段进行分析等。","abbrlink":"1cb7ab34","date":"2020-10-26T16:00:00.000Z","_content":"\n\n\n# 慢日志\n\n```mysql\nSHOW VARIABLES LIKE 'slow_query_log'; //查看慢查询日志是否打开\nSHOW VARIABLES LIKE 'slow_query_log_file';//查看慢查询日志位置\nSHOW VARIABLES LIKE 'long_query_time';//多慢会记录到慢查询日志\nshow status like '%slow_queries%';//有多少条慢查询日志 只是本次连接的\n\n//重启服务器则会失效，需要改配置文件\n//需要重新连接数据库\nset global slow_query_log = on;\nset global long_query_time = 1;\n```\n\n# explain分析\n\n一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，从而可以有针对性的提升我们查询语句的性能。\n\n![image-20210218170118879](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170118879.png)\n\nEXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table列代表着该表的表名\n\n## 字段\n\n### id \n\n+ 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id\n\n+ 查询语句中每出现一个SELECT关键字，就会为它分配一个唯一的id值。\n\n+ 对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的\n\n+ 在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表\n\n    ![image-20210218170813309](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170813309.png)\n\n### select_type   \n\nSELECT关键字对应的那个查询的类型\n\n查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型\n\n![image-20210218170932915](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170932915.png)\n\n对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY\n\n### table \n\n表名\n\n### partitions \n\n匹配的分区信息\n\n### type \n\n着MySQL对某个表的执行查询时的访问方法\n\n+ system 当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system\n+ const 当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const\n+ eq_ref 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问\n+ ref 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref\n+ range 如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法\n+ index 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index\n+ ALL 最熟悉的全表扫描\n\n### possible_keys\n\n表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些\n\npossible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。\n\n### key\n\nkey列表示实际用到的索引有哪些\n\n### key_len\n\nkey_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度\n\n它是由这三个部分构成的：\n\n+  对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是utf8， 那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。 \n+ 如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。 \n+ 对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。\n\n### ref \n\n当使用索引列等值查询时，与索引列进行等值匹配的对象信息 \n\n![image-20210218173701880](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218173701880.png)\n\n### rows 预估的需要读取的记录条数 \n\n如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。\n\n### filtered 某个表经过搜索条件过滤后剩余记录条数的百分比\n\n如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。 \n\n如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。 \n\n### Extra 一些额外的信息\n\n我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。\n\n**Using index** \n\n当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在Extra列将会提示该额外信息。比方说下边这个查询中只需要用到idx_key1而不需要回表操作：\n\n![image-20210218180232658](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180232658.png)\n\n**Using where**\n\n当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时，在Extra列中会提示上述额外信息。\n\n![image-20210218180202646](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180202646.png)\n\n","source":"_posts/数据库/MySQL数据库/03.MySQL慢查询与优化.md","raw":"---\ntitle: MySQL慢查询与优化\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: MySQL慢查询与优化笔记，包括慢日志、对explain的各种字段进行分析等。\ncategories: MySQL\ntags:\n  - 优化\n  - explain\n  - 慢查询\nabbrlink: 1cb7ab34\ndate: 2020-10-27 00:00:00\n---\n\n\n\n# 慢日志\n\n```mysql\nSHOW VARIABLES LIKE 'slow_query_log'; //查看慢查询日志是否打开\nSHOW VARIABLES LIKE 'slow_query_log_file';//查看慢查询日志位置\nSHOW VARIABLES LIKE 'long_query_time';//多慢会记录到慢查询日志\nshow status like '%slow_queries%';//有多少条慢查询日志 只是本次连接的\n\n//重启服务器则会失效，需要改配置文件\n//需要重新连接数据库\nset global slow_query_log = on;\nset global long_query_time = 1;\n```\n\n# explain分析\n\n一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，从而可以有针对性的提升我们查询语句的性能。\n\n![image-20210218170118879](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170118879.png)\n\nEXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table列代表着该表的表名\n\n## 字段\n\n### id \n\n+ 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id\n\n+ 查询语句中每出现一个SELECT关键字，就会为它分配一个唯一的id值。\n\n+ 对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的\n\n+ 在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表\n\n    ![image-20210218170813309](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170813309.png)\n\n### select_type   \n\nSELECT关键字对应的那个查询的类型\n\n查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型\n\n![image-20210218170932915](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170932915.png)\n\n对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY\n\n### table \n\n表名\n\n### partitions \n\n匹配的分区信息\n\n### type \n\n着MySQL对某个表的执行查询时的访问方法\n\n+ system 当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system\n+ const 当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const\n+ eq_ref 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问\n+ ref 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref\n+ range 如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法\n+ index 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index\n+ ALL 最熟悉的全表扫描\n\n### possible_keys\n\n表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些\n\npossible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。\n\n### key\n\nkey列表示实际用到的索引有哪些\n\n### key_len\n\nkey_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度\n\n它是由这三个部分构成的：\n\n+  对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是utf8， 那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。 \n+ 如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。 \n+ 对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。\n\n### ref \n\n当使用索引列等值查询时，与索引列进行等值匹配的对象信息 \n\n![image-20210218173701880](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218173701880.png)\n\n### rows 预估的需要读取的记录条数 \n\n如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。\n\n### filtered 某个表经过搜索条件过滤后剩余记录条数的百分比\n\n如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。 \n\n如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。 \n\n### Extra 一些额外的信息\n\n我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。\n\n**Using index** \n\n当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在Extra列将会提示该额外信息。比方说下边这个查询中只需要用到idx_key1而不需要回表操作：\n\n![image-20210218180232658](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180232658.png)\n\n**Using where**\n\n当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时，在Extra列中会提示上述额外信息。\n\n![image-20210218180202646](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180202646.png)\n\n","slug":"数据库/MySQL数据库/03.MySQL慢查询与优化","published":1,"updated":"2021-06-08T03:35:00.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq5190014z0tphoje6a60","content":"<h1 id=\"慢日志\"><a href=\"#慢日志\" class=\"headerlink\" title=\"慢日志\"></a>慢日志</h1><pre class=\" language-mysql\"><code class=\"language-mysql\">SHOW VARIABLES LIKE 'slow_query_log'; //查看慢查询日志是否打开\nSHOW VARIABLES LIKE 'slow_query_log_file';//查看慢查询日志位置\nSHOW VARIABLES LIKE 'long_query_time';//多慢会记录到慢查询日志\nshow status like '%slow_queries%';//有多少条慢查询日志 只是本次连接的\n\n//重启服务器则会失效，需要改配置文件\n//需要重新连接数据库\nset global slow_query_log = on;\nset global long_query_time = 1;</code></pre>\n<h1 id=\"explain分析\"><a href=\"#explain分析\" class=\"headerlink\" title=\"explain分析\"></a>explain分析</h1><p>一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，从而可以有针对性的提升我们查询语句的性能。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170118879.png\" alt=\"image-20210218170118879\"></p>\n<p>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table列代表着该表的表名</p>\n<h2 id=\"字段\"><a href=\"#字段\" class=\"headerlink\" title=\"字段\"></a>字段</h2><h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h3><ul>\n<li><p>在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</p>\n</li>\n<li><p>查询语句中每出现一个SELECT关键字，就会为它分配一个唯一的id值。</p>\n</li>\n<li><p>对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的</p>\n</li>\n<li><p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表</p>\n<p>  <img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170813309.png\" alt=\"image-20210218170813309\"></p>\n</li>\n</ul>\n<h3 id=\"select-type\"><a href=\"#select-type\" class=\"headerlink\" title=\"select_type\"></a>select_type</h3><p>SELECT关键字对应的那个查询的类型</p>\n<p>查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170932915.png\" alt=\"image-20210218170932915\"></p>\n<p>对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY</p>\n<h3 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h3><p>表名</p>\n<h3 id=\"partitions\"><a href=\"#partitions\" class=\"headerlink\" title=\"partitions\"></a>partitions</h3><p>匹配的分区信息</p>\n<h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h3><p>着MySQL对某个表的执行查询时的访问方法</p>\n<ul>\n<li>system 当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system</li>\n<li>const 当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const</li>\n<li>eq_ref 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问</li>\n<li>ref 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref</li>\n<li>range 如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法</li>\n<li>index 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index</li>\n<li>ALL 最熟悉的全表扫描</li>\n</ul>\n<h3 id=\"possible-keys\"><a href=\"#possible-keys\" class=\"headerlink\" title=\"possible_keys\"></a>possible_keys</h3><p>表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些</p>\n<p>possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。</p>\n<h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><p>key列表示实际用到的索引有哪些</p>\n<h3 id=\"key-len\"><a href=\"#key-len\" class=\"headerlink\" title=\"key_len\"></a>key_len</h3><p>key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度</p>\n<p>它是由这三个部分构成的：</p>\n<ul>\n<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是utf8， 那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。 </li>\n<li>如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。 </li>\n<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>\n</ul>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><p>当使用索引列等值查询时，与索引列进行等值匹配的对象信息 </p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218173701880.png\" alt=\"image-20210218173701880\"></p>\n<h3 id=\"rows-预估的需要读取的记录条数\"><a href=\"#rows-预估的需要读取的记录条数\" class=\"headerlink\" title=\"rows 预估的需要读取的记录条数\"></a>rows 预估的需要读取的记录条数</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。</p>\n<h3 id=\"filtered-某个表经过搜索条件过滤后剩余记录条数的百分比\"><a href=\"#filtered-某个表经过搜索条件过滤后剩余记录条数的百分比\" class=\"headerlink\" title=\"filtered 某个表经过搜索条件过滤后剩余记录条数的百分比\"></a>filtered 某个表经过搜索条件过滤后剩余记录条数的百分比</h3><p>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。 </p>\n<p>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。 </p>\n<h3 id=\"Extra-一些额外的信息\"><a href=\"#Extra-一些额外的信息\" class=\"headerlink\" title=\"Extra 一些额外的信息\"></a>Extra 一些额外的信息</h3><p>我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。</p>\n<p><strong>Using index</strong> </p>\n<p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在Extra列将会提示该额外信息。比方说下边这个查询中只需要用到idx_key1而不需要回表操作：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180232658.png\" alt=\"image-20210218180232658\"></p>\n<p><strong>Using where</strong></p>\n<p>当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时，在Extra列中会提示上述额外信息。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180202646.png\" alt=\"image-20210218180202646\"></p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"慢日志\"><a href=\"#慢日志\" class=\"headerlink\" title=\"慢日志\"></a>慢日志</h1><pre><code class=\"mysql\">SHOW VARIABLES LIKE &#39;slow_query_log&#39;; //查看慢查询日志是否打开\nSHOW VARIABLES LIKE &#39;slow_query_log_file&#39;;//查看慢查询日志位置\nSHOW VARIABLES LIKE &#39;long_query_time&#39;;//多慢会记录到慢查询日志\nshow status like &#39;%slow_queries%&#39;;//有多少条慢查询日志 只是本次连接的\n\n//重启服务器则会失效，需要改配置文件\n//需要重新连接数据库\nset global slow_query_log = on;\nset global long_query_time = 1;</code></pre>\n<h1 id=\"explain分析\"><a href=\"#explain分析\" class=\"headerlink\" title=\"explain分析\"></a>explain分析</h1><p>一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，从而可以有针对性的提升我们查询语句的性能。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170118879.png\" alt=\"image-20210218170118879\"></p>\n<p>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table列代表着该表的表名</p>\n<h2 id=\"字段\"><a href=\"#字段\" class=\"headerlink\" title=\"字段\"></a>字段</h2><h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h3><ul>\n<li><p>在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</p>\n</li>\n<li><p>查询语句中每出现一个SELECT关键字，就会为它分配一个唯一的id值。</p>\n</li>\n<li><p>对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的</p>\n</li>\n<li><p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表</p>\n<p>  <img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170813309.png\" alt=\"image-20210218170813309\"></p>\n</li>\n</ul>\n<h3 id=\"select-type\"><a href=\"#select-type\" class=\"headerlink\" title=\"select_type\"></a>select_type</h3><p>SELECT关键字对应的那个查询的类型</p>\n<p>查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170932915.png\" alt=\"image-20210218170932915\"></p>\n<p>对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY</p>\n<h3 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h3><p>表名</p>\n<h3 id=\"partitions\"><a href=\"#partitions\" class=\"headerlink\" title=\"partitions\"></a>partitions</h3><p>匹配的分区信息</p>\n<h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h3><p>着MySQL对某个表的执行查询时的访问方法</p>\n<ul>\n<li>system 当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system</li>\n<li>const 当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const</li>\n<li>eq_ref 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问</li>\n<li>ref 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref</li>\n<li>range 如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法</li>\n<li>index 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index</li>\n<li>ALL 最熟悉的全表扫描</li>\n</ul>\n<h3 id=\"possible-keys\"><a href=\"#possible-keys\" class=\"headerlink\" title=\"possible_keys\"></a>possible_keys</h3><p>表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些</p>\n<p>possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。</p>\n<h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><p>key列表示实际用到的索引有哪些</p>\n<h3 id=\"key-len\"><a href=\"#key-len\" class=\"headerlink\" title=\"key_len\"></a>key_len</h3><p>key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度</p>\n<p>它是由这三个部分构成的：</p>\n<ul>\n<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是utf8， 那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。 </li>\n<li>如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。 </li>\n<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>\n</ul>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><p>当使用索引列等值查询时，与索引列进行等值匹配的对象信息 </p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218173701880.png\" alt=\"image-20210218173701880\"></p>\n<h3 id=\"rows-预估的需要读取的记录条数\"><a href=\"#rows-预估的需要读取的记录条数\" class=\"headerlink\" title=\"rows 预估的需要读取的记录条数\"></a>rows 预估的需要读取的记录条数</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。</p>\n<h3 id=\"filtered-某个表经过搜索条件过滤后剩余记录条数的百分比\"><a href=\"#filtered-某个表经过搜索条件过滤后剩余记录条数的百分比\" class=\"headerlink\" title=\"filtered 某个表经过搜索条件过滤后剩余记录条数的百分比\"></a>filtered 某个表经过搜索条件过滤后剩余记录条数的百分比</h3><p>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。 </p>\n<p>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。 </p>\n<h3 id=\"Extra-一些额外的信息\"><a href=\"#Extra-一些额外的信息\" class=\"headerlink\" title=\"Extra 一些额外的信息\"></a>Extra 一些额外的信息</h3><p>我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。</p>\n<p><strong>Using index</strong> </p>\n<p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在Extra列将会提示该额外信息。比方说下边这个查询中只需要用到idx_key1而不需要回表操作：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180232658.png\" alt=\"image-20210218180232658\"></p>\n<p><strong>Using where</strong></p>\n<p>当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时，在Extra列中会提示上述额外信息。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180202646.png\" alt=\"image-20210218180202646\"></p>\n"},{"title":"MySQL索引","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"包括索引概述、页结构、各种索引模型、索引的分类、索引的实践原则等。","abbrlink":"43a71ae4","date":"2020-10-04T16:00:00.000Z","_content":"\n\n\n# 索引概述\n\n## 理解\n\n+ 索引是存储引擎用于快速找到记录的一种数据结构\n+ 索引是帮助MySQL高效获取数据的数据结构，索引存储在硬盘中\n+ 索引优化是对查询性能优化最有效的手段\n+ 存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行\n+ 索引代价：空间代价、时间代价（对数据增删改查要修改B+树的索引）\n\n\n\n+ 每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。\n+ InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。\n+ 可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。\n+ B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。\n+ 通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。\n+ 尽量少地访问资源是数据库设计的重要原则之一。\n\n## 页结构\n\n+ 各个数据页可以组成⼀个双向链表\n+ ⽽每个数据页中的记录又可以组成⼀个单向链表\n+ 每个数据页都会为存储在它里面的记录⽣成⼀个页⽬录，在通过主键查找某条记录的时候可以在页目录中使用⼆分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录\n+ 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。\n\n# 索引模型\n\n## 哈希表\n\n+ 只有Memory引擎显示支持，且是Memory引擎的默认索引类型，支持非唯一哈希索引(即冲突的以链表存储).只适用特定场合，但是性能显著\n\n+ 因为不是有序的，所以哈希索引做区间查询很慢，不支持排序\n\n+ 只适用于只有等值查询的场景\n\n+ 不能利用部分索引键查询，始终使用索引列的全部内容计算Hash，即如果有索引(A，B)，查询只有数据列A，则无法使用索引。\n\n+ Hash冲突时，必须遍历链表中所有行指针，逐行比较\n\n+ Hash在内存中，但是有几千万的数据时不行\n\n+ 可以快速的精确查询，但是不⽀持范围查询。\n\n+ 无法被用来避免数据的排序操作\n\n+ 不能避免表扫描\n\n    \n\n## 有序数组\n\n+ 在等值查询和范围查询场景中的性能就都非常优秀\n+ 只适用于静态存储引擎\n+ 往中间插入一个记录就必须得挪动后面所有的记录，成本太高\n\n\n\n## 二叉搜索树\n\n+ 一般来说索引非常大，尤其是关系型数据库这种，当数据量比较大的时候，索引的大小有可能几个G甚至更多，数据量大的索引能达到亿级别，所以为了减少内存的占用，**数据库索引是存储在外部磁盘上的**。\n+ 因为索引不止存在内存中，还要写到磁盘上。一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块\n+ 为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。\n+ 运行瓶颈在IO。IO次数太多，而且造成IO浪费\n+ 二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。\n+ 当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载每个磁盘页，磁盘页对应索引树的节点。那么Mysql衡量查询效率的标准就是磁盘IO次数。如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。那么为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好，因此B树正好符合我们的要求，这也是B-树的特征之一。\n\n## B树\n\n+ B树⼀个节点可以存储多个元素，相对于完全平衡⼆叉树整体的树⾼降低了，磁盘IO效率提⾼了。\n+ ⽽B+树是B树的升级版，只是把非叶子节点冗余⼀下，这么做的好处是为了提⾼范围查找的效率。\n+ 需要遵循一些约束，目的是尽可能存储更多的信息\n\n\n\n## B+树\n\n+ B+树很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数，磁盘读写代价更低\n+ B+树的查询效率更加稳定\n+ B+树更有利于对数据库的扫描（范围查询）\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/5824016-540158230f76f9cc.png)\n\n+ 根节点至少一个元素\n+ 非根节点元素范围：m/2 <= k <= m-1。除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女\n+ 父节点存有右孩子的第一个元素的索引。\n+ B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。\n+ 有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。\n+ 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。\n+ 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。\n\n**区别**\n\n+ B+树中间节点没有存储数据，只有叶节点存放数据，其余节点用来索引，所以同样大小的磁盘页可以容纳更多的节点元素，而B-树是每个索引节点都会有Data域。这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询是IO次数也更少。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。\n+ 其次，B+树的查询必须最终查询到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。因此，B-树的查询性能并不稳定（最好情况是只查根节点，最坏情况是查到叶子节点）。而B+树每一次查找都是稳定的。\n+ B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。对于**范围查询**，比如查询范围为3~11的元素，B-树只能依靠繁琐的中序遍历，首先自顶向下查找范围的下限，然后中序遍历找到上限。B+树的范围查询则要简单的多，首先自顶向下查找范围的下限，然后只需要在叶子节点所在的链表上做遍历即可。\n\n**优势**\n\n1.单一节点存储更多的元素，使得查询的IO次数更少。\n\n2.所有查询都要查找到叶子节点，查询性能稳定。\n\n3.所有叶子节点形成有序链表，便于范围查询。\n\n### 插入操作\n\n对于插入操作很简单，只需要记住一个技巧即可：**当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的**。\n\n下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。\n\n- 插入5，10，15，20\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-d382af5adae64c9a.png?imageMogr2/auto-orient/strip|imageView2/2/w/352/format/webp)\n\n- 插入25，此时元素数量大于4个了，分裂\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-0fdf67534b398b14.png?imageMogr2/auto-orient/strip|imageView2/2/w/542/format/webp)\n\n- 接着插入26，30，继续分裂\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-5c335f386d0d7518.png?imageMogr2/auto-orient/strip|imageView2/2/w/602/format/webp)\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-0f74727e08f5a45d.png?imageMogr2/auto-orient/strip|imageView2/2/w/687/format/webp)\n\n### 删除操作\n\n**叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key**，下面我们看看具体的实例。\n\n- 初始状态\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-8b1c2a995b8da6b9.png?imageMogr2/auto-orient/strip|imageView2/2/w/963/format/webp)\n\n- 删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-3363541b1c6a0765.png?imageMogr2/auto-orient/strip|imageView2/2/w/995/format/webp)\n\n- 删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-4ea5c178a3435518.png?imageMogr2/auto-orient/strip|imageView2/2/w/944/format/webp)\n\n- 发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-091103cefce92d4e.png?imageMogr2/auto-orient/strip|imageView2/2/w/919/format/webp)\n\n# 索引分类\n\n## 主键索引\n\n+ 也称为聚簇索引，主键索引的叶子节点存的是整行数据。\n+ 所有完整的用户记录都存放在这个聚簇索引的叶子节点处\n+ 会自动的为我们创建聚簇索引\n+ 一般是通过主键聚集数据，但是如果没有定义主键，则回选取唯一非空索引替代。若没有这样的索引，则会隐式定义一个主键作为聚簇索引\n+ 只有主键索引是聚集索引，其他的索引都是非聚集索引。数据区挂载在主键索引上\n\n## 二级索引\n\n+ 也叫非聚簇索引\n+ 按照该索引列的大小顺序排成一个单向链表\n+ 非主键索引的叶子节点内容是该（索引列、主键的值）。\n+ 由于查询结果所需要的数据只在主键索引上有，所以不得不回表。回到主键索引树搜索的过程，即回表查询\n+ 没有唯一性约束，所以索引列值为4的记录可能分布在多个数据页中\n+ 对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。\n\n## 唯一索引\n\n+ 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。\n+ 普通索引和唯一索引对更新语句性能影响的差别\n+ 因为change buffer，尽量选择普通索引。\n\n## 联合索引\n\n+ 时以多个列的大小作为排序规则，也就是同时为多个列建立索引\n+ 索引（c2，c3），先把各个记录和页按照c2列进行排序。在记录的c2列相同的情况下，采用c3列进行排序\n\n## 覆盖索引\n\n+ 索引k已经“覆盖了”我们的查询需求，不需要使用回表\n+ 覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。\n+ 最好在查询列表里只包含索引列，很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明\n\n## 前缀索引\n\n+ 使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中\n+ 要选择足够长的前缀以保证较高的选择性\n+ 索引的选择性:不重复的索引值和数据表的记录总数。索引的选择性越高则查询效率越高，因为索引的选择性高则可以在查找时过滤更多的行。唯一索引的选择性是1，是最好的索引选择性，性能最好\n+ 一般情况下某个列前缀的选择性也足够高，足以满足查询性能，大大节约索引空间\n+ 如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。\n+ alter table user add index index2(email(6));\n+ 使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。\n+ 在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。\n+ select count(distinct left(email，4)) as L4 from user;\n+ 使用前缀索引就用不上覆盖索引对查询性能的优化\n\n# 实践原则\n\n## 索引适用场景\n\n+ 全值匹配（顺序颠倒也有查询优化器帮忙）\n+ 匹配左边的列\n+ 匹配列前缀（tongji%能，%tongji则不能使用索引）\n+ 匹配范围值：先找范围左边，再找范围右边，取中间的。如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引，例如中通过name进行范围查找的记录中可能并不是按照birthday列进行排序的\n+ 精确匹配某一列并范围匹配另外一列\n+ 用于排序\n+ 用于分组\n\n## 普通索引与唯一索引\n\n尽量选择普通索引：这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响\n\n普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。\n\n### 查询操作\n\n查询性能差距微乎其微：InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。数据页的大小默认是16KB。因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。\n\n流程：对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。\n\n### 更新操作\n\n当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。\n\n对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4，400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。\n\n因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。\n\n## 自增主键\n\n+ 每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。\n+ 由于每个非主键索引的叶子节点上都是主键的值。所以主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。\n\n## 最左前缀原则\n\nMySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，**而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到**。\n\n查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的**查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的**。\n\n**最左前缀匹配原则：**在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。\n\n\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1804577-20200521182659976-48843100.png)\n\n可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现**a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引**。\n\n\n\n\n\n+ 不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。\n+ 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。\n+ 索引可以简单如⼀个列 (a)，也可以复杂如多个列 (a，b，c，d)，即联合索引。\n+ 如果是联合索引，那么key也由多个列组成，同时，索引只能⽤于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进⼀步匹配了，后续退化为线性查找。\n+ 因此，列的排列顺序决定了可命中索引的列数。\n+ MySQL会⼀直向右匹配直到遇到范围查询 （>，<，BETWEEN，LIKE）就停⽌匹配。\n\n## 索引下推优化\n\n可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\n\n## 只为用于搜索、排序或分组的列创建索引\n\n只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引\n\n## 考虑列的基数\n\n+ 指的是某一列中不重复数据的个数\n+ 且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了\n\n## 索引列的类型尽量小\n\n+ 在表示的整数范围允许的情况下，尽量让索引列使用较小的类型\n+ 对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O\n\n## 索引字符串值的前缀\n\n只对字符串的前几个字符进行索引\t\n\n## 让索引列在比较表达式中单独出现\n\n如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。\n\n## 避免冗余和重复索引\n\n重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免这样创建重复索引，发现后也应该立即移除\n\n## 选择合适的索引列顺序\n\n正确的顺序依赖于使用该索引的查询，同时需要考虑如何更好地满足排序和分组的需求将选择性最高的列放到索引的最前列","source":"_posts/数据库/MySQL数据库/01.MySQL索引.md","raw":"---\ntitle: MySQL索引\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 包括索引概述、页结构、各种索引模型、索引的分类、索引的实践原则等。\ncategories: MySQL\ntags:\n  - 索引\n  - B+树\n  - MySQL\nabbrlink: 43a71ae4\ndate: 2020-10-05 00:00:00\n---\n\n\n\n# 索引概述\n\n## 理解\n\n+ 索引是存储引擎用于快速找到记录的一种数据结构\n+ 索引是帮助MySQL高效获取数据的数据结构，索引存储在硬盘中\n+ 索引优化是对查询性能优化最有效的手段\n+ 存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行\n+ 索引代价：空间代价、时间代价（对数据增删改查要修改B+树的索引）\n\n\n\n+ 每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。\n+ InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。\n+ 可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。\n+ B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。\n+ 通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。\n+ 尽量少地访问资源是数据库设计的重要原则之一。\n\n## 页结构\n\n+ 各个数据页可以组成⼀个双向链表\n+ ⽽每个数据页中的记录又可以组成⼀个单向链表\n+ 每个数据页都会为存储在它里面的记录⽣成⼀个页⽬录，在通过主键查找某条记录的时候可以在页目录中使用⼆分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录\n+ 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。\n\n# 索引模型\n\n## 哈希表\n\n+ 只有Memory引擎显示支持，且是Memory引擎的默认索引类型，支持非唯一哈希索引(即冲突的以链表存储).只适用特定场合，但是性能显著\n\n+ 因为不是有序的，所以哈希索引做区间查询很慢，不支持排序\n\n+ 只适用于只有等值查询的场景\n\n+ 不能利用部分索引键查询，始终使用索引列的全部内容计算Hash，即如果有索引(A，B)，查询只有数据列A，则无法使用索引。\n\n+ Hash冲突时，必须遍历链表中所有行指针，逐行比较\n\n+ Hash在内存中，但是有几千万的数据时不行\n\n+ 可以快速的精确查询，但是不⽀持范围查询。\n\n+ 无法被用来避免数据的排序操作\n\n+ 不能避免表扫描\n\n    \n\n## 有序数组\n\n+ 在等值查询和范围查询场景中的性能就都非常优秀\n+ 只适用于静态存储引擎\n+ 往中间插入一个记录就必须得挪动后面所有的记录，成本太高\n\n\n\n## 二叉搜索树\n\n+ 一般来说索引非常大，尤其是关系型数据库这种，当数据量比较大的时候，索引的大小有可能几个G甚至更多，数据量大的索引能达到亿级别，所以为了减少内存的占用，**数据库索引是存储在外部磁盘上的**。\n+ 因为索引不止存在内存中，还要写到磁盘上。一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块\n+ 为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。\n+ 运行瓶颈在IO。IO次数太多，而且造成IO浪费\n+ 二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。\n+ 当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载每个磁盘页，磁盘页对应索引树的节点。那么Mysql衡量查询效率的标准就是磁盘IO次数。如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。那么为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好，因此B树正好符合我们的要求，这也是B-树的特征之一。\n\n## B树\n\n+ B树⼀个节点可以存储多个元素，相对于完全平衡⼆叉树整体的树⾼降低了，磁盘IO效率提⾼了。\n+ ⽽B+树是B树的升级版，只是把非叶子节点冗余⼀下，这么做的好处是为了提⾼范围查找的效率。\n+ 需要遵循一些约束，目的是尽可能存储更多的信息\n\n\n\n## B+树\n\n+ B+树很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数，磁盘读写代价更低\n+ B+树的查询效率更加稳定\n+ B+树更有利于对数据库的扫描（范围查询）\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/5824016-540158230f76f9cc.png)\n\n+ 根节点至少一个元素\n+ 非根节点元素范围：m/2 <= k <= m-1。除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女\n+ 父节点存有右孩子的第一个元素的索引。\n+ B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。\n+ 有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。\n+ 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。\n+ 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。\n\n**区别**\n\n+ B+树中间节点没有存储数据，只有叶节点存放数据，其余节点用来索引，所以同样大小的磁盘页可以容纳更多的节点元素，而B-树是每个索引节点都会有Data域。这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询是IO次数也更少。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。\n+ 其次，B+树的查询必须最终查询到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。因此，B-树的查询性能并不稳定（最好情况是只查根节点，最坏情况是查到叶子节点）。而B+树每一次查找都是稳定的。\n+ B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。对于**范围查询**，比如查询范围为3~11的元素，B-树只能依靠繁琐的中序遍历，首先自顶向下查找范围的下限，然后中序遍历找到上限。B+树的范围查询则要简单的多，首先自顶向下查找范围的下限，然后只需要在叶子节点所在的链表上做遍历即可。\n\n**优势**\n\n1.单一节点存储更多的元素，使得查询的IO次数更少。\n\n2.所有查询都要查找到叶子节点，查询性能稳定。\n\n3.所有叶子节点形成有序链表，便于范围查询。\n\n### 插入操作\n\n对于插入操作很简单，只需要记住一个技巧即可：**当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的**。\n\n下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。\n\n- 插入5，10，15，20\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-d382af5adae64c9a.png?imageMogr2/auto-orient/strip|imageView2/2/w/352/format/webp)\n\n- 插入25，此时元素数量大于4个了，分裂\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-0fdf67534b398b14.png?imageMogr2/auto-orient/strip|imageView2/2/w/542/format/webp)\n\n- 接着插入26，30，继续分裂\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-5c335f386d0d7518.png?imageMogr2/auto-orient/strip|imageView2/2/w/602/format/webp)\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-0f74727e08f5a45d.png?imageMogr2/auto-orient/strip|imageView2/2/w/687/format/webp)\n\n### 删除操作\n\n**叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key**，下面我们看看具体的实例。\n\n- 初始状态\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-8b1c2a995b8da6b9.png?imageMogr2/auto-orient/strip|imageView2/2/w/963/format/webp)\n\n- 删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-3363541b1c6a0765.png?imageMogr2/auto-orient/strip|imageView2/2/w/995/format/webp)\n\n- 删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-4ea5c178a3435518.png?imageMogr2/auto-orient/strip|imageView2/2/w/944/format/webp)\n\n- 发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作\n\n![img](https:////upload-images.jianshu.io/upload_images/5824016-091103cefce92d4e.png?imageMogr2/auto-orient/strip|imageView2/2/w/919/format/webp)\n\n# 索引分类\n\n## 主键索引\n\n+ 也称为聚簇索引，主键索引的叶子节点存的是整行数据。\n+ 所有完整的用户记录都存放在这个聚簇索引的叶子节点处\n+ 会自动的为我们创建聚簇索引\n+ 一般是通过主键聚集数据，但是如果没有定义主键，则回选取唯一非空索引替代。若没有这样的索引，则会隐式定义一个主键作为聚簇索引\n+ 只有主键索引是聚集索引，其他的索引都是非聚集索引。数据区挂载在主键索引上\n\n## 二级索引\n\n+ 也叫非聚簇索引\n+ 按照该索引列的大小顺序排成一个单向链表\n+ 非主键索引的叶子节点内容是该（索引列、主键的值）。\n+ 由于查询结果所需要的数据只在主键索引上有，所以不得不回表。回到主键索引树搜索的过程，即回表查询\n+ 没有唯一性约束，所以索引列值为4的记录可能分布在多个数据页中\n+ 对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。\n\n## 唯一索引\n\n+ 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。\n+ 普通索引和唯一索引对更新语句性能影响的差别\n+ 因为change buffer，尽量选择普通索引。\n\n## 联合索引\n\n+ 时以多个列的大小作为排序规则，也就是同时为多个列建立索引\n+ 索引（c2，c3），先把各个记录和页按照c2列进行排序。在记录的c2列相同的情况下，采用c3列进行排序\n\n## 覆盖索引\n\n+ 索引k已经“覆盖了”我们的查询需求，不需要使用回表\n+ 覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。\n+ 最好在查询列表里只包含索引列，很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明\n\n## 前缀索引\n\n+ 使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中\n+ 要选择足够长的前缀以保证较高的选择性\n+ 索引的选择性:不重复的索引值和数据表的记录总数。索引的选择性越高则查询效率越高，因为索引的选择性高则可以在查找时过滤更多的行。唯一索引的选择性是1，是最好的索引选择性，性能最好\n+ 一般情况下某个列前缀的选择性也足够高，足以满足查询性能，大大节约索引空间\n+ 如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。\n+ alter table user add index index2(email(6));\n+ 使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。\n+ 在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。\n+ select count(distinct left(email，4)) as L4 from user;\n+ 使用前缀索引就用不上覆盖索引对查询性能的优化\n\n# 实践原则\n\n## 索引适用场景\n\n+ 全值匹配（顺序颠倒也有查询优化器帮忙）\n+ 匹配左边的列\n+ 匹配列前缀（tongji%能，%tongji则不能使用索引）\n+ 匹配范围值：先找范围左边，再找范围右边，取中间的。如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引，例如中通过name进行范围查找的记录中可能并不是按照birthday列进行排序的\n+ 精确匹配某一列并范围匹配另外一列\n+ 用于排序\n+ 用于分组\n\n## 普通索引与唯一索引\n\n尽量选择普通索引：这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响\n\n普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。\n\n### 查询操作\n\n查询性能差距微乎其微：InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。数据页的大小默认是16KB。因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。\n\n流程：对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。\n\n### 更新操作\n\n当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。\n\n对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4，400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。\n\n因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。\n\n## 自增主键\n\n+ 每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。\n+ 由于每个非主键索引的叶子节点上都是主键的值。所以主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。\n\n## 最左前缀原则\n\nMySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，**而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到**。\n\n查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的**查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的**。\n\n**最左前缀匹配原则：**在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。\n\n\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1804577-20200521182659976-48843100.png)\n\n可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现**a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引**。\n\n\n\n\n\n+ 不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。\n+ 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。\n+ 索引可以简单如⼀个列 (a)，也可以复杂如多个列 (a，b，c，d)，即联合索引。\n+ 如果是联合索引，那么key也由多个列组成，同时，索引只能⽤于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进⼀步匹配了，后续退化为线性查找。\n+ 因此，列的排列顺序决定了可命中索引的列数。\n+ MySQL会⼀直向右匹配直到遇到范围查询 （>，<，BETWEEN，LIKE）就停⽌匹配。\n\n## 索引下推优化\n\n可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\n\n## 只为用于搜索、排序或分组的列创建索引\n\n只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引\n\n## 考虑列的基数\n\n+ 指的是某一列中不重复数据的个数\n+ 且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了\n\n## 索引列的类型尽量小\n\n+ 在表示的整数范围允许的情况下，尽量让索引列使用较小的类型\n+ 对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O\n\n## 索引字符串值的前缀\n\n只对字符串的前几个字符进行索引\t\n\n## 让索引列在比较表达式中单独出现\n\n如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。\n\n## 避免冗余和重复索引\n\n重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免这样创建重复索引，发现后也应该立即移除\n\n## 选择合适的索引列顺序\n\n正确的顺序依赖于使用该索引的查询，同时需要考虑如何更好地满足排序和分组的需求将选择性最高的列放到索引的最前列","slug":"数据库/MySQL数据库/01.MySQL索引","published":1,"updated":"2021-06-08T03:35:00.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq51b0017z0tp6kosepl6","content":"<h1 id=\"索引概述\"><a href=\"#索引概述\" class=\"headerlink\" title=\"索引概述\"></a>索引概述</h1><h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><ul>\n<li>索引是存储引擎用于快速找到记录的一种数据结构</li>\n<li>索引是帮助MySQL高效获取数据的数据结构，索引存储在硬盘中</li>\n<li>索引优化是对查询性能优化最有效的手段</li>\n<li>存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行</li>\n<li>索引代价：空间代价、时间代价（对数据增删改查要修改B+树的索引）</li>\n</ul>\n<ul>\n<li>每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。</li>\n<li>InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。</li>\n<li>可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li>\n<li>B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</li>\n<li>通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。</li>\n<li>尽量少地访问资源是数据库设计的重要原则之一。</li>\n</ul>\n<h2 id=\"页结构\"><a href=\"#页结构\" class=\"headerlink\" title=\"页结构\"></a>页结构</h2><ul>\n<li>各个数据页可以组成⼀个双向链表</li>\n<li>⽽每个数据页中的记录又可以组成⼀个单向链表</li>\n<li>每个数据页都会为存储在它里面的记录⽣成⼀个页⽬录，在通过主键查找某条记录的时候可以在页目录中使用⼆分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li>\n<li>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</li>\n</ul>\n<h1 id=\"索引模型\"><a href=\"#索引模型\" class=\"headerlink\" title=\"索引模型\"></a>索引模型</h1><h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><ul>\n<li><p>只有Memory引擎显示支持，且是Memory引擎的默认索引类型，支持非唯一哈希索引(即冲突的以链表存储).只适用特定场合，但是性能显著</p>\n</li>\n<li><p>因为不是有序的，所以哈希索引做区间查询很慢，不支持排序</p>\n</li>\n<li><p>只适用于只有等值查询的场景</p>\n</li>\n<li><p>不能利用部分索引键查询，始终使用索引列的全部内容计算Hash，即如果有索引(A，B)，查询只有数据列A，则无法使用索引。</p>\n</li>\n<li><p>Hash冲突时，必须遍历链表中所有行指针，逐行比较</p>\n</li>\n<li><p>Hash在内存中，但是有几千万的数据时不行</p>\n</li>\n<li><p>可以快速的精确查询，但是不⽀持范围查询。</p>\n</li>\n<li><p>无法被用来避免数据的排序操作</p>\n</li>\n<li><p>不能避免表扫描</p>\n</li>\n</ul>\n<h2 id=\"有序数组\"><a href=\"#有序数组\" class=\"headerlink\" title=\"有序数组\"></a>有序数组</h2><ul>\n<li>在等值查询和范围查询场景中的性能就都非常优秀</li>\n<li>只适用于静态存储引擎</li>\n<li>往中间插入一个记录就必须得挪动后面所有的记录，成本太高</li>\n</ul>\n<h2 id=\"二叉搜索树\"><a href=\"#二叉搜索树\" class=\"headerlink\" title=\"二叉搜索树\"></a>二叉搜索树</h2><ul>\n<li>一般来说索引非常大，尤其是关系型数据库这种，当数据量比较大的时候，索引的大小有可能几个G甚至更多，数据量大的索引能达到亿级别，所以为了减少内存的占用，<strong>数据库索引是存储在外部磁盘上的</strong>。</li>\n<li>因为索引不止存在内存中，还要写到磁盘上。一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块</li>\n<li>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。</li>\n<li>运行瓶颈在IO。IO次数太多，而且造成IO浪费</li>\n<li>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</li>\n<li>当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载每个磁盘页，磁盘页对应索引树的节点。那么Mysql衡量查询效率的标准就是磁盘IO次数。如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。那么为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好，因此B树正好符合我们的要求，这也是B-树的特征之一。</li>\n</ul>\n<h2 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h2><ul>\n<li>B树⼀个节点可以存储多个元素，相对于完全平衡⼆叉树整体的树⾼降低了，磁盘IO效率提⾼了。</li>\n<li>⽽B+树是B树的升级版，只是把非叶子节点冗余⼀下，这么做的好处是为了提⾼范围查找的效率。</li>\n<li>需要遵循一些约束，目的是尽可能存储更多的信息</li>\n</ul>\n<h2 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h2><ul>\n<li>B+树很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数，磁盘读写代价更低</li>\n<li>B+树的查询效率更加稳定</li>\n<li>B+树更有利于对数据库的扫描（范围查询）</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/5824016-540158230f76f9cc.png\"></p>\n<ul>\n<li>根节点至少一个元素</li>\n<li>非根节点元素范围：m/2 &lt;= k &lt;= m-1。除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女</li>\n<li>父节点存有右孩子的第一个元素的索引。</li>\n<li>B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。</li>\n<li>有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</li>\n<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>\n<li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</li>\n</ul>\n<p><strong>区别</strong></p>\n<ul>\n<li>B+树中间节点没有存储数据，只有叶节点存放数据，其余节点用来索引，所以同样大小的磁盘页可以容纳更多的节点元素，而B-树是每个索引节点都会有Data域。这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询是IO次数也更少。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。</li>\n<li>其次，B+树的查询必须最终查询到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。因此，B-树的查询性能并不稳定（最好情况是只查根节点，最坏情况是查到叶子节点）。而B+树每一次查找都是稳定的。</li>\n<li>B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。对于<strong>范围查询</strong>，比如查询范围为3~11的元素，B-树只能依靠繁琐的中序遍历，首先自顶向下查找范围的下限，然后中序遍历找到上限。B+树的范围查询则要简单的多，首先自顶向下查找范围的下限，然后只需要在叶子节点所在的链表上做遍历即可。</li>\n</ul>\n<p><strong>优势</strong></p>\n<p>1.单一节点存储更多的元素，使得查询的IO次数更少。</p>\n<p>2.所有查询都要查找到叶子节点，查询性能稳定。</p>\n<p>3.所有叶子节点形成有序链表，便于范围查询。</p>\n<h3 id=\"插入操作\"><a href=\"#插入操作\" class=\"headerlink\" title=\"插入操作\"></a>插入操作</h3><p>对于插入操作很简单，只需要记住一个技巧即可：<strong>当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的</strong>。</p>\n<p>下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。</p>\n<ul>\n<li>插入5，10，15，20</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-d382af5adae64c9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/352/format/webp\" alt=\"img\"></p>\n<ul>\n<li>插入25，此时元素数量大于4个了，分裂</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-0fdf67534b398b14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/542/format/webp\" alt=\"img\"></p>\n<ul>\n<li>接着插入26，30，继续分裂</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-5c335f386d0d7518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/602/format/webp\" alt=\"img\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-0f74727e08f5a45d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/687/format/webp\" alt=\"img\"></p>\n<h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3><p><strong>叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key</strong>，下面我们看看具体的实例。</p>\n<ul>\n<li>初始状态</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-8b1c2a995b8da6b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/963/format/webp\" alt=\"img\"></p>\n<ul>\n<li>删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-3363541b1c6a0765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/995/format/webp\" alt=\"img\"></p>\n<ul>\n<li>删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-4ea5c178a3435518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/944/format/webp\" alt=\"img\"></p>\n<ul>\n<li>发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-091103cefce92d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/919/format/webp\" alt=\"img\"></p>\n<h1 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h1><h2 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h2><ul>\n<li>也称为聚簇索引，主键索引的叶子节点存的是整行数据。</li>\n<li>所有完整的用户记录都存放在这个聚簇索引的叶子节点处</li>\n<li>会自动的为我们创建聚簇索引</li>\n<li>一般是通过主键聚集数据，但是如果没有定义主键，则回选取唯一非空索引替代。若没有这样的索引，则会隐式定义一个主键作为聚簇索引</li>\n<li>只有主键索引是聚集索引，其他的索引都是非聚集索引。数据区挂载在主键索引上</li>\n</ul>\n<h2 id=\"二级索引\"><a href=\"#二级索引\" class=\"headerlink\" title=\"二级索引\"></a>二级索引</h2><ul>\n<li>也叫非聚簇索引</li>\n<li>按照该索引列的大小顺序排成一个单向链表</li>\n<li>非主键索引的叶子节点内容是该（索引列、主键的值）。</li>\n<li>由于查询结果所需要的数据只在主键索引上有，所以不得不回表。回到主键索引树搜索的过程，即回表查询</li>\n<li>没有唯一性约束，所以索引列值为4的记录可能分布在多个数据页中</li>\n<li>对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</li>\n</ul>\n<h2 id=\"唯一索引\"><a href=\"#唯一索引\" class=\"headerlink\" title=\"唯一索引\"></a>唯一索引</h2><ul>\n<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li>\n<li>普通索引和唯一索引对更新语句性能影响的差别</li>\n<li>因为change buffer，尽量选择普通索引。</li>\n</ul>\n<h2 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h2><ul>\n<li>时以多个列的大小作为排序规则，也就是同时为多个列建立索引</li>\n<li>索引（c2，c3），先把各个记录和页按照c2列进行排序。在记录的c2列相同的情况下，采用c3列进行排序</li>\n</ul>\n<h2 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h2><ul>\n<li>索引k已经“覆盖了”我们的查询需求，不需要使用回表</li>\n<li>覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</li>\n<li>最好在查询列表里只包含索引列，很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明</li>\n</ul>\n<h2 id=\"前缀索引\"><a href=\"#前缀索引\" class=\"headerlink\" title=\"前缀索引\"></a>前缀索引</h2><ul>\n<li>使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中</li>\n<li>要选择足够长的前缀以保证较高的选择性</li>\n<li>索引的选择性:不重复的索引值和数据表的记录总数。索引的选择性越高则查询效率越高，因为索引的选择性高则可以在查找时过滤更多的行。唯一索引的选择性是1，是最好的索引选择性，性能最好</li>\n<li>一般情况下某个列前缀的选择性也足够高，足以满足查询性能，大大节约索引空间</li>\n<li>如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</li>\n<li>alter table user add index index2(email(6));</li>\n<li>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</li>\n<li>在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</li>\n<li>select count(distinct left(email，4)) as L4 from user;</li>\n<li>使用前缀索引就用不上覆盖索引对查询性能的优化</li>\n</ul>\n<h1 id=\"实践原则\"><a href=\"#实践原则\" class=\"headerlink\" title=\"实践原则\"></a>实践原则</h1><h2 id=\"索引适用场景\"><a href=\"#索引适用场景\" class=\"headerlink\" title=\"索引适用场景\"></a>索引适用场景</h2><ul>\n<li>全值匹配（顺序颠倒也有查询优化器帮忙）</li>\n<li>匹配左边的列</li>\n<li>匹配列前缀（tongji%能，%tongji则不能使用索引）</li>\n<li>匹配范围值：先找范围左边，再找范围右边，取中间的。如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引，例如中通过name进行范围查找的记录中可能并不是按照birthday列进行排序的</li>\n<li>精确匹配某一列并范围匹配另外一列</li>\n<li>用于排序</li>\n<li>用于分组</li>\n</ul>\n<h2 id=\"普通索引与唯一索引\"><a href=\"#普通索引与唯一索引\" class=\"headerlink\" title=\"普通索引与唯一索引\"></a>普通索引与唯一索引</h2><p>尽量选择普通索引：这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响</p>\n<p>普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。</p>\n<h3 id=\"查询操作\"><a href=\"#查询操作\" class=\"headerlink\" title=\"查询操作\"></a>查询操作</h3><p>查询性能差距微乎其微：InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。数据页的大小默认是16KB。因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p>\n<p>流程：对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p>\n<h3 id=\"更新操作\"><a href=\"#更新操作\" class=\"headerlink\" title=\"更新操作\"></a>更新操作</h3><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。</p>\n<p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4，400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。</p>\n<p>因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。</p>\n<h2 id=\"自增主键\"><a href=\"#自增主键\" class=\"headerlink\" title=\"自增主键\"></a>自增主键</h2><ul>\n<li>每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</li>\n<li>由于每个非主键索引的叶子节点上都是主键的值。所以主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</li>\n</ul>\n<h2 id=\"最左前缀原则\"><a href=\"#最左前缀原则\" class=\"headerlink\" title=\"最左前缀原则\"></a>最左前缀原则</h2><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，<strong>而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到</strong>。</p>\n<p>查询的时候如果两个条件都用上了，但是顺序不同，如 <code>city= xx and name ＝xx</code>，那么现在的<strong>查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的</strong>。</p>\n<p><strong>最左前缀匹配原则：</strong>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1804577-20200521182659976-48843100.png\"></p>\n<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现<strong>a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引</strong>。</p>\n<ul>\n<li>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</li>\n<li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>\n<li>索引可以简单如⼀个列 (a)，也可以复杂如多个列 (a，b，c，d)，即联合索引。</li>\n<li>如果是联合索引，那么key也由多个列组成，同时，索引只能⽤于查找key是否存在（相等），遇到范围查询 (&gt;、&lt;、between、like左匹配)等就不能进⼀步匹配了，后续退化为线性查找。</li>\n<li>因此，列的排列顺序决定了可命中索引的列数。</li>\n<li>MySQL会⼀直向右匹配直到遇到范围查询 （&gt;，&lt;，BETWEEN，LIKE）就停⽌匹配。</li>\n</ul>\n<h2 id=\"索引下推优化\"><a href=\"#索引下推优化\" class=\"headerlink\" title=\"索引下推优化\"></a>索引下推优化</h2><p>可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>\n<h2 id=\"只为用于搜索、排序或分组的列创建索引\"><a href=\"#只为用于搜索、排序或分组的列创建索引\" class=\"headerlink\" title=\"只为用于搜索、排序或分组的列创建索引\"></a>只为用于搜索、排序或分组的列创建索引</h2><p>只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引</p>\n<h2 id=\"考虑列的基数\"><a href=\"#考虑列的基数\" class=\"headerlink\" title=\"考虑列的基数\"></a>考虑列的基数</h2><ul>\n<li>指的是某一列中不重复数据的个数</li>\n<li>且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了</li>\n</ul>\n<h2 id=\"索引列的类型尽量小\"><a href=\"#索引列的类型尽量小\" class=\"headerlink\" title=\"索引列的类型尽量小\"></a>索引列的类型尽量小</h2><ul>\n<li>在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</li>\n<li>对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O</li>\n</ul>\n<h2 id=\"索引字符串值的前缀\"><a href=\"#索引字符串值的前缀\" class=\"headerlink\" title=\"索引字符串值的前缀\"></a>索引字符串值的前缀</h2><p>只对字符串的前几个字符进行索引    </p>\n<h2 id=\"让索引列在比较表达式中单独出现\"><a href=\"#让索引列在比较表达式中单独出现\" class=\"headerlink\" title=\"让索引列在比较表达式中单独出现\"></a>让索引列在比较表达式中单独出现</h2><p>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p>\n<h2 id=\"避免冗余和重复索引\"><a href=\"#避免冗余和重复索引\" class=\"headerlink\" title=\"避免冗余和重复索引\"></a>避免冗余和重复索引</h2><p>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免这样创建重复索引，发现后也应该立即移除</p>\n<h2 id=\"选择合适的索引列顺序\"><a href=\"#选择合适的索引列顺序\" class=\"headerlink\" title=\"选择合适的索引列顺序\"></a>选择合适的索引列顺序</h2><p>正确的顺序依赖于使用该索引的查询，同时需要考虑如何更好地满足排序和分组的需求将选择性最高的列放到索引的最前列</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"索引概述\"><a href=\"#索引概述\" class=\"headerlink\" title=\"索引概述\"></a>索引概述</h1><h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><ul>\n<li>索引是存储引擎用于快速找到记录的一种数据结构</li>\n<li>索引是帮助MySQL高效获取数据的数据结构，索引存储在硬盘中</li>\n<li>索引优化是对查询性能优化最有效的手段</li>\n<li>存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行</li>\n<li>索引代价：空间代价、时间代价（对数据增删改查要修改B+树的索引）</li>\n</ul>\n<ul>\n<li>每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。</li>\n<li>InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。</li>\n<li>可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li>\n<li>B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</li>\n<li>通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。</li>\n<li>尽量少地访问资源是数据库设计的重要原则之一。</li>\n</ul>\n<h2 id=\"页结构\"><a href=\"#页结构\" class=\"headerlink\" title=\"页结构\"></a>页结构</h2><ul>\n<li>各个数据页可以组成⼀个双向链表</li>\n<li>⽽每个数据页中的记录又可以组成⼀个单向链表</li>\n<li>每个数据页都会为存储在它里面的记录⽣成⼀个页⽬录，在通过主键查找某条记录的时候可以在页目录中使用⼆分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li>\n<li>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</li>\n</ul>\n<h1 id=\"索引模型\"><a href=\"#索引模型\" class=\"headerlink\" title=\"索引模型\"></a>索引模型</h1><h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><ul>\n<li><p>只有Memory引擎显示支持，且是Memory引擎的默认索引类型，支持非唯一哈希索引(即冲突的以链表存储).只适用特定场合，但是性能显著</p>\n</li>\n<li><p>因为不是有序的，所以哈希索引做区间查询很慢，不支持排序</p>\n</li>\n<li><p>只适用于只有等值查询的场景</p>\n</li>\n<li><p>不能利用部分索引键查询，始终使用索引列的全部内容计算Hash，即如果有索引(A，B)，查询只有数据列A，则无法使用索引。</p>\n</li>\n<li><p>Hash冲突时，必须遍历链表中所有行指针，逐行比较</p>\n</li>\n<li><p>Hash在内存中，但是有几千万的数据时不行</p>\n</li>\n<li><p>可以快速的精确查询，但是不⽀持范围查询。</p>\n</li>\n<li><p>无法被用来避免数据的排序操作</p>\n</li>\n<li><p>不能避免表扫描</p>\n</li>\n</ul>\n<h2 id=\"有序数组\"><a href=\"#有序数组\" class=\"headerlink\" title=\"有序数组\"></a>有序数组</h2><ul>\n<li>在等值查询和范围查询场景中的性能就都非常优秀</li>\n<li>只适用于静态存储引擎</li>\n<li>往中间插入一个记录就必须得挪动后面所有的记录，成本太高</li>\n</ul>\n<h2 id=\"二叉搜索树\"><a href=\"#二叉搜索树\" class=\"headerlink\" title=\"二叉搜索树\"></a>二叉搜索树</h2><ul>\n<li>一般来说索引非常大，尤其是关系型数据库这种，当数据量比较大的时候，索引的大小有可能几个G甚至更多，数据量大的索引能达到亿级别，所以为了减少内存的占用，<strong>数据库索引是存储在外部磁盘上的</strong>。</li>\n<li>因为索引不止存在内存中，还要写到磁盘上。一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块</li>\n<li>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。</li>\n<li>运行瓶颈在IO。IO次数太多，而且造成IO浪费</li>\n<li>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</li>\n<li>当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载每个磁盘页，磁盘页对应索引树的节点。那么Mysql衡量查询效率的标准就是磁盘IO次数。如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。那么为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好，因此B树正好符合我们的要求，这也是B-树的特征之一。</li>\n</ul>\n<h2 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h2><ul>\n<li>B树⼀个节点可以存储多个元素，相对于完全平衡⼆叉树整体的树⾼降低了，磁盘IO效率提⾼了。</li>\n<li>⽽B+树是B树的升级版，只是把非叶子节点冗余⼀下，这么做的好处是为了提⾼范围查找的效率。</li>\n<li>需要遵循一些约束，目的是尽可能存储更多的信息</li>\n</ul>\n<h2 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h2><ul>\n<li>B+树很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数，磁盘读写代价更低</li>\n<li>B+树的查询效率更加稳定</li>\n<li>B+树更有利于对数据库的扫描（范围查询）</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/5824016-540158230f76f9cc.png\"></p>\n<ul>\n<li>根节点至少一个元素</li>\n<li>非根节点元素范围：m/2 &lt;= k &lt;= m-1。除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女</li>\n<li>父节点存有右孩子的第一个元素的索引。</li>\n<li>B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。</li>\n<li>有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</li>\n<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>\n<li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</li>\n</ul>\n<p><strong>区别</strong></p>\n<ul>\n<li>B+树中间节点没有存储数据，只有叶节点存放数据，其余节点用来索引，所以同样大小的磁盘页可以容纳更多的节点元素，而B-树是每个索引节点都会有Data域。这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询是IO次数也更少。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。</li>\n<li>其次，B+树的查询必须最终查询到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。因此，B-树的查询性能并不稳定（最好情况是只查根节点，最坏情况是查到叶子节点）。而B+树每一次查找都是稳定的。</li>\n<li>B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。对于<strong>范围查询</strong>，比如查询范围为3~11的元素，B-树只能依靠繁琐的中序遍历，首先自顶向下查找范围的下限，然后中序遍历找到上限。B+树的范围查询则要简单的多，首先自顶向下查找范围的下限，然后只需要在叶子节点所在的链表上做遍历即可。</li>\n</ul>\n<p><strong>优势</strong></p>\n<p>1.单一节点存储更多的元素，使得查询的IO次数更少。</p>\n<p>2.所有查询都要查找到叶子节点，查询性能稳定。</p>\n<p>3.所有叶子节点形成有序链表，便于范围查询。</p>\n<h3 id=\"插入操作\"><a href=\"#插入操作\" class=\"headerlink\" title=\"插入操作\"></a>插入操作</h3><p>对于插入操作很简单，只需要记住一个技巧即可：<strong>当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的</strong>。</p>\n<p>下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。</p>\n<ul>\n<li>插入5，10，15，20</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-d382af5adae64c9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/352/format/webp\" alt=\"img\"></p>\n<ul>\n<li>插入25，此时元素数量大于4个了，分裂</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-0fdf67534b398b14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/542/format/webp\" alt=\"img\"></p>\n<ul>\n<li>接着插入26，30，继续分裂</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-5c335f386d0d7518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/602/format/webp\" alt=\"img\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-0f74727e08f5a45d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/687/format/webp\" alt=\"img\"></p>\n<h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3><p><strong>叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key</strong>，下面我们看看具体的实例。</p>\n<ul>\n<li>初始状态</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-8b1c2a995b8da6b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/963/format/webp\" alt=\"img\"></p>\n<ul>\n<li>删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-3363541b1c6a0765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/995/format/webp\" alt=\"img\"></p>\n<ul>\n<li>删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-4ea5c178a3435518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/944/format/webp\" alt=\"img\"></p>\n<ul>\n<li>发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5824016-091103cefce92d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/919/format/webp\" alt=\"img\"></p>\n<h1 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h1><h2 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h2><ul>\n<li>也称为聚簇索引，主键索引的叶子节点存的是整行数据。</li>\n<li>所有完整的用户记录都存放在这个聚簇索引的叶子节点处</li>\n<li>会自动的为我们创建聚簇索引</li>\n<li>一般是通过主键聚集数据，但是如果没有定义主键，则回选取唯一非空索引替代。若没有这样的索引，则会隐式定义一个主键作为聚簇索引</li>\n<li>只有主键索引是聚集索引，其他的索引都是非聚集索引。数据区挂载在主键索引上</li>\n</ul>\n<h2 id=\"二级索引\"><a href=\"#二级索引\" class=\"headerlink\" title=\"二级索引\"></a>二级索引</h2><ul>\n<li>也叫非聚簇索引</li>\n<li>按照该索引列的大小顺序排成一个单向链表</li>\n<li>非主键索引的叶子节点内容是该（索引列、主键的值）。</li>\n<li>由于查询结果所需要的数据只在主键索引上有，所以不得不回表。回到主键索引树搜索的过程，即回表查询</li>\n<li>没有唯一性约束，所以索引列值为4的记录可能分布在多个数据页中</li>\n<li>对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</li>\n</ul>\n<h2 id=\"唯一索引\"><a href=\"#唯一索引\" class=\"headerlink\" title=\"唯一索引\"></a>唯一索引</h2><ul>\n<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li>\n<li>普通索引和唯一索引对更新语句性能影响的差别</li>\n<li>因为change buffer，尽量选择普通索引。</li>\n</ul>\n<h2 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h2><ul>\n<li>时以多个列的大小作为排序规则，也就是同时为多个列建立索引</li>\n<li>索引（c2，c3），先把各个记录和页按照c2列进行排序。在记录的c2列相同的情况下，采用c3列进行排序</li>\n</ul>\n<h2 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h2><ul>\n<li>索引k已经“覆盖了”我们的查询需求，不需要使用回表</li>\n<li>覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</li>\n<li>最好在查询列表里只包含索引列，很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明</li>\n</ul>\n<h2 id=\"前缀索引\"><a href=\"#前缀索引\" class=\"headerlink\" title=\"前缀索引\"></a>前缀索引</h2><ul>\n<li>使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中</li>\n<li>要选择足够长的前缀以保证较高的选择性</li>\n<li>索引的选择性:不重复的索引值和数据表的记录总数。索引的选择性越高则查询效率越高，因为索引的选择性高则可以在查找时过滤更多的行。唯一索引的选择性是1，是最好的索引选择性，性能最好</li>\n<li>一般情况下某个列前缀的选择性也足够高，足以满足查询性能，大大节约索引空间</li>\n<li>如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</li>\n<li>alter table user add index index2(email(6));</li>\n<li>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</li>\n<li>在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</li>\n<li>select count(distinct left(email，4)) as L4 from user;</li>\n<li>使用前缀索引就用不上覆盖索引对查询性能的优化</li>\n</ul>\n<h1 id=\"实践原则\"><a href=\"#实践原则\" class=\"headerlink\" title=\"实践原则\"></a>实践原则</h1><h2 id=\"索引适用场景\"><a href=\"#索引适用场景\" class=\"headerlink\" title=\"索引适用场景\"></a>索引适用场景</h2><ul>\n<li>全值匹配（顺序颠倒也有查询优化器帮忙）</li>\n<li>匹配左边的列</li>\n<li>匹配列前缀（tongji%能，%tongji则不能使用索引）</li>\n<li>匹配范围值：先找范围左边，再找范围右边，取中间的。如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引，例如中通过name进行范围查找的记录中可能并不是按照birthday列进行排序的</li>\n<li>精确匹配某一列并范围匹配另外一列</li>\n<li>用于排序</li>\n<li>用于分组</li>\n</ul>\n<h2 id=\"普通索引与唯一索引\"><a href=\"#普通索引与唯一索引\" class=\"headerlink\" title=\"普通索引与唯一索引\"></a>普通索引与唯一索引</h2><p>尽量选择普通索引：这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响</p>\n<p>普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。</p>\n<h3 id=\"查询操作\"><a href=\"#查询操作\" class=\"headerlink\" title=\"查询操作\"></a>查询操作</h3><p>查询性能差距微乎其微：InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。数据页的大小默认是16KB。因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p>\n<p>流程：对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p>\n<h3 id=\"更新操作\"><a href=\"#更新操作\" class=\"headerlink\" title=\"更新操作\"></a>更新操作</h3><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。</p>\n<p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4，400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。</p>\n<p>因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。</p>\n<h2 id=\"自增主键\"><a href=\"#自增主键\" class=\"headerlink\" title=\"自增主键\"></a>自增主键</h2><ul>\n<li>每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</li>\n<li>由于每个非主键索引的叶子节点上都是主键的值。所以主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</li>\n</ul>\n<h2 id=\"最左前缀原则\"><a href=\"#最左前缀原则\" class=\"headerlink\" title=\"最左前缀原则\"></a>最左前缀原则</h2><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，<strong>而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到</strong>。</p>\n<p>查询的时候如果两个条件都用上了，但是顺序不同，如 <code>city= xx and name ＝xx</code>，那么现在的<strong>查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的</strong>。</p>\n<p><strong>最左前缀匹配原则：</strong>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1804577-20200521182659976-48843100.png\"></p>\n<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现<strong>a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引</strong>。</p>\n<ul>\n<li>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</li>\n<li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>\n<li>索引可以简单如⼀个列 (a)，也可以复杂如多个列 (a，b，c，d)，即联合索引。</li>\n<li>如果是联合索引，那么key也由多个列组成，同时，索引只能⽤于查找key是否存在（相等），遇到范围查询 (&gt;、&lt;、between、like左匹配)等就不能进⼀步匹配了，后续退化为线性查找。</li>\n<li>因此，列的排列顺序决定了可命中索引的列数。</li>\n<li>MySQL会⼀直向右匹配直到遇到范围查询 （&gt;，&lt;，BETWEEN，LIKE）就停⽌匹配。</li>\n</ul>\n<h2 id=\"索引下推优化\"><a href=\"#索引下推优化\" class=\"headerlink\" title=\"索引下推优化\"></a>索引下推优化</h2><p>可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>\n<h2 id=\"只为用于搜索、排序或分组的列创建索引\"><a href=\"#只为用于搜索、排序或分组的列创建索引\" class=\"headerlink\" title=\"只为用于搜索、排序或分组的列创建索引\"></a>只为用于搜索、排序或分组的列创建索引</h2><p>只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引</p>\n<h2 id=\"考虑列的基数\"><a href=\"#考虑列的基数\" class=\"headerlink\" title=\"考虑列的基数\"></a>考虑列的基数</h2><ul>\n<li>指的是某一列中不重复数据的个数</li>\n<li>且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了</li>\n</ul>\n<h2 id=\"索引列的类型尽量小\"><a href=\"#索引列的类型尽量小\" class=\"headerlink\" title=\"索引列的类型尽量小\"></a>索引列的类型尽量小</h2><ul>\n<li>在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</li>\n<li>对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O</li>\n</ul>\n<h2 id=\"索引字符串值的前缀\"><a href=\"#索引字符串值的前缀\" class=\"headerlink\" title=\"索引字符串值的前缀\"></a>索引字符串值的前缀</h2><p>只对字符串的前几个字符进行索引    </p>\n<h2 id=\"让索引列在比较表达式中单独出现\"><a href=\"#让索引列在比较表达式中单独出现\" class=\"headerlink\" title=\"让索引列在比较表达式中单独出现\"></a>让索引列在比较表达式中单独出现</h2><p>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p>\n<h2 id=\"避免冗余和重复索引\"><a href=\"#避免冗余和重复索引\" class=\"headerlink\" title=\"避免冗余和重复索引\"></a>避免冗余和重复索引</h2><p>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免这样创建重复索引，发现后也应该立即移除</p>\n<h2 id=\"选择合适的索引列顺序\"><a href=\"#选择合适的索引列顺序\" class=\"headerlink\" title=\"选择合适的索引列顺序\"></a>选择合适的索引列顺序</h2><p>正确的顺序依赖于使用该索引的查询，同时需要考虑如何更好地满足排序和分组的需求将选择性最高的列放到索引的最前列</p>\n"},{"title":"MySQL事务","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"包括事务四大特性ACID、并发问题、事务隔离级别、MVCC多版本并发控制、锁等。","abbrlink":"f91535f","date":"2020-10-12T16:00:00.000Z","_content":"\n\n\n# 事务概述\n\n事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。\n事务的结束有两种，当事务中的所有步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消之前到事务开始时的所有操作。\n\n事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。\n\n# 四大特性（ACID）\n\n## 原子性（Atomicity）\n\n事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部失败；\n\n## 一致性（Consistency）\n\n事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。\n\n如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。\n\n事务操作成功后，保证数据不会被破坏。如A账户转账100元到B账户，不管操作成功与否，A和B账户的存款总额是不变的。\n\n现实世界中转账操作完成后，有一个一致性需求就是参与转账的账户的总的余额是不变的\n\n数据库某些操作的原子性和隔离性都是保证一致性的一种手段\n\n## 隔离性（Isolation）\n\n当并发访问数据库时，一个正在执行的事务在执行完毕前，对应其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。\n\n## 持久性（Durability）\n\n⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。\n\n# 并发问题\n\n## 脏写\n\n+ 一个事务修改了另一个未提交事务修改过的数据\n+ A写，B写，A提交，B回滚，最后A提交的不复存在\n+ 不论是哪种隔离级别，都不允许脏写的情况发生。\n+ InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。\n+ 由于写-写产生的\n\n## 脏读\n\n+ 一个事务读到了另一个未提交事务修改过的数据\n+ 读未提交\n+ 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。\n+ 脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。\n\n## 不可重复读\n\n+ 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值\n+ 读已提交\n+ 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。\n+ 对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据**更新（UPDATE）**操作。\n\n## 幻读\n\n+ 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来\n+ 不像之前是读取和写入一条相同记录而产生的，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。\n+ MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的\n+ 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n+ 不可重复读的重点是修改，幻读的重点在于新增或者删除。\n+ 幻读是说数据的条数发生了变化，原本不存在的数据存在了。不可重复读是说数据的内容发生了变化，原本存在的数据的内容发生了改变\n\n\n\n例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。\n\n例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。\n\n# 事务隔离级别\n\n- “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。\n- 在“读提交”隔离级 别下，这个视图是在每个SQL语句开始执行的时候创建的。\n- 在“可重复读”隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。\n- “串行化”隔离级别下直接用加锁的方式来避免并行访问。\n\n![image-20210206101335402](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206101335402.png)\n\n## READ-UNCOMMITTED(读取未提交)\n\n+  一个事务还没提交时，它做的变更就能被别的事务看到。\n+ “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念\n\n## READ-COMMITTED(读取已提交)\n\n+ 一个事务提交之后，它做的变更才会被其他事务看到。\n+ 在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。\n\n## REPEATABLE-READ（可重复读）\n\n+ 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。\n+ 数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。\n+ 默认隔离级别\n+ MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的\n+ 事务启动时的视图可以认为是静态的，不受其他事务更新的影响。\n+ 是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。\n\n## SERIALIZABLE(可串行化)\n\n最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。\n\n对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。\n\n\n\n# MVCC（多版本并发控制）\n\n## 理解\n\n+ 聚簇索引记录中都包含两个必要的隐藏列\n    + trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。\n    + roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。\n+ 每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表\n+ 对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id\n+ 按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。\n+ 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。\n+ 更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。\n+ 可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。\n+ 同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。系统里面应该避免长事务\n+ 读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：\n    + 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；\n    + 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。\n    + 对于可重复读，查询只承认在事务启动前就已经提交完成的数据\n    + 对于读提交，查询只承认在语句启动前就已经提交完成的数据；\n    + 而当前读，总是读取已经提交完成的最新版本。\n+ MVCC（Multi-VersionConcurrencyControl，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的 事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READCOMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。\n\n## 一致性读视图（consistent read view）\n\n+ 对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的\n+ READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。READ COMMITTED ——每次读取数据前都生成一个ReadView。REPEATABLEREAD ——在第一次读取数据时生成一个ReadView\n\n\n\n+ 在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。\n\n+ 按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到的上一个版本”。如果是这个事务自己更新的数据，它自己还是要认的。\n\n+ InnoDB的行数据有多个版本，每个数据版本有自己的rowtrx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据rowtrx_id和一致性视图确定数据版本的可见性。对于可重复读，查询只承认在事务启动前就已经提交完成的数据；对于读提交，查询只承认在语句启动前就已经提交完成的数据；而当前读，总是读取已经提交完成的最新版本。\n\n   \n\n# 锁\n\n## 共享锁与排他锁\n\n- 共享锁（读锁）：其他事务可以读，但不能写。\n- 排他锁（写锁） ：其他事务不能读取，也不能写。\n\n## 粒度锁\n\nMyISAM默认使用表级锁，不支持行级锁\n\nInnoDB默认使用行级锁，支持表级锁\n\n\n\n默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。\n\n但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。\n\n- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。\n\n- - 这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。\n    - 表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用\n\n- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n\n- - 最大程度的支持并发，同时也带来了最大的锁开销。\n    - 在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。\n    - 行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统\n\n- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n\n\n\n## 乐观锁、悲观锁\n\n- **乐观锁(Optimistic Lock)**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。\n\n乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。\n\n- **悲观锁(Pessimistic Lock)**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。\n\n悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n\n\n\n![image-20210206171833981](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206171833981.png)\n\n![image-20210206113508784](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206113508784.png)\n\n锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。\n\n## 全局锁\n\n- Flush tables with read lock (FTWRL)。你需要让整个库处于只读状态的时候。典型使用场景是，做全库逻辑备份。\n\n## 表级锁\n\nMySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)\n\n### 表锁\n\n共享锁、排它锁\n\n![image-20210206145740253](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206145740253.png)\n\n- 表锁一般是在数据库引擎不支持行锁的时候才会被用到的。\n- 不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。\n- 举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。\n- 在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。\n\n### 元数据锁（meta data lock）\n\nMDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查，读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。\n\n事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。\n\n解决长事务，事务不提交，就会一直占着MDL锁。\n\nMDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。\n\n# 面试题\n\n## 幻读与间隙锁\n\n### 理解\n\n一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。**两点需要说明**：\n 　1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在**当前读**下才会出现。\n 　2、幻读专指**新插入的行**，读到原本存在行的更新结果不算。因为**当前读**的作用就是能读到所有已经提交记录的最新值。\n\n### 幻读产生的原因\n\n- 行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。\n\n### 快照读\n\n快照读读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，读取的是记录数据的可见版本（可能是过期的数据），不用加锁\n\nMySQL使用的InnoDB引擎默认的隔离级别是**可重复读**，也就是说在同一个事务中，两次执行同样的查询，得到的效果应该是一样的。因此，尽管B事务在A事务还未结束的时候，增加了表中的数据，但是为了维护可重复读，A事务中不管怎么查询，是查询不了新增的数据的。但是对于真实的表而言，表中的数据是的的确确增加了。\n\n在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。\n\n### 当前读\n\n当前读就是读取最新数据，而不是历史版本的数据。加锁的 SELECT，或者对数据进行增删改都会进行当前读，比如：\n\n```\nSELECT * FROM player LOCK IN SHARE MODE;\nSELECT * FROM player FOR UPDATE;\nINSERT INTO player values ...\nDELETE FROM player WHERE ...\nUPDATE player SET ...\n```\n\n这里需要说明的是，快照读就是普通的读操作，而当前读包括了加锁的读取和 DML 操作。\n\nupdate、insert、delete 当前读。读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录\n  InnoDB默认隔离级别是RR， 是通过MVCC来实现了，读方式有两种，执行select的时候是快照读，其余是当前读，所以MVCC不能根本上解决幻读的情况\n\n### 行锁类型\n\n**Record Locks**\n\n行锁，也称为记录锁。仅仅把一条记录锁上。是有S锁和X锁之分的，当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁\n\n**Gap Locks**\n\n![2-28-1](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-1.png)\n\nMySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC方案解决，也可以采用加锁方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。\n\n如图中为number值为8的记录加了gap锁，意味着不允许别的事务在number值为8的记录前边的间隙插入新记录，其实就是number列的值**(3, 8)这个区间**的新记录是不允许立即插入的。\n\n比方说有另外一 个事务再想插入一条number值为4的新记录，它定位到该条新记录的下一条记录的number值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，number列的值在区间(3, 8)中的新记录才可以被插入。 \n\n这个gap锁的提出仅仅是为了防止插入幻影记录而提出的，虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用都是相同的。而且如果你对一条记录加了gap锁（不论是共享gap锁还是独占gap 锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁，再强调一遍，**gap锁的作用仅仅是为了防止插入幻影记录**的而已。\n\n 不知道大家发现了一个问题没，给一条记录加了gap锁只是不允许其他事务往这条记录前边的间隙插入新记录，那对于最后一条记录之后的间隙，也就是hero表中number值为20的记录之后的间隙该咋办呢？也就是说给哪条记录加gap锁才能阻止其他事务插入number值在(20, +∞)这个区间的新记录呢？\n\n数据页的两条伪记录： Infimum记录，表示该页面中最小的记录。 Supremum记录，表示该页面中最大的记录。 \n\n为了实现阻止其他事务插入number值在**(20, +∞)**这个区间的新记录，我们可以**给索引中的最后一条记录**，也就是number值为20的那条记录所在页面的Supremum记录加上一个gap锁，画个图就是这样：\n\n![2-28-2](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-2.png)\n\n**Next-Key Locks**\n\n有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，next-key锁。\n\nnext-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。\n\n![2-28-3](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-3.png)\n\n### 如何解决幻读\n\n- 将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为**间隙锁**。\n- 间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是**往这个间隙中插入一个记录**这个操作。\n\n### 幻读解决\n\n即便是给每行数据都加上行锁，也无法解决幻读，行锁只能阻止修改，无法阻止数据的删除。而且新插入的数据，自然是数据库中不存在的数据，原本不存在的数据自然无法对其加锁，因此仅仅使用行锁是无法阻止别的事务插入数据的。\n\n产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。\n\n顾名思义，间隙锁，锁的就是两个值之间的空隙。比如表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。\n\n这样，当你执行 select *fromt where d=5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。\n\n也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上 了间隙锁。 \n\n所以数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。\n\n跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操 作。间隙锁之间都不存在冲突关系。\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20201210122512284.png)\n\n间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 SELECT * FEOM t FOR UPDATE要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (负无穷,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, 正无穷]。\n\n+∞是开区间。实现上，InnoDB给每个索引加了一个不存在的最大值supremum，这样才符合我们前面说的“都是前开后闭区间”。\n\n\n\n- 间隙锁是在可重复读隔离级别下才会生效的\n\n- 怎么加间隙锁呢？使用写锁（又叫排它锁）时自动生效，也就是说我们执行 SELECT * FEOM t FOR UPDATE时便会自动触发间隙锁。会给主键加上上图所示的锁。\n\n\n","source":"_posts/数据库/MySQL数据库/02.MySQL事务.md","raw":"---\ntitle: MySQL事务\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 包括事务四大特性ACID、并发问题、事务隔离级别、MVCC多版本并发控制、锁等。\ncategories: MySQL\ntags:\n  - 锁\n  - 事务\n  - MVCC\nabbrlink: f91535f\ndate: 2020-10-13 00:00:00\n---\n\n\n\n# 事务概述\n\n事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。\n事务的结束有两种，当事务中的所有步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消之前到事务开始时的所有操作。\n\n事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。\n\n# 四大特性（ACID）\n\n## 原子性（Atomicity）\n\n事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部失败；\n\n## 一致性（Consistency）\n\n事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。\n\n如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。\n\n事务操作成功后，保证数据不会被破坏。如A账户转账100元到B账户，不管操作成功与否，A和B账户的存款总额是不变的。\n\n现实世界中转账操作完成后，有一个一致性需求就是参与转账的账户的总的余额是不变的\n\n数据库某些操作的原子性和隔离性都是保证一致性的一种手段\n\n## 隔离性（Isolation）\n\n当并发访问数据库时，一个正在执行的事务在执行完毕前，对应其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。\n\n## 持久性（Durability）\n\n⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。\n\n# 并发问题\n\n## 脏写\n\n+ 一个事务修改了另一个未提交事务修改过的数据\n+ A写，B写，A提交，B回滚，最后A提交的不复存在\n+ 不论是哪种隔离级别，都不允许脏写的情况发生。\n+ InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。\n+ 由于写-写产生的\n\n## 脏读\n\n+ 一个事务读到了另一个未提交事务修改过的数据\n+ 读未提交\n+ 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。\n+ 脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。\n\n## 不可重复读\n\n+ 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值\n+ 读已提交\n+ 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。\n+ 对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据**更新（UPDATE）**操作。\n\n## 幻读\n\n+ 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来\n+ 不像之前是读取和写入一条相同记录而产生的，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。\n+ MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的\n+ 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n+ 不可重复读的重点是修改，幻读的重点在于新增或者删除。\n+ 幻读是说数据的条数发生了变化，原本不存在的数据存在了。不可重复读是说数据的内容发生了变化，原本存在的数据的内容发生了改变\n\n\n\n例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。\n\n例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。\n\n# 事务隔离级别\n\n- “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。\n- 在“读提交”隔离级 别下，这个视图是在每个SQL语句开始执行的时候创建的。\n- 在“可重复读”隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。\n- “串行化”隔离级别下直接用加锁的方式来避免并行访问。\n\n![image-20210206101335402](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206101335402.png)\n\n## READ-UNCOMMITTED(读取未提交)\n\n+  一个事务还没提交时，它做的变更就能被别的事务看到。\n+ “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念\n\n## READ-COMMITTED(读取已提交)\n\n+ 一个事务提交之后，它做的变更才会被其他事务看到。\n+ 在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。\n\n## REPEATABLE-READ（可重复读）\n\n+ 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。\n+ 数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。\n+ 默认隔离级别\n+ MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的\n+ 事务启动时的视图可以认为是静态的，不受其他事务更新的影响。\n+ 是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。\n\n## SERIALIZABLE(可串行化)\n\n最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。\n\n对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。\n\n\n\n# MVCC（多版本并发控制）\n\n## 理解\n\n+ 聚簇索引记录中都包含两个必要的隐藏列\n    + trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。\n    + roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。\n+ 每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表\n+ 对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id\n+ 按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。\n+ 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。\n+ 更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。\n+ 可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。\n+ 同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。系统里面应该避免长事务\n+ 读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：\n    + 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；\n    + 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。\n    + 对于可重复读，查询只承认在事务启动前就已经提交完成的数据\n    + 对于读提交，查询只承认在语句启动前就已经提交完成的数据；\n    + 而当前读，总是读取已经提交完成的最新版本。\n+ MVCC（Multi-VersionConcurrencyControl，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的 事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READCOMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。\n\n## 一致性读视图（consistent read view）\n\n+ 对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的\n+ READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。READ COMMITTED ——每次读取数据前都生成一个ReadView。REPEATABLEREAD ——在第一次读取数据时生成一个ReadView\n\n\n\n+ 在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。\n\n+ 按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到的上一个版本”。如果是这个事务自己更新的数据，它自己还是要认的。\n\n+ InnoDB的行数据有多个版本，每个数据版本有自己的rowtrx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据rowtrx_id和一致性视图确定数据版本的可见性。对于可重复读，查询只承认在事务启动前就已经提交完成的数据；对于读提交，查询只承认在语句启动前就已经提交完成的数据；而当前读，总是读取已经提交完成的最新版本。\n\n   \n\n# 锁\n\n## 共享锁与排他锁\n\n- 共享锁（读锁）：其他事务可以读，但不能写。\n- 排他锁（写锁） ：其他事务不能读取，也不能写。\n\n## 粒度锁\n\nMyISAM默认使用表级锁，不支持行级锁\n\nInnoDB默认使用行级锁，支持表级锁\n\n\n\n默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。\n\n但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。\n\n- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。\n\n- - 这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。\n    - 表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用\n\n- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n\n- - 最大程度的支持并发，同时也带来了最大的锁开销。\n    - 在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。\n    - 行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统\n\n- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n\n\n\n## 乐观锁、悲观锁\n\n- **乐观锁(Optimistic Lock)**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。\n\n乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。\n\n- **悲观锁(Pessimistic Lock)**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。\n\n悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n\n\n\n![image-20210206171833981](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206171833981.png)\n\n![image-20210206113508784](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206113508784.png)\n\n锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。\n\n## 全局锁\n\n- Flush tables with read lock (FTWRL)。你需要让整个库处于只读状态的时候。典型使用场景是，做全库逻辑备份。\n\n## 表级锁\n\nMySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)\n\n### 表锁\n\n共享锁、排它锁\n\n![image-20210206145740253](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206145740253.png)\n\n- 表锁一般是在数据库引擎不支持行锁的时候才会被用到的。\n- 不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。\n- 举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。\n- 在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。\n\n### 元数据锁（meta data lock）\n\nMDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查，读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。\n\n事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。\n\n解决长事务，事务不提交，就会一直占着MDL锁。\n\nMDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。\n\n# 面试题\n\n## 幻读与间隙锁\n\n### 理解\n\n一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。**两点需要说明**：\n 　1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在**当前读**下才会出现。\n 　2、幻读专指**新插入的行**，读到原本存在行的更新结果不算。因为**当前读**的作用就是能读到所有已经提交记录的最新值。\n\n### 幻读产生的原因\n\n- 行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。\n\n### 快照读\n\n快照读读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，读取的是记录数据的可见版本（可能是过期的数据），不用加锁\n\nMySQL使用的InnoDB引擎默认的隔离级别是**可重复读**，也就是说在同一个事务中，两次执行同样的查询，得到的效果应该是一样的。因此，尽管B事务在A事务还未结束的时候，增加了表中的数据，但是为了维护可重复读，A事务中不管怎么查询，是查询不了新增的数据的。但是对于真实的表而言，表中的数据是的的确确增加了。\n\n在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。\n\n### 当前读\n\n当前读就是读取最新数据，而不是历史版本的数据。加锁的 SELECT，或者对数据进行增删改都会进行当前读，比如：\n\n```\nSELECT * FROM player LOCK IN SHARE MODE;\nSELECT * FROM player FOR UPDATE;\nINSERT INTO player values ...\nDELETE FROM player WHERE ...\nUPDATE player SET ...\n```\n\n这里需要说明的是，快照读就是普通的读操作，而当前读包括了加锁的读取和 DML 操作。\n\nupdate、insert、delete 当前读。读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录\n  InnoDB默认隔离级别是RR， 是通过MVCC来实现了，读方式有两种，执行select的时候是快照读，其余是当前读，所以MVCC不能根本上解决幻读的情况\n\n### 行锁类型\n\n**Record Locks**\n\n行锁，也称为记录锁。仅仅把一条记录锁上。是有S锁和X锁之分的，当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁\n\n**Gap Locks**\n\n![2-28-1](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-1.png)\n\nMySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC方案解决，也可以采用加锁方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。\n\n如图中为number值为8的记录加了gap锁，意味着不允许别的事务在number值为8的记录前边的间隙插入新记录，其实就是number列的值**(3, 8)这个区间**的新记录是不允许立即插入的。\n\n比方说有另外一 个事务再想插入一条number值为4的新记录，它定位到该条新记录的下一条记录的number值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，number列的值在区间(3, 8)中的新记录才可以被插入。 \n\n这个gap锁的提出仅仅是为了防止插入幻影记录而提出的，虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用都是相同的。而且如果你对一条记录加了gap锁（不论是共享gap锁还是独占gap 锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁，再强调一遍，**gap锁的作用仅仅是为了防止插入幻影记录**的而已。\n\n 不知道大家发现了一个问题没，给一条记录加了gap锁只是不允许其他事务往这条记录前边的间隙插入新记录，那对于最后一条记录之后的间隙，也就是hero表中number值为20的记录之后的间隙该咋办呢？也就是说给哪条记录加gap锁才能阻止其他事务插入number值在(20, +∞)这个区间的新记录呢？\n\n数据页的两条伪记录： Infimum记录，表示该页面中最小的记录。 Supremum记录，表示该页面中最大的记录。 \n\n为了实现阻止其他事务插入number值在**(20, +∞)**这个区间的新记录，我们可以**给索引中的最后一条记录**，也就是number值为20的那条记录所在页面的Supremum记录加上一个gap锁，画个图就是这样：\n\n![2-28-2](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-2.png)\n\n**Next-Key Locks**\n\n有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，next-key锁。\n\nnext-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。\n\n![2-28-3](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-3.png)\n\n### 如何解决幻读\n\n- 将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为**间隙锁**。\n- 间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是**往这个间隙中插入一个记录**这个操作。\n\n### 幻读解决\n\n即便是给每行数据都加上行锁，也无法解决幻读，行锁只能阻止修改，无法阻止数据的删除。而且新插入的数据，自然是数据库中不存在的数据，原本不存在的数据自然无法对其加锁，因此仅仅使用行锁是无法阻止别的事务插入数据的。\n\n产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。\n\n顾名思义，间隙锁，锁的就是两个值之间的空隙。比如表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。\n\n这样，当你执行 select *fromt where d=5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。\n\n也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上 了间隙锁。 \n\n所以数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。\n\n跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操 作。间隙锁之间都不存在冲突关系。\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20201210122512284.png)\n\n间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 SELECT * FEOM t FOR UPDATE要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (负无穷,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, 正无穷]。\n\n+∞是开区间。实现上，InnoDB给每个索引加了一个不存在的最大值supremum，这样才符合我们前面说的“都是前开后闭区间”。\n\n\n\n- 间隙锁是在可重复读隔离级别下才会生效的\n\n- 怎么加间隙锁呢？使用写锁（又叫排它锁）时自动生效，也就是说我们执行 SELECT * FEOM t FOR UPDATE时便会自动触发间隙锁。会给主键加上上图所示的锁。\n\n\n","slug":"数据库/MySQL数据库/02.MySQL事务","published":1,"updated":"2021-06-08T03:35:00.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq51c0019z0tp72fi2msl","content":"<h1 id=\"事务概述\"><a href=\"#事务概述\" class=\"headerlink\" title=\"事务概述\"></a>事务概述</h1><p>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。<br>事务的结束有两种，当事务中的所有步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消之前到事务开始时的所有操作。</p>\n<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>\n<h1 id=\"四大特性（ACID）\"><a href=\"#四大特性（ACID）\" class=\"headerlink\" title=\"四大特性（ACID）\"></a>四大特性（ACID）</h1><h2 id=\"原子性（Atomicity）\"><a href=\"#原子性（Atomicity）\" class=\"headerlink\" title=\"原子性（Atomicity）\"></a>原子性（Atomicity）</h2><p>事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部失败；</p>\n<h2 id=\"一致性（Consistency）\"><a href=\"#一致性（Consistency）\" class=\"headerlink\" title=\"一致性（Consistency）\"></a>一致性（Consistency）</h2><p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</p>\n<p>如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p>\n<p>事务操作成功后，保证数据不会被破坏。如A账户转账100元到B账户，不管操作成功与否，A和B账户的存款总额是不变的。</p>\n<p>现实世界中转账操作完成后，有一个一致性需求就是参与转账的账户的总的余额是不变的</p>\n<p>数据库某些操作的原子性和隔离性都是保证一致性的一种手段</p>\n<h2 id=\"隔离性（Isolation）\"><a href=\"#隔离性（Isolation）\" class=\"headerlink\" title=\"隔离性（Isolation）\"></a>隔离性（Isolation）</h2><p>当并发访问数据库时，一个正在执行的事务在执行完毕前，对应其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。</p>\n<h2 id=\"持久性（Durability）\"><a href=\"#持久性（Durability）\" class=\"headerlink\" title=\"持久性（Durability）\"></a>持久性（Durability）</h2><p>⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p>\n<h1 id=\"并发问题\"><a href=\"#并发问题\" class=\"headerlink\" title=\"并发问题\"></a>并发问题</h1><h2 id=\"脏写\"><a href=\"#脏写\" class=\"headerlink\" title=\"脏写\"></a>脏写</h2><ul>\n<li>一个事务修改了另一个未提交事务修改过的数据</li>\n<li>A写，B写，A提交，B回滚，最后A提交的不复存在</li>\n<li>不论是哪种隔离级别，都不允许脏写的情况发生。</li>\n<li>InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</li>\n<li>由于写-写产生的</li>\n</ul>\n<h2 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h2><ul>\n<li>一个事务读到了另一个未提交事务修改过的数据</li>\n<li>读未提交</li>\n<li>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>\n<li>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</li>\n</ul>\n<h2 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h2><ul>\n<li>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</li>\n<li>读已提交</li>\n<li>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>\n<li>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（UPDATE）</strong>操作。</li>\n</ul>\n<h2 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h2><ul>\n<li>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</li>\n<li>不像之前是读取和写入一条相同记录而产生的，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</li>\n<li>MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的</li>\n<li>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>\n<li>不可重复读的重点是修改，幻读的重点在于新增或者删除。</li>\n<li>幻读是说数据的条数发生了变化，原本不存在的数据存在了。不可重复读是说数据的内容发生了变化，原本存在的数据的内容发生了改变</li>\n</ul>\n<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>\n<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>\n<h1 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h1><ul>\n<li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。</li>\n<li>在“读提交”隔离级 别下，这个视图是在每个SQL语句开始执行的时候创建的。</li>\n<li>在“可重复读”隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li>\n<li>“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206101335402.png\" alt=\"image-20210206101335402\"></p>\n<h2 id=\"READ-UNCOMMITTED-读取未提交\"><a href=\"#READ-UNCOMMITTED-读取未提交\" class=\"headerlink\" title=\"READ-UNCOMMITTED(读取未提交)\"></a>READ-UNCOMMITTED(读取未提交)</h2><ul>\n<li>一个事务还没提交时，它做的变更就能被别的事务看到。</li>\n<li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念</li>\n</ul>\n<h2 id=\"READ-COMMITTED-读取已提交\"><a href=\"#READ-COMMITTED-读取已提交\" class=\"headerlink\" title=\"READ-COMMITTED(读取已提交)\"></a>READ-COMMITTED(读取已提交)</h2><ul>\n<li>一个事务提交之后，它做的变更才会被其他事务看到。</li>\n<li>在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。</li>\n</ul>\n<h2 id=\"REPEATABLE-READ（可重复读）\"><a href=\"#REPEATABLE-READ（可重复读）\" class=\"headerlink\" title=\"REPEATABLE-READ（可重复读）\"></a>REPEATABLE-READ（可重复读）</h2><ul>\n<li>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li>\n<li>数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li>\n<li>默认隔离级别</li>\n<li>MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的</li>\n<li>事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</li>\n<li>是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</li>\n</ul>\n<h2 id=\"SERIALIZABLE-可串行化\"><a href=\"#SERIALIZABLE-可串行化\" class=\"headerlink\" title=\"SERIALIZABLE(可串行化)\"></a>SERIALIZABLE(可串行化)</h2><p>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。</p>\n<p>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>\n<h1 id=\"MVCC（多版本并发控制）\"><a href=\"#MVCC（多版本并发控制）\" class=\"headerlink\" title=\"MVCC（多版本并发控制）\"></a>MVCC（多版本并发控制）</h1><h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><ul>\n<li>聚簇索引记录中都包含两个必要的隐藏列<ul>\n<li>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</li>\n<li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>\n</ul>\n</li>\n<li>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表</li>\n<li>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id</li>\n<li>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</li>\n<li>为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</li>\n<li>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</li>\n<li>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</li>\n<li>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。系统里面应该避免长事务</li>\n<li>读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：<ul>\n<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>\n<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>\n<li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据</li>\n<li>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li>\n<li>而当前读，总是读取已经提交完成的最新版本。</li>\n</ul>\n</li>\n<li>MVCC（Multi-VersionConcurrencyControl，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的 事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READCOMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li>\n</ul>\n<h2 id=\"一致性读视图（consistent-read-view）\"><a href=\"#一致性读视图（consistent-read-view）\" class=\"headerlink\" title=\"一致性读视图（consistent read view）\"></a>一致性读视图（consistent read view）</h2><ul>\n<li>对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的</li>\n<li>READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。READ COMMITTED ——每次读取数据前都生成一个ReadView。REPEATABLEREAD ——在第一次读取数据时生成一个ReadView</li>\n</ul>\n<ul>\n<li><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p>\n</li>\n<li><p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到的上一个版本”。如果是这个事务自己更新的数据，它自己还是要认的。</p>\n</li>\n<li><p>InnoDB的行数据有多个版本，每个数据版本有自己的rowtrx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据rowtrx_id和一致性视图确定数据版本的可见性。对于可重复读，查询只承认在事务启动前就已经提交完成的数据；对于读提交，查询只承认在语句启动前就已经提交完成的数据；而当前读，总是读取已经提交完成的最新版本。</p>\n</li>\n</ul>\n<h1 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h1><h2 id=\"共享锁与排他锁\"><a href=\"#共享锁与排他锁\" class=\"headerlink\" title=\"共享锁与排他锁\"></a>共享锁与排他锁</h2><ul>\n<li>共享锁（读锁）：其他事务可以读，但不能写。</li>\n<li>排他锁（写锁） ：其他事务不能读取，也不能写。</li>\n</ul>\n<h2 id=\"粒度锁\"><a href=\"#粒度锁\" class=\"headerlink\" title=\"粒度锁\"></a>粒度锁</h2><p>MyISAM默认使用表级锁，不支持行级锁</p>\n<p>InnoDB默认使用行级锁，支持表级锁</p>\n<p>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p>\n<p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p>\n<ul>\n<li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>\n</li>\n<li><ul>\n<li>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。<ul>\n<li>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>\n</li>\n<li><ul>\n<li>最大程度的支持并发，同时也带来了最大的锁开销。<ul>\n<li>在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li>\n<li>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>\n</li>\n</ul>\n<h2 id=\"乐观锁、悲观锁\"><a href=\"#乐观锁、悲观锁\" class=\"headerlink\" title=\"乐观锁、悲观锁\"></a>乐观锁、悲观锁</h2><ul>\n<li>**乐观锁(Optimistic Lock)**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</li>\n</ul>\n<p>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>\n<ul>\n<li>**悲观锁(Pessimistic Lock)**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li>\n</ul>\n<p>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206171833981.png\" alt=\"image-20210206171833981\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206113508784.png\" alt=\"image-20210206113508784\"></p>\n<p>锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。</p>\n<h2 id=\"全局锁\"><a href=\"#全局锁\" class=\"headerlink\" title=\"全局锁\"></a>全局锁</h2><ul>\n<li>Flush tables with read lock (FTWRL)。你需要让整个库处于只读状态的时候。典型使用场景是，做全库逻辑备份。</li>\n</ul>\n<h2 id=\"表级锁\"><a href=\"#表级锁\" class=\"headerlink\" title=\"表级锁\"></a>表级锁</h2><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)</p>\n<h3 id=\"表锁\"><a href=\"#表锁\" class=\"headerlink\" title=\"表锁\"></a>表锁</h3><p>共享锁、排它锁</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206145740253.png\" alt=\"image-20210206145740253\"></p>\n<ul>\n<li>表锁一般是在数据库引擎不支持行锁的时候才会被用到的。</li>\n<li>不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。</li>\n<li>举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。</li>\n<li>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。</li>\n</ul>\n<h3 id=\"元数据锁（meta-data-lock）\"><a href=\"#元数据锁（meta-data-lock）\" class=\"headerlink\" title=\"元数据锁（meta data lock）\"></a>元数据锁（meta data lock）</h3><p>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查，读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>\n<p>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>\n<p>解决长事务，事务不提交，就会一直占着MDL锁。</p>\n<p>MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"幻读与间隙锁\"><a href=\"#幻读与间隙锁\" class=\"headerlink\" title=\"幻读与间隙锁\"></a>幻读与间隙锁</h2><h3 id=\"理解-1\"><a href=\"#理解-1\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。<strong>两点需要说明</strong>：<br> 　1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在<strong>当前读</strong>下才会出现。<br> 　2、幻读专指<strong>新插入的行</strong>，读到原本存在行的更新结果不算。因为<strong>当前读</strong>的作用就是能读到所有已经提交记录的最新值。</p>\n<h3 id=\"幻读产生的原因\"><a href=\"#幻读产生的原因\" class=\"headerlink\" title=\"幻读产生的原因\"></a>幻读产生的原因</h3><ul>\n<li>行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。</li>\n</ul>\n<h3 id=\"快照读\"><a href=\"#快照读\" class=\"headerlink\" title=\"快照读\"></a>快照读</h3><p>快照读读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，读取的是记录数据的可见版本（可能是过期的数据），不用加锁</p>\n<p>MySQL使用的InnoDB引擎默认的隔离级别是<strong>可重复读</strong>，也就是说在同一个事务中，两次执行同样的查询，得到的效果应该是一样的。因此，尽管B事务在A事务还未结束的时候，增加了表中的数据，但是为了维护可重复读，A事务中不管怎么查询，是查询不了新增的数据的。但是对于真实的表而言，表中的数据是的的确确增加了。</p>\n<p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</p>\n<h3 id=\"当前读\"><a href=\"#当前读\" class=\"headerlink\" title=\"当前读\"></a>当前读</h3><p>当前读就是读取最新数据，而不是历史版本的数据。加锁的 SELECT，或者对数据进行增删改都会进行当前读，比如：</p>\n<pre><code>SELECT * FROM player LOCK IN SHARE MODE;\nSELECT * FROM player FOR UPDATE;\nINSERT INTO player values ...\nDELETE FROM player WHERE ...\nUPDATE player SET ...</code></pre>\n<p>这里需要说明的是，快照读就是普通的读操作，而当前读包括了加锁的读取和 DML 操作。</p>\n<p>update、insert、delete 当前读。读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录<br>  InnoDB默认隔离级别是RR， 是通过MVCC来实现了，读方式有两种，执行select的时候是快照读，其余是当前读，所以MVCC不能根本上解决幻读的情况</p>\n<h3 id=\"行锁类型\"><a href=\"#行锁类型\" class=\"headerlink\" title=\"行锁类型\"></a>行锁类型</h3><p><strong>Record Locks</strong></p>\n<p>行锁，也称为记录锁。仅仅把一条记录锁上。是有S锁和X锁之分的，当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁</p>\n<p><strong>Gap Locks</strong></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-1.png\" alt=\"2-28-1\"></p>\n<p>MySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC方案解决，也可以采用加锁方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。</p>\n<p>如图中为number值为8的记录加了gap锁，意味着不允许别的事务在number值为8的记录前边的间隙插入新记录，其实就是number列的值**(3, 8)这个区间**的新记录是不允许立即插入的。</p>\n<p>比方说有另外一 个事务再想插入一条number值为4的新记录，它定位到该条新记录的下一条记录的number值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，number列的值在区间(3, 8)中的新记录才可以被插入。 </p>\n<p>这个gap锁的提出仅仅是为了防止插入幻影记录而提出的，虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用都是相同的。而且如果你对一条记录加了gap锁（不论是共享gap锁还是独占gap 锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁，再强调一遍，<strong>gap锁的作用仅仅是为了防止插入幻影记录</strong>的而已。</p>\n<p> 不知道大家发现了一个问题没，给一条记录加了gap锁只是不允许其他事务往这条记录前边的间隙插入新记录，那对于最后一条记录之后的间隙，也就是hero表中number值为20的记录之后的间隙该咋办呢？也就是说给哪条记录加gap锁才能阻止其他事务插入number值在(20, +∞)这个区间的新记录呢？</p>\n<p>数据页的两条伪记录： Infimum记录，表示该页面中最小的记录。 Supremum记录，表示该页面中最大的记录。 </p>\n<p>为了实现阻止其他事务插入number值在**(20, +∞)<strong>这个区间的新记录，我们可以</strong>给索引中的最后一条记录**，也就是number值为20的那条记录所在页面的Supremum记录加上一个gap锁，画个图就是这样：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-2.png\" alt=\"2-28-2\"></p>\n<p><strong>Next-Key Locks</strong></p>\n<p>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，next-key锁。</p>\n<p>next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-3.png\" alt=\"2-28-3\"></p>\n<h3 id=\"如何解决幻读\"><a href=\"#如何解决幻读\" class=\"headerlink\" title=\"如何解决幻读\"></a>如何解决幻读</h3><ul>\n<li>将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为<strong>间隙锁</strong>。</li>\n<li>间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是<strong>往这个间隙中插入一个记录</strong>这个操作。</li>\n</ul>\n<h3 id=\"幻读解决\"><a href=\"#幻读解决\" class=\"headerlink\" title=\"幻读解决\"></a>幻读解决</h3><p>即便是给每行数据都加上行锁，也无法解决幻读，行锁只能阻止修改，无法阻止数据的删除。而且新插入的数据，自然是数据库中不存在的数据，原本不存在的数据自然无法对其加锁，因此仅仅使用行锁是无法阻止别的事务插入数据的。</p>\n<p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。</p>\n<p>顾名思义，间隙锁，锁的就是两个值之间的空隙。比如表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。</p>\n<p>这样，当你执行 select *fromt where d=5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p>\n<p>也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上 了间隙锁。 </p>\n<p>所以数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。</p>\n<p>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操 作。间隙锁之间都不存在冲突关系。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20201210122512284.png\"></p>\n<p>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 SELECT * FEOM t FOR UPDATE要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (负无穷,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, 正无穷]。</p>\n<p>+∞是开区间。实现上，InnoDB给每个索引加了一个不存在的最大值supremum，这样才符合我们前面说的“都是前开后闭区间”。</p>\n<ul>\n<li><p>间隙锁是在可重复读隔离级别下才会生效的</p>\n</li>\n<li><p>怎么加间隙锁呢？使用写锁（又叫排它锁）时自动生效，也就是说我们执行 SELECT * FEOM t FOR UPDATE时便会自动触发间隙锁。会给主键加上上图所示的锁。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"事务概述\"><a href=\"#事务概述\" class=\"headerlink\" title=\"事务概述\"></a>事务概述</h1><p>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。<br>事务的结束有两种，当事务中的所有步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消之前到事务开始时的所有操作。</p>\n<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>\n<h1 id=\"四大特性（ACID）\"><a href=\"#四大特性（ACID）\" class=\"headerlink\" title=\"四大特性（ACID）\"></a>四大特性（ACID）</h1><h2 id=\"原子性（Atomicity）\"><a href=\"#原子性（Atomicity）\" class=\"headerlink\" title=\"原子性（Atomicity）\"></a>原子性（Atomicity）</h2><p>事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部失败；</p>\n<h2 id=\"一致性（Consistency）\"><a href=\"#一致性（Consistency）\" class=\"headerlink\" title=\"一致性（Consistency）\"></a>一致性（Consistency）</h2><p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</p>\n<p>如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p>\n<p>事务操作成功后，保证数据不会被破坏。如A账户转账100元到B账户，不管操作成功与否，A和B账户的存款总额是不变的。</p>\n<p>现实世界中转账操作完成后，有一个一致性需求就是参与转账的账户的总的余额是不变的</p>\n<p>数据库某些操作的原子性和隔离性都是保证一致性的一种手段</p>\n<h2 id=\"隔离性（Isolation）\"><a href=\"#隔离性（Isolation）\" class=\"headerlink\" title=\"隔离性（Isolation）\"></a>隔离性（Isolation）</h2><p>当并发访问数据库时，一个正在执行的事务在执行完毕前，对应其他的会话是不可见的，多个并发事务之间的数据是相互隔离的。</p>\n<h2 id=\"持久性（Durability）\"><a href=\"#持久性（Durability）\" class=\"headerlink\" title=\"持久性（Durability）\"></a>持久性（Durability）</h2><p>⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p>\n<h1 id=\"并发问题\"><a href=\"#并发问题\" class=\"headerlink\" title=\"并发问题\"></a>并发问题</h1><h2 id=\"脏写\"><a href=\"#脏写\" class=\"headerlink\" title=\"脏写\"></a>脏写</h2><ul>\n<li>一个事务修改了另一个未提交事务修改过的数据</li>\n<li>A写，B写，A提交，B回滚，最后A提交的不复存在</li>\n<li>不论是哪种隔离级别，都不允许脏写的情况发生。</li>\n<li>InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</li>\n<li>由于写-写产生的</li>\n</ul>\n<h2 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h2><ul>\n<li>一个事务读到了另一个未提交事务修改过的数据</li>\n<li>读未提交</li>\n<li>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>\n<li>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</li>\n</ul>\n<h2 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h2><ul>\n<li>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</li>\n<li>读已提交</li>\n<li>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>\n<li>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（UPDATE）</strong>操作。</li>\n</ul>\n<h2 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h2><ul>\n<li>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</li>\n<li>不像之前是读取和写入一条相同记录而产生的，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</li>\n<li>MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的</li>\n<li>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>\n<li>不可重复读的重点是修改，幻读的重点在于新增或者删除。</li>\n<li>幻读是说数据的条数发生了变化，原本不存在的数据存在了。不可重复读是说数据的内容发生了变化，原本存在的数据的内容发生了改变</li>\n</ul>\n<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>\n<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>\n<h1 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h1><ul>\n<li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。</li>\n<li>在“读提交”隔离级 别下，这个视图是在每个SQL语句开始执行的时候创建的。</li>\n<li>在“可重复读”隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li>\n<li>“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206101335402.png\" alt=\"image-20210206101335402\"></p>\n<h2 id=\"READ-UNCOMMITTED-读取未提交\"><a href=\"#READ-UNCOMMITTED-读取未提交\" class=\"headerlink\" title=\"READ-UNCOMMITTED(读取未提交)\"></a>READ-UNCOMMITTED(读取未提交)</h2><ul>\n<li>一个事务还没提交时，它做的变更就能被别的事务看到。</li>\n<li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念</li>\n</ul>\n<h2 id=\"READ-COMMITTED-读取已提交\"><a href=\"#READ-COMMITTED-读取已提交\" class=\"headerlink\" title=\"READ-COMMITTED(读取已提交)\"></a>READ-COMMITTED(读取已提交)</h2><ul>\n<li>一个事务提交之后，它做的变更才会被其他事务看到。</li>\n<li>在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。</li>\n</ul>\n<h2 id=\"REPEATABLE-READ（可重复读）\"><a href=\"#REPEATABLE-READ（可重复读）\" class=\"headerlink\" title=\"REPEATABLE-READ（可重复读）\"></a>REPEATABLE-READ（可重复读）</h2><ul>\n<li>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li>\n<li>数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li>\n<li>默认隔离级别</li>\n<li>MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的</li>\n<li>事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</li>\n<li>是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</li>\n</ul>\n<h2 id=\"SERIALIZABLE-可串行化\"><a href=\"#SERIALIZABLE-可串行化\" class=\"headerlink\" title=\"SERIALIZABLE(可串行化)\"></a>SERIALIZABLE(可串行化)</h2><p>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。</p>\n<p>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>\n<h1 id=\"MVCC（多版本并发控制）\"><a href=\"#MVCC（多版本并发控制）\" class=\"headerlink\" title=\"MVCC（多版本并发控制）\"></a>MVCC（多版本并发控制）</h1><h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><ul>\n<li>聚簇索引记录中都包含两个必要的隐藏列<ul>\n<li>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</li>\n<li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>\n</ul>\n</li>\n<li>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表</li>\n<li>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id</li>\n<li>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</li>\n<li>为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</li>\n<li>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</li>\n<li>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</li>\n<li>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。系统里面应该避免长事务</li>\n<li>读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：<ul>\n<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>\n<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>\n<li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据</li>\n<li>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li>\n<li>而当前读，总是读取已经提交完成的最新版本。</li>\n</ul>\n</li>\n<li>MVCC（Multi-VersionConcurrencyControl，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的 事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READCOMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li>\n</ul>\n<h2 id=\"一致性读视图（consistent-read-view）\"><a href=\"#一致性读视图（consistent-read-view）\" class=\"headerlink\" title=\"一致性读视图（consistent read view）\"></a>一致性读视图（consistent read view）</h2><ul>\n<li>对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的</li>\n<li>READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。READ COMMITTED ——每次读取数据前都生成一个ReadView。REPEATABLEREAD ——在第一次读取数据时生成一个ReadView</li>\n</ul>\n<ul>\n<li><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p>\n</li>\n<li><p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到的上一个版本”。如果是这个事务自己更新的数据，它自己还是要认的。</p>\n</li>\n<li><p>InnoDB的行数据有多个版本，每个数据版本有自己的rowtrx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据rowtrx_id和一致性视图确定数据版本的可见性。对于可重复读，查询只承认在事务启动前就已经提交完成的数据；对于读提交，查询只承认在语句启动前就已经提交完成的数据；而当前读，总是读取已经提交完成的最新版本。</p>\n</li>\n</ul>\n<h1 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h1><h2 id=\"共享锁与排他锁\"><a href=\"#共享锁与排他锁\" class=\"headerlink\" title=\"共享锁与排他锁\"></a>共享锁与排他锁</h2><ul>\n<li>共享锁（读锁）：其他事务可以读，但不能写。</li>\n<li>排他锁（写锁） ：其他事务不能读取，也不能写。</li>\n</ul>\n<h2 id=\"粒度锁\"><a href=\"#粒度锁\" class=\"headerlink\" title=\"粒度锁\"></a>粒度锁</h2><p>MyISAM默认使用表级锁，不支持行级锁</p>\n<p>InnoDB默认使用行级锁，支持表级锁</p>\n<p>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p>\n<p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p>\n<ul>\n<li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>\n</li>\n<li><ul>\n<li>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。<ul>\n<li>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>\n</li>\n<li><ul>\n<li>最大程度的支持并发，同时也带来了最大的锁开销。<ul>\n<li>在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li>\n<li>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>\n</li>\n</ul>\n<h2 id=\"乐观锁、悲观锁\"><a href=\"#乐观锁、悲观锁\" class=\"headerlink\" title=\"乐观锁、悲观锁\"></a>乐观锁、悲观锁</h2><ul>\n<li>**乐观锁(Optimistic Lock)**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</li>\n</ul>\n<p>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>\n<ul>\n<li>**悲观锁(Pessimistic Lock)**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li>\n</ul>\n<p>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206171833981.png\" alt=\"image-20210206171833981\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206113508784.png\" alt=\"image-20210206113508784\"></p>\n<p>锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。</p>\n<h2 id=\"全局锁\"><a href=\"#全局锁\" class=\"headerlink\" title=\"全局锁\"></a>全局锁</h2><ul>\n<li>Flush tables with read lock (FTWRL)。你需要让整个库处于只读状态的时候。典型使用场景是，做全库逻辑备份。</li>\n</ul>\n<h2 id=\"表级锁\"><a href=\"#表级锁\" class=\"headerlink\" title=\"表级锁\"></a>表级锁</h2><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)</p>\n<h3 id=\"表锁\"><a href=\"#表锁\" class=\"headerlink\" title=\"表锁\"></a>表锁</h3><p>共享锁、排它锁</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206145740253.png\" alt=\"image-20210206145740253\"></p>\n<ul>\n<li>表锁一般是在数据库引擎不支持行锁的时候才会被用到的。</li>\n<li>不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。</li>\n<li>举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。</li>\n<li>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。</li>\n</ul>\n<h3 id=\"元数据锁（meta-data-lock）\"><a href=\"#元数据锁（meta-data-lock）\" class=\"headerlink\" title=\"元数据锁（meta data lock）\"></a>元数据锁（meta data lock）</h3><p>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查，读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>\n<p>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>\n<p>解决长事务，事务不提交，就会一直占着MDL锁。</p>\n<p>MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"幻读与间隙锁\"><a href=\"#幻读与间隙锁\" class=\"headerlink\" title=\"幻读与间隙锁\"></a>幻读与间隙锁</h2><h3 id=\"理解-1\"><a href=\"#理解-1\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。<strong>两点需要说明</strong>：<br> 　1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在<strong>当前读</strong>下才会出现。<br> 　2、幻读专指<strong>新插入的行</strong>，读到原本存在行的更新结果不算。因为<strong>当前读</strong>的作用就是能读到所有已经提交记录的最新值。</p>\n<h3 id=\"幻读产生的原因\"><a href=\"#幻读产生的原因\" class=\"headerlink\" title=\"幻读产生的原因\"></a>幻读产生的原因</h3><ul>\n<li>行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。</li>\n</ul>\n<h3 id=\"快照读\"><a href=\"#快照读\" class=\"headerlink\" title=\"快照读\"></a>快照读</h3><p>快照读读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，读取的是记录数据的可见版本（可能是过期的数据），不用加锁</p>\n<p>MySQL使用的InnoDB引擎默认的隔离级别是<strong>可重复读</strong>，也就是说在同一个事务中，两次执行同样的查询，得到的效果应该是一样的。因此，尽管B事务在A事务还未结束的时候，增加了表中的数据，但是为了维护可重复读，A事务中不管怎么查询，是查询不了新增的数据的。但是对于真实的表而言，表中的数据是的的确确增加了。</p>\n<p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</p>\n<h3 id=\"当前读\"><a href=\"#当前读\" class=\"headerlink\" title=\"当前读\"></a>当前读</h3><p>当前读就是读取最新数据，而不是历史版本的数据。加锁的 SELECT，或者对数据进行增删改都会进行当前读，比如：</p>\n<pre><code>SELECT * FROM player LOCK IN SHARE MODE;\nSELECT * FROM player FOR UPDATE;\nINSERT INTO player values ...\nDELETE FROM player WHERE ...\nUPDATE player SET ...</code></pre>\n<p>这里需要说明的是，快照读就是普通的读操作，而当前读包括了加锁的读取和 DML 操作。</p>\n<p>update、insert、delete 当前读。读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录<br>  InnoDB默认隔离级别是RR， 是通过MVCC来实现了，读方式有两种，执行select的时候是快照读，其余是当前读，所以MVCC不能根本上解决幻读的情况</p>\n<h3 id=\"行锁类型\"><a href=\"#行锁类型\" class=\"headerlink\" title=\"行锁类型\"></a>行锁类型</h3><p><strong>Record Locks</strong></p>\n<p>行锁，也称为记录锁。仅仅把一条记录锁上。是有S锁和X锁之分的，当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁</p>\n<p><strong>Gap Locks</strong></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-1.png\" alt=\"2-28-1\"></p>\n<p>MySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC方案解决，也可以采用加锁方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。</p>\n<p>如图中为number值为8的记录加了gap锁，意味着不允许别的事务在number值为8的记录前边的间隙插入新记录，其实就是number列的值**(3, 8)这个区间**的新记录是不允许立即插入的。</p>\n<p>比方说有另外一 个事务再想插入一条number值为4的新记录，它定位到该条新记录的下一条记录的number值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，number列的值在区间(3, 8)中的新记录才可以被插入。 </p>\n<p>这个gap锁的提出仅仅是为了防止插入幻影记录而提出的，虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用都是相同的。而且如果你对一条记录加了gap锁（不论是共享gap锁还是独占gap 锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁，再强调一遍，<strong>gap锁的作用仅仅是为了防止插入幻影记录</strong>的而已。</p>\n<p> 不知道大家发现了一个问题没，给一条记录加了gap锁只是不允许其他事务往这条记录前边的间隙插入新记录，那对于最后一条记录之后的间隙，也就是hero表中number值为20的记录之后的间隙该咋办呢？也就是说给哪条记录加gap锁才能阻止其他事务插入number值在(20, +∞)这个区间的新记录呢？</p>\n<p>数据页的两条伪记录： Infimum记录，表示该页面中最小的记录。 Supremum记录，表示该页面中最大的记录。 </p>\n<p>为了实现阻止其他事务插入number值在**(20, +∞)<strong>这个区间的新记录，我们可以</strong>给索引中的最后一条记录**，也就是number值为20的那条记录所在页面的Supremum记录加上一个gap锁，画个图就是这样：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-2.png\" alt=\"2-28-2\"></p>\n<p><strong>Next-Key Locks</strong></p>\n<p>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，next-key锁。</p>\n<p>next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2-28-3.png\" alt=\"2-28-3\"></p>\n<h3 id=\"如何解决幻读\"><a href=\"#如何解决幻读\" class=\"headerlink\" title=\"如何解决幻读\"></a>如何解决幻读</h3><ul>\n<li>将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为<strong>间隙锁</strong>。</li>\n<li>间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是<strong>往这个间隙中插入一个记录</strong>这个操作。</li>\n</ul>\n<h3 id=\"幻读解决\"><a href=\"#幻读解决\" class=\"headerlink\" title=\"幻读解决\"></a>幻读解决</h3><p>即便是给每行数据都加上行锁，也无法解决幻读，行锁只能阻止修改，无法阻止数据的删除。而且新插入的数据，自然是数据库中不存在的数据，原本不存在的数据自然无法对其加锁，因此仅仅使用行锁是无法阻止别的事务插入数据的。</p>\n<p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。</p>\n<p>顾名思义，间隙锁，锁的就是两个值之间的空隙。比如表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。</p>\n<p>这样，当你执行 select *fromt where d=5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p>\n<p>也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上 了间隙锁。 </p>\n<p>所以数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。</p>\n<p>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操 作。间隙锁之间都不存在冲突关系。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20201210122512284.png\"></p>\n<p>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 SELECT * FEOM t FOR UPDATE要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (负无穷,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, 正无穷]。</p>\n<p>+∞是开区间。实现上，InnoDB给每个索引加了一个不存在的最大值supremum，这样才符合我们前面说的“都是前开后闭区间”。</p>\n<ul>\n<li><p>间隙锁是在可重复读隔离级别下才会生效的</p>\n</li>\n<li><p>怎么加间隙锁呢？使用写锁（又叫排它锁）时自动生效，也就是说我们执行 SELECT * FEOM t FOR UPDATE时便会自动触发间隙锁。会给主键加上上图所示的锁。</p>\n</li>\n</ul>\n"},{"title":"Redis数据结构","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"包括了Redis底层数据结构、基本数据结构、高级数据结构（HyperLogLog、Bloom Filter）等。","abbrlink":"85682d75","date":"2020-10-31T16:00:00.000Z","_content":"\n\n\n# 底层数据结构\n\n## 简单动态字符串\n\n### SDS简介\n\n+ 使用**简单动态字符串**(simple dynamic string SDS)作为默认字符串\n+ c字符串只作为字符串字面量，用在无需对字符串值进行修改的地方\n+ 包含字符串值的键值对在底层都是用SDS实现的\n\n### SDS的定义\n\n```c\nstruct sdshdr\n{\n\tint len;//记录buf数组中已使用字节的数量 为字符串长度\n\tint free;//未使用的数量\n\tchar buf[];//字节数组，用来保存字符串\n}\n```\n\n1. buf数组以空字符结尾，且最后的空字符不算在len里面\n2. 该空字符由SDS函数自动完成，对SDS用户透明\n\n### SDS与C字符串的区别\n\n#### 获取字符串长度所需复杂度从O(N)降低到​O(1)​\n\n#### 杜绝了缓冲区溢出\n\n例如c进行字符串拼接，需要假设已经为字符串分配了足够的内存以容纳要拼接的字符串，否则就会溢出。\n**SDS空间分配策略**完全杜绝了发生缓冲区溢出的可能性。当要对SDS进行修改时，会先检查空间是否满足修改所需的要求，如果不满足，则会自动将**SDS的空间扩展**，然后再执行实际的修改操作\n\n#### 减少修改字符串时带来的内存重分配次数\n\nC字符串底层实现总是一个N+1个字符长的数组，每次对该数组进行增加或缩短，总要进行一次**内存重分配**操作。如果是增长，则要内存重分配扩展底层数组的空间大小。如果是缩短，则执行操作后，需要内存重分配来释放空间，避免内存泄漏。\n\nRedis通过**未使用空间**解除了字符串长度和底层数组长度之间的关联\n\n##### 空间预分配\n\n用于优化SDS的字符串增长操作，在扩展SDS空间之前，会先检查未使用的空间是否足够，如果足够，则直接使用未使用空间，无需进行内存重分配。\n\n在对一个SDS进行修改，并且需要对SDS进行空间扩展时，不仅为SDS分配修改所需要的空间，还会分配额外的未使用空间。\n\n如果修改后 SDS.len < 1MB，程序会分配给和len一样的长度给free\n\n如果修改后 SDS.len >= 1MB，程序会分配1MB给free\n\n##### 惰性空间释放\n\n用于优化SDS字符串缩短操作：不立即回收缩短后多出来的字节，而是用free记录。避免了缩短字符串时所需的内存重分配操作，并且为将来可能的增长提供了优化\n\nAPI也让我们在需要时，真正释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费\n\n#### 二进制安全\n\n1. C字符串并且符合特定的编码，并且除字符串的末尾外，不能包含空字符，使得他只能保存文本数据\n2. Redis以处理二进制的方式处理SDS存放在buf数组的数据，使用len而不是空字符判断字符串是否结束。所以他可以保存**任意格式**的二进制数据。\n\n#### 兼容部分C字符串函数\n\nSDS保存数据的末尾总是为空字符，所以让那些保存文本数据的SDS可以重用一部分<string.h>库'定义的函数\n\n## 链表\n\n被广泛用于实现Redis的各种功能，如列表键，发布与订阅，慢查询，监视器等等\n\n### 链表和链表节点的实现\n\n```c\ntypedef struct listNode\n{\n\tstruct listNode * prev;\n\tstruct listNode * next;\n\tvoid * value;\n}listNode;\n```\n\n```c\ntypedef struct list\n{\n\tlistNode *head;\n\tlistNode *tail;\n\tunsigned long len;\n\t\n\tvoid *(*dup)(void *ptr);//节点值的复制函数\n\tvoid (*free)(void * ptr);//节点值的释放函数\n\tint (*match)(void * ptr，void * key);//节点值的对比函数\n}\n```\n\n### 特性总结\n\n+ 双端、无环、带表头和表尾指针、带链表长度计数器\n+ 多态：可以保存各种不同类型的值\n\n\n\n## 字典\n\nRedis的数据库底层就是用字典实现的\n\n字典也是**哈希键**的底层实现之一\n\n### 字典的实现\n\n字典采用哈希表作为底层实现，一个哈希表可以有多个哈希表节点，每个节点保存了一个键值对\n\n每个字典带有**两个哈希表**，一个平时使用，一个仅仅在rehash时使用\n\n### 哈希表\n\n```c\ntypedef struct dictht\n{\n\tdictEntry ** table;//哈希表数组\n\tunsigned long size;\n\tunsigned long sizemask;//哈希表大小掩码，用于计算索引值 总=size-1\n\tunsigned long used;\n}dictht;\n```\n\nsizemask和哈希值一起决定一个键应该放到table数组里面的哪个索引上\n\n### 哈希表节点\n\n```c\ntypedef struct dictEntry\n{\n\tvoid *key;\n\tunion\n\t{\n\t\tvoid *val;\n\t\tuint64_t u64;\n\t\tint64_t s64;\n\t} v;\n\tstruct dictEntry * next; \n}dictEntry;\n```\n\n值可以是应该指针，或者是应该uint64_t类型的整数，或是一个int64_t整数\n\nnext属性指向另一个哈希表节点的指针，可以将多个哈希值相同的键值对连接在一起，以解决键冲突\n\n### 字典\n\n```c\ntypedef struct dict\n{\n\tdicType * type;//类型特定函数\n\tvoid * privdata;//私有数据\n\tditcht ht[2];//哈希表\n\t\n\tint rehashidx;//rehash索引，当rehash不再进行时，值为-1\n}dict;\n```\n\n1. type，privdata属性是针对不同类型的键值对，为创建多态字典而设置的\n2. 每个dicType结构保存了一簇用于操作特定类型键值对的函数\n3. privdata属性保存了需要传给那些类型特定函数的可选参数\n4. ht数组中，每个项都是**ditcht哈希表**，一般只使用ht[0]，ht[1]只会在ht[0]进行rehash时使用\n5. rehashidx记录rehash目前的进度\n\n### 哈希算法\n\n程序先通过键计算哈希值hash，在计算索引(hash & sizemask)，再根据索引将包含新键值对的哈希表节点放到哈希表数组的指定索引上\n\n### 解决键冲突\n\n用链地址法，多个分配到同一个索引的节点用单向链表连接起来。且用**头插法**，将新节点添加到链表的表头位置 \n\n### rehash\n\n#### 时机\n\n1. 若没有在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于1时rehash\n2. 若在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于5时rehash\n3. load_factor=ht[0].used / ht[0].size\n4. 以上的不同是因为，执行那两个命令时，Redis需要创建当前服务器进程的**子进程**，在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而京可能避免在子进程存在期间进行哈希表的扩展操作，可以避免不必要的内存写入操作，最大限度地节约内存\n5. 当负载因子小于0.1，则自动进行收缩操作\n\n#### 步骤\n\n1. 为字典的ht[1]哈希表分配空间\n    - 如果是扩展，则ht[1]大小为第一个大于等于 ht[0].used * 2 的2^n​。\n    - 如果是收缩，则是第一个大于等于 ht[0].used 的2^n​。\n2. 将保存在ht[0]的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后放到ht[1]的指定位置上\n3. 当ht[0]所有的键值对都迁移到了ht[1]，则将ht[1]设置为ht[0]，并且在ht[1]新建一个空哈希表\n\n### 渐进式rehash\n\n1. rehash时，服务器不是一次就将ht[0]里面的所有键值对全部rehash到ht[1]。而是分多次，**渐进式**地将ht[0]里面的键值对慢慢地rehash到ht[1]\n2. 在执行操作之外，顺带将键值对rehash到ht[1]中，把rehash键值对所需的计算工作均摊到每次对字典的增删改查操作之中。当rehash工作完成后，将rehashidx属性的值加一。所有的键rehash完毕后，rehashidx设置为-1\n3. 在进行渐进式rehash时，字典**同时**使用ht[0]，ht[1]。所以操作同时在两个哈希表中进行，即如果要查找一个键，会先在ht[0]找，没找到就继续到ht[1]中找\n4. 新添加的键值对直接保存到ht[1]中\n\n\n\n## 跳跃表\n\n### 简单记忆\n\n跳表具有如下性质：\n\n(1) 由很多层结构组成\n\n(2) 每一层都是一个有序的链表\n\n(3) 最底层(Level 1)的链表包含所有元素\n\n(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。\n\n(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/151153099856214.jpg)\n\n例子：查找元素 117\n\n(1) 比较 21， 比 21 大，往后面找\n\n(2) 比较 37,  比 37大，比链表最大值小，从 37 的下面一层开始找\n\n(3) 比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找\n\n(4) 比较 85， 比 85 大，从后面找\n\n(5) 比较 117， 等于 117， 找到了节点。\n\n```c\n/* 如果存在 x, 返回 x 所在的节点， \n * 否则返回 x 的后继节点 */  \nfind(x)   \n{  \n    p = top;  \n    while (1) {  \n        while (p->next->key < x)  \n            p = p->next;  \n        if (p->down == NULL)   \n            return p->next;  \n        p = p->down;  \n    }  \n}  \n```\n\n\n\n### 特性\n\n+ 通过在每个节点中维持多个指向其他节点的指针，从而快速访问节点\n+ 查找速度:平均O(log N)，最坏O(N)\n+ 支持顺序性操作\n+ 使用跳跃表作为有序集合键的底层实现之一\n\n- 因为要进行随机的插入和删除，不便用数组\n\n- 要定位插入位置一般用二分查找\n\n- 层级制，最下面所有元素串起来，每隔几个元素挑选一个代表，再将这几个代表用另外一级指针串起来，然后继续选出二级代表，最后形成金字塔结构\n\n- 插入，先在顶层定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插入进去\n\n- 随机策略，位于L0层概率为1，兼职L1层概率0.5，到L2层0.25，概率逐层降低\n\n\n### 性质\n\n1. 每一层都是一个有序的链表，最底层(L1)的链表包含**所有元素**\n2. 如果一个元素出现在第 n 层的链表中，则它也出现在第 n-1 层\n3. 搜索先从上层搜索，当前面的元素比target大时，则向下一级搜索(即向着更密集的数据找)\n4. 总体来看从左上往右下寻找\n\n### 查找代码\n\n从每个节点的最高层开始寻找，如果该层forward不为null，并且分值小于score，则跳到下一个节点，即x = x->level[i].forward，然后如果相等，则返回。如果该层的forward不满足，则遍历自己的下一个层级(level[i-1])的位置。综上就是从左往右，从上往下。\n\n```c\n// 通过分值和对象值获取排位信息，以1为起始值\nunsigned long zslGetRank(zskiplist *zsl， double score， robj *o) {\n    zskiplistNode *x;\n    unsigned long rank = 0;\n    int i;\n\n    x = zsl->header;\n    // 从最高层依次往下\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n            (x->level[i].forward->score < score ||\n                (x->level[i].forward->score == score &&\n                compareStringObjects(x->level[i].forward->obj，o) <= 0))) {\n            // 排位增加\n            rank += x->level[i].span;\n            x = x->level[i].forward;\n        }\n\n        /* x might be equal to zsl->header， so test if obj is non-NULL */\n        // 对象和分数值都相等\n        if (x->obj && equalStringObjects(x->obj，o)) {\n            return rank;\n        }\n    }\n    return 0;\n}\n```\n\n### 原理\n\n![IMG_20200818_102630](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200818_102630.jpg)\n\nlevel:表中层数最大的节点的层数\n\nlength:节点数量\n\n### 跳跃表节点\n\n```c\ntypedef struct zskiplistNode\n{\n\tstruct zskiplistNode * backward;//后退指针\n\tdouble score;//分值\n\trobj * obj;//成员对象\n\t\n\tstruct zskiplistLevel //层\n\t{\n\t\tstruct zskiplistNode * forward; //前进指针\n\t\tunsigned int span;//跨度\n\t} level[];\n}\n```\n\n#### 层\n\nlevel数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，来加快访问其他节点的速度\n\n感觉幂次规律，随机生成一个[1，32]的值作为level数组的大小，即层的高度\n\n#### 前进指针\n\n每个层都有一个指向表尾方向的前进指针(level[i].forward)\n\n#### 跨度\n\n记录两个节点之间的距离\n\n指向NULL的所有前进指针的跨度都为0\n\n跨度实际是用来计算排位的:在查找某个节点过程中，将沿途访问的所有层的跨度累积起来，得到的结果就是目标节点在跳跃表中的排位(即该节点是第几个节点)\n\n#### 后退指针\n\n可以先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点...，直到遇到指向NULL的后退指针\n\n#### 分值和成员\n\n1. 分值:跳跃表中所有节点都按分值从小到大排序\n2. 成员对象:指向**SDS字符串**对象的指针\n3. 跳跃表中成员对象必须唯一，但是分值可以相同\n4. 分值相同的节点按照成员变量的字典序排序\n\n### 跳跃表结构\n\n```c\ntypedef struct zskiplist\n{\n\tstruct zskiplistNode * header，*tial;\n\tunsigned long length;//表中节点的数量\n\tint level;//表中层数最大的节点的层数\n} zskiplist;\n```\n\n使得能O(1)访问表头表尾节点，访问跳跃表长度，获取表中层数最大的节点的层数\n\n## 整数集合\n\n当一个集合只包含整数值元素，并且数量不多时，redis就会采用整数集合作为集合键的底层实现\n\n```c\ntypedef strcut intset\n{\n\tuint32_t encoding; //编码方式\n\tuint32_t length; //元素数量\n\tint8_t contents[]; //保存元素的数组\n}\n```\n\n可以保存类型为 int16_t，int32_t，int64_t的**非重复**整数值，且元素在contents数组中**有序排列**\n\n### 升级\n\n每当添加一个新元素到整数集合里面，并且新元素的类型比**现有所有元素类型**都长，需要先对整数集合进行升级，再加入该元素\n\n1. 根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间\n2. 将底层数组现有的**所有元素转换**成与新元素相同的类型，并且放置到正确位置上，仍需**保证有序性**\n3. 将新元素添加到底层数组里\n\n每次添加新元素都有可能引起升级，而每次升级都需要对底层数组所有元素进行类型转换，所以添加新元素时间复杂度为O(N)\n\n### 升级的好处\n\n#### 提升灵活性\n\n整数集合可以通过自动升级底层数组来适应新元素，所以可以将 int16_t、int32_t、int64_t随意地添加到集合中，不必担心类型错误\n\n#### 节约内存\n\n既可以让集合能**同时保存三种不同类型**的值，又可以确保升级只在必要时进行\n\n### 降级\n\n**不支持**降级操作，即使把之前因为他而升级的元素删除，底层数组还仍然是加入那个元素后的类型\n\n\n\n## 压缩列表\n\n### 特点\n\n- **（1）内存空间连续：**ziplist为了提高存储效率，从存储结构上看ziplist更像是一个表(list)，但不是一个链表(linkedlist)。ziplist将每一项数据存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。而普通的双向链表每一项都占用独立的一块内存，各项之间用指针连接，这样会带来大量内存碎片，而且指针也会占用额外内存。\n- **（2）查询元素：**查找指定的数据项就会性能变得很低，需要进行遍历整个zipList。\n- **（3）插入和修改：**每次插入或修改引发的重新分配内存(realloc)操作会有更大的概率造成内存拷贝，从而降低性能。跟list一样，一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据。\n\nziplist提高了存储效率，是内存紧缩的列表，多个数据在一起的连续空间，不擅长修改，在两端pop,push快。\n\n### 理解\n\n压缩链表同样具有一定的劣势。压缩链表由于使用的是有一段连续的内存，这就意味着，执行插入操作导致内存大小发生变化时，便会引起一次内存的重新分配过程，同时还会执行一定量的数据移动。特别是对于压缩链表较长的情况下，大批量的数据移动势必会降低系统的性能。而在上述这个方面恰恰就是经典双端链表的优势，故此*Redis*设计实现了一种快速链表的数据结构，兼具经典双端链表与压缩链表的特点，实现了时间与空间上的一种折衷。\n\n\n\n链表存在一个问题，便是在存储小数据的时候， 内存使用效率过低，例如当一个链表节点中只保存一个字节的`unsigned char`数据时，我们需要为这个节点保存24个字节的额外数据， 其中包含`listNode.prev`指针，`listNode.next`指针，以及指向具体数据的`listNode.value`指针， 同时对于链表节点所占用内存的反复申请与释放，也容易导致内存碎片的产生。 为了解决经典双端链表在保存小数据而导致内存效率过低的问题，*Redis*设了一套压缩链表的数据数据结构*ziplist*来对这种场景下的链表应用进行优化。\n\n压缩链表允许在链表两端以 *O(1)* 的时间复杂度执行 *Pop* 或者 *Push* 操作，当然这只是一种理想状态下的情况， 由于压缩链表实际上是内存中一段连续分配的内存，因此这些操作需要对压缩链表所使用的内存进行重新分配， 所以其真实的时间复杂度是和链表所使用的内存大小相关的。\n\n压缩链表与经典双端链表最大的区别在于，双端链表的节点是分散在内存中并不是连续的，压缩链表中所有的数据都是存储在一段连续的内存之中的\n\n\n\n压缩链表是相对于普通链表而言的\n\n当普通链表的数据越来越多, 链表查询性能会低效\n\n当存储的数据较少时, 使用链表存储会浪费空间\n\n压缩链表本质上是一个字符串\n\n压缩链表内存储的数据只能是 整型, 字符串\n\n### 具体\n\n- 压缩列表是列表键和哈希键的底层实现之一\n- 当一个列表键只包含**少量列表项**，并且每个列表项都是**小整数或较短字符串**，则用压缩列表作为底层实现\n- 压缩列表是为了**节约内存**而开发的，是由一系列特殊编码的连续内存块组成的**顺序型数据结构**\n    - zlbytes：记录整个压缩列表所占用的内存字节数，在内存重分配或zlend位置时使用\n    - zltail：记录压缩列表表尾节点距压缩列表的起始地址有多少字节，通过该偏移量，可无须遍历整个压缩列表就可以确定表尾节点的地址\n    - zllen：记录了压缩列表包含的节点数量\n    - entryX：压缩列表包含的各个节点，节点长度由节点包含的内容决定\n    - zlend：特殊值0xFF，用于标记压缩列表的末端\n\n![image-20210207091430874](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091430874.png)\n\n### 压缩列表节点的构成\n\n![image-20210207091652786](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091652786.png)\n\n#### previous_entry_length\n\n- 记录压缩列表**前一个节点**的长度\n- 通过指针运算，根据当前节点的起始地址得到前一个节点的起始地址\n- 用于从表尾到表头的遍历：指向表尾节点的指针可以通过压缩列表的起始地址的指针加上zltail得到\n\n#### encoding\n\n记录节点的content属性所保存数据的类型及长度\n\n#### content\n\n负责保存节点的值，值的类型和属性由encoding决定\n\n#### 连锁更新\n\n- 每个节点的previous_entry_length属性都记录了前一个节点的长度，如果前一节点长度小于254字节，则previous_entry_length属性用1字节空间保存该长度值，否则需要用5字节空间。\n- 如果在压缩列表中，有多个介于[250，153]字节的节点[e1，eN]，记录这些节点的长度只需要1字节长的**previous_entry_length**，所以[e1，eN]所有节点的**previous_entry_length**都是1字节长\n\n- 但如果将一个大于254字节的新节点new加入压缩列表的头节点，则new成为e1的前置节点。而这样e1的**previous_entry_length**属性不足以保存new的长度，所以进行空间重分配，变成5字节大小\n\n- 这样e1的长度大于254字节了，e2的**previous_entry_length**也不足以保存e1的长度，也扩展成5字节大小。这样就进行连续多次空间扩展，即连锁更新\n\n- 删除节点也会引发连锁更新\n- 连锁更新在最坏情况下需要对压缩列表进行N次空间重分配操作，每次操作最坏O(N)，所以连锁更新最坏时间复杂度为O(N^2)​.\n- 但是发生的机率比较低：\n    - 恰好有多个连续的，长度介于250-153字节的节点的情况并不多见 \n    - 即使出现连锁更新，只要被更新的节点数量不多，就不会对性能有影响\n- 所以平均复杂度为O(N)\n\n## 快速链表\n\n- 双向链表便于在表的进行插入和删除节点操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。\n- ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的内存重新分配(realloc)。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。\n\n可见，一个quicklist节点上的ziplist要保持一个合理的长度\n\n**quicklist将 双向链表插入和修改元素不需要移动节点的优点 和 ziplist的存储效率很高优点(一整块连续内存)结合在一起，同时将各自的缺点进行一个折中的处理。**\n\n### 使用原因\n\n链表在早先的 redis 版本中也作为 list 的数据结构使用过，但是单纯的链表的缺陷之前也说了，插入便利，但是空间利用率低，并且不能进行二分查找等，检索效率低，ziplist 压缩表的产生也是同理，希望获得更好的性能，包括存储空间和访问性能等\n\n作者结合了经典双端链表以及压缩链表的特性，实现了快速链表的数据结构。简单来说，使用双端链表的形式描述整个快速链表，而每一个快速链表的节点都是使用一个压缩链表作为底层数据存储，可以存储若干个数据节点。同时基于链表数据结构通常对头部与尾部的访问最为频繁，而对链表中间的数据访问并不是特别频繁，因此出于节省空间的目的，会对中间节点底层压缩链表所使用的内存进行压缩\n\n### 理解\n\nquicklist 里有 head，tail, quicklistNode里有 prev，next 指针，是不是有链表的基本轮廓了\n\n关键就在这个`unsigned char *zl;`zl 是不是前面又看到过，就是 ziplist ，这是什么鬼，\n\n链表里用压缩表\n\n回顾下前面说的 ziplist，ziplist 有哪些特点，内存利用率高，可以从表头快速定位到尾节点，节点可以从后往前找，但是有个缺点，就是从中间插入的效率比较低，需要整体往后移，这个其实是普通数组的优化版，但还是有数组的一些劣势，所以要真的快，是不是可以将链表跟数组真的结合起来。\n\n假如每个快表节点的 ziplist 只放一个元素，那么其实这就退化成了一个链表，如果 10 个元素放在一个 quicklistNode 的 ziplist 里，那就退化成了一个 ziplist\n\nquickList 是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1294391-20180827151851500-1561398239.png)\n\n  \n\n# 基本数据结构\n\n## 字符串对象\n\n1. 字符串对象的编码可以是int，raw，embstr\n2. 如果字符串对象保存整数值，且可以用long表示，则会将整数值保存在ptr中，enconding设为int\n3. 如果保存字符串值，并且长度大于39字节，就用`SDS`保存，并且设为raw\n4. 如果保存字符串值，并且长度小于39字节，就用`embstr`编码保存，并且设为embstr\n\n#### embstr\n\n专门用来保存短字符串的一种优化编码方式，和SDS差不多\n不同的是，只调用一次内存分配函数来分配一块连续的空间，空间依次包含redisObject，sdshdr两个结构\n优点：内存分配与释放次数由两次变为一次；字符串所有的数据保存在一块连续的内存中，更好利用缓存\n\n#### 编码的转换\n\n1. int编码的字符串对象如果操作后保存的不再是整数值，而是字符串值，则编码变为raw\n2. embstr编码的字符串对象只是可读的，对它执行任何修改命令，都会编程raw\n\n**应用**\n\n+ 点赞数量:  incr likes 每操作一 次，就+1，最后可以通过get likes得到最终结果\n+ 将用户信息使用JSON序列化为字符串，将字符串塞进Redis来缓存\n+ 如果value是整数，则可以进行自增操作。用于计数器：可以快速实现计数和查询的功能。\n\n## 列表对象\n\n编码可以是`ziplist`,`linkedlist`。ziplist使用压缩列表作为底层实现，linkedlist采用双端链表作为底层实现。每个双端链表节点都保持一个字符串对象（之后使用的是quickList)\n\n字符串对象是Redis 5种类型的对象中唯一一种会被其他四种对象嵌套的对象\n\n#### 编码转换\n\n使用ziplist编码的情况：\n\n1. 列表对象保存的所有字符串元素都小于64字节\n2. 列表保存的元素数量小于512\n\n**理解**\n\n+ 相当于LinkedList，是链表不是数组，插入删除快，索引定位慢\n+ 元素较少时会使用一块连续内存存储，即ziplist（压缩列表），所有元素彼此紧挨着一起存储\n+ 元素较多时采用快速链表（quicklist），将多个ziplist使用双向指针串起来使用，既满足快速插入删除，又不会出现太大空间冗余\n\n**应用场景**\n\n+ 粉丝列表、文章的评论列表\n\n+ 通过 lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。\n\n+ 消息队列（异步队列）：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。\n\n## 哈希对象\n\n编码可以是ziplist、hashtable。\n\n用ziplist则将键值对压入列表表尾，键值对紧挨一起，键在前，值在后。类似队列\n\nhashtable编码用字典作为底层实现，字典的每个键与值都是一个字符串对象\n\n#### 编码转换\n\n使用ziplist编码的情况：\n\n1. 列表对象保存的所有字符串元素都小于64字节\n2. 列表保存的元素数量小于512\n\n**应用**\n\n- 类似与Map<String，Map<String，String>\n\n- 和HashMap一样采用数组+链表\n\n- Redis字典的值只能是字符串\n\n- 渐进式rehash策略：在rehash时保留新旧两个hash结构，查询时会同时查询两个hash结构，循序渐进的将旧hash的内容一点点地迁移到新的hash结构中\n\n- 记录帖子的点赞数、评论数、点击数\n\n## 集合对象\n\n编码可以是intset、hashtable。\n\n用intset编码的集合使用整数集合作为底层实现\n\n用hashtable编码的集合使用字典作为底层实现，每个键是一个字符串对象，而值设为NULL\n\n#### 编码转换\n\n使用intset编码的情况：\n\n1. 列表对象保存的都是整数值\n2. 列表保存的元素数量小于512\n\n\n\n**set**\n\n- 相当于HashSet，键值对是无序的、唯一的。相当于所有value都是NULL的hash\n\n- 统计中奖的用户ID，可以去重\n\n\n+ 交集运算:微博共同关注 SINTER key1 key2\n+ 朋友圈点赞\n+ 抽奖活动\n    + SADD key 添加参与\n    + SCARD key 查看有几个人参与了抽奖\n    + SRANDMEMBER key 2 随机抽两个人，不删除\n    + SPOP key 随机抽取并删除1个人\n\n## 有序集合对象\n\n有序集合的编码可以是ziplist、skiplist\n\n用ziplist编码则每个集合元素使用两个紧挨的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值。集合元素按分值从小到大进行排序\n\n#### 用skiplist编码实现\n\n同时包含一个**字典**和**跳跃表**\n\n```c\ntypedef struct zset\n{\n\tzskiplist *zsl;\n\tdict * dict;\n} zset;\n```\n\nzset中的zsl跳跃表按分值从小到大保存了所有集合元素\n\n每个跳跃表节点中：object属性保存元素的成员，score属性保存元素的分值\n\n此外，dict中，字典的键保存元素的成员，值保存元素的分值，这样，通过字典可以用O(1)的复杂度查找给定成员的分值\n\n这两种数据结构都会通过指针来共享相同元素的成员和分值，所以使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，不会浪费额外内存\n\n优点：\n\n+ 范围操作不需要对字典保存的所有元素进行排序，从O(NlogN)到O(N)\n+ 根据成员查询分值不需要通过跳跃表，复杂度从O(N)降低到O(1)\n\n#### 编码转换\n\n使用ziplist编码的情况：\n\n1. 有序集合保存的所有元素长度都小于64字节\n2. 有序集合保存的元素数量小于128个\n\n**应用**\n\n+ 类似于SortedSet和HashMap的结合体，保证了value的唯一性，每个value有score（排序权重）\n\n+ 热搜\n\n+ 游戏排名\n\n+ 排行榜：榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。\n\n+ 微博热搜榜，value是名称，score是热度值\n\n+ 粉丝列表，value是粉丝用户ID，score是关注时间\n\n+ 学生成绩，value是学生ID，score是考试成绩\n\n## 对象特性\n\n### 简介\n\n1. 基于之前的数据结构创建一个对象系统。包括字符串对象，列表对象，哈希对象，集合对象，有序集合对象五种\n2. 可以在执行命令之前，根据对象类型判断一个对象能否执行给定的命令\n3. 可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率\n4. 实现基于引用计数的内存回收机制，实现内存共享机制，让多个数据库键共享同一个对象节约内存\n5. 对象带有访问时间记录信息，记录数据库键的空转时间\n\n**理解**\n\n每个键值对都是由对象组成，键总是一个字符串对象，值可以是五种对象中的一种\n\n如果容器不存在，则先创建一个再进行操作\n\n如果容器里元素为空，则立刻删除容器，释放内存\n\n### 对象的类型和编码\n\n使用对象来表示数据库的键和值，新创建一个键值对时，会创建两个对象分别代表键和值\n\n```c\ntypedef struct redisObject\n{\n\tunsigned type:4;//类型\n\tunsigned encoding:4;//编码\n\tvoid * ptr;//指向底层实现数据结构的指针\n}\n```\n\n#### 类型\n\n`type`属性记录了对象的类型，即五种对象类型之一\n对于一个键值对，键总是字符串对象，值可以是五种对象类型之一\n\n#### 编码和底层实现\n\n1. 对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，即之前学习的几种数据结构\n2. 每种类型的对象都至少使用了两种不同的编码\n3. 通过`encoding`属性来设定使用的编码，极大地提升了灵活性和效率，可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率\n\n### 类型检查和命令多态\n\n在执行一个类型的特定命令之前，服务器会检查输入数据库键的值对象是否为执行命令所需的指令，如果是，服务器就会对键执行指定的命令。否则将拒绝执行命令，并向客户端返回一个类型错误。\n\n类型检查是通过`redisObject`结构的type属性来实现的 \n\n#### 多态命令的实现\n\nRedis除了会根据值对象的类型来判断键是否能够执行指定指令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令\n\n例如，`LLEN命令`是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行\n\nDEL，TYPE等命令也是多态命令，无论输入的键是什么类型，这些命令都可以正常执行。区别在于，DEL，TYPE等命令是基于类型的多态，一个命令可以处理多种不同的类型的键，LLen命令是基于编码的多态，一个命令可以同时用于处理多种不同编码\n\n### 内存回收\n\n基于引用计数法实现内存回收机制，通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收\n\n1. 创建对象，引用计数值为1\n2. 对象被新程序使用，引用计数值+1\n3. 对象不被一个程序使用，引用计数值-1\n4. 引用计数值为0时，释放对象占用的内存\n\n### 对象共享\n\n#### 步骤\n\n让多个键共享同一个值对象步骤：\n\n1. 将数据库键的值指向一个现有的值对象\n2. 将被共享的值对象引用计数值+1\n\n#### 内置整数\n\nRedis在初始化服务器时，会创建一万个字符串对象，存储[0,9999]的整数值。如果需要用到这些字符串对象，服务器则会使用这些共享对象，而不会新创建对象。\n\n这些共享对象不仅仅只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象\n\n#### 为什么不共享包含字符串的对象\n\n只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象\n\n一个共享对象保存的值越复杂，则验证共享对象和目标对象是否相同所需的复杂度越高：\n\n1. 共享对象是整数值的字符串对象，验证操作为`O(1)`\n2. 共享对象是保存字符串值的字符串对象，验证操作为`O(N)`\n3. 共享对象是包含多个值的对象（如列表），验证操作为`O(N^2)`\n\n### 对象的空转时间\n\n`redisObject`结构包含属性lru,记录了对象最后一次被命令程序访问的时间。可用当前时间-键的值对象的lru时间求得空转时间\n\n可通过设置，使得当服务器占用的内存数超过了，`maxmemory`的上限时，空转时间较高的那部分键会优先被服务器释放，从而回收内存\n\n# 高级数据结构\n\n## 位图bitmap\n\n位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组\n\n可以使用get/set 直接获取和设置整个位图的内容，也可以使⽤位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。\n\n位数组会自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动进行零扩充\n\n\n\n**应用场景**\n\n用户签到\n\n+ 有些bool 型数据需要存取，例如用户⼀年的签到记录，签了是 1，没签是0，要记录 365 天\n+ 位图数据结构让每天的签到记录只占据⼀个位，365 天就是 365个位，46 个字节 (⼀个稍长⼀点的字符串) 就可以完全容纳下\n+ 统计和查找\n    + bitcount：统计指定范围内1的个数，可以统计用户一共签到多少天 \n    + bitpos：用于查找指定范围内出现的第一个0或1，从哪天开始第一次签到\n\n## HyperLogLog\n\n+ 提供不精确的去重统计方案，标准误差是0.81%\n+ 不能知道一个值是否在结构中，即不提供 pfcontains功能\n\n+ pfadd 和 pfcount，⼀个是增加计数，⼀个是获取计数。pfadd codehole user1（将用户ID塞进去）；pfcount codehole\n+ pfmerge：用于将多个pf计数值累加在一起形成一个新的pf值，例如两个差不多的页面进行合并，需要将页面的UV访问量也合并\n+ 场景：UV（Unique Visitor） 需要去重，同⼀个用户⼀天之内的多次访问请求只能计数⼀次。\n+ 实现：计数较小时使用稀疏矩阵存储，占用空间超过阈值，则转成稠密矩阵\n\n## Bloom Filter\n\n### 定义\n\n布隆过滤器是一个很长的二进制向量和一系列随机映射函数。\n\n优点是空间效率和查询时间都远远超过⼀般的算法\n\n### 原理\n\n当⼀个元素被加入集合时，通过K个散列函数将这个元素映射成⼀个位数组中的K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（⼤约）知道集合中有没有它了：如 果这些点有任何⼀个0，则被检元素⼀定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。\n\nBloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使⽤了k个哈希函数，每个字符串跟k个 bit对应。从⽽降低了冲突的概率。\n\n### 特点\n\n+ 是一个很长的二进制向量和一系列随机映射函数\n+ 当⼀个元素被加入集合时，通过K个散列函数将这个元素映射成⼀个位数组中的K 个点，把它们置为1\n+ exists：把hash的几个位置都算出来，看看位数组在几个位置是否都为1\n    + 如果这些点有任何⼀个0，则被检元素⼀定不在\n    + 如果都是1，则被检元素很可能在\n+ 空间效率和查询时间都远远超过⼀般的算法\n+ 存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1\n+ 删除困难。⼀个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。\n\n### 缺点\n\n缺点是有⼀定的误识别率和删除困难，bloom filter之所以能做到在时间和空间上的效率⽐较⾼，是因为牺牲了判断的准确率、删除的便利性\n\n+ 存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果 bloom filter中存储的是⿊名单，那么可以通过建⽴⼀个白名单来存储可能会误判的元素。\n+ 删除困难。⼀个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。\n\n### 实现\n\n+ 在使⽤bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp\n+  在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的⼤⼩。\n+ 对于⼀个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数 组的⼤⼩m，以及hash函数的个数k，并选择hash函数\n+ 一个好的哈希函数要能近似等概率的将字符串映射到各个 Bit。选择k个不同的哈希函数⽐较麻烦，⼀种简单的⽅法是选择⼀个哈希函数，然后送入k个不同的参数。 \n\n```java\n//项目要导入guava的maven依赖\npackage com.tongji;\n\n\nimport com.google.common.hash.BloomFilter;\nimport com.google.common.hash.Funnels;\n\n/**\n * 测试布隆过滤器(可用于redis缓存穿透)\n * @author tongji4m3\n */\n\npublic class TestBloomFilter {\n    private static int total = 1000000;\n    /*\n    static <T> BloomFilter<T> create(Funnel<? super T> funnel， long expectedInsertions， double fpp， BloomFilter.Strategy strategy)\n    funnel：数据类型(⼀般是调⽤Funnels⼯具类中的)\n    expectedInsertions：期望插入的值的个数\n    fpp 错误率(默认值为0.03)\n    strategy 哈希算法\n\n    numBits，表示存⼀百万个int类型数字，需要的位数为7298440，700多万位。理论上存⼀百万个\n    数，⼀个int是4字节32位，需要481000000=3200万位。如果使⽤HashMap去存，按HashMap50%的\n    存储效率，需要6400万位。可以看出BloomFilter的存储空间很⼩，只有HashMap的1/10左右\n\n    错误率越⼤，所需空间和时间越⼩，错误率越⼩，所需空间和时间越⼤\n     */\n    private static BloomFilter<Integer> bloomFilter = BloomFilter.create(Funnels.integerFunnel()， total);\n\n    public static void main(String[] args) {\n        //初始化total条数据到过滤器里\n        for (int i = 0; i < total; i++) {\n            bloomFilter.put(i);\n        }\n        //匹配已经再过滤器中的值，看是否有匹配不上的\n        //没有输出，说明只要放进去的，都能匹配上\n        for (int i = 0; i < total; i++) {\n            if (!bloomFilter.mightContain(i)) {\n                System.out.println(\"有坏人逃脱啦~\");\n            }\n        }\n\n        //匹配不在过滤器中的10000个值，有多少匹配出来\n        int count = 0;\n        for (int i = total; i < total + 10000; i++) {\n            if (bloomFilter.mightContain(i)) {\n                ++count;\n            }\n        }\n        //误伤数量: 320 错误率是0.03左右\n        System.out.println(\"误伤数量: \"+count);\n    }\n}\n```\n\n### 应用\n\n#### 缓存击穿\n\n数据库的id都是1开始然后自增的，那我知道你接⼝是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我⼜去数据库查也没有，⼀个请求这样，100个，1000 个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return⼀个数据为空不就好了嘛。\n\n+ 海量数据去重\n+ 用于检索一个元素是否在一个集合中\n+ 爬⾍过滤已抓到的url就不再抓，可⽤bloom filter过滤，只会使得爬虫系统错过少量的新页面\n+ 垃圾邮件过滤。Bloom Filter只需要哈希表 1/8到 1/4 的大小\n+ 海量数据去重：不断放入元素到集合中，检索一个元素是否在一个集合中，在则说明重复、推荐去重，即APP会把用户已经看过的内容去掉、能准确过滤掉用户已经看过的内容，那些用户没有看过的新内容，也会过滤掉极小一部分（误判）\n\n","source":"_posts/数据库/Redis数据库/1.Redis数据结构.md","raw":"---\ntitle: Redis数据结构\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 包括了Redis底层数据结构、基本数据结构、高级数据结构（HyperLogLog、Bloom Filter）等。\ncategories: Redis\ntags:\n  - 数据结构\n  - 对象\n  - 开源框架\nabbrlink: 85682d75\ndate: 2020-11-01 00:00:00\n---\n\n\n\n# 底层数据结构\n\n## 简单动态字符串\n\n### SDS简介\n\n+ 使用**简单动态字符串**(simple dynamic string SDS)作为默认字符串\n+ c字符串只作为字符串字面量，用在无需对字符串值进行修改的地方\n+ 包含字符串值的键值对在底层都是用SDS实现的\n\n### SDS的定义\n\n```c\nstruct sdshdr\n{\n\tint len;//记录buf数组中已使用字节的数量 为字符串长度\n\tint free;//未使用的数量\n\tchar buf[];//字节数组，用来保存字符串\n}\n```\n\n1. buf数组以空字符结尾，且最后的空字符不算在len里面\n2. 该空字符由SDS函数自动完成，对SDS用户透明\n\n### SDS与C字符串的区别\n\n#### 获取字符串长度所需复杂度从O(N)降低到​O(1)​\n\n#### 杜绝了缓冲区溢出\n\n例如c进行字符串拼接，需要假设已经为字符串分配了足够的内存以容纳要拼接的字符串，否则就会溢出。\n**SDS空间分配策略**完全杜绝了发生缓冲区溢出的可能性。当要对SDS进行修改时，会先检查空间是否满足修改所需的要求，如果不满足，则会自动将**SDS的空间扩展**，然后再执行实际的修改操作\n\n#### 减少修改字符串时带来的内存重分配次数\n\nC字符串底层实现总是一个N+1个字符长的数组，每次对该数组进行增加或缩短，总要进行一次**内存重分配**操作。如果是增长，则要内存重分配扩展底层数组的空间大小。如果是缩短，则执行操作后，需要内存重分配来释放空间，避免内存泄漏。\n\nRedis通过**未使用空间**解除了字符串长度和底层数组长度之间的关联\n\n##### 空间预分配\n\n用于优化SDS的字符串增长操作，在扩展SDS空间之前，会先检查未使用的空间是否足够，如果足够，则直接使用未使用空间，无需进行内存重分配。\n\n在对一个SDS进行修改，并且需要对SDS进行空间扩展时，不仅为SDS分配修改所需要的空间，还会分配额外的未使用空间。\n\n如果修改后 SDS.len < 1MB，程序会分配给和len一样的长度给free\n\n如果修改后 SDS.len >= 1MB，程序会分配1MB给free\n\n##### 惰性空间释放\n\n用于优化SDS字符串缩短操作：不立即回收缩短后多出来的字节，而是用free记录。避免了缩短字符串时所需的内存重分配操作，并且为将来可能的增长提供了优化\n\nAPI也让我们在需要时，真正释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费\n\n#### 二进制安全\n\n1. C字符串并且符合特定的编码，并且除字符串的末尾外，不能包含空字符，使得他只能保存文本数据\n2. Redis以处理二进制的方式处理SDS存放在buf数组的数据，使用len而不是空字符判断字符串是否结束。所以他可以保存**任意格式**的二进制数据。\n\n#### 兼容部分C字符串函数\n\nSDS保存数据的末尾总是为空字符，所以让那些保存文本数据的SDS可以重用一部分<string.h>库'定义的函数\n\n## 链表\n\n被广泛用于实现Redis的各种功能，如列表键，发布与订阅，慢查询，监视器等等\n\n### 链表和链表节点的实现\n\n```c\ntypedef struct listNode\n{\n\tstruct listNode * prev;\n\tstruct listNode * next;\n\tvoid * value;\n}listNode;\n```\n\n```c\ntypedef struct list\n{\n\tlistNode *head;\n\tlistNode *tail;\n\tunsigned long len;\n\t\n\tvoid *(*dup)(void *ptr);//节点值的复制函数\n\tvoid (*free)(void * ptr);//节点值的释放函数\n\tint (*match)(void * ptr，void * key);//节点值的对比函数\n}\n```\n\n### 特性总结\n\n+ 双端、无环、带表头和表尾指针、带链表长度计数器\n+ 多态：可以保存各种不同类型的值\n\n\n\n## 字典\n\nRedis的数据库底层就是用字典实现的\n\n字典也是**哈希键**的底层实现之一\n\n### 字典的实现\n\n字典采用哈希表作为底层实现，一个哈希表可以有多个哈希表节点，每个节点保存了一个键值对\n\n每个字典带有**两个哈希表**，一个平时使用，一个仅仅在rehash时使用\n\n### 哈希表\n\n```c\ntypedef struct dictht\n{\n\tdictEntry ** table;//哈希表数组\n\tunsigned long size;\n\tunsigned long sizemask;//哈希表大小掩码，用于计算索引值 总=size-1\n\tunsigned long used;\n}dictht;\n```\n\nsizemask和哈希值一起决定一个键应该放到table数组里面的哪个索引上\n\n### 哈希表节点\n\n```c\ntypedef struct dictEntry\n{\n\tvoid *key;\n\tunion\n\t{\n\t\tvoid *val;\n\t\tuint64_t u64;\n\t\tint64_t s64;\n\t} v;\n\tstruct dictEntry * next; \n}dictEntry;\n```\n\n值可以是应该指针，或者是应该uint64_t类型的整数，或是一个int64_t整数\n\nnext属性指向另一个哈希表节点的指针，可以将多个哈希值相同的键值对连接在一起，以解决键冲突\n\n### 字典\n\n```c\ntypedef struct dict\n{\n\tdicType * type;//类型特定函数\n\tvoid * privdata;//私有数据\n\tditcht ht[2];//哈希表\n\t\n\tint rehashidx;//rehash索引，当rehash不再进行时，值为-1\n}dict;\n```\n\n1. type，privdata属性是针对不同类型的键值对，为创建多态字典而设置的\n2. 每个dicType结构保存了一簇用于操作特定类型键值对的函数\n3. privdata属性保存了需要传给那些类型特定函数的可选参数\n4. ht数组中，每个项都是**ditcht哈希表**，一般只使用ht[0]，ht[1]只会在ht[0]进行rehash时使用\n5. rehashidx记录rehash目前的进度\n\n### 哈希算法\n\n程序先通过键计算哈希值hash，在计算索引(hash & sizemask)，再根据索引将包含新键值对的哈希表节点放到哈希表数组的指定索引上\n\n### 解决键冲突\n\n用链地址法，多个分配到同一个索引的节点用单向链表连接起来。且用**头插法**，将新节点添加到链表的表头位置 \n\n### rehash\n\n#### 时机\n\n1. 若没有在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于1时rehash\n2. 若在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于5时rehash\n3. load_factor=ht[0].used / ht[0].size\n4. 以上的不同是因为，执行那两个命令时，Redis需要创建当前服务器进程的**子进程**，在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而京可能避免在子进程存在期间进行哈希表的扩展操作，可以避免不必要的内存写入操作，最大限度地节约内存\n5. 当负载因子小于0.1，则自动进行收缩操作\n\n#### 步骤\n\n1. 为字典的ht[1]哈希表分配空间\n    - 如果是扩展，则ht[1]大小为第一个大于等于 ht[0].used * 2 的2^n​。\n    - 如果是收缩，则是第一个大于等于 ht[0].used 的2^n​。\n2. 将保存在ht[0]的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后放到ht[1]的指定位置上\n3. 当ht[0]所有的键值对都迁移到了ht[1]，则将ht[1]设置为ht[0]，并且在ht[1]新建一个空哈希表\n\n### 渐进式rehash\n\n1. rehash时，服务器不是一次就将ht[0]里面的所有键值对全部rehash到ht[1]。而是分多次，**渐进式**地将ht[0]里面的键值对慢慢地rehash到ht[1]\n2. 在执行操作之外，顺带将键值对rehash到ht[1]中，把rehash键值对所需的计算工作均摊到每次对字典的增删改查操作之中。当rehash工作完成后，将rehashidx属性的值加一。所有的键rehash完毕后，rehashidx设置为-1\n3. 在进行渐进式rehash时，字典**同时**使用ht[0]，ht[1]。所以操作同时在两个哈希表中进行，即如果要查找一个键，会先在ht[0]找，没找到就继续到ht[1]中找\n4. 新添加的键值对直接保存到ht[1]中\n\n\n\n## 跳跃表\n\n### 简单记忆\n\n跳表具有如下性质：\n\n(1) 由很多层结构组成\n\n(2) 每一层都是一个有序的链表\n\n(3) 最底层(Level 1)的链表包含所有元素\n\n(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。\n\n(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/151153099856214.jpg)\n\n例子：查找元素 117\n\n(1) 比较 21， 比 21 大，往后面找\n\n(2) 比较 37,  比 37大，比链表最大值小，从 37 的下面一层开始找\n\n(3) 比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找\n\n(4) 比较 85， 比 85 大，从后面找\n\n(5) 比较 117， 等于 117， 找到了节点。\n\n```c\n/* 如果存在 x, 返回 x 所在的节点， \n * 否则返回 x 的后继节点 */  \nfind(x)   \n{  \n    p = top;  \n    while (1) {  \n        while (p->next->key < x)  \n            p = p->next;  \n        if (p->down == NULL)   \n            return p->next;  \n        p = p->down;  \n    }  \n}  \n```\n\n\n\n### 特性\n\n+ 通过在每个节点中维持多个指向其他节点的指针，从而快速访问节点\n+ 查找速度:平均O(log N)，最坏O(N)\n+ 支持顺序性操作\n+ 使用跳跃表作为有序集合键的底层实现之一\n\n- 因为要进行随机的插入和删除，不便用数组\n\n- 要定位插入位置一般用二分查找\n\n- 层级制，最下面所有元素串起来，每隔几个元素挑选一个代表，再将这几个代表用另外一级指针串起来，然后继续选出二级代表，最后形成金字塔结构\n\n- 插入，先在顶层定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插入进去\n\n- 随机策略，位于L0层概率为1，兼职L1层概率0.5，到L2层0.25，概率逐层降低\n\n\n### 性质\n\n1. 每一层都是一个有序的链表，最底层(L1)的链表包含**所有元素**\n2. 如果一个元素出现在第 n 层的链表中，则它也出现在第 n-1 层\n3. 搜索先从上层搜索，当前面的元素比target大时，则向下一级搜索(即向着更密集的数据找)\n4. 总体来看从左上往右下寻找\n\n### 查找代码\n\n从每个节点的最高层开始寻找，如果该层forward不为null，并且分值小于score，则跳到下一个节点，即x = x->level[i].forward，然后如果相等，则返回。如果该层的forward不满足，则遍历自己的下一个层级(level[i-1])的位置。综上就是从左往右，从上往下。\n\n```c\n// 通过分值和对象值获取排位信息，以1为起始值\nunsigned long zslGetRank(zskiplist *zsl， double score， robj *o) {\n    zskiplistNode *x;\n    unsigned long rank = 0;\n    int i;\n\n    x = zsl->header;\n    // 从最高层依次往下\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n            (x->level[i].forward->score < score ||\n                (x->level[i].forward->score == score &&\n                compareStringObjects(x->level[i].forward->obj，o) <= 0))) {\n            // 排位增加\n            rank += x->level[i].span;\n            x = x->level[i].forward;\n        }\n\n        /* x might be equal to zsl->header， so test if obj is non-NULL */\n        // 对象和分数值都相等\n        if (x->obj && equalStringObjects(x->obj，o)) {\n            return rank;\n        }\n    }\n    return 0;\n}\n```\n\n### 原理\n\n![IMG_20200818_102630](https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200818_102630.jpg)\n\nlevel:表中层数最大的节点的层数\n\nlength:节点数量\n\n### 跳跃表节点\n\n```c\ntypedef struct zskiplistNode\n{\n\tstruct zskiplistNode * backward;//后退指针\n\tdouble score;//分值\n\trobj * obj;//成员对象\n\t\n\tstruct zskiplistLevel //层\n\t{\n\t\tstruct zskiplistNode * forward; //前进指针\n\t\tunsigned int span;//跨度\n\t} level[];\n}\n```\n\n#### 层\n\nlevel数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，来加快访问其他节点的速度\n\n感觉幂次规律，随机生成一个[1，32]的值作为level数组的大小，即层的高度\n\n#### 前进指针\n\n每个层都有一个指向表尾方向的前进指针(level[i].forward)\n\n#### 跨度\n\n记录两个节点之间的距离\n\n指向NULL的所有前进指针的跨度都为0\n\n跨度实际是用来计算排位的:在查找某个节点过程中，将沿途访问的所有层的跨度累积起来，得到的结果就是目标节点在跳跃表中的排位(即该节点是第几个节点)\n\n#### 后退指针\n\n可以先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点...，直到遇到指向NULL的后退指针\n\n#### 分值和成员\n\n1. 分值:跳跃表中所有节点都按分值从小到大排序\n2. 成员对象:指向**SDS字符串**对象的指针\n3. 跳跃表中成员对象必须唯一，但是分值可以相同\n4. 分值相同的节点按照成员变量的字典序排序\n\n### 跳跃表结构\n\n```c\ntypedef struct zskiplist\n{\n\tstruct zskiplistNode * header，*tial;\n\tunsigned long length;//表中节点的数量\n\tint level;//表中层数最大的节点的层数\n} zskiplist;\n```\n\n使得能O(1)访问表头表尾节点，访问跳跃表长度，获取表中层数最大的节点的层数\n\n## 整数集合\n\n当一个集合只包含整数值元素，并且数量不多时，redis就会采用整数集合作为集合键的底层实现\n\n```c\ntypedef strcut intset\n{\n\tuint32_t encoding; //编码方式\n\tuint32_t length; //元素数量\n\tint8_t contents[]; //保存元素的数组\n}\n```\n\n可以保存类型为 int16_t，int32_t，int64_t的**非重复**整数值，且元素在contents数组中**有序排列**\n\n### 升级\n\n每当添加一个新元素到整数集合里面，并且新元素的类型比**现有所有元素类型**都长，需要先对整数集合进行升级，再加入该元素\n\n1. 根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间\n2. 将底层数组现有的**所有元素转换**成与新元素相同的类型，并且放置到正确位置上，仍需**保证有序性**\n3. 将新元素添加到底层数组里\n\n每次添加新元素都有可能引起升级，而每次升级都需要对底层数组所有元素进行类型转换，所以添加新元素时间复杂度为O(N)\n\n### 升级的好处\n\n#### 提升灵活性\n\n整数集合可以通过自动升级底层数组来适应新元素，所以可以将 int16_t、int32_t、int64_t随意地添加到集合中，不必担心类型错误\n\n#### 节约内存\n\n既可以让集合能**同时保存三种不同类型**的值，又可以确保升级只在必要时进行\n\n### 降级\n\n**不支持**降级操作，即使把之前因为他而升级的元素删除，底层数组还仍然是加入那个元素后的类型\n\n\n\n## 压缩列表\n\n### 特点\n\n- **（1）内存空间连续：**ziplist为了提高存储效率，从存储结构上看ziplist更像是一个表(list)，但不是一个链表(linkedlist)。ziplist将每一项数据存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。而普通的双向链表每一项都占用独立的一块内存，各项之间用指针连接，这样会带来大量内存碎片，而且指针也会占用额外内存。\n- **（2）查询元素：**查找指定的数据项就会性能变得很低，需要进行遍历整个zipList。\n- **（3）插入和修改：**每次插入或修改引发的重新分配内存(realloc)操作会有更大的概率造成内存拷贝，从而降低性能。跟list一样，一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据。\n\nziplist提高了存储效率，是内存紧缩的列表，多个数据在一起的连续空间，不擅长修改，在两端pop,push快。\n\n### 理解\n\n压缩链表同样具有一定的劣势。压缩链表由于使用的是有一段连续的内存，这就意味着，执行插入操作导致内存大小发生变化时，便会引起一次内存的重新分配过程，同时还会执行一定量的数据移动。特别是对于压缩链表较长的情况下，大批量的数据移动势必会降低系统的性能。而在上述这个方面恰恰就是经典双端链表的优势，故此*Redis*设计实现了一种快速链表的数据结构，兼具经典双端链表与压缩链表的特点，实现了时间与空间上的一种折衷。\n\n\n\n链表存在一个问题，便是在存储小数据的时候， 内存使用效率过低，例如当一个链表节点中只保存一个字节的`unsigned char`数据时，我们需要为这个节点保存24个字节的额外数据， 其中包含`listNode.prev`指针，`listNode.next`指针，以及指向具体数据的`listNode.value`指针， 同时对于链表节点所占用内存的反复申请与释放，也容易导致内存碎片的产生。 为了解决经典双端链表在保存小数据而导致内存效率过低的问题，*Redis*设了一套压缩链表的数据数据结构*ziplist*来对这种场景下的链表应用进行优化。\n\n压缩链表允许在链表两端以 *O(1)* 的时间复杂度执行 *Pop* 或者 *Push* 操作，当然这只是一种理想状态下的情况， 由于压缩链表实际上是内存中一段连续分配的内存，因此这些操作需要对压缩链表所使用的内存进行重新分配， 所以其真实的时间复杂度是和链表所使用的内存大小相关的。\n\n压缩链表与经典双端链表最大的区别在于，双端链表的节点是分散在内存中并不是连续的，压缩链表中所有的数据都是存储在一段连续的内存之中的\n\n\n\n压缩链表是相对于普通链表而言的\n\n当普通链表的数据越来越多, 链表查询性能会低效\n\n当存储的数据较少时, 使用链表存储会浪费空间\n\n压缩链表本质上是一个字符串\n\n压缩链表内存储的数据只能是 整型, 字符串\n\n### 具体\n\n- 压缩列表是列表键和哈希键的底层实现之一\n- 当一个列表键只包含**少量列表项**，并且每个列表项都是**小整数或较短字符串**，则用压缩列表作为底层实现\n- 压缩列表是为了**节约内存**而开发的，是由一系列特殊编码的连续内存块组成的**顺序型数据结构**\n    - zlbytes：记录整个压缩列表所占用的内存字节数，在内存重分配或zlend位置时使用\n    - zltail：记录压缩列表表尾节点距压缩列表的起始地址有多少字节，通过该偏移量，可无须遍历整个压缩列表就可以确定表尾节点的地址\n    - zllen：记录了压缩列表包含的节点数量\n    - entryX：压缩列表包含的各个节点，节点长度由节点包含的内容决定\n    - zlend：特殊值0xFF，用于标记压缩列表的末端\n\n![image-20210207091430874](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091430874.png)\n\n### 压缩列表节点的构成\n\n![image-20210207091652786](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091652786.png)\n\n#### previous_entry_length\n\n- 记录压缩列表**前一个节点**的长度\n- 通过指针运算，根据当前节点的起始地址得到前一个节点的起始地址\n- 用于从表尾到表头的遍历：指向表尾节点的指针可以通过压缩列表的起始地址的指针加上zltail得到\n\n#### encoding\n\n记录节点的content属性所保存数据的类型及长度\n\n#### content\n\n负责保存节点的值，值的类型和属性由encoding决定\n\n#### 连锁更新\n\n- 每个节点的previous_entry_length属性都记录了前一个节点的长度，如果前一节点长度小于254字节，则previous_entry_length属性用1字节空间保存该长度值，否则需要用5字节空间。\n- 如果在压缩列表中，有多个介于[250，153]字节的节点[e1，eN]，记录这些节点的长度只需要1字节长的**previous_entry_length**，所以[e1，eN]所有节点的**previous_entry_length**都是1字节长\n\n- 但如果将一个大于254字节的新节点new加入压缩列表的头节点，则new成为e1的前置节点。而这样e1的**previous_entry_length**属性不足以保存new的长度，所以进行空间重分配，变成5字节大小\n\n- 这样e1的长度大于254字节了，e2的**previous_entry_length**也不足以保存e1的长度，也扩展成5字节大小。这样就进行连续多次空间扩展，即连锁更新\n\n- 删除节点也会引发连锁更新\n- 连锁更新在最坏情况下需要对压缩列表进行N次空间重分配操作，每次操作最坏O(N)，所以连锁更新最坏时间复杂度为O(N^2)​.\n- 但是发生的机率比较低：\n    - 恰好有多个连续的，长度介于250-153字节的节点的情况并不多见 \n    - 即使出现连锁更新，只要被更新的节点数量不多，就不会对性能有影响\n- 所以平均复杂度为O(N)\n\n## 快速链表\n\n- 双向链表便于在表的进行插入和删除节点操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。\n- ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的内存重新分配(realloc)。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。\n\n可见，一个quicklist节点上的ziplist要保持一个合理的长度\n\n**quicklist将 双向链表插入和修改元素不需要移动节点的优点 和 ziplist的存储效率很高优点(一整块连续内存)结合在一起，同时将各自的缺点进行一个折中的处理。**\n\n### 使用原因\n\n链表在早先的 redis 版本中也作为 list 的数据结构使用过，但是单纯的链表的缺陷之前也说了，插入便利，但是空间利用率低，并且不能进行二分查找等，检索效率低，ziplist 压缩表的产生也是同理，希望获得更好的性能，包括存储空间和访问性能等\n\n作者结合了经典双端链表以及压缩链表的特性，实现了快速链表的数据结构。简单来说，使用双端链表的形式描述整个快速链表，而每一个快速链表的节点都是使用一个压缩链表作为底层数据存储，可以存储若干个数据节点。同时基于链表数据结构通常对头部与尾部的访问最为频繁，而对链表中间的数据访问并不是特别频繁，因此出于节省空间的目的，会对中间节点底层压缩链表所使用的内存进行压缩\n\n### 理解\n\nquicklist 里有 head，tail, quicklistNode里有 prev，next 指针，是不是有链表的基本轮廓了\n\n关键就在这个`unsigned char *zl;`zl 是不是前面又看到过，就是 ziplist ，这是什么鬼，\n\n链表里用压缩表\n\n回顾下前面说的 ziplist，ziplist 有哪些特点，内存利用率高，可以从表头快速定位到尾节点，节点可以从后往前找，但是有个缺点，就是从中间插入的效率比较低，需要整体往后移，这个其实是普通数组的优化版，但还是有数组的一些劣势，所以要真的快，是不是可以将链表跟数组真的结合起来。\n\n假如每个快表节点的 ziplist 只放一个元素，那么其实这就退化成了一个链表，如果 10 个元素放在一个 quicklistNode 的 ziplist 里，那就退化成了一个 ziplist\n\nquickList 是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1294391-20180827151851500-1561398239.png)\n\n  \n\n# 基本数据结构\n\n## 字符串对象\n\n1. 字符串对象的编码可以是int，raw，embstr\n2. 如果字符串对象保存整数值，且可以用long表示，则会将整数值保存在ptr中，enconding设为int\n3. 如果保存字符串值，并且长度大于39字节，就用`SDS`保存，并且设为raw\n4. 如果保存字符串值，并且长度小于39字节，就用`embstr`编码保存，并且设为embstr\n\n#### embstr\n\n专门用来保存短字符串的一种优化编码方式，和SDS差不多\n不同的是，只调用一次内存分配函数来分配一块连续的空间，空间依次包含redisObject，sdshdr两个结构\n优点：内存分配与释放次数由两次变为一次；字符串所有的数据保存在一块连续的内存中，更好利用缓存\n\n#### 编码的转换\n\n1. int编码的字符串对象如果操作后保存的不再是整数值，而是字符串值，则编码变为raw\n2. embstr编码的字符串对象只是可读的，对它执行任何修改命令，都会编程raw\n\n**应用**\n\n+ 点赞数量:  incr likes 每操作一 次，就+1，最后可以通过get likes得到最终结果\n+ 将用户信息使用JSON序列化为字符串，将字符串塞进Redis来缓存\n+ 如果value是整数，则可以进行自增操作。用于计数器：可以快速实现计数和查询的功能。\n\n## 列表对象\n\n编码可以是`ziplist`,`linkedlist`。ziplist使用压缩列表作为底层实现，linkedlist采用双端链表作为底层实现。每个双端链表节点都保持一个字符串对象（之后使用的是quickList)\n\n字符串对象是Redis 5种类型的对象中唯一一种会被其他四种对象嵌套的对象\n\n#### 编码转换\n\n使用ziplist编码的情况：\n\n1. 列表对象保存的所有字符串元素都小于64字节\n2. 列表保存的元素数量小于512\n\n**理解**\n\n+ 相当于LinkedList，是链表不是数组，插入删除快，索引定位慢\n+ 元素较少时会使用一块连续内存存储，即ziplist（压缩列表），所有元素彼此紧挨着一起存储\n+ 元素较多时采用快速链表（quicklist），将多个ziplist使用双向指针串起来使用，既满足快速插入删除，又不会出现太大空间冗余\n\n**应用场景**\n\n+ 粉丝列表、文章的评论列表\n\n+ 通过 lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。\n\n+ 消息队列（异步队列）：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。\n\n## 哈希对象\n\n编码可以是ziplist、hashtable。\n\n用ziplist则将键值对压入列表表尾，键值对紧挨一起，键在前，值在后。类似队列\n\nhashtable编码用字典作为底层实现，字典的每个键与值都是一个字符串对象\n\n#### 编码转换\n\n使用ziplist编码的情况：\n\n1. 列表对象保存的所有字符串元素都小于64字节\n2. 列表保存的元素数量小于512\n\n**应用**\n\n- 类似与Map<String，Map<String，String>\n\n- 和HashMap一样采用数组+链表\n\n- Redis字典的值只能是字符串\n\n- 渐进式rehash策略：在rehash时保留新旧两个hash结构，查询时会同时查询两个hash结构，循序渐进的将旧hash的内容一点点地迁移到新的hash结构中\n\n- 记录帖子的点赞数、评论数、点击数\n\n## 集合对象\n\n编码可以是intset、hashtable。\n\n用intset编码的集合使用整数集合作为底层实现\n\n用hashtable编码的集合使用字典作为底层实现，每个键是一个字符串对象，而值设为NULL\n\n#### 编码转换\n\n使用intset编码的情况：\n\n1. 列表对象保存的都是整数值\n2. 列表保存的元素数量小于512\n\n\n\n**set**\n\n- 相当于HashSet，键值对是无序的、唯一的。相当于所有value都是NULL的hash\n\n- 统计中奖的用户ID，可以去重\n\n\n+ 交集运算:微博共同关注 SINTER key1 key2\n+ 朋友圈点赞\n+ 抽奖活动\n    + SADD key 添加参与\n    + SCARD key 查看有几个人参与了抽奖\n    + SRANDMEMBER key 2 随机抽两个人，不删除\n    + SPOP key 随机抽取并删除1个人\n\n## 有序集合对象\n\n有序集合的编码可以是ziplist、skiplist\n\n用ziplist编码则每个集合元素使用两个紧挨的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值。集合元素按分值从小到大进行排序\n\n#### 用skiplist编码实现\n\n同时包含一个**字典**和**跳跃表**\n\n```c\ntypedef struct zset\n{\n\tzskiplist *zsl;\n\tdict * dict;\n} zset;\n```\n\nzset中的zsl跳跃表按分值从小到大保存了所有集合元素\n\n每个跳跃表节点中：object属性保存元素的成员，score属性保存元素的分值\n\n此外，dict中，字典的键保存元素的成员，值保存元素的分值，这样，通过字典可以用O(1)的复杂度查找给定成员的分值\n\n这两种数据结构都会通过指针来共享相同元素的成员和分值，所以使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，不会浪费额外内存\n\n优点：\n\n+ 范围操作不需要对字典保存的所有元素进行排序，从O(NlogN)到O(N)\n+ 根据成员查询分值不需要通过跳跃表，复杂度从O(N)降低到O(1)\n\n#### 编码转换\n\n使用ziplist编码的情况：\n\n1. 有序集合保存的所有元素长度都小于64字节\n2. 有序集合保存的元素数量小于128个\n\n**应用**\n\n+ 类似于SortedSet和HashMap的结合体，保证了value的唯一性，每个value有score（排序权重）\n\n+ 热搜\n\n+ 游戏排名\n\n+ 排行榜：榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。\n\n+ 微博热搜榜，value是名称，score是热度值\n\n+ 粉丝列表，value是粉丝用户ID，score是关注时间\n\n+ 学生成绩，value是学生ID，score是考试成绩\n\n## 对象特性\n\n### 简介\n\n1. 基于之前的数据结构创建一个对象系统。包括字符串对象，列表对象，哈希对象，集合对象，有序集合对象五种\n2. 可以在执行命令之前，根据对象类型判断一个对象能否执行给定的命令\n3. 可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率\n4. 实现基于引用计数的内存回收机制，实现内存共享机制，让多个数据库键共享同一个对象节约内存\n5. 对象带有访问时间记录信息，记录数据库键的空转时间\n\n**理解**\n\n每个键值对都是由对象组成，键总是一个字符串对象，值可以是五种对象中的一种\n\n如果容器不存在，则先创建一个再进行操作\n\n如果容器里元素为空，则立刻删除容器，释放内存\n\n### 对象的类型和编码\n\n使用对象来表示数据库的键和值，新创建一个键值对时，会创建两个对象分别代表键和值\n\n```c\ntypedef struct redisObject\n{\n\tunsigned type:4;//类型\n\tunsigned encoding:4;//编码\n\tvoid * ptr;//指向底层实现数据结构的指针\n}\n```\n\n#### 类型\n\n`type`属性记录了对象的类型，即五种对象类型之一\n对于一个键值对，键总是字符串对象，值可以是五种对象类型之一\n\n#### 编码和底层实现\n\n1. 对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，即之前学习的几种数据结构\n2. 每种类型的对象都至少使用了两种不同的编码\n3. 通过`encoding`属性来设定使用的编码，极大地提升了灵活性和效率，可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率\n\n### 类型检查和命令多态\n\n在执行一个类型的特定命令之前，服务器会检查输入数据库键的值对象是否为执行命令所需的指令，如果是，服务器就会对键执行指定的命令。否则将拒绝执行命令，并向客户端返回一个类型错误。\n\n类型检查是通过`redisObject`结构的type属性来实现的 \n\n#### 多态命令的实现\n\nRedis除了会根据值对象的类型来判断键是否能够执行指定指令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令\n\n例如，`LLEN命令`是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行\n\nDEL，TYPE等命令也是多态命令，无论输入的键是什么类型，这些命令都可以正常执行。区别在于，DEL，TYPE等命令是基于类型的多态，一个命令可以处理多种不同的类型的键，LLen命令是基于编码的多态，一个命令可以同时用于处理多种不同编码\n\n### 内存回收\n\n基于引用计数法实现内存回收机制，通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收\n\n1. 创建对象，引用计数值为1\n2. 对象被新程序使用，引用计数值+1\n3. 对象不被一个程序使用，引用计数值-1\n4. 引用计数值为0时，释放对象占用的内存\n\n### 对象共享\n\n#### 步骤\n\n让多个键共享同一个值对象步骤：\n\n1. 将数据库键的值指向一个现有的值对象\n2. 将被共享的值对象引用计数值+1\n\n#### 内置整数\n\nRedis在初始化服务器时，会创建一万个字符串对象，存储[0,9999]的整数值。如果需要用到这些字符串对象，服务器则会使用这些共享对象，而不会新创建对象。\n\n这些共享对象不仅仅只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象\n\n#### 为什么不共享包含字符串的对象\n\n只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象\n\n一个共享对象保存的值越复杂，则验证共享对象和目标对象是否相同所需的复杂度越高：\n\n1. 共享对象是整数值的字符串对象，验证操作为`O(1)`\n2. 共享对象是保存字符串值的字符串对象，验证操作为`O(N)`\n3. 共享对象是包含多个值的对象（如列表），验证操作为`O(N^2)`\n\n### 对象的空转时间\n\n`redisObject`结构包含属性lru,记录了对象最后一次被命令程序访问的时间。可用当前时间-键的值对象的lru时间求得空转时间\n\n可通过设置，使得当服务器占用的内存数超过了，`maxmemory`的上限时，空转时间较高的那部分键会优先被服务器释放，从而回收内存\n\n# 高级数据结构\n\n## 位图bitmap\n\n位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组\n\n可以使用get/set 直接获取和设置整个位图的内容，也可以使⽤位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。\n\n位数组会自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动进行零扩充\n\n\n\n**应用场景**\n\n用户签到\n\n+ 有些bool 型数据需要存取，例如用户⼀年的签到记录，签了是 1，没签是0，要记录 365 天\n+ 位图数据结构让每天的签到记录只占据⼀个位，365 天就是 365个位，46 个字节 (⼀个稍长⼀点的字符串) 就可以完全容纳下\n+ 统计和查找\n    + bitcount：统计指定范围内1的个数，可以统计用户一共签到多少天 \n    + bitpos：用于查找指定范围内出现的第一个0或1，从哪天开始第一次签到\n\n## HyperLogLog\n\n+ 提供不精确的去重统计方案，标准误差是0.81%\n+ 不能知道一个值是否在结构中，即不提供 pfcontains功能\n\n+ pfadd 和 pfcount，⼀个是增加计数，⼀个是获取计数。pfadd codehole user1（将用户ID塞进去）；pfcount codehole\n+ pfmerge：用于将多个pf计数值累加在一起形成一个新的pf值，例如两个差不多的页面进行合并，需要将页面的UV访问量也合并\n+ 场景：UV（Unique Visitor） 需要去重，同⼀个用户⼀天之内的多次访问请求只能计数⼀次。\n+ 实现：计数较小时使用稀疏矩阵存储，占用空间超过阈值，则转成稠密矩阵\n\n## Bloom Filter\n\n### 定义\n\n布隆过滤器是一个很长的二进制向量和一系列随机映射函数。\n\n优点是空间效率和查询时间都远远超过⼀般的算法\n\n### 原理\n\n当⼀个元素被加入集合时，通过K个散列函数将这个元素映射成⼀个位数组中的K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（⼤约）知道集合中有没有它了：如 果这些点有任何⼀个0，则被检元素⼀定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。\n\nBloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使⽤了k个哈希函数，每个字符串跟k个 bit对应。从⽽降低了冲突的概率。\n\n### 特点\n\n+ 是一个很长的二进制向量和一系列随机映射函数\n+ 当⼀个元素被加入集合时，通过K个散列函数将这个元素映射成⼀个位数组中的K 个点，把它们置为1\n+ exists：把hash的几个位置都算出来，看看位数组在几个位置是否都为1\n    + 如果这些点有任何⼀个0，则被检元素⼀定不在\n    + 如果都是1，则被检元素很可能在\n+ 空间效率和查询时间都远远超过⼀般的算法\n+ 存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1\n+ 删除困难。⼀个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。\n\n### 缺点\n\n缺点是有⼀定的误识别率和删除困难，bloom filter之所以能做到在时间和空间上的效率⽐较⾼，是因为牺牲了判断的准确率、删除的便利性\n\n+ 存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果 bloom filter中存储的是⿊名单，那么可以通过建⽴⼀个白名单来存储可能会误判的元素。\n+ 删除困难。⼀个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。\n\n### 实现\n\n+ 在使⽤bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp\n+  在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的⼤⼩。\n+ 对于⼀个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数 组的⼤⼩m，以及hash函数的个数k，并选择hash函数\n+ 一个好的哈希函数要能近似等概率的将字符串映射到各个 Bit。选择k个不同的哈希函数⽐较麻烦，⼀种简单的⽅法是选择⼀个哈希函数，然后送入k个不同的参数。 \n\n```java\n//项目要导入guava的maven依赖\npackage com.tongji;\n\n\nimport com.google.common.hash.BloomFilter;\nimport com.google.common.hash.Funnels;\n\n/**\n * 测试布隆过滤器(可用于redis缓存穿透)\n * @author tongji4m3\n */\n\npublic class TestBloomFilter {\n    private static int total = 1000000;\n    /*\n    static <T> BloomFilter<T> create(Funnel<? super T> funnel， long expectedInsertions， double fpp， BloomFilter.Strategy strategy)\n    funnel：数据类型(⼀般是调⽤Funnels⼯具类中的)\n    expectedInsertions：期望插入的值的个数\n    fpp 错误率(默认值为0.03)\n    strategy 哈希算法\n\n    numBits，表示存⼀百万个int类型数字，需要的位数为7298440，700多万位。理论上存⼀百万个\n    数，⼀个int是4字节32位，需要481000000=3200万位。如果使⽤HashMap去存，按HashMap50%的\n    存储效率，需要6400万位。可以看出BloomFilter的存储空间很⼩，只有HashMap的1/10左右\n\n    错误率越⼤，所需空间和时间越⼩，错误率越⼩，所需空间和时间越⼤\n     */\n    private static BloomFilter<Integer> bloomFilter = BloomFilter.create(Funnels.integerFunnel()， total);\n\n    public static void main(String[] args) {\n        //初始化total条数据到过滤器里\n        for (int i = 0; i < total; i++) {\n            bloomFilter.put(i);\n        }\n        //匹配已经再过滤器中的值，看是否有匹配不上的\n        //没有输出，说明只要放进去的，都能匹配上\n        for (int i = 0; i < total; i++) {\n            if (!bloomFilter.mightContain(i)) {\n                System.out.println(\"有坏人逃脱啦~\");\n            }\n        }\n\n        //匹配不在过滤器中的10000个值，有多少匹配出来\n        int count = 0;\n        for (int i = total; i < total + 10000; i++) {\n            if (bloomFilter.mightContain(i)) {\n                ++count;\n            }\n        }\n        //误伤数量: 320 错误率是0.03左右\n        System.out.println(\"误伤数量: \"+count);\n    }\n}\n```\n\n### 应用\n\n#### 缓存击穿\n\n数据库的id都是1开始然后自增的，那我知道你接⼝是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我⼜去数据库查也没有，⼀个请求这样，100个，1000 个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return⼀个数据为空不就好了嘛。\n\n+ 海量数据去重\n+ 用于检索一个元素是否在一个集合中\n+ 爬⾍过滤已抓到的url就不再抓，可⽤bloom filter过滤，只会使得爬虫系统错过少量的新页面\n+ 垃圾邮件过滤。Bloom Filter只需要哈希表 1/8到 1/4 的大小\n+ 海量数据去重：不断放入元素到集合中，检索一个元素是否在一个集合中，在则说明重复、推荐去重，即APP会把用户已经看过的内容去掉、能准确过滤掉用户已经看过的内容，那些用户没有看过的新内容，也会过滤掉极小一部分（误判）\n\n","slug":"数据库/Redis数据库/1.Redis数据结构","published":1,"updated":"2021-06-08T03:35:00.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq51e001dz0tp5nh8d6no","content":"<h1 id=\"底层数据结构\"><a href=\"#底层数据结构\" class=\"headerlink\" title=\"底层数据结构\"></a>底层数据结构</h1><h2 id=\"简单动态字符串\"><a href=\"#简单动态字符串\" class=\"headerlink\" title=\"简单动态字符串\"></a>简单动态字符串</h2><h3 id=\"SDS简介\"><a href=\"#SDS简介\" class=\"headerlink\" title=\"SDS简介\"></a>SDS简介</h3><ul>\n<li>使用<strong>简单动态字符串</strong>(simple dynamic string SDS)作为默认字符串</li>\n<li>c字符串只作为字符串字面量，用在无需对字符串值进行修改的地方</li>\n<li>包含字符串值的键值对在底层都是用SDS实现的</li>\n</ul>\n<h3 id=\"SDS的定义\"><a href=\"#SDS的定义\" class=\"headerlink\" title=\"SDS的定义\"></a>SDS的定义</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> sdshdr\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//记录buf数组中已使用字节的数量 为字符串长度</span>\n    <span class=\"token keyword\">int</span> free<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//未使用的数量</span>\n    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//字节数组，用来保存字符串</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ol>\n<li>buf数组以空字符结尾，且最后的空字符不算在len里面</li>\n<li>该空字符由SDS函数自动完成，对SDS用户透明</li>\n</ol>\n<h3 id=\"SDS与C字符串的区别\"><a href=\"#SDS与C字符串的区别\" class=\"headerlink\" title=\"SDS与C字符串的区别\"></a>SDS与C字符串的区别</h3><h4 id=\"获取字符串长度所需复杂度从O-N-降低到​O-1-​\"><a href=\"#获取字符串长度所需复杂度从O-N-降低到​O-1-​\" class=\"headerlink\" title=\"获取字符串长度所需复杂度从O(N)降低到​O(1)​\"></a>获取字符串长度所需复杂度从O(N)降低到​O(1)​</h4><h4 id=\"杜绝了缓冲区溢出\"><a href=\"#杜绝了缓冲区溢出\" class=\"headerlink\" title=\"杜绝了缓冲区溢出\"></a>杜绝了缓冲区溢出</h4><p>例如c进行字符串拼接，需要假设已经为字符串分配了足够的内存以容纳要拼接的字符串，否则就会溢出。<br><strong>SDS空间分配策略</strong>完全杜绝了发生缓冲区溢出的可能性。当要对SDS进行修改时，会先检查空间是否满足修改所需的要求，如果不满足，则会自动将<strong>SDS的空间扩展</strong>，然后再执行实际的修改操作</p>\n<h4 id=\"减少修改字符串时带来的内存重分配次数\"><a href=\"#减少修改字符串时带来的内存重分配次数\" class=\"headerlink\" title=\"减少修改字符串时带来的内存重分配次数\"></a>减少修改字符串时带来的内存重分配次数</h4><p>C字符串底层实现总是一个N+1个字符长的数组，每次对该数组进行增加或缩短，总要进行一次<strong>内存重分配</strong>操作。如果是增长，则要内存重分配扩展底层数组的空间大小。如果是缩短，则执行操作后，需要内存重分配来释放空间，避免内存泄漏。</p>\n<p>Redis通过<strong>未使用空间</strong>解除了字符串长度和底层数组长度之间的关联</p>\n<h5 id=\"空间预分配\"><a href=\"#空间预分配\" class=\"headerlink\" title=\"空间预分配\"></a>空间预分配</h5><p>用于优化SDS的字符串增长操作，在扩展SDS空间之前，会先检查未使用的空间是否足够，如果足够，则直接使用未使用空间，无需进行内存重分配。</p>\n<p>在对一个SDS进行修改，并且需要对SDS进行空间扩展时，不仅为SDS分配修改所需要的空间，还会分配额外的未使用空间。</p>\n<p>如果修改后 SDS.len &lt; 1MB，程序会分配给和len一样的长度给free</p>\n<p>如果修改后 SDS.len &gt;= 1MB，程序会分配1MB给free</p>\n<h5 id=\"惰性空间释放\"><a href=\"#惰性空间释放\" class=\"headerlink\" title=\"惰性空间释放\"></a>惰性空间释放</h5><p>用于优化SDS字符串缩短操作：不立即回收缩短后多出来的字节，而是用free记录。避免了缩短字符串时所需的内存重分配操作，并且为将来可能的增长提供了优化</p>\n<p>API也让我们在需要时，真正释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费</p>\n<h4 id=\"二进制安全\"><a href=\"#二进制安全\" class=\"headerlink\" title=\"二进制安全\"></a>二进制安全</h4><ol>\n<li>C字符串并且符合特定的编码，并且除字符串的末尾外，不能包含空字符，使得他只能保存文本数据</li>\n<li>Redis以处理二进制的方式处理SDS存放在buf数组的数据，使用len而不是空字符判断字符串是否结束。所以他可以保存<strong>任意格式</strong>的二进制数据。</li>\n</ol>\n<h4 id=\"兼容部分C字符串函数\"><a href=\"#兼容部分C字符串函数\" class=\"headerlink\" title=\"兼容部分C字符串函数\"></a>兼容部分C字符串函数</h4><p>SDS保存数据的末尾总是为空字符，所以让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库’定义的函数</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>被广泛用于实现Redis的各种功能，如列表键，发布与订阅，慢查询，监视器等等</p>\n<h3 id=\"链表和链表节点的实现\"><a href=\"#链表和链表节点的实现\" class=\"headerlink\" title=\"链表和链表节点的实现\"></a>链表和链表节点的实现</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> listNode\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> listNode <span class=\"token operator\">*</span> prev<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> listNode <span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>listNode<span class=\"token punctuation\">;</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> list\n<span class=\"token punctuation\">{</span>\n    listNode <span class=\"token operator\">*</span>head<span class=\"token punctuation\">;</span>\n    listNode <span class=\"token operator\">*</span>tail<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> len<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>dup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//节点值的复制函数</span>\n    <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>free<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//节点值的释放函数</span>\n    <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>match<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> ptr，<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//节点值的对比函数</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"特性总结\"><a href=\"#特性总结\" class=\"headerlink\" title=\"特性总结\"></a>特性总结</h3><ul>\n<li>双端、无环、带表头和表尾指针、带链表长度计数器</li>\n<li>多态：可以保存各种不同类型的值</li>\n</ul>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>Redis的数据库底层就是用字典实现的</p>\n<p>字典也是<strong>哈希键</strong>的底层实现之一</p>\n<h3 id=\"字典的实现\"><a href=\"#字典的实现\" class=\"headerlink\" title=\"字典的实现\"></a>字典的实现</h3><p>字典采用哈希表作为底层实现，一个哈希表可以有多个哈希表节点，每个节点保存了一个键值对</p>\n<p>每个字典带有<strong>两个哈希表</strong>，一个平时使用，一个仅仅在rehash时使用</p>\n<h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> dictht\n<span class=\"token punctuation\">{</span>\n    dictEntry <span class=\"token operator\">*</span><span class=\"token operator\">*</span> table<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//哈希表数组</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> size<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> sizemask<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//哈希表大小掩码，用于计算索引值 总=size-1</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> used<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>dictht<span class=\"token punctuation\">;</span></code></pre>\n<p>sizemask和哈希值一起决定一个键应该放到table数组里面的哪个索引上</p>\n<h3 id=\"哈希表节点\"><a href=\"#哈希表节点\" class=\"headerlink\" title=\"哈希表节点\"></a>哈希表节点</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> dictEntry\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>key<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">union</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>val<span class=\"token punctuation\">;</span>\n        uint64_t u64<span class=\"token punctuation\">;</span>\n        int64_t s64<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> v<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> dictEntry <span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>dictEntry<span class=\"token punctuation\">;</span></code></pre>\n<p>值可以是应该指针，或者是应该uint64_t类型的整数，或是一个int64_t整数</p>\n<p>next属性指向另一个哈希表节点的指针，可以将多个哈希值相同的键值对连接在一起，以解决键冲突</p>\n<h3 id=\"字典-1\"><a href=\"#字典-1\" class=\"headerlink\" title=\"字典\"></a>字典</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> dict\n<span class=\"token punctuation\">{</span>\n    dicType <span class=\"token operator\">*</span> type<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//类型特定函数</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> privdata<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//私有数据</span>\n    ditcht ht<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//哈希表</span>\n\n    <span class=\"token keyword\">int</span> rehashidx<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//rehash索引，当rehash不再进行时，值为-1</span>\n<span class=\"token punctuation\">}</span>dict<span class=\"token punctuation\">;</span></code></pre>\n<ol>\n<li>type，privdata属性是针对不同类型的键值对，为创建多态字典而设置的</li>\n<li>每个dicType结构保存了一簇用于操作特定类型键值对的函数</li>\n<li>privdata属性保存了需要传给那些类型特定函数的可选参数</li>\n<li>ht数组中，每个项都是<strong>ditcht哈希表</strong>，一般只使用ht[0]，ht[1]只会在ht[0]进行rehash时使用</li>\n<li>rehashidx记录rehash目前的进度</li>\n</ol>\n<h3 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h3><p>程序先通过键计算哈希值hash，在计算索引(hash &amp; sizemask)，再根据索引将包含新键值对的哈希表节点放到哈希表数组的指定索引上</p>\n<h3 id=\"解决键冲突\"><a href=\"#解决键冲突\" class=\"headerlink\" title=\"解决键冲突\"></a>解决键冲突</h3><p>用链地址法，多个分配到同一个索引的节点用单向链表连接起来。且用<strong>头插法</strong>，将新节点添加到链表的表头位置 </p>\n<h3 id=\"rehash\"><a href=\"#rehash\" class=\"headerlink\" title=\"rehash\"></a>rehash</h3><h4 id=\"时机\"><a href=\"#时机\" class=\"headerlink\" title=\"时机\"></a>时机</h4><ol>\n<li>若没有在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于1时rehash</li>\n<li>若在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于5时rehash</li>\n<li>load_factor=ht[0].used / ht[0].size</li>\n<li>以上的不同是因为，执行那两个命令时，Redis需要创建当前服务器进程的<strong>子进程</strong>，在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而京可能避免在子进程存在期间进行哈希表的扩展操作，可以避免不必要的内存写入操作，最大限度地节约内存</li>\n<li>当负载因子小于0.1，则自动进行收缩操作</li>\n</ol>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>为字典的ht[1]哈希表分配空间<ul>\n<li>如果是扩展，则ht[1]大小为第一个大于等于 ht[0].used * 2 的2^n​。</li>\n<li>如果是收缩，则是第一个大于等于 ht[0].used 的2^n​。</li>\n</ul>\n</li>\n<li>将保存在ht[0]的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后放到ht[1]的指定位置上</li>\n<li>当ht[0]所有的键值对都迁移到了ht[1]，则将ht[1]设置为ht[0]，并且在ht[1]新建一个空哈希表</li>\n</ol>\n<h3 id=\"渐进式rehash\"><a href=\"#渐进式rehash\" class=\"headerlink\" title=\"渐进式rehash\"></a>渐进式rehash</h3><ol>\n<li>rehash时，服务器不是一次就将ht[0]里面的所有键值对全部rehash到ht[1]。而是分多次，<strong>渐进式</strong>地将ht[0]里面的键值对慢慢地rehash到ht[1]</li>\n<li>在执行操作之外，顺带将键值对rehash到ht[1]中，把rehash键值对所需的计算工作均摊到每次对字典的增删改查操作之中。当rehash工作完成后，将rehashidx属性的值加一。所有的键rehash完毕后，rehashidx设置为-1</li>\n<li>在进行渐进式rehash时，字典<strong>同时</strong>使用ht[0]，ht[1]。所以操作同时在两个哈希表中进行，即如果要查找一个键，会先在ht[0]找，没找到就继续到ht[1]中找</li>\n<li>新添加的键值对直接保存到ht[1]中</li>\n</ol>\n<h2 id=\"跳跃表\"><a href=\"#跳跃表\" class=\"headerlink\" title=\"跳跃表\"></a>跳跃表</h2><h3 id=\"简单记忆\"><a href=\"#简单记忆\" class=\"headerlink\" title=\"简单记忆\"></a>简单记忆</h3><p>跳表具有如下性质：</p>\n<p>(1) 由很多层结构组成</p>\n<p>(2) 每一层都是一个有序的链表</p>\n<p>(3) 最底层(Level 1)的链表包含所有元素</p>\n<p>(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</p>\n<p>(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/151153099856214.jpg\"></p>\n<p>例子：查找元素 117</p>\n<p>(1) 比较 21， 比 21 大，往后面找</p>\n<p>(2) 比较 37,  比 37大，比链表最大值小，从 37 的下面一层开始找</p>\n<p>(3) 比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找</p>\n<p>(4) 比较 85， 比 85 大，从后面找</p>\n<p>(5) 比较 117， 等于 117， 找到了节点。</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* 如果存在 x, 返回 x 所在的节点， \n * 否则返回 x 的后继节点 */</span>  \n<span class=\"token function\">find</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>   \n<span class=\"token punctuation\">{</span>  \n    p <span class=\"token operator\">=</span> top<span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>next<span class=\"token operator\">-></span>key <span class=\"token operator\">&lt;</span> x<span class=\"token punctuation\">)</span>  \n            p <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>down <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>   \n            <span class=\"token keyword\">return</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>  \n        p <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>down<span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span>  </code></pre>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ul>\n<li>通过在每个节点中维持多个指向其他节点的指针，从而快速访问节点</li>\n<li>查找速度:平均O(log N)，最坏O(N)</li>\n<li>支持顺序性操作</li>\n<li>使用跳跃表作为有序集合键的底层实现之一</li>\n</ul>\n<ul>\n<li><p>因为要进行随机的插入和删除，不便用数组</p>\n</li>\n<li><p>要定位插入位置一般用二分查找</p>\n</li>\n<li><p>层级制，最下面所有元素串起来，每隔几个元素挑选一个代表，再将这几个代表用另外一级指针串起来，然后继续选出二级代表，最后形成金字塔结构</p>\n</li>\n<li><p>插入，先在顶层定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插入进去</p>\n</li>\n<li><p>随机策略，位于L0层概率为1，兼职L1层概率0.5，到L2层0.25，概率逐层降低</p>\n</li>\n</ul>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><ol>\n<li>每一层都是一个有序的链表，最底层(L1)的链表包含<strong>所有元素</strong></li>\n<li>如果一个元素出现在第 n 层的链表中，则它也出现在第 n-1 层</li>\n<li>搜索先从上层搜索，当前面的元素比target大时，则向下一级搜索(即向着更密集的数据找)</li>\n<li>总体来看从左上往右下寻找</li>\n</ol>\n<h3 id=\"查找代码\"><a href=\"#查找代码\" class=\"headerlink\" title=\"查找代码\"></a>查找代码</h3><p>从每个节点的最高层开始寻找，如果该层forward不为null，并且分值小于score，则跳到下一个节点，即x = x-&gt;level[i].forward，然后如果相等，则返回。如果该层的forward不满足，则遍历自己的下一个层级(level[i-1])的位置。综上就是从左往右，从上往下。</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">// 通过分值和对象值获取排位信息，以1为起始值</span>\n<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token function\">zslGetRank</span><span class=\"token punctuation\">(</span>zskiplist <span class=\"token operator\">*</span>zsl， <span class=\"token keyword\">double</span> score， robj <span class=\"token operator\">*</span>o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    zskiplistNode <span class=\"token operator\">*</span>x<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> rank <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n    x <span class=\"token operator\">=</span> zsl<span class=\"token operator\">-></span>header<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 从最高层依次往下</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> zsl<span class=\"token operator\">-></span>level<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">-></span>level<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>forward <span class=\"token operator\">&amp;&amp;</span>\n            <span class=\"token punctuation\">(</span>x<span class=\"token operator\">-></span>level<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>forward<span class=\"token operator\">-></span>score <span class=\"token operator\">&lt;</span> score <span class=\"token operator\">||</span>\n                <span class=\"token punctuation\">(</span>x<span class=\"token operator\">-></span>level<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>forward<span class=\"token operator\">-></span>score <span class=\"token operator\">==</span> score <span class=\"token operator\">&amp;&amp;</span>\n                <span class=\"token function\">compareStringObjects</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">-></span>level<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>forward<span class=\"token operator\">-></span>obj，o<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 排位增加</span>\n            rank <span class=\"token operator\">+</span><span class=\"token operator\">=</span> x<span class=\"token operator\">-></span>level<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>span<span class=\"token punctuation\">;</span>\n            x <span class=\"token operator\">=</span> x<span class=\"token operator\">-></span>level<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>forward<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/* x might be equal to zsl->header， so test if obj is non-NULL */</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 对象和分数值都相等</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">-></span>obj <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">equalStringObjects</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">-></span>obj，o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> rank<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200818_102630.jpg\" alt=\"IMG_20200818_102630\"></p>\n<p>level:表中层数最大的节点的层数</p>\n<p>length:节点数量</p>\n<h3 id=\"跳跃表节点\"><a href=\"#跳跃表节点\" class=\"headerlink\" title=\"跳跃表节点\"></a>跳跃表节点</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> zskiplistNode\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> zskiplistNode <span class=\"token operator\">*</span> backward<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//后退指针</span>\n    <span class=\"token keyword\">double</span> score<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//分值</span>\n    robj <span class=\"token operator\">*</span> obj<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//成员对象</span>\n\n    <span class=\"token keyword\">struct</span> zskiplistLevel <span class=\"token comment\" spellcheck=\"true\">//层</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">struct</span> zskiplistNode <span class=\"token operator\">*</span> forward<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//前进指针</span>\n        <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> span<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//跨度</span>\n    <span class=\"token punctuation\">}</span> level<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"层\"><a href=\"#层\" class=\"headerlink\" title=\"层\"></a>层</h4><p>level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，来加快访问其他节点的速度</p>\n<p>感觉幂次规律，随机生成一个[1，32]的值作为level数组的大小，即层的高度</p>\n<h4 id=\"前进指针\"><a href=\"#前进指针\" class=\"headerlink\" title=\"前进指针\"></a>前进指针</h4><p>每个层都有一个指向表尾方向的前进指针(level[i].forward)</p>\n<h4 id=\"跨度\"><a href=\"#跨度\" class=\"headerlink\" title=\"跨度\"></a>跨度</h4><p>记录两个节点之间的距离</p>\n<p>指向NULL的所有前进指针的跨度都为0</p>\n<p>跨度实际是用来计算排位的:在查找某个节点过程中，将沿途访问的所有层的跨度累积起来，得到的结果就是目标节点在跳跃表中的排位(即该节点是第几个节点)</p>\n<h4 id=\"后退指针\"><a href=\"#后退指针\" class=\"headerlink\" title=\"后退指针\"></a>后退指针</h4><p>可以先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点…，直到遇到指向NULL的后退指针</p>\n<h4 id=\"分值和成员\"><a href=\"#分值和成员\" class=\"headerlink\" title=\"分值和成员\"></a>分值和成员</h4><ol>\n<li>分值:跳跃表中所有节点都按分值从小到大排序</li>\n<li>成员对象:指向<strong>SDS字符串</strong>对象的指针</li>\n<li>跳跃表中成员对象必须唯一，但是分值可以相同</li>\n<li>分值相同的节点按照成员变量的字典序排序</li>\n</ol>\n<h3 id=\"跳跃表结构\"><a href=\"#跳跃表结构\" class=\"headerlink\" title=\"跳跃表结构\"></a>跳跃表结构</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> zskiplist\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> zskiplistNode <span class=\"token operator\">*</span> header，<span class=\"token operator\">*</span>tial<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> length<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//表中节点的数量</span>\n    <span class=\"token keyword\">int</span> level<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//表中层数最大的节点的层数</span>\n<span class=\"token punctuation\">}</span> zskiplist<span class=\"token punctuation\">;</span></code></pre>\n<p>使得能O(1)访问表头表尾节点，访问跳跃表长度，获取表中层数最大的节点的层数</p>\n<h2 id=\"整数集合\"><a href=\"#整数集合\" class=\"headerlink\" title=\"整数集合\"></a>整数集合</h2><p>当一个集合只包含整数值元素，并且数量不多时，redis就会采用整数集合作为集合键的底层实现</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> strcut intset\n<span class=\"token punctuation\">{</span>\n    uint32_t encoding<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//编码方式</span>\n    uint32_t length<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//元素数量</span>\n    int8_t contents<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//保存元素的数组</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>可以保存类型为 int16_t，int32_t，int64_t的<strong>非重复</strong>整数值，且元素在contents数组中<strong>有序排列</strong></p>\n<h3 id=\"升级\"><a href=\"#升级\" class=\"headerlink\" title=\"升级\"></a>升级</h3><p>每当添加一个新元素到整数集合里面，并且新元素的类型比<strong>现有所有元素类型</strong>都长，需要先对整数集合进行升级，再加入该元素</p>\n<ol>\n<li>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li>\n<li>将底层数组现有的<strong>所有元素转换</strong>成与新元素相同的类型，并且放置到正确位置上，仍需<strong>保证有序性</strong></li>\n<li>将新元素添加到底层数组里</li>\n</ol>\n<p>每次添加新元素都有可能引起升级，而每次升级都需要对底层数组所有元素进行类型转换，所以添加新元素时间复杂度为O(N)</p>\n<h3 id=\"升级的好处\"><a href=\"#升级的好处\" class=\"headerlink\" title=\"升级的好处\"></a>升级的好处</h3><h4 id=\"提升灵活性\"><a href=\"#提升灵活性\" class=\"headerlink\" title=\"提升灵活性\"></a>提升灵活性</h4><p>整数集合可以通过自动升级底层数组来适应新元素，所以可以将 int16_t、int32_t、int64_t随意地添加到集合中，不必担心类型错误</p>\n<h4 id=\"节约内存\"><a href=\"#节约内存\" class=\"headerlink\" title=\"节约内存\"></a>节约内存</h4><p>既可以让集合能<strong>同时保存三种不同类型</strong>的值，又可以确保升级只在必要时进行</p>\n<h3 id=\"降级\"><a href=\"#降级\" class=\"headerlink\" title=\"降级\"></a>降级</h3><p><strong>不支持</strong>降级操作，即使把之前因为他而升级的元素删除，底层数组还仍然是加入那个元素后的类型</p>\n<h2 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h2><h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li><strong>（1）内存空间连续：</strong>ziplist为了提高存储效率，从存储结构上看ziplist更像是一个表(list)，但不是一个链表(linkedlist)。ziplist将每一项数据存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。而普通的双向链表每一项都占用独立的一块内存，各项之间用指针连接，这样会带来大量内存碎片，而且指针也会占用额外内存。</li>\n<li><strong>（2）查询元素：</strong>查找指定的数据项就会性能变得很低，需要进行遍历整个zipList。</li>\n<li><strong>（3）插入和修改：</strong>每次插入或修改引发的重新分配内存(realloc)操作会有更大的概率造成内存拷贝，从而降低性能。跟list一样，一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据。</li>\n</ul>\n<p>ziplist提高了存储效率，是内存紧缩的列表，多个数据在一起的连续空间，不擅长修改，在两端pop,push快。</p>\n<h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>压缩链表同样具有一定的劣势。压缩链表由于使用的是有一段连续的内存，这就意味着，执行插入操作导致内存大小发生变化时，便会引起一次内存的重新分配过程，同时还会执行一定量的数据移动。特别是对于压缩链表较长的情况下，大批量的数据移动势必会降低系统的性能。而在上述这个方面恰恰就是经典双端链表的优势，故此<em>Redis</em>设计实现了一种快速链表的数据结构，兼具经典双端链表与压缩链表的特点，实现了时间与空间上的一种折衷。</p>\n<p>链表存在一个问题，便是在存储小数据的时候， 内存使用效率过低，例如当一个链表节点中只保存一个字节的<code>unsigned char</code>数据时，我们需要为这个节点保存24个字节的额外数据， 其中包含<code>listNode.prev</code>指针，<code>listNode.next</code>指针，以及指向具体数据的<code>listNode.value</code>指针， 同时对于链表节点所占用内存的反复申请与释放，也容易导致内存碎片的产生。 为了解决经典双端链表在保存小数据而导致内存效率过低的问题，<em>Redis</em>设了一套压缩链表的数据数据结构<em>ziplist</em>来对这种场景下的链表应用进行优化。</p>\n<p>压缩链表允许在链表两端以 <em>O(1)</em> 的时间复杂度执行 <em>Pop</em> 或者 <em>Push</em> 操作，当然这只是一种理想状态下的情况， 由于压缩链表实际上是内存中一段连续分配的内存，因此这些操作需要对压缩链表所使用的内存进行重新分配， 所以其真实的时间复杂度是和链表所使用的内存大小相关的。</p>\n<p>压缩链表与经典双端链表最大的区别在于，双端链表的节点是分散在内存中并不是连续的，压缩链表中所有的数据都是存储在一段连续的内存之中的</p>\n<p>压缩链表是相对于普通链表而言的</p>\n<p>当普通链表的数据越来越多, 链表查询性能会低效</p>\n<p>当存储的数据较少时, 使用链表存储会浪费空间</p>\n<p>压缩链表本质上是一个字符串</p>\n<p>压缩链表内存储的数据只能是 整型, 字符串</p>\n<h3 id=\"具体\"><a href=\"#具体\" class=\"headerlink\" title=\"具体\"></a>具体</h3><ul>\n<li>压缩列表是列表键和哈希键的底层实现之一</li>\n<li>当一个列表键只包含<strong>少量列表项</strong>，并且每个列表项都是<strong>小整数或较短字符串</strong>，则用压缩列表作为底层实现</li>\n<li>压缩列表是为了<strong>节约内存</strong>而开发的，是由一系列特殊编码的连续内存块组成的<strong>顺序型数据结构</strong><ul>\n<li>zlbytes：记录整个压缩列表所占用的内存字节数，在内存重分配或zlend位置时使用</li>\n<li>zltail：记录压缩列表表尾节点距压缩列表的起始地址有多少字节，通过该偏移量，可无须遍历整个压缩列表就可以确定表尾节点的地址</li>\n<li>zllen：记录了压缩列表包含的节点数量</li>\n<li>entryX：压缩列表包含的各个节点，节点长度由节点包含的内容决定</li>\n<li>zlend：特殊值0xFF，用于标记压缩列表的末端</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091430874.png\" alt=\"image-20210207091430874\"></p>\n<h3 id=\"压缩列表节点的构成\"><a href=\"#压缩列表节点的构成\" class=\"headerlink\" title=\"压缩列表节点的构成\"></a>压缩列表节点的构成</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091652786.png\" alt=\"image-20210207091652786\"></p>\n<h4 id=\"previous-entry-length\"><a href=\"#previous-entry-length\" class=\"headerlink\" title=\"previous_entry_length\"></a>previous_entry_length</h4><ul>\n<li>记录压缩列表<strong>前一个节点</strong>的长度</li>\n<li>通过指针运算，根据当前节点的起始地址得到前一个节点的起始地址</li>\n<li>用于从表尾到表头的遍历：指向表尾节点的指针可以通过压缩列表的起始地址的指针加上zltail得到</li>\n</ul>\n<h4 id=\"encoding\"><a href=\"#encoding\" class=\"headerlink\" title=\"encoding\"></a>encoding</h4><p>记录节点的content属性所保存数据的类型及长度</p>\n<h4 id=\"content\"><a href=\"#content\" class=\"headerlink\" title=\"content\"></a>content</h4><p>负责保存节点的值，值的类型和属性由encoding决定</p>\n<h4 id=\"连锁更新\"><a href=\"#连锁更新\" class=\"headerlink\" title=\"连锁更新\"></a>连锁更新</h4><ul>\n<li><p>每个节点的previous_entry_length属性都记录了前一个节点的长度，如果前一节点长度小于254字节，则previous_entry_length属性用1字节空间保存该长度值，否则需要用5字节空间。</p>\n</li>\n<li><p>如果在压缩列表中，有多个介于[250，153]字节的节点[e1，eN]，记录这些节点的长度只需要1字节长的<strong>previous_entry_length</strong>，所以[e1，eN]所有节点的<strong>previous_entry_length</strong>都是1字节长</p>\n</li>\n<li><p>但如果将一个大于254字节的新节点new加入压缩列表的头节点，则new成为e1的前置节点。而这样e1的<strong>previous_entry_length</strong>属性不足以保存new的长度，所以进行空间重分配，变成5字节大小</p>\n</li>\n<li><p>这样e1的长度大于254字节了，e2的<strong>previous_entry_length</strong>也不足以保存e1的长度，也扩展成5字节大小。这样就进行连续多次空间扩展，即连锁更新</p>\n</li>\n<li><p>删除节点也会引发连锁更新</p>\n</li>\n<li><p>连锁更新在最坏情况下需要对压缩列表进行N次空间重分配操作，每次操作最坏O(N)，所以连锁更新最坏时间复杂度为O(N^2)​.</p>\n</li>\n<li><p>但是发生的机率比较低：</p>\n<ul>\n<li>恰好有多个连续的，长度介于250-153字节的节点的情况并不多见 </li>\n<li>即使出现连锁更新，只要被更新的节点数量不多，就不会对性能有影响</li>\n</ul>\n</li>\n<li><p>所以平均复杂度为O(N)</p>\n</li>\n</ul>\n<h2 id=\"快速链表\"><a href=\"#快速链表\" class=\"headerlink\" title=\"快速链表\"></a>快速链表</h2><ul>\n<li>双向链表便于在表的进行插入和删除节点操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li>\n<li>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的内存重新分配(realloc)。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</li>\n</ul>\n<p>可见，一个quicklist节点上的ziplist要保持一个合理的长度</p>\n<p><strong>quicklist将 双向链表插入和修改元素不需要移动节点的优点 和 ziplist的存储效率很高优点(一整块连续内存)结合在一起，同时将各自的缺点进行一个折中的处理。</strong></p>\n<h3 id=\"使用原因\"><a href=\"#使用原因\" class=\"headerlink\" title=\"使用原因\"></a>使用原因</h3><p>链表在早先的 redis 版本中也作为 list 的数据结构使用过，但是单纯的链表的缺陷之前也说了，插入便利，但是空间利用率低，并且不能进行二分查找等，检索效率低，ziplist 压缩表的产生也是同理，希望获得更好的性能，包括存储空间和访问性能等</p>\n<p>作者结合了经典双端链表以及压缩链表的特性，实现了快速链表的数据结构。简单来说，使用双端链表的形式描述整个快速链表，而每一个快速链表的节点都是使用一个压缩链表作为底层数据存储，可以存储若干个数据节点。同时基于链表数据结构通常对头部与尾部的访问最为频繁，而对链表中间的数据访问并不是特别频繁，因此出于节省空间的目的，会对中间节点底层压缩链表所使用的内存进行压缩</p>\n<h3 id=\"理解-1\"><a href=\"#理解-1\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>quicklist 里有 head，tail, quicklistNode里有 prev，next 指针，是不是有链表的基本轮廓了</p>\n<p>关键就在这个<code>unsigned char *zl;</code>zl 是不是前面又看到过，就是 ziplist ，这是什么鬼，</p>\n<p>链表里用压缩表</p>\n<p>回顾下前面说的 ziplist，ziplist 有哪些特点，内存利用率高，可以从表头快速定位到尾节点，节点可以从后往前找，但是有个缺点，就是从中间插入的效率比较低，需要整体往后移，这个其实是普通数组的优化版，但还是有数组的一些劣势，所以要真的快，是不是可以将链表跟数组真的结合起来。</p>\n<p>假如每个快表节点的 ziplist 只放一个元素，那么其实这就退化成了一个链表，如果 10 个元素放在一个 quicklistNode 的 ziplist 里，那就退化成了一个 ziplist</p>\n<p>quickList 是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1294391-20180827151851500-1561398239.png\"></p>\n<h1 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h1><h2 id=\"字符串对象\"><a href=\"#字符串对象\" class=\"headerlink\" title=\"字符串对象\"></a>字符串对象</h2><ol>\n<li>字符串对象的编码可以是int，raw，embstr</li>\n<li>如果字符串对象保存整数值，且可以用long表示，则会将整数值保存在ptr中，enconding设为int</li>\n<li>如果保存字符串值，并且长度大于39字节，就用<code>SDS</code>保存，并且设为raw</li>\n<li>如果保存字符串值，并且长度小于39字节，就用<code>embstr</code>编码保存，并且设为embstr</li>\n</ol>\n<h4 id=\"embstr\"><a href=\"#embstr\" class=\"headerlink\" title=\"embstr\"></a>embstr</h4><p>专门用来保存短字符串的一种优化编码方式，和SDS差不多<br>不同的是，只调用一次内存分配函数来分配一块连续的空间，空间依次包含redisObject，sdshdr两个结构<br>优点：内存分配与释放次数由两次变为一次；字符串所有的数据保存在一块连续的内存中，更好利用缓存</p>\n<h4 id=\"编码的转换\"><a href=\"#编码的转换\" class=\"headerlink\" title=\"编码的转换\"></a>编码的转换</h4><ol>\n<li>int编码的字符串对象如果操作后保存的不再是整数值，而是字符串值，则编码变为raw</li>\n<li>embstr编码的字符串对象只是可读的，对它执行任何修改命令，都会编程raw</li>\n</ol>\n<p><strong>应用</strong></p>\n<ul>\n<li>点赞数量:  incr likes 每操作一 次，就+1，最后可以通过get likes得到最终结果</li>\n<li>将用户信息使用JSON序列化为字符串，将字符串塞进Redis来缓存</li>\n<li>如果value是整数，则可以进行自增操作。用于计数器：可以快速实现计数和查询的功能。</li>\n</ul>\n<h2 id=\"列表对象\"><a href=\"#列表对象\" class=\"headerlink\" title=\"列表对象\"></a>列表对象</h2><p>编码可以是<code>ziplist</code>,<code>linkedlist</code>。ziplist使用压缩列表作为底层实现，linkedlist采用双端链表作为底层实现。每个双端链表节点都保持一个字符串对象（之后使用的是quickList)</p>\n<p>字符串对象是Redis 5种类型的对象中唯一一种会被其他四种对象嵌套的对象</p>\n<h4 id=\"编码转换\"><a href=\"#编码转换\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h4><p>使用ziplist编码的情况：</p>\n<ol>\n<li>列表对象保存的所有字符串元素都小于64字节</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<p><strong>理解</strong></p>\n<ul>\n<li>相当于LinkedList，是链表不是数组，插入删除快，索引定位慢</li>\n<li>元素较少时会使用一块连续内存存储，即ziplist（压缩列表），所有元素彼此紧挨着一起存储</li>\n<li>元素较多时采用快速链表（quicklist），将多个ziplist使用双向指针串起来使用，既满足快速插入删除，又不会出现太大空间冗余</li>\n</ul>\n<p><strong>应用场景</strong></p>\n<ul>\n<li><p>粉丝列表、文章的评论列表</p>\n</li>\n<li><p>通过 lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p>\n</li>\n<li><p>消息队列（异步队列）：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。</p>\n</li>\n</ul>\n<h2 id=\"哈希对象\"><a href=\"#哈希对象\" class=\"headerlink\" title=\"哈希对象\"></a>哈希对象</h2><p>编码可以是ziplist、hashtable。</p>\n<p>用ziplist则将键值对压入列表表尾，键值对紧挨一起，键在前，值在后。类似队列</p>\n<p>hashtable编码用字典作为底层实现，字典的每个键与值都是一个字符串对象</p>\n<h4 id=\"编码转换-1\"><a href=\"#编码转换-1\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h4><p>使用ziplist编码的情况：</p>\n<ol>\n<li>列表对象保存的所有字符串元素都小于64字节</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<p><strong>应用</strong></p>\n<ul>\n<li><p>类似与Map&lt;String，Map&lt;String，String&gt;</p>\n</li>\n<li><p>和HashMap一样采用数组+链表</p>\n</li>\n<li><p>Redis字典的值只能是字符串</p>\n</li>\n<li><p>渐进式rehash策略：在rehash时保留新旧两个hash结构，查询时会同时查询两个hash结构，循序渐进的将旧hash的内容一点点地迁移到新的hash结构中</p>\n</li>\n<li><p>记录帖子的点赞数、评论数、点击数</p>\n</li>\n</ul>\n<h2 id=\"集合对象\"><a href=\"#集合对象\" class=\"headerlink\" title=\"集合对象\"></a>集合对象</h2><p>编码可以是intset、hashtable。</p>\n<p>用intset编码的集合使用整数集合作为底层实现</p>\n<p>用hashtable编码的集合使用字典作为底层实现，每个键是一个字符串对象，而值设为NULL</p>\n<h4 id=\"编码转换-2\"><a href=\"#编码转换-2\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h4><p>使用intset编码的情况：</p>\n<ol>\n<li>列表对象保存的都是整数值</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<p><strong>set</strong></p>\n<ul>\n<li><p>相当于HashSet，键值对是无序的、唯一的。相当于所有value都是NULL的hash</p>\n</li>\n<li><p>统计中奖的用户ID，可以去重</p>\n</li>\n</ul>\n<ul>\n<li>交集运算:微博共同关注 SINTER key1 key2</li>\n<li>朋友圈点赞</li>\n<li>抽奖活动<ul>\n<li>SADD key 添加参与</li>\n<li>SCARD key 查看有几个人参与了抽奖</li>\n<li>SRANDMEMBER key 2 随机抽两个人，不删除</li>\n<li>SPOP key 随机抽取并删除1个人</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"有序集合对象\"><a href=\"#有序集合对象\" class=\"headerlink\" title=\"有序集合对象\"></a>有序集合对象</h2><p>有序集合的编码可以是ziplist、skiplist</p>\n<p>用ziplist编码则每个集合元素使用两个紧挨的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值。集合元素按分值从小到大进行排序</p>\n<h4 id=\"用skiplist编码实现\"><a href=\"#用skiplist编码实现\" class=\"headerlink\" title=\"用skiplist编码实现\"></a>用skiplist编码实现</h4><p>同时包含一个<strong>字典</strong>和<strong>跳跃表</strong></p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> zset\n<span class=\"token punctuation\">{</span>\n    zskiplist <span class=\"token operator\">*</span>zsl<span class=\"token punctuation\">;</span>\n    dict <span class=\"token operator\">*</span> dict<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> zset<span class=\"token punctuation\">;</span></code></pre>\n<p>zset中的zsl跳跃表按分值从小到大保存了所有集合元素</p>\n<p>每个跳跃表节点中：object属性保存元素的成员，score属性保存元素的分值</p>\n<p>此外，dict中，字典的键保存元素的成员，值保存元素的分值，这样，通过字典可以用O(1)的复杂度查找给定成员的分值</p>\n<p>这两种数据结构都会通过指针来共享相同元素的成员和分值，所以使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，不会浪费额外内存</p>\n<p>优点：</p>\n<ul>\n<li>范围操作不需要对字典保存的所有元素进行排序，从O(NlogN)到O(N)</li>\n<li>根据成员查询分值不需要通过跳跃表，复杂度从O(N)降低到O(1)</li>\n</ul>\n<h4 id=\"编码转换-3\"><a href=\"#编码转换-3\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h4><p>使用ziplist编码的情况：</p>\n<ol>\n<li>有序集合保存的所有元素长度都小于64字节</li>\n<li>有序集合保存的元素数量小于128个</li>\n</ol>\n<p><strong>应用</strong></p>\n<ul>\n<li><p>类似于SortedSet和HashMap的结合体，保证了value的唯一性，每个value有score（排序权重）</p>\n</li>\n<li><p>热搜</p>\n</li>\n<li><p>游戏排名</p>\n</li>\n<li><p>排行榜：榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p>\n</li>\n<li><p>微博热搜榜，value是名称，score是热度值</p>\n</li>\n<li><p>粉丝列表，value是粉丝用户ID，score是关注时间</p>\n</li>\n<li><p>学生成绩，value是学生ID，score是考试成绩</p>\n</li>\n</ul>\n<h2 id=\"对象特性\"><a href=\"#对象特性\" class=\"headerlink\" title=\"对象特性\"></a>对象特性</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ol>\n<li>基于之前的数据结构创建一个对象系统。包括字符串对象，列表对象，哈希对象，集合对象，有序集合对象五种</li>\n<li>可以在执行命令之前，根据对象类型判断一个对象能否执行给定的命令</li>\n<li>可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率</li>\n<li>实现基于引用计数的内存回收机制，实现内存共享机制，让多个数据库键共享同一个对象节约内存</li>\n<li>对象带有访问时间记录信息，记录数据库键的空转时间</li>\n</ol>\n<p><strong>理解</strong></p>\n<p>每个键值对都是由对象组成，键总是一个字符串对象，值可以是五种对象中的一种</p>\n<p>如果容器不存在，则先创建一个再进行操作</p>\n<p>如果容器里元素为空，则立刻删除容器，释放内存</p>\n<h3 id=\"对象的类型和编码\"><a href=\"#对象的类型和编码\" class=\"headerlink\" title=\"对象的类型和编码\"></a>对象的类型和编码</h3><p>使用对象来表示数据库的键和值，新创建一个键值对时，会创建两个对象分别代表键和值</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> redisObject\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">unsigned</span> type<span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//类型</span>\n    <span class=\"token keyword\">unsigned</span> encoding<span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//编码</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> ptr<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//指向底层实现数据结构的指针</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><code>type</code>属性记录了对象的类型，即五种对象类型之一<br>对于一个键值对，键总是字符串对象，值可以是五种对象类型之一</p>\n<h4 id=\"编码和底层实现\"><a href=\"#编码和底层实现\" class=\"headerlink\" title=\"编码和底层实现\"></a>编码和底层实现</h4><ol>\n<li>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，即之前学习的几种数据结构</li>\n<li>每种类型的对象都至少使用了两种不同的编码</li>\n<li>通过<code>encoding</code>属性来设定使用的编码，极大地提升了灵活性和效率，可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率</li>\n</ol>\n<h3 id=\"类型检查和命令多态\"><a href=\"#类型检查和命令多态\" class=\"headerlink\" title=\"类型检查和命令多态\"></a>类型检查和命令多态</h3><p>在执行一个类型的特定命令之前，服务器会检查输入数据库键的值对象是否为执行命令所需的指令，如果是，服务器就会对键执行指定的命令。否则将拒绝执行命令，并向客户端返回一个类型错误。</p>\n<p>类型检查是通过<code>redisObject</code>结构的type属性来实现的 </p>\n<h4 id=\"多态命令的实现\"><a href=\"#多态命令的实现\" class=\"headerlink\" title=\"多态命令的实现\"></a>多态命令的实现</h4><p>Redis除了会根据值对象的类型来判断键是否能够执行指定指令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令</p>\n<p>例如，<code>LLEN命令</code>是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行</p>\n<p>DEL，TYPE等命令也是多态命令，无论输入的键是什么类型，这些命令都可以正常执行。区别在于，DEL，TYPE等命令是基于类型的多态，一个命令可以处理多种不同的类型的键，LLen命令是基于编码的多态，一个命令可以同时用于处理多种不同编码</p>\n<h3 id=\"内存回收\"><a href=\"#内存回收\" class=\"headerlink\" title=\"内存回收\"></a>内存回收</h3><p>基于引用计数法实现内存回收机制，通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p>\n<ol>\n<li>创建对象，引用计数值为1</li>\n<li>对象被新程序使用，引用计数值+1</li>\n<li>对象不被一个程序使用，引用计数值-1</li>\n<li>引用计数值为0时，释放对象占用的内存</li>\n</ol>\n<h3 id=\"对象共享\"><a href=\"#对象共享\" class=\"headerlink\" title=\"对象共享\"></a>对象共享</h3><h4 id=\"步骤-1\"><a href=\"#步骤-1\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><p>让多个键共享同一个值对象步骤：</p>\n<ol>\n<li>将数据库键的值指向一个现有的值对象</li>\n<li>将被共享的值对象引用计数值+1</li>\n</ol>\n<h4 id=\"内置整数\"><a href=\"#内置整数\" class=\"headerlink\" title=\"内置整数\"></a>内置整数</h4><p>Redis在初始化服务器时，会创建一万个字符串对象，存储[0,9999]的整数值。如果需要用到这些字符串对象，服务器则会使用这些共享对象，而不会新创建对象。</p>\n<p>这些共享对象不仅仅只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象</p>\n<h4 id=\"为什么不共享包含字符串的对象\"><a href=\"#为什么不共享包含字符串的对象\" class=\"headerlink\" title=\"为什么不共享包含字符串的对象\"></a>为什么不共享包含字符串的对象</h4><p>只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象</p>\n<p>一个共享对象保存的值越复杂，则验证共享对象和目标对象是否相同所需的复杂度越高：</p>\n<ol>\n<li>共享对象是整数值的字符串对象，验证操作为<code>O(1)</code></li>\n<li>共享对象是保存字符串值的字符串对象，验证操作为<code>O(N)</code></li>\n<li>共享对象是包含多个值的对象（如列表），验证操作为<code>O(N^2)</code></li>\n</ol>\n<h3 id=\"对象的空转时间\"><a href=\"#对象的空转时间\" class=\"headerlink\" title=\"对象的空转时间\"></a>对象的空转时间</h3><p><code>redisObject</code>结构包含属性lru,记录了对象最后一次被命令程序访问的时间。可用当前时间-键的值对象的lru时间求得空转时间</p>\n<p>可通过设置，使得当服务器占用的内存数超过了，<code>maxmemory</code>的上限时，空转时间较高的那部分键会优先被服务器释放，从而回收内存</p>\n<h1 id=\"高级数据结构\"><a href=\"#高级数据结构\" class=\"headerlink\" title=\"高级数据结构\"></a>高级数据结构</h1><h2 id=\"位图bitmap\"><a href=\"#位图bitmap\" class=\"headerlink\" title=\"位图bitmap\"></a>位图bitmap</h2><p>位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组</p>\n<p>可以使用get/set 直接获取和设置整个位图的内容，也可以使⽤位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。</p>\n<p>位数组会自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动进行零扩充</p>\n<p><strong>应用场景</strong></p>\n<p>用户签到</p>\n<ul>\n<li>有些bool 型数据需要存取，例如用户⼀年的签到记录，签了是 1，没签是0，要记录 365 天</li>\n<li>位图数据结构让每天的签到记录只占据⼀个位，365 天就是 365个位，46 个字节 (⼀个稍长⼀点的字符串) 就可以完全容纳下</li>\n<li>统计和查找<ul>\n<li>bitcount：统计指定范围内1的个数，可以统计用户一共签到多少天 </li>\n<li>bitpos：用于查找指定范围内出现的第一个0或1，从哪天开始第一次签到</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h2><ul>\n<li><p>提供不精确的去重统计方案，标准误差是0.81%</p>\n</li>\n<li><p>不能知道一个值是否在结构中，即不提供 pfcontains功能</p>\n</li>\n<li><p>pfadd 和 pfcount，⼀个是增加计数，⼀个是获取计数。pfadd codehole user1（将用户ID塞进去）；pfcount codehole</p>\n</li>\n<li><p>pfmerge：用于将多个pf计数值累加在一起形成一个新的pf值，例如两个差不多的页面进行合并，需要将页面的UV访问量也合并</p>\n</li>\n<li><p>场景：UV（Unique Visitor） 需要去重，同⼀个用户⼀天之内的多次访问请求只能计数⼀次。</p>\n</li>\n<li><p>实现：计数较小时使用稀疏矩阵存储，占用空间超过阈值，则转成稠密矩阵</p>\n</li>\n</ul>\n<h2 id=\"Bloom-Filter\"><a href=\"#Bloom-Filter\" class=\"headerlink\" title=\"Bloom Filter\"></a>Bloom Filter</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>布隆过滤器是一个很长的二进制向量和一系列随机映射函数。</p>\n<p>优点是空间效率和查询时间都远远超过⼀般的算法</p>\n<h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>当⼀个元素被加入集合时，通过K个散列函数将这个元素映射成⼀个位数组中的K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（⼤约）知道集合中有没有它了：如 果这些点有任何⼀个0，则被检元素⼀定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p>\n<p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使⽤了k个哈希函数，每个字符串跟k个 bit对应。从⽽降低了冲突的概率。</p>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>是一个很长的二进制向量和一系列随机映射函数</li>\n<li>当⼀个元素被加入集合时，通过K个散列函数将这个元素映射成⼀个位数组中的K 个点，把它们置为1</li>\n<li>exists：把hash的几个位置都算出来，看看位数组在几个位置是否都为1<ul>\n<li>如果这些点有任何⼀个0，则被检元素⼀定不在</li>\n<li>如果都是1，则被检元素很可能在</li>\n</ul>\n</li>\n<li>空间效率和查询时间都远远超过⼀般的算法</li>\n<li>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1</li>\n<li>删除困难。⼀个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>缺点是有⼀定的误识别率和删除困难，bloom filter之所以能做到在时间和空间上的效率⽐较⾼，是因为牺牲了判断的准确率、删除的便利性</p>\n<ul>\n<li>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果 bloom filter中存储的是⿊名单，那么可以通过建⽴⼀个白名单来存储可能会误判的元素。</li>\n<li>删除困难。⼀个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ul>\n<li>在使⽤bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp</li>\n<li>在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的⼤⼩。</li>\n<li>对于⼀个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数 组的⼤⼩m，以及hash函数的个数k，并选择hash函数</li>\n<li>一个好的哈希函数要能近似等概率的将字符串映射到各个 Bit。选择k个不同的哈希函数⽐较麻烦，⼀种简单的⽅法是选择⼀个哈希函数，然后送入k个不同的参数。 </li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//项目要导入guava的maven依赖</span>\n<span class=\"token keyword\">package</span> com<span class=\"token punctuation\">.</span>tongji<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>google<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">.</span>BloomFilter<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>google<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">.</span>Funnels<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 测试布隆过滤器(可用于redis缓存穿透)\n * @author tongji4m3\n */</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestBloomFilter</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> total <span class=\"token operator\">=</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    static &lt;T> BloomFilter&lt;T> create(Funnel&lt;? super T> funnel， long expectedInsertions， double fpp， BloomFilter.Strategy strategy)\n    funnel：数据类型(⼀般是调⽤Funnels⼯具类中的)\n    expectedInsertions：期望插入的值的个数\n    fpp 错误率(默认值为0.03)\n    strategy 哈希算法\n\n    numBits，表示存⼀百万个int类型数字，需要的位数为7298440，700多万位。理论上存⼀百万个\n    数，⼀个int是4字节32位，需要481000000=3200万位。如果使⽤HashMap去存，按HashMap50%的\n    存储效率，需要6400万位。可以看出BloomFilter的存储空间很⼩，只有HashMap的1/10左右\n\n    错误率越⼤，所需空间和时间越⼩，错误率越⼩，所需空间和时间越⼤\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> BloomFilter<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> bloomFilter <span class=\"token operator\">=</span> BloomFilter<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Funnels<span class=\"token punctuation\">.</span><span class=\"token function\">integerFunnel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>， total<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//初始化total条数据到过滤器里</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> total<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            bloomFilter<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//匹配已经再过滤器中的值，看是否有匹配不上的</span>\n        <span class=\"token comment\" spellcheck=\"true\">//没有输出，说明只要放进去的，都能匹配上</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> total<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>bloomFilter<span class=\"token punctuation\">.</span><span class=\"token function\">mightContain</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"有坏人逃脱啦~\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//匹配不在过滤器中的10000个值，有多少匹配出来</span>\n        <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> total<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> total <span class=\"token operator\">+</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bloomFilter<span class=\"token punctuation\">.</span><span class=\"token function\">mightContain</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token operator\">++</span>count<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//误伤数量: 320 错误率是0.03左右</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"误伤数量: \"</span><span class=\"token operator\">+</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h4><p>数据库的id都是1开始然后自增的，那我知道你接⼝是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我⼜去数据库查也没有，⼀个请求这样，100个，1000 个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return⼀个数据为空不就好了嘛。</p>\n<ul>\n<li>海量数据去重</li>\n<li>用于检索一个元素是否在一个集合中</li>\n<li>爬⾍过滤已抓到的url就不再抓，可⽤bloom filter过滤，只会使得爬虫系统错过少量的新页面</li>\n<li>垃圾邮件过滤。Bloom Filter只需要哈希表 1/8到 1/4 的大小</li>\n<li>海量数据去重：不断放入元素到集合中，检索一个元素是否在一个集合中，在则说明重复、推荐去重，即APP会把用户已经看过的内容去掉、能准确过滤掉用户已经看过的内容，那些用户没有看过的新内容，也会过滤掉极小一部分（误判）</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"底层数据结构\"><a href=\"#底层数据结构\" class=\"headerlink\" title=\"底层数据结构\"></a>底层数据结构</h1><h2 id=\"简单动态字符串\"><a href=\"#简单动态字符串\" class=\"headerlink\" title=\"简单动态字符串\"></a>简单动态字符串</h2><h3 id=\"SDS简介\"><a href=\"#SDS简介\" class=\"headerlink\" title=\"SDS简介\"></a>SDS简介</h3><ul>\n<li>使用<strong>简单动态字符串</strong>(simple dynamic string SDS)作为默认字符串</li>\n<li>c字符串只作为字符串字面量，用在无需对字符串值进行修改的地方</li>\n<li>包含字符串值的键值对在底层都是用SDS实现的</li>\n</ul>\n<h3 id=\"SDS的定义\"><a href=\"#SDS的定义\" class=\"headerlink\" title=\"SDS的定义\"></a>SDS的定义</h3><pre><code class=\"c\">struct sdshdr\n{\n    int len;//记录buf数组中已使用字节的数量 为字符串长度\n    int free;//未使用的数量\n    char buf[];//字节数组，用来保存字符串\n}</code></pre>\n<ol>\n<li>buf数组以空字符结尾，且最后的空字符不算在len里面</li>\n<li>该空字符由SDS函数自动完成，对SDS用户透明</li>\n</ol>\n<h3 id=\"SDS与C字符串的区别\"><a href=\"#SDS与C字符串的区别\" class=\"headerlink\" title=\"SDS与C字符串的区别\"></a>SDS与C字符串的区别</h3><h4 id=\"获取字符串长度所需复杂度从O-N-降低到​O-1-​\"><a href=\"#获取字符串长度所需复杂度从O-N-降低到​O-1-​\" class=\"headerlink\" title=\"获取字符串长度所需复杂度从O(N)降低到​O(1)​\"></a>获取字符串长度所需复杂度从O(N)降低到​O(1)​</h4><h4 id=\"杜绝了缓冲区溢出\"><a href=\"#杜绝了缓冲区溢出\" class=\"headerlink\" title=\"杜绝了缓冲区溢出\"></a>杜绝了缓冲区溢出</h4><p>例如c进行字符串拼接，需要假设已经为字符串分配了足够的内存以容纳要拼接的字符串，否则就会溢出。<br><strong>SDS空间分配策略</strong>完全杜绝了发生缓冲区溢出的可能性。当要对SDS进行修改时，会先检查空间是否满足修改所需的要求，如果不满足，则会自动将<strong>SDS的空间扩展</strong>，然后再执行实际的修改操作</p>\n<h4 id=\"减少修改字符串时带来的内存重分配次数\"><a href=\"#减少修改字符串时带来的内存重分配次数\" class=\"headerlink\" title=\"减少修改字符串时带来的内存重分配次数\"></a>减少修改字符串时带来的内存重分配次数</h4><p>C字符串底层实现总是一个N+1个字符长的数组，每次对该数组进行增加或缩短，总要进行一次<strong>内存重分配</strong>操作。如果是增长，则要内存重分配扩展底层数组的空间大小。如果是缩短，则执行操作后，需要内存重分配来释放空间，避免内存泄漏。</p>\n<p>Redis通过<strong>未使用空间</strong>解除了字符串长度和底层数组长度之间的关联</p>\n<h5 id=\"空间预分配\"><a href=\"#空间预分配\" class=\"headerlink\" title=\"空间预分配\"></a>空间预分配</h5><p>用于优化SDS的字符串增长操作，在扩展SDS空间之前，会先检查未使用的空间是否足够，如果足够，则直接使用未使用空间，无需进行内存重分配。</p>\n<p>在对一个SDS进行修改，并且需要对SDS进行空间扩展时，不仅为SDS分配修改所需要的空间，还会分配额外的未使用空间。</p>\n<p>如果修改后 SDS.len &lt; 1MB，程序会分配给和len一样的长度给free</p>\n<p>如果修改后 SDS.len &gt;= 1MB，程序会分配1MB给free</p>\n<h5 id=\"惰性空间释放\"><a href=\"#惰性空间释放\" class=\"headerlink\" title=\"惰性空间释放\"></a>惰性空间释放</h5><p>用于优化SDS字符串缩短操作：不立即回收缩短后多出来的字节，而是用free记录。避免了缩短字符串时所需的内存重分配操作，并且为将来可能的增长提供了优化</p>\n<p>API也让我们在需要时，真正释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费</p>\n<h4 id=\"二进制安全\"><a href=\"#二进制安全\" class=\"headerlink\" title=\"二进制安全\"></a>二进制安全</h4><ol>\n<li>C字符串并且符合特定的编码，并且除字符串的末尾外，不能包含空字符，使得他只能保存文本数据</li>\n<li>Redis以处理二进制的方式处理SDS存放在buf数组的数据，使用len而不是空字符判断字符串是否结束。所以他可以保存<strong>任意格式</strong>的二进制数据。</li>\n</ol>\n<h4 id=\"兼容部分C字符串函数\"><a href=\"#兼容部分C字符串函数\" class=\"headerlink\" title=\"兼容部分C字符串函数\"></a>兼容部分C字符串函数</h4><p>SDS保存数据的末尾总是为空字符，所以让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库’定义的函数</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>被广泛用于实现Redis的各种功能，如列表键，发布与订阅，慢查询，监视器等等</p>\n<h3 id=\"链表和链表节点的实现\"><a href=\"#链表和链表节点的实现\" class=\"headerlink\" title=\"链表和链表节点的实现\"></a>链表和链表节点的实现</h3><pre><code class=\"c\">typedef struct listNode\n{\n    struct listNode * prev;\n    struct listNode * next;\n    void * value;\n}listNode;</code></pre>\n<pre><code class=\"c\">typedef struct list\n{\n    listNode *head;\n    listNode *tail;\n    unsigned long len;\n\n    void *(*dup)(void *ptr);//节点值的复制函数\n    void (*free)(void * ptr);//节点值的释放函数\n    int (*match)(void * ptr，void * key);//节点值的对比函数\n}</code></pre>\n<h3 id=\"特性总结\"><a href=\"#特性总结\" class=\"headerlink\" title=\"特性总结\"></a>特性总结</h3><ul>\n<li>双端、无环、带表头和表尾指针、带链表长度计数器</li>\n<li>多态：可以保存各种不同类型的值</li>\n</ul>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>Redis的数据库底层就是用字典实现的</p>\n<p>字典也是<strong>哈希键</strong>的底层实现之一</p>\n<h3 id=\"字典的实现\"><a href=\"#字典的实现\" class=\"headerlink\" title=\"字典的实现\"></a>字典的实现</h3><p>字典采用哈希表作为底层实现，一个哈希表可以有多个哈希表节点，每个节点保存了一个键值对</p>\n<p>每个字典带有<strong>两个哈希表</strong>，一个平时使用，一个仅仅在rehash时使用</p>\n<h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><pre><code class=\"c\">typedef struct dictht\n{\n    dictEntry ** table;//哈希表数组\n    unsigned long size;\n    unsigned long sizemask;//哈希表大小掩码，用于计算索引值 总=size-1\n    unsigned long used;\n}dictht;</code></pre>\n<p>sizemask和哈希值一起决定一个键应该放到table数组里面的哪个索引上</p>\n<h3 id=\"哈希表节点\"><a href=\"#哈希表节点\" class=\"headerlink\" title=\"哈希表节点\"></a>哈希表节点</h3><pre><code class=\"c\">typedef struct dictEntry\n{\n    void *key;\n    union\n    {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n    struct dictEntry * next; \n}dictEntry;</code></pre>\n<p>值可以是应该指针，或者是应该uint64_t类型的整数，或是一个int64_t整数</p>\n<p>next属性指向另一个哈希表节点的指针，可以将多个哈希值相同的键值对连接在一起，以解决键冲突</p>\n<h3 id=\"字典-1\"><a href=\"#字典-1\" class=\"headerlink\" title=\"字典\"></a>字典</h3><pre><code class=\"c\">typedef struct dict\n{\n    dicType * type;//类型特定函数\n    void * privdata;//私有数据\n    ditcht ht[2];//哈希表\n\n    int rehashidx;//rehash索引，当rehash不再进行时，值为-1\n}dict;</code></pre>\n<ol>\n<li>type，privdata属性是针对不同类型的键值对，为创建多态字典而设置的</li>\n<li>每个dicType结构保存了一簇用于操作特定类型键值对的函数</li>\n<li>privdata属性保存了需要传给那些类型特定函数的可选参数</li>\n<li>ht数组中，每个项都是<strong>ditcht哈希表</strong>，一般只使用ht[0]，ht[1]只会在ht[0]进行rehash时使用</li>\n<li>rehashidx记录rehash目前的进度</li>\n</ol>\n<h3 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h3><p>程序先通过键计算哈希值hash，在计算索引(hash &amp; sizemask)，再根据索引将包含新键值对的哈希表节点放到哈希表数组的指定索引上</p>\n<h3 id=\"解决键冲突\"><a href=\"#解决键冲突\" class=\"headerlink\" title=\"解决键冲突\"></a>解决键冲突</h3><p>用链地址法，多个分配到同一个索引的节点用单向链表连接起来。且用<strong>头插法</strong>，将新节点添加到链表的表头位置 </p>\n<h3 id=\"rehash\"><a href=\"#rehash\" class=\"headerlink\" title=\"rehash\"></a>rehash</h3><h4 id=\"时机\"><a href=\"#时机\" class=\"headerlink\" title=\"时机\"></a>时机</h4><ol>\n<li>若没有在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于1时rehash</li>\n<li>若在执行BGSAVE或BGREWRITEAOF命令，则哈希表负载因子大于等于5时rehash</li>\n<li>load_factor=ht[0].used / ht[0].size</li>\n<li>以上的不同是因为，执行那两个命令时，Redis需要创建当前服务器进程的<strong>子进程</strong>，在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而京可能避免在子进程存在期间进行哈希表的扩展操作，可以避免不必要的内存写入操作，最大限度地节约内存</li>\n<li>当负载因子小于0.1，则自动进行收缩操作</li>\n</ol>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>为字典的ht[1]哈希表分配空间<ul>\n<li>如果是扩展，则ht[1]大小为第一个大于等于 ht[0].used * 2 的2^n​。</li>\n<li>如果是收缩，则是第一个大于等于 ht[0].used 的2^n​。</li>\n</ul>\n</li>\n<li>将保存在ht[0]的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后放到ht[1]的指定位置上</li>\n<li>当ht[0]所有的键值对都迁移到了ht[1]，则将ht[1]设置为ht[0]，并且在ht[1]新建一个空哈希表</li>\n</ol>\n<h3 id=\"渐进式rehash\"><a href=\"#渐进式rehash\" class=\"headerlink\" title=\"渐进式rehash\"></a>渐进式rehash</h3><ol>\n<li>rehash时，服务器不是一次就将ht[0]里面的所有键值对全部rehash到ht[1]。而是分多次，<strong>渐进式</strong>地将ht[0]里面的键值对慢慢地rehash到ht[1]</li>\n<li>在执行操作之外，顺带将键值对rehash到ht[1]中，把rehash键值对所需的计算工作均摊到每次对字典的增删改查操作之中。当rehash工作完成后，将rehashidx属性的值加一。所有的键rehash完毕后，rehashidx设置为-1</li>\n<li>在进行渐进式rehash时，字典<strong>同时</strong>使用ht[0]，ht[1]。所以操作同时在两个哈希表中进行，即如果要查找一个键，会先在ht[0]找，没找到就继续到ht[1]中找</li>\n<li>新添加的键值对直接保存到ht[1]中</li>\n</ol>\n<h2 id=\"跳跃表\"><a href=\"#跳跃表\" class=\"headerlink\" title=\"跳跃表\"></a>跳跃表</h2><h3 id=\"简单记忆\"><a href=\"#简单记忆\" class=\"headerlink\" title=\"简单记忆\"></a>简单记忆</h3><p>跳表具有如下性质：</p>\n<p>(1) 由很多层结构组成</p>\n<p>(2) 每一层都是一个有序的链表</p>\n<p>(3) 最底层(Level 1)的链表包含所有元素</p>\n<p>(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</p>\n<p>(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/151153099856214.jpg\"></p>\n<p>例子：查找元素 117</p>\n<p>(1) 比较 21， 比 21 大，往后面找</p>\n<p>(2) 比较 37,  比 37大，比链表最大值小，从 37 的下面一层开始找</p>\n<p>(3) 比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找</p>\n<p>(4) 比较 85， 比 85 大，从后面找</p>\n<p>(5) 比较 117， 等于 117， 找到了节点。</p>\n<pre><code class=\"c\">/* 如果存在 x, 返回 x 所在的节点， \n * 否则返回 x 的后继节点 */  \nfind(x)   \n{  \n    p = top;  \n    while (1) {  \n        while (p-&gt;next-&gt;key &lt; x)  \n            p = p-&gt;next;  \n        if (p-&gt;down == NULL)   \n            return p-&gt;next;  \n        p = p-&gt;down;  \n    }  \n}  </code></pre>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ul>\n<li>通过在每个节点中维持多个指向其他节点的指针，从而快速访问节点</li>\n<li>查找速度:平均O(log N)，最坏O(N)</li>\n<li>支持顺序性操作</li>\n<li>使用跳跃表作为有序集合键的底层实现之一</li>\n</ul>\n<ul>\n<li><p>因为要进行随机的插入和删除，不便用数组</p>\n</li>\n<li><p>要定位插入位置一般用二分查找</p>\n</li>\n<li><p>层级制，最下面所有元素串起来，每隔几个元素挑选一个代表，再将这几个代表用另外一级指针串起来，然后继续选出二级代表，最后形成金字塔结构</p>\n</li>\n<li><p>插入，先在顶层定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插入进去</p>\n</li>\n<li><p>随机策略，位于L0层概率为1，兼职L1层概率0.5，到L2层0.25，概率逐层降低</p>\n</li>\n</ul>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><ol>\n<li>每一层都是一个有序的链表，最底层(L1)的链表包含<strong>所有元素</strong></li>\n<li>如果一个元素出现在第 n 层的链表中，则它也出现在第 n-1 层</li>\n<li>搜索先从上层搜索，当前面的元素比target大时，则向下一级搜索(即向着更密集的数据找)</li>\n<li>总体来看从左上往右下寻找</li>\n</ol>\n<h3 id=\"查找代码\"><a href=\"#查找代码\" class=\"headerlink\" title=\"查找代码\"></a>查找代码</h3><p>从每个节点的最高层开始寻找，如果该层forward不为null，并且分值小于score，则跳到下一个节点，即x = x-&gt;level[i].forward，然后如果相等，则返回。如果该层的forward不满足，则遍历自己的下一个层级(level[i-1])的位置。综上就是从左往右，从上往下。</p>\n<pre><code class=\"c\">// 通过分值和对象值获取排位信息，以1为起始值\nunsigned long zslGetRank(zskiplist *zsl， double score， robj *o) {\n    zskiplistNode *x;\n    unsigned long rank = 0;\n    int i;\n\n    x = zsl-&gt;header;\n    // 从最高层依次往下\n    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {\n        while (x-&gt;level[i].forward &amp;&amp;\n            (x-&gt;level[i].forward-&gt;score &lt; score ||\n                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;\n                compareStringObjects(x-&gt;level[i].forward-&gt;obj，o) &lt;= 0))) {\n            // 排位增加\n            rank += x-&gt;level[i].span;\n            x = x-&gt;level[i].forward;\n        }\n\n        /* x might be equal to zsl-&gt;header， so test if obj is non-NULL */\n        // 对象和分数值都相等\n        if (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj，o)) {\n            return rank;\n        }\n    }\n    return 0;\n}</code></pre>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><img src=\"https://tongji4m3.oss-cn-beijing.aliyuncs.com/IMG_20200818_102630.jpg\" alt=\"IMG_20200818_102630\"></p>\n<p>level:表中层数最大的节点的层数</p>\n<p>length:节点数量</p>\n<h3 id=\"跳跃表节点\"><a href=\"#跳跃表节点\" class=\"headerlink\" title=\"跳跃表节点\"></a>跳跃表节点</h3><pre><code class=\"c\">typedef struct zskiplistNode\n{\n    struct zskiplistNode * backward;//后退指针\n    double score;//分值\n    robj * obj;//成员对象\n\n    struct zskiplistLevel //层\n    {\n        struct zskiplistNode * forward; //前进指针\n        unsigned int span;//跨度\n    } level[];\n}</code></pre>\n<h4 id=\"层\"><a href=\"#层\" class=\"headerlink\" title=\"层\"></a>层</h4><p>level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，来加快访问其他节点的速度</p>\n<p>感觉幂次规律，随机生成一个[1，32]的值作为level数组的大小，即层的高度</p>\n<h4 id=\"前进指针\"><a href=\"#前进指针\" class=\"headerlink\" title=\"前进指针\"></a>前进指针</h4><p>每个层都有一个指向表尾方向的前进指针(level[i].forward)</p>\n<h4 id=\"跨度\"><a href=\"#跨度\" class=\"headerlink\" title=\"跨度\"></a>跨度</h4><p>记录两个节点之间的距离</p>\n<p>指向NULL的所有前进指针的跨度都为0</p>\n<p>跨度实际是用来计算排位的:在查找某个节点过程中，将沿途访问的所有层的跨度累积起来，得到的结果就是目标节点在跳跃表中的排位(即该节点是第几个节点)</p>\n<h4 id=\"后退指针\"><a href=\"#后退指针\" class=\"headerlink\" title=\"后退指针\"></a>后退指针</h4><p>可以先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点…，直到遇到指向NULL的后退指针</p>\n<h4 id=\"分值和成员\"><a href=\"#分值和成员\" class=\"headerlink\" title=\"分值和成员\"></a>分值和成员</h4><ol>\n<li>分值:跳跃表中所有节点都按分值从小到大排序</li>\n<li>成员对象:指向<strong>SDS字符串</strong>对象的指针</li>\n<li>跳跃表中成员对象必须唯一，但是分值可以相同</li>\n<li>分值相同的节点按照成员变量的字典序排序</li>\n</ol>\n<h3 id=\"跳跃表结构\"><a href=\"#跳跃表结构\" class=\"headerlink\" title=\"跳跃表结构\"></a>跳跃表结构</h3><pre><code class=\"c\">typedef struct zskiplist\n{\n    struct zskiplistNode * header，*tial;\n    unsigned long length;//表中节点的数量\n    int level;//表中层数最大的节点的层数\n} zskiplist;</code></pre>\n<p>使得能O(1)访问表头表尾节点，访问跳跃表长度，获取表中层数最大的节点的层数</p>\n<h2 id=\"整数集合\"><a href=\"#整数集合\" class=\"headerlink\" title=\"整数集合\"></a>整数集合</h2><p>当一个集合只包含整数值元素，并且数量不多时，redis就会采用整数集合作为集合键的底层实现</p>\n<pre><code class=\"c\">typedef strcut intset\n{\n    uint32_t encoding; //编码方式\n    uint32_t length; //元素数量\n    int8_t contents[]; //保存元素的数组\n}</code></pre>\n<p>可以保存类型为 int16_t，int32_t，int64_t的<strong>非重复</strong>整数值，且元素在contents数组中<strong>有序排列</strong></p>\n<h3 id=\"升级\"><a href=\"#升级\" class=\"headerlink\" title=\"升级\"></a>升级</h3><p>每当添加一个新元素到整数集合里面，并且新元素的类型比<strong>现有所有元素类型</strong>都长，需要先对整数集合进行升级，再加入该元素</p>\n<ol>\n<li>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li>\n<li>将底层数组现有的<strong>所有元素转换</strong>成与新元素相同的类型，并且放置到正确位置上，仍需<strong>保证有序性</strong></li>\n<li>将新元素添加到底层数组里</li>\n</ol>\n<p>每次添加新元素都有可能引起升级，而每次升级都需要对底层数组所有元素进行类型转换，所以添加新元素时间复杂度为O(N)</p>\n<h3 id=\"升级的好处\"><a href=\"#升级的好处\" class=\"headerlink\" title=\"升级的好处\"></a>升级的好处</h3><h4 id=\"提升灵活性\"><a href=\"#提升灵活性\" class=\"headerlink\" title=\"提升灵活性\"></a>提升灵活性</h4><p>整数集合可以通过自动升级底层数组来适应新元素，所以可以将 int16_t、int32_t、int64_t随意地添加到集合中，不必担心类型错误</p>\n<h4 id=\"节约内存\"><a href=\"#节约内存\" class=\"headerlink\" title=\"节约内存\"></a>节约内存</h4><p>既可以让集合能<strong>同时保存三种不同类型</strong>的值，又可以确保升级只在必要时进行</p>\n<h3 id=\"降级\"><a href=\"#降级\" class=\"headerlink\" title=\"降级\"></a>降级</h3><p><strong>不支持</strong>降级操作，即使把之前因为他而升级的元素删除，底层数组还仍然是加入那个元素后的类型</p>\n<h2 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h2><h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li><strong>（1）内存空间连续：</strong>ziplist为了提高存储效率，从存储结构上看ziplist更像是一个表(list)，但不是一个链表(linkedlist)。ziplist将每一项数据存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。而普通的双向链表每一项都占用独立的一块内存，各项之间用指针连接，这样会带来大量内存碎片，而且指针也会占用额外内存。</li>\n<li><strong>（2）查询元素：</strong>查找指定的数据项就会性能变得很低，需要进行遍历整个zipList。</li>\n<li><strong>（3）插入和修改：</strong>每次插入或修改引发的重新分配内存(realloc)操作会有更大的概率造成内存拷贝，从而降低性能。跟list一样，一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据。</li>\n</ul>\n<p>ziplist提高了存储效率，是内存紧缩的列表，多个数据在一起的连续空间，不擅长修改，在两端pop,push快。</p>\n<h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>压缩链表同样具有一定的劣势。压缩链表由于使用的是有一段连续的内存，这就意味着，执行插入操作导致内存大小发生变化时，便会引起一次内存的重新分配过程，同时还会执行一定量的数据移动。特别是对于压缩链表较长的情况下，大批量的数据移动势必会降低系统的性能。而在上述这个方面恰恰就是经典双端链表的优势，故此<em>Redis</em>设计实现了一种快速链表的数据结构，兼具经典双端链表与压缩链表的特点，实现了时间与空间上的一种折衷。</p>\n<p>链表存在一个问题，便是在存储小数据的时候， 内存使用效率过低，例如当一个链表节点中只保存一个字节的<code>unsigned char</code>数据时，我们需要为这个节点保存24个字节的额外数据， 其中包含<code>listNode.prev</code>指针，<code>listNode.next</code>指针，以及指向具体数据的<code>listNode.value</code>指针， 同时对于链表节点所占用内存的反复申请与释放，也容易导致内存碎片的产生。 为了解决经典双端链表在保存小数据而导致内存效率过低的问题，<em>Redis</em>设了一套压缩链表的数据数据结构<em>ziplist</em>来对这种场景下的链表应用进行优化。</p>\n<p>压缩链表允许在链表两端以 <em>O(1)</em> 的时间复杂度执行 <em>Pop</em> 或者 <em>Push</em> 操作，当然这只是一种理想状态下的情况， 由于压缩链表实际上是内存中一段连续分配的内存，因此这些操作需要对压缩链表所使用的内存进行重新分配， 所以其真实的时间复杂度是和链表所使用的内存大小相关的。</p>\n<p>压缩链表与经典双端链表最大的区别在于，双端链表的节点是分散在内存中并不是连续的，压缩链表中所有的数据都是存储在一段连续的内存之中的</p>\n<p>压缩链表是相对于普通链表而言的</p>\n<p>当普通链表的数据越来越多, 链表查询性能会低效</p>\n<p>当存储的数据较少时, 使用链表存储会浪费空间</p>\n<p>压缩链表本质上是一个字符串</p>\n<p>压缩链表内存储的数据只能是 整型, 字符串</p>\n<h3 id=\"具体\"><a href=\"#具体\" class=\"headerlink\" title=\"具体\"></a>具体</h3><ul>\n<li>压缩列表是列表键和哈希键的底层实现之一</li>\n<li>当一个列表键只包含<strong>少量列表项</strong>，并且每个列表项都是<strong>小整数或较短字符串</strong>，则用压缩列表作为底层实现</li>\n<li>压缩列表是为了<strong>节约内存</strong>而开发的，是由一系列特殊编码的连续内存块组成的<strong>顺序型数据结构</strong><ul>\n<li>zlbytes：记录整个压缩列表所占用的内存字节数，在内存重分配或zlend位置时使用</li>\n<li>zltail：记录压缩列表表尾节点距压缩列表的起始地址有多少字节，通过该偏移量，可无须遍历整个压缩列表就可以确定表尾节点的地址</li>\n<li>zllen：记录了压缩列表包含的节点数量</li>\n<li>entryX：压缩列表包含的各个节点，节点长度由节点包含的内容决定</li>\n<li>zlend：特殊值0xFF，用于标记压缩列表的末端</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091430874.png\" alt=\"image-20210207091430874\"></p>\n<h3 id=\"压缩列表节点的构成\"><a href=\"#压缩列表节点的构成\" class=\"headerlink\" title=\"压缩列表节点的构成\"></a>压缩列表节点的构成</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207091652786.png\" alt=\"image-20210207091652786\"></p>\n<h4 id=\"previous-entry-length\"><a href=\"#previous-entry-length\" class=\"headerlink\" title=\"previous_entry_length\"></a>previous_entry_length</h4><ul>\n<li>记录压缩列表<strong>前一个节点</strong>的长度</li>\n<li>通过指针运算，根据当前节点的起始地址得到前一个节点的起始地址</li>\n<li>用于从表尾到表头的遍历：指向表尾节点的指针可以通过压缩列表的起始地址的指针加上zltail得到</li>\n</ul>\n<h4 id=\"encoding\"><a href=\"#encoding\" class=\"headerlink\" title=\"encoding\"></a>encoding</h4><p>记录节点的content属性所保存数据的类型及长度</p>\n<h4 id=\"content\"><a href=\"#content\" class=\"headerlink\" title=\"content\"></a>content</h4><p>负责保存节点的值，值的类型和属性由encoding决定</p>\n<h4 id=\"连锁更新\"><a href=\"#连锁更新\" class=\"headerlink\" title=\"连锁更新\"></a>连锁更新</h4><ul>\n<li><p>每个节点的previous_entry_length属性都记录了前一个节点的长度，如果前一节点长度小于254字节，则previous_entry_length属性用1字节空间保存该长度值，否则需要用5字节空间。</p>\n</li>\n<li><p>如果在压缩列表中，有多个介于[250，153]字节的节点[e1，eN]，记录这些节点的长度只需要1字节长的<strong>previous_entry_length</strong>，所以[e1，eN]所有节点的<strong>previous_entry_length</strong>都是1字节长</p>\n</li>\n<li><p>但如果将一个大于254字节的新节点new加入压缩列表的头节点，则new成为e1的前置节点。而这样e1的<strong>previous_entry_length</strong>属性不足以保存new的长度，所以进行空间重分配，变成5字节大小</p>\n</li>\n<li><p>这样e1的长度大于254字节了，e2的<strong>previous_entry_length</strong>也不足以保存e1的长度，也扩展成5字节大小。这样就进行连续多次空间扩展，即连锁更新</p>\n</li>\n<li><p>删除节点也会引发连锁更新</p>\n</li>\n<li><p>连锁更新在最坏情况下需要对压缩列表进行N次空间重分配操作，每次操作最坏O(N)，所以连锁更新最坏时间复杂度为O(N^2)​.</p>\n</li>\n<li><p>但是发生的机率比较低：</p>\n<ul>\n<li>恰好有多个连续的，长度介于250-153字节的节点的情况并不多见 </li>\n<li>即使出现连锁更新，只要被更新的节点数量不多，就不会对性能有影响</li>\n</ul>\n</li>\n<li><p>所以平均复杂度为O(N)</p>\n</li>\n</ul>\n<h2 id=\"快速链表\"><a href=\"#快速链表\" class=\"headerlink\" title=\"快速链表\"></a>快速链表</h2><ul>\n<li>双向链表便于在表的进行插入和删除节点操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li>\n<li>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的内存重新分配(realloc)。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</li>\n</ul>\n<p>可见，一个quicklist节点上的ziplist要保持一个合理的长度</p>\n<p><strong>quicklist将 双向链表插入和修改元素不需要移动节点的优点 和 ziplist的存储效率很高优点(一整块连续内存)结合在一起，同时将各自的缺点进行一个折中的处理。</strong></p>\n<h3 id=\"使用原因\"><a href=\"#使用原因\" class=\"headerlink\" title=\"使用原因\"></a>使用原因</h3><p>链表在早先的 redis 版本中也作为 list 的数据结构使用过，但是单纯的链表的缺陷之前也说了，插入便利，但是空间利用率低，并且不能进行二分查找等，检索效率低，ziplist 压缩表的产生也是同理，希望获得更好的性能，包括存储空间和访问性能等</p>\n<p>作者结合了经典双端链表以及压缩链表的特性，实现了快速链表的数据结构。简单来说，使用双端链表的形式描述整个快速链表，而每一个快速链表的节点都是使用一个压缩链表作为底层数据存储，可以存储若干个数据节点。同时基于链表数据结构通常对头部与尾部的访问最为频繁，而对链表中间的数据访问并不是特别频繁，因此出于节省空间的目的，会对中间节点底层压缩链表所使用的内存进行压缩</p>\n<h3 id=\"理解-1\"><a href=\"#理解-1\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>quicklist 里有 head，tail, quicklistNode里有 prev，next 指针，是不是有链表的基本轮廓了</p>\n<p>关键就在这个<code>unsigned char *zl;</code>zl 是不是前面又看到过，就是 ziplist ，这是什么鬼，</p>\n<p>链表里用压缩表</p>\n<p>回顾下前面说的 ziplist，ziplist 有哪些特点，内存利用率高，可以从表头快速定位到尾节点，节点可以从后往前找，但是有个缺点，就是从中间插入的效率比较低，需要整体往后移，这个其实是普通数组的优化版，但还是有数组的一些劣势，所以要真的快，是不是可以将链表跟数组真的结合起来。</p>\n<p>假如每个快表节点的 ziplist 只放一个元素，那么其实这就退化成了一个链表，如果 10 个元素放在一个 quicklistNode 的 ziplist 里，那就退化成了一个 ziplist</p>\n<p>quickList 是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1294391-20180827151851500-1561398239.png\"></p>\n<h1 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h1><h2 id=\"字符串对象\"><a href=\"#字符串对象\" class=\"headerlink\" title=\"字符串对象\"></a>字符串对象</h2><ol>\n<li>字符串对象的编码可以是int，raw，embstr</li>\n<li>如果字符串对象保存整数值，且可以用long表示，则会将整数值保存在ptr中，enconding设为int</li>\n<li>如果保存字符串值，并且长度大于39字节，就用<code>SDS</code>保存，并且设为raw</li>\n<li>如果保存字符串值，并且长度小于39字节，就用<code>embstr</code>编码保存，并且设为embstr</li>\n</ol>\n<h4 id=\"embstr\"><a href=\"#embstr\" class=\"headerlink\" title=\"embstr\"></a>embstr</h4><p>专门用来保存短字符串的一种优化编码方式，和SDS差不多<br>不同的是，只调用一次内存分配函数来分配一块连续的空间，空间依次包含redisObject，sdshdr两个结构<br>优点：内存分配与释放次数由两次变为一次；字符串所有的数据保存在一块连续的内存中，更好利用缓存</p>\n<h4 id=\"编码的转换\"><a href=\"#编码的转换\" class=\"headerlink\" title=\"编码的转换\"></a>编码的转换</h4><ol>\n<li>int编码的字符串对象如果操作后保存的不再是整数值，而是字符串值，则编码变为raw</li>\n<li>embstr编码的字符串对象只是可读的，对它执行任何修改命令，都会编程raw</li>\n</ol>\n<p><strong>应用</strong></p>\n<ul>\n<li>点赞数量:  incr likes 每操作一 次，就+1，最后可以通过get likes得到最终结果</li>\n<li>将用户信息使用JSON序列化为字符串，将字符串塞进Redis来缓存</li>\n<li>如果value是整数，则可以进行自增操作。用于计数器：可以快速实现计数和查询的功能。</li>\n</ul>\n<h2 id=\"列表对象\"><a href=\"#列表对象\" class=\"headerlink\" title=\"列表对象\"></a>列表对象</h2><p>编码可以是<code>ziplist</code>,<code>linkedlist</code>。ziplist使用压缩列表作为底层实现，linkedlist采用双端链表作为底层实现。每个双端链表节点都保持一个字符串对象（之后使用的是quickList)</p>\n<p>字符串对象是Redis 5种类型的对象中唯一一种会被其他四种对象嵌套的对象</p>\n<h4 id=\"编码转换\"><a href=\"#编码转换\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h4><p>使用ziplist编码的情况：</p>\n<ol>\n<li>列表对象保存的所有字符串元素都小于64字节</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<p><strong>理解</strong></p>\n<ul>\n<li>相当于LinkedList，是链表不是数组，插入删除快，索引定位慢</li>\n<li>元素较少时会使用一块连续内存存储，即ziplist（压缩列表），所有元素彼此紧挨着一起存储</li>\n<li>元素较多时采用快速链表（quicklist），将多个ziplist使用双向指针串起来使用，既满足快速插入删除，又不会出现太大空间冗余</li>\n</ul>\n<p><strong>应用场景</strong></p>\n<ul>\n<li><p>粉丝列表、文章的评论列表</p>\n</li>\n<li><p>通过 lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p>\n</li>\n<li><p>消息队列（异步队列）：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。</p>\n</li>\n</ul>\n<h2 id=\"哈希对象\"><a href=\"#哈希对象\" class=\"headerlink\" title=\"哈希对象\"></a>哈希对象</h2><p>编码可以是ziplist、hashtable。</p>\n<p>用ziplist则将键值对压入列表表尾，键值对紧挨一起，键在前，值在后。类似队列</p>\n<p>hashtable编码用字典作为底层实现，字典的每个键与值都是一个字符串对象</p>\n<h4 id=\"编码转换-1\"><a href=\"#编码转换-1\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h4><p>使用ziplist编码的情况：</p>\n<ol>\n<li>列表对象保存的所有字符串元素都小于64字节</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<p><strong>应用</strong></p>\n<ul>\n<li><p>类似与Map&lt;String，Map&lt;String，String&gt;</p>\n</li>\n<li><p>和HashMap一样采用数组+链表</p>\n</li>\n<li><p>Redis字典的值只能是字符串</p>\n</li>\n<li><p>渐进式rehash策略：在rehash时保留新旧两个hash结构，查询时会同时查询两个hash结构，循序渐进的将旧hash的内容一点点地迁移到新的hash结构中</p>\n</li>\n<li><p>记录帖子的点赞数、评论数、点击数</p>\n</li>\n</ul>\n<h2 id=\"集合对象\"><a href=\"#集合对象\" class=\"headerlink\" title=\"集合对象\"></a>集合对象</h2><p>编码可以是intset、hashtable。</p>\n<p>用intset编码的集合使用整数集合作为底层实现</p>\n<p>用hashtable编码的集合使用字典作为底层实现，每个键是一个字符串对象，而值设为NULL</p>\n<h4 id=\"编码转换-2\"><a href=\"#编码转换-2\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h4><p>使用intset编码的情况：</p>\n<ol>\n<li>列表对象保存的都是整数值</li>\n<li>列表保存的元素数量小于512</li>\n</ol>\n<p><strong>set</strong></p>\n<ul>\n<li><p>相当于HashSet，键值对是无序的、唯一的。相当于所有value都是NULL的hash</p>\n</li>\n<li><p>统计中奖的用户ID，可以去重</p>\n</li>\n</ul>\n<ul>\n<li>交集运算:微博共同关注 SINTER key1 key2</li>\n<li>朋友圈点赞</li>\n<li>抽奖活动<ul>\n<li>SADD key 添加参与</li>\n<li>SCARD key 查看有几个人参与了抽奖</li>\n<li>SRANDMEMBER key 2 随机抽两个人，不删除</li>\n<li>SPOP key 随机抽取并删除1个人</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"有序集合对象\"><a href=\"#有序集合对象\" class=\"headerlink\" title=\"有序集合对象\"></a>有序集合对象</h2><p>有序集合的编码可以是ziplist、skiplist</p>\n<p>用ziplist编码则每个集合元素使用两个紧挨的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值。集合元素按分值从小到大进行排序</p>\n<h4 id=\"用skiplist编码实现\"><a href=\"#用skiplist编码实现\" class=\"headerlink\" title=\"用skiplist编码实现\"></a>用skiplist编码实现</h4><p>同时包含一个<strong>字典</strong>和<strong>跳跃表</strong></p>\n<pre><code class=\"c\">typedef struct zset\n{\n    zskiplist *zsl;\n    dict * dict;\n} zset;</code></pre>\n<p>zset中的zsl跳跃表按分值从小到大保存了所有集合元素</p>\n<p>每个跳跃表节点中：object属性保存元素的成员，score属性保存元素的分值</p>\n<p>此外，dict中，字典的键保存元素的成员，值保存元素的分值，这样，通过字典可以用O(1)的复杂度查找给定成员的分值</p>\n<p>这两种数据结构都会通过指针来共享相同元素的成员和分值，所以使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，不会浪费额外内存</p>\n<p>优点：</p>\n<ul>\n<li>范围操作不需要对字典保存的所有元素进行排序，从O(NlogN)到O(N)</li>\n<li>根据成员查询分值不需要通过跳跃表，复杂度从O(N)降低到O(1)</li>\n</ul>\n<h4 id=\"编码转换-3\"><a href=\"#编码转换-3\" class=\"headerlink\" title=\"编码转换\"></a>编码转换</h4><p>使用ziplist编码的情况：</p>\n<ol>\n<li>有序集合保存的所有元素长度都小于64字节</li>\n<li>有序集合保存的元素数量小于128个</li>\n</ol>\n<p><strong>应用</strong></p>\n<ul>\n<li><p>类似于SortedSet和HashMap的结合体，保证了value的唯一性，每个value有score（排序权重）</p>\n</li>\n<li><p>热搜</p>\n</li>\n<li><p>游戏排名</p>\n</li>\n<li><p>排行榜：榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p>\n</li>\n<li><p>微博热搜榜，value是名称，score是热度值</p>\n</li>\n<li><p>粉丝列表，value是粉丝用户ID，score是关注时间</p>\n</li>\n<li><p>学生成绩，value是学生ID，score是考试成绩</p>\n</li>\n</ul>\n<h2 id=\"对象特性\"><a href=\"#对象特性\" class=\"headerlink\" title=\"对象特性\"></a>对象特性</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ol>\n<li>基于之前的数据结构创建一个对象系统。包括字符串对象，列表对象，哈希对象，集合对象，有序集合对象五种</li>\n<li>可以在执行命令之前，根据对象类型判断一个对象能否执行给定的命令</li>\n<li>可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率</li>\n<li>实现基于引用计数的内存回收机制，实现内存共享机制，让多个数据库键共享同一个对象节约内存</li>\n<li>对象带有访问时间记录信息，记录数据库键的空转时间</li>\n</ol>\n<p><strong>理解</strong></p>\n<p>每个键值对都是由对象组成，键总是一个字符串对象，值可以是五种对象中的一种</p>\n<p>如果容器不存在，则先创建一个再进行操作</p>\n<p>如果容器里元素为空，则立刻删除容器，释放内存</p>\n<h3 id=\"对象的类型和编码\"><a href=\"#对象的类型和编码\" class=\"headerlink\" title=\"对象的类型和编码\"></a>对象的类型和编码</h3><p>使用对象来表示数据库的键和值，新创建一个键值对时，会创建两个对象分别代表键和值</p>\n<pre><code class=\"c\">typedef struct redisObject\n{\n    unsigned type:4;//类型\n    unsigned encoding:4;//编码\n    void * ptr;//指向底层实现数据结构的指针\n}</code></pre>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><code>type</code>属性记录了对象的类型，即五种对象类型之一<br>对于一个键值对，键总是字符串对象，值可以是五种对象类型之一</p>\n<h4 id=\"编码和底层实现\"><a href=\"#编码和底层实现\" class=\"headerlink\" title=\"编码和底层实现\"></a>编码和底层实现</h4><ol>\n<li>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，即之前学习的几种数据结构</li>\n<li>每种类型的对象都至少使用了两种不同的编码</li>\n<li>通过<code>encoding</code>属性来设定使用的编码，极大地提升了灵活性和效率，可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率</li>\n</ol>\n<h3 id=\"类型检查和命令多态\"><a href=\"#类型检查和命令多态\" class=\"headerlink\" title=\"类型检查和命令多态\"></a>类型检查和命令多态</h3><p>在执行一个类型的特定命令之前，服务器会检查输入数据库键的值对象是否为执行命令所需的指令，如果是，服务器就会对键执行指定的命令。否则将拒绝执行命令，并向客户端返回一个类型错误。</p>\n<p>类型检查是通过<code>redisObject</code>结构的type属性来实现的 </p>\n<h4 id=\"多态命令的实现\"><a href=\"#多态命令的实现\" class=\"headerlink\" title=\"多态命令的实现\"></a>多态命令的实现</h4><p>Redis除了会根据值对象的类型来判断键是否能够执行指定指令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令</p>\n<p>例如，<code>LLEN命令</code>是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行</p>\n<p>DEL，TYPE等命令也是多态命令，无论输入的键是什么类型，这些命令都可以正常执行。区别在于，DEL，TYPE等命令是基于类型的多态，一个命令可以处理多种不同的类型的键，LLen命令是基于编码的多态，一个命令可以同时用于处理多种不同编码</p>\n<h3 id=\"内存回收\"><a href=\"#内存回收\" class=\"headerlink\" title=\"内存回收\"></a>内存回收</h3><p>基于引用计数法实现内存回收机制，通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p>\n<ol>\n<li>创建对象，引用计数值为1</li>\n<li>对象被新程序使用，引用计数值+1</li>\n<li>对象不被一个程序使用，引用计数值-1</li>\n<li>引用计数值为0时，释放对象占用的内存</li>\n</ol>\n<h3 id=\"对象共享\"><a href=\"#对象共享\" class=\"headerlink\" title=\"对象共享\"></a>对象共享</h3><h4 id=\"步骤-1\"><a href=\"#步骤-1\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><p>让多个键共享同一个值对象步骤：</p>\n<ol>\n<li>将数据库键的值指向一个现有的值对象</li>\n<li>将被共享的值对象引用计数值+1</li>\n</ol>\n<h4 id=\"内置整数\"><a href=\"#内置整数\" class=\"headerlink\" title=\"内置整数\"></a>内置整数</h4><p>Redis在初始化服务器时，会创建一万个字符串对象，存储[0,9999]的整数值。如果需要用到这些字符串对象，服务器则会使用这些共享对象，而不会新创建对象。</p>\n<p>这些共享对象不仅仅只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象</p>\n<h4 id=\"为什么不共享包含字符串的对象\"><a href=\"#为什么不共享包含字符串的对象\" class=\"headerlink\" title=\"为什么不共享包含字符串的对象\"></a>为什么不共享包含字符串的对象</h4><p>只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象</p>\n<p>一个共享对象保存的值越复杂，则验证共享对象和目标对象是否相同所需的复杂度越高：</p>\n<ol>\n<li>共享对象是整数值的字符串对象，验证操作为<code>O(1)</code></li>\n<li>共享对象是保存字符串值的字符串对象，验证操作为<code>O(N)</code></li>\n<li>共享对象是包含多个值的对象（如列表），验证操作为<code>O(N^2)</code></li>\n</ol>\n<h3 id=\"对象的空转时间\"><a href=\"#对象的空转时间\" class=\"headerlink\" title=\"对象的空转时间\"></a>对象的空转时间</h3><p><code>redisObject</code>结构包含属性lru,记录了对象最后一次被命令程序访问的时间。可用当前时间-键的值对象的lru时间求得空转时间</p>\n<p>可通过设置，使得当服务器占用的内存数超过了，<code>maxmemory</code>的上限时，空转时间较高的那部分键会优先被服务器释放，从而回收内存</p>\n<h1 id=\"高级数据结构\"><a href=\"#高级数据结构\" class=\"headerlink\" title=\"高级数据结构\"></a>高级数据结构</h1><h2 id=\"位图bitmap\"><a href=\"#位图bitmap\" class=\"headerlink\" title=\"位图bitmap\"></a>位图bitmap</h2><p>位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组</p>\n<p>可以使用get/set 直接获取和设置整个位图的内容，也可以使⽤位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。</p>\n<p>位数组会自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动进行零扩充</p>\n<p><strong>应用场景</strong></p>\n<p>用户签到</p>\n<ul>\n<li>有些bool 型数据需要存取，例如用户⼀年的签到记录，签了是 1，没签是0，要记录 365 天</li>\n<li>位图数据结构让每天的签到记录只占据⼀个位，365 天就是 365个位，46 个字节 (⼀个稍长⼀点的字符串) 就可以完全容纳下</li>\n<li>统计和查找<ul>\n<li>bitcount：统计指定范围内1的个数，可以统计用户一共签到多少天 </li>\n<li>bitpos：用于查找指定范围内出现的第一个0或1，从哪天开始第一次签到</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h2><ul>\n<li><p>提供不精确的去重统计方案，标准误差是0.81%</p>\n</li>\n<li><p>不能知道一个值是否在结构中，即不提供 pfcontains功能</p>\n</li>\n<li><p>pfadd 和 pfcount，⼀个是增加计数，⼀个是获取计数。pfadd codehole user1（将用户ID塞进去）；pfcount codehole</p>\n</li>\n<li><p>pfmerge：用于将多个pf计数值累加在一起形成一个新的pf值，例如两个差不多的页面进行合并，需要将页面的UV访问量也合并</p>\n</li>\n<li><p>场景：UV（Unique Visitor） 需要去重，同⼀个用户⼀天之内的多次访问请求只能计数⼀次。</p>\n</li>\n<li><p>实现：计数较小时使用稀疏矩阵存储，占用空间超过阈值，则转成稠密矩阵</p>\n</li>\n</ul>\n<h2 id=\"Bloom-Filter\"><a href=\"#Bloom-Filter\" class=\"headerlink\" title=\"Bloom Filter\"></a>Bloom Filter</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>布隆过滤器是一个很长的二进制向量和一系列随机映射函数。</p>\n<p>优点是空间效率和查询时间都远远超过⼀般的算法</p>\n<h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>当⼀个元素被加入集合时，通过K个散列函数将这个元素映射成⼀个位数组中的K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（⼤约）知道集合中有没有它了：如 果这些点有任何⼀个0，则被检元素⼀定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p>\n<p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使⽤了k个哈希函数，每个字符串跟k个 bit对应。从⽽降低了冲突的概率。</p>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>是一个很长的二进制向量和一系列随机映射函数</li>\n<li>当⼀个元素被加入集合时，通过K个散列函数将这个元素映射成⼀个位数组中的K 个点，把它们置为1</li>\n<li>exists：把hash的几个位置都算出来，看看位数组在几个位置是否都为1<ul>\n<li>如果这些点有任何⼀个0，则被检元素⼀定不在</li>\n<li>如果都是1，则被检元素很可能在</li>\n</ul>\n</li>\n<li>空间效率和查询时间都远远超过⼀般的算法</li>\n<li>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1</li>\n<li>删除困难。⼀个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>缺点是有⼀定的误识别率和删除困难，bloom filter之所以能做到在时间和空间上的效率⽐较⾼，是因为牺牲了判断的准确率、删除的便利性</p>\n<ul>\n<li>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果 bloom filter中存储的是⿊名单，那么可以通过建⽴⼀个白名单来存储可能会误判的元素。</li>\n<li>删除困难。⼀个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ul>\n<li>在使⽤bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp</li>\n<li>在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的⼤⼩。</li>\n<li>对于⼀个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数 组的⼤⼩m，以及hash函数的个数k，并选择hash函数</li>\n<li>一个好的哈希函数要能近似等概率的将字符串映射到各个 Bit。选择k个不同的哈希函数⽐较麻烦，⼀种简单的⽅法是选择⼀个哈希函数，然后送入k个不同的参数。 </li>\n</ul>\n<pre><code class=\"java\">//项目要导入guava的maven依赖\npackage com.tongji;\n\n\nimport com.google.common.hash.BloomFilter;\nimport com.google.common.hash.Funnels;\n\n/**\n * 测试布隆过滤器(可用于redis缓存穿透)\n * @author tongji4m3\n */\n\npublic class TestBloomFilter {\n    private static int total = 1000000;\n    /*\n    static &lt;T&gt; BloomFilter&lt;T&gt; create(Funnel&lt;? super T&gt; funnel， long expectedInsertions， double fpp， BloomFilter.Strategy strategy)\n    funnel：数据类型(⼀般是调⽤Funnels⼯具类中的)\n    expectedInsertions：期望插入的值的个数\n    fpp 错误率(默认值为0.03)\n    strategy 哈希算法\n\n    numBits，表示存⼀百万个int类型数字，需要的位数为7298440，700多万位。理论上存⼀百万个\n    数，⼀个int是4字节32位，需要481000000=3200万位。如果使⽤HashMap去存，按HashMap50%的\n    存储效率，需要6400万位。可以看出BloomFilter的存储空间很⼩，只有HashMap的1/10左右\n\n    错误率越⼤，所需空间和时间越⼩，错误率越⼩，所需空间和时间越⼤\n     */\n    private static BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel()， total);\n\n    public static void main(String[] args) {\n        //初始化total条数据到过滤器里\n        for (int i = 0; i &lt; total; i++) {\n            bloomFilter.put(i);\n        }\n        //匹配已经再过滤器中的值，看是否有匹配不上的\n        //没有输出，说明只要放进去的，都能匹配上\n        for (int i = 0; i &lt; total; i++) {\n            if (!bloomFilter.mightContain(i)) {\n                System.out.println(&quot;有坏人逃脱啦~&quot;);\n            }\n        }\n\n        //匹配不在过滤器中的10000个值，有多少匹配出来\n        int count = 0;\n        for (int i = total; i &lt; total + 10000; i++) {\n            if (bloomFilter.mightContain(i)) {\n                ++count;\n            }\n        }\n        //误伤数量: 320 错误率是0.03左右\n        System.out.println(&quot;误伤数量: &quot;+count);\n    }\n}</code></pre>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h4><p>数据库的id都是1开始然后自增的，那我知道你接⼝是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我⼜去数据库查也没有，⼀个请求这样，100个，1000 个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return⼀个数据为空不就好了嘛。</p>\n<ul>\n<li>海量数据去重</li>\n<li>用于检索一个元素是否在一个集合中</li>\n<li>爬⾍过滤已抓到的url就不再抓，可⽤bloom filter过滤，只会使得爬虫系统错过少量的新页面</li>\n<li>垃圾邮件过滤。Bloom Filter只需要哈希表 1/8到 1/4 的大小</li>\n<li>海量数据去重：不断放入元素到集合中，检索一个元素是否在一个集合中，在则说明重复、推荐去重，即APP会把用户已经看过的内容去掉、能准确过滤掉用户已经看过的内容，那些用户没有看过的新内容，也会过滤掉极小一部分（误判）</li>\n</ul>\n"},{"title":"Redis设计机制","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"包括缓存（缓存穿透、缓存击穿、缓存雪崩）、过期键删除策略、RDB/AOF持久化等。","abbrlink":"83265645","date":"2020-11-13T16:00:00.000Z","_content":"\n\n\n# Redis简介\n\n它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。\n\n命令不区分大小写，而key区分大小写\n\nRedis所有的数据结构都以唯一的key字符串作为名称，不同类型的数据结构的差异就在于value的结构不一样\n\n所有数据结构都可以设置过期时间\n\n## 基本认识\n\n### 官方介绍\n\nRemote Dictionary Service(远程词典服务)，是一个存储中间件\n\nRedis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。\n\nRedis是一个开源的内存中的数据结构存储系统，它可以用作：**数据库、缓存和消息中间件**。\n\n它支持多种类型的数据结构，如字符串（Strings），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。**其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。**\n\nRedis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。\n\nRedis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。\n\n### Redis为什么快\n\n- redis是基于内存的，数据存在内存中，内存的读写速度非常快；它类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；\n- 数据结构简单，对数据操作也简单，有高效的数据结构。底层多种数据结构支持不同的数据类型，支持 Redis 存储不同的数据\n- 采用单线程，避免了不必要的上下文切换和竞争条件，不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；\n- redis使用I/O多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在IO上浪费一点时间。\n\n## Redis和memcached的区别\n\n+ Redis 支持复杂的数据结构，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作\n+ Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务\n+ 性能方面，Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Remcached，还是稍有逊色。\n+ Redis ⽀持持久化，所以 Redis 不仅仅可以⽤作缓存，也可以⽤作 NoSQL 数据库。\n\n## 为什么Redis是单线程的\n\n这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行\n\n 单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。\n\n 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间\n\n**1.官方答案**\n\n因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。\n\n**2.性能指标**\n\n关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。\n\n**3.详细原因**\n\n**1）不需要各种锁的性能消耗**\n\nRedis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除\n\n一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。\n\n总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。\n\n**2）单线程多进程集群方案**\n\n单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。\n\n**所以单线程、多进程的集群不失为一个时髦的解决方案。**\n\n**3）CPU消耗**\n\n采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。\n\n但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？\n\n可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。\n\n## Redis单线程的优劣势\n\n**单进程单线程优势**\n\n1. 代码更清晰，处理逻辑更简单\n2. 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗\n3. 不存在多进程或者多线程导致的切换而消耗CPU\n\n**单进程单线程弊端**\n\n1. 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；\n\n## 为什么快\n\nRedis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而  **I/O 多路复用** 就是为了解决这个问题而出现的。\n\nredis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。\n\n+ 优先选择时间复杂度为O(1)的IO复用函数作为底层实现，例如epoll\n+ 以select系统调用为保底，时间复杂度O(N)\n+ 基于react设计模式监听IO事件\n\n多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。\n\n**这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。\n\n## 数据库\n\n### 服务器中的数据库\n\n```c\nstruct redisServer\n{\n\tint dbnum;//服务器的数据库数量\n\tredisDb *db; //一个数组，保存着服务器中的所有数据库 默认16\n}\n```\n\n### 切换数据库\n\n每个Redis客户端都有个目标数据库，每当客户端执行数据库读写命令时，目标数据库就成为这些命令的操作对象.默认目标数据库为0号数据库\n\n```c\ntypedef struct redisClient\n{\n\tredisDb * db;//记录客户端当前使用的数据库\n}redisClient;\n```\n\n### 数据库键空间\n\n```c\ntypedef struct redisDb\n{\n\tdict *dict;//数据库键空间，保存着数据库中的所有键值对\n} redisDb;\n```\n\n键空间的键是一个字符串对象，值可以是字符串对象，列表对象，哈希表对象，集合对象，有序集合对象\n\n所有针对数据库的操作，都是通过对键空间字典进行操作实现的\n\n#### 添加新键\n\n就是将新键值对添加到键空间字典里面\n\n#### 读写键空间时的维护操作\n\n+ 在读取一个键后(读写操作都要对键进行读取)，服务器会根据键是否存在来更新服务器的键空间命中次数\n+ 在读取一个键后，会更新LRU时间，可以计算键的闲置时间\n+ 在读取一个键若发现该键已过期，则会先删除过期键\n+ 在对被监视的键进行修改后，会标记为脏，让事务程序注意该键已经被修改\n\n# 缓存\n\n## 缓存穿透\n\n查询某个Key对应的数据，Redis缓存中没有相应的数据，则直接到数据库中查询。数据库中也不存在要查询的数据，则数据库会返回空，而Redis也不会缓存这个空结果。这就造成每次通过这样的Key去查询数据都会直接到数据库中查询，Redis不会缓存空结果。这就造成了缓存穿透的问题。\n\n一些恶意的请求会故意查询不存在的 key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。\n\n### 解决\n\n1. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。\n2. 如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。\n3. 根据明显错误的key在逻辑层就就行验证。\n4. 分析用户行为，是否为故意请求或者爬虫、攻击者。针对用户访问做限制。\n\n## 缓存击穿\n\n缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。\n\n缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，好像蛮力击穿一样。\n\n击穿和穿透不同，穿透的意思是想法绕过redis去使得数据库崩掉。而击穿你可以理解为正面刚击穿，这种通常为大量并发对一个key进行大规模的读写操作。**这个key在缓存失效期间大量请求数据库**，对数据库造成太大压力使得数据库崩掉。就比如在秒杀场景下10000块钱的mac和100块的mac这个100块的那个订单肯定会被抢到爆，不断的请求(当然具体秒杀有自己处理方式这里只是举个例子)。所以缓存击穿就是针对某个常用key大量请求导致数据库崩溃。\n\n### 解决\n\n#### 使用互斥锁\n\n在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。\n\n在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。\n\n```java\npublic String get(key) {\n      String value = redis.get(key);\n      if (value == null) \n      { \n          //代表缓存值过期\n          //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db\n\t\t  if (redis.setnx(key_mutex， 1， 3 * 60) == 1) \n          {  \n              //代表设置成功\n              value = db.get(key);\n              redis.set(key， value， expire_secs);\n              redis.del(key_mutex);\n          } \n          else \n          {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可\n              sleep(50);\n              get(key);  //重试\n          }\n      } \n    else \n    {\n        return value;      \n    }\n }\n```\n\n#### 热点key永不过期\n\n## 缓存雪崩\n\n大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。\n\n### 解决\n\n- 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。\n- 做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期\n- 可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。\n- 热点数据可以考虑不失效\n\n# 过期键删除策略\n\n## 过期键实现\n\n### 设置过期时间\n\n1. EXPIRE 设置过期时间，单位为秒\n2. PEXPIRE 设置过期时间，单位为毫秒\n3. EXPIREAT 设置过期时间为秒数时间戳\n4. PEXPIREAT 设置过期时间为毫秒数时间戳\n\n最后都是转换为PEXPIREAT来执行的\n\n### 保存过期时间\n\n```c\ntypedef struct redisDb\n{\n\tdict *dict;//数据库键空间，保存着数据库中的所有键值对\n\tdict *expires;//保存了数据库中所有键的过期时间，过期字典\n\t//key是一个指针，指向键空间某个键\n\t//value为long long类型的过期时间，一个毫秒精度的UNIX时间戳\n} redisDb;\n```\n\n键空间的键和过期字典的键都指向同一个键对象，不会出现任何重复对象，也不会浪费任何空间\n\n```python\ndef PEXPIREAT(key，expire_time_in_ms)\n{\n \t#如果给定的键不存在键空间，那么不能设置过期时间\n    if key not in redisDb.dict:\n    \treturn 0\n    #在过期字典中关联键和过期时间\n    redisDb.expires[key] = expire_time_in_ms\n    # 过期时间设置成功\n    return 1\n}\n```\n\n### 移除过期时间\n\n```python\ndef PERSIST(key):\n    #如果给定的键不存在或没设置过期时间，那么直接返回\n     if key not in redisDb.expires:\n    \treturn 0\n    #移除过期字典中给定键的键值对关联\n    redisDb.expires.remove(key)\n    #移除成功\n    return 1\n```\n\n### 计算并返回剩余生存时间\n\n```python\ndef PTTL(key):\n    #如果给定的键不存在数据库\n    if key not in redisDb.dict:\n    \treturn -2\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n    \n    if expire_time_in_ms is None:\n        return -1\n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n    return (expire_time_in_ms - now_ms)\n```\n\n```python\ndef TTL(key):\n    ttl_in_ms = PTTL(key)\n    if ttl_in_ms<0:\n        //处理为-2，-1的异常情况\n        return ttl_in_ms\n    else:\n        #将毫秒转为秒\n        return ms_to_sec(ttl_in_ms)\n    \n```\n\n### 过期键的判断\n\n```python\ndef is_expired(key):\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n    \n    if expire_time_in_ms is None:\n        return False\n    \n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n    \n    if  now_ms>expire_time_in_ms:\n        return True # 已过期\n    else:\n        return False\n```\n\n## 定时删除\n\n- 在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作\n\n- 可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存\n\n- 对CPU时间最不友好，在内存不紧张而CPU非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，对服务器的响应时间和吞吐量造成影响\n\n- 不太现实\n\n\n## 惰性删除\n\n- 每次取出键都会检查是否过期，过期则删除\n\n- 只有在取出键时才会对键进行过期检查，对CPU时间最友好\n\n- 对内存最不友好：如果一个键已过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。\n\n- 会导致内存泄漏，无用的垃圾数据占用了大量内存。如日志，当不再使用时，会大量积压在数据库，用户以为自动删除了，其实还存在，则它们不会被删除，所占用的内存就不会释放。\n\n\n## 定期删除\n\n- 每隔一段时间进行检查，删除里面的过期键\n- 通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响；定期删除策略有效减少了因为过期键而带来的内存浪费。是前两种的整合与折中。\n- 必须合理地设置删除操作的执行时间和执行效率：太频繁或执行时间太长会退化为定时删除策略，反之则出现浪费内存的情况\n\n\n## Redis过期键删除策略\n\n配合使用**惰性删除**和**定期删除**两种\n\n### 惰性删除策略的实现\n\n所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查，如果输入键已过期，则将输入键从数据库中删除\n\n采用expireIfNeeded函数，如果过期则将键删除。就像过滤器，在命令真正执行前，过滤掉过期的输入键，避免命令接触到过期键\n\n所以每个命令的实现函数必须能同时处理键存在和不存在两种情况\n\n![image-20210207104150550](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104150550.png)\n\n![image-20210207104206293](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104206293.png)\n\n### 定期删除策略实现\n\n每当Redis服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键\n\n```python\n# coding=utf-8\n# 默认每次检查的数据库数量\nDEFAULT_DB_NUMBERS = 16\n\n# 默认每个数据库检查的键数量\nDEFAULT_KEY_NUMBERS = 20\n\n# 全局变量，记录检查进度\n# 如果当前的activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数时，将从11号数据库开始查找并删除过期键\ncurrent_db = 0\n\n# 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键\ndef activeExpireCycle():\n    # 初始化要检查的数据库数量\n    # 以服务器的数据库数量为主\n    if serer.dbnum < DEFAULT_DB_NUMBERS:\n        db_numbers = serer.dbnum\n    else:\n        db_numbers = DEFAULT_DB_NUMBERS\n\n    #遍历每个数据库\n    for i in range(db_numbers):\n        #如果current_db=服务器的数据库数量\n        #则表示已经遍历了服务器的所有数据库一次\n        #将current_db=重置为0，开始新一轮\n        if current_db==server.dbnum:\n            current_db=0\n        \n        #获取当前要处理的数据库\n        redisDb=server.db[current_db]\n        \n        #指向下一个要处理的数据库\n        current_db+=1\n        \n        #检查数据库的键\n        for j in range(DEFAULT_KEY_NUMBERS):\n            #如果数据库中没有一个键带有过期时间，则跳过该数据库\n            if redisDb.expires.size()==0:\n                break\n            \n            #随机获取一个带过期时间的键\n            key_with_ttl=redisDb.expires.get_random_key()\n            \n            if is_expired(key_with_ttl):\n                delete_key(key_with_ttl)\n                \n            # 已到达时间上限，停止处理\n            if reach_time_limit():\n                return \n```\n\n# 持久化\n\n## RDB持久化\n\n### 创建\n\n**SAVE指令**会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，所以当Save命令正在执行时，客户端发送的所有命令请求都会被阻塞\n\n**BGSAVE命令**会派生出一个子进程，由它负责创建RDB文件，服务器进程(父进程)继续处理命令请求。\n\n\n\n1、在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝。服务器禁止SAVE与BGSAVE同时执行是为了避免父进程和子进程同时指向两个rdbSave调用，防止产生竞争条件。\n\n2、同样的道理，在BGSAVE执行期间，客户端的BGSAVE命令也会被服务器拒绝。\n\n3、另外，对于AOF持久化命令BGREWRITEAOF与BGSAVE也同样是互斥关系，如果BGSAVE正在执行，则BGREWRITEAOF命令会被延迟到BGSAVE执行完毕之后；而BGREWRITEAOF命令执行时，服务器会拒绝BGSAVE命令的执行。\n\n4、而事实上，因为BGREWRITEAOF命令与BGSAVE两个命令的实际工作都是由子进程执行，所以这两个命令在操作方面并没有冲突的地方，不能同时执行只是性能方面的考虑--并发处两个子进程，并且这两个子进程同时对磁盘进行大量读写。\n\n```python\ndef SAVE():\n\t#创建RDB文件\n\trdbSave（）\n\t\ndef BGSAVE():\n\t# 创建子进程\n\tpid=fork()\n\t\n\tif pid == 0:\n\t\t# 子进程负责创建RDB文件\n\t\trdbSave（）\n\t\t# 完成之后向父进程发送信号\n\t\tsignal_parent()\n\telif pid>0:\n\t\t# 父进程继续处理命令请求，并通过轮询等待子进程的信号\n\t\thandle_request_and_wait_signal()\n\telse:\n\t\t# 处理出错情况\n\t\thandle_fork_error()\n```\n\n### 载入\n\n- RDB文件的载入工作是服务器启动时自动进行的，只要Redis服务器在启动时检测到RDB文件存在，就会自动载入RDB文件\n- 如果服务器开启了AOF持久化功能，则优先使用AOF文件还原数据库状态\n- 只有未开启AOF持久化功能，才会使用RDB文件还原数据库状态\n- 服务器在载入RDB文件时会一直处于阻塞状态，直到载入工作完成\n\n### 自动间隔性保存\n\n服务器每隔一段时间自动执行一次BGSAVE命令，可以设置多个保存条件，只要任意一个条件被满足，服务器就会执行BGSAVE指令\n\n```c\nsave 900 1\nsave 300 10\nsave 60 10000\n\n服务器在900秒内进行了至少1次修改\n服务器在300秒内进行了至少10次修改\n服务器在60秒内进行了至少10000次修改\n```\n\n### 设置保存条件\n\n服务器程序根据save选项（可通过配置文件设置）所设置的保存条件，设置服务器状态的redisServer结构的saveparams属性\n\n```c\nstruct redisServer\n{\n\tstruct saveparam * saveparams;\n\tlong long dirty; //距离上一次成功执行BGSAVE之后，进行修改的次数\n\ttime_t lastsave; //上一次成功执行BGSAVE的时间\n};\n\nstruct saveparam\n{\n\ttime_t seconds;\n\tint changes;\n}\n```\n\n### 检查保存条件是否满足\n\n服务器周期性操作函数serverCron()默认每隔100ms执行一次\n\n其中一项工作就是检查save选项所设置的保存条件是否已经满足\n\n如果满足，则执行BGSAVE（）\n\n```python\ndef serverCron():\n\t# 遍历所有保存条件\n\tfor saveparam in server.saveparams:\n\t\tsave_interval=unixtime_now() - server.lastsave\n\t\t\n\t\t#如果数据库状态的修改次数超过条件所设置的次数\n\t\t#并且距离上次保存的时间超过条件所设置的时间\n\t\t#那么执行保存操作\n\t\tif server.dirty >= saveparam.changes and save_interval>saveparam.seconds:\n\t\t\tBGSAVE()\n```\n\n### RDB文件结构\n\n#### 概览\n\n1. REDIS，通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否是RDB文件\n2. db_version，记录了版本号\n3. databases，包含任意个数据库以及他们的键值对数据。\n4. EOF，标志着RDB文件正文内容的结束\n5. check_sum，校验和，检查RDB文件是否有出错或损坏的情况。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum进行比对，已发行RDB文件是否损坏\n\n#### databases\n\n每个非空数据库保存三部分：\n\n1. SELECTDB 常量，说明接下来会读取一个数据库号码\n2. db_number，读入后，调用SELECT指令，进行数据库切换，使得之后读入的键值对可以载入到正确的数据库之中\n3. key_value_pairs，保存了数据库中的所有键值对数据。包含过期时间。\n\n#### key_value_pairs\n\n1. TYPE记录了value的类型，代表了一种对象类型或底层编码。程序根据TYPE的值决定如何读入和解释value的数据\n2. key总是一个字符串对象\n3. value根据TYPE的指令保存相应类型的内容\n4. EXPIRETIME_MS常量，代表之后会读取一个以毫秒为单位的过期时间\n5. ms，保存键值对的过期时间，以毫秒为单位的UNIX时间戳\n\n\n\n## AOF持久化\n\n### 简介\n\n- AOF（Append Only File)\n- 通过保存`Redis`服务器所执行的写命令来记录数据库状态的\n- 被写入AOF文件的所有命令都是以Redis的命令请求协议格式（纯文本）保存的。\n- 服务器启动时，可以通过载入和执行`AOF文件`中保存的命令来还原服务器关闭之前的数据库状态\n\n\n### AOF持久化的实现\n\n#### 命令追加\n\n服务器在执行完一个写命令后，会将被执行的写命令追加到服务器状态的`aof_buf`缓冲区的末尾:\n\n```c\nstruct redisServer\n{\n\t// AOF缓冲区\n\tsds aof_buf;\n}\n```\n\n#### AOF文件的写入与同步\n\n服务器进程是一个事件循环，循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。时间事件负责执行像serverCron函数这样需要定时运行的函数\n\n```python\ndef eventLoop()\n{\n\twhile True:\n\t\t#处理文件事件，接收命令请求以及发送命令回复\n\t\t#处理命令请求时可能会有新内容加入到aof_buf缓冲区中\n\t\tprocessFileEvents()\n\t\t\n\t\t#处理时间事件\n\t\tprocessTimeEvents()\n\t\t\n\t\t#考虑是否要将aof_buf缓冲区中的内容写入和保存到AOF文件里面\n\t\tflushAppendOnlyFile()\n}\n```\n\n**写入**：在现代操作系统中，当数据写入到文件中时，会调用write函数。操作系统会将写入数据暂时保存在一个内存缓存区中，等到缓冲区空间满的时候，才真正将缓冲区中的数据写入到磁盘中。\n\n**同步**：同时系统也提供了同步函数（例如fsync)，它可以强制让操作系统立即将缓冲区中的数据写入到磁盘中。\n\n\n\n在每个事件循环都会调用flushAppendOnlyFile函数，flushAppendOnlyFile函数的行为由**appendfsync**的值决定：\n\n**always**：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中，并同步AOF文件（把aof_buf数据写入并同步到AOF文件中）\n\n**everysec**：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，并且每隔一秒就在子线程中对AOF文件进行一次同步(每隔一秒同步)。\n\n**no**：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，至于什么时候同步，由操作系统控制（不知道啥时候同步）。在该模式下的flushAppendOnlyFile的调用不需要同步执行。\n\n\n\n上述配置的值，直接决定服务器的效率与安全性，当always时，安全性最高，但是效率最低；no时效率最高，安全性最低；everysec居中：从效率上来讲，everysec模式足够快，并且就算出现了故障停机，数据库也只丢失一秒钟的命令数据。系统默认配置是everysec。\n\n### AOF文件的载入与数据还原\n\n只要读入并重新执行一遍`AOF文件`里面保存的写命令，就可以还原服务器关闭之前的数据库状态\n\n1. 创建一个不带网络连接的伪客户端\n2. 从AOF文件中分析并读取出一条写命令\n3. 使用伪客户端执行被读出的写命令\n4. 一直执行2，3直到AOF文件中的所有写命令都被处理完毕\n\n![image-20210207113554356](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207113554356.png)\n\n### AOF重写\n\n为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。\n\n服务器创建一个新的AOF文件来**替代**现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但是新的AOF文件不会包含任何浪费空间的冗余命令\n\n### AOF文件重写的实现\n\n不需要对现有的AOF文件进行操作，是通过读取服务器当前的数据库状态来实现的\n\n首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。\n\n```python\ndef aof_rewrite(new_aof_file_name):\n\t#创建新的aof文件\n\tf=create_file(new_aof_file_name)\n\t#遍历数据库\n\tfor db in redisServer.db:\n\t\t#忽略空数据库\n\t\tif db.is_empty():continue\n\t\t\n\t\t#写入SELECT命令，指定数据库号码\n\t\tf.write_command(\"SELECT\"+db.id)\n\t\t\n\t\t#遍历数据库中所有键\n\t\tfor key in db:\n\t\t\t#忽略过期的键\n\t\t\tif key.is_expired():continue\n\t\t\t\n\t\t\t#根据键的类型对键进行重写\n\t\t\tif key.type == String:\n\t\t\t\trewrite_string(key)\n\t\t\telif key.type == List:\n\t\t\t\trewrite_list(key)\n\t\t\telif key.type == Hash:\n\t\t\t\trewrite_hash(key)\n            elif key.type == Set:\n\t\t\t\trewrite_set(key)\n            elif key.type == SortedSet:\n\t\t\t\trewrite_sortedSet(key)\n\t\t\t\t\n\t\t\t# 如果键带有过期时间，过期时间也要重写\n\t\t\tif key.have_expired_time():\n\t\t\t\trewrite_expired_time(key)\n\t#写入完毕，关闭文件\t\t\t\n\tf.close()\n\t\ndef rewrite_string(key):\n\t#使用GET命令获取字符串的值\n\tvalue=GET(key)\n\t#使用SET命令重写字符串键\n\tf.write_command(SET，key，value)\n\t\ndef rewrite_expired_time(key):\n\t#获取毫秒精度的键过期时间戳\n\ttimestamp=get_expired_time_in_unixstamp(key)\n\t#使用PEXPIREAT命令重写键的过期时间\n\tf.write_command(PEXPIREAT，key，timestamp)\n```\n\n\n\n### AOF后台重写\n\n因为aof_rewrite函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞\n\n因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求。\n\n所以决定将AOF重写程序放到**子进程**中执行\n\n+ 子进程在进行AOF重写期间，服务器进程可以进行处理命令请求\n+ 子进程带有服务器进程的**数据副本**，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性\n\n但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库**状态不一致**\n\n\n\n#### AOF重写缓冲区\n\n为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，会同时将这个命令发送给**AOF缓冲区和AOF重写缓冲区**\n\n![image-20210207114138147](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207114138147.png)\n\n在子进程执行AOF重写期间，服务器进程执行:\n\n1. 执行客户端发来的指令\n2. 将执行后的写命令追加到AOF缓冲区\n3. 将执行后的写命令追加到AOF重写缓冲区\n\n\n\n这样一来可以**保证**\n\n- AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。\n- 从创建子进程开始，服务器执行的所有写命都会被记录到AOF重写缓冲区里面。\n\n\n\n当子进程完成AOF重写工作之后，它  会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：\n\n- 将AOF重写缓冲区中的所有内容重写到新AOF文件中，这时新AOF文件保存的数据库状态将**和服务器当前的数据库状态一致**。\n- 对新的AOF文件进行改名，原子地(atomic)覆盖现有地AOF文件，完成**新旧两个AOF文件地替换**。\n\n这个信号处理函数执行完毕后，父进程可以继续像往常一样接收命令请求了\n\n\n\n在整个AOF后台重写过程中，只有**信号处理函数执行时会对服务器进程（父进程）造成阻塞**，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。\n\n# 分布式锁\n\n## 理解\n\n在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。\n\n一个应用往往会部署在多台机器上（多节点），在某些场景中，多个进程必须以互斥的方式独占共享资源。因此需要使用分布式锁\n\n\n\n分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源，一般来说，分布式锁需要满足的特性有这么几点：\n\n1、互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；\n\n2、高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；\n\n3、防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；\n\n4、独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了；\n\n## setnx（set if not exists)\n\n```\nSETNX key value\n```\n\nSET if Not eXists(如果不存在，则 SET)\n\n命令在设置成功时返回 1 ，设置失败时返回 0 。\n\n用来实现Redis锁机制，一个进程进来占坑，用完后再调用del指令释放坑\n\n只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作。\n\n**中间代码异常**\n\n如果逻辑执行到中间出现异常，可能导致del指令没有被调用，就会陷入死锁，锁永远得不到释放\n\n可以再拿到锁以后再给锁加上一个过期时间，比如5s，这样即使中间出现异常也可以保证5s后锁会自动释放\n\n```redis\nsetnx tongji4m3 true\n\nexpire tongji4m3 5\n\ndel tongji4m3\n```\n\n**expire异常**\n\n如果在setnx和expire之间服务器出现问题，导致expire得不到执行，也会死锁\n\n根源在于setnx和expire不是一条原子指令，但又不能用事务解决，因为expire依赖与setnx的执行结果，如果setnx没抢到锁，expire是不应该执行的，而事务没有if-else分支逻辑\n\nRedis支持set指令的扩展参数，使得setnx和expire指令可以一起执行，形成原子指令\n\n```\nSETEX key seconds value\n\nSET key value [EX seconds] [PX milliseconds] [NX|XX]\nset tongji4m3 true ex 5 nx\nNX:只在键不存在时， 才对键进行设置操作。\nXX:只在键已经存在时， 才对键进行设置操作。\n```\n\n将值 `value` 关联到 `key` ，并将 `key` 的生存时间设为 `seconds` (以秒为单位)。\n\n如果 `key` 已经存在，`setex`命令将覆写旧值。\n\n有小伙伴肯定会疑惑万一set value 成功 set time失败，那不就傻了么，这啊Redis官网想到了。\n\n`setex`是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成。\n\n单机加锁或synchronized就够了\n\n但如果线程挂了,那锁就一直在那无法得到释放，后面的线程也永远得不到锁，又死锁了。\n\nsetex设置一个过期时间，就算线程1挂了，也会在失效时间到了，自动释放。\n\n**超时问题**\n\n如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，会导致第一个线程持有的锁过期了而临界区的逻辑还没执行完\n\nRedis分布式锁不能用于较长时间的任务\n\n将set指令的value参数设置为随机数，释放锁时先匹配随机数是否一致，然后再删除key，确保当前线程持有的锁不会被其他线程释放，除非这个锁是因为过期了而被服务器自己释放的\n\n但是匹配value和删除key不是一个原子操作，需要要Lua脚本处理，他保证多个指令的原子性执行\n\n**可重入性**\n\n线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，就是可重入锁\n\n分布式锁要支持可重入，则要使用线程的Threadlocal变量存储当前持有锁的计数\n\n### 怎么释放锁\n\n释放锁的命令就简单了，直接删除key就行，但我们前面说了，因为分布式锁必须由锁的持有者自己释放，所以我们必须先确保当前释放锁的线程是持有者，没问题了再删除，这样一来，就变成两个步骤了，似乎又违背了原子性了，怎么办呢？\n\n不慌，我们可以用lua脚本把两步操作做拼装\n\n## redisson\n\nredisson的锁，就实现了可重入\n\n```java\nThreadPoolExecutor threadPoolExecutor =\n        new ThreadPoolExecutor(inventory, inventory, 10L, SECONDS, linkedBlockingQueue);\nlong start = System.currentTimeMillis();\nConfig config = new Config();\nconfig.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\nfinal RedissonClient client = Redisson.create(config);\nfinal RLock lock = client.getLock(\"lock1\");\n\nfor (int i = 0; i <= NUM; i++) {\n    threadPoolExecutor.execute(new Runnable() {\n        public void run() {\n            lock.lock();\n            inventory--;\n            System.out.println(inventory);\n            lock.unlock();\n        }\n    });\n}\nlong end = System.currentTimeMillis();\nSystem.out.println(\"执行线程数:\" + NUM + \"   总耗时:\" + (end - start) + \"  库存数为:\" + inventory);\n```\n\n\n### 初始化\n\n```java\npublic RLock getLock(String name) {\n    return new RedissonLock(connectionManager.getCommandExecutor(), name);\n}\n\npublic RedissonLock(CommandAsyncExecutor commandExecutor, String name) {\n    super(commandExecutor, name);\n    //命令执行器\n    this.commandExecutor = commandExecutor;\n    //UUID字符串\n    this.id = commandExecutor.getConnectionManager().getId();\n    //内部锁过期时间\n    this.internalLockLeaseTime = commandExecutor.\n                getConnectionManager().getCfg().getLockWatchdogTimeout();\n    this.entryName = id + \":\" + name;\n```\n\n### 加锁\n\n```java\npublic void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException {\n    \n    //当前线程ID\n    long threadId = Thread.currentThread().getId();\n    //尝试获取锁\n    Long ttl = tryAcquire(leaseTime, unit, threadId);\n    // 如果ttl为空，则证明获取锁成功\n    if (ttl == null) {\n        return;\n    }\n    //如果获取锁失败，则订阅到对应这个锁的channel\n    RFuture<RedissonLockEntry> future = subscribe(threadId);\n    commandExecutor.syncSubscription(future);\n\n    try {\n        while (true) {\n            //再次尝试获取锁\n            ttl = tryAcquire(leaseTime, unit, threadId);\n            //ttl为空，说明成功获取锁，返回\n            if (ttl == null) {\n                break;\n            }\n            //ttl大于0 则等待ttl时间后继续尝试获取\n            if (ttl >= 0) {\n                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);\n            } else {\n                getEntry(threadId).getLatch().acquire();\n            }\n        }\n    } finally {\n        //取消对channel的订阅\n        unsubscribe(future, threadId);\n    }\n    //get(lockAsync(leaseTime, unit));\n}\n```\n\n### 获取锁\n\n```java\nprivate <T> RFuture<Long> tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) {\n\n    //如果带有过期时间，则按照普通方式获取锁\n    if (leaseTime != -1) {\n        return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);\n    }\n    \n    //先按照30秒的过期时间来执行获取锁的方法\n    RFuture<Long> ttlRemainingFuture = tryLockInnerAsync(\n        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),\n        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);\n        \n    //如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间\n    ttlRemainingFuture.addListener(new FutureListener<Long>() {\n        @Override\n        public void operationComplete(Future<Long> future) throws Exception {\n            if (!future.isSuccess()) {\n                return;\n            }\n\n            Long ttlRemaining = future.getNow();\n            // lock acquired\n            if (ttlRemaining == null) {\n                scheduleExpirationRenewal(threadId);\n            }\n        }\n    });\n    return ttlRemainingFuture;\n}\n```\n\n### 底层加锁逻辑\n\n你可能会想这么多操作，在一起不是原子性不还是有问题么？\n\n大佬们肯定想得到呀，所以还是LUA，他使用了Hash的数据结构。\n\n主要是判断锁是否存在，存在就设置过期时间，如果锁已经存在了，那对比一下线程，线程是一个那就证明可以重入，锁在了，但是不是当前线程，证明别人还没释放，那就把剩余时间返回，加锁失败。\n\n```java\n<T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit,     \n                            long threadId, RedisStrictCommand<T> command) {\n\n        //过期时间\n        internalLockLeaseTime = unit.toMillis(leaseTime);\n\n        return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,\n                  //如果锁不存在，则通过hset设置它的值，并设置过期时间\n                  \"if (redis.call('exists', KEYS[1]) == 0) then \" +\n                      \"redis.call('hset', KEYS[1], ARGV[2], 1); \" +\n                      \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n                      \"return nil; \" +\n                  \"end; \" +\n                  //如果锁已存在，并且锁的是当前线程，则通过hincrby给数值递增1\n                  \"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \" +\n                      \"redis.call('hincrby', KEYS[1], ARGV[2], 1); \" +\n                      \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n                      \"return nil; \" +\n                  \"end; \" +\n                  //如果锁已存在，但并非本线程，则返回过期时间ttl\n                  \"return redis.call('pttl', KEYS[1]);\",\n        Collections.<Object>singletonList(getName()), \n                internalLockLeaseTime, getLockName(threadId));\n    }\n```\n\n\n\n### 解锁\n\n锁的释放主要是publish释放锁的信息，然后做校验，一样会判断是否当前线程，成功就释放锁，还有个**hincrby**递减的操作，锁的值大于0说明是可重入锁，那就刷新过期时间。\n\n如果值小于0了，那删掉Key释放锁。\n\n是不是又和AQS很像了？\n\nAQS就是通过一个volatile修饰status去看锁的状态，也会看数值判断是否是可重入的。\n\n\n\n```java\npublic RFuture<Void> unlockAsync(final long threadId) {\n    final RPromise<Void> result = new RedissonPromise<Void>();\n    \n    //解锁方法\n    RFuture<Boolean> future = unlockInnerAsync(threadId);\n\n    future.addListener(new FutureListener<Boolean>() {\n        @Override\n        public void operationComplete(Future<Boolean> future) throws Exception {\n            if (!future.isSuccess()) {\n                cancelExpirationRenewal(threadId);\n                result.tryFailure(future.cause());\n                return;\n            }\n            //获取返回值\n            Boolean opStatus = future.getNow();\n            //如果返回空，则证明解锁的线程和当前锁不是同一个线程，抛出异常\n            if (opStatus == null) {\n                IllegalMonitorStateException cause = \n                    new IllegalMonitorStateException(\"\n                        attempt to unlock lock, not locked by current thread by node id: \"\n                        + id + \" thread-id: \" + threadId);\n                result.tryFailure(cause);\n                return;\n            }\n            //解锁成功，取消刷新过期时间的那个定时任务\n            if (opStatus) {\n                cancelExpirationRenewal(null);\n            }\n            result.trySuccess(null);\n        }\n    });\n\n    return result;\n}\n\n\nprotected RFuture<Boolean> unlockInnerAsync(long threadId) {\n    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, EVAL,\n    \n            //如果锁已经不存在， 发布锁释放的消息\n            \"if (redis.call('exists', KEYS[1]) == 0) then \" +\n                \"redis.call('publish', KEYS[2], ARGV[1]); \" +\n                \"return 1; \" +\n            \"end;\" +\n            //如果释放锁的线程和已存在锁的线程不是同一个线程，返回null\n            \"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then \" +\n                \"return nil;\" +\n            \"end; \" +\n            //通过hincrby递减1的方式，释放一次锁\n            //若剩余次数大于0 ，则刷新过期时间\n            \"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); \" +\n            \"if (counter > 0) then \" +\n                \"redis.call('pexpire', KEYS[1], ARGV[2]); \" +\n                \"return 0; \" +\n            //否则证明锁已经释放，删除key并发布锁释放的消息\n            \"else \" +\n                \"redis.call('del', KEYS[1]); \" +\n                \"redis.call('publish', KEYS[2], ARGV[1]); \" +\n                \"return 1; \"+\n            \"end; \" +\n            \"return nil;\",\n    Arrays.<Object>asList(getName(), getChannelName()), \n        LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));\n\n}\n```\n\n","source":"_posts/数据库/Redis数据库/2.Redis设计机制.md","raw":"---\ntitle: Redis设计机制\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 包括缓存（缓存穿透、缓存击穿、缓存雪崩）、过期键删除策略、RDB/AOF持久化等。\ncategories: Redis\ntags:\n  - 缓存\n  - 持久化\n  - 删除策略\nabbrlink: '83265645'\ndate: 2020-11-14 00:00:00\n---\n\n\n\n# Redis简介\n\n它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。\n\n命令不区分大小写，而key区分大小写\n\nRedis所有的数据结构都以唯一的key字符串作为名称，不同类型的数据结构的差异就在于value的结构不一样\n\n所有数据结构都可以设置过期时间\n\n## 基本认识\n\n### 官方介绍\n\nRemote Dictionary Service(远程词典服务)，是一个存储中间件\n\nRedis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。\n\nRedis是一个开源的内存中的数据结构存储系统，它可以用作：**数据库、缓存和消息中间件**。\n\n它支持多种类型的数据结构，如字符串（Strings），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。**其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。**\n\nRedis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。\n\nRedis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。\n\n### Redis为什么快\n\n- redis是基于内存的，数据存在内存中，内存的读写速度非常快；它类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；\n- 数据结构简单，对数据操作也简单，有高效的数据结构。底层多种数据结构支持不同的数据类型，支持 Redis 存储不同的数据\n- 采用单线程，避免了不必要的上下文切换和竞争条件，不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；\n- redis使用I/O多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在IO上浪费一点时间。\n\n## Redis和memcached的区别\n\n+ Redis 支持复杂的数据结构，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作\n+ Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务\n+ 性能方面，Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Remcached，还是稍有逊色。\n+ Redis ⽀持持久化，所以 Redis 不仅仅可以⽤作缓存，也可以⽤作 NoSQL 数据库。\n\n## 为什么Redis是单线程的\n\n这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行\n\n 单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。\n\n 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间\n\n**1.官方答案**\n\n因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。\n\n**2.性能指标**\n\n关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。\n\n**3.详细原因**\n\n**1）不需要各种锁的性能消耗**\n\nRedis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除\n\n一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。\n\n总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。\n\n**2）单线程多进程集群方案**\n\n单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。\n\n**所以单线程、多进程的集群不失为一个时髦的解决方案。**\n\n**3）CPU消耗**\n\n采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。\n\n但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？\n\n可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。\n\n## Redis单线程的优劣势\n\n**单进程单线程优势**\n\n1. 代码更清晰，处理逻辑更简单\n2. 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗\n3. 不存在多进程或者多线程导致的切换而消耗CPU\n\n**单进程单线程弊端**\n\n1. 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；\n\n## 为什么快\n\nRedis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而  **I/O 多路复用** 就是为了解决这个问题而出现的。\n\nredis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。\n\n+ 优先选择时间复杂度为O(1)的IO复用函数作为底层实现，例如epoll\n+ 以select系统调用为保底，时间复杂度O(N)\n+ 基于react设计模式监听IO事件\n\n多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。\n\n**这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。\n\n## 数据库\n\n### 服务器中的数据库\n\n```c\nstruct redisServer\n{\n\tint dbnum;//服务器的数据库数量\n\tredisDb *db; //一个数组，保存着服务器中的所有数据库 默认16\n}\n```\n\n### 切换数据库\n\n每个Redis客户端都有个目标数据库，每当客户端执行数据库读写命令时，目标数据库就成为这些命令的操作对象.默认目标数据库为0号数据库\n\n```c\ntypedef struct redisClient\n{\n\tredisDb * db;//记录客户端当前使用的数据库\n}redisClient;\n```\n\n### 数据库键空间\n\n```c\ntypedef struct redisDb\n{\n\tdict *dict;//数据库键空间，保存着数据库中的所有键值对\n} redisDb;\n```\n\n键空间的键是一个字符串对象，值可以是字符串对象，列表对象，哈希表对象，集合对象，有序集合对象\n\n所有针对数据库的操作，都是通过对键空间字典进行操作实现的\n\n#### 添加新键\n\n就是将新键值对添加到键空间字典里面\n\n#### 读写键空间时的维护操作\n\n+ 在读取一个键后(读写操作都要对键进行读取)，服务器会根据键是否存在来更新服务器的键空间命中次数\n+ 在读取一个键后，会更新LRU时间，可以计算键的闲置时间\n+ 在读取一个键若发现该键已过期，则会先删除过期键\n+ 在对被监视的键进行修改后，会标记为脏，让事务程序注意该键已经被修改\n\n# 缓存\n\n## 缓存穿透\n\n查询某个Key对应的数据，Redis缓存中没有相应的数据，则直接到数据库中查询。数据库中也不存在要查询的数据，则数据库会返回空，而Redis也不会缓存这个空结果。这就造成每次通过这样的Key去查询数据都会直接到数据库中查询，Redis不会缓存空结果。这就造成了缓存穿透的问题。\n\n一些恶意的请求会故意查询不存在的 key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。\n\n### 解决\n\n1. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。\n2. 如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。\n3. 根据明显错误的key在逻辑层就就行验证。\n4. 分析用户行为，是否为故意请求或者爬虫、攻击者。针对用户访问做限制。\n\n## 缓存击穿\n\n缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。\n\n缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，好像蛮力击穿一样。\n\n击穿和穿透不同，穿透的意思是想法绕过redis去使得数据库崩掉。而击穿你可以理解为正面刚击穿，这种通常为大量并发对一个key进行大规模的读写操作。**这个key在缓存失效期间大量请求数据库**，对数据库造成太大压力使得数据库崩掉。就比如在秒杀场景下10000块钱的mac和100块的mac这个100块的那个订单肯定会被抢到爆，不断的请求(当然具体秒杀有自己处理方式这里只是举个例子)。所以缓存击穿就是针对某个常用key大量请求导致数据库崩溃。\n\n### 解决\n\n#### 使用互斥锁\n\n在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。\n\n在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。\n\n```java\npublic String get(key) {\n      String value = redis.get(key);\n      if (value == null) \n      { \n          //代表缓存值过期\n          //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db\n\t\t  if (redis.setnx(key_mutex， 1， 3 * 60) == 1) \n          {  \n              //代表设置成功\n              value = db.get(key);\n              redis.set(key， value， expire_secs);\n              redis.del(key_mutex);\n          } \n          else \n          {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可\n              sleep(50);\n              get(key);  //重试\n          }\n      } \n    else \n    {\n        return value;      \n    }\n }\n```\n\n#### 热点key永不过期\n\n## 缓存雪崩\n\n大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。\n\n### 解决\n\n- 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。\n- 做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期\n- 可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。\n- 热点数据可以考虑不失效\n\n# 过期键删除策略\n\n## 过期键实现\n\n### 设置过期时间\n\n1. EXPIRE 设置过期时间，单位为秒\n2. PEXPIRE 设置过期时间，单位为毫秒\n3. EXPIREAT 设置过期时间为秒数时间戳\n4. PEXPIREAT 设置过期时间为毫秒数时间戳\n\n最后都是转换为PEXPIREAT来执行的\n\n### 保存过期时间\n\n```c\ntypedef struct redisDb\n{\n\tdict *dict;//数据库键空间，保存着数据库中的所有键值对\n\tdict *expires;//保存了数据库中所有键的过期时间，过期字典\n\t//key是一个指针，指向键空间某个键\n\t//value为long long类型的过期时间，一个毫秒精度的UNIX时间戳\n} redisDb;\n```\n\n键空间的键和过期字典的键都指向同一个键对象，不会出现任何重复对象，也不会浪费任何空间\n\n```python\ndef PEXPIREAT(key，expire_time_in_ms)\n{\n \t#如果给定的键不存在键空间，那么不能设置过期时间\n    if key not in redisDb.dict:\n    \treturn 0\n    #在过期字典中关联键和过期时间\n    redisDb.expires[key] = expire_time_in_ms\n    # 过期时间设置成功\n    return 1\n}\n```\n\n### 移除过期时间\n\n```python\ndef PERSIST(key):\n    #如果给定的键不存在或没设置过期时间，那么直接返回\n     if key not in redisDb.expires:\n    \treturn 0\n    #移除过期字典中给定键的键值对关联\n    redisDb.expires.remove(key)\n    #移除成功\n    return 1\n```\n\n### 计算并返回剩余生存时间\n\n```python\ndef PTTL(key):\n    #如果给定的键不存在数据库\n    if key not in redisDb.dict:\n    \treturn -2\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n    \n    if expire_time_in_ms is None:\n        return -1\n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n    return (expire_time_in_ms - now_ms)\n```\n\n```python\ndef TTL(key):\n    ttl_in_ms = PTTL(key)\n    if ttl_in_ms<0:\n        //处理为-2，-1的异常情况\n        return ttl_in_ms\n    else:\n        #将毫秒转为秒\n        return ms_to_sec(ttl_in_ms)\n    \n```\n\n### 过期键的判断\n\n```python\ndef is_expired(key):\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n    \n    if expire_time_in_ms is None:\n        return False\n    \n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n    \n    if  now_ms>expire_time_in_ms:\n        return True # 已过期\n    else:\n        return False\n```\n\n## 定时删除\n\n- 在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作\n\n- 可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存\n\n- 对CPU时间最不友好，在内存不紧张而CPU非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，对服务器的响应时间和吞吐量造成影响\n\n- 不太现实\n\n\n## 惰性删除\n\n- 每次取出键都会检查是否过期，过期则删除\n\n- 只有在取出键时才会对键进行过期检查，对CPU时间最友好\n\n- 对内存最不友好：如果一个键已过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。\n\n- 会导致内存泄漏，无用的垃圾数据占用了大量内存。如日志，当不再使用时，会大量积压在数据库，用户以为自动删除了，其实还存在，则它们不会被删除，所占用的内存就不会释放。\n\n\n## 定期删除\n\n- 每隔一段时间进行检查，删除里面的过期键\n- 通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响；定期删除策略有效减少了因为过期键而带来的内存浪费。是前两种的整合与折中。\n- 必须合理地设置删除操作的执行时间和执行效率：太频繁或执行时间太长会退化为定时删除策略，反之则出现浪费内存的情况\n\n\n## Redis过期键删除策略\n\n配合使用**惰性删除**和**定期删除**两种\n\n### 惰性删除策略的实现\n\n所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查，如果输入键已过期，则将输入键从数据库中删除\n\n采用expireIfNeeded函数，如果过期则将键删除。就像过滤器，在命令真正执行前，过滤掉过期的输入键，避免命令接触到过期键\n\n所以每个命令的实现函数必须能同时处理键存在和不存在两种情况\n\n![image-20210207104150550](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104150550.png)\n\n![image-20210207104206293](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104206293.png)\n\n### 定期删除策略实现\n\n每当Redis服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键\n\n```python\n# coding=utf-8\n# 默认每次检查的数据库数量\nDEFAULT_DB_NUMBERS = 16\n\n# 默认每个数据库检查的键数量\nDEFAULT_KEY_NUMBERS = 20\n\n# 全局变量，记录检查进度\n# 如果当前的activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数时，将从11号数据库开始查找并删除过期键\ncurrent_db = 0\n\n# 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键\ndef activeExpireCycle():\n    # 初始化要检查的数据库数量\n    # 以服务器的数据库数量为主\n    if serer.dbnum < DEFAULT_DB_NUMBERS:\n        db_numbers = serer.dbnum\n    else:\n        db_numbers = DEFAULT_DB_NUMBERS\n\n    #遍历每个数据库\n    for i in range(db_numbers):\n        #如果current_db=服务器的数据库数量\n        #则表示已经遍历了服务器的所有数据库一次\n        #将current_db=重置为0，开始新一轮\n        if current_db==server.dbnum:\n            current_db=0\n        \n        #获取当前要处理的数据库\n        redisDb=server.db[current_db]\n        \n        #指向下一个要处理的数据库\n        current_db+=1\n        \n        #检查数据库的键\n        for j in range(DEFAULT_KEY_NUMBERS):\n            #如果数据库中没有一个键带有过期时间，则跳过该数据库\n            if redisDb.expires.size()==0:\n                break\n            \n            #随机获取一个带过期时间的键\n            key_with_ttl=redisDb.expires.get_random_key()\n            \n            if is_expired(key_with_ttl):\n                delete_key(key_with_ttl)\n                \n            # 已到达时间上限，停止处理\n            if reach_time_limit():\n                return \n```\n\n# 持久化\n\n## RDB持久化\n\n### 创建\n\n**SAVE指令**会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，所以当Save命令正在执行时，客户端发送的所有命令请求都会被阻塞\n\n**BGSAVE命令**会派生出一个子进程，由它负责创建RDB文件，服务器进程(父进程)继续处理命令请求。\n\n\n\n1、在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝。服务器禁止SAVE与BGSAVE同时执行是为了避免父进程和子进程同时指向两个rdbSave调用，防止产生竞争条件。\n\n2、同样的道理，在BGSAVE执行期间，客户端的BGSAVE命令也会被服务器拒绝。\n\n3、另外，对于AOF持久化命令BGREWRITEAOF与BGSAVE也同样是互斥关系，如果BGSAVE正在执行，则BGREWRITEAOF命令会被延迟到BGSAVE执行完毕之后；而BGREWRITEAOF命令执行时，服务器会拒绝BGSAVE命令的执行。\n\n4、而事实上，因为BGREWRITEAOF命令与BGSAVE两个命令的实际工作都是由子进程执行，所以这两个命令在操作方面并没有冲突的地方，不能同时执行只是性能方面的考虑--并发处两个子进程，并且这两个子进程同时对磁盘进行大量读写。\n\n```python\ndef SAVE():\n\t#创建RDB文件\n\trdbSave（）\n\t\ndef BGSAVE():\n\t# 创建子进程\n\tpid=fork()\n\t\n\tif pid == 0:\n\t\t# 子进程负责创建RDB文件\n\t\trdbSave（）\n\t\t# 完成之后向父进程发送信号\n\t\tsignal_parent()\n\telif pid>0:\n\t\t# 父进程继续处理命令请求，并通过轮询等待子进程的信号\n\t\thandle_request_and_wait_signal()\n\telse:\n\t\t# 处理出错情况\n\t\thandle_fork_error()\n```\n\n### 载入\n\n- RDB文件的载入工作是服务器启动时自动进行的，只要Redis服务器在启动时检测到RDB文件存在，就会自动载入RDB文件\n- 如果服务器开启了AOF持久化功能，则优先使用AOF文件还原数据库状态\n- 只有未开启AOF持久化功能，才会使用RDB文件还原数据库状态\n- 服务器在载入RDB文件时会一直处于阻塞状态，直到载入工作完成\n\n### 自动间隔性保存\n\n服务器每隔一段时间自动执行一次BGSAVE命令，可以设置多个保存条件，只要任意一个条件被满足，服务器就会执行BGSAVE指令\n\n```c\nsave 900 1\nsave 300 10\nsave 60 10000\n\n服务器在900秒内进行了至少1次修改\n服务器在300秒内进行了至少10次修改\n服务器在60秒内进行了至少10000次修改\n```\n\n### 设置保存条件\n\n服务器程序根据save选项（可通过配置文件设置）所设置的保存条件，设置服务器状态的redisServer结构的saveparams属性\n\n```c\nstruct redisServer\n{\n\tstruct saveparam * saveparams;\n\tlong long dirty; //距离上一次成功执行BGSAVE之后，进行修改的次数\n\ttime_t lastsave; //上一次成功执行BGSAVE的时间\n};\n\nstruct saveparam\n{\n\ttime_t seconds;\n\tint changes;\n}\n```\n\n### 检查保存条件是否满足\n\n服务器周期性操作函数serverCron()默认每隔100ms执行一次\n\n其中一项工作就是检查save选项所设置的保存条件是否已经满足\n\n如果满足，则执行BGSAVE（）\n\n```python\ndef serverCron():\n\t# 遍历所有保存条件\n\tfor saveparam in server.saveparams:\n\t\tsave_interval=unixtime_now() - server.lastsave\n\t\t\n\t\t#如果数据库状态的修改次数超过条件所设置的次数\n\t\t#并且距离上次保存的时间超过条件所设置的时间\n\t\t#那么执行保存操作\n\t\tif server.dirty >= saveparam.changes and save_interval>saveparam.seconds:\n\t\t\tBGSAVE()\n```\n\n### RDB文件结构\n\n#### 概览\n\n1. REDIS，通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否是RDB文件\n2. db_version，记录了版本号\n3. databases，包含任意个数据库以及他们的键值对数据。\n4. EOF，标志着RDB文件正文内容的结束\n5. check_sum，校验和，检查RDB文件是否有出错或损坏的情况。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum进行比对，已发行RDB文件是否损坏\n\n#### databases\n\n每个非空数据库保存三部分：\n\n1. SELECTDB 常量，说明接下来会读取一个数据库号码\n2. db_number，读入后，调用SELECT指令，进行数据库切换，使得之后读入的键值对可以载入到正确的数据库之中\n3. key_value_pairs，保存了数据库中的所有键值对数据。包含过期时间。\n\n#### key_value_pairs\n\n1. TYPE记录了value的类型，代表了一种对象类型或底层编码。程序根据TYPE的值决定如何读入和解释value的数据\n2. key总是一个字符串对象\n3. value根据TYPE的指令保存相应类型的内容\n4. EXPIRETIME_MS常量，代表之后会读取一个以毫秒为单位的过期时间\n5. ms，保存键值对的过期时间，以毫秒为单位的UNIX时间戳\n\n\n\n## AOF持久化\n\n### 简介\n\n- AOF（Append Only File)\n- 通过保存`Redis`服务器所执行的写命令来记录数据库状态的\n- 被写入AOF文件的所有命令都是以Redis的命令请求协议格式（纯文本）保存的。\n- 服务器启动时，可以通过载入和执行`AOF文件`中保存的命令来还原服务器关闭之前的数据库状态\n\n\n### AOF持久化的实现\n\n#### 命令追加\n\n服务器在执行完一个写命令后，会将被执行的写命令追加到服务器状态的`aof_buf`缓冲区的末尾:\n\n```c\nstruct redisServer\n{\n\t// AOF缓冲区\n\tsds aof_buf;\n}\n```\n\n#### AOF文件的写入与同步\n\n服务器进程是一个事件循环，循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。时间事件负责执行像serverCron函数这样需要定时运行的函数\n\n```python\ndef eventLoop()\n{\n\twhile True:\n\t\t#处理文件事件，接收命令请求以及发送命令回复\n\t\t#处理命令请求时可能会有新内容加入到aof_buf缓冲区中\n\t\tprocessFileEvents()\n\t\t\n\t\t#处理时间事件\n\t\tprocessTimeEvents()\n\t\t\n\t\t#考虑是否要将aof_buf缓冲区中的内容写入和保存到AOF文件里面\n\t\tflushAppendOnlyFile()\n}\n```\n\n**写入**：在现代操作系统中，当数据写入到文件中时，会调用write函数。操作系统会将写入数据暂时保存在一个内存缓存区中，等到缓冲区空间满的时候，才真正将缓冲区中的数据写入到磁盘中。\n\n**同步**：同时系统也提供了同步函数（例如fsync)，它可以强制让操作系统立即将缓冲区中的数据写入到磁盘中。\n\n\n\n在每个事件循环都会调用flushAppendOnlyFile函数，flushAppendOnlyFile函数的行为由**appendfsync**的值决定：\n\n**always**：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中，并同步AOF文件（把aof_buf数据写入并同步到AOF文件中）\n\n**everysec**：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，并且每隔一秒就在子线程中对AOF文件进行一次同步(每隔一秒同步)。\n\n**no**：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，至于什么时候同步，由操作系统控制（不知道啥时候同步）。在该模式下的flushAppendOnlyFile的调用不需要同步执行。\n\n\n\n上述配置的值，直接决定服务器的效率与安全性，当always时，安全性最高，但是效率最低；no时效率最高，安全性最低；everysec居中：从效率上来讲，everysec模式足够快，并且就算出现了故障停机，数据库也只丢失一秒钟的命令数据。系统默认配置是everysec。\n\n### AOF文件的载入与数据还原\n\n只要读入并重新执行一遍`AOF文件`里面保存的写命令，就可以还原服务器关闭之前的数据库状态\n\n1. 创建一个不带网络连接的伪客户端\n2. 从AOF文件中分析并读取出一条写命令\n3. 使用伪客户端执行被读出的写命令\n4. 一直执行2，3直到AOF文件中的所有写命令都被处理完毕\n\n![image-20210207113554356](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207113554356.png)\n\n### AOF重写\n\n为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。\n\n服务器创建一个新的AOF文件来**替代**现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但是新的AOF文件不会包含任何浪费空间的冗余命令\n\n### AOF文件重写的实现\n\n不需要对现有的AOF文件进行操作，是通过读取服务器当前的数据库状态来实现的\n\n首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。\n\n```python\ndef aof_rewrite(new_aof_file_name):\n\t#创建新的aof文件\n\tf=create_file(new_aof_file_name)\n\t#遍历数据库\n\tfor db in redisServer.db:\n\t\t#忽略空数据库\n\t\tif db.is_empty():continue\n\t\t\n\t\t#写入SELECT命令，指定数据库号码\n\t\tf.write_command(\"SELECT\"+db.id)\n\t\t\n\t\t#遍历数据库中所有键\n\t\tfor key in db:\n\t\t\t#忽略过期的键\n\t\t\tif key.is_expired():continue\n\t\t\t\n\t\t\t#根据键的类型对键进行重写\n\t\t\tif key.type == String:\n\t\t\t\trewrite_string(key)\n\t\t\telif key.type == List:\n\t\t\t\trewrite_list(key)\n\t\t\telif key.type == Hash:\n\t\t\t\trewrite_hash(key)\n            elif key.type == Set:\n\t\t\t\trewrite_set(key)\n            elif key.type == SortedSet:\n\t\t\t\trewrite_sortedSet(key)\n\t\t\t\t\n\t\t\t# 如果键带有过期时间，过期时间也要重写\n\t\t\tif key.have_expired_time():\n\t\t\t\trewrite_expired_time(key)\n\t#写入完毕，关闭文件\t\t\t\n\tf.close()\n\t\ndef rewrite_string(key):\n\t#使用GET命令获取字符串的值\n\tvalue=GET(key)\n\t#使用SET命令重写字符串键\n\tf.write_command(SET，key，value)\n\t\ndef rewrite_expired_time(key):\n\t#获取毫秒精度的键过期时间戳\n\ttimestamp=get_expired_time_in_unixstamp(key)\n\t#使用PEXPIREAT命令重写键的过期时间\n\tf.write_command(PEXPIREAT，key，timestamp)\n```\n\n\n\n### AOF后台重写\n\n因为aof_rewrite函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞\n\n因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求。\n\n所以决定将AOF重写程序放到**子进程**中执行\n\n+ 子进程在进行AOF重写期间，服务器进程可以进行处理命令请求\n+ 子进程带有服务器进程的**数据副本**，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性\n\n但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库**状态不一致**\n\n\n\n#### AOF重写缓冲区\n\n为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，会同时将这个命令发送给**AOF缓冲区和AOF重写缓冲区**\n\n![image-20210207114138147](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207114138147.png)\n\n在子进程执行AOF重写期间，服务器进程执行:\n\n1. 执行客户端发来的指令\n2. 将执行后的写命令追加到AOF缓冲区\n3. 将执行后的写命令追加到AOF重写缓冲区\n\n\n\n这样一来可以**保证**\n\n- AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。\n- 从创建子进程开始，服务器执行的所有写命都会被记录到AOF重写缓冲区里面。\n\n\n\n当子进程完成AOF重写工作之后，它  会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：\n\n- 将AOF重写缓冲区中的所有内容重写到新AOF文件中，这时新AOF文件保存的数据库状态将**和服务器当前的数据库状态一致**。\n- 对新的AOF文件进行改名，原子地(atomic)覆盖现有地AOF文件，完成**新旧两个AOF文件地替换**。\n\n这个信号处理函数执行完毕后，父进程可以继续像往常一样接收命令请求了\n\n\n\n在整个AOF后台重写过程中，只有**信号处理函数执行时会对服务器进程（父进程）造成阻塞**，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。\n\n# 分布式锁\n\n## 理解\n\n在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。\n\n一个应用往往会部署在多台机器上（多节点），在某些场景中，多个进程必须以互斥的方式独占共享资源。因此需要使用分布式锁\n\n\n\n分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源，一般来说，分布式锁需要满足的特性有这么几点：\n\n1、互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；\n\n2、高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；\n\n3、防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；\n\n4、独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了；\n\n## setnx（set if not exists)\n\n```\nSETNX key value\n```\n\nSET if Not eXists(如果不存在，则 SET)\n\n命令在设置成功时返回 1 ，设置失败时返回 0 。\n\n用来实现Redis锁机制，一个进程进来占坑，用完后再调用del指令释放坑\n\n只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作。\n\n**中间代码异常**\n\n如果逻辑执行到中间出现异常，可能导致del指令没有被调用，就会陷入死锁，锁永远得不到释放\n\n可以再拿到锁以后再给锁加上一个过期时间，比如5s，这样即使中间出现异常也可以保证5s后锁会自动释放\n\n```redis\nsetnx tongji4m3 true\n\nexpire tongji4m3 5\n\ndel tongji4m3\n```\n\n**expire异常**\n\n如果在setnx和expire之间服务器出现问题，导致expire得不到执行，也会死锁\n\n根源在于setnx和expire不是一条原子指令，但又不能用事务解决，因为expire依赖与setnx的执行结果，如果setnx没抢到锁，expire是不应该执行的，而事务没有if-else分支逻辑\n\nRedis支持set指令的扩展参数，使得setnx和expire指令可以一起执行，形成原子指令\n\n```\nSETEX key seconds value\n\nSET key value [EX seconds] [PX milliseconds] [NX|XX]\nset tongji4m3 true ex 5 nx\nNX:只在键不存在时， 才对键进行设置操作。\nXX:只在键已经存在时， 才对键进行设置操作。\n```\n\n将值 `value` 关联到 `key` ，并将 `key` 的生存时间设为 `seconds` (以秒为单位)。\n\n如果 `key` 已经存在，`setex`命令将覆写旧值。\n\n有小伙伴肯定会疑惑万一set value 成功 set time失败，那不就傻了么，这啊Redis官网想到了。\n\n`setex`是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成。\n\n单机加锁或synchronized就够了\n\n但如果线程挂了,那锁就一直在那无法得到释放，后面的线程也永远得不到锁，又死锁了。\n\nsetex设置一个过期时间，就算线程1挂了，也会在失效时间到了，自动释放。\n\n**超时问题**\n\n如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，会导致第一个线程持有的锁过期了而临界区的逻辑还没执行完\n\nRedis分布式锁不能用于较长时间的任务\n\n将set指令的value参数设置为随机数，释放锁时先匹配随机数是否一致，然后再删除key，确保当前线程持有的锁不会被其他线程释放，除非这个锁是因为过期了而被服务器自己释放的\n\n但是匹配value和删除key不是一个原子操作，需要要Lua脚本处理，他保证多个指令的原子性执行\n\n**可重入性**\n\n线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，就是可重入锁\n\n分布式锁要支持可重入，则要使用线程的Threadlocal变量存储当前持有锁的计数\n\n### 怎么释放锁\n\n释放锁的命令就简单了，直接删除key就行，但我们前面说了，因为分布式锁必须由锁的持有者自己释放，所以我们必须先确保当前释放锁的线程是持有者，没问题了再删除，这样一来，就变成两个步骤了，似乎又违背了原子性了，怎么办呢？\n\n不慌，我们可以用lua脚本把两步操作做拼装\n\n## redisson\n\nredisson的锁，就实现了可重入\n\n```java\nThreadPoolExecutor threadPoolExecutor =\n        new ThreadPoolExecutor(inventory, inventory, 10L, SECONDS, linkedBlockingQueue);\nlong start = System.currentTimeMillis();\nConfig config = new Config();\nconfig.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\nfinal RedissonClient client = Redisson.create(config);\nfinal RLock lock = client.getLock(\"lock1\");\n\nfor (int i = 0; i <= NUM; i++) {\n    threadPoolExecutor.execute(new Runnable() {\n        public void run() {\n            lock.lock();\n            inventory--;\n            System.out.println(inventory);\n            lock.unlock();\n        }\n    });\n}\nlong end = System.currentTimeMillis();\nSystem.out.println(\"执行线程数:\" + NUM + \"   总耗时:\" + (end - start) + \"  库存数为:\" + inventory);\n```\n\n\n### 初始化\n\n```java\npublic RLock getLock(String name) {\n    return new RedissonLock(connectionManager.getCommandExecutor(), name);\n}\n\npublic RedissonLock(CommandAsyncExecutor commandExecutor, String name) {\n    super(commandExecutor, name);\n    //命令执行器\n    this.commandExecutor = commandExecutor;\n    //UUID字符串\n    this.id = commandExecutor.getConnectionManager().getId();\n    //内部锁过期时间\n    this.internalLockLeaseTime = commandExecutor.\n                getConnectionManager().getCfg().getLockWatchdogTimeout();\n    this.entryName = id + \":\" + name;\n```\n\n### 加锁\n\n```java\npublic void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException {\n    \n    //当前线程ID\n    long threadId = Thread.currentThread().getId();\n    //尝试获取锁\n    Long ttl = tryAcquire(leaseTime, unit, threadId);\n    // 如果ttl为空，则证明获取锁成功\n    if (ttl == null) {\n        return;\n    }\n    //如果获取锁失败，则订阅到对应这个锁的channel\n    RFuture<RedissonLockEntry> future = subscribe(threadId);\n    commandExecutor.syncSubscription(future);\n\n    try {\n        while (true) {\n            //再次尝试获取锁\n            ttl = tryAcquire(leaseTime, unit, threadId);\n            //ttl为空，说明成功获取锁，返回\n            if (ttl == null) {\n                break;\n            }\n            //ttl大于0 则等待ttl时间后继续尝试获取\n            if (ttl >= 0) {\n                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);\n            } else {\n                getEntry(threadId).getLatch().acquire();\n            }\n        }\n    } finally {\n        //取消对channel的订阅\n        unsubscribe(future, threadId);\n    }\n    //get(lockAsync(leaseTime, unit));\n}\n```\n\n### 获取锁\n\n```java\nprivate <T> RFuture<Long> tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) {\n\n    //如果带有过期时间，则按照普通方式获取锁\n    if (leaseTime != -1) {\n        return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);\n    }\n    \n    //先按照30秒的过期时间来执行获取锁的方法\n    RFuture<Long> ttlRemainingFuture = tryLockInnerAsync(\n        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),\n        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);\n        \n    //如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间\n    ttlRemainingFuture.addListener(new FutureListener<Long>() {\n        @Override\n        public void operationComplete(Future<Long> future) throws Exception {\n            if (!future.isSuccess()) {\n                return;\n            }\n\n            Long ttlRemaining = future.getNow();\n            // lock acquired\n            if (ttlRemaining == null) {\n                scheduleExpirationRenewal(threadId);\n            }\n        }\n    });\n    return ttlRemainingFuture;\n}\n```\n\n### 底层加锁逻辑\n\n你可能会想这么多操作，在一起不是原子性不还是有问题么？\n\n大佬们肯定想得到呀，所以还是LUA，他使用了Hash的数据结构。\n\n主要是判断锁是否存在，存在就设置过期时间，如果锁已经存在了，那对比一下线程，线程是一个那就证明可以重入，锁在了，但是不是当前线程，证明别人还没释放，那就把剩余时间返回，加锁失败。\n\n```java\n<T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit,     \n                            long threadId, RedisStrictCommand<T> command) {\n\n        //过期时间\n        internalLockLeaseTime = unit.toMillis(leaseTime);\n\n        return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,\n                  //如果锁不存在，则通过hset设置它的值，并设置过期时间\n                  \"if (redis.call('exists', KEYS[1]) == 0) then \" +\n                      \"redis.call('hset', KEYS[1], ARGV[2], 1); \" +\n                      \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n                      \"return nil; \" +\n                  \"end; \" +\n                  //如果锁已存在，并且锁的是当前线程，则通过hincrby给数值递增1\n                  \"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \" +\n                      \"redis.call('hincrby', KEYS[1], ARGV[2], 1); \" +\n                      \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n                      \"return nil; \" +\n                  \"end; \" +\n                  //如果锁已存在，但并非本线程，则返回过期时间ttl\n                  \"return redis.call('pttl', KEYS[1]);\",\n        Collections.<Object>singletonList(getName()), \n                internalLockLeaseTime, getLockName(threadId));\n    }\n```\n\n\n\n### 解锁\n\n锁的释放主要是publish释放锁的信息，然后做校验，一样会判断是否当前线程，成功就释放锁，还有个**hincrby**递减的操作，锁的值大于0说明是可重入锁，那就刷新过期时间。\n\n如果值小于0了，那删掉Key释放锁。\n\n是不是又和AQS很像了？\n\nAQS就是通过一个volatile修饰status去看锁的状态，也会看数值判断是否是可重入的。\n\n\n\n```java\npublic RFuture<Void> unlockAsync(final long threadId) {\n    final RPromise<Void> result = new RedissonPromise<Void>();\n    \n    //解锁方法\n    RFuture<Boolean> future = unlockInnerAsync(threadId);\n\n    future.addListener(new FutureListener<Boolean>() {\n        @Override\n        public void operationComplete(Future<Boolean> future) throws Exception {\n            if (!future.isSuccess()) {\n                cancelExpirationRenewal(threadId);\n                result.tryFailure(future.cause());\n                return;\n            }\n            //获取返回值\n            Boolean opStatus = future.getNow();\n            //如果返回空，则证明解锁的线程和当前锁不是同一个线程，抛出异常\n            if (opStatus == null) {\n                IllegalMonitorStateException cause = \n                    new IllegalMonitorStateException(\"\n                        attempt to unlock lock, not locked by current thread by node id: \"\n                        + id + \" thread-id: \" + threadId);\n                result.tryFailure(cause);\n                return;\n            }\n            //解锁成功，取消刷新过期时间的那个定时任务\n            if (opStatus) {\n                cancelExpirationRenewal(null);\n            }\n            result.trySuccess(null);\n        }\n    });\n\n    return result;\n}\n\n\nprotected RFuture<Boolean> unlockInnerAsync(long threadId) {\n    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, EVAL,\n    \n            //如果锁已经不存在， 发布锁释放的消息\n            \"if (redis.call('exists', KEYS[1]) == 0) then \" +\n                \"redis.call('publish', KEYS[2], ARGV[1]); \" +\n                \"return 1; \" +\n            \"end;\" +\n            //如果释放锁的线程和已存在锁的线程不是同一个线程，返回null\n            \"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then \" +\n                \"return nil;\" +\n            \"end; \" +\n            //通过hincrby递减1的方式，释放一次锁\n            //若剩余次数大于0 ，则刷新过期时间\n            \"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); \" +\n            \"if (counter > 0) then \" +\n                \"redis.call('pexpire', KEYS[1], ARGV[2]); \" +\n                \"return 0; \" +\n            //否则证明锁已经释放，删除key并发布锁释放的消息\n            \"else \" +\n                \"redis.call('del', KEYS[1]); \" +\n                \"redis.call('publish', KEYS[2], ARGV[1]); \" +\n                \"return 1; \"+\n            \"end; \" +\n            \"return nil;\",\n    Arrays.<Object>asList(getName(), getChannelName()), \n        LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));\n\n}\n```\n\n","slug":"数据库/Redis数据库/2.Redis设计机制","published":1,"updated":"2021-06-08T03:35:00.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq51f001gz0tp5ale9leu","content":"<h1 id=\"Redis简介\"><a href=\"#Redis简介\" class=\"headerlink\" title=\"Redis简介\"></a>Redis简介</h1><p>它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。</p>\n<p>命令不区分大小写，而key区分大小写</p>\n<p>Redis所有的数据结构都以唯一的key字符串作为名称，不同类型的数据结构的差异就在于value的结构不一样</p>\n<p>所有数据结构都可以设置过期时间</p>\n<h2 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h2><h3 id=\"官方介绍\"><a href=\"#官方介绍\" class=\"headerlink\" title=\"官方介绍\"></a>官方介绍</h3><p>Remote Dictionary Service(远程词典服务)，是一个存储中间件</p>\n<p>Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。</p>\n<p>Redis是一个开源的内存中的数据结构存储系统，它可以用作：<strong>数据库、缓存和消息中间件</strong>。</p>\n<p>它支持多种类型的数据结构，如字符串（Strings），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。<strong>其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。</strong></p>\n<p>Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p>\n<p>Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</p>\n<h3 id=\"Redis为什么快\"><a href=\"#Redis为什么快\" class=\"headerlink\" title=\"Redis为什么快\"></a>Redis为什么快</h3><ul>\n<li>redis是基于内存的，数据存在内存中，内存的读写速度非常快；它类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li>\n<li>数据结构简单，对数据操作也简单，有高效的数据结构。底层多种数据结构支持不同的数据类型，支持 Redis 存储不同的数据</li>\n<li>采用单线程，避免了不必要的上下文切换和竞争条件，不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>\n<li>redis使用I/O多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在IO上浪费一点时间。</li>\n</ul>\n<h2 id=\"Redis和memcached的区别\"><a href=\"#Redis和memcached的区别\" class=\"headerlink\" title=\"Redis和memcached的区别\"></a>Redis和memcached的区别</h2><ul>\n<li>Redis 支持复杂的数据结构，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作</li>\n<li>Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务</li>\n<li>性能方面，Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Remcached，还是稍有逊色。</li>\n<li>Redis ⽀持持久化，所以 Redis 不仅仅可以⽤作缓存，也可以⽤作 NoSQL 数据库。</li>\n</ul>\n<h2 id=\"为什么Redis是单线程的\"><a href=\"#为什么Redis是单线程的\" class=\"headerlink\" title=\"为什么Redis是单线程的\"></a>为什么Redis是单线程的</h2><p>这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行</p>\n<p> 单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p>\n<p> 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间</p>\n<p><strong>1.官方答案</strong></p>\n<p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>\n<p><strong>2.性能指标</strong></p>\n<p>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n<p><strong>3.详细原因</strong></p>\n<p><strong>1）不需要各种锁的性能消耗</strong></p>\n<p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p>\n<p>一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p>\n<p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p>\n<p><strong>2）单线程多进程集群方案</strong></p>\n<p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p>\n<p><strong>所以单线程、多进程的集群不失为一个时髦的解决方案。</strong></p>\n<p><strong>3）CPU消耗</strong></p>\n<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p>\n<p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p>\n<p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p>\n<h2 id=\"Redis单线程的优劣势\"><a href=\"#Redis单线程的优劣势\" class=\"headerlink\" title=\"Redis单线程的优劣势\"></a>Redis单线程的优劣势</h2><p><strong>单进程单线程优势</strong></p>\n<ol>\n<li>代码更清晰，处理逻辑更简单</li>\n<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li>\n<li>不存在多进程或者多线程导致的切换而消耗CPU</li>\n</ol>\n<p><strong>单进程单线程弊端</strong></p>\n<ol>\n<li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li>\n</ol>\n<h2 id=\"为什么快\"><a href=\"#为什么快\" class=\"headerlink\" title=\"为什么快\"></a>为什么快</h2><p>Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而  <strong>I/O 多路复用</strong> 就是为了解决这个问题而出现的。</p>\n<p>redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p>\n<ul>\n<li>优先选择时间复杂度为O(1)的IO复用函数作为底层实现，例如epoll</li>\n<li>以select系统调用为保底，时间复杂度O(N)</li>\n<li>基于react设计模式监听IO事件</li>\n</ul>\n<p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p>\n<p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"服务器中的数据库\"><a href=\"#服务器中的数据库\" class=\"headerlink\" title=\"服务器中的数据库\"></a>服务器中的数据库</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> redisServer\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> dbnum<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//服务器的数据库数量</span>\n    redisDb <span class=\"token operator\">*</span>db<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//一个数组，保存着服务器中的所有数据库 默认16</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"切换数据库\"><a href=\"#切换数据库\" class=\"headerlink\" title=\"切换数据库\"></a>切换数据库</h3><p>每个Redis客户端都有个目标数据库，每当客户端执行数据库读写命令时，目标数据库就成为这些命令的操作对象.默认目标数据库为0号数据库</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> redisClient\n<span class=\"token punctuation\">{</span>\n    redisDb <span class=\"token operator\">*</span> db<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//记录客户端当前使用的数据库</span>\n<span class=\"token punctuation\">}</span>redisClient<span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"数据库键空间\"><a href=\"#数据库键空间\" class=\"headerlink\" title=\"数据库键空间\"></a>数据库键空间</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> redisDb\n<span class=\"token punctuation\">{</span>\n    dict <span class=\"token operator\">*</span>dict<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//数据库键空间，保存着数据库中的所有键值对</span>\n<span class=\"token punctuation\">}</span> redisDb<span class=\"token punctuation\">;</span></code></pre>\n<p>键空间的键是一个字符串对象，值可以是字符串对象，列表对象，哈希表对象，集合对象，有序集合对象</p>\n<p>所有针对数据库的操作，都是通过对键空间字典进行操作实现的</p>\n<h4 id=\"添加新键\"><a href=\"#添加新键\" class=\"headerlink\" title=\"添加新键\"></a>添加新键</h4><p>就是将新键值对添加到键空间字典里面</p>\n<h4 id=\"读写键空间时的维护操作\"><a href=\"#读写键空间时的维护操作\" class=\"headerlink\" title=\"读写键空间时的维护操作\"></a>读写键空间时的维护操作</h4><ul>\n<li>在读取一个键后(读写操作都要对键进行读取)，服务器会根据键是否存在来更新服务器的键空间命中次数</li>\n<li>在读取一个键后，会更新LRU时间，可以计算键的闲置时间</li>\n<li>在读取一个键若发现该键已过期，则会先删除过期键</li>\n<li>在对被监视的键进行修改后，会标记为脏，让事务程序注意该键已经被修改</li>\n</ul>\n<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><p>查询某个Key对应的数据，Redis缓存中没有相应的数据，则直接到数据库中查询。数据库中也不存在要查询的数据，则数据库会返回空，而Redis也不会缓存这个空结果。这就造成每次通过这样的Key去查询数据都会直接到数据库中查询，Redis不会缓存空结果。这就造成了缓存穿透的问题。</p>\n<p>一些恶意的请求会故意查询不存在的 key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><ol>\n<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li>\n<li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li>\n<li>根据明显错误的key在逻辑层就就行验证。</li>\n<li>分析用户行为，是否为故意请求或者爬虫、攻击者。针对用户访问做限制。</li>\n</ol>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>\n<p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，好像蛮力击穿一样。</p>\n<p>击穿和穿透不同，穿透的意思是想法绕过redis去使得数据库崩掉。而击穿你可以理解为正面刚击穿，这种通常为大量并发对一个key进行大规模的读写操作。<strong>这个key在缓存失效期间大量请求数据库</strong>，对数据库造成太大压力使得数据库崩掉。就比如在秒杀场景下10000块钱的mac和100块的mac这个100块的那个订单肯定会被抢到爆，不断的请求(当然具体秒杀有自己处理方式这里只是举个例子)。所以缓存击穿就是针对某个常用key大量请求导致数据库崩溃。</p>\n<h3 id=\"解决-1\"><a href=\"#解决-1\" class=\"headerlink\" title=\"解决\"></a>解决</h3><h4 id=\"使用互斥锁\"><a href=\"#使用互斥锁\" class=\"headerlink\" title=\"使用互斥锁\"></a>使用互斥锁</h4><p>在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p>\n<p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> String <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      String value <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> \n      <span class=\"token punctuation\">{</span> \n          <span class=\"token comment\" spellcheck=\"true\">//代表缓存值过期</span>\n          <span class=\"token comment\" spellcheck=\"true\">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>redis<span class=\"token punctuation\">.</span><span class=\"token function\">setnx</span><span class=\"token punctuation\">(</span>key_mutex， <span class=\"token number\">1</span>， <span class=\"token number\">3</span> <span class=\"token operator\">*</span> <span class=\"token number\">60</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> \n          <span class=\"token punctuation\">{</span>  \n              <span class=\"token comment\" spellcheck=\"true\">//代表设置成功</span>\n              value <span class=\"token operator\">=</span> db<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              redis<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key， value， expire_secs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              redis<span class=\"token punctuation\">.</span><span class=\"token function\">del</span><span class=\"token punctuation\">(</span>key_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span> \n          <span class=\"token keyword\">else</span> \n          <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span>\n              <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//重试</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span> \n    <span class=\"token keyword\">else</span> \n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">;</span>      \n    <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"热点key永不过期\"><a href=\"#热点key永不过期\" class=\"headerlink\" title=\"热点key永不过期\"></a>热点key永不过期</h4><h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>\n<h3 id=\"解决-2\"><a href=\"#解决-2\" class=\"headerlink\" title=\"解决\"></a>解决</h3><ul>\n<li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</li>\n<li>做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期</li>\n<li>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li>\n<li>热点数据可以考虑不失效</li>\n</ul>\n<h1 id=\"过期键删除策略\"><a href=\"#过期键删除策略\" class=\"headerlink\" title=\"过期键删除策略\"></a>过期键删除策略</h1><h2 id=\"过期键实现\"><a href=\"#过期键实现\" class=\"headerlink\" title=\"过期键实现\"></a>过期键实现</h2><h3 id=\"设置过期时间\"><a href=\"#设置过期时间\" class=\"headerlink\" title=\"设置过期时间\"></a>设置过期时间</h3><ol>\n<li>EXPIRE 设置过期时间，单位为秒</li>\n<li>PEXPIRE 设置过期时间，单位为毫秒</li>\n<li>EXPIREAT 设置过期时间为秒数时间戳</li>\n<li>PEXPIREAT 设置过期时间为毫秒数时间戳</li>\n</ol>\n<p>最后都是转换为PEXPIREAT来执行的</p>\n<h3 id=\"保存过期时间\"><a href=\"#保存过期时间\" class=\"headerlink\" title=\"保存过期时间\"></a>保存过期时间</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> redisDb\n<span class=\"token punctuation\">{</span>\n    dict <span class=\"token operator\">*</span>dict<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//数据库键空间，保存着数据库中的所有键值对</span>\n    dict <span class=\"token operator\">*</span>expires<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//保存了数据库中所有键的过期时间，过期字典</span>\n    <span class=\"token comment\" spellcheck=\"true\">//key是一个指针，指向键空间某个键</span>\n    <span class=\"token comment\" spellcheck=\"true\">//value为long long类型的过期时间，一个毫秒精度的UNIX时间戳</span>\n<span class=\"token punctuation\">}</span> redisDb<span class=\"token punctuation\">;</span></code></pre>\n<p>键空间的键和过期字典的键都指向同一个键对象，不会出现任何重复对象，也不会浪费任何空间</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">PEXPIREAT</span><span class=\"token punctuation\">(</span>key，expire_time_in_ms<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n     <span class=\"token comment\" spellcheck=\"true\">#如果给定的键不存在键空间，那么不能设置过期时间</span>\n    <span class=\"token keyword\">if</span> key <span class=\"token operator\">not</span> <span class=\"token keyword\">in</span> redisDb<span class=\"token punctuation\">.</span>dict<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n    <span class=\"token comment\" spellcheck=\"true\">#在过期字典中关联键和过期时间</span>\n    redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> expire_time_in_ms\n    <span class=\"token comment\" spellcheck=\"true\"># 过期时间设置成功</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"移除过期时间\"><a href=\"#移除过期时间\" class=\"headerlink\" title=\"移除过期时间\"></a>移除过期时间</h3><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">PERSIST</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#如果给定的键不存在或没设置过期时间，那么直接返回</span>\n     <span class=\"token keyword\">if</span> key <span class=\"token operator\">not</span> <span class=\"token keyword\">in</span> redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n    <span class=\"token comment\" spellcheck=\"true\">#移除过期字典中给定键的键值对关联</span>\n    redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">#移除成功</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span></code></pre>\n<h3 id=\"计算并返回剩余生存时间\"><a href=\"#计算并返回剩余生存时间\" class=\"headerlink\" title=\"计算并返回剩余生存时间\"></a>计算并返回剩余生存时间</h3><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">PTTL</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#如果给定的键不存在数据库</span>\n    <span class=\"token keyword\">if</span> key <span class=\"token operator\">not</span> <span class=\"token keyword\">in</span> redisDb<span class=\"token punctuation\">.</span>dict<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">2</span>\n    <span class=\"token comment\" spellcheck=\"true\">#尝试获取过期时间</span>\n    <span class=\"token comment\" spellcheck=\"true\">#没有则为None</span>\n    expire_time_in_ms<span class=\"token operator\">=</span>redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> expire_time_in_ms <span class=\"token keyword\">is</span> None<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 获取当前时间时间戳</span>\n    now_ms<span class=\"token operator\">=</span>get_current_unix_timestamp_in_ms<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>expire_time_in_ms <span class=\"token operator\">-</span> now_ms<span class=\"token punctuation\">)</span></code></pre>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">TTL</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    ttl_in_ms <span class=\"token operator\">=</span> PTTL<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> ttl_in_ms<span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token operator\">//</span>处理为<span class=\"token operator\">-</span><span class=\"token number\">2</span>，<span class=\"token operator\">-</span><span class=\"token number\">1</span>的异常情况\n        <span class=\"token keyword\">return</span> ttl_in_ms\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">#将毫秒转为秒</span>\n        <span class=\"token keyword\">return</span> ms_to_sec<span class=\"token punctuation\">(</span>ttl_in_ms<span class=\"token punctuation\">)</span>\n</code></pre>\n<h3 id=\"过期键的判断\"><a href=\"#过期键的判断\" class=\"headerlink\" title=\"过期键的判断\"></a>过期键的判断</h3><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">is_expired</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#尝试获取过期时间</span>\n    <span class=\"token comment\" spellcheck=\"true\">#没有则为None</span>\n    expire_time_in_ms<span class=\"token operator\">=</span>redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> expire_time_in_ms <span class=\"token keyword\">is</span> None<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># 获取当前时间时间戳</span>\n    now_ms<span class=\"token operator\">=</span>get_current_unix_timestamp_in_ms<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span>  now_ms<span class=\"token operator\">></span>expire_time_in_ms<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span> <span class=\"token comment\" spellcheck=\"true\"># 已过期</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span></code></pre>\n<h2 id=\"定时删除\"><a href=\"#定时删除\" class=\"headerlink\" title=\"定时删除\"></a>定时删除</h2><ul>\n<li><p>在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作</p>\n</li>\n<li><p>可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存</p>\n</li>\n<li><p>对CPU时间最不友好，在内存不紧张而CPU非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，对服务器的响应时间和吞吐量造成影响</p>\n</li>\n<li><p>不太现实</p>\n</li>\n</ul>\n<h2 id=\"惰性删除\"><a href=\"#惰性删除\" class=\"headerlink\" title=\"惰性删除\"></a>惰性删除</h2><ul>\n<li><p>每次取出键都会检查是否过期，过期则删除</p>\n</li>\n<li><p>只有在取出键时才会对键进行过期检查，对CPU时间最友好</p>\n</li>\n<li><p>对内存最不友好：如果一个键已过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。</p>\n</li>\n<li><p>会导致内存泄漏，无用的垃圾数据占用了大量内存。如日志，当不再使用时，会大量积压在数据库，用户以为自动删除了，其实还存在，则它们不会被删除，所占用的内存就不会释放。</p>\n</li>\n</ul>\n<h2 id=\"定期删除\"><a href=\"#定期删除\" class=\"headerlink\" title=\"定期删除\"></a>定期删除</h2><ul>\n<li>每隔一段时间进行检查，删除里面的过期键</li>\n<li>通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响；定期删除策略有效减少了因为过期键而带来的内存浪费。是前两种的整合与折中。</li>\n<li>必须合理地设置删除操作的执行时间和执行效率：太频繁或执行时间太长会退化为定时删除策略，反之则出现浪费内存的情况</li>\n</ul>\n<h2 id=\"Redis过期键删除策略\"><a href=\"#Redis过期键删除策略\" class=\"headerlink\" title=\"Redis过期键删除策略\"></a>Redis过期键删除策略</h2><p>配合使用<strong>惰性删除</strong>和<strong>定期删除</strong>两种</p>\n<h3 id=\"惰性删除策略的实现\"><a href=\"#惰性删除策略的实现\" class=\"headerlink\" title=\"惰性删除策略的实现\"></a>惰性删除策略的实现</h3><p>所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查，如果输入键已过期，则将输入键从数据库中删除</p>\n<p>采用expireIfNeeded函数，如果过期则将键删除。就像过滤器，在命令真正执行前，过滤掉过期的输入键，避免命令接触到过期键</p>\n<p>所以每个命令的实现函数必须能同时处理键存在和不存在两种情况</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104150550.png\" alt=\"image-20210207104150550\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104206293.png\" alt=\"image-20210207104206293\"></p>\n<h3 id=\"定期删除策略实现\"><a href=\"#定期删除策略实现\" class=\"headerlink\" title=\"定期删除策略实现\"></a>定期删除策略实现</h3><p>每当Redis服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># coding=utf-8</span>\n<span class=\"token comment\" spellcheck=\"true\"># 默认每次检查的数据库数量</span>\nDEFAULT_DB_NUMBERS <span class=\"token operator\">=</span> <span class=\"token number\">16</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 默认每个数据库检查的键数量</span>\nDEFAULT_KEY_NUMBERS <span class=\"token operator\">=</span> <span class=\"token number\">20</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 全局变量，记录检查进度</span>\n<span class=\"token comment\" spellcheck=\"true\"># 如果当前的activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数时，将从11号数据库开始查找并删除过期键</span>\ncurrent_db <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">activeExpireCycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 初始化要检查的数据库数量</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 以服务器的数据库数量为主</span>\n    <span class=\"token keyword\">if</span> serer<span class=\"token punctuation\">.</span>dbnum <span class=\"token operator\">&lt;</span> DEFAULT_DB_NUMBERS<span class=\"token punctuation\">:</span>\n        db_numbers <span class=\"token operator\">=</span> serer<span class=\"token punctuation\">.</span>dbnum\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        db_numbers <span class=\"token operator\">=</span> DEFAULT_DB_NUMBERS\n\n    <span class=\"token comment\" spellcheck=\"true\">#遍历每个数据库</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span>db_numbers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">#如果current_db=服务器的数据库数量</span>\n        <span class=\"token comment\" spellcheck=\"true\">#则表示已经遍历了服务器的所有数据库一次</span>\n        <span class=\"token comment\" spellcheck=\"true\">#将current_db=重置为0，开始新一轮</span>\n        <span class=\"token keyword\">if</span> current_db<span class=\"token operator\">==</span>server<span class=\"token punctuation\">.</span>dbnum<span class=\"token punctuation\">:</span>\n            current_db<span class=\"token operator\">=</span><span class=\"token number\">0</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#获取当前要处理的数据库</span>\n        redisDb<span class=\"token operator\">=</span>server<span class=\"token punctuation\">.</span>db<span class=\"token punctuation\">[</span>current_db<span class=\"token punctuation\">]</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#指向下一个要处理的数据库</span>\n        current_db<span class=\"token operator\">+=</span><span class=\"token number\">1</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#检查数据库的键</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span>DEFAULT_KEY_NUMBERS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\" spellcheck=\"true\">#如果数据库中没有一个键带有过期时间，则跳过该数据库</span>\n            <span class=\"token keyword\">if</span> redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">break</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">#随机获取一个带过期时间的键</span>\n            key_with_ttl<span class=\"token operator\">=</span>redisDb<span class=\"token punctuation\">.</span>expires<span class=\"token punctuation\">.</span>get_random_key<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n            <span class=\"token keyword\">if</span> is_expired<span class=\"token punctuation\">(</span>key_with_ttl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                delete_key<span class=\"token punctuation\">(</span>key_with_ttl<span class=\"token punctuation\">)</span>\n\n            <span class=\"token comment\" spellcheck=\"true\"># 已到达时间上限，停止处理</span>\n            <span class=\"token keyword\">if</span> reach_time_limit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> </code></pre>\n<h1 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h1><h2 id=\"RDB持久化\"><a href=\"#RDB持久化\" class=\"headerlink\" title=\"RDB持久化\"></a>RDB持久化</h2><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p><strong>SAVE指令</strong>会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，所以当Save命令正在执行时，客户端发送的所有命令请求都会被阻塞</p>\n<p><strong>BGSAVE命令</strong>会派生出一个子进程，由它负责创建RDB文件，服务器进程(父进程)继续处理命令请求。</p>\n<p>1、在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝。服务器禁止SAVE与BGSAVE同时执行是为了避免父进程和子进程同时指向两个rdbSave调用，防止产生竞争条件。</p>\n<p>2、同样的道理，在BGSAVE执行期间，客户端的BGSAVE命令也会被服务器拒绝。</p>\n<p>3、另外，对于AOF持久化命令BGREWRITEAOF与BGSAVE也同样是互斥关系，如果BGSAVE正在执行，则BGREWRITEAOF命令会被延迟到BGSAVE执行完毕之后；而BGREWRITEAOF命令执行时，服务器会拒绝BGSAVE命令的执行。</p>\n<p>4、而事实上，因为BGREWRITEAOF命令与BGSAVE两个命令的实际工作都是由子进程执行，所以这两个命令在操作方面并没有冲突的地方，不能同时执行只是性能方面的考虑–并发处两个子进程，并且这两个子进程同时对磁盘进行大量读写。</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">SAVE</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#创建RDB文件</span>\n    rdbSave（）\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">BGSAVE</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 创建子进程</span>\n    pid<span class=\"token operator\">=</span>fork<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> pid <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\"># 子进程负责创建RDB文件</span>\n        rdbSave（）\n        <span class=\"token comment\" spellcheck=\"true\"># 完成之后向父进程发送信号</span>\n        signal_parent<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">elif</span> pid<span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\"># 父进程继续处理命令请求，并通过轮询等待子进程的信号</span>\n        handle_request_and_wait_signal<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\"># 处理出错情况</span>\n        handle_fork_error<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<h3 id=\"载入\"><a href=\"#载入\" class=\"headerlink\" title=\"载入\"></a>载入</h3><ul>\n<li>RDB文件的载入工作是服务器启动时自动进行的，只要Redis服务器在启动时检测到RDB文件存在，就会自动载入RDB文件</li>\n<li>如果服务器开启了AOF持久化功能，则优先使用AOF文件还原数据库状态</li>\n<li>只有未开启AOF持久化功能，才会使用RDB文件还原数据库状态</li>\n<li>服务器在载入RDB文件时会一直处于阻塞状态，直到载入工作完成</li>\n</ul>\n<h3 id=\"自动间隔性保存\"><a href=\"#自动间隔性保存\" class=\"headerlink\" title=\"自动间隔性保存\"></a>自动间隔性保存</h3><p>服务器每隔一段时间自动执行一次BGSAVE命令，可以设置多个保存条件，只要任意一个条件被满足，服务器就会执行BGSAVE指令</p>\n<pre class=\" language-c\"><code class=\"language-c\">save <span class=\"token number\">900</span> <span class=\"token number\">1</span>\nsave <span class=\"token number\">300</span> <span class=\"token number\">10</span>\nsave <span class=\"token number\">60</span> <span class=\"token number\">10000</span>\n\n服务器在<span class=\"token number\">900</span>秒内进行了至少<span class=\"token number\">1</span>次修改\n服务器在<span class=\"token number\">300</span>秒内进行了至少<span class=\"token number\">10</span>次修改\n服务器在<span class=\"token number\">60</span>秒内进行了至少<span class=\"token number\">10000</span>次修改</code></pre>\n<h3 id=\"设置保存条件\"><a href=\"#设置保存条件\" class=\"headerlink\" title=\"设置保存条件\"></a>设置保存条件</h3><p>服务器程序根据save选项（可通过配置文件设置）所设置的保存条件，设置服务器状态的redisServer结构的saveparams属性</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> redisServer\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> saveparam <span class=\"token operator\">*</span> saveparams<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> dirty<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//距离上一次成功执行BGSAVE之后，进行修改的次数</span>\n    time_t lastsave<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//上一次成功执行BGSAVE的时间</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> saveparam\n<span class=\"token punctuation\">{</span>\n    time_t seconds<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> changes<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"检查保存条件是否满足\"><a href=\"#检查保存条件是否满足\" class=\"headerlink\" title=\"检查保存条件是否满足\"></a>检查保存条件是否满足</h3><p>服务器周期性操作函数serverCron()默认每隔100ms执行一次</p>\n<p>其中一项工作就是检查save选项所设置的保存条件是否已经满足</p>\n<p>如果满足，则执行BGSAVE（）</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">serverCron</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 遍历所有保存条件</span>\n    <span class=\"token keyword\">for</span> saveparam <span class=\"token keyword\">in</span> server<span class=\"token punctuation\">.</span>saveparams<span class=\"token punctuation\">:</span>\n        save_interval<span class=\"token operator\">=</span>unixtime_now<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> server<span class=\"token punctuation\">.</span>lastsave\n\n        <span class=\"token comment\" spellcheck=\"true\">#如果数据库状态的修改次数超过条件所设置的次数</span>\n        <span class=\"token comment\" spellcheck=\"true\">#并且距离上次保存的时间超过条件所设置的时间</span>\n        <span class=\"token comment\" spellcheck=\"true\">#那么执行保存操作</span>\n        <span class=\"token keyword\">if</span> server<span class=\"token punctuation\">.</span>dirty <span class=\"token operator\">>=</span> saveparam<span class=\"token punctuation\">.</span>changes <span class=\"token operator\">and</span> save_interval<span class=\"token operator\">></span>saveparam<span class=\"token punctuation\">.</span>seconds<span class=\"token punctuation\">:</span>\n            BGSAVE<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<h3 id=\"RDB文件结构\"><a href=\"#RDB文件结构\" class=\"headerlink\" title=\"RDB文件结构\"></a>RDB文件结构</h3><h4 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h4><ol>\n<li>REDIS，通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否是RDB文件</li>\n<li>db_version，记录了版本号</li>\n<li>databases，包含任意个数据库以及他们的键值对数据。</li>\n<li>EOF，标志着RDB文件正文内容的结束</li>\n<li>check_sum，校验和，检查RDB文件是否有出错或损坏的情况。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum进行比对，已发行RDB文件是否损坏</li>\n</ol>\n<h4 id=\"databases\"><a href=\"#databases\" class=\"headerlink\" title=\"databases\"></a>databases</h4><p>每个非空数据库保存三部分：</p>\n<ol>\n<li>SELECTDB 常量，说明接下来会读取一个数据库号码</li>\n<li>db_number，读入后，调用SELECT指令，进行数据库切换，使得之后读入的键值对可以载入到正确的数据库之中</li>\n<li>key_value_pairs，保存了数据库中的所有键值对数据。包含过期时间。</li>\n</ol>\n<h4 id=\"key-value-pairs\"><a href=\"#key-value-pairs\" class=\"headerlink\" title=\"key_value_pairs\"></a>key_value_pairs</h4><ol>\n<li>TYPE记录了value的类型，代表了一种对象类型或底层编码。程序根据TYPE的值决定如何读入和解释value的数据</li>\n<li>key总是一个字符串对象</li>\n<li>value根据TYPE的指令保存相应类型的内容</li>\n<li>EXPIRETIME_MS常量，代表之后会读取一个以毫秒为单位的过期时间</li>\n<li>ms，保存键值对的过期时间，以毫秒为单位的UNIX时间戳</li>\n</ol>\n<h2 id=\"AOF持久化\"><a href=\"#AOF持久化\" class=\"headerlink\" title=\"AOF持久化\"></a>AOF持久化</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>AOF（Append Only File)</li>\n<li>通过保存<code>Redis</code>服务器所执行的写命令来记录数据库状态的</li>\n<li>被写入AOF文件的所有命令都是以Redis的命令请求协议格式（纯文本）保存的。</li>\n<li>服务器启动时，可以通过载入和执行<code>AOF文件</code>中保存的命令来还原服务器关闭之前的数据库状态</li>\n</ul>\n<h3 id=\"AOF持久化的实现\"><a href=\"#AOF持久化的实现\" class=\"headerlink\" title=\"AOF持久化的实现\"></a>AOF持久化的实现</h3><h4 id=\"命令追加\"><a href=\"#命令追加\" class=\"headerlink\" title=\"命令追加\"></a>命令追加</h4><p>服务器在执行完一个写命令后，会将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾:</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> redisServer\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// AOF缓冲区</span>\n    sds aof_buf<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"AOF文件的写入与同步\"><a href=\"#AOF文件的写入与同步\" class=\"headerlink\" title=\"AOF文件的写入与同步\"></a>AOF文件的写入与同步</h4><p>服务器进程是一个事件循环，循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。时间事件负责执行像serverCron函数这样需要定时运行的函数</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">eventLoop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">#处理文件事件，接收命令请求以及发送命令回复</span>\n        <span class=\"token comment\" spellcheck=\"true\">#处理命令请求时可能会有新内容加入到aof_buf缓冲区中</span>\n        processFileEvents<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#处理时间事件</span>\n        processTimeEvents<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#考虑是否要将aof_buf缓冲区中的内容写入和保存到AOF文件里面</span>\n        flushAppendOnlyFile<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>写入</strong>：在现代操作系统中，当数据写入到文件中时，会调用write函数。操作系统会将写入数据暂时保存在一个内存缓存区中，等到缓冲区空间满的时候，才真正将缓冲区中的数据写入到磁盘中。</p>\n<p><strong>同步</strong>：同时系统也提供了同步函数（例如fsync)，它可以强制让操作系统立即将缓冲区中的数据写入到磁盘中。</p>\n<p>在每个事件循环都会调用flushAppendOnlyFile函数，flushAppendOnlyFile函数的行为由<strong>appendfsync</strong>的值决定：</p>\n<p><strong>always</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中，并同步AOF文件（把aof_buf数据写入并同步到AOF文件中）</p>\n<p><strong>everysec</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，并且每隔一秒就在子线程中对AOF文件进行一次同步(每隔一秒同步)。</p>\n<p><strong>no</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，至于什么时候同步，由操作系统控制（不知道啥时候同步）。在该模式下的flushAppendOnlyFile的调用不需要同步执行。</p>\n<p>上述配置的值，直接决定服务器的效率与安全性，当always时，安全性最高，但是效率最低；no时效率最高，安全性最低；everysec居中：从效率上来讲，everysec模式足够快，并且就算出现了故障停机，数据库也只丢失一秒钟的命令数据。系统默认配置是everysec。</p>\n<h3 id=\"AOF文件的载入与数据还原\"><a href=\"#AOF文件的载入与数据还原\" class=\"headerlink\" title=\"AOF文件的载入与数据还原\"></a>AOF文件的载入与数据还原</h3><p>只要读入并重新执行一遍<code>AOF文件</code>里面保存的写命令，就可以还原服务器关闭之前的数据库状态</p>\n<ol>\n<li>创建一个不带网络连接的伪客户端</li>\n<li>从AOF文件中分析并读取出一条写命令</li>\n<li>使用伪客户端执行被读出的写命令</li>\n<li>一直执行2，3直到AOF文件中的所有写命令都被处理完毕</li>\n</ol>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207113554356.png\" alt=\"image-20210207113554356\"></p>\n<h3 id=\"AOF重写\"><a href=\"#AOF重写\" class=\"headerlink\" title=\"AOF重写\"></a>AOF重写</h3><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。</p>\n<p>服务器创建一个新的AOF文件来<strong>替代</strong>现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但是新的AOF文件不会包含任何浪费空间的冗余命令</p>\n<h3 id=\"AOF文件重写的实现\"><a href=\"#AOF文件重写的实现\" class=\"headerlink\" title=\"AOF文件重写的实现\"></a>AOF文件重写的实现</h3><p>不需要对现有的AOF文件进行操作，是通过读取服务器当前的数据库状态来实现的</p>\n<p>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">aof_rewrite</span><span class=\"token punctuation\">(</span>new_aof_file_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#创建新的aof文件</span>\n    f<span class=\"token operator\">=</span>create_file<span class=\"token punctuation\">(</span>new_aof_file_name<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">#遍历数据库</span>\n    <span class=\"token keyword\">for</span> db <span class=\"token keyword\">in</span> redisServer<span class=\"token punctuation\">.</span>db<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">#忽略空数据库</span>\n        <span class=\"token keyword\">if</span> db<span class=\"token punctuation\">.</span>is_empty<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">continue</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#写入SELECT命令，指定数据库号码</span>\n        f<span class=\"token punctuation\">.</span>write_command<span class=\"token punctuation\">(</span><span class=\"token string\">\"SELECT\"</span><span class=\"token operator\">+</span>db<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">#遍历数据库中所有键</span>\n        <span class=\"token keyword\">for</span> key <span class=\"token keyword\">in</span> db<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\" spellcheck=\"true\">#忽略过期的键</span>\n            <span class=\"token keyword\">if</span> key<span class=\"token punctuation\">.</span>is_expired<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">continue</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">#根据键的类型对键进行重写</span>\n            <span class=\"token keyword\">if</span> key<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> String<span class=\"token punctuation\">:</span>\n                rewrite_string<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">elif</span> key<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> List<span class=\"token punctuation\">:</span>\n                rewrite_list<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">elif</span> key<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> Hash<span class=\"token punctuation\">:</span>\n                rewrite_hash<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">elif</span> key<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> Set<span class=\"token punctuation\">:</span>\n                rewrite_set<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">elif</span> key<span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> SortedSet<span class=\"token punctuation\">:</span>\n                rewrite_sortedSet<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n\n            <span class=\"token comment\" spellcheck=\"true\"># 如果键带有过期时间，过期时间也要重写</span>\n            <span class=\"token keyword\">if</span> key<span class=\"token punctuation\">.</span>have_expired_time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                rewrite_expired_time<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">#写入完毕，关闭文件            </span>\n    f<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">rewrite_string</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#使用GET命令获取字符串的值</span>\n    value<span class=\"token operator\">=</span>GET<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">#使用SET命令重写字符串键</span>\n    f<span class=\"token punctuation\">.</span>write_command<span class=\"token punctuation\">(</span>SET，key，value<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">rewrite_expired_time</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">#获取毫秒精度的键过期时间戳</span>\n    timestamp<span class=\"token operator\">=</span>get_expired_time_in_unixstamp<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">#使用PEXPIREAT命令重写键的过期时间</span>\n    f<span class=\"token punctuation\">.</span>write_command<span class=\"token punctuation\">(</span>PEXPIREAT，key，timestamp<span class=\"token punctuation\">)</span></code></pre>\n<h3 id=\"AOF后台重写\"><a href=\"#AOF后台重写\" class=\"headerlink\" title=\"AOF后台重写\"></a>AOF后台重写</h3><p>因为aof_rewrite函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞</p>\n<p>因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求。</p>\n<p>所以决定将AOF重写程序放到<strong>子进程</strong>中执行</p>\n<ul>\n<li>子进程在进行AOF重写期间，服务器进程可以进行处理命令请求</li>\n<li>子进程带有服务器进程的<strong>数据副本</strong>，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性</li>\n</ul>\n<p>但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库<strong>状态不一致</strong></p>\n<h4 id=\"AOF重写缓冲区\"><a href=\"#AOF重写缓冲区\" class=\"headerlink\" title=\"AOF重写缓冲区\"></a>AOF重写缓冲区</h4><p>为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，会同时将这个命令发送给<strong>AOF缓冲区和AOF重写缓冲区</strong></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207114138147.png\" alt=\"image-20210207114138147\"></p>\n<p>在子进程执行AOF重写期间，服务器进程执行:</p>\n<ol>\n<li>执行客户端发来的指令</li>\n<li>将执行后的写命令追加到AOF缓冲区</li>\n<li>将执行后的写命令追加到AOF重写缓冲区</li>\n</ol>\n<p>这样一来可以<strong>保证</strong></p>\n<ul>\n<li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。</li>\n<li>从创建子进程开始，服务器执行的所有写命都会被记录到AOF重写缓冲区里面。</li>\n</ul>\n<p>当子进程完成AOF重写工作之后，它  会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p>\n<ul>\n<li>将AOF重写缓冲区中的所有内容重写到新AOF文件中，这时新AOF文件保存的数据库状态将<strong>和服务器当前的数据库状态一致</strong>。</li>\n<li>对新的AOF文件进行改名，原子地(atomic)覆盖现有地AOF文件，完成<strong>新旧两个AOF文件地替换</strong>。</li>\n</ul>\n<p>这个信号处理函数执行完毕后，父进程可以继续像往常一样接收命令请求了</p>\n<p>在整个AOF后台重写过程中，只有<strong>信号处理函数执行时会对服务器进程（父进程）造成阻塞</strong>，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。</p>\n<h1 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h1><h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。</p>\n<p>一个应用往往会部署在多台机器上（多节点），在某些场景中，多个进程必须以互斥的方式独占共享资源。因此需要使用分布式锁</p>\n<p>分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源，一般来说，分布式锁需要满足的特性有这么几点：</p>\n<p>1、互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；</p>\n<p>2、高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；</p>\n<p>3、防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；</p>\n<p>4、独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了；</p>\n<h2 id=\"setnx（set-if-not-exists\"><a href=\"#setnx（set-if-not-exists\" class=\"headerlink\" title=\"setnx（set if not exists)\"></a>setnx（set if not exists)</h2><pre><code>SETNX key value</code></pre>\n<p>SET if Not eXists(如果不存在，则 SET)</p>\n<p>命令在设置成功时返回 1 ，设置失败时返回 0 。</p>\n<p>用来实现Redis锁机制，一个进程进来占坑，用完后再调用del指令释放坑</p>\n<p>只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作。</p>\n<p><strong>中间代码异常</strong></p>\n<p>如果逻辑执行到中间出现异常，可能导致del指令没有被调用，就会陷入死锁，锁永远得不到释放</p>\n<p>可以再拿到锁以后再给锁加上一个过期时间，比如5s，这样即使中间出现异常也可以保证5s后锁会自动释放</p>\n<pre class=\" language-redis\"><code class=\"language-redis\">setnx tongji4m3 true\n\nexpire tongji4m3 5\n\ndel tongji4m3</code></pre>\n<p><strong>expire异常</strong></p>\n<p>如果在setnx和expire之间服务器出现问题，导致expire得不到执行，也会死锁</p>\n<p>根源在于setnx和expire不是一条原子指令，但又不能用事务解决，因为expire依赖与setnx的执行结果，如果setnx没抢到锁，expire是不应该执行的，而事务没有if-else分支逻辑</p>\n<p>Redis支持set指令的扩展参数，使得setnx和expire指令可以一起执行，形成原子指令</p>\n<pre><code>SETEX key seconds value\n\nSET key value [EX seconds] [PX milliseconds] [NX|XX]\nset tongji4m3 true ex 5 nx\nNX:只在键不存在时， 才对键进行设置操作。\nXX:只在键已经存在时， 才对键进行设置操作。</code></pre>\n<p>将值 <code>value</code> 关联到 <code>key</code> ，并将 <code>key</code> 的生存时间设为 <code>seconds</code> (以秒为单位)。</p>\n<p>如果 <code>key</code> 已经存在，<code>setex</code>命令将覆写旧值。</p>\n<p>有小伙伴肯定会疑惑万一set value 成功 set time失败，那不就傻了么，这啊Redis官网想到了。</p>\n<p><code>setex</code>是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成。</p>\n<p>单机加锁或synchronized就够了</p>\n<p>但如果线程挂了,那锁就一直在那无法得到释放，后面的线程也永远得不到锁，又死锁了。</p>\n<p>setex设置一个过期时间，就算线程1挂了，也会在失效时间到了，自动释放。</p>\n<p><strong>超时问题</strong></p>\n<p>如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，会导致第一个线程持有的锁过期了而临界区的逻辑还没执行完</p>\n<p>Redis分布式锁不能用于较长时间的任务</p>\n<p>将set指令的value参数设置为随机数，释放锁时先匹配随机数是否一致，然后再删除key，确保当前线程持有的锁不会被其他线程释放，除非这个锁是因为过期了而被服务器自己释放的</p>\n<p>但是匹配value和删除key不是一个原子操作，需要要Lua脚本处理，他保证多个指令的原子性执行</p>\n<p><strong>可重入性</strong></p>\n<p>线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，就是可重入锁</p>\n<p>分布式锁要支持可重入，则要使用线程的Threadlocal变量存储当前持有锁的计数</p>\n<h3 id=\"怎么释放锁\"><a href=\"#怎么释放锁\" class=\"headerlink\" title=\"怎么释放锁\"></a>怎么释放锁</h3><p>释放锁的命令就简单了，直接删除key就行，但我们前面说了，因为分布式锁必须由锁的持有者自己释放，所以我们必须先确保当前释放锁的线程是持有者，没问题了再删除，这样一来，就变成两个步骤了，似乎又违背了原子性了，怎么办呢？</p>\n<p>不慌，我们可以用lua脚本把两步操作做拼装</p>\n<h2 id=\"redisson\"><a href=\"#redisson\" class=\"headerlink\" title=\"redisson\"></a>redisson</h2><p>redisson的锁，就实现了可重入</p>\n<pre class=\" language-java\"><code class=\"language-java\">ThreadPoolExecutor threadPoolExecutor <span class=\"token operator\">=</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span>inventory<span class=\"token punctuation\">,</span> inventory<span class=\"token punctuation\">,</span> 10L<span class=\"token punctuation\">,</span> SECONDS<span class=\"token punctuation\">,</span> linkedBlockingQueue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> start <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nConfig config <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Config</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconfig<span class=\"token punctuation\">.</span><span class=\"token function\">useSingleServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"redis://127.0.0.1:6379\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">final</span> RedissonClient client <span class=\"token operator\">=</span> Redisson<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">final</span> RLock lock <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">getLock</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lock1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> NUM<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    threadPoolExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            inventory<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>inventory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">long</span> end <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"执行线程数:\"</span> <span class=\"token operator\">+</span> NUM <span class=\"token operator\">+</span> <span class=\"token string\">\"   总耗时:\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>end <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"  库存数为:\"</span> <span class=\"token operator\">+</span> inventory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> RLock <span class=\"token function\">getLock</span><span class=\"token punctuation\">(</span>String name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RedissonLock</span><span class=\"token punctuation\">(</span>connectionManager<span class=\"token punctuation\">.</span><span class=\"token function\">getCommandExecutor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token function\">RedissonLock</span><span class=\"token punctuation\">(</span>CommandAsyncExecutor commandExecutor<span class=\"token punctuation\">,</span> String name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>commandExecutor<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//命令执行器</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>commandExecutor <span class=\"token operator\">=</span> commandExecutor<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//UUID字符串</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> commandExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">getConnectionManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//内部锁过期时间</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>internalLockLeaseTime <span class=\"token operator\">=</span> commandExecutor<span class=\"token punctuation\">.</span>\n                <span class=\"token function\">getConnectionManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getCfg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLockWatchdogTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>entryName <span class=\"token operator\">=</span> id <span class=\"token operator\">+</span> <span class=\"token string\">\":\"</span> <span class=\"token operator\">+</span> name<span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"加锁\"><a href=\"#加锁\" class=\"headerlink\" title=\"加锁\"></a>加锁</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> leaseTime<span class=\"token punctuation\">,</span> TimeUnit unit<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//当前线程ID</span>\n    <span class=\"token keyword\">long</span> threadId <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//尝试获取锁</span>\n    Long ttl <span class=\"token operator\">=</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>leaseTime<span class=\"token punctuation\">,</span> unit<span class=\"token punctuation\">,</span> threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果ttl为空，则证明获取锁成功</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ttl <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果获取锁失败，则订阅到对应这个锁的channel</span>\n    RFuture<span class=\"token operator\">&lt;</span>RedissonLockEntry<span class=\"token operator\">></span> future <span class=\"token operator\">=</span> <span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span>threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    commandExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">syncSubscription</span><span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//再次尝试获取锁</span>\n            ttl <span class=\"token operator\">=</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>leaseTime<span class=\"token punctuation\">,</span> unit<span class=\"token punctuation\">,</span> threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//ttl为空，说明成功获取锁，返回</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ttl <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//ttl大于0 则等待ttl时间后继续尝试获取</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ttl <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">getEntry</span><span class=\"token punctuation\">(</span>threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>ttl<span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">getEntry</span><span class=\"token punctuation\">(</span>threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//取消对channel的订阅</span>\n        <span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">,</span> threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//get(lockAsync(leaseTime, unit));</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"获取锁\"><a href=\"#获取锁\" class=\"headerlink\" title=\"获取锁\"></a>获取锁</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> RFuture<span class=\"token operator\">&lt;</span>Long<span class=\"token operator\">></span> <span class=\"token function\">tryAcquireAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> leaseTime<span class=\"token punctuation\">,</span> TimeUnit unit<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> threadId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//如果带有过期时间，则按照普通方式获取锁</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leaseTime <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">tryLockInnerAsync</span><span class=\"token punctuation\">(</span>leaseTime<span class=\"token punctuation\">,</span> unit<span class=\"token punctuation\">,</span> threadId<span class=\"token punctuation\">,</span> RedisCommands<span class=\"token punctuation\">.</span>EVAL_LONG<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//先按照30秒的过期时间来执行获取锁的方法</span>\n    RFuture<span class=\"token operator\">&lt;</span>Long<span class=\"token operator\">></span> ttlRemainingFuture <span class=\"token operator\">=</span> <span class=\"token function\">tryLockInnerAsync</span><span class=\"token punctuation\">(</span>\n        commandExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">getConnectionManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getCfg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLockWatchdogTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">,</span> threadId<span class=\"token punctuation\">,</span> RedisCommands<span class=\"token punctuation\">.</span>EVAL_LONG<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间</span>\n    ttlRemainingFuture<span class=\"token punctuation\">.</span><span class=\"token function\">addListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FutureListener</span><span class=\"token operator\">&lt;</span>Long<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">operationComplete</span><span class=\"token punctuation\">(</span>Future<span class=\"token operator\">&lt;</span>Long<span class=\"token operator\">></span> future<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>future<span class=\"token punctuation\">.</span><span class=\"token function\">isSuccess</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            Long ttlRemaining <span class=\"token operator\">=</span> future<span class=\"token punctuation\">.</span><span class=\"token function\">getNow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// lock acquired</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ttlRemaining <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">scheduleExpirationRenewal</span><span class=\"token punctuation\">(</span>threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ttlRemainingFuture<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"底层加锁逻辑\"><a href=\"#底层加锁逻辑\" class=\"headerlink\" title=\"底层加锁逻辑\"></a>底层加锁逻辑</h3><p>你可能会想这么多操作，在一起不是原子性不还是有问题么？</p>\n<p>大佬们肯定想得到呀，所以还是LUA，他使用了Hash的数据结构。</p>\n<p>主要是判断锁是否存在，存在就设置过期时间，如果锁已经存在了，那对比一下线程，线程是一个那就证明可以重入，锁在了，但是不是当前线程，证明别人还没释放，那就把剩余时间返回，加锁失败。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> RFuture<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">tryLockInnerAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> leaseTime<span class=\"token punctuation\">,</span> TimeUnit unit<span class=\"token punctuation\">,</span>     \n                            <span class=\"token keyword\">long</span> threadId<span class=\"token punctuation\">,</span> RedisStrictCommand<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> command<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//过期时间</span>\n        internalLockLeaseTime <span class=\"token operator\">=</span> unit<span class=\"token punctuation\">.</span><span class=\"token function\">toMillis</span><span class=\"token punctuation\">(</span>leaseTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> commandExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">evalWriteAsync</span><span class=\"token punctuation\">(</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> LongCodec<span class=\"token punctuation\">.</span>INSTANCE<span class=\"token punctuation\">,</span> command<span class=\"token punctuation\">,</span>\n                  <span class=\"token comment\" spellcheck=\"true\">//如果锁不存在，则通过hset设置它的值，并设置过期时间</span>\n                  <span class=\"token string\">\"if (redis.call('exists', KEYS[1]) == 0) then \"</span> <span class=\"token operator\">+</span>\n                      <span class=\"token string\">\"redis.call('hset', KEYS[1], ARGV[2], 1); \"</span> <span class=\"token operator\">+</span>\n                      <span class=\"token string\">\"redis.call('pexpire', KEYS[1], ARGV[1]); \"</span> <span class=\"token operator\">+</span>\n                      <span class=\"token string\">\"return nil; \"</span> <span class=\"token operator\">+</span>\n                  <span class=\"token string\">\"end; \"</span> <span class=\"token operator\">+</span>\n                  <span class=\"token comment\" spellcheck=\"true\">//如果锁已存在，并且锁的是当前线程，则通过hincrby给数值递增1</span>\n                  <span class=\"token string\">\"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \"</span> <span class=\"token operator\">+</span>\n                      <span class=\"token string\">\"redis.call('hincrby', KEYS[1], ARGV[2], 1); \"</span> <span class=\"token operator\">+</span>\n                      <span class=\"token string\">\"redis.call('pexpire', KEYS[1], ARGV[1]); \"</span> <span class=\"token operator\">+</span>\n                      <span class=\"token string\">\"return nil; \"</span> <span class=\"token operator\">+</span>\n                  <span class=\"token string\">\"end; \"</span> <span class=\"token operator\">+</span>\n                  <span class=\"token comment\" spellcheck=\"true\">//如果锁已存在，但并非本线程，则返回过期时间ttl</span>\n                  <span class=\"token string\">\"return redis.call('pttl', KEYS[1]);\"</span><span class=\"token punctuation\">,</span>\n        Collections<span class=\"token punctuation\">.</span>&lt;Object<span class=\"token operator\">></span><span class=\"token function\">singletonList</span><span class=\"token punctuation\">(</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n                internalLockLeaseTime<span class=\"token punctuation\">,</span> <span class=\"token function\">getLockName</span><span class=\"token punctuation\">(</span>threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"解锁\"><a href=\"#解锁\" class=\"headerlink\" title=\"解锁\"></a>解锁</h3><p>锁的释放主要是publish释放锁的信息，然后做校验，一样会判断是否当前线程，成功就释放锁，还有个<strong>hincrby</strong>递减的操作，锁的值大于0说明是可重入锁，那就刷新过期时间。</p>\n<p>如果值小于0了，那删掉Key释放锁。</p>\n<p>是不是又和AQS很像了？</p>\n<p>AQS就是通过一个volatile修饰status去看锁的状态，也会看数值判断是否是可重入的。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> RFuture<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">unlockAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> threadId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> RPromise<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RedissonPromise</span><span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//解锁方法</span>\n    RFuture<span class=\"token operator\">&lt;</span>Boolean<span class=\"token operator\">></span> future <span class=\"token operator\">=</span> <span class=\"token function\">unlockInnerAsync</span><span class=\"token punctuation\">(</span>threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    future<span class=\"token punctuation\">.</span><span class=\"token function\">addListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FutureListener</span><span class=\"token operator\">&lt;</span>Boolean<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">operationComplete</span><span class=\"token punctuation\">(</span>Future<span class=\"token operator\">&lt;</span>Boolean<span class=\"token operator\">></span> future<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>future<span class=\"token punctuation\">.</span><span class=\"token function\">isSuccess</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">cancelExpirationRenewal</span><span class=\"token punctuation\">(</span>threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                result<span class=\"token punctuation\">.</span><span class=\"token function\">tryFailure</span><span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">.</span><span class=\"token function\">cause</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//获取返回值</span>\n            Boolean opStatus <span class=\"token operator\">=</span> future<span class=\"token punctuation\">.</span><span class=\"token function\">getNow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果返回空，则证明解锁的线程和当前锁不是同一个线程，抛出异常</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opStatus <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                IllegalMonitorStateException cause <span class=\"token operator\">=</span> \n                    <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalMonitorStateException</span><span class=\"token punctuation\">(</span>\"\n                        attempt to unlock lock<span class=\"token punctuation\">,</span> not locked by current thread by node id<span class=\"token operator\">:</span> \"\n                        <span class=\"token operator\">+</span> id <span class=\"token operator\">+</span> <span class=\"token string\">\" thread-id: \"</span> <span class=\"token operator\">+</span> threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                result<span class=\"token punctuation\">.</span><span class=\"token function\">tryFailure</span><span class=\"token punctuation\">(</span>cause<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//解锁成功，取消刷新过期时间的那个定时任务</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opStatus<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">cancelExpirationRenewal</span><span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            result<span class=\"token punctuation\">.</span><span class=\"token function\">trySuccess</span><span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">protected</span> RFuture<span class=\"token operator\">&lt;</span>Boolean<span class=\"token operator\">></span> <span class=\"token function\">unlockInnerAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> threadId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> commandExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">evalWriteAsync</span><span class=\"token punctuation\">(</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> LongCodec<span class=\"token punctuation\">.</span>INSTANCE<span class=\"token punctuation\">,</span> EVAL<span class=\"token punctuation\">,</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">//如果锁已经不存在， 发布锁释放的消息</span>\n            <span class=\"token string\">\"if (redis.call('exists', KEYS[1]) == 0) then \"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"redis.call('publish', KEYS[2], ARGV[1]); \"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"return 1; \"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"end;\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果释放锁的线程和已存在锁的线程不是同一个线程，返回null</span>\n            <span class=\"token string\">\"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then \"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"return nil;\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"end; \"</span> <span class=\"token operator\">+</span>\n            <span class=\"token comment\" spellcheck=\"true\">//通过hincrby递减1的方式，释放一次锁</span>\n            <span class=\"token comment\" spellcheck=\"true\">//若剩余次数大于0 ，则刷新过期时间</span>\n            <span class=\"token string\">\"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); \"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"if (counter > 0) then \"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"redis.call('pexpire', KEYS[1], ARGV[2]); \"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"return 0; \"</span> <span class=\"token operator\">+</span>\n            <span class=\"token comment\" spellcheck=\"true\">//否则证明锁已经释放，删除key并发布锁释放的消息</span>\n            <span class=\"token string\">\"else \"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"redis.call('del', KEYS[1]); \"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"redis.call('publish', KEYS[2], ARGV[1]); \"</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">\"return 1; \"</span><span class=\"token operator\">+</span>\n            <span class=\"token string\">\"end; \"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"return nil;\"</span><span class=\"token punctuation\">,</span>\n    Arrays<span class=\"token punctuation\">.</span>&lt;Object<span class=\"token operator\">></span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">getChannelName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n        LockPubSub<span class=\"token punctuation\">.</span>unlockMessage<span class=\"token punctuation\">,</span> internalLockLeaseTime<span class=\"token punctuation\">,</span> <span class=\"token function\">getLockName</span><span class=\"token punctuation\">(</span>threadId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"Redis简介\"><a href=\"#Redis简介\" class=\"headerlink\" title=\"Redis简介\"></a>Redis简介</h1><p>它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。</p>\n<p>命令不区分大小写，而key区分大小写</p>\n<p>Redis所有的数据结构都以唯一的key字符串作为名称，不同类型的数据结构的差异就在于value的结构不一样</p>\n<p>所有数据结构都可以设置过期时间</p>\n<h2 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h2><h3 id=\"官方介绍\"><a href=\"#官方介绍\" class=\"headerlink\" title=\"官方介绍\"></a>官方介绍</h3><p>Remote Dictionary Service(远程词典服务)，是一个存储中间件</p>\n<p>Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。</p>\n<p>Redis是一个开源的内存中的数据结构存储系统，它可以用作：<strong>数据库、缓存和消息中间件</strong>。</p>\n<p>它支持多种类型的数据结构，如字符串（Strings），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。<strong>其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。</strong></p>\n<p>Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p>\n<p>Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</p>\n<h3 id=\"Redis为什么快\"><a href=\"#Redis为什么快\" class=\"headerlink\" title=\"Redis为什么快\"></a>Redis为什么快</h3><ul>\n<li>redis是基于内存的，数据存在内存中，内存的读写速度非常快；它类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li>\n<li>数据结构简单，对数据操作也简单，有高效的数据结构。底层多种数据结构支持不同的数据类型，支持 Redis 存储不同的数据</li>\n<li>采用单线程，避免了不必要的上下文切换和竞争条件，不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>\n<li>redis使用I/O多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在IO上浪费一点时间。</li>\n</ul>\n<h2 id=\"Redis和memcached的区别\"><a href=\"#Redis和memcached的区别\" class=\"headerlink\" title=\"Redis和memcached的区别\"></a>Redis和memcached的区别</h2><ul>\n<li>Redis 支持复杂的数据结构，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作</li>\n<li>Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务</li>\n<li>性能方面，Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Remcached，还是稍有逊色。</li>\n<li>Redis ⽀持持久化，所以 Redis 不仅仅可以⽤作缓存，也可以⽤作 NoSQL 数据库。</li>\n</ul>\n<h2 id=\"为什么Redis是单线程的\"><a href=\"#为什么Redis是单线程的\" class=\"headerlink\" title=\"为什么Redis是单线程的\"></a>为什么Redis是单线程的</h2><p>这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行</p>\n<p> 单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p>\n<p> 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间</p>\n<p><strong>1.官方答案</strong></p>\n<p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>\n<p><strong>2.性能指标</strong></p>\n<p>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n<p><strong>3.详细原因</strong></p>\n<p><strong>1）不需要各种锁的性能消耗</strong></p>\n<p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p>\n<p>一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p>\n<p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p>\n<p><strong>2）单线程多进程集群方案</strong></p>\n<p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p>\n<p><strong>所以单线程、多进程的集群不失为一个时髦的解决方案。</strong></p>\n<p><strong>3）CPU消耗</strong></p>\n<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p>\n<p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p>\n<p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p>\n<h2 id=\"Redis单线程的优劣势\"><a href=\"#Redis单线程的优劣势\" class=\"headerlink\" title=\"Redis单线程的优劣势\"></a>Redis单线程的优劣势</h2><p><strong>单进程单线程优势</strong></p>\n<ol>\n<li>代码更清晰，处理逻辑更简单</li>\n<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li>\n<li>不存在多进程或者多线程导致的切换而消耗CPU</li>\n</ol>\n<p><strong>单进程单线程弊端</strong></p>\n<ol>\n<li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li>\n</ol>\n<h2 id=\"为什么快\"><a href=\"#为什么快\" class=\"headerlink\" title=\"为什么快\"></a>为什么快</h2><p>Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而  <strong>I/O 多路复用</strong> 就是为了解决这个问题而出现的。</p>\n<p>redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p>\n<ul>\n<li>优先选择时间复杂度为O(1)的IO复用函数作为底层实现，例如epoll</li>\n<li>以select系统调用为保底，时间复杂度O(N)</li>\n<li>基于react设计模式监听IO事件</li>\n</ul>\n<p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p>\n<p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"服务器中的数据库\"><a href=\"#服务器中的数据库\" class=\"headerlink\" title=\"服务器中的数据库\"></a>服务器中的数据库</h3><pre><code class=\"c\">struct redisServer\n{\n    int dbnum;//服务器的数据库数量\n    redisDb *db; //一个数组，保存着服务器中的所有数据库 默认16\n}</code></pre>\n<h3 id=\"切换数据库\"><a href=\"#切换数据库\" class=\"headerlink\" title=\"切换数据库\"></a>切换数据库</h3><p>每个Redis客户端都有个目标数据库，每当客户端执行数据库读写命令时，目标数据库就成为这些命令的操作对象.默认目标数据库为0号数据库</p>\n<pre><code class=\"c\">typedef struct redisClient\n{\n    redisDb * db;//记录客户端当前使用的数据库\n}redisClient;</code></pre>\n<h3 id=\"数据库键空间\"><a href=\"#数据库键空间\" class=\"headerlink\" title=\"数据库键空间\"></a>数据库键空间</h3><pre><code class=\"c\">typedef struct redisDb\n{\n    dict *dict;//数据库键空间，保存着数据库中的所有键值对\n} redisDb;</code></pre>\n<p>键空间的键是一个字符串对象，值可以是字符串对象，列表对象，哈希表对象，集合对象，有序集合对象</p>\n<p>所有针对数据库的操作，都是通过对键空间字典进行操作实现的</p>\n<h4 id=\"添加新键\"><a href=\"#添加新键\" class=\"headerlink\" title=\"添加新键\"></a>添加新键</h4><p>就是将新键值对添加到键空间字典里面</p>\n<h4 id=\"读写键空间时的维护操作\"><a href=\"#读写键空间时的维护操作\" class=\"headerlink\" title=\"读写键空间时的维护操作\"></a>读写键空间时的维护操作</h4><ul>\n<li>在读取一个键后(读写操作都要对键进行读取)，服务器会根据键是否存在来更新服务器的键空间命中次数</li>\n<li>在读取一个键后，会更新LRU时间，可以计算键的闲置时间</li>\n<li>在读取一个键若发现该键已过期，则会先删除过期键</li>\n<li>在对被监视的键进行修改后，会标记为脏，让事务程序注意该键已经被修改</li>\n</ul>\n<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><p>查询某个Key对应的数据，Redis缓存中没有相应的数据，则直接到数据库中查询。数据库中也不存在要查询的数据，则数据库会返回空，而Redis也不会缓存这个空结果。这就造成每次通过这样的Key去查询数据都会直接到数据库中查询，Redis不会缓存空结果。这就造成了缓存穿透的问题。</p>\n<p>一些恶意的请求会故意查询不存在的 key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><ol>\n<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li>\n<li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li>\n<li>根据明显错误的key在逻辑层就就行验证。</li>\n<li>分析用户行为，是否为故意请求或者爬虫、攻击者。针对用户访问做限制。</li>\n</ol>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>\n<p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，好像蛮力击穿一样。</p>\n<p>击穿和穿透不同，穿透的意思是想法绕过redis去使得数据库崩掉。而击穿你可以理解为正面刚击穿，这种通常为大量并发对一个key进行大规模的读写操作。<strong>这个key在缓存失效期间大量请求数据库</strong>，对数据库造成太大压力使得数据库崩掉。就比如在秒杀场景下10000块钱的mac和100块的mac这个100块的那个订单肯定会被抢到爆，不断的请求(当然具体秒杀有自己处理方式这里只是举个例子)。所以缓存击穿就是针对某个常用key大量请求导致数据库崩溃。</p>\n<h3 id=\"解决-1\"><a href=\"#解决-1\" class=\"headerlink\" title=\"解决\"></a>解决</h3><h4 id=\"使用互斥锁\"><a href=\"#使用互斥锁\" class=\"headerlink\" title=\"使用互斥锁\"></a>使用互斥锁</h4><p>在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p>\n<p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p>\n<pre><code class=\"java\">public String get(key) {\n      String value = redis.get(key);\n      if (value == null) \n      { \n          //代表缓存值过期\n          //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db\n          if (redis.setnx(key_mutex， 1， 3 * 60) == 1) \n          {  \n              //代表设置成功\n              value = db.get(key);\n              redis.set(key， value， expire_secs);\n              redis.del(key_mutex);\n          } \n          else \n          {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可\n              sleep(50);\n              get(key);  //重试\n          }\n      } \n    else \n    {\n        return value;      \n    }\n }</code></pre>\n<h4 id=\"热点key永不过期\"><a href=\"#热点key永不过期\" class=\"headerlink\" title=\"热点key永不过期\"></a>热点key永不过期</h4><h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>\n<h3 id=\"解决-2\"><a href=\"#解决-2\" class=\"headerlink\" title=\"解决\"></a>解决</h3><ul>\n<li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</li>\n<li>做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期</li>\n<li>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li>\n<li>热点数据可以考虑不失效</li>\n</ul>\n<h1 id=\"过期键删除策略\"><a href=\"#过期键删除策略\" class=\"headerlink\" title=\"过期键删除策略\"></a>过期键删除策略</h1><h2 id=\"过期键实现\"><a href=\"#过期键实现\" class=\"headerlink\" title=\"过期键实现\"></a>过期键实现</h2><h3 id=\"设置过期时间\"><a href=\"#设置过期时间\" class=\"headerlink\" title=\"设置过期时间\"></a>设置过期时间</h3><ol>\n<li>EXPIRE 设置过期时间，单位为秒</li>\n<li>PEXPIRE 设置过期时间，单位为毫秒</li>\n<li>EXPIREAT 设置过期时间为秒数时间戳</li>\n<li>PEXPIREAT 设置过期时间为毫秒数时间戳</li>\n</ol>\n<p>最后都是转换为PEXPIREAT来执行的</p>\n<h3 id=\"保存过期时间\"><a href=\"#保存过期时间\" class=\"headerlink\" title=\"保存过期时间\"></a>保存过期时间</h3><pre><code class=\"c\">typedef struct redisDb\n{\n    dict *dict;//数据库键空间，保存着数据库中的所有键值对\n    dict *expires;//保存了数据库中所有键的过期时间，过期字典\n    //key是一个指针，指向键空间某个键\n    //value为long long类型的过期时间，一个毫秒精度的UNIX时间戳\n} redisDb;</code></pre>\n<p>键空间的键和过期字典的键都指向同一个键对象，不会出现任何重复对象，也不会浪费任何空间</p>\n<pre><code class=\"python\">def PEXPIREAT(key，expire_time_in_ms)\n{\n     #如果给定的键不存在键空间，那么不能设置过期时间\n    if key not in redisDb.dict:\n        return 0\n    #在过期字典中关联键和过期时间\n    redisDb.expires[key] = expire_time_in_ms\n    # 过期时间设置成功\n    return 1\n}</code></pre>\n<h3 id=\"移除过期时间\"><a href=\"#移除过期时间\" class=\"headerlink\" title=\"移除过期时间\"></a>移除过期时间</h3><pre><code class=\"python\">def PERSIST(key):\n    #如果给定的键不存在或没设置过期时间，那么直接返回\n     if key not in redisDb.expires:\n        return 0\n    #移除过期字典中给定键的键值对关联\n    redisDb.expires.remove(key)\n    #移除成功\n    return 1</code></pre>\n<h3 id=\"计算并返回剩余生存时间\"><a href=\"#计算并返回剩余生存时间\" class=\"headerlink\" title=\"计算并返回剩余生存时间\"></a>计算并返回剩余生存时间</h3><pre><code class=\"python\">def PTTL(key):\n    #如果给定的键不存在数据库\n    if key not in redisDb.dict:\n        return -2\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n\n    if expire_time_in_ms is None:\n        return -1\n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n    return (expire_time_in_ms - now_ms)</code></pre>\n<pre><code class=\"python\">def TTL(key):\n    ttl_in_ms = PTTL(key)\n    if ttl_in_ms&lt;0:\n        //处理为-2，-1的异常情况\n        return ttl_in_ms\n    else:\n        #将毫秒转为秒\n        return ms_to_sec(ttl_in_ms)\n</code></pre>\n<h3 id=\"过期键的判断\"><a href=\"#过期键的判断\" class=\"headerlink\" title=\"过期键的判断\"></a>过期键的判断</h3><pre><code class=\"python\">def is_expired(key):\n    #尝试获取过期时间\n    #没有则为None\n    expire_time_in_ms=redisDb.expires.get(key)\n\n    if expire_time_in_ms is None:\n        return False\n\n    # 获取当前时间时间戳\n    now_ms=get_current_unix_timestamp_in_ms()\n\n    if  now_ms&gt;expire_time_in_ms:\n        return True # 已过期\n    else:\n        return False</code></pre>\n<h2 id=\"定时删除\"><a href=\"#定时删除\" class=\"headerlink\" title=\"定时删除\"></a>定时删除</h2><ul>\n<li><p>在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作</p>\n</li>\n<li><p>可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存</p>\n</li>\n<li><p>对CPU时间最不友好，在内存不紧张而CPU非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，对服务器的响应时间和吞吐量造成影响</p>\n</li>\n<li><p>不太现实</p>\n</li>\n</ul>\n<h2 id=\"惰性删除\"><a href=\"#惰性删除\" class=\"headerlink\" title=\"惰性删除\"></a>惰性删除</h2><ul>\n<li><p>每次取出键都会检查是否过期，过期则删除</p>\n</li>\n<li><p>只有在取出键时才会对键进行过期检查，对CPU时间最友好</p>\n</li>\n<li><p>对内存最不友好：如果一个键已过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。</p>\n</li>\n<li><p>会导致内存泄漏，无用的垃圾数据占用了大量内存。如日志，当不再使用时，会大量积压在数据库，用户以为自动删除了，其实还存在，则它们不会被删除，所占用的内存就不会释放。</p>\n</li>\n</ul>\n<h2 id=\"定期删除\"><a href=\"#定期删除\" class=\"headerlink\" title=\"定期删除\"></a>定期删除</h2><ul>\n<li>每隔一段时间进行检查，删除里面的过期键</li>\n<li>通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响；定期删除策略有效减少了因为过期键而带来的内存浪费。是前两种的整合与折中。</li>\n<li>必须合理地设置删除操作的执行时间和执行效率：太频繁或执行时间太长会退化为定时删除策略，反之则出现浪费内存的情况</li>\n</ul>\n<h2 id=\"Redis过期键删除策略\"><a href=\"#Redis过期键删除策略\" class=\"headerlink\" title=\"Redis过期键删除策略\"></a>Redis过期键删除策略</h2><p>配合使用<strong>惰性删除</strong>和<strong>定期删除</strong>两种</p>\n<h3 id=\"惰性删除策略的实现\"><a href=\"#惰性删除策略的实现\" class=\"headerlink\" title=\"惰性删除策略的实现\"></a>惰性删除策略的实现</h3><p>所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查，如果输入键已过期，则将输入键从数据库中删除</p>\n<p>采用expireIfNeeded函数，如果过期则将键删除。就像过滤器，在命令真正执行前，过滤掉过期的输入键，避免命令接触到过期键</p>\n<p>所以每个命令的实现函数必须能同时处理键存在和不存在两种情况</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104150550.png\" alt=\"image-20210207104150550\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104206293.png\" alt=\"image-20210207104206293\"></p>\n<h3 id=\"定期删除策略实现\"><a href=\"#定期删除策略实现\" class=\"headerlink\" title=\"定期删除策略实现\"></a>定期删除策略实现</h3><p>每当Redis服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键</p>\n<pre><code class=\"python\"># coding=utf-8\n# 默认每次检查的数据库数量\nDEFAULT_DB_NUMBERS = 16\n\n# 默认每个数据库检查的键数量\nDEFAULT_KEY_NUMBERS = 20\n\n# 全局变量，记录检查进度\n# 如果当前的activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数时，将从11号数据库开始查找并删除过期键\ncurrent_db = 0\n\n# 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键\ndef activeExpireCycle():\n    # 初始化要检查的数据库数量\n    # 以服务器的数据库数量为主\n    if serer.dbnum &lt; DEFAULT_DB_NUMBERS:\n        db_numbers = serer.dbnum\n    else:\n        db_numbers = DEFAULT_DB_NUMBERS\n\n    #遍历每个数据库\n    for i in range(db_numbers):\n        #如果current_db=服务器的数据库数量\n        #则表示已经遍历了服务器的所有数据库一次\n        #将current_db=重置为0，开始新一轮\n        if current_db==server.dbnum:\n            current_db=0\n\n        #获取当前要处理的数据库\n        redisDb=server.db[current_db]\n\n        #指向下一个要处理的数据库\n        current_db+=1\n\n        #检查数据库的键\n        for j in range(DEFAULT_KEY_NUMBERS):\n            #如果数据库中没有一个键带有过期时间，则跳过该数据库\n            if redisDb.expires.size()==0:\n                break\n\n            #随机获取一个带过期时间的键\n            key_with_ttl=redisDb.expires.get_random_key()\n\n            if is_expired(key_with_ttl):\n                delete_key(key_with_ttl)\n\n            # 已到达时间上限，停止处理\n            if reach_time_limit():\n                return </code></pre>\n<h1 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h1><h2 id=\"RDB持久化\"><a href=\"#RDB持久化\" class=\"headerlink\" title=\"RDB持久化\"></a>RDB持久化</h2><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p><strong>SAVE指令</strong>会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，所以当Save命令正在执行时，客户端发送的所有命令请求都会被阻塞</p>\n<p><strong>BGSAVE命令</strong>会派生出一个子进程，由它负责创建RDB文件，服务器进程(父进程)继续处理命令请求。</p>\n<p>1、在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝。服务器禁止SAVE与BGSAVE同时执行是为了避免父进程和子进程同时指向两个rdbSave调用，防止产生竞争条件。</p>\n<p>2、同样的道理，在BGSAVE执行期间，客户端的BGSAVE命令也会被服务器拒绝。</p>\n<p>3、另外，对于AOF持久化命令BGREWRITEAOF与BGSAVE也同样是互斥关系，如果BGSAVE正在执行，则BGREWRITEAOF命令会被延迟到BGSAVE执行完毕之后；而BGREWRITEAOF命令执行时，服务器会拒绝BGSAVE命令的执行。</p>\n<p>4、而事实上，因为BGREWRITEAOF命令与BGSAVE两个命令的实际工作都是由子进程执行，所以这两个命令在操作方面并没有冲突的地方，不能同时执行只是性能方面的考虑–并发处两个子进程，并且这两个子进程同时对磁盘进行大量读写。</p>\n<pre><code class=\"python\">def SAVE():\n    #创建RDB文件\n    rdbSave（）\n\ndef BGSAVE():\n    # 创建子进程\n    pid=fork()\n\n    if pid == 0:\n        # 子进程负责创建RDB文件\n        rdbSave（）\n        # 完成之后向父进程发送信号\n        signal_parent()\n    elif pid&gt;0:\n        # 父进程继续处理命令请求，并通过轮询等待子进程的信号\n        handle_request_and_wait_signal()\n    else:\n        # 处理出错情况\n        handle_fork_error()</code></pre>\n<h3 id=\"载入\"><a href=\"#载入\" class=\"headerlink\" title=\"载入\"></a>载入</h3><ul>\n<li>RDB文件的载入工作是服务器启动时自动进行的，只要Redis服务器在启动时检测到RDB文件存在，就会自动载入RDB文件</li>\n<li>如果服务器开启了AOF持久化功能，则优先使用AOF文件还原数据库状态</li>\n<li>只有未开启AOF持久化功能，才会使用RDB文件还原数据库状态</li>\n<li>服务器在载入RDB文件时会一直处于阻塞状态，直到载入工作完成</li>\n</ul>\n<h3 id=\"自动间隔性保存\"><a href=\"#自动间隔性保存\" class=\"headerlink\" title=\"自动间隔性保存\"></a>自动间隔性保存</h3><p>服务器每隔一段时间自动执行一次BGSAVE命令，可以设置多个保存条件，只要任意一个条件被满足，服务器就会执行BGSAVE指令</p>\n<pre><code class=\"c\">save 900 1\nsave 300 10\nsave 60 10000\n\n服务器在900秒内进行了至少1次修改\n服务器在300秒内进行了至少10次修改\n服务器在60秒内进行了至少10000次修改</code></pre>\n<h3 id=\"设置保存条件\"><a href=\"#设置保存条件\" class=\"headerlink\" title=\"设置保存条件\"></a>设置保存条件</h3><p>服务器程序根据save选项（可通过配置文件设置）所设置的保存条件，设置服务器状态的redisServer结构的saveparams属性</p>\n<pre><code class=\"c\">struct redisServer\n{\n    struct saveparam * saveparams;\n    long long dirty; //距离上一次成功执行BGSAVE之后，进行修改的次数\n    time_t lastsave; //上一次成功执行BGSAVE的时间\n};\n\nstruct saveparam\n{\n    time_t seconds;\n    int changes;\n}</code></pre>\n<h3 id=\"检查保存条件是否满足\"><a href=\"#检查保存条件是否满足\" class=\"headerlink\" title=\"检查保存条件是否满足\"></a>检查保存条件是否满足</h3><p>服务器周期性操作函数serverCron()默认每隔100ms执行一次</p>\n<p>其中一项工作就是检查save选项所设置的保存条件是否已经满足</p>\n<p>如果满足，则执行BGSAVE（）</p>\n<pre><code class=\"python\">def serverCron():\n    # 遍历所有保存条件\n    for saveparam in server.saveparams:\n        save_interval=unixtime_now() - server.lastsave\n\n        #如果数据库状态的修改次数超过条件所设置的次数\n        #并且距离上次保存的时间超过条件所设置的时间\n        #那么执行保存操作\n        if server.dirty &gt;= saveparam.changes and save_interval&gt;saveparam.seconds:\n            BGSAVE()</code></pre>\n<h3 id=\"RDB文件结构\"><a href=\"#RDB文件结构\" class=\"headerlink\" title=\"RDB文件结构\"></a>RDB文件结构</h3><h4 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h4><ol>\n<li>REDIS，通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否是RDB文件</li>\n<li>db_version，记录了版本号</li>\n<li>databases，包含任意个数据库以及他们的键值对数据。</li>\n<li>EOF，标志着RDB文件正文内容的结束</li>\n<li>check_sum，校验和，检查RDB文件是否有出错或损坏的情况。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum进行比对，已发行RDB文件是否损坏</li>\n</ol>\n<h4 id=\"databases\"><a href=\"#databases\" class=\"headerlink\" title=\"databases\"></a>databases</h4><p>每个非空数据库保存三部分：</p>\n<ol>\n<li>SELECTDB 常量，说明接下来会读取一个数据库号码</li>\n<li>db_number，读入后，调用SELECT指令，进行数据库切换，使得之后读入的键值对可以载入到正确的数据库之中</li>\n<li>key_value_pairs，保存了数据库中的所有键值对数据。包含过期时间。</li>\n</ol>\n<h4 id=\"key-value-pairs\"><a href=\"#key-value-pairs\" class=\"headerlink\" title=\"key_value_pairs\"></a>key_value_pairs</h4><ol>\n<li>TYPE记录了value的类型，代表了一种对象类型或底层编码。程序根据TYPE的值决定如何读入和解释value的数据</li>\n<li>key总是一个字符串对象</li>\n<li>value根据TYPE的指令保存相应类型的内容</li>\n<li>EXPIRETIME_MS常量，代表之后会读取一个以毫秒为单位的过期时间</li>\n<li>ms，保存键值对的过期时间，以毫秒为单位的UNIX时间戳</li>\n</ol>\n<h2 id=\"AOF持久化\"><a href=\"#AOF持久化\" class=\"headerlink\" title=\"AOF持久化\"></a>AOF持久化</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>AOF（Append Only File)</li>\n<li>通过保存<code>Redis</code>服务器所执行的写命令来记录数据库状态的</li>\n<li>被写入AOF文件的所有命令都是以Redis的命令请求协议格式（纯文本）保存的。</li>\n<li>服务器启动时，可以通过载入和执行<code>AOF文件</code>中保存的命令来还原服务器关闭之前的数据库状态</li>\n</ul>\n<h3 id=\"AOF持久化的实现\"><a href=\"#AOF持久化的实现\" class=\"headerlink\" title=\"AOF持久化的实现\"></a>AOF持久化的实现</h3><h4 id=\"命令追加\"><a href=\"#命令追加\" class=\"headerlink\" title=\"命令追加\"></a>命令追加</h4><p>服务器在执行完一个写命令后，会将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾:</p>\n<pre><code class=\"c\">struct redisServer\n{\n    // AOF缓冲区\n    sds aof_buf;\n}</code></pre>\n<h4 id=\"AOF文件的写入与同步\"><a href=\"#AOF文件的写入与同步\" class=\"headerlink\" title=\"AOF文件的写入与同步\"></a>AOF文件的写入与同步</h4><p>服务器进程是一个事件循环，循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。时间事件负责执行像serverCron函数这样需要定时运行的函数</p>\n<pre><code class=\"python\">def eventLoop()\n{\n    while True:\n        #处理文件事件，接收命令请求以及发送命令回复\n        #处理命令请求时可能会有新内容加入到aof_buf缓冲区中\n        processFileEvents()\n\n        #处理时间事件\n        processTimeEvents()\n\n        #考虑是否要将aof_buf缓冲区中的内容写入和保存到AOF文件里面\n        flushAppendOnlyFile()\n}</code></pre>\n<p><strong>写入</strong>：在现代操作系统中，当数据写入到文件中时，会调用write函数。操作系统会将写入数据暂时保存在一个内存缓存区中，等到缓冲区空间满的时候，才真正将缓冲区中的数据写入到磁盘中。</p>\n<p><strong>同步</strong>：同时系统也提供了同步函数（例如fsync)，它可以强制让操作系统立即将缓冲区中的数据写入到磁盘中。</p>\n<p>在每个事件循环都会调用flushAppendOnlyFile函数，flushAppendOnlyFile函数的行为由<strong>appendfsync</strong>的值决定：</p>\n<p><strong>always</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中，并同步AOF文件（把aof_buf数据写入并同步到AOF文件中）</p>\n<p><strong>everysec</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，并且每隔一秒就在子线程中对AOF文件进行一次同步(每隔一秒同步)。</p>\n<p><strong>no</strong>：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，至于什么时候同步，由操作系统控制（不知道啥时候同步）。在该模式下的flushAppendOnlyFile的调用不需要同步执行。</p>\n<p>上述配置的值，直接决定服务器的效率与安全性，当always时，安全性最高，但是效率最低；no时效率最高，安全性最低；everysec居中：从效率上来讲，everysec模式足够快，并且就算出现了故障停机，数据库也只丢失一秒钟的命令数据。系统默认配置是everysec。</p>\n<h3 id=\"AOF文件的载入与数据还原\"><a href=\"#AOF文件的载入与数据还原\" class=\"headerlink\" title=\"AOF文件的载入与数据还原\"></a>AOF文件的载入与数据还原</h3><p>只要读入并重新执行一遍<code>AOF文件</code>里面保存的写命令，就可以还原服务器关闭之前的数据库状态</p>\n<ol>\n<li>创建一个不带网络连接的伪客户端</li>\n<li>从AOF文件中分析并读取出一条写命令</li>\n<li>使用伪客户端执行被读出的写命令</li>\n<li>一直执行2，3直到AOF文件中的所有写命令都被处理完毕</li>\n</ol>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207113554356.png\" alt=\"image-20210207113554356\"></p>\n<h3 id=\"AOF重写\"><a href=\"#AOF重写\" class=\"headerlink\" title=\"AOF重写\"></a>AOF重写</h3><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。</p>\n<p>服务器创建一个新的AOF文件来<strong>替代</strong>现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但是新的AOF文件不会包含任何浪费空间的冗余命令</p>\n<h3 id=\"AOF文件重写的实现\"><a href=\"#AOF文件重写的实现\" class=\"headerlink\" title=\"AOF文件重写的实现\"></a>AOF文件重写的实现</h3><p>不需要对现有的AOF文件进行操作，是通过读取服务器当前的数据库状态来实现的</p>\n<p>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。</p>\n<pre><code class=\"python\">def aof_rewrite(new_aof_file_name):\n    #创建新的aof文件\n    f=create_file(new_aof_file_name)\n    #遍历数据库\n    for db in redisServer.db:\n        #忽略空数据库\n        if db.is_empty():continue\n\n        #写入SELECT命令，指定数据库号码\n        f.write_command(&quot;SELECT&quot;+db.id)\n\n        #遍历数据库中所有键\n        for key in db:\n            #忽略过期的键\n            if key.is_expired():continue\n\n            #根据键的类型对键进行重写\n            if key.type == String:\n                rewrite_string(key)\n            elif key.type == List:\n                rewrite_list(key)\n            elif key.type == Hash:\n                rewrite_hash(key)\n            elif key.type == Set:\n                rewrite_set(key)\n            elif key.type == SortedSet:\n                rewrite_sortedSet(key)\n\n            # 如果键带有过期时间，过期时间也要重写\n            if key.have_expired_time():\n                rewrite_expired_time(key)\n    #写入完毕，关闭文件            \n    f.close()\n\ndef rewrite_string(key):\n    #使用GET命令获取字符串的值\n    value=GET(key)\n    #使用SET命令重写字符串键\n    f.write_command(SET，key，value)\n\ndef rewrite_expired_time(key):\n    #获取毫秒精度的键过期时间戳\n    timestamp=get_expired_time_in_unixstamp(key)\n    #使用PEXPIREAT命令重写键的过期时间\n    f.write_command(PEXPIREAT，key，timestamp)</code></pre>\n<h3 id=\"AOF后台重写\"><a href=\"#AOF后台重写\" class=\"headerlink\" title=\"AOF后台重写\"></a>AOF后台重写</h3><p>因为aof_rewrite函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞</p>\n<p>因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求。</p>\n<p>所以决定将AOF重写程序放到<strong>子进程</strong>中执行</p>\n<ul>\n<li>子进程在进行AOF重写期间，服务器进程可以进行处理命令请求</li>\n<li>子进程带有服务器进程的<strong>数据副本</strong>，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性</li>\n</ul>\n<p>但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库<strong>状态不一致</strong></p>\n<h4 id=\"AOF重写缓冲区\"><a href=\"#AOF重写缓冲区\" class=\"headerlink\" title=\"AOF重写缓冲区\"></a>AOF重写缓冲区</h4><p>为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，会同时将这个命令发送给<strong>AOF缓冲区和AOF重写缓冲区</strong></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207114138147.png\" alt=\"image-20210207114138147\"></p>\n<p>在子进程执行AOF重写期间，服务器进程执行:</p>\n<ol>\n<li>执行客户端发来的指令</li>\n<li>将执行后的写命令追加到AOF缓冲区</li>\n<li>将执行后的写命令追加到AOF重写缓冲区</li>\n</ol>\n<p>这样一来可以<strong>保证</strong></p>\n<ul>\n<li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。</li>\n<li>从创建子进程开始，服务器执行的所有写命都会被记录到AOF重写缓冲区里面。</li>\n</ul>\n<p>当子进程完成AOF重写工作之后，它  会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p>\n<ul>\n<li>将AOF重写缓冲区中的所有内容重写到新AOF文件中，这时新AOF文件保存的数据库状态将<strong>和服务器当前的数据库状态一致</strong>。</li>\n<li>对新的AOF文件进行改名，原子地(atomic)覆盖现有地AOF文件，完成<strong>新旧两个AOF文件地替换</strong>。</li>\n</ul>\n<p>这个信号处理函数执行完毕后，父进程可以继续像往常一样接收命令请求了</p>\n<p>在整个AOF后台重写过程中，只有<strong>信号处理函数执行时会对服务器进程（父进程）造成阻塞</strong>，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。</p>\n<h1 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h1><h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。</p>\n<p>一个应用往往会部署在多台机器上（多节点），在某些场景中，多个进程必须以互斥的方式独占共享资源。因此需要使用分布式锁</p>\n<p>分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源，一般来说，分布式锁需要满足的特性有这么几点：</p>\n<p>1、互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；</p>\n<p>2、高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；</p>\n<p>3、防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；</p>\n<p>4、独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了；</p>\n<h2 id=\"setnx（set-if-not-exists\"><a href=\"#setnx（set-if-not-exists\" class=\"headerlink\" title=\"setnx（set if not exists)\"></a>setnx（set if not exists)</h2><pre><code>SETNX key value</code></pre>\n<p>SET if Not eXists(如果不存在，则 SET)</p>\n<p>命令在设置成功时返回 1 ，设置失败时返回 0 。</p>\n<p>用来实现Redis锁机制，一个进程进来占坑，用完后再调用del指令释放坑</p>\n<p>只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作。</p>\n<p><strong>中间代码异常</strong></p>\n<p>如果逻辑执行到中间出现异常，可能导致del指令没有被调用，就会陷入死锁，锁永远得不到释放</p>\n<p>可以再拿到锁以后再给锁加上一个过期时间，比如5s，这样即使中间出现异常也可以保证5s后锁会自动释放</p>\n<pre><code class=\"redis\">setnx tongji4m3 true\n\nexpire tongji4m3 5\n\ndel tongji4m3</code></pre>\n<p><strong>expire异常</strong></p>\n<p>如果在setnx和expire之间服务器出现问题，导致expire得不到执行，也会死锁</p>\n<p>根源在于setnx和expire不是一条原子指令，但又不能用事务解决，因为expire依赖与setnx的执行结果，如果setnx没抢到锁，expire是不应该执行的，而事务没有if-else分支逻辑</p>\n<p>Redis支持set指令的扩展参数，使得setnx和expire指令可以一起执行，形成原子指令</p>\n<pre><code>SETEX key seconds value\n\nSET key value [EX seconds] [PX milliseconds] [NX|XX]\nset tongji4m3 true ex 5 nx\nNX:只在键不存在时， 才对键进行设置操作。\nXX:只在键已经存在时， 才对键进行设置操作。</code></pre>\n<p>将值 <code>value</code> 关联到 <code>key</code> ，并将 <code>key</code> 的生存时间设为 <code>seconds</code> (以秒为单位)。</p>\n<p>如果 <code>key</code> 已经存在，<code>setex</code>命令将覆写旧值。</p>\n<p>有小伙伴肯定会疑惑万一set value 成功 set time失败，那不就傻了么，这啊Redis官网想到了。</p>\n<p><code>setex</code>是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成。</p>\n<p>单机加锁或synchronized就够了</p>\n<p>但如果线程挂了,那锁就一直在那无法得到释放，后面的线程也永远得不到锁，又死锁了。</p>\n<p>setex设置一个过期时间，就算线程1挂了，也会在失效时间到了，自动释放。</p>\n<p><strong>超时问题</strong></p>\n<p>如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，会导致第一个线程持有的锁过期了而临界区的逻辑还没执行完</p>\n<p>Redis分布式锁不能用于较长时间的任务</p>\n<p>将set指令的value参数设置为随机数，释放锁时先匹配随机数是否一致，然后再删除key，确保当前线程持有的锁不会被其他线程释放，除非这个锁是因为过期了而被服务器自己释放的</p>\n<p>但是匹配value和删除key不是一个原子操作，需要要Lua脚本处理，他保证多个指令的原子性执行</p>\n<p><strong>可重入性</strong></p>\n<p>线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，就是可重入锁</p>\n<p>分布式锁要支持可重入，则要使用线程的Threadlocal变量存储当前持有锁的计数</p>\n<h3 id=\"怎么释放锁\"><a href=\"#怎么释放锁\" class=\"headerlink\" title=\"怎么释放锁\"></a>怎么释放锁</h3><p>释放锁的命令就简单了，直接删除key就行，但我们前面说了，因为分布式锁必须由锁的持有者自己释放，所以我们必须先确保当前释放锁的线程是持有者，没问题了再删除，这样一来，就变成两个步骤了，似乎又违背了原子性了，怎么办呢？</p>\n<p>不慌，我们可以用lua脚本把两步操作做拼装</p>\n<h2 id=\"redisson\"><a href=\"#redisson\" class=\"headerlink\" title=\"redisson\"></a>redisson</h2><p>redisson的锁，就实现了可重入</p>\n<pre><code class=\"java\">ThreadPoolExecutor threadPoolExecutor =\n        new ThreadPoolExecutor(inventory, inventory, 10L, SECONDS, linkedBlockingQueue);\nlong start = System.currentTimeMillis();\nConfig config = new Config();\nconfig.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);\nfinal RedissonClient client = Redisson.create(config);\nfinal RLock lock = client.getLock(&quot;lock1&quot;);\n\nfor (int i = 0; i &lt;= NUM; i++) {\n    threadPoolExecutor.execute(new Runnable() {\n        public void run() {\n            lock.lock();\n            inventory--;\n            System.out.println(inventory);\n            lock.unlock();\n        }\n    });\n}\nlong end = System.currentTimeMillis();\nSystem.out.println(&quot;执行线程数:&quot; + NUM + &quot;   总耗时:&quot; + (end - start) + &quot;  库存数为:&quot; + inventory);</code></pre>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><pre><code class=\"java\">public RLock getLock(String name) {\n    return new RedissonLock(connectionManager.getCommandExecutor(), name);\n}\n\npublic RedissonLock(CommandAsyncExecutor commandExecutor, String name) {\n    super(commandExecutor, name);\n    //命令执行器\n    this.commandExecutor = commandExecutor;\n    //UUID字符串\n    this.id = commandExecutor.getConnectionManager().getId();\n    //内部锁过期时间\n    this.internalLockLeaseTime = commandExecutor.\n                getConnectionManager().getCfg().getLockWatchdogTimeout();\n    this.entryName = id + &quot;:&quot; + name;</code></pre>\n<h3 id=\"加锁\"><a href=\"#加锁\" class=\"headerlink\" title=\"加锁\"></a>加锁</h3><pre><code class=\"java\">public void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException {\n\n    //当前线程ID\n    long threadId = Thread.currentThread().getId();\n    //尝试获取锁\n    Long ttl = tryAcquire(leaseTime, unit, threadId);\n    // 如果ttl为空，则证明获取锁成功\n    if (ttl == null) {\n        return;\n    }\n    //如果获取锁失败，则订阅到对应这个锁的channel\n    RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);\n    commandExecutor.syncSubscription(future);\n\n    try {\n        while (true) {\n            //再次尝试获取锁\n            ttl = tryAcquire(leaseTime, unit, threadId);\n            //ttl为空，说明成功获取锁，返回\n            if (ttl == null) {\n                break;\n            }\n            //ttl大于0 则等待ttl时间后继续尝试获取\n            if (ttl &gt;= 0) {\n                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);\n            } else {\n                getEntry(threadId).getLatch().acquire();\n            }\n        }\n    } finally {\n        //取消对channel的订阅\n        unsubscribe(future, threadId);\n    }\n    //get(lockAsync(leaseTime, unit));\n}</code></pre>\n<h3 id=\"获取锁\"><a href=\"#获取锁\" class=\"headerlink\" title=\"获取锁\"></a>获取锁</h3><pre><code class=\"java\">private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) {\n\n    //如果带有过期时间，则按照普通方式获取锁\n    if (leaseTime != -1) {\n        return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);\n    }\n\n    //先按照30秒的过期时间来执行获取锁的方法\n    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(\n        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),\n        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);\n\n    //如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间\n    ttlRemainingFuture.addListener(new FutureListener&lt;Long&gt;() {\n        @Override\n        public void operationComplete(Future&lt;Long&gt; future) throws Exception {\n            if (!future.isSuccess()) {\n                return;\n            }\n\n            Long ttlRemaining = future.getNow();\n            // lock acquired\n            if (ttlRemaining == null) {\n                scheduleExpirationRenewal(threadId);\n            }\n        }\n    });\n    return ttlRemainingFuture;\n}</code></pre>\n<h3 id=\"底层加锁逻辑\"><a href=\"#底层加锁逻辑\" class=\"headerlink\" title=\"底层加锁逻辑\"></a>底层加锁逻辑</h3><p>你可能会想这么多操作，在一起不是原子性不还是有问题么？</p>\n<p>大佬们肯定想得到呀，所以还是LUA，他使用了Hash的数据结构。</p>\n<p>主要是判断锁是否存在，存在就设置过期时间，如果锁已经存在了，那对比一下线程，线程是一个那就证明可以重入，锁在了，但是不是当前线程，证明别人还没释放，那就把剩余时间返回，加锁失败。</p>\n<pre><code class=\"java\">&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long leaseTime, TimeUnit unit,     \n                            long threadId, RedisStrictCommand&lt;T&gt; command) {\n\n        //过期时间\n        internalLockLeaseTime = unit.toMillis(leaseTime);\n\n        return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,\n                  //如果锁不存在，则通过hset设置它的值，并设置过期时间\n                  &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot; +\n                      &quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &quot; +\n                      &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +\n                      &quot;return nil; &quot; +\n                  &quot;end; &quot; +\n                  //如果锁已存在，并且锁的是当前线程，则通过hincrby给数值递增1\n                  &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot; +\n                      &quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot; +\n                      &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +\n                      &quot;return nil; &quot; +\n                  &quot;end; &quot; +\n                  //如果锁已存在，但并非本线程，则返回过期时间ttl\n                  &quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;,\n        Collections.&lt;Object&gt;singletonList(getName()), \n                internalLockLeaseTime, getLockName(threadId));\n    }</code></pre>\n<h3 id=\"解锁\"><a href=\"#解锁\" class=\"headerlink\" title=\"解锁\"></a>解锁</h3><p>锁的释放主要是publish释放锁的信息，然后做校验，一样会判断是否当前线程，成功就释放锁，还有个<strong>hincrby</strong>递减的操作，锁的值大于0说明是可重入锁，那就刷新过期时间。</p>\n<p>如果值小于0了，那删掉Key释放锁。</p>\n<p>是不是又和AQS很像了？</p>\n<p>AQS就是通过一个volatile修饰status去看锁的状态，也会看数值判断是否是可重入的。</p>\n<pre><code class=\"java\">public RFuture&lt;Void&gt; unlockAsync(final long threadId) {\n    final RPromise&lt;Void&gt; result = new RedissonPromise&lt;Void&gt;();\n\n    //解锁方法\n    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId);\n\n    future.addListener(new FutureListener&lt;Boolean&gt;() {\n        @Override\n        public void operationComplete(Future&lt;Boolean&gt; future) throws Exception {\n            if (!future.isSuccess()) {\n                cancelExpirationRenewal(threadId);\n                result.tryFailure(future.cause());\n                return;\n            }\n            //获取返回值\n            Boolean opStatus = future.getNow();\n            //如果返回空，则证明解锁的线程和当前锁不是同一个线程，抛出异常\n            if (opStatus == null) {\n                IllegalMonitorStateException cause = \n                    new IllegalMonitorStateException(&quot;\n                        attempt to unlock lock, not locked by current thread by node id: &quot;\n                        + id + &quot; thread-id: &quot; + threadId);\n                result.tryFailure(cause);\n                return;\n            }\n            //解锁成功，取消刷新过期时间的那个定时任务\n            if (opStatus) {\n                cancelExpirationRenewal(null);\n            }\n            result.trySuccess(null);\n        }\n    });\n\n    return result;\n}\n\n\nprotected RFuture&lt;Boolean&gt; unlockInnerAsync(long threadId) {\n    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, EVAL,\n\n            //如果锁已经不存在， 发布锁释放的消息\n            &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot; +\n                &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot; +\n                &quot;return 1; &quot; +\n            &quot;end;&quot; +\n            //如果释放锁的线程和已存在锁的线程不是同一个线程，返回null\n            &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) == 0) then &quot; +\n                &quot;return nil;&quot; +\n            &quot;end; &quot; +\n            //通过hincrby递减1的方式，释放一次锁\n            //若剩余次数大于0 ，则刷新过期时间\n            &quot;local counter = redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1); &quot; +\n            &quot;if (counter &gt; 0) then &quot; +\n                &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); &quot; +\n                &quot;return 0; &quot; +\n            //否则证明锁已经释放，删除key并发布锁释放的消息\n            &quot;else &quot; +\n                &quot;redis.call(&#39;del&#39;, KEYS[1]); &quot; +\n                &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot; +\n                &quot;return 1; &quot;+\n            &quot;end; &quot; +\n            &quot;return nil;&quot;,\n    Arrays.&lt;Object&gt;asList(getName(), getChannelName()), \n        LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));\n\n}</code></pre>\n"},{"title":"Redis集群","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"Redis集群学习笔记，包括Redis主从复制、Redis哨兵、Redis集群等。","abbrlink":"37cf2cfd","date":"2020-11-28T16:00:00.000Z","_content":"\n\n\n# 主从复制\n\n## 简介\n\n#### 理解\n\n被复制的服务器称为主服务器，对主服务器进行复制的服务器称为从服务器\n\n进行复制中的主从服务器双方的数据库将保存相同的数据\n\n#### 优点\n\n+ 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。减轻主数据库的压力\n+ 一主多从，「主数据库(master)可以读也可以写(read/write)，从数据库仅读(only read)」。\n+ 主从一定程度上解决了单机版并发量大，导致请求延迟或者redis宕机服务停止的问题。\n+ 从数据库分担主数据库的读压力，若是主数据库是只写模式，那么实现读写分离，主数据库就没有了读压力了。\n+ 另一方面解决了单机版单点故障的问题，若是主数据库挂了，那么从数据库可以随时顶上来，综上来说，主从模式一定程度上提高了系统的可用性和性能，是实现哨兵和集群的基础。\n+ 主从同步以异步方式进行同步，期间Redis仍然可以响应客户端提交的查询和更新的请求。\n\n###### 缺点\n\n比如数据的一致性问题，假如主数据库写操作完成，那么他的数据会被复制到从数据库，若是还没有即使复制到从数据库，读请求又来了，此时读取的数据就不是最新的数据。\n\n若是从主同步的过程网络出故障了，导致主从同步失败，也会出现问题数据一致性的问题。\n\n主从模式不具备自动容错和恢复的功能，一旦主数据库，从节点晋升为主数据库的过程需要人为操作，维护的成本就会升高，并且主节点的写能力、存储能力都会受到限制。\n\n## 旧版复制功能的实现\n\n- **同步操作**（sync）**：**用于将从服务器的数据库状态**更新至**主服务器当前所处的数据库状态\n- **命令传播操作**（command propagate）**：**则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库**重新回到一致状态**\n\n#### 同步\n\n- **概念：**当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，**将从服务器的数据库状态更新至主服务器当前所处的数据库状态**\n\n- **SYNC命令：**\n\n    从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：\n\n    - ①从服务器向主服务器**发送SYNC命令**\n    - ②收到SYNC命令的主服务器**执行BGSAVE命令，在后台生成一个RDB文件**，并使用一 个缓冲区记录从现在开始执行的所有写命令\n    - ③当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的**RDB文件发送给从服务器**，从服务器**接收并载入**这个RDB文件，将自己的数据库状态更新至主服务器 执行BGSAVE命令时的数据库状态\n    - ④主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写 命令，将自己的数据库状态更新至主服务器数据库当前所处的状态\n\n- 下图展示了SYNC命令执行期间，主从服务器的通信过程：\n\n![20191201105150863](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105150863.png)\n\n#### 命令传播\n\n- 在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并**导致主从服务器状态不再一致**\n- 为了让主从服务器再次回到一致状态，**主服务器需要对从服务器执行命令传播操作：**主 服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态\n- 例如，主服务器执行了DEL k3的命令，那么主服务器将向从服务器发送相同的命令DEL k3，当从服务器执行完这个命令之后，主从服务器将再次回到一致状态，现在主从服务器两者的数据库都不再包含键k3了。\n\n#### 缺陷\n\n旧版复制功能在处理断线重复制情况时低效\n\n在Redis中，**从服务器对主服务器的复制可以分为以下两种情况：**\n\n- **初次复制：**从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务 器和上一次复制的主服务器不同。\n- **断线后重复制：**处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务 器通过自动重连接重新连上了主服务器，并继续复制主服务器\n\n![20191201105727757](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105727757.png)\n\n**为什么网络断开之后重新复制效率低，以上面的演示案例为例：**\n\n- 主从服务器在时间T0至时间T10086中一直处于一致状态，这两个服务器保存的数据**大部分都是相同的**\n- 从服务器想要将自己更新至主服务器当前所处的状态，**真正需要的是主从服务器连接中断期间**，主服务器新添加的k10087、k10088、k10089三个键的数据\n- 可惜的是，旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键k1至键k10089的RDB文件，但实际上RDB文件包含的键k1至键k10086的数据对于从服务器来说都是不必要的\n\n主从服务器断开的时 间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数 据，**却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的**\n\n## 新版复制功能的实现\n\n- 为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，**使用PSYNC命令代替SYNC命令**来执行复制时的同步操作\n- **PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：**\n    - **完整重同步：**用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步 骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步\n    - **部分重同步：**则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态\n- PSYNC命令的部分重同步模式**解决了旧版复制功能在处理断线后重复制时出现的低效情况**\n\n**执行部分重同步所需的资源比起执行SYNC命令所需的资源要少得多**，完成同步的速度也快得多。执行SYNC命令需要生成、传送和载入整个RDB文件，而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了\n\n## 部分重同步的实现\n\n**同步功能由以下三个部分构成：**\n\n- 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量\n- 主服务器的复制积压缓冲区（replication backlog）\n- 服务器的运行ID（run ID）\n\n#### 复制偏移量\n\n- 执行复制的双方——主服务器和从服务器会**分别维护一个复制偏移量：**\n\n    - 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N\n    - 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N\n\n- 通过对比主从服务器的复制偏移量，\n\n    **程序可以很容易地知道主从服务器是否处于一致状态：**\n\n    - 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的\n    - 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态\n\n在下图所示的例子中，主从服务器的复制偏移量的值都为10086\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121350757.png)\n\n如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121359413.png)\n\n#### 复制积压缓冲区\n\n- 复制积压缓冲区是由主服务器维护的一个**固定长度（fixed-size）先进先出（FIFO）队列**，默认大小为1MB\n- 当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会**将写命令入队到复制积压缓冲区里面**，如下图所示：\n- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121909779.png)\n- 因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会**为队列中的每个字节记录相应的复制偏移量**\n- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121943503.png)\n- 当从服务器重新连上主服务器时，从服务器会通过PSYNC命令**将自己的复制偏移量offset发送给主服务器**，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操 作：\n    - 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）**仍然存在于复制积压缓冲区里面**，那么主服务器将对从服务器执行部分重同步操作\n    - 相反，如果offset偏移量之后的数据**已经不存在于复制积压缓冲区**，那么主服务器将对从服务器执行完整重同步操作\n\n**演示案例：**\n\n- 回到之前上面图片所展示的断线后重连接例子：\n- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121522212.png)\n- 当从服务器A断线之后，它立即重新连接主服务器，并**向主服务器发送PSYNC命令，报告自己的复制偏移量为10086**\n- 主服务器收到从服务器发来的PSYNC命令以及偏移量10086之后，主服务器将**检查偏移量10086之后的数据是否存在于复制积压缓冲区里面**，结果发现**这些数据仍然存在**，于是主服务器向从服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行\n- 接着主服务器会将复制积压缓冲区10086偏移量之后的**所有数据（偏移量为10087至 10119）都发送给从服务器**\n- 从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态，如下图所示\n- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201122209306.png)\n\n#### 服务器运行ID\n\n- 除了复制偏移量和复制积压缓冲区之外，\n\n    **实现部分重同步还需要用到服务器运行ID（run ID）：**\n\n    - 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID\n    - 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3\n\n- 当从服务器对主服务器**进行初次复制时**，主服务器会**将自己的运行ID传送给从服务器**， 而从服务器则会将**这个运行ID保存起来**\n\n- 当从服务器断线并重新连上一个主服务器时，**从服务器将向当前连接的主服务器发送之前保存的运行ID：**\n\n    - 如果从服务器保存的运行ID和当前连接的主服务器的**运行ID相同**，那么说明从服务器 断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作\n    - 相反地，如果从服务器保存的运行ID和当前连接的主服务器的**运行ID并不相同**，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作\n\n- 举个例子，假设从服务器原本正在复制一个运行ID为 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3的主服务器，那么在网络断开，从服务器重新连 接上主服务器之后，从服务器将向主服务器发送这个运行ID，主服务器根据自己的运行ID是 否53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3来判断是执行部分重同步还是执行完整重同步\n\n## PSYNC命令的实现\n\n#### PSYNC命令的调用方法有两种：\n\n- 如果从服务器**以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令：**那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器**进行完整重同步**（因为这时不可能执行部分重同步）\n\n- 如果从服务器**已经复制过某个主服务器**\n\n    ，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC <runid> <offset>命令：\n\n    - 其中runid是上一次复制的主服务器的运行 ID，而offset则是从服务器当前的复制偏移量\n    - 接收到这个命令的主服务器会**通过这两个参数来判断应该对从服务器执行哪种同步操作**\n\n\n\n#### 接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：\n\n- 如果**主服务器返回+FULLRESYNC  回复**，那么**表示主服务器将与从服务器执行完整重同步操作：**其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起 来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器 会将这个值作为自己的初始化偏移量\n- 如果**主服务器返回+CONTINUE回复**，那么表示**主服务器将与从服务器执行部分重同步操作**，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了\n- 如果**主服务器返回-ERR回复**，那么表示主服务器的版本低于Redis 2.8，**它识别不了PSYNC命令**，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作\n\n\n\n#### 流程图\n\n- 下面的流程图总结了PSYNC命令执行完整重同步和部分重同步时可能遇上的情况：\n- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201123546284.png)\n\n\n\n#### 演示案例\n\n为了熟悉PSYNC命令的用法，让我们来看一个完整的复制——网络中断——重复制例 子\n\n- 首先，假设有两个Redis服务器，它们的版本都是Redis 2.8，其中主服务器的地址为 127.0.0.1:6379，从服务器的地址为127.0.0.1:12345\n- 如果客户端向从服务器发送命令SLAVEOF 127.0.0.1 6379，并且假设从服务器是第一次 执行复制操作，那么从服务器将向主服务器发送PSYNC ? -1命令，请求主服务器执行完整重 同步操作\n- 主服务器在收到完整重同步请求之后，将在后台执行BGSAVE命令，并向从服务器返回 +FULLRESYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 10086回复，其中 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3是主服务器的运行ID，而10086则是主服务器当 前的复制偏移量\n- 假设完整重同步成功执行，并且主从服务器在一段时间之后仍然保持一致，但是在复制 偏移量为20000的时候，主从服务器之间的网络连接中断了，这时从服务器将重新连接主服 务器，并再次对主服务器进行复制。\n- 因为之前曾经对主服务器进行过复制，所以从服务器将向主服务器发送命令PSYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 20000，请求进行部分重同步\n- 主服务器在接收到从服务器的PSYNC命令之后，首先对比从服务器传来的运行 ID53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3和主服务器自身的运行ID，结果显示该ID和 主服务器的运行ID相同，于是主服务器继续读取从服务器传来的偏移量20000，检查偏移量 为20000之后的数据是否存在于复制积压缓冲区里面，结果发现数据仍然存在\n- 确认运行ID相同并且数据存在之后，主服务器将向从服务器返回+CONTINUE回复，表 示将与从服务器执行部分重同步操作，之后主服务器会将保存在复制积压缓冲区20000偏移 量之后的所有数据发送给从服务器，主从服务器将再次回到一致状态\n\n\n\n## 复制的实现\n\n#### 步骤1:设置主服务器的地址和端口\n\n当客户端向从服务器发送以下命令时:`SLAVEOF 127.0.0.1 6379`\n\n从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379**保存到服务器状态的masterhost属性和masterport属性里面**\n\n```c\nstruct redisServer\n{\n\tchar * masterhost;//主服务器的地址\n\tint masterport;//主服务器的端口号\n};\n```\n\n**SLAVEOF命令是一个异步命令**，在完成masterhost属性和masterport属性的设置工作之 后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而**实际的复制工作将在OK返回之后才真正开始执行**\n\n#### 步骤2:建立套接字连接\n\n- 在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，**创建连向主服务器的套接字连接**，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131155414.png)\n\n- 如果**从服务器创建的套接字能成功连接（connect）到主服务器**，那么从服务器将为这个套接字关联一个专门**用于处理复制工作的文件事件处理器**，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类\n- 而**主服务器在接受（accept）从服务器的套接字连接之后**，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器（server）和客户端（client）两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131243941.png)\n\n- 因为复制工作接下来的几个步骤都会以从服务器向主服务器发送命令请求的形式来进 行，所以**理解“从服务器是主服务器的客户端”这一点非常重要**\n\n#### 步骤3:发送PING命令\n\n- 从服务器成为主服务器的客户端之后，做的第一件事就是**向主服务器发送一个PING命令**，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131333757.png)\n\n- **这个PING命令有两个作用：**\n    - 虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信， 通过发送PING命令可以**检查套接字的读写状态是否正常**\n    - 因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以**检查主服务器能否正常处理命令请求**\n- **从服务器在发送PING命令之后将遇到以下三种情况的其中一种：**\n    - 如果主服务器向从服务器返回了一个命令回复，但从服务器却**不能在规定的时限 （timeout）内读取出命令回复的内容**，那么表示主从服务器之间的网络连接状态不佳，不能 继续执行复制工作的后续步骤。当出现这种情况时，从服务器**断开并重新创建**连向主服务器 的套接字\n    - 如果主服务器**向从服务器返回一个错误**，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，**从服务器断开并重新创建连向主服务器的套接字**。比如说，如果主服务器正在处理一个超时运行的脚本，那么当从 服务器向主服务器发送PING命令时，从服务器将收到主服务器返回的BUSY Redisis busy running a script.You can only call SCRIPT KILL or SHUTDOWN NOSAVE.错误\n    - 如果从服务器**读取到\"PONG\"回复**，那么表示主从服务器之间的网络连接状态正常，并 且主服务器可以正常处理从服务器（客户端）发送的命令请求，在这种情况下，从服务器可 以继续执行复制工作的下个步骤\n- 下面的流程图总结了从服务器在发送PING命令时可能遇到的情况，以及各个情况的处理方式\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131558981.png)\n\n#### 步骤4:身份验证\n\n- 从服务器在收到主服务器返回的\"PONG\"回复之后，\n\n    **下一步要做的就是决定是否进行身份验证：**\n\n    - 如果从服务器设置了masterauth选项，那么进行身份验证\n    - 如果从服务器没有设置masterauth选项，那么不进行身份验证\n\n- 在需要进行身份验证的情况下，**从服务器将向主服务器发送一条AUTH命令**，命令的**参数为从服务器masterauth选项的值**\n\n- 举个例子，如果从服务器masterauth选项的值为10086，那么从服务器将向主服务器发送 命令AUTH 10086，如下图所示\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131632595.png)\n\n#### 步骤5:发送端口信息\n\n- 在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port ， **向主服务器发送从服务器的监听端口号**\n- 例如在我们的例子中，从服务器的监听端口为12345，那么从服务器将**向主服务器发送命令REPLCONF listening-port 12345**，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113200247.png)\n\n#### 步骤6:同步\n\n- 在这一步，从服务器将向主服务器发送PSYNC命令，***\\*执行同步操作\\****，并**将自己的数据库更新至主服务器数据库当前所处的状态**\n\n- 值得一提的是，在同步操作执行之前，只有从服务器是主服务器的客户端，但是\n\n    **在执行同步操作之后，主服务器也会成为从服务器的客户端：**\n\n    - 如果PSYNC命令执行的是**完整重同步操作**，那么主服务器需要成为从服务器的客户 端，才能将保存在缓冲区里面的写命令发送给从服务器执行。\n    - 如果PSYNC命令执行的是**部分重同步操作**，那么主服务器需要成为从服务器的客户 端，才能向从服务器发送保存在复制积压缓冲区里面的写命令\n\n- 因此，在同步操作执行之后，**主从服务器双方都是对方的客户端**，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113224549.png)\n\n- 正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命 令传播操作的基础\n\n#### 步骤7:命令传播\n\n- 当完成了同步之后，**主从服务器就会进入命令传播阶段**，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就**可以保证主从服务器一直保持一致了**\n\n\n\n## 心跳检测\n\n- 在命令传播阶段，从服务器默认会**以每秒一次的频率**，向主服务器发送命令：\n\n```bash\nREPLCONF ACK <replication_offset>\n//其中replication_offset是从服务器当前的复制偏移量\n```\n\n- **发送REPLCONF ACK命令对于主从服务器有三个作用：**\n    - ①检测主从服务器的网络连接状态\n    - ②辅助实现min-slaves选项\n    - ③检测命令丢失\n\n#### 检测主从服务器的网络连接状态（lag标志）\n\n- 主从服务器可以通过发送和接收REPLCONF ACK命令**来检查两者之间的网络连接是否正常：**如果主服务器**超过一秒钟没有收到**从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了\n- 通过向主服务器发送**INFO replication命令**，在列出的**从服务器列表的lag一栏中**，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令**距离现在过了多少秒。**在一般情况下，**lag的值应该在0秒或者1秒之间跳动**，如果超过1秒的话，那么说明主从 服务器之间的连接出现了故障。\n\n#### 辅助实现min-slaves配置选项\n\n- Redis的**min-slaves-to-write和min-slaves-max-lag两个选项**可以**防止主服务器在不安全的情况下执行写命令**\n- 举个例子，如果我们向主服务器提供以下设置：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201132859439.png)\n\n- 那么在**从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时**，主服务器将**拒绝执行写命令**，这里的延迟值就是上面提到的INFO replication命令的lag 值\n\n#### 检测命令丢失\n\n如果因为网络故障，**主服务器传播给从服务器的写命令在半路丢失**，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将**发觉**从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里 面找到从服务器缺少的数据，并**将这些数据重新发送给从服务器**\n\n#### 演示案例\n\n- 举个例子，假设有两个处于一致状态的主从服务器，它们的复制偏移量都是200，如下图所示\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133107682.png)\n\n- 如果这时主服务器执行了命令SET key value（协议格式的长度为33字节），将自己的复 制偏移量更新到了233，并尝试向从服务器传播命令SET key value，但这条命令却因为网络 故障而在传播的途中丢失，那么主从服务器之间的复制偏移量就会出现不一致，主服务器的 复制偏移量会被更新为233，而从服务器的复制偏移量仍然为200，如下图所示\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133127229.png)\n\n- 在这之后，当从服务器向主服务器发送REPLCONF ACK命令的时候，主服务器会察觉 从服务器的复制偏移量依然为200，而自己的复制偏移量为233，这说明复制积压缓冲区里面 复制偏移量为201至233的数据（也即是命令SET key value）在传播过程中丢失了，于是主服 务器会再次向从服务器传播命令SET key value，从服务器通过接收并执行这个命令可以将自 己更新至主服务器当前所处的状态，如下图所示\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133147307.png)\n\n# Redis哨兵\n\n## Sentinel\n\n#### 优点\n\n哨兵模式是主从的升级版，因为主从的出现故障后，不会自动恢复，需要人为干预。\n\n在主从的基础上，实现哨兵模式就是为了监控主从的运行状况，对主从的健壮进行监控，就好像哨兵一样，只要有异常就发出警告，对异常状况进行处理。\n\n总的概括来说，哨兵模式有以下的优点(功能点)：\n\n- 「监控」：监控master和slave是否正常运行，以及哨兵之间也会相互监控\n- 「自动故障恢复」：当master出现故障的时候，会自动选举一个slave作为master顶上去。\n- 哨兵模式是主从模式的升级版，所以在系统层面提高了系统的可用性和性能、稳定性。当master宕机的时候，能够自动进行故障恢复，需不要人为的干预。\n- 哨兵与哨兵之间、哨兵与master之间能够进行及时的监控，心跳检测，及时发现系统的问题，这都是弥补了主从的缺点。\n\n#### 缺点\n\n哨兵一主多从的模式同样也会遇到写的瓶颈，已经存储瓶颈，若是master宕机了，故障恢复的时间比较长，写的业务就会受到影响。\n\n增加了哨兵也增加了系统的复杂度，需要同时维护哨兵模式。\n\n#### 简介\n\nSentinel（哨岗、哨兵）是**Redis的高可用性（high availability）解决方案：**由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以**监视任意多个**主服务器，以及这些主服务器属下的所有从服务器，并在被监视的**主服务器进入下线状态时**，自动将下线主服务器属下的某个从服务器**升级为新的主服务器**，然后由新的主服务器代替已下线的主服务器继续处理命令请求\n\n\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201213815316.png)\n\n\n\n- 根据上面的图片，假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对 主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如下图所示（下线的服务器用虚线表示）\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214010487.png)\n\n- 当server1的**下线时长超过用户设定的下线时长上限时**，Sentinel系统就会对server1执行**故障转移**\n\n    操作：\n\n    - 首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器\n    - 之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕\n    - 另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器\n\n- 举个例子，下图展示了Sentinel系统**将server2升级为新的主服务器**，并让服务器server3和server4成为server2的从服务器的过程\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214149843.png)\n\n- 之后，如果server1**重新上线的话**，它将被Sentinel系统**降级为server2的从服务器**，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214154597.png)\n\n## 启动并初始化Sentinel\n\n启动`Sentinel`会执行以下操作：\n\n1. 初始化服务器\n2. 将普通Redis服务器使用的代码替换成`Sentinel`专用代码\n3. 初始化`Sentinel`状态\n4. 根据给定的配置文件,初始化`Sentinel`的监视主服务器列表\n5. 创建连向主服务器的网络连接\n\n#### 初始化Sentinel状态\n\n在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个**sentinel.c/sentinelState结构**（后面简称“Sentinel状态”），这个结构**保存了服务器中所有和Sentinel功能有关的状态** （服务器的一般状态仍然由redis.h/redisServer结构保存）\n\n```c\nstruct sentinelState {\n    //当前纪元，用于实现故障转移\n    uint64_t current_epoch;\n \n    //保存了所有被这个sentinel 监视的主服务器\n    dict *masters;\n    \n    //略\n} sentinel;\n```\n\n\n#### 初始化Sentinel状态的masters属性\n\nSentinel状态中的**masters字典记录了所有被Sentinel监视的主服务器的相关信息**，其中：\n\n- **字典的键**是被监视主服务器的名字\n- **字典的值**则是被监视主服务器对应的sentinel.c/**sentinelRedisInstance结构**\n\n\n\n- 每个sentinelRedisInstance结构（后面简称“实例结构”）**代表一个被Sentinel监视的Redis服务器实例**（instance），这个实例可以是**主服务器、从服务器，或者另外一个Sentinel**\n\n```c\ntypedef struct sentinelRedisInstance {\n    //标识值，记录了实例的类型，以及该实例的当前状态\n    int flags;\n \n    //实例的名字\n    //主服务器的名字由用户在配置文件中设置\n    //从服务器以及Sentinel 的名字由Sentinel 自动设置\n    //格式为ip:port ，例如\"127.0.0.1:26379\"\n    char *name;\n \n    //实例的运行ID\n    char *runid;\n \n    //配置纪元，用于实现故障转移\n    uint64_t config_epoch;\n \n    //实例的地址\n    sentinelAddr *addr;\n} sentinelRedisInstance;\n```\n\n```c\nstruct sentinelAddr\n{\n\tchar * ip;\n\tint port;\n}\n```\n\n###### 例子\n\n- 对Sentinel状态的初始化将引发对masters字典的初始化，而masters字典的初始化是**根据被载入的Sentinel配置文件**来进行的\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201220900699.png)\n\n#### 创建连向主服务器的网络连接\n\n- 初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，**Sentinel将成为主服务器的客户端**，它可以向主服务器发送命令，并从命令回复中获取相关的信息\n\n- 对于每个被Sentinel监视的主服务器来说，Sentinel会\n\n    **创建两个连向主服务器的异步网络连接：**\n\n    - 一个是**命令连接**，这个连接专门用于向主服务器发送命令，并接收命令回复\n    - 另一个是**订阅连接**，这个连接专门用于订阅主服务器的__sentinel__:hello频道\n\n\n\n## 获取主服务器的信息\n\n- Sentinel默认会以**每十秒一次的频率**，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来**获取主服务器的当前信息**\n\n- 通过分析主服务器返回的INFO命令回复，**Sentinel可以获取以下两方面的信息：**\n    - 一方面是**关于主服务器本身的信息**，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色\n    - 另一方面是关于主服务器属下**所有从服务器的信息**，每个从服务器都由一个\"slave\"字符 串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端 口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器\n- **根据run_id域和role域记录的信息，Sentinel将对主服务器的实例结构进行更新**，例如， 主服务器重启之后，它的运行ID就会和实例结构之前保存的运行ID不同，Sentinel检测到这 一情况之后，就会对实例结构的运行ID进行更新\n- Sentinel在分析INFO命令中包含的从服务器信息时，**会检查从服务器对应的实例结构是否已经存在于slaves字典：**\n    - 如果**从服务器对应的实例结构已经存在**，那么Sentinel对从服务器的实例结构进行更新\n    - 如果**从服务器对应的实例结构不存在**，那么说明这个从服务器是新发现的从服务器， Sentinel会在slaves字典中为这个从服务器新创建一个实例结构\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201223205478.png)\n\n## 获取从服务器信息\n\n- 当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的**从服务器创建相应的实例结构之外**，Sentinel还会创建连接到从服务器的**命令连接和订阅连接**\n- 举个例子，对于上面那张图所示的主从服务器关系来说，Sentinel将对slave0、slave1和 slave2三个从服务器分别创建命令连接和订阅连接，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120122373496.png)\n\n**根据INFO命令的回复，Sentinel会提取出以下信息：**\n\n- 从服务器的运行ID run_id\n- 从服务器的角色role\n- 主服务器的IP地址master_host，以及主服务器的端口号master_port\n- 主从服务器的连接状态master_link_status\n- 从服务器的优先级slave_priority\n- 从服务器的复制偏移量slave_repl_offset\n\n## Sentinel向主服务器和从服务器发送信息\n\n在默认情况下，Sentinel会以**每两秒一次的频率**，通过命令连接向所有被监视的**主服务器和从服务器**发送命令\n\n对于监视同一个服务器的多个Sentinel来说，**一个Sentinel发送的信息会被其他Sentinel接收到**，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。\n\n## Sentinel接收服务器和从服务器的频道信息\n\n当一个Sentinel从__sentinel__:hello频道收到一条信息时，Sentinel会对这条信息进行分 析，**提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：**\n\n- 如果信息中记录的Sentinel运行ID和接收信息的Sentinel的**运行ID相同**，那么说明这条信 息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理\n- 相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的**运行ID不相同**，那么 说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，**对相应主服务器的实例结构进行更新**\n- 因为一个Sentinel可以通过分析接收到的频道信息来**获知其他Sentinel的存在**，并通过发送频道信息来**让其他Sentinel知道自己**的存在，所以用户在使用Sentinel的时候并不需要提供各个Sentinel的地址信息，监视同一个主服务器的多个Sentinel**可以自动发现对方**\n- 当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，**还会创建一个连向新Sentinel的命令连接**，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的**多个Sentinel将形成相互连接的网络：**Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202184847281.png)\n\n## 检测主观下线状态\n\n- 在默认情况下，Sentinel会**以每秒一次的频率**向所有与它创建了命令连接的实例（**包括主服务器、从服务器、其他Sentinel在内**）发送**PING命令**，并通过实例返回的PING命令回复来判断实例是否在线\n- 如果配置文件指定Sentinel1的**down-after-milliseconds选项的值为50000毫秒**，那么当主服务器master连续50000毫秒都向Sentinel1**返回无效回复时**， Sentinel1就会将master标记为主观下线\n\n## 检测客观下线状态\n\n- 当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线 了，它会**向同样监视这一主服务器的其他Sentinel进行询问**，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里**接收到足够数量的已下线判断之后**，Sentinel就会将从服务器判定为客观下线，并对主服务器**执行故障转移操作**\n\n## 选取领头Sentinel\n\n- 当一个主服务器被判断为客观下线时，监视这个下线主服务器的**各个Sentinel会进行协商**，选举出一个领头Sentinel，并由领头Sentinel**对下线主服务器执行故障转移操作**\n\n- 1.**所有在线的Sentinel都有被选为领头Sentinel的资格**，换句话说，监视同一个主服务器的 多个在线Sentinel中的任意一个都有可能成为领头Sentinel\n- 2.每次进行领头Sentinel选举之后，**不论选举是否成功，所有Sentinel的配置纪元 （configuration epoch）的值都会自增一次**。配置纪元实际上就是一个计数器，并没有什么特别的\n- 3.在一个配置纪元里面，**所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会**，并且局部领头一旦设置，在这个配置每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel\n- 4.当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送**SENTINEL ismaster-down-by-addr命令**，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这**表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel**\n- 5.Sentinel设置局部领头Sentinel的规则是先到先得：**最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头**Sentinel，而**之后接收到的所有设置要求都会被目标Sentinel拒绝**\n- 6.目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，**将向源Sentinel返回 一条命令回复，**回复中的leader_runid参数和leader_epoch参数分别**记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元**\n- 7.源Sentinel在接收到目标Sentinel返回的命令回复之后，**会检查回复中leader_epoch参数的值和自己的配置纪元是否相同**，如果相同的话，那么源Sentinel继续取出回复中的 leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标 Sentinel将源Sentinel设置成了局部领头Sentinel\n- 8.如果**有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel**。举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于 10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成 为领头Sentine\n- 9.因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，**所以在一个配置纪元里面，只会出现一个领头 Sentinel**\n- 10.如果在给定时限内，**没有一个Sentinel被选举为领头Sentinel**，那么各个Sentinel将在一段时间之后**再次进行选举**，直到选出领头Sentinel为止\n\n## 故障转移\n\n- 在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器**执行故障转移操作**\n- **该操作包含下面3个步骤：**\n    - ①在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器\n    - ②让已下线主服务器属下的所有从服务器改为复制新的主服务器\n    - ③将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线 时，它就会成为新的主服务器的从服务器\n\n#### 选出新的主服务器\n\n- 故障转移操作第一步要做的就是**在已下线主服务器属下的所有从服务器中**，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送**SLAVEOF no one命令**，将这个**从服务器转换为主服务器**\n\n###### 演示案例\n\n- 下图展示了在一次故障转移操作中，领头Sentinel向**被选中的从服务器server2**发送SLAVEOF no one命令的情形：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193156859.png)\n\n- 在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一 次），向被升级的从服务器**发送INFO命令，**并观察命令回复中的角色（role）信息，**当被升级服务器的role从原来的slave变为master时**，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了\n\n#### 修改从服务器的复制目标\n\n- 当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的**所有从服务器去复制新的主服务器**，这一动作可以**通过向从服务器发送SLAVEOF命令来实现**\n\n###### 图示\n\n- 下图展示了在故障转移操作中，领头Sentinel向已下线主服务器server1的两个从服务器server3和server4发送SLAVEOF命令，让**它们复制新的主服务器server2的例子**\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193616934.png)\n\n- 下图展示了**server3和server4成为server2的从服务器之后**，各个服务器以及领头Sentinel的样子\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193633254.png)\n\n#### 将旧的主服务器变为从服务器\n\n- 故障转移操作最后要做的是，**将已下线的主服务器设置为新的主服务器的从服务器**。比如说，下图就展示了被领头Sentinel设置为从服务器之后，服务器server1的样子\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193748287.png)\n\n- 因为旧的主服务器已经下线，所以这种设置是保存在server1对应的实例结构里面的，当 server1重新上线时，**Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器**\n- 例如，下图就展示了server1重新上线并成为server2的从服务器的例子\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193757739.png)\n\n\n\n# Redis集群\n\n###### 优点\n\n最后，Cluster是真正的集群模式了，哨兵解决和主从不能自动故障恢复的问题，但是同时也存在难以扩容以及单机存储、读写能力受限的问题，并且集群之前都是一台redis都是全量的数据，这样所有的redis都冗余一份，就会大大消耗内存空间。\n\n集群模式实现了Redis数据的分布式存储，实现数据的分片，每个redis节点存储不同的内容，并且解决了在线的节点收缩(下线)和扩容(上线)问题。\n\n集群模式真正意义上实现了系统的高可用和高性能，但是集群同时进一步使系统变得越来越复杂，接下来我们来详细的了解集群的运作原理。\n\n集群模式是一个无中心的架构模式，将数据进行分片，分布到对应的槽中，每个节点存储不同的数据内容，通过路由能够找到对应的节点负责存储的槽，能够实现高效率的查询。\n\n并且集群模式增加了横向和纵向的扩展能力，实现节点加入和收缩，集群模式是哨兵的升级版，哨兵的优点集群都有。\n\n###### 缺点\n\n缓存的最大问题就是带来数据一致性问题，在平衡数据一致性的问题时，兼顾性能与业务要求，大多数都是以最终一致性的方案进行解决，而不是强一致性。\n\n并且集群模式带来节点数量的剧增，一个集群模式最少要6台机，因为要满足半数原则的选举方式，所以也带来了架构的复杂性。\n\nslave只充当冷备，并不能缓解master的读的压力。\n\n#### 基本信息\n\n- Redis Cluster是去中心化的，例如一个集群由三个Redis节点组成，每个节点负责整个集群的一部分数据。这三个节点就相互连接组成一个对等的集群，他们之间通过一种特殊的二进制协议交互集群信息。\n\n- 所有数据划分为16384个槽位，每个节点负责其中一部分槽位，槽位的信息存储在每个节点中\n\n- 客户端为了可以直接定位到某个具体的key所在的节点，需要缓存槽位相关信息，这样才可以准确快速地定位到相应的节点。同时因为可能会存在客户端与服务器存储槽位的信息不一致的情况。还需要纠正机制来实现槽位信息的校验调整\n\n- 当客户端向一个错误的节点发出了指令后，该节点会发现指令的key所在的槽位并不归自己管理，这时他会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连接这个节点以获取数据\n\n- ```\n    GET x\n    -MOVED 3999 127.0.0.1:6381\n    //MOVED的一个参数3999是key对应的槽位编号，后面是目标节点的地址。\n    //MOVED指令前面有一个减号，表示该指令是一个错误消息\n    //客户端收到MOVED指令后，要立即纠正本地的槽位映射表。\n    //后续所有key将使用新的槽位映射表\n    ```\n\n    \n\n- \n\n#### 理解\n\n在Redis主从复制中介绍过利用主从节点实现读写分离来扩展主节点的数据读取能力，那么当主节点的写入能力成为瓶颈时，集群便是性能扩展的解决方案之一。Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。集群设计，本质上来讲是把数据存储在不同的数据节点上，这些节点可以独立的向外提供服务，那么需要解决的最重要几个问题是\n\n- 当新的写入数据到达时，该数据应该存储在哪台机器上。即数据分布问题\n- 当新的查询请求到达时，我们该如何知道这部分数据存储在哪个机器节点上。即查询路由问题。\n- 当新的节点加入时，我们该如何重新分配数据，让新的节点也对外提供服务。当有节点退出时，我们该如何把存在该节点上的数据分配到其他机器上，让其他机器来提供这部分数据的服务。即集群的扩缩容问题。\n- 当有节点因故障而不能提供服务时，如何能保证该集群仍然能正常向外提供服务。即高可用问题。\n\n#### 总结\n\n对于分布式存储，数据分区规则是核心问题之一，Redis集群中使用的是虚拟槽/虚拟桶分区，使用CRC16函数计算每个键的哈希值，并把所有的键划分到16384个桶中。数据存储在各个结点之后，当客户端访问键时，需要能够知道键所在的节点地址，Redis集群没有采用代理的方案，而是每个节点都保存集群中槽的负责节点信息，客户端可连接任意一个节点，当该节点发现客户端请求的键并不由自己负责时，会向客户端返回重定向，重定向中包含着负责该键的节点地址信息。同路由信息一样，Redis的集群元数据信息也是存储在各个节点上，并使用Gossip协议来完成集群的元数据同步。每个集群节点会每100ms向部分节点随机传输自己视角下的N/10个节点的信息，同时Redis集群节点会努力保证自己与其他的所有节点每node_timeout/2时间内至少通信一次。\n\n#### 数据分布\n\n分布式数据库首先要解决地把整个数据集按照分区规则映射到多个节点地问题。即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。如下图所示：\n\n![img](https://pic4.zhimg.com/80/v2-17d40b36ede8d8c4a3309306370f09f7_1440w.jpg)\n\n分布式存储数据分区\n\nRedis采用了虚拟桶分区方法，使用分散度良好地哈希函数把所有的数据均匀地哈希到K个桶中。具体实现中，Redis使用CRC16函数计算键的哈希值并把所有键分到16384个桶中，键的桶编号计算方法如下所示。每个桶**只能**由一个主节点存储，但一个主节点可以负责多个桶。Redis集群中，数据的迁移都是以桶为单位的，集群的扩缩容等价为桶在不同节点间的移动。\n\n```text\nHASH_SLOT = CRC16(key) mod 16384\n//默认对key值使用crc16算法进行hash，得到一个整数值，然后用这个整数值对16384进行取模得到具体槽位\n```\n\n#### 查询路由\n\n基于上述的分区方法，集群中的数据存储可能如下图所示。我们有5个节点，每个节点平均存储大约3273个桶（即16384/5）。那么当我们要进行一个键值的查询时，给定一个key，我们如何知道该key的值存储在哪个机器节点上呢？即我们需要一个查询路由，该路由根据给定的key，返回存储该键值的机器地址。\n\n![img](https://pic2.zhimg.com/80/v2-1fe6033d4997d85449ce6764251923e1_1440w.jpg)5个节点，每个节点负责一部分桶\n\n常规的实现方式便是采用如下图所示的代理方案，即采用一个中央节点（比如HDFS中的NameNode）来管理所有的元数据，但是这样的方案带来的最大问题就是代理节点很容易成为访问的瓶颈，当读写并发量高的时候，代理节点会严重的拖慢整个系统的性能。\n\n![img](https://pic1.zhimg.com/80/v2-936c9a100eda3f1a2c79c10901134180_1440w.jpg)采用代理的方案实现路由\n\nRedis没有选择使用代理，而是客户端直接连接每个节点。Redis的每个节点中都存储着如下所示的整个集群的状态，集群状态中一个重要的信息就是**每个桶的负责节点**。在具体的实现中，Redis用一个大小固定为CLUSTER_SLOTS的clusterNode数组 slots来保存每个桶的负责节点。在集群模式下，Redis接收任何键相关命令时首先**计算键对应的桶编号，再根据桶找出所对应的节点**，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，**通知客户端请求正确的节点，这个过程称为MOVED重定向**。重定向信息包含了键所对应的桶以及负责该桶的节点地址，根据这些信息客户端就可以向正确的节点发起请求。\n\n这样的话，假设集群中有N个主节点存储数据，那么客户端要查询一个键时，一次就恰好访问到正确节点的概率只有1/N。有(N-1)/N的概率是要请求两次的，第一次随机连接一个节点获得正确的节点地址，第二次从正确的节点中获取数据。当请求并发量比较大时，我们就会浪费大量的节点处理时间。一种较好的方案是在客户端把ClusterState中的slots数据信息缓存起来，这样每次客户端计算出对应的桶之后，根据本地的缓存获得正确的节点位置。这样便可以避免大量不必要的重复请求。当然，如果集群发生了扩缩容或者failover导致客户端缓存的信息过期时，客户端只需要在访问节点得到**MOVED**重定向时，重新更新下本地的缓存信息即可。这种缓存slots信息的客户端就是**Smart Client**。\n\n#### 集群扩容\n\n当集群中发生扩缩容时会发生桶的迁移，比如当节点A正在把桶334迁移到节点B，那么在迁移完成之前，桶334的一部分数据存在节点A，一部分数据存在节点B。**在迁移完成之前，集群中的所有节点都仍然会认为桶334由节点A负责**。所以当访问桶334中的数据时，请求会被统一路由到节点A，如果A发现客户端访问的键并不在本地存储（可能已经被迁移到了节点B，或者该键之前就不存在），那么节点A就会向客户端返回**ASK重定向**。ASK重定向同样会返回**槽值和节点B的地址**，客户端会根据ASK返回的重定向地址向B发起请求，看看新节点存不存在数据。对客户端来说，MOVED和ASK重定向的区别在于，**当客户端收到MOVED重定向时会选择更新本地的缓存，但是接收到ASK重定向并不会更新本地缓存。**当节点A和节点B完成了桶334的迁移之后，**节点B会向整个集群广播自己目前负责的桶的信息，之后整个集群的其他节点就会认为桶334由B负责，此时如果客户端再向节点A访问桶334的数据，那么节点A就会返回MOVED重定向。**即ASK重定向只会在数据迁移的时候发生，同时客户端接收到ASK重定向之后并不会更新本地缓存。\n\nASK指令只是用来临时纠正槽位的，不会刷新槽位映射关系表，不影响后续指令。\n\n#### 集群节点通信\n\n**集群中所有节点的状态以及桶-节点映射关系构成集群的元数据**，许多分布式存储系统的元数据管理是采用专门的元数据管理节点的，比如HDFS中的Name Node，但是**Redis集群的元数据是保存在各个Redis节点。如果元数据保存在各个节点上，我们需要解决的最重要的问题是如何保证各个节点的元数据一致性。**第一种方法便是每个节点都向其他所有的节点广播自己的元数据内容及元数据版本。每个节点接收到其他节点的元数据之后，如果发现接收到的数据版本比本地的版本更新，便用接收到的数据来更新本地的数据。这样做的好处，便是元数据同步的速度会很快，一旦一个节点的元数据修改，只要网络不断，可以很快的向其他节点同步数据，但是这样带来的坏处就是通信量的剧增。所有集群中的N个节点构成了一个全连接图，那么如果每个节点每100ms进行一次全局广播，那么每一次广播都会广播N^2条信息，这将占据大量的带宽。\n\nRedis采用**Gossip通信协议来进行集群元数据的同步**。Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息。每个Redis都会保存自己视角下的集群中其他节点的状态信息，具体实现中所有的节点信息都存储在clusterNode结构体中。那么使用Gossip协议，集群中的每个节点，每次会随机向几个节点传输自己视角下的集群其他节点状态。如果每次都传输所有的节点状态数据，那么数据体量又会过于庞大，于是Redis集群采用的最终的信息同步方式是： 一个大小为N的集群的每一个节点每次向随机K个其他节点传输自己视角下的随机M个节点的状态。其中M和K都远远小于N。\n\n虽然Gossip协议的信息交换机制具有天然的分布式特性，但它是有成本的。由于内部需要频繁地进行节点信息交换，而ping/pong消息会携带当前节点和其他M个节点的状态数据，势必会加重带宽和计算的负担。Redis集群内节点通信采用固定频率（定时任务每秒执行10次）。因此节点每次选择需要通信的节点列表变得非常重要。通信节点K选择过大虽然可以做到信息及时交换但成本过高。节点选择K过小会降低集群内所有节点彼此信息交换频率，从而影响故障判定、新节点发现等需求的速度。因此Redis集群的Gossip协议需要兼顾信息交换实时性和成本开销。既然M和N最重要，那么我们就需要知道如何确定M和K的值，以及如何选出K个通信节点以及M个传输状态节点。\n\n#### 容错\n\nRedis Cluster可以为每个主节点设置若干个从节点，当主节点发生故障时，集群会自动将其中某个从节点提升为主节点。如果某个主节点没有从节点，那么当他发生故障时，集群将完全处于不可用状态。\n\n#### 可能下线（PFail）与确认下线（Fail)\n\n因为Cluster是去中心化的，一个节点认为某个节点失联了并不代表所有的节点都认为他失联了，所以集群还得经过一次协商的过程。只有大多数节点都认定某个节点失联了，集群才认为该节点需要进行主从切换来容错。\n\nRedis集群节点采用Gossip协议来广播自己的状态以及改变整个集群的认知。比如一个节点发现某个节点失联了（Possibly Fail），他会将这条信息向整个集群广播，其他节点就可以收到这点的失联信息。\n\n如果收到了某个节点失联的节点数量达到了集群的大多数，就可以标记该失联节点为确认下线状态。然后向整个集群广播，强迫其他节点也接收该节点已经下线的事实，并立即对该失联节点进行主从切换。","source":"_posts/数据库/Redis数据库/3.Redis集群.md","raw":"---\ntitle: Redis集群\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: Redis集群学习笔记，包括Redis主从复制、Redis哨兵、Redis集群等。\ncategories: Redis\ntags:\n  - 主从复制\n  - Sentinel\n  - 集群\nabbrlink: 37cf2cfd\ndate: 2020-11-29 00:00:00\n---\n\n\n\n# 主从复制\n\n## 简介\n\n#### 理解\n\n被复制的服务器称为主服务器，对主服务器进行复制的服务器称为从服务器\n\n进行复制中的主从服务器双方的数据库将保存相同的数据\n\n#### 优点\n\n+ 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。减轻主数据库的压力\n+ 一主多从，「主数据库(master)可以读也可以写(read/write)，从数据库仅读(only read)」。\n+ 主从一定程度上解决了单机版并发量大，导致请求延迟或者redis宕机服务停止的问题。\n+ 从数据库分担主数据库的读压力，若是主数据库是只写模式，那么实现读写分离，主数据库就没有了读压力了。\n+ 另一方面解决了单机版单点故障的问题，若是主数据库挂了，那么从数据库可以随时顶上来，综上来说，主从模式一定程度上提高了系统的可用性和性能，是实现哨兵和集群的基础。\n+ 主从同步以异步方式进行同步，期间Redis仍然可以响应客户端提交的查询和更新的请求。\n\n###### 缺点\n\n比如数据的一致性问题，假如主数据库写操作完成，那么他的数据会被复制到从数据库，若是还没有即使复制到从数据库，读请求又来了，此时读取的数据就不是最新的数据。\n\n若是从主同步的过程网络出故障了，导致主从同步失败，也会出现问题数据一致性的问题。\n\n主从模式不具备自动容错和恢复的功能，一旦主数据库，从节点晋升为主数据库的过程需要人为操作，维护的成本就会升高，并且主节点的写能力、存储能力都会受到限制。\n\n## 旧版复制功能的实现\n\n- **同步操作**（sync）**：**用于将从服务器的数据库状态**更新至**主服务器当前所处的数据库状态\n- **命令传播操作**（command propagate）**：**则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库**重新回到一致状态**\n\n#### 同步\n\n- **概念：**当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，**将从服务器的数据库状态更新至主服务器当前所处的数据库状态**\n\n- **SYNC命令：**\n\n    从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：\n\n    - ①从服务器向主服务器**发送SYNC命令**\n    - ②收到SYNC命令的主服务器**执行BGSAVE命令，在后台生成一个RDB文件**，并使用一 个缓冲区记录从现在开始执行的所有写命令\n    - ③当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的**RDB文件发送给从服务器**，从服务器**接收并载入**这个RDB文件，将自己的数据库状态更新至主服务器 执行BGSAVE命令时的数据库状态\n    - ④主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写 命令，将自己的数据库状态更新至主服务器数据库当前所处的状态\n\n- 下图展示了SYNC命令执行期间，主从服务器的通信过程：\n\n![20191201105150863](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105150863.png)\n\n#### 命令传播\n\n- 在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并**导致主从服务器状态不再一致**\n- 为了让主从服务器再次回到一致状态，**主服务器需要对从服务器执行命令传播操作：**主 服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态\n- 例如，主服务器执行了DEL k3的命令，那么主服务器将向从服务器发送相同的命令DEL k3，当从服务器执行完这个命令之后，主从服务器将再次回到一致状态，现在主从服务器两者的数据库都不再包含键k3了。\n\n#### 缺陷\n\n旧版复制功能在处理断线重复制情况时低效\n\n在Redis中，**从服务器对主服务器的复制可以分为以下两种情况：**\n\n- **初次复制：**从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务 器和上一次复制的主服务器不同。\n- **断线后重复制：**处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务 器通过自动重连接重新连上了主服务器，并继续复制主服务器\n\n![20191201105727757](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105727757.png)\n\n**为什么网络断开之后重新复制效率低，以上面的演示案例为例：**\n\n- 主从服务器在时间T0至时间T10086中一直处于一致状态，这两个服务器保存的数据**大部分都是相同的**\n- 从服务器想要将自己更新至主服务器当前所处的状态，**真正需要的是主从服务器连接中断期间**，主服务器新添加的k10087、k10088、k10089三个键的数据\n- 可惜的是，旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键k1至键k10089的RDB文件，但实际上RDB文件包含的键k1至键k10086的数据对于从服务器来说都是不必要的\n\n主从服务器断开的时 间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数 据，**却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的**\n\n## 新版复制功能的实现\n\n- 为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，**使用PSYNC命令代替SYNC命令**来执行复制时的同步操作\n- **PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：**\n    - **完整重同步：**用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步 骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步\n    - **部分重同步：**则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态\n- PSYNC命令的部分重同步模式**解决了旧版复制功能在处理断线后重复制时出现的低效情况**\n\n**执行部分重同步所需的资源比起执行SYNC命令所需的资源要少得多**，完成同步的速度也快得多。执行SYNC命令需要生成、传送和载入整个RDB文件，而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了\n\n## 部分重同步的实现\n\n**同步功能由以下三个部分构成：**\n\n- 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量\n- 主服务器的复制积压缓冲区（replication backlog）\n- 服务器的运行ID（run ID）\n\n#### 复制偏移量\n\n- 执行复制的双方——主服务器和从服务器会**分别维护一个复制偏移量：**\n\n    - 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N\n    - 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N\n\n- 通过对比主从服务器的复制偏移量，\n\n    **程序可以很容易地知道主从服务器是否处于一致状态：**\n\n    - 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的\n    - 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态\n\n在下图所示的例子中，主从服务器的复制偏移量的值都为10086\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121350757.png)\n\n如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121359413.png)\n\n#### 复制积压缓冲区\n\n- 复制积压缓冲区是由主服务器维护的一个**固定长度（fixed-size）先进先出（FIFO）队列**，默认大小为1MB\n- 当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会**将写命令入队到复制积压缓冲区里面**，如下图所示：\n- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121909779.png)\n- 因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会**为队列中的每个字节记录相应的复制偏移量**\n- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121943503.png)\n- 当从服务器重新连上主服务器时，从服务器会通过PSYNC命令**将自己的复制偏移量offset发送给主服务器**，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操 作：\n    - 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）**仍然存在于复制积压缓冲区里面**，那么主服务器将对从服务器执行部分重同步操作\n    - 相反，如果offset偏移量之后的数据**已经不存在于复制积压缓冲区**，那么主服务器将对从服务器执行完整重同步操作\n\n**演示案例：**\n\n- 回到之前上面图片所展示的断线后重连接例子：\n- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121522212.png)\n- 当从服务器A断线之后，它立即重新连接主服务器，并**向主服务器发送PSYNC命令，报告自己的复制偏移量为10086**\n- 主服务器收到从服务器发来的PSYNC命令以及偏移量10086之后，主服务器将**检查偏移量10086之后的数据是否存在于复制积压缓冲区里面**，结果发现**这些数据仍然存在**，于是主服务器向从服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行\n- 接着主服务器会将复制积压缓冲区10086偏移量之后的**所有数据（偏移量为10087至 10119）都发送给从服务器**\n- 从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态，如下图所示\n- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201122209306.png)\n\n#### 服务器运行ID\n\n- 除了复制偏移量和复制积压缓冲区之外，\n\n    **实现部分重同步还需要用到服务器运行ID（run ID）：**\n\n    - 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID\n    - 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3\n\n- 当从服务器对主服务器**进行初次复制时**，主服务器会**将自己的运行ID传送给从服务器**， 而从服务器则会将**这个运行ID保存起来**\n\n- 当从服务器断线并重新连上一个主服务器时，**从服务器将向当前连接的主服务器发送之前保存的运行ID：**\n\n    - 如果从服务器保存的运行ID和当前连接的主服务器的**运行ID相同**，那么说明从服务器 断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作\n    - 相反地，如果从服务器保存的运行ID和当前连接的主服务器的**运行ID并不相同**，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作\n\n- 举个例子，假设从服务器原本正在复制一个运行ID为 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3的主服务器，那么在网络断开，从服务器重新连 接上主服务器之后，从服务器将向主服务器发送这个运行ID，主服务器根据自己的运行ID是 否53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3来判断是执行部分重同步还是执行完整重同步\n\n## PSYNC命令的实现\n\n#### PSYNC命令的调用方法有两种：\n\n- 如果从服务器**以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令：**那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器**进行完整重同步**（因为这时不可能执行部分重同步）\n\n- 如果从服务器**已经复制过某个主服务器**\n\n    ，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC <runid> <offset>命令：\n\n    - 其中runid是上一次复制的主服务器的运行 ID，而offset则是从服务器当前的复制偏移量\n    - 接收到这个命令的主服务器会**通过这两个参数来判断应该对从服务器执行哪种同步操作**\n\n\n\n#### 接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：\n\n- 如果**主服务器返回+FULLRESYNC  回复**，那么**表示主服务器将与从服务器执行完整重同步操作：**其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起 来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器 会将这个值作为自己的初始化偏移量\n- 如果**主服务器返回+CONTINUE回复**，那么表示**主服务器将与从服务器执行部分重同步操作**，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了\n- 如果**主服务器返回-ERR回复**，那么表示主服务器的版本低于Redis 2.8，**它识别不了PSYNC命令**，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作\n\n\n\n#### 流程图\n\n- 下面的流程图总结了PSYNC命令执行完整重同步和部分重同步时可能遇上的情况：\n- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201123546284.png)\n\n\n\n#### 演示案例\n\n为了熟悉PSYNC命令的用法，让我们来看一个完整的复制——网络中断——重复制例 子\n\n- 首先，假设有两个Redis服务器，它们的版本都是Redis 2.8，其中主服务器的地址为 127.0.0.1:6379，从服务器的地址为127.0.0.1:12345\n- 如果客户端向从服务器发送命令SLAVEOF 127.0.0.1 6379，并且假设从服务器是第一次 执行复制操作，那么从服务器将向主服务器发送PSYNC ? -1命令，请求主服务器执行完整重 同步操作\n- 主服务器在收到完整重同步请求之后，将在后台执行BGSAVE命令，并向从服务器返回 +FULLRESYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 10086回复，其中 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3是主服务器的运行ID，而10086则是主服务器当 前的复制偏移量\n- 假设完整重同步成功执行，并且主从服务器在一段时间之后仍然保持一致，但是在复制 偏移量为20000的时候，主从服务器之间的网络连接中断了，这时从服务器将重新连接主服 务器，并再次对主服务器进行复制。\n- 因为之前曾经对主服务器进行过复制，所以从服务器将向主服务器发送命令PSYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 20000，请求进行部分重同步\n- 主服务器在接收到从服务器的PSYNC命令之后，首先对比从服务器传来的运行 ID53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3和主服务器自身的运行ID，结果显示该ID和 主服务器的运行ID相同，于是主服务器继续读取从服务器传来的偏移量20000，检查偏移量 为20000之后的数据是否存在于复制积压缓冲区里面，结果发现数据仍然存在\n- 确认运行ID相同并且数据存在之后，主服务器将向从服务器返回+CONTINUE回复，表 示将与从服务器执行部分重同步操作，之后主服务器会将保存在复制积压缓冲区20000偏移 量之后的所有数据发送给从服务器，主从服务器将再次回到一致状态\n\n\n\n## 复制的实现\n\n#### 步骤1:设置主服务器的地址和端口\n\n当客户端向从服务器发送以下命令时:`SLAVEOF 127.0.0.1 6379`\n\n从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379**保存到服务器状态的masterhost属性和masterport属性里面**\n\n```c\nstruct redisServer\n{\n\tchar * masterhost;//主服务器的地址\n\tint masterport;//主服务器的端口号\n};\n```\n\n**SLAVEOF命令是一个异步命令**，在完成masterhost属性和masterport属性的设置工作之 后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而**实际的复制工作将在OK返回之后才真正开始执行**\n\n#### 步骤2:建立套接字连接\n\n- 在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，**创建连向主服务器的套接字连接**，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131155414.png)\n\n- 如果**从服务器创建的套接字能成功连接（connect）到主服务器**，那么从服务器将为这个套接字关联一个专门**用于处理复制工作的文件事件处理器**，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类\n- 而**主服务器在接受（accept）从服务器的套接字连接之后**，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器（server）和客户端（client）两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131243941.png)\n\n- 因为复制工作接下来的几个步骤都会以从服务器向主服务器发送命令请求的形式来进 行，所以**理解“从服务器是主服务器的客户端”这一点非常重要**\n\n#### 步骤3:发送PING命令\n\n- 从服务器成为主服务器的客户端之后，做的第一件事就是**向主服务器发送一个PING命令**，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131333757.png)\n\n- **这个PING命令有两个作用：**\n    - 虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信， 通过发送PING命令可以**检查套接字的读写状态是否正常**\n    - 因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以**检查主服务器能否正常处理命令请求**\n- **从服务器在发送PING命令之后将遇到以下三种情况的其中一种：**\n    - 如果主服务器向从服务器返回了一个命令回复，但从服务器却**不能在规定的时限 （timeout）内读取出命令回复的内容**，那么表示主从服务器之间的网络连接状态不佳，不能 继续执行复制工作的后续步骤。当出现这种情况时，从服务器**断开并重新创建**连向主服务器 的套接字\n    - 如果主服务器**向从服务器返回一个错误**，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，**从服务器断开并重新创建连向主服务器的套接字**。比如说，如果主服务器正在处理一个超时运行的脚本，那么当从 服务器向主服务器发送PING命令时，从服务器将收到主服务器返回的BUSY Redisis busy running a script.You can only call SCRIPT KILL or SHUTDOWN NOSAVE.错误\n    - 如果从服务器**读取到\"PONG\"回复**，那么表示主从服务器之间的网络连接状态正常，并 且主服务器可以正常处理从服务器（客户端）发送的命令请求，在这种情况下，从服务器可 以继续执行复制工作的下个步骤\n- 下面的流程图总结了从服务器在发送PING命令时可能遇到的情况，以及各个情况的处理方式\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131558981.png)\n\n#### 步骤4:身份验证\n\n- 从服务器在收到主服务器返回的\"PONG\"回复之后，\n\n    **下一步要做的就是决定是否进行身份验证：**\n\n    - 如果从服务器设置了masterauth选项，那么进行身份验证\n    - 如果从服务器没有设置masterauth选项，那么不进行身份验证\n\n- 在需要进行身份验证的情况下，**从服务器将向主服务器发送一条AUTH命令**，命令的**参数为从服务器masterauth选项的值**\n\n- 举个例子，如果从服务器masterauth选项的值为10086，那么从服务器将向主服务器发送 命令AUTH 10086，如下图所示\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131632595.png)\n\n#### 步骤5:发送端口信息\n\n- 在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port ， **向主服务器发送从服务器的监听端口号**\n- 例如在我们的例子中，从服务器的监听端口为12345，那么从服务器将**向主服务器发送命令REPLCONF listening-port 12345**，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113200247.png)\n\n#### 步骤6:同步\n\n- 在这一步，从服务器将向主服务器发送PSYNC命令，***\\*执行同步操作\\****，并**将自己的数据库更新至主服务器数据库当前所处的状态**\n\n- 值得一提的是，在同步操作执行之前，只有从服务器是主服务器的客户端，但是\n\n    **在执行同步操作之后，主服务器也会成为从服务器的客户端：**\n\n    - 如果PSYNC命令执行的是**完整重同步操作**，那么主服务器需要成为从服务器的客户 端，才能将保存在缓冲区里面的写命令发送给从服务器执行。\n    - 如果PSYNC命令执行的是**部分重同步操作**，那么主服务器需要成为从服务器的客户 端，才能向从服务器发送保存在复制积压缓冲区里面的写命令\n\n- 因此，在同步操作执行之后，**主从服务器双方都是对方的客户端**，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113224549.png)\n\n- 正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命 令传播操作的基础\n\n#### 步骤7:命令传播\n\n- 当完成了同步之后，**主从服务器就会进入命令传播阶段**，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就**可以保证主从服务器一直保持一致了**\n\n\n\n## 心跳检测\n\n- 在命令传播阶段，从服务器默认会**以每秒一次的频率**，向主服务器发送命令：\n\n```bash\nREPLCONF ACK <replication_offset>\n//其中replication_offset是从服务器当前的复制偏移量\n```\n\n- **发送REPLCONF ACK命令对于主从服务器有三个作用：**\n    - ①检测主从服务器的网络连接状态\n    - ②辅助实现min-slaves选项\n    - ③检测命令丢失\n\n#### 检测主从服务器的网络连接状态（lag标志）\n\n- 主从服务器可以通过发送和接收REPLCONF ACK命令**来检查两者之间的网络连接是否正常：**如果主服务器**超过一秒钟没有收到**从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了\n- 通过向主服务器发送**INFO replication命令**，在列出的**从服务器列表的lag一栏中**，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令**距离现在过了多少秒。**在一般情况下，**lag的值应该在0秒或者1秒之间跳动**，如果超过1秒的话，那么说明主从 服务器之间的连接出现了故障。\n\n#### 辅助实现min-slaves配置选项\n\n- Redis的**min-slaves-to-write和min-slaves-max-lag两个选项**可以**防止主服务器在不安全的情况下执行写命令**\n- 举个例子，如果我们向主服务器提供以下设置：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201132859439.png)\n\n- 那么在**从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时**，主服务器将**拒绝执行写命令**，这里的延迟值就是上面提到的INFO replication命令的lag 值\n\n#### 检测命令丢失\n\n如果因为网络故障，**主服务器传播给从服务器的写命令在半路丢失**，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将**发觉**从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里 面找到从服务器缺少的数据，并**将这些数据重新发送给从服务器**\n\n#### 演示案例\n\n- 举个例子，假设有两个处于一致状态的主从服务器，它们的复制偏移量都是200，如下图所示\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133107682.png)\n\n- 如果这时主服务器执行了命令SET key value（协议格式的长度为33字节），将自己的复 制偏移量更新到了233，并尝试向从服务器传播命令SET key value，但这条命令却因为网络 故障而在传播的途中丢失，那么主从服务器之间的复制偏移量就会出现不一致，主服务器的 复制偏移量会被更新为233，而从服务器的复制偏移量仍然为200，如下图所示\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133127229.png)\n\n- 在这之后，当从服务器向主服务器发送REPLCONF ACK命令的时候，主服务器会察觉 从服务器的复制偏移量依然为200，而自己的复制偏移量为233，这说明复制积压缓冲区里面 复制偏移量为201至233的数据（也即是命令SET key value）在传播过程中丢失了，于是主服 务器会再次向从服务器传播命令SET key value，从服务器通过接收并执行这个命令可以将自 己更新至主服务器当前所处的状态，如下图所示\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133147307.png)\n\n# Redis哨兵\n\n## Sentinel\n\n#### 优点\n\n哨兵模式是主从的升级版，因为主从的出现故障后，不会自动恢复，需要人为干预。\n\n在主从的基础上，实现哨兵模式就是为了监控主从的运行状况，对主从的健壮进行监控，就好像哨兵一样，只要有异常就发出警告，对异常状况进行处理。\n\n总的概括来说，哨兵模式有以下的优点(功能点)：\n\n- 「监控」：监控master和slave是否正常运行，以及哨兵之间也会相互监控\n- 「自动故障恢复」：当master出现故障的时候，会自动选举一个slave作为master顶上去。\n- 哨兵模式是主从模式的升级版，所以在系统层面提高了系统的可用性和性能、稳定性。当master宕机的时候，能够自动进行故障恢复，需不要人为的干预。\n- 哨兵与哨兵之间、哨兵与master之间能够进行及时的监控，心跳检测，及时发现系统的问题，这都是弥补了主从的缺点。\n\n#### 缺点\n\n哨兵一主多从的模式同样也会遇到写的瓶颈，已经存储瓶颈，若是master宕机了，故障恢复的时间比较长，写的业务就会受到影响。\n\n增加了哨兵也增加了系统的复杂度，需要同时维护哨兵模式。\n\n#### 简介\n\nSentinel（哨岗、哨兵）是**Redis的高可用性（high availability）解决方案：**由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以**监视任意多个**主服务器，以及这些主服务器属下的所有从服务器，并在被监视的**主服务器进入下线状态时**，自动将下线主服务器属下的某个从服务器**升级为新的主服务器**，然后由新的主服务器代替已下线的主服务器继续处理命令请求\n\n\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201213815316.png)\n\n\n\n- 根据上面的图片，假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对 主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如下图所示（下线的服务器用虚线表示）\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214010487.png)\n\n- 当server1的**下线时长超过用户设定的下线时长上限时**，Sentinel系统就会对server1执行**故障转移**\n\n    操作：\n\n    - 首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器\n    - 之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕\n    - 另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器\n\n- 举个例子，下图展示了Sentinel系统**将server2升级为新的主服务器**，并让服务器server3和server4成为server2的从服务器的过程\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214149843.png)\n\n- 之后，如果server1**重新上线的话**，它将被Sentinel系统**降级为server2的从服务器**，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214154597.png)\n\n## 启动并初始化Sentinel\n\n启动`Sentinel`会执行以下操作：\n\n1. 初始化服务器\n2. 将普通Redis服务器使用的代码替换成`Sentinel`专用代码\n3. 初始化`Sentinel`状态\n4. 根据给定的配置文件,初始化`Sentinel`的监视主服务器列表\n5. 创建连向主服务器的网络连接\n\n#### 初始化Sentinel状态\n\n在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个**sentinel.c/sentinelState结构**（后面简称“Sentinel状态”），这个结构**保存了服务器中所有和Sentinel功能有关的状态** （服务器的一般状态仍然由redis.h/redisServer结构保存）\n\n```c\nstruct sentinelState {\n    //当前纪元，用于实现故障转移\n    uint64_t current_epoch;\n \n    //保存了所有被这个sentinel 监视的主服务器\n    dict *masters;\n    \n    //略\n} sentinel;\n```\n\n\n#### 初始化Sentinel状态的masters属性\n\nSentinel状态中的**masters字典记录了所有被Sentinel监视的主服务器的相关信息**，其中：\n\n- **字典的键**是被监视主服务器的名字\n- **字典的值**则是被监视主服务器对应的sentinel.c/**sentinelRedisInstance结构**\n\n\n\n- 每个sentinelRedisInstance结构（后面简称“实例结构”）**代表一个被Sentinel监视的Redis服务器实例**（instance），这个实例可以是**主服务器、从服务器，或者另外一个Sentinel**\n\n```c\ntypedef struct sentinelRedisInstance {\n    //标识值，记录了实例的类型，以及该实例的当前状态\n    int flags;\n \n    //实例的名字\n    //主服务器的名字由用户在配置文件中设置\n    //从服务器以及Sentinel 的名字由Sentinel 自动设置\n    //格式为ip:port ，例如\"127.0.0.1:26379\"\n    char *name;\n \n    //实例的运行ID\n    char *runid;\n \n    //配置纪元，用于实现故障转移\n    uint64_t config_epoch;\n \n    //实例的地址\n    sentinelAddr *addr;\n} sentinelRedisInstance;\n```\n\n```c\nstruct sentinelAddr\n{\n\tchar * ip;\n\tint port;\n}\n```\n\n###### 例子\n\n- 对Sentinel状态的初始化将引发对masters字典的初始化，而masters字典的初始化是**根据被载入的Sentinel配置文件**来进行的\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201220900699.png)\n\n#### 创建连向主服务器的网络连接\n\n- 初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，**Sentinel将成为主服务器的客户端**，它可以向主服务器发送命令，并从命令回复中获取相关的信息\n\n- 对于每个被Sentinel监视的主服务器来说，Sentinel会\n\n    **创建两个连向主服务器的异步网络连接：**\n\n    - 一个是**命令连接**，这个连接专门用于向主服务器发送命令，并接收命令回复\n    - 另一个是**订阅连接**，这个连接专门用于订阅主服务器的__sentinel__:hello频道\n\n\n\n## 获取主服务器的信息\n\n- Sentinel默认会以**每十秒一次的频率**，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来**获取主服务器的当前信息**\n\n- 通过分析主服务器返回的INFO命令回复，**Sentinel可以获取以下两方面的信息：**\n    - 一方面是**关于主服务器本身的信息**，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色\n    - 另一方面是关于主服务器属下**所有从服务器的信息**，每个从服务器都由一个\"slave\"字符 串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端 口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器\n- **根据run_id域和role域记录的信息，Sentinel将对主服务器的实例结构进行更新**，例如， 主服务器重启之后，它的运行ID就会和实例结构之前保存的运行ID不同，Sentinel检测到这 一情况之后，就会对实例结构的运行ID进行更新\n- Sentinel在分析INFO命令中包含的从服务器信息时，**会检查从服务器对应的实例结构是否已经存在于slaves字典：**\n    - 如果**从服务器对应的实例结构已经存在**，那么Sentinel对从服务器的实例结构进行更新\n    - 如果**从服务器对应的实例结构不存在**，那么说明这个从服务器是新发现的从服务器， Sentinel会在slaves字典中为这个从服务器新创建一个实例结构\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201223205478.png)\n\n## 获取从服务器信息\n\n- 当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的**从服务器创建相应的实例结构之外**，Sentinel还会创建连接到从服务器的**命令连接和订阅连接**\n- 举个例子，对于上面那张图所示的主从服务器关系来说，Sentinel将对slave0、slave1和 slave2三个从服务器分别创建命令连接和订阅连接，如下图所示：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120122373496.png)\n\n**根据INFO命令的回复，Sentinel会提取出以下信息：**\n\n- 从服务器的运行ID run_id\n- 从服务器的角色role\n- 主服务器的IP地址master_host，以及主服务器的端口号master_port\n- 主从服务器的连接状态master_link_status\n- 从服务器的优先级slave_priority\n- 从服务器的复制偏移量slave_repl_offset\n\n## Sentinel向主服务器和从服务器发送信息\n\n在默认情况下，Sentinel会以**每两秒一次的频率**，通过命令连接向所有被监视的**主服务器和从服务器**发送命令\n\n对于监视同一个服务器的多个Sentinel来说，**一个Sentinel发送的信息会被其他Sentinel接收到**，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。\n\n## Sentinel接收服务器和从服务器的频道信息\n\n当一个Sentinel从__sentinel__:hello频道收到一条信息时，Sentinel会对这条信息进行分 析，**提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：**\n\n- 如果信息中记录的Sentinel运行ID和接收信息的Sentinel的**运行ID相同**，那么说明这条信 息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理\n- 相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的**运行ID不相同**，那么 说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，**对相应主服务器的实例结构进行更新**\n- 因为一个Sentinel可以通过分析接收到的频道信息来**获知其他Sentinel的存在**，并通过发送频道信息来**让其他Sentinel知道自己**的存在，所以用户在使用Sentinel的时候并不需要提供各个Sentinel的地址信息，监视同一个主服务器的多个Sentinel**可以自动发现对方**\n- 当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，**还会创建一个连向新Sentinel的命令连接**，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的**多个Sentinel将形成相互连接的网络：**Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202184847281.png)\n\n## 检测主观下线状态\n\n- 在默认情况下，Sentinel会**以每秒一次的频率**向所有与它创建了命令连接的实例（**包括主服务器、从服务器、其他Sentinel在内**）发送**PING命令**，并通过实例返回的PING命令回复来判断实例是否在线\n- 如果配置文件指定Sentinel1的**down-after-milliseconds选项的值为50000毫秒**，那么当主服务器master连续50000毫秒都向Sentinel1**返回无效回复时**， Sentinel1就会将master标记为主观下线\n\n## 检测客观下线状态\n\n- 当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线 了，它会**向同样监视这一主服务器的其他Sentinel进行询问**，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里**接收到足够数量的已下线判断之后**，Sentinel就会将从服务器判定为客观下线，并对主服务器**执行故障转移操作**\n\n## 选取领头Sentinel\n\n- 当一个主服务器被判断为客观下线时，监视这个下线主服务器的**各个Sentinel会进行协商**，选举出一个领头Sentinel，并由领头Sentinel**对下线主服务器执行故障转移操作**\n\n- 1.**所有在线的Sentinel都有被选为领头Sentinel的资格**，换句话说，监视同一个主服务器的 多个在线Sentinel中的任意一个都有可能成为领头Sentinel\n- 2.每次进行领头Sentinel选举之后，**不论选举是否成功，所有Sentinel的配置纪元 （configuration epoch）的值都会自增一次**。配置纪元实际上就是一个计数器，并没有什么特别的\n- 3.在一个配置纪元里面，**所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会**，并且局部领头一旦设置，在这个配置每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel\n- 4.当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送**SENTINEL ismaster-down-by-addr命令**，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这**表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel**\n- 5.Sentinel设置局部领头Sentinel的规则是先到先得：**最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头**Sentinel，而**之后接收到的所有设置要求都会被目标Sentinel拒绝**\n- 6.目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，**将向源Sentinel返回 一条命令回复，**回复中的leader_runid参数和leader_epoch参数分别**记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元**\n- 7.源Sentinel在接收到目标Sentinel返回的命令回复之后，**会检查回复中leader_epoch参数的值和自己的配置纪元是否相同**，如果相同的话，那么源Sentinel继续取出回复中的 leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标 Sentinel将源Sentinel设置成了局部领头Sentinel\n- 8.如果**有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel**。举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于 10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成 为领头Sentine\n- 9.因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，**所以在一个配置纪元里面，只会出现一个领头 Sentinel**\n- 10.如果在给定时限内，**没有一个Sentinel被选举为领头Sentinel**，那么各个Sentinel将在一段时间之后**再次进行选举**，直到选出领头Sentinel为止\n\n## 故障转移\n\n- 在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器**执行故障转移操作**\n- **该操作包含下面3个步骤：**\n    - ①在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器\n    - ②让已下线主服务器属下的所有从服务器改为复制新的主服务器\n    - ③将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线 时，它就会成为新的主服务器的从服务器\n\n#### 选出新的主服务器\n\n- 故障转移操作第一步要做的就是**在已下线主服务器属下的所有从服务器中**，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送**SLAVEOF no one命令**，将这个**从服务器转换为主服务器**\n\n###### 演示案例\n\n- 下图展示了在一次故障转移操作中，领头Sentinel向**被选中的从服务器server2**发送SLAVEOF no one命令的情形：\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193156859.png)\n\n- 在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一 次），向被升级的从服务器**发送INFO命令，**并观察命令回复中的角色（role）信息，**当被升级服务器的role从原来的slave变为master时**，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了\n\n#### 修改从服务器的复制目标\n\n- 当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的**所有从服务器去复制新的主服务器**，这一动作可以**通过向从服务器发送SLAVEOF命令来实现**\n\n###### 图示\n\n- 下图展示了在故障转移操作中，领头Sentinel向已下线主服务器server1的两个从服务器server3和server4发送SLAVEOF命令，让**它们复制新的主服务器server2的例子**\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193616934.png)\n\n- 下图展示了**server3和server4成为server2的从服务器之后**，各个服务器以及领头Sentinel的样子\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193633254.png)\n\n#### 将旧的主服务器变为从服务器\n\n- 故障转移操作最后要做的是，**将已下线的主服务器设置为新的主服务器的从服务器**。比如说，下图就展示了被领头Sentinel设置为从服务器之后，服务器server1的样子\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193748287.png)\n\n- 因为旧的主服务器已经下线，所以这种设置是保存在server1对应的实例结构里面的，当 server1重新上线时，**Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器**\n- 例如，下图就展示了server1重新上线并成为server2的从服务器的例子\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193757739.png)\n\n\n\n# Redis集群\n\n###### 优点\n\n最后，Cluster是真正的集群模式了，哨兵解决和主从不能自动故障恢复的问题，但是同时也存在难以扩容以及单机存储、读写能力受限的问题，并且集群之前都是一台redis都是全量的数据，这样所有的redis都冗余一份，就会大大消耗内存空间。\n\n集群模式实现了Redis数据的分布式存储，实现数据的分片，每个redis节点存储不同的内容，并且解决了在线的节点收缩(下线)和扩容(上线)问题。\n\n集群模式真正意义上实现了系统的高可用和高性能，但是集群同时进一步使系统变得越来越复杂，接下来我们来详细的了解集群的运作原理。\n\n集群模式是一个无中心的架构模式，将数据进行分片，分布到对应的槽中，每个节点存储不同的数据内容，通过路由能够找到对应的节点负责存储的槽，能够实现高效率的查询。\n\n并且集群模式增加了横向和纵向的扩展能力，实现节点加入和收缩，集群模式是哨兵的升级版，哨兵的优点集群都有。\n\n###### 缺点\n\n缓存的最大问题就是带来数据一致性问题，在平衡数据一致性的问题时，兼顾性能与业务要求，大多数都是以最终一致性的方案进行解决，而不是强一致性。\n\n并且集群模式带来节点数量的剧增，一个集群模式最少要6台机，因为要满足半数原则的选举方式，所以也带来了架构的复杂性。\n\nslave只充当冷备，并不能缓解master的读的压力。\n\n#### 基本信息\n\n- Redis Cluster是去中心化的，例如一个集群由三个Redis节点组成，每个节点负责整个集群的一部分数据。这三个节点就相互连接组成一个对等的集群，他们之间通过一种特殊的二进制协议交互集群信息。\n\n- 所有数据划分为16384个槽位，每个节点负责其中一部分槽位，槽位的信息存储在每个节点中\n\n- 客户端为了可以直接定位到某个具体的key所在的节点，需要缓存槽位相关信息，这样才可以准确快速地定位到相应的节点。同时因为可能会存在客户端与服务器存储槽位的信息不一致的情况。还需要纠正机制来实现槽位信息的校验调整\n\n- 当客户端向一个错误的节点发出了指令后，该节点会发现指令的key所在的槽位并不归自己管理，这时他会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连接这个节点以获取数据\n\n- ```\n    GET x\n    -MOVED 3999 127.0.0.1:6381\n    //MOVED的一个参数3999是key对应的槽位编号，后面是目标节点的地址。\n    //MOVED指令前面有一个减号，表示该指令是一个错误消息\n    //客户端收到MOVED指令后，要立即纠正本地的槽位映射表。\n    //后续所有key将使用新的槽位映射表\n    ```\n\n    \n\n- \n\n#### 理解\n\n在Redis主从复制中介绍过利用主从节点实现读写分离来扩展主节点的数据读取能力，那么当主节点的写入能力成为瓶颈时，集群便是性能扩展的解决方案之一。Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。集群设计，本质上来讲是把数据存储在不同的数据节点上，这些节点可以独立的向外提供服务，那么需要解决的最重要几个问题是\n\n- 当新的写入数据到达时，该数据应该存储在哪台机器上。即数据分布问题\n- 当新的查询请求到达时，我们该如何知道这部分数据存储在哪个机器节点上。即查询路由问题。\n- 当新的节点加入时，我们该如何重新分配数据，让新的节点也对外提供服务。当有节点退出时，我们该如何把存在该节点上的数据分配到其他机器上，让其他机器来提供这部分数据的服务。即集群的扩缩容问题。\n- 当有节点因故障而不能提供服务时，如何能保证该集群仍然能正常向外提供服务。即高可用问题。\n\n#### 总结\n\n对于分布式存储，数据分区规则是核心问题之一，Redis集群中使用的是虚拟槽/虚拟桶分区，使用CRC16函数计算每个键的哈希值，并把所有的键划分到16384个桶中。数据存储在各个结点之后，当客户端访问键时，需要能够知道键所在的节点地址，Redis集群没有采用代理的方案，而是每个节点都保存集群中槽的负责节点信息，客户端可连接任意一个节点，当该节点发现客户端请求的键并不由自己负责时，会向客户端返回重定向，重定向中包含着负责该键的节点地址信息。同路由信息一样，Redis的集群元数据信息也是存储在各个节点上，并使用Gossip协议来完成集群的元数据同步。每个集群节点会每100ms向部分节点随机传输自己视角下的N/10个节点的信息，同时Redis集群节点会努力保证自己与其他的所有节点每node_timeout/2时间内至少通信一次。\n\n#### 数据分布\n\n分布式数据库首先要解决地把整个数据集按照分区规则映射到多个节点地问题。即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。如下图所示：\n\n![img](https://pic4.zhimg.com/80/v2-17d40b36ede8d8c4a3309306370f09f7_1440w.jpg)\n\n分布式存储数据分区\n\nRedis采用了虚拟桶分区方法，使用分散度良好地哈希函数把所有的数据均匀地哈希到K个桶中。具体实现中，Redis使用CRC16函数计算键的哈希值并把所有键分到16384个桶中，键的桶编号计算方法如下所示。每个桶**只能**由一个主节点存储，但一个主节点可以负责多个桶。Redis集群中，数据的迁移都是以桶为单位的，集群的扩缩容等价为桶在不同节点间的移动。\n\n```text\nHASH_SLOT = CRC16(key) mod 16384\n//默认对key值使用crc16算法进行hash，得到一个整数值，然后用这个整数值对16384进行取模得到具体槽位\n```\n\n#### 查询路由\n\n基于上述的分区方法，集群中的数据存储可能如下图所示。我们有5个节点，每个节点平均存储大约3273个桶（即16384/5）。那么当我们要进行一个键值的查询时，给定一个key，我们如何知道该key的值存储在哪个机器节点上呢？即我们需要一个查询路由，该路由根据给定的key，返回存储该键值的机器地址。\n\n![img](https://pic2.zhimg.com/80/v2-1fe6033d4997d85449ce6764251923e1_1440w.jpg)5个节点，每个节点负责一部分桶\n\n常规的实现方式便是采用如下图所示的代理方案，即采用一个中央节点（比如HDFS中的NameNode）来管理所有的元数据，但是这样的方案带来的最大问题就是代理节点很容易成为访问的瓶颈，当读写并发量高的时候，代理节点会严重的拖慢整个系统的性能。\n\n![img](https://pic1.zhimg.com/80/v2-936c9a100eda3f1a2c79c10901134180_1440w.jpg)采用代理的方案实现路由\n\nRedis没有选择使用代理，而是客户端直接连接每个节点。Redis的每个节点中都存储着如下所示的整个集群的状态，集群状态中一个重要的信息就是**每个桶的负责节点**。在具体的实现中，Redis用一个大小固定为CLUSTER_SLOTS的clusterNode数组 slots来保存每个桶的负责节点。在集群模式下，Redis接收任何键相关命令时首先**计算键对应的桶编号，再根据桶找出所对应的节点**，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，**通知客户端请求正确的节点，这个过程称为MOVED重定向**。重定向信息包含了键所对应的桶以及负责该桶的节点地址，根据这些信息客户端就可以向正确的节点发起请求。\n\n这样的话，假设集群中有N个主节点存储数据，那么客户端要查询一个键时，一次就恰好访问到正确节点的概率只有1/N。有(N-1)/N的概率是要请求两次的，第一次随机连接一个节点获得正确的节点地址，第二次从正确的节点中获取数据。当请求并发量比较大时，我们就会浪费大量的节点处理时间。一种较好的方案是在客户端把ClusterState中的slots数据信息缓存起来，这样每次客户端计算出对应的桶之后，根据本地的缓存获得正确的节点位置。这样便可以避免大量不必要的重复请求。当然，如果集群发生了扩缩容或者failover导致客户端缓存的信息过期时，客户端只需要在访问节点得到**MOVED**重定向时，重新更新下本地的缓存信息即可。这种缓存slots信息的客户端就是**Smart Client**。\n\n#### 集群扩容\n\n当集群中发生扩缩容时会发生桶的迁移，比如当节点A正在把桶334迁移到节点B，那么在迁移完成之前，桶334的一部分数据存在节点A，一部分数据存在节点B。**在迁移完成之前，集群中的所有节点都仍然会认为桶334由节点A负责**。所以当访问桶334中的数据时，请求会被统一路由到节点A，如果A发现客户端访问的键并不在本地存储（可能已经被迁移到了节点B，或者该键之前就不存在），那么节点A就会向客户端返回**ASK重定向**。ASK重定向同样会返回**槽值和节点B的地址**，客户端会根据ASK返回的重定向地址向B发起请求，看看新节点存不存在数据。对客户端来说，MOVED和ASK重定向的区别在于，**当客户端收到MOVED重定向时会选择更新本地的缓存，但是接收到ASK重定向并不会更新本地缓存。**当节点A和节点B完成了桶334的迁移之后，**节点B会向整个集群广播自己目前负责的桶的信息，之后整个集群的其他节点就会认为桶334由B负责，此时如果客户端再向节点A访问桶334的数据，那么节点A就会返回MOVED重定向。**即ASK重定向只会在数据迁移的时候发生，同时客户端接收到ASK重定向之后并不会更新本地缓存。\n\nASK指令只是用来临时纠正槽位的，不会刷新槽位映射关系表，不影响后续指令。\n\n#### 集群节点通信\n\n**集群中所有节点的状态以及桶-节点映射关系构成集群的元数据**，许多分布式存储系统的元数据管理是采用专门的元数据管理节点的，比如HDFS中的Name Node，但是**Redis集群的元数据是保存在各个Redis节点。如果元数据保存在各个节点上，我们需要解决的最重要的问题是如何保证各个节点的元数据一致性。**第一种方法便是每个节点都向其他所有的节点广播自己的元数据内容及元数据版本。每个节点接收到其他节点的元数据之后，如果发现接收到的数据版本比本地的版本更新，便用接收到的数据来更新本地的数据。这样做的好处，便是元数据同步的速度会很快，一旦一个节点的元数据修改，只要网络不断，可以很快的向其他节点同步数据，但是这样带来的坏处就是通信量的剧增。所有集群中的N个节点构成了一个全连接图，那么如果每个节点每100ms进行一次全局广播，那么每一次广播都会广播N^2条信息，这将占据大量的带宽。\n\nRedis采用**Gossip通信协议来进行集群元数据的同步**。Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息。每个Redis都会保存自己视角下的集群中其他节点的状态信息，具体实现中所有的节点信息都存储在clusterNode结构体中。那么使用Gossip协议，集群中的每个节点，每次会随机向几个节点传输自己视角下的集群其他节点状态。如果每次都传输所有的节点状态数据，那么数据体量又会过于庞大，于是Redis集群采用的最终的信息同步方式是： 一个大小为N的集群的每一个节点每次向随机K个其他节点传输自己视角下的随机M个节点的状态。其中M和K都远远小于N。\n\n虽然Gossip协议的信息交换机制具有天然的分布式特性，但它是有成本的。由于内部需要频繁地进行节点信息交换，而ping/pong消息会携带当前节点和其他M个节点的状态数据，势必会加重带宽和计算的负担。Redis集群内节点通信采用固定频率（定时任务每秒执行10次）。因此节点每次选择需要通信的节点列表变得非常重要。通信节点K选择过大虽然可以做到信息及时交换但成本过高。节点选择K过小会降低集群内所有节点彼此信息交换频率，从而影响故障判定、新节点发现等需求的速度。因此Redis集群的Gossip协议需要兼顾信息交换实时性和成本开销。既然M和N最重要，那么我们就需要知道如何确定M和K的值，以及如何选出K个通信节点以及M个传输状态节点。\n\n#### 容错\n\nRedis Cluster可以为每个主节点设置若干个从节点，当主节点发生故障时，集群会自动将其中某个从节点提升为主节点。如果某个主节点没有从节点，那么当他发生故障时，集群将完全处于不可用状态。\n\n#### 可能下线（PFail）与确认下线（Fail)\n\n因为Cluster是去中心化的，一个节点认为某个节点失联了并不代表所有的节点都认为他失联了，所以集群还得经过一次协商的过程。只有大多数节点都认定某个节点失联了，集群才认为该节点需要进行主从切换来容错。\n\nRedis集群节点采用Gossip协议来广播自己的状态以及改变整个集群的认知。比如一个节点发现某个节点失联了（Possibly Fail），他会将这条信息向整个集群广播，其他节点就可以收到这点的失联信息。\n\n如果收到了某个节点失联的节点数量达到了集群的大多数，就可以标记该失联节点为确认下线状态。然后向整个集群广播，强迫其他节点也接收该节点已经下线的事实，并立即对该失联节点进行主从切换。","slug":"数据库/Redis数据库/3.Redis集群","published":1,"updated":"2021-06-08T03:35:00.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq527004uz0tp1evudv3v","content":"<h1 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h4 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h4><p>被复制的服务器称为主服务器，对主服务器进行复制的服务器称为从服务器</p>\n<p>进行复制中的主从服务器双方的数据库将保存相同的数据</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。减轻主数据库的压力</li>\n<li>一主多从，「主数据库(master)可以读也可以写(read/write)，从数据库仅读(only read)」。</li>\n<li>主从一定程度上解决了单机版并发量大，导致请求延迟或者redis宕机服务停止的问题。</li>\n<li>从数据库分担主数据库的读压力，若是主数据库是只写模式，那么实现读写分离，主数据库就没有了读压力了。</li>\n<li>另一方面解决了单机版单点故障的问题，若是主数据库挂了，那么从数据库可以随时顶上来，综上来说，主从模式一定程度上提高了系统的可用性和性能，是实现哨兵和集群的基础。</li>\n<li>主从同步以异步方式进行同步，期间Redis仍然可以响应客户端提交的查询和更新的请求。</li>\n</ul>\n<h6 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h6><p>比如数据的一致性问题，假如主数据库写操作完成，那么他的数据会被复制到从数据库，若是还没有即使复制到从数据库，读请求又来了，此时读取的数据就不是最新的数据。</p>\n<p>若是从主同步的过程网络出故障了，导致主从同步失败，也会出现问题数据一致性的问题。</p>\n<p>主从模式不具备自动容错和恢复的功能，一旦主数据库，从节点晋升为主数据库的过程需要人为操作，维护的成本就会升高，并且主节点的写能力、存储能力都会受到限制。</p>\n<h2 id=\"旧版复制功能的实现\"><a href=\"#旧版复制功能的实现\" class=\"headerlink\" title=\"旧版复制功能的实现\"></a>旧版复制功能的实现</h2><ul>\n<li><strong>同步操作</strong>（sync）<strong>：</strong>用于将从服务器的数据库状态<strong>更新至</strong>主服务器当前所处的数据库状态</li>\n<li><strong>命令传播操作</strong>（command propagate）<strong>：</strong>则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库<strong>重新回到一致状态</strong></li>\n</ul>\n<h4 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h4><ul>\n<li><p><strong>概念：</strong>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，<strong>将从服务器的数据库状态更新至主服务器当前所处的数据库状态</strong></p>\n</li>\n<li><p><strong>SYNC命令：</strong></p>\n<p>  从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p>\n<ul>\n<li>①从服务器向主服务器<strong>发送SYNC命令</strong></li>\n<li>②收到SYNC命令的主服务器<strong>执行BGSAVE命令，在后台生成一个RDB文件</strong>，并使用一 个缓冲区记录从现在开始执行的所有写命令</li>\n<li>③当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的<strong>RDB文件发送给从服务器</strong>，从服务器<strong>接收并载入</strong>这个RDB文件，将自己的数据库状态更新至主服务器 执行BGSAVE命令时的数据库状态</li>\n<li>④主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写 命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</li>\n</ul>\n</li>\n<li><p>下图展示了SYNC命令执行期间，主从服务器的通信过程：</p>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105150863.png\" alt=\"20191201105150863\"></p>\n<h4 id=\"命令传播\"><a href=\"#命令传播\" class=\"headerlink\" title=\"命令传播\"></a>命令传播</h4><ul>\n<li>在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并<strong>导致主从服务器状态不再一致</strong></li>\n<li>为了让主从服务器再次回到一致状态，<strong>主服务器需要对从服务器执行命令传播操作：</strong>主 服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态</li>\n<li>例如，主服务器执行了DEL k3的命令，那么主服务器将向从服务器发送相同的命令DEL k3，当从服务器执行完这个命令之后，主从服务器将再次回到一致状态，现在主从服务器两者的数据库都不再包含键k3了。</li>\n</ul>\n<h4 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h4><p>旧版复制功能在处理断线重复制情况时低效</p>\n<p>在Redis中，<strong>从服务器对主服务器的复制可以分为以下两种情况：</strong></p>\n<ul>\n<li><strong>初次复制：</strong>从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务 器和上一次复制的主服务器不同。</li>\n<li><strong>断线后重复制：</strong>处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务 器通过自动重连接重新连上了主服务器，并继续复制主服务器</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105727757.png\" alt=\"20191201105727757\"></p>\n<p><strong>为什么网络断开之后重新复制效率低，以上面的演示案例为例：</strong></p>\n<ul>\n<li>主从服务器在时间T0至时间T10086中一直处于一致状态，这两个服务器保存的数据<strong>大部分都是相同的</strong></li>\n<li>从服务器想要将自己更新至主服务器当前所处的状态，<strong>真正需要的是主从服务器连接中断期间</strong>，主服务器新添加的k10087、k10088、k10089三个键的数据</li>\n<li>可惜的是，旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键k1至键k10089的RDB文件，但实际上RDB文件包含的键k1至键k10086的数据对于从服务器来说都是不必要的</li>\n</ul>\n<p>主从服务器断开的时 间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数 据，<strong>却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的</strong></p>\n<h2 id=\"新版复制功能的实现\"><a href=\"#新版复制功能的实现\" class=\"headerlink\" title=\"新版复制功能的实现\"></a>新版复制功能的实现</h2><ul>\n<li>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，<strong>使用PSYNC命令代替SYNC命令</strong>来执行复制时的同步操作</li>\n<li><strong>PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：</strong><ul>\n<li><strong>完整重同步：</strong>用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步 骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步</li>\n<li><strong>部分重同步：</strong>则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li>\n</ul>\n</li>\n<li>PSYNC命令的部分重同步模式<strong>解决了旧版复制功能在处理断线后重复制时出现的低效情况</strong></li>\n</ul>\n<p><strong>执行部分重同步所需的资源比起执行SYNC命令所需的资源要少得多</strong>，完成同步的速度也快得多。执行SYNC命令需要生成、传送和载入整个RDB文件，而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了</p>\n<h2 id=\"部分重同步的实现\"><a href=\"#部分重同步的实现\" class=\"headerlink\" title=\"部分重同步的实现\"></a>部分重同步的实现</h2><p><strong>同步功能由以下三个部分构成：</strong></p>\n<ul>\n<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li>\n<li>主服务器的复制积压缓冲区（replication backlog）</li>\n<li>服务器的运行ID（run ID）</li>\n</ul>\n<h4 id=\"复制偏移量\"><a href=\"#复制偏移量\" class=\"headerlink\" title=\"复制偏移量\"></a>复制偏移量</h4><ul>\n<li><p>执行复制的双方——主服务器和从服务器会<strong>分别维护一个复制偏移量：</strong></p>\n<ul>\n<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li>\n<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li>\n</ul>\n</li>\n<li><p>通过对比主从服务器的复制偏移量，</p>\n<p>  <strong>程序可以很容易地知道主从服务器是否处于一致状态：</strong></p>\n<ul>\n<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li>\n<li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</li>\n</ul>\n</li>\n</ul>\n<p>在下图所示的例子中，主从服务器的复制偏移量的值都为10086</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121350757.png\"></p>\n<p>如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121359413.png\" alt=\"img\"></p>\n<h4 id=\"复制积压缓冲区\"><a href=\"#复制积压缓冲区\" class=\"headerlink\" title=\"复制积压缓冲区\"></a>复制积压缓冲区</h4><ul>\n<li>复制积压缓冲区是由主服务器维护的一个<strong>固定长度（fixed-size）先进先出（FIFO）队列</strong>，默认大小为1MB</li>\n<li>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会<strong>将写命令入队到复制积压缓冲区里面</strong>，如下图所示：</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121909779.png\" alt=\"img\"></li>\n<li>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会<strong>为队列中的每个字节记录相应的复制偏移量</strong></li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121943503.png\" alt=\"img\"></li>\n<li>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令<strong>将自己的复制偏移量offset发送给主服务器</strong>，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操 作：<ul>\n<li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）<strong>仍然存在于复制积压缓冲区里面</strong>，那么主服务器将对从服务器执行部分重同步操作</li>\n<li>相反，如果offset偏移量之后的数据<strong>已经不存在于复制积压缓冲区</strong>，那么主服务器将对从服务器执行完整重同步操作</li>\n</ul>\n</li>\n</ul>\n<p><strong>演示案例：</strong></p>\n<ul>\n<li>回到之前上面图片所展示的断线后重连接例子：</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121522212.png\" alt=\"img\"></li>\n<li>当从服务器A断线之后，它立即重新连接主服务器，并<strong>向主服务器发送PSYNC命令，报告自己的复制偏移量为10086</strong></li>\n<li>主服务器收到从服务器发来的PSYNC命令以及偏移量10086之后，主服务器将<strong>检查偏移量10086之后的数据是否存在于复制积压缓冲区里面</strong>，结果发现<strong>这些数据仍然存在</strong>，于是主服务器向从服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行</li>\n<li>接着主服务器会将复制积压缓冲区10086偏移量之后的<strong>所有数据（偏移量为10087至 10119）都发送给从服务器</strong></li>\n<li>从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态，如下图所示</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201122209306.png\" alt=\"img\"></li>\n</ul>\n<h4 id=\"服务器运行ID\"><a href=\"#服务器运行ID\" class=\"headerlink\" title=\"服务器运行ID\"></a>服务器运行ID</h4><ul>\n<li><p>除了复制偏移量和复制积压缓冲区之外，</p>\n<p>  <strong>实现部分重同步还需要用到服务器运行ID（run ID）：</strong></p>\n<ul>\n<li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li>\n<li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3</li>\n</ul>\n</li>\n<li><p>当从服务器对主服务器<strong>进行初次复制时</strong>，主服务器会<strong>将自己的运行ID传送给从服务器</strong>， 而从服务器则会将<strong>这个运行ID保存起来</strong></p>\n</li>\n<li><p>当从服务器断线并重新连上一个主服务器时，<strong>从服务器将向当前连接的主服务器发送之前保存的运行ID：</strong></p>\n<ul>\n<li>如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID相同</strong>，那么说明从服务器 断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作</li>\n<li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID并不相同</strong>，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作</li>\n</ul>\n</li>\n<li><p>举个例子，假设从服务器原本正在复制一个运行ID为 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3的主服务器，那么在网络断开，从服务器重新连 接上主服务器之后，从服务器将向主服务器发送这个运行ID，主服务器根据自己的运行ID是 否53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3来判断是执行部分重同步还是执行完整重同步</p>\n</li>\n</ul>\n<h2 id=\"PSYNC命令的实现\"><a href=\"#PSYNC命令的实现\" class=\"headerlink\" title=\"PSYNC命令的实现\"></a>PSYNC命令的实现</h2><h4 id=\"PSYNC命令的调用方法有两种：\"><a href=\"#PSYNC命令的调用方法有两种：\" class=\"headerlink\" title=\"PSYNC命令的调用方法有两种：\"></a>PSYNC命令的调用方法有两种：</h4><ul>\n<li><p>如果从服务器<strong>以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令：</strong>那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器<strong>进行完整重同步</strong>（因为这时不可能执行部分重同步）</p>\n</li>\n<li><p>如果从服务器<strong>已经复制过某个主服务器</strong></p>\n<p>  ，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC <runid> <offset>命令：</p>\n<ul>\n<li>其中runid是上一次复制的主服务器的运行 ID，而offset则是从服务器当前的复制偏移量</li>\n<li>接收到这个命令的主服务器会<strong>通过这两个参数来判断应该对从服务器执行哪种同步操作</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：\"><a href=\"#接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：\" class=\"headerlink\" title=\"接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：\"></a>接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：</h4><ul>\n<li>如果<strong>主服务器返回+FULLRESYNC  回复</strong>，那么<strong>表示主服务器将与从服务器执行完整重同步操作：</strong>其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起 来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器 会将这个值作为自己的初始化偏移量</li>\n<li>如果<strong>主服务器返回+CONTINUE回复</strong>，那么表示<strong>主服务器将与从服务器执行部分重同步操作</strong>，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了</li>\n<li>如果<strong>主服务器返回-ERR回复</strong>，那么表示主服务器的版本低于Redis 2.8，<strong>它识别不了PSYNC命令</strong>，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作</li>\n</ul>\n<h4 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h4><ul>\n<li>下面的流程图总结了PSYNC命令执行完整重同步和部分重同步时可能遇上的情况：</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201123546284.png\" alt=\"img\"></li>\n</ul>\n<h4 id=\"演示案例\"><a href=\"#演示案例\" class=\"headerlink\" title=\"演示案例\"></a>演示案例</h4><p>为了熟悉PSYNC命令的用法，让我们来看一个完整的复制——网络中断——重复制例 子</p>\n<ul>\n<li>首先，假设有两个Redis服务器，它们的版本都是Redis 2.8，其中主服务器的地址为 127.0.0.1:6379，从服务器的地址为127.0.0.1:12345</li>\n<li>如果客户端向从服务器发送命令SLAVEOF 127.0.0.1 6379，并且假设从服务器是第一次 执行复制操作，那么从服务器将向主服务器发送PSYNC ? -1命令，请求主服务器执行完整重 同步操作</li>\n<li>主服务器在收到完整重同步请求之后，将在后台执行BGSAVE命令，并向从服务器返回 +FULLRESYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 10086回复，其中 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3是主服务器的运行ID，而10086则是主服务器当 前的复制偏移量</li>\n<li>假设完整重同步成功执行，并且主从服务器在一段时间之后仍然保持一致，但是在复制 偏移量为20000的时候，主从服务器之间的网络连接中断了，这时从服务器将重新连接主服 务器，并再次对主服务器进行复制。</li>\n<li>因为之前曾经对主服务器进行过复制，所以从服务器将向主服务器发送命令PSYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 20000，请求进行部分重同步</li>\n<li>主服务器在接收到从服务器的PSYNC命令之后，首先对比从服务器传来的运行 ID53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3和主服务器自身的运行ID，结果显示该ID和 主服务器的运行ID相同，于是主服务器继续读取从服务器传来的偏移量20000，检查偏移量 为20000之后的数据是否存在于复制积压缓冲区里面，结果发现数据仍然存在</li>\n<li>确认运行ID相同并且数据存在之后，主服务器将向从服务器返回+CONTINUE回复，表 示将与从服务器执行部分重同步操作，之后主服务器会将保存在复制积压缓冲区20000偏移 量之后的所有数据发送给从服务器，主从服务器将再次回到一致状态</li>\n</ul>\n<h2 id=\"复制的实现\"><a href=\"#复制的实现\" class=\"headerlink\" title=\"复制的实现\"></a>复制的实现</h2><h4 id=\"步骤1-设置主服务器的地址和端口\"><a href=\"#步骤1-设置主服务器的地址和端口\" class=\"headerlink\" title=\"步骤1:设置主服务器的地址和端口\"></a>步骤1:设置主服务器的地址和端口</h4><p>当客户端向从服务器发送以下命令时:<code>SLAVEOF 127.0.0.1 6379</code></p>\n<p>从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379<strong>保存到服务器状态的masterhost属性和masterport属性里面</strong></p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> redisServer\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> masterhost<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//主服务器的地址</span>\n    <span class=\"token keyword\">int</span> masterport<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//主服务器的端口号</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p><strong>SLAVEOF命令是一个异步命令</strong>，在完成masterhost属性和masterport属性的设置工作之 后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而<strong>实际的复制工作将在OK返回之后才真正开始执行</strong></p>\n<h4 id=\"步骤2-建立套接字连接\"><a href=\"#步骤2-建立套接字连接\" class=\"headerlink\" title=\"步骤2:建立套接字连接\"></a>步骤2:建立套接字连接</h4><ul>\n<li>在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，<strong>创建连向主服务器的套接字连接</strong>，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131155414.png\" alt=\"img\"></p>\n<ul>\n<li>如果<strong>从服务器创建的套接字能成功连接（connect）到主服务器</strong>，那么从服务器将为这个套接字关联一个专门<strong>用于处理复制工作的文件事件处理器</strong>，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类</li>\n<li>而<strong>主服务器在接受（accept）从服务器的套接字连接之后</strong>，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器（server）和客户端（client）两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131243941.png\" alt=\"img\"></p>\n<ul>\n<li>因为复制工作接下来的几个步骤都会以从服务器向主服务器发送命令请求的形式来进 行，所以<strong>理解“从服务器是主服务器的客户端”这一点非常重要</strong></li>\n</ul>\n<h4 id=\"步骤3-发送PING命令\"><a href=\"#步骤3-发送PING命令\" class=\"headerlink\" title=\"步骤3:发送PING命令\"></a>步骤3:发送PING命令</h4><ul>\n<li>从服务器成为主服务器的客户端之后，做的第一件事就是<strong>向主服务器发送一个PING命令</strong>，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131333757.png\" alt=\"img\"></p>\n<ul>\n<li><strong>这个PING命令有两个作用：</strong><ul>\n<li>虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信， 通过发送PING命令可以<strong>检查套接字的读写状态是否正常</strong></li>\n<li>因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以<strong>检查主服务器能否正常处理命令请求</strong></li>\n</ul>\n</li>\n<li><strong>从服务器在发送PING命令之后将遇到以下三种情况的其中一种：</strong><ul>\n<li>如果主服务器向从服务器返回了一个命令回复，但从服务器却<strong>不能在规定的时限 （timeout）内读取出命令回复的内容</strong>，那么表示主从服务器之间的网络连接状态不佳，不能 继续执行复制工作的后续步骤。当出现这种情况时，从服务器<strong>断开并重新创建</strong>连向主服务器 的套接字</li>\n<li>如果主服务器<strong>向从服务器返回一个错误</strong>，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，<strong>从服务器断开并重新创建连向主服务器的套接字</strong>。比如说，如果主服务器正在处理一个超时运行的脚本，那么当从 服务器向主服务器发送PING命令时，从服务器将收到主服务器返回的BUSY Redisis busy running a script.You can only call SCRIPT KILL or SHUTDOWN NOSAVE.错误</li>\n<li>如果从服务器<strong>读取到”PONG”回复</strong>，那么表示主从服务器之间的网络连接状态正常，并 且主服务器可以正常处理从服务器（客户端）发送的命令请求，在这种情况下，从服务器可 以继续执行复制工作的下个步骤</li>\n</ul>\n</li>\n<li>下面的流程图总结了从服务器在发送PING命令时可能遇到的情况，以及各个情况的处理方式</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131558981.png\" alt=\"img\"></p>\n<h4 id=\"步骤4-身份验证\"><a href=\"#步骤4-身份验证\" class=\"headerlink\" title=\"步骤4:身份验证\"></a>步骤4:身份验证</h4><ul>\n<li><p>从服务器在收到主服务器返回的”PONG”回复之后，</p>\n<p>  <strong>下一步要做的就是决定是否进行身份验证：</strong></p>\n<ul>\n<li>如果从服务器设置了masterauth选项，那么进行身份验证</li>\n<li>如果从服务器没有设置masterauth选项，那么不进行身份验证</li>\n</ul>\n</li>\n<li><p>在需要进行身份验证的情况下，<strong>从服务器将向主服务器发送一条AUTH命令</strong>，命令的<strong>参数为从服务器masterauth选项的值</strong></p>\n</li>\n<li><p>举个例子，如果从服务器masterauth选项的值为10086，那么从服务器将向主服务器发送 命令AUTH 10086，如下图所示</p>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131632595.png\" alt=\"img\"></p>\n<h4 id=\"步骤5-发送端口信息\"><a href=\"#步骤5-发送端口信息\" class=\"headerlink\" title=\"步骤5:发送端口信息\"></a>步骤5:发送端口信息</h4><ul>\n<li>在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port ， <strong>向主服务器发送从服务器的监听端口号</strong></li>\n<li>例如在我们的例子中，从服务器的监听端口为12345，那么从服务器将<strong>向主服务器发送命令REPLCONF listening-port 12345</strong>，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113200247.png\" alt=\"img\"></p>\n<h4 id=\"步骤6-同步\"><a href=\"#步骤6-同步\" class=\"headerlink\" title=\"步骤6:同步\"></a>步骤6:同步</h4><ul>\n<li><p>在这一步，从服务器将向主服务器发送PSYNC命令，*<strong>*执行同步操作**</strong>，并<strong>将自己的数据库更新至主服务器数据库当前所处的状态</strong></p>\n</li>\n<li><p>值得一提的是，在同步操作执行之前，只有从服务器是主服务器的客户端，但是</p>\n<p>  <strong>在执行同步操作之后，主服务器也会成为从服务器的客户端：</strong></p>\n<ul>\n<li>如果PSYNC命令执行的是<strong>完整重同步操作</strong>，那么主服务器需要成为从服务器的客户 端，才能将保存在缓冲区里面的写命令发送给从服务器执行。</li>\n<li>如果PSYNC命令执行的是<strong>部分重同步操作</strong>，那么主服务器需要成为从服务器的客户 端，才能向从服务器发送保存在复制积压缓冲区里面的写命令</li>\n</ul>\n</li>\n<li><p>因此，在同步操作执行之后，<strong>主从服务器双方都是对方的客户端</strong>，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复，如下图所示：</p>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113224549.png\" alt=\"img\"></p>\n<ul>\n<li>正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命 令传播操作的基础</li>\n</ul>\n<h4 id=\"步骤7-命令传播\"><a href=\"#步骤7-命令传播\" class=\"headerlink\" title=\"步骤7:命令传播\"></a>步骤7:命令传播</h4><ul>\n<li>当完成了同步之后，<strong>主从服务器就会进入命令传播阶段</strong>，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就<strong>可以保证主从服务器一直保持一致了</strong></li>\n</ul>\n<h2 id=\"心跳检测\"><a href=\"#心跳检测\" class=\"headerlink\" title=\"心跳检测\"></a>心跳检测</h2><ul>\n<li>在命令传播阶段，从服务器默认会<strong>以每秒一次的频率</strong>，向主服务器发送命令：</li>\n</ul>\n<pre class=\" language-bash\"><code class=\"language-bash\">REPLCONF ACK <span class=\"token operator\">&lt;</span>replication_offset<span class=\"token operator\">></span>\n//其中replication_offset是从服务器当前的复制偏移量</code></pre>\n<ul>\n<li><strong>发送REPLCONF ACK命令对于主从服务器有三个作用：</strong><ul>\n<li>①检测主从服务器的网络连接状态</li>\n<li>②辅助实现min-slaves选项</li>\n<li>③检测命令丢失</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"检测主从服务器的网络连接状态（lag标志）\"><a href=\"#检测主从服务器的网络连接状态（lag标志）\" class=\"headerlink\" title=\"检测主从服务器的网络连接状态（lag标志）\"></a>检测主从服务器的网络连接状态（lag标志）</h4><ul>\n<li>主从服务器可以通过发送和接收REPLCONF ACK命令<strong>来检查两者之间的网络连接是否正常：</strong>如果主服务器<strong>超过一秒钟没有收到</strong>从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了</li>\n<li>通过向主服务器发送<strong>INFO replication命令</strong>，在列出的<strong>从服务器列表的lag一栏中</strong>，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令<strong>距离现在过了多少秒。</strong>在一般情况下，<strong>lag的值应该在0秒或者1秒之间跳动</strong>，如果超过1秒的话，那么说明主从 服务器之间的连接出现了故障。</li>\n</ul>\n<h4 id=\"辅助实现min-slaves配置选项\"><a href=\"#辅助实现min-slaves配置选项\" class=\"headerlink\" title=\"辅助实现min-slaves配置选项\"></a>辅助实现min-slaves配置选项</h4><ul>\n<li>Redis的<strong>min-slaves-to-write和min-slaves-max-lag两个选项</strong>可以<strong>防止主服务器在不安全的情况下执行写命令</strong></li>\n<li>举个例子，如果我们向主服务器提供以下设置：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201132859439.png\" alt=\"img\"></p>\n<ul>\n<li>那么在<strong>从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时</strong>，主服务器将<strong>拒绝执行写命令</strong>，这里的延迟值就是上面提到的INFO replication命令的lag 值</li>\n</ul>\n<h4 id=\"检测命令丢失\"><a href=\"#检测命令丢失\" class=\"headerlink\" title=\"检测命令丢失\"></a>检测命令丢失</h4><p>如果因为网络故障，<strong>主服务器传播给从服务器的写命令在半路丢失</strong>，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将<strong>发觉</strong>从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里 面找到从服务器缺少的数据，并<strong>将这些数据重新发送给从服务器</strong></p>\n<h4 id=\"演示案例-1\"><a href=\"#演示案例-1\" class=\"headerlink\" title=\"演示案例\"></a>演示案例</h4><ul>\n<li>举个例子，假设有两个处于一致状态的主从服务器，它们的复制偏移量都是200，如下图所示</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133107682.png\" alt=\"img\"></p>\n<ul>\n<li>如果这时主服务器执行了命令SET key value（协议格式的长度为33字节），将自己的复 制偏移量更新到了233，并尝试向从服务器传播命令SET key value，但这条命令却因为网络 故障而在传播的途中丢失，那么主从服务器之间的复制偏移量就会出现不一致，主服务器的 复制偏移量会被更新为233，而从服务器的复制偏移量仍然为200，如下图所示</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133127229.png\" alt=\"img\"></p>\n<ul>\n<li>在这之后，当从服务器向主服务器发送REPLCONF ACK命令的时候，主服务器会察觉 从服务器的复制偏移量依然为200，而自己的复制偏移量为233，这说明复制积压缓冲区里面 复制偏移量为201至233的数据（也即是命令SET key value）在传播过程中丢失了，于是主服 务器会再次向从服务器传播命令SET key value，从服务器通过接收并执行这个命令可以将自 己更新至主服务器当前所处的状态，如下图所示</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133147307.png\" alt=\"img\"></p>\n<h1 id=\"Redis哨兵\"><a href=\"#Redis哨兵\" class=\"headerlink\" title=\"Redis哨兵\"></a>Redis哨兵</h1><h2 id=\"Sentinel\"><a href=\"#Sentinel\" class=\"headerlink\" title=\"Sentinel\"></a>Sentinel</h2><h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>哨兵模式是主从的升级版，因为主从的出现故障后，不会自动恢复，需要人为干预。</p>\n<p>在主从的基础上，实现哨兵模式就是为了监控主从的运行状况，对主从的健壮进行监控，就好像哨兵一样，只要有异常就发出警告，对异常状况进行处理。</p>\n<p>总的概括来说，哨兵模式有以下的优点(功能点)：</p>\n<ul>\n<li>「监控」：监控master和slave是否正常运行，以及哨兵之间也会相互监控</li>\n<li>「自动故障恢复」：当master出现故障的时候，会自动选举一个slave作为master顶上去。</li>\n<li>哨兵模式是主从模式的升级版，所以在系统层面提高了系统的可用性和性能、稳定性。当master宕机的时候，能够自动进行故障恢复，需不要人为的干预。</li>\n<li>哨兵与哨兵之间、哨兵与master之间能够进行及时的监控，心跳检测，及时发现系统的问题，这都是弥补了主从的缺点。</li>\n</ul>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>哨兵一主多从的模式同样也会遇到写的瓶颈，已经存储瓶颈，若是master宕机了，故障恢复的时间比较长，写的业务就会受到影响。</p>\n<p>增加了哨兵也增加了系统的复杂度，需要同时维护哨兵模式。</p>\n<h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>Sentinel（哨岗、哨兵）是<strong>Redis的高可用性（high availability）解决方案：</strong>由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以<strong>监视任意多个</strong>主服务器，以及这些主服务器属下的所有从服务器，并在被监视的<strong>主服务器进入下线状态时</strong>，自动将下线主服务器属下的某个从服务器<strong>升级为新的主服务器</strong>，然后由新的主服务器代替已下线的主服务器继续处理命令请求</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201213815316.png\" alt=\"img\"></p>\n<ul>\n<li>根据上面的图片，假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对 主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如下图所示（下线的服务器用虚线表示）</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214010487.png\" alt=\"img\"></p>\n<ul>\n<li><p>当server1的<strong>下线时长超过用户设定的下线时长上限时</strong>，Sentinel系统就会对server1执行<strong>故障转移</strong></p>\n<p>  操作：</p>\n<ul>\n<li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器</li>\n<li>之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕</li>\n<li>另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器</li>\n</ul>\n</li>\n<li><p>举个例子，下图展示了Sentinel系统<strong>将server2升级为新的主服务器</strong>，并让服务器server3和server4成为server2的从服务器的过程</p>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214149843.png\" alt=\"img\"></p>\n<ul>\n<li>之后，如果server1<strong>重新上线的话</strong>，它将被Sentinel系统<strong>降级为server2的从服务器</strong>，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214154597.png\" alt=\"img\"></p>\n<h2 id=\"启动并初始化Sentinel\"><a href=\"#启动并初始化Sentinel\" class=\"headerlink\" title=\"启动并初始化Sentinel\"></a>启动并初始化Sentinel</h2><p>启动<code>Sentinel</code>会执行以下操作：</p>\n<ol>\n<li>初始化服务器</li>\n<li>将普通Redis服务器使用的代码替换成<code>Sentinel</code>专用代码</li>\n<li>初始化<code>Sentinel</code>状态</li>\n<li>根据给定的配置文件,初始化<code>Sentinel</code>的监视主服务器列表</li>\n<li>创建连向主服务器的网络连接</li>\n</ol>\n<h4 id=\"初始化Sentinel状态\"><a href=\"#初始化Sentinel状态\" class=\"headerlink\" title=\"初始化Sentinel状态\"></a>初始化Sentinel状态</h4><p>在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个<strong>sentinel.c/sentinelState结构</strong>（后面简称“Sentinel状态”），这个结构<strong>保存了服务器中所有和Sentinel功能有关的状态</strong> （服务器的一般状态仍然由redis.h/redisServer结构保存）</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> sentinelState <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//当前纪元，用于实现故障转移</span>\n    uint64_t current_epoch<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//保存了所有被这个sentinel 监视的主服务器</span>\n    dict <span class=\"token operator\">*</span>masters<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//略</span>\n<span class=\"token punctuation\">}</span> sentinel<span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"初始化Sentinel状态的masters属性\"><a href=\"#初始化Sentinel状态的masters属性\" class=\"headerlink\" title=\"初始化Sentinel状态的masters属性\"></a>初始化Sentinel状态的masters属性</h4><p>Sentinel状态中的<strong>masters字典记录了所有被Sentinel监视的主服务器的相关信息</strong>，其中：</p>\n<ul>\n<li><strong>字典的键</strong>是被监视主服务器的名字</li>\n<li><strong>字典的值</strong>则是被监视主服务器对应的sentinel.c/<strong>sentinelRedisInstance结构</strong></li>\n</ul>\n<ul>\n<li>每个sentinelRedisInstance结构（后面简称“实例结构”）<strong>代表一个被Sentinel监视的Redis服务器实例</strong>（instance），这个实例可以是<strong>主服务器、从服务器，或者另外一个Sentinel</strong></li>\n</ul>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> sentinelRedisInstance <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//标识值，记录了实例的类型，以及该实例的当前状态</span>\n    <span class=\"token keyword\">int</span> flags<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//实例的名字</span>\n    <span class=\"token comment\" spellcheck=\"true\">//主服务器的名字由用户在配置文件中设置</span>\n    <span class=\"token comment\" spellcheck=\"true\">//从服务器以及Sentinel 的名字由Sentinel 自动设置</span>\n    <span class=\"token comment\" spellcheck=\"true\">//格式为ip:port ，例如\"127.0.0.1:26379\"</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//实例的运行ID</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>runid<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//配置纪元，用于实现故障转移</span>\n    uint64_t config_epoch<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//实例的地址</span>\n    sentinelAddr <span class=\"token operator\">*</span>addr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> sentinelRedisInstance<span class=\"token punctuation\">;</span></code></pre>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> sentinelAddr\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> ip<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> port<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h6 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h6><ul>\n<li>对Sentinel状态的初始化将引发对masters字典的初始化，而masters字典的初始化是<strong>根据被载入的Sentinel配置文件</strong>来进行的</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201220900699.png\" alt=\"img\"></p>\n<h4 id=\"创建连向主服务器的网络连接\"><a href=\"#创建连向主服务器的网络连接\" class=\"headerlink\" title=\"创建连向主服务器的网络连接\"></a>创建连向主服务器的网络连接</h4><ul>\n<li><p>初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，<strong>Sentinel将成为主服务器的客户端</strong>，它可以向主服务器发送命令，并从命令回复中获取相关的信息</p>\n</li>\n<li><p>对于每个被Sentinel监视的主服务器来说，Sentinel会</p>\n<p>  <strong>创建两个连向主服务器的异步网络连接：</strong></p>\n<ul>\n<li>一个是<strong>命令连接</strong>，这个连接专门用于向主服务器发送命令，并接收命令回复</li>\n<li>另一个是<strong>订阅连接</strong>，这个连接专门用于订阅主服务器的<strong>sentinel</strong>:hello频道</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"获取主服务器的信息\"><a href=\"#获取主服务器的信息\" class=\"headerlink\" title=\"获取主服务器的信息\"></a>获取主服务器的信息</h2><ul>\n<li><p>Sentinel默认会以<strong>每十秒一次的频率</strong>，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来<strong>获取主服务器的当前信息</strong></p>\n</li>\n<li><p>通过分析主服务器返回的INFO命令回复，<strong>Sentinel可以获取以下两方面的信息：</strong></p>\n<ul>\n<li>一方面是<strong>关于主服务器本身的信息</strong>，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色</li>\n<li>另一方面是关于主服务器属下<strong>所有从服务器的信息</strong>，每个从服务器都由一个”slave”字符 串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端 口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器</li>\n</ul>\n</li>\n<li><p><strong>根据run_id域和role域记录的信息，Sentinel将对主服务器的实例结构进行更新</strong>，例如， 主服务器重启之后，它的运行ID就会和实例结构之前保存的运行ID不同，Sentinel检测到这 一情况之后，就会对实例结构的运行ID进行更新</p>\n</li>\n<li><p>Sentinel在分析INFO命令中包含的从服务器信息时，<strong>会检查从服务器对应的实例结构是否已经存在于slaves字典：</strong></p>\n<ul>\n<li>如果<strong>从服务器对应的实例结构已经存在</strong>，那么Sentinel对从服务器的实例结构进行更新</li>\n<li>如果<strong>从服务器对应的实例结构不存在</strong>，那么说明这个从服务器是新发现的从服务器， Sentinel会在slaves字典中为这个从服务器新创建一个实例结构</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201223205478.png\" alt=\"img\"></p>\n<h2 id=\"获取从服务器信息\"><a href=\"#获取从服务器信息\" class=\"headerlink\" title=\"获取从服务器信息\"></a>获取从服务器信息</h2><ul>\n<li>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的<strong>从服务器创建相应的实例结构之外</strong>，Sentinel还会创建连接到从服务器的<strong>命令连接和订阅连接</strong></li>\n<li>举个例子，对于上面那张图所示的主从服务器关系来说，Sentinel将对slave0、slave1和 slave2三个从服务器分别创建命令连接和订阅连接，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120122373496.png\" alt=\"img\"></p>\n<p><strong>根据INFO命令的回复，Sentinel会提取出以下信息：</strong></p>\n<ul>\n<li>从服务器的运行ID run_id</li>\n<li>从服务器的角色role</li>\n<li>主服务器的IP地址master_host，以及主服务器的端口号master_port</li>\n<li>主从服务器的连接状态master_link_status</li>\n<li>从服务器的优先级slave_priority</li>\n<li>从服务器的复制偏移量slave_repl_offset</li>\n</ul>\n<h2 id=\"Sentinel向主服务器和从服务器发送信息\"><a href=\"#Sentinel向主服务器和从服务器发送信息\" class=\"headerlink\" title=\"Sentinel向主服务器和从服务器发送信息\"></a>Sentinel向主服务器和从服务器发送信息</h2><p>在默认情况下，Sentinel会以<strong>每两秒一次的频率</strong>，通过命令连接向所有被监视的<strong>主服务器和从服务器</strong>发送命令</p>\n<p>对于监视同一个服务器的多个Sentinel来说，<strong>一个Sentinel发送的信息会被其他Sentinel接收到</strong>，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。</p>\n<h2 id=\"Sentinel接收服务器和从服务器的频道信息\"><a href=\"#Sentinel接收服务器和从服务器的频道信息\" class=\"headerlink\" title=\"Sentinel接收服务器和从服务器的频道信息\"></a>Sentinel接收服务器和从服务器的频道信息</h2><p>当一个Sentinel从<strong>sentinel</strong>:hello频道收到一条信息时，Sentinel会对这条信息进行分 析，<strong>提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：</strong></p>\n<ul>\n<li>如果信息中记录的Sentinel运行ID和接收信息的Sentinel的<strong>运行ID相同</strong>，那么说明这条信 息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理</li>\n<li>相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的<strong>运行ID不相同</strong>，那么 说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，<strong>对相应主服务器的实例结构进行更新</strong></li>\n<li>因为一个Sentinel可以通过分析接收到的频道信息来<strong>获知其他Sentinel的存在</strong>，并通过发送频道信息来<strong>让其他Sentinel知道自己</strong>的存在，所以用户在使用Sentinel的时候并不需要提供各个Sentinel的地址信息，监视同一个主服务器的多个Sentinel<strong>可以自动发现对方</strong></li>\n<li>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，<strong>还会创建一个连向新Sentinel的命令连接</strong>，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的<strong>多个Sentinel将形成相互连接的网络：</strong>Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202184847281.png\" alt=\"img\"></p>\n<h2 id=\"检测主观下线状态\"><a href=\"#检测主观下线状态\" class=\"headerlink\" title=\"检测主观下线状态\"></a>检测主观下线状态</h2><ul>\n<li>在默认情况下，Sentinel会<strong>以每秒一次的频率</strong>向所有与它创建了命令连接的实例（<strong>包括主服务器、从服务器、其他Sentinel在内</strong>）发送<strong>PING命令</strong>，并通过实例返回的PING命令回复来判断实例是否在线</li>\n<li>如果配置文件指定Sentinel1的<strong>down-after-milliseconds选项的值为50000毫秒</strong>，那么当主服务器master连续50000毫秒都向Sentinel1<strong>返回无效回复时</strong>， Sentinel1就会将master标记为主观下线</li>\n</ul>\n<h2 id=\"检测客观下线状态\"><a href=\"#检测客观下线状态\" class=\"headerlink\" title=\"检测客观下线状态\"></a>检测客观下线状态</h2><ul>\n<li>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线 了，它会<strong>向同样监视这一主服务器的其他Sentinel进行询问</strong>，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里<strong>接收到足够数量的已下线判断之后</strong>，Sentinel就会将从服务器判定为客观下线，并对主服务器<strong>执行故障转移操作</strong></li>\n</ul>\n<h2 id=\"选取领头Sentinel\"><a href=\"#选取领头Sentinel\" class=\"headerlink\" title=\"选取领头Sentinel\"></a>选取领头Sentinel</h2><ul>\n<li><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的<strong>各个Sentinel会进行协商</strong>，选举出一个领头Sentinel，并由领头Sentinel<strong>对下线主服务器执行故障转移操作</strong></p>\n</li>\n<li><p>1.<strong>所有在线的Sentinel都有被选为领头Sentinel的资格</strong>，换句话说，监视同一个主服务器的 多个在线Sentinel中的任意一个都有可能成为领头Sentinel</p>\n</li>\n<li><p>2.每次进行领头Sentinel选举之后，<strong>不论选举是否成功，所有Sentinel的配置纪元 （configuration epoch）的值都会自增一次</strong>。配置纪元实际上就是一个计数器，并没有什么特别的</p>\n</li>\n<li><p>3.在一个配置纪元里面，<strong>所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会</strong>，并且局部领头一旦设置，在这个配置每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel</p>\n</li>\n<li><p>4.当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送<strong>SENTINEL ismaster-down-by-addr命令</strong>，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这<strong>表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel</strong></p>\n</li>\n<li><p>5.Sentinel设置局部领头Sentinel的规则是先到先得：<strong>最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头</strong>Sentinel，而<strong>之后接收到的所有设置要求都会被目标Sentinel拒绝</strong></p>\n</li>\n<li><p>6.目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，<strong>将向源Sentinel返回 一条命令回复，</strong>回复中的leader_runid参数和leader_epoch参数分别<strong>记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元</strong></p>\n</li>\n<li><p>7.源Sentinel在接收到目标Sentinel返回的命令回复之后，<strong>会检查回复中leader_epoch参数的值和自己的配置纪元是否相同</strong>，如果相同的话，那么源Sentinel继续取出回复中的 leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标 Sentinel将源Sentinel设置成了局部领头Sentinel</p>\n</li>\n<li><p>8.如果<strong>有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel</strong>。举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于 10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成 为领头Sentine</p>\n</li>\n<li><p>9.因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，<strong>所以在一个配置纪元里面，只会出现一个领头 Sentinel</strong></p>\n</li>\n<li><p>10.如果在给定时限内，<strong>没有一个Sentinel被选举为领头Sentinel</strong>，那么各个Sentinel将在一段时间之后<strong>再次进行选举</strong>，直到选出领头Sentinel为止</p>\n</li>\n</ul>\n<h2 id=\"故障转移\"><a href=\"#故障转移\" class=\"headerlink\" title=\"故障转移\"></a>故障转移</h2><ul>\n<li>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器<strong>执行故障转移操作</strong></li>\n<li><strong>该操作包含下面3个步骤：</strong><ul>\n<li>①在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器</li>\n<li>②让已下线主服务器属下的所有从服务器改为复制新的主服务器</li>\n<li>③将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线 时，它就会成为新的主服务器的从服务器</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"选出新的主服务器\"><a href=\"#选出新的主服务器\" class=\"headerlink\" title=\"选出新的主服务器\"></a>选出新的主服务器</h4><ul>\n<li>故障转移操作第一步要做的就是<strong>在已下线主服务器属下的所有从服务器中</strong>，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送<strong>SLAVEOF no one命令</strong>，将这个<strong>从服务器转换为主服务器</strong></li>\n</ul>\n<h6 id=\"演示案例-2\"><a href=\"#演示案例-2\" class=\"headerlink\" title=\"演示案例\"></a>演示案例</h6><ul>\n<li>下图展示了在一次故障转移操作中，领头Sentinel向<strong>被选中的从服务器server2</strong>发送SLAVEOF no one命令的情形：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193156859.png\" alt=\"img\"></p>\n<ul>\n<li>在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一 次），向被升级的从服务器<strong>发送INFO命令，</strong>并观察命令回复中的角色（role）信息，<strong>当被升级服务器的role从原来的slave变为master时</strong>，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了</li>\n</ul>\n<h4 id=\"修改从服务器的复制目标\"><a href=\"#修改从服务器的复制目标\" class=\"headerlink\" title=\"修改从服务器的复制目标\"></a>修改从服务器的复制目标</h4><ul>\n<li>当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的<strong>所有从服务器去复制新的主服务器</strong>，这一动作可以<strong>通过向从服务器发送SLAVEOF命令来实现</strong></li>\n</ul>\n<h6 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h6><ul>\n<li>下图展示了在故障转移操作中，领头Sentinel向已下线主服务器server1的两个从服务器server3和server4发送SLAVEOF命令，让<strong>它们复制新的主服务器server2的例子</strong></li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193616934.png\" alt=\"img\"></p>\n<ul>\n<li>下图展示了<strong>server3和server4成为server2的从服务器之后</strong>，各个服务器以及领头Sentinel的样子</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193633254.png\" alt=\"img\"></p>\n<h4 id=\"将旧的主服务器变为从服务器\"><a href=\"#将旧的主服务器变为从服务器\" class=\"headerlink\" title=\"将旧的主服务器变为从服务器\"></a>将旧的主服务器变为从服务器</h4><ul>\n<li>故障转移操作最后要做的是，<strong>将已下线的主服务器设置为新的主服务器的从服务器</strong>。比如说，下图就展示了被领头Sentinel设置为从服务器之后，服务器server1的样子</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193748287.png\" alt=\"img\"></p>\n<ul>\n<li>因为旧的主服务器已经下线，所以这种设置是保存在server1对应的实例结构里面的，当 server1重新上线时，<strong>Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器</strong></li>\n<li>例如，下图就展示了server1重新上线并成为server2的从服务器的例子</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193757739.png\" alt=\"img\"></p>\n<h1 id=\"Redis集群\"><a href=\"#Redis集群\" class=\"headerlink\" title=\"Redis集群\"></a>Redis集群</h1><h6 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h6><p>最后，Cluster是真正的集群模式了，哨兵解决和主从不能自动故障恢复的问题，但是同时也存在难以扩容以及单机存储、读写能力受限的问题，并且集群之前都是一台redis都是全量的数据，这样所有的redis都冗余一份，就会大大消耗内存空间。</p>\n<p>集群模式实现了Redis数据的分布式存储，实现数据的分片，每个redis节点存储不同的内容，并且解决了在线的节点收缩(下线)和扩容(上线)问题。</p>\n<p>集群模式真正意义上实现了系统的高可用和高性能，但是集群同时进一步使系统变得越来越复杂，接下来我们来详细的了解集群的运作原理。</p>\n<p>集群模式是一个无中心的架构模式，将数据进行分片，分布到对应的槽中，每个节点存储不同的数据内容，通过路由能够找到对应的节点负责存储的槽，能够实现高效率的查询。</p>\n<p>并且集群模式增加了横向和纵向的扩展能力，实现节点加入和收缩，集群模式是哨兵的升级版，哨兵的优点集群都有。</p>\n<h6 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h6><p>缓存的最大问题就是带来数据一致性问题，在平衡数据一致性的问题时，兼顾性能与业务要求，大多数都是以最终一致性的方案进行解决，而不是强一致性。</p>\n<p>并且集群模式带来节点数量的剧增，一个集群模式最少要6台机，因为要满足半数原则的选举方式，所以也带来了架构的复杂性。</p>\n<p>slave只充当冷备，并不能缓解master的读的压力。</p>\n<h4 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><ul>\n<li><p>Redis Cluster是去中心化的，例如一个集群由三个Redis节点组成，每个节点负责整个集群的一部分数据。这三个节点就相互连接组成一个对等的集群，他们之间通过一种特殊的二进制协议交互集群信息。</p>\n</li>\n<li><p>所有数据划分为16384个槽位，每个节点负责其中一部分槽位，槽位的信息存储在每个节点中</p>\n</li>\n<li><p>客户端为了可以直接定位到某个具体的key所在的节点，需要缓存槽位相关信息，这样才可以准确快速地定位到相应的节点。同时因为可能会存在客户端与服务器存储槽位的信息不一致的情况。还需要纠正机制来实现槽位信息的校验调整</p>\n</li>\n<li><p>当客户端向一个错误的节点发出了指令后，该节点会发现指令的key所在的槽位并不归自己管理，这时他会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连接这个节点以获取数据</p>\n</li>\n<li><pre><code>  GET x\n  -MOVED 3999 127.0.0.1:6381\n  //MOVED的一个参数3999是key对应的槽位编号，后面是目标节点的地址。\n  //MOVED指令前面有一个减号，表示该指令是一个错误消息\n  //客户端收到MOVED指令后，要立即纠正本地的槽位映射表。\n  //后续所有key将使用新的槽位映射表</code></pre>\n</li>\n</ul>\n<ul>\n<li><h4 id=\"理解-1\"><a href=\"#理解-1\" class=\"headerlink\" title=\"理解\"></a>理解</h4></li>\n</ul>\n<p>在Redis主从复制中介绍过利用主从节点实现读写分离来扩展主节点的数据读取能力，那么当主节点的写入能力成为瓶颈时，集群便是性能扩展的解决方案之一。Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。集群设计，本质上来讲是把数据存储在不同的数据节点上，这些节点可以独立的向外提供服务，那么需要解决的最重要几个问题是</p>\n<ul>\n<li>当新的写入数据到达时，该数据应该存储在哪台机器上。即数据分布问题</li>\n<li>当新的查询请求到达时，我们该如何知道这部分数据存储在哪个机器节点上。即查询路由问题。</li>\n<li>当新的节点加入时，我们该如何重新分配数据，让新的节点也对外提供服务。当有节点退出时，我们该如何把存在该节点上的数据分配到其他机器上，让其他机器来提供这部分数据的服务。即集群的扩缩容问题。</li>\n<li>当有节点因故障而不能提供服务时，如何能保证该集群仍然能正常向外提供服务。即高可用问题。</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>对于分布式存储，数据分区规则是核心问题之一，Redis集群中使用的是虚拟槽/虚拟桶分区，使用CRC16函数计算每个键的哈希值，并把所有的键划分到16384个桶中。数据存储在各个结点之后，当客户端访问键时，需要能够知道键所在的节点地址，Redis集群没有采用代理的方案，而是每个节点都保存集群中槽的负责节点信息，客户端可连接任意一个节点，当该节点发现客户端请求的键并不由自己负责时，会向客户端返回重定向，重定向中包含着负责该键的节点地址信息。同路由信息一样，Redis的集群元数据信息也是存储在各个节点上，并使用Gossip协议来完成集群的元数据同步。每个集群节点会每100ms向部分节点随机传输自己视角下的N/10个节点的信息，同时Redis集群节点会努力保证自己与其他的所有节点每node_timeout/2时间内至少通信一次。</p>\n<h4 id=\"数据分布\"><a href=\"#数据分布\" class=\"headerlink\" title=\"数据分布\"></a>数据分布</h4><p>分布式数据库首先要解决地把整个数据集按照分区规则映射到多个节点地问题。即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。如下图所示：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-17d40b36ede8d8c4a3309306370f09f7_1440w.jpg\" alt=\"img\"></p>\n<p>分布式存储数据分区</p>\n<p>Redis采用了虚拟桶分区方法，使用分散度良好地哈希函数把所有的数据均匀地哈希到K个桶中。具体实现中，Redis使用CRC16函数计算键的哈希值并把所有键分到16384个桶中，键的桶编号计算方法如下所示。每个桶<strong>只能</strong>由一个主节点存储，但一个主节点可以负责多个桶。Redis集群中，数据的迁移都是以桶为单位的，集群的扩缩容等价为桶在不同节点间的移动。</p>\n<pre class=\" language-text\"><code class=\"language-text\">HASH_SLOT = CRC16(key) mod 16384\n//默认对key值使用crc16算法进行hash，得到一个整数值，然后用这个整数值对16384进行取模得到具体槽位</code></pre>\n<h4 id=\"查询路由\"><a href=\"#查询路由\" class=\"headerlink\" title=\"查询路由\"></a>查询路由</h4><p>基于上述的分区方法，集群中的数据存储可能如下图所示。我们有5个节点，每个节点平均存储大约3273个桶（即16384/5）。那么当我们要进行一个键值的查询时，给定一个key，我们如何知道该key的值存储在哪个机器节点上呢？即我们需要一个查询路由，该路由根据给定的key，返回存储该键值的机器地址。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-1fe6033d4997d85449ce6764251923e1_1440w.jpg\" alt=\"img\">5个节点，每个节点负责一部分桶</p>\n<p>常规的实现方式便是采用如下图所示的代理方案，即采用一个中央节点（比如HDFS中的NameNode）来管理所有的元数据，但是这样的方案带来的最大问题就是代理节点很容易成为访问的瓶颈，当读写并发量高的时候，代理节点会严重的拖慢整个系统的性能。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-936c9a100eda3f1a2c79c10901134180_1440w.jpg\" alt=\"img\">采用代理的方案实现路由</p>\n<p>Redis没有选择使用代理，而是客户端直接连接每个节点。Redis的每个节点中都存储着如下所示的整个集群的状态，集群状态中一个重要的信息就是<strong>每个桶的负责节点</strong>。在具体的实现中，Redis用一个大小固定为CLUSTER_SLOTS的clusterNode数组 slots来保存每个桶的负责节点。在集群模式下，Redis接收任何键相关命令时首先<strong>计算键对应的桶编号，再根据桶找出所对应的节点</strong>，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，<strong>通知客户端请求正确的节点，这个过程称为MOVED重定向</strong>。重定向信息包含了键所对应的桶以及负责该桶的节点地址，根据这些信息客户端就可以向正确的节点发起请求。</p>\n<p>这样的话，假设集群中有N个主节点存储数据，那么客户端要查询一个键时，一次就恰好访问到正确节点的概率只有1/N。有(N-1)/N的概率是要请求两次的，第一次随机连接一个节点获得正确的节点地址，第二次从正确的节点中获取数据。当请求并发量比较大时，我们就会浪费大量的节点处理时间。一种较好的方案是在客户端把ClusterState中的slots数据信息缓存起来，这样每次客户端计算出对应的桶之后，根据本地的缓存获得正确的节点位置。这样便可以避免大量不必要的重复请求。当然，如果集群发生了扩缩容或者failover导致客户端缓存的信息过期时，客户端只需要在访问节点得到<strong>MOVED</strong>重定向时，重新更新下本地的缓存信息即可。这种缓存slots信息的客户端就是<strong>Smart Client</strong>。</p>\n<h4 id=\"集群扩容\"><a href=\"#集群扩容\" class=\"headerlink\" title=\"集群扩容\"></a>集群扩容</h4><p>当集群中发生扩缩容时会发生桶的迁移，比如当节点A正在把桶334迁移到节点B，那么在迁移完成之前，桶334的一部分数据存在节点A，一部分数据存在节点B。<strong>在迁移完成之前，集群中的所有节点都仍然会认为桶334由节点A负责</strong>。所以当访问桶334中的数据时，请求会被统一路由到节点A，如果A发现客户端访问的键并不在本地存储（可能已经被迁移到了节点B，或者该键之前就不存在），那么节点A就会向客户端返回<strong>ASK重定向</strong>。ASK重定向同样会返回<strong>槽值和节点B的地址</strong>，客户端会根据ASK返回的重定向地址向B发起请求，看看新节点存不存在数据。对客户端来说，MOVED和ASK重定向的区别在于，<strong>当客户端收到MOVED重定向时会选择更新本地的缓存，但是接收到ASK重定向并不会更新本地缓存。</strong>当节点A和节点B完成了桶334的迁移之后，<strong>节点B会向整个集群广播自己目前负责的桶的信息，之后整个集群的其他节点就会认为桶334由B负责，此时如果客户端再向节点A访问桶334的数据，那么节点A就会返回MOVED重定向。</strong>即ASK重定向只会在数据迁移的时候发生，同时客户端接收到ASK重定向之后并不会更新本地缓存。</p>\n<p>ASK指令只是用来临时纠正槽位的，不会刷新槽位映射关系表，不影响后续指令。</p>\n<h4 id=\"集群节点通信\"><a href=\"#集群节点通信\" class=\"headerlink\" title=\"集群节点通信\"></a>集群节点通信</h4><p><strong>集群中所有节点的状态以及桶-节点映射关系构成集群的元数据</strong>，许多分布式存储系统的元数据管理是采用专门的元数据管理节点的，比如HDFS中的Name Node，但是<strong>Redis集群的元数据是保存在各个Redis节点。如果元数据保存在各个节点上，我们需要解决的最重要的问题是如何保证各个节点的元数据一致性。</strong>第一种方法便是每个节点都向其他所有的节点广播自己的元数据内容及元数据版本。每个节点接收到其他节点的元数据之后，如果发现接收到的数据版本比本地的版本更新，便用接收到的数据来更新本地的数据。这样做的好处，便是元数据同步的速度会很快，一旦一个节点的元数据修改，只要网络不断，可以很快的向其他节点同步数据，但是这样带来的坏处就是通信量的剧增。所有集群中的N个节点构成了一个全连接图，那么如果每个节点每100ms进行一次全局广播，那么每一次广播都会广播N^2条信息，这将占据大量的带宽。</p>\n<p>Redis采用<strong>Gossip通信协议来进行集群元数据的同步</strong>。Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息。每个Redis都会保存自己视角下的集群中其他节点的状态信息，具体实现中所有的节点信息都存储在clusterNode结构体中。那么使用Gossip协议，集群中的每个节点，每次会随机向几个节点传输自己视角下的集群其他节点状态。如果每次都传输所有的节点状态数据，那么数据体量又会过于庞大，于是Redis集群采用的最终的信息同步方式是： 一个大小为N的集群的每一个节点每次向随机K个其他节点传输自己视角下的随机M个节点的状态。其中M和K都远远小于N。</p>\n<p>虽然Gossip协议的信息交换机制具有天然的分布式特性，但它是有成本的。由于内部需要频繁地进行节点信息交换，而ping/pong消息会携带当前节点和其他M个节点的状态数据，势必会加重带宽和计算的负担。Redis集群内节点通信采用固定频率（定时任务每秒执行10次）。因此节点每次选择需要通信的节点列表变得非常重要。通信节点K选择过大虽然可以做到信息及时交换但成本过高。节点选择K过小会降低集群内所有节点彼此信息交换频率，从而影响故障判定、新节点发现等需求的速度。因此Redis集群的Gossip协议需要兼顾信息交换实时性和成本开销。既然M和N最重要，那么我们就需要知道如何确定M和K的值，以及如何选出K个通信节点以及M个传输状态节点。</p>\n<h4 id=\"容错\"><a href=\"#容错\" class=\"headerlink\" title=\"容错\"></a>容错</h4><p>Redis Cluster可以为每个主节点设置若干个从节点，当主节点发生故障时，集群会自动将其中某个从节点提升为主节点。如果某个主节点没有从节点，那么当他发生故障时，集群将完全处于不可用状态。</p>\n<h4 id=\"可能下线（PFail）与确认下线（Fail\"><a href=\"#可能下线（PFail）与确认下线（Fail\" class=\"headerlink\" title=\"可能下线（PFail）与确认下线（Fail)\"></a>可能下线（PFail）与确认下线（Fail)</h4><p>因为Cluster是去中心化的，一个节点认为某个节点失联了并不代表所有的节点都认为他失联了，所以集群还得经过一次协商的过程。只有大多数节点都认定某个节点失联了，集群才认为该节点需要进行主从切换来容错。</p>\n<p>Redis集群节点采用Gossip协议来广播自己的状态以及改变整个集群的认知。比如一个节点发现某个节点失联了（Possibly Fail），他会将这条信息向整个集群广播，其他节点就可以收到这点的失联信息。</p>\n<p>如果收到了某个节点失联的节点数量达到了集群的大多数，就可以标记该失联节点为确认下线状态。然后向整个集群广播，强迫其他节点也接收该节点已经下线的事实，并立即对该失联节点进行主从切换。</p>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h4 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h4><p>被复制的服务器称为主服务器，对主服务器进行复制的服务器称为从服务器</p>\n<p>进行复制中的主从服务器双方的数据库将保存相同的数据</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。减轻主数据库的压力</li>\n<li>一主多从，「主数据库(master)可以读也可以写(read/write)，从数据库仅读(only read)」。</li>\n<li>主从一定程度上解决了单机版并发量大，导致请求延迟或者redis宕机服务停止的问题。</li>\n<li>从数据库分担主数据库的读压力，若是主数据库是只写模式，那么实现读写分离，主数据库就没有了读压力了。</li>\n<li>另一方面解决了单机版单点故障的问题，若是主数据库挂了，那么从数据库可以随时顶上来，综上来说，主从模式一定程度上提高了系统的可用性和性能，是实现哨兵和集群的基础。</li>\n<li>主从同步以异步方式进行同步，期间Redis仍然可以响应客户端提交的查询和更新的请求。</li>\n</ul>\n<h6 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h6><p>比如数据的一致性问题，假如主数据库写操作完成，那么他的数据会被复制到从数据库，若是还没有即使复制到从数据库，读请求又来了，此时读取的数据就不是最新的数据。</p>\n<p>若是从主同步的过程网络出故障了，导致主从同步失败，也会出现问题数据一致性的问题。</p>\n<p>主从模式不具备自动容错和恢复的功能，一旦主数据库，从节点晋升为主数据库的过程需要人为操作，维护的成本就会升高，并且主节点的写能力、存储能力都会受到限制。</p>\n<h2 id=\"旧版复制功能的实现\"><a href=\"#旧版复制功能的实现\" class=\"headerlink\" title=\"旧版复制功能的实现\"></a>旧版复制功能的实现</h2><ul>\n<li><strong>同步操作</strong>（sync）<strong>：</strong>用于将从服务器的数据库状态<strong>更新至</strong>主服务器当前所处的数据库状态</li>\n<li><strong>命令传播操作</strong>（command propagate）<strong>：</strong>则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库<strong>重新回到一致状态</strong></li>\n</ul>\n<h4 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h4><ul>\n<li><p><strong>概念：</strong>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，<strong>将从服务器的数据库状态更新至主服务器当前所处的数据库状态</strong></p>\n</li>\n<li><p><strong>SYNC命令：</strong></p>\n<p>  从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p>\n<ul>\n<li>①从服务器向主服务器<strong>发送SYNC命令</strong></li>\n<li>②收到SYNC命令的主服务器<strong>执行BGSAVE命令，在后台生成一个RDB文件</strong>，并使用一 个缓冲区记录从现在开始执行的所有写命令</li>\n<li>③当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的<strong>RDB文件发送给从服务器</strong>，从服务器<strong>接收并载入</strong>这个RDB文件，将自己的数据库状态更新至主服务器 执行BGSAVE命令时的数据库状态</li>\n<li>④主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写 命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</li>\n</ul>\n</li>\n<li><p>下图展示了SYNC命令执行期间，主从服务器的通信过程：</p>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105150863.png\" alt=\"20191201105150863\"></p>\n<h4 id=\"命令传播\"><a href=\"#命令传播\" class=\"headerlink\" title=\"命令传播\"></a>命令传播</h4><ul>\n<li>在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并<strong>导致主从服务器状态不再一致</strong></li>\n<li>为了让主从服务器再次回到一致状态，<strong>主服务器需要对从服务器执行命令传播操作：</strong>主 服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态</li>\n<li>例如，主服务器执行了DEL k3的命令，那么主服务器将向从服务器发送相同的命令DEL k3，当从服务器执行完这个命令之后，主从服务器将再次回到一致状态，现在主从服务器两者的数据库都不再包含键k3了。</li>\n</ul>\n<h4 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h4><p>旧版复制功能在处理断线重复制情况时低效</p>\n<p>在Redis中，<strong>从服务器对主服务器的复制可以分为以下两种情况：</strong></p>\n<ul>\n<li><strong>初次复制：</strong>从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务 器和上一次复制的主服务器不同。</li>\n<li><strong>断线后重复制：</strong>处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务 器通过自动重连接重新连上了主服务器，并继续复制主服务器</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105727757.png\" alt=\"20191201105727757\"></p>\n<p><strong>为什么网络断开之后重新复制效率低，以上面的演示案例为例：</strong></p>\n<ul>\n<li>主从服务器在时间T0至时间T10086中一直处于一致状态，这两个服务器保存的数据<strong>大部分都是相同的</strong></li>\n<li>从服务器想要将自己更新至主服务器当前所处的状态，<strong>真正需要的是主从服务器连接中断期间</strong>，主服务器新添加的k10087、k10088、k10089三个键的数据</li>\n<li>可惜的是，旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键k1至键k10089的RDB文件，但实际上RDB文件包含的键k1至键k10086的数据对于从服务器来说都是不必要的</li>\n</ul>\n<p>主从服务器断开的时 间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数 据，<strong>却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的</strong></p>\n<h2 id=\"新版复制功能的实现\"><a href=\"#新版复制功能的实现\" class=\"headerlink\" title=\"新版复制功能的实现\"></a>新版复制功能的实现</h2><ul>\n<li>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，<strong>使用PSYNC命令代替SYNC命令</strong>来执行复制时的同步操作</li>\n<li><strong>PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：</strong><ul>\n<li><strong>完整重同步：</strong>用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步 骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步</li>\n<li><strong>部分重同步：</strong>则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li>\n</ul>\n</li>\n<li>PSYNC命令的部分重同步模式<strong>解决了旧版复制功能在处理断线后重复制时出现的低效情况</strong></li>\n</ul>\n<p><strong>执行部分重同步所需的资源比起执行SYNC命令所需的资源要少得多</strong>，完成同步的速度也快得多。执行SYNC命令需要生成、传送和载入整个RDB文件，而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了</p>\n<h2 id=\"部分重同步的实现\"><a href=\"#部分重同步的实现\" class=\"headerlink\" title=\"部分重同步的实现\"></a>部分重同步的实现</h2><p><strong>同步功能由以下三个部分构成：</strong></p>\n<ul>\n<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li>\n<li>主服务器的复制积压缓冲区（replication backlog）</li>\n<li>服务器的运行ID（run ID）</li>\n</ul>\n<h4 id=\"复制偏移量\"><a href=\"#复制偏移量\" class=\"headerlink\" title=\"复制偏移量\"></a>复制偏移量</h4><ul>\n<li><p>执行复制的双方——主服务器和从服务器会<strong>分别维护一个复制偏移量：</strong></p>\n<ul>\n<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li>\n<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li>\n</ul>\n</li>\n<li><p>通过对比主从服务器的复制偏移量，</p>\n<p>  <strong>程序可以很容易地知道主从服务器是否处于一致状态：</strong></p>\n<ul>\n<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li>\n<li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</li>\n</ul>\n</li>\n</ul>\n<p>在下图所示的例子中，主从服务器的复制偏移量的值都为10086</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121350757.png\"></p>\n<p>如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121359413.png\" alt=\"img\"></p>\n<h4 id=\"复制积压缓冲区\"><a href=\"#复制积压缓冲区\" class=\"headerlink\" title=\"复制积压缓冲区\"></a>复制积压缓冲区</h4><ul>\n<li>复制积压缓冲区是由主服务器维护的一个<strong>固定长度（fixed-size）先进先出（FIFO）队列</strong>，默认大小为1MB</li>\n<li>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会<strong>将写命令入队到复制积压缓冲区里面</strong>，如下图所示：</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121909779.png\" alt=\"img\"></li>\n<li>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会<strong>为队列中的每个字节记录相应的复制偏移量</strong></li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121943503.png\" alt=\"img\"></li>\n<li>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令<strong>将自己的复制偏移量offset发送给主服务器</strong>，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操 作：<ul>\n<li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）<strong>仍然存在于复制积压缓冲区里面</strong>，那么主服务器将对从服务器执行部分重同步操作</li>\n<li>相反，如果offset偏移量之后的数据<strong>已经不存在于复制积压缓冲区</strong>，那么主服务器将对从服务器执行完整重同步操作</li>\n</ul>\n</li>\n</ul>\n<p><strong>演示案例：</strong></p>\n<ul>\n<li>回到之前上面图片所展示的断线后重连接例子：</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121522212.png\" alt=\"img\"></li>\n<li>当从服务器A断线之后，它立即重新连接主服务器，并<strong>向主服务器发送PSYNC命令，报告自己的复制偏移量为10086</strong></li>\n<li>主服务器收到从服务器发来的PSYNC命令以及偏移量10086之后，主服务器将<strong>检查偏移量10086之后的数据是否存在于复制积压缓冲区里面</strong>，结果发现<strong>这些数据仍然存在</strong>，于是主服务器向从服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行</li>\n<li>接着主服务器会将复制积压缓冲区10086偏移量之后的<strong>所有数据（偏移量为10087至 10119）都发送给从服务器</strong></li>\n<li>从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态，如下图所示</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201122209306.png\" alt=\"img\"></li>\n</ul>\n<h4 id=\"服务器运行ID\"><a href=\"#服务器运行ID\" class=\"headerlink\" title=\"服务器运行ID\"></a>服务器运行ID</h4><ul>\n<li><p>除了复制偏移量和复制积压缓冲区之外，</p>\n<p>  <strong>实现部分重同步还需要用到服务器运行ID（run ID）：</strong></p>\n<ul>\n<li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li>\n<li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3</li>\n</ul>\n</li>\n<li><p>当从服务器对主服务器<strong>进行初次复制时</strong>，主服务器会<strong>将自己的运行ID传送给从服务器</strong>， 而从服务器则会将<strong>这个运行ID保存起来</strong></p>\n</li>\n<li><p>当从服务器断线并重新连上一个主服务器时，<strong>从服务器将向当前连接的主服务器发送之前保存的运行ID：</strong></p>\n<ul>\n<li>如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID相同</strong>，那么说明从服务器 断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作</li>\n<li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID并不相同</strong>，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作</li>\n</ul>\n</li>\n<li><p>举个例子，假设从服务器原本正在复制一个运行ID为 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3的主服务器，那么在网络断开，从服务器重新连 接上主服务器之后，从服务器将向主服务器发送这个运行ID，主服务器根据自己的运行ID是 否53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3来判断是执行部分重同步还是执行完整重同步</p>\n</li>\n</ul>\n<h2 id=\"PSYNC命令的实现\"><a href=\"#PSYNC命令的实现\" class=\"headerlink\" title=\"PSYNC命令的实现\"></a>PSYNC命令的实现</h2><h4 id=\"PSYNC命令的调用方法有两种：\"><a href=\"#PSYNC命令的调用方法有两种：\" class=\"headerlink\" title=\"PSYNC命令的调用方法有两种：\"></a>PSYNC命令的调用方法有两种：</h4><ul>\n<li><p>如果从服务器<strong>以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令：</strong>那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器<strong>进行完整重同步</strong>（因为这时不可能执行部分重同步）</p>\n</li>\n<li><p>如果从服务器<strong>已经复制过某个主服务器</strong></p>\n<p>  ，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC <runid> <offset>命令：</p>\n<ul>\n<li>其中runid是上一次复制的主服务器的运行 ID，而offset则是从服务器当前的复制偏移量</li>\n<li>接收到这个命令的主服务器会<strong>通过这两个参数来判断应该对从服务器执行哪种同步操作</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：\"><a href=\"#接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：\" class=\"headerlink\" title=\"接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：\"></a>接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：</h4><ul>\n<li>如果<strong>主服务器返回+FULLRESYNC  回复</strong>，那么<strong>表示主服务器将与从服务器执行完整重同步操作：</strong>其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起 来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器 会将这个值作为自己的初始化偏移量</li>\n<li>如果<strong>主服务器返回+CONTINUE回复</strong>，那么表示<strong>主服务器将与从服务器执行部分重同步操作</strong>，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了</li>\n<li>如果<strong>主服务器返回-ERR回复</strong>，那么表示主服务器的版本低于Redis 2.8，<strong>它识别不了PSYNC命令</strong>，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作</li>\n</ul>\n<h4 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h4><ul>\n<li>下面的流程图总结了PSYNC命令执行完整重同步和部分重同步时可能遇上的情况：</li>\n<li><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201123546284.png\" alt=\"img\"></li>\n</ul>\n<h4 id=\"演示案例\"><a href=\"#演示案例\" class=\"headerlink\" title=\"演示案例\"></a>演示案例</h4><p>为了熟悉PSYNC命令的用法，让我们来看一个完整的复制——网络中断——重复制例 子</p>\n<ul>\n<li>首先，假设有两个Redis服务器，它们的版本都是Redis 2.8，其中主服务器的地址为 127.0.0.1:6379，从服务器的地址为127.0.0.1:12345</li>\n<li>如果客户端向从服务器发送命令SLAVEOF 127.0.0.1 6379，并且假设从服务器是第一次 执行复制操作，那么从服务器将向主服务器发送PSYNC ? -1命令，请求主服务器执行完整重 同步操作</li>\n<li>主服务器在收到完整重同步请求之后，将在后台执行BGSAVE命令，并向从服务器返回 +FULLRESYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 10086回复，其中 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3是主服务器的运行ID，而10086则是主服务器当 前的复制偏移量</li>\n<li>假设完整重同步成功执行，并且主从服务器在一段时间之后仍然保持一致，但是在复制 偏移量为20000的时候，主从服务器之间的网络连接中断了，这时从服务器将重新连接主服 务器，并再次对主服务器进行复制。</li>\n<li>因为之前曾经对主服务器进行过复制，所以从服务器将向主服务器发送命令PSYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 20000，请求进行部分重同步</li>\n<li>主服务器在接收到从服务器的PSYNC命令之后，首先对比从服务器传来的运行 ID53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3和主服务器自身的运行ID，结果显示该ID和 主服务器的运行ID相同，于是主服务器继续读取从服务器传来的偏移量20000，检查偏移量 为20000之后的数据是否存在于复制积压缓冲区里面，结果发现数据仍然存在</li>\n<li>确认运行ID相同并且数据存在之后，主服务器将向从服务器返回+CONTINUE回复，表 示将与从服务器执行部分重同步操作，之后主服务器会将保存在复制积压缓冲区20000偏移 量之后的所有数据发送给从服务器，主从服务器将再次回到一致状态</li>\n</ul>\n<h2 id=\"复制的实现\"><a href=\"#复制的实现\" class=\"headerlink\" title=\"复制的实现\"></a>复制的实现</h2><h4 id=\"步骤1-设置主服务器的地址和端口\"><a href=\"#步骤1-设置主服务器的地址和端口\" class=\"headerlink\" title=\"步骤1:设置主服务器的地址和端口\"></a>步骤1:设置主服务器的地址和端口</h4><p>当客户端向从服务器发送以下命令时:<code>SLAVEOF 127.0.0.1 6379</code></p>\n<p>从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379<strong>保存到服务器状态的masterhost属性和masterport属性里面</strong></p>\n<pre><code class=\"c\">struct redisServer\n{\n    char * masterhost;//主服务器的地址\n    int masterport;//主服务器的端口号\n};</code></pre>\n<p><strong>SLAVEOF命令是一个异步命令</strong>，在完成masterhost属性和masterport属性的设置工作之 后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而<strong>实际的复制工作将在OK返回之后才真正开始执行</strong></p>\n<h4 id=\"步骤2-建立套接字连接\"><a href=\"#步骤2-建立套接字连接\" class=\"headerlink\" title=\"步骤2:建立套接字连接\"></a>步骤2:建立套接字连接</h4><ul>\n<li>在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，<strong>创建连向主服务器的套接字连接</strong>，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131155414.png\" alt=\"img\"></p>\n<ul>\n<li>如果<strong>从服务器创建的套接字能成功连接（connect）到主服务器</strong>，那么从服务器将为这个套接字关联一个专门<strong>用于处理复制工作的文件事件处理器</strong>，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类</li>\n<li>而<strong>主服务器在接受（accept）从服务器的套接字连接之后</strong>，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器（server）和客户端（client）两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131243941.png\" alt=\"img\"></p>\n<ul>\n<li>因为复制工作接下来的几个步骤都会以从服务器向主服务器发送命令请求的形式来进 行，所以<strong>理解“从服务器是主服务器的客户端”这一点非常重要</strong></li>\n</ul>\n<h4 id=\"步骤3-发送PING命令\"><a href=\"#步骤3-发送PING命令\" class=\"headerlink\" title=\"步骤3:发送PING命令\"></a>步骤3:发送PING命令</h4><ul>\n<li>从服务器成为主服务器的客户端之后，做的第一件事就是<strong>向主服务器发送一个PING命令</strong>，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131333757.png\" alt=\"img\"></p>\n<ul>\n<li><strong>这个PING命令有两个作用：</strong><ul>\n<li>虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信， 通过发送PING命令可以<strong>检查套接字的读写状态是否正常</strong></li>\n<li>因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以<strong>检查主服务器能否正常处理命令请求</strong></li>\n</ul>\n</li>\n<li><strong>从服务器在发送PING命令之后将遇到以下三种情况的其中一种：</strong><ul>\n<li>如果主服务器向从服务器返回了一个命令回复，但从服务器却<strong>不能在规定的时限 （timeout）内读取出命令回复的内容</strong>，那么表示主从服务器之间的网络连接状态不佳，不能 继续执行复制工作的后续步骤。当出现这种情况时，从服务器<strong>断开并重新创建</strong>连向主服务器 的套接字</li>\n<li>如果主服务器<strong>向从服务器返回一个错误</strong>，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，<strong>从服务器断开并重新创建连向主服务器的套接字</strong>。比如说，如果主服务器正在处理一个超时运行的脚本，那么当从 服务器向主服务器发送PING命令时，从服务器将收到主服务器返回的BUSY Redisis busy running a script.You can only call SCRIPT KILL or SHUTDOWN NOSAVE.错误</li>\n<li>如果从服务器<strong>读取到”PONG”回复</strong>，那么表示主从服务器之间的网络连接状态正常，并 且主服务器可以正常处理从服务器（客户端）发送的命令请求，在这种情况下，从服务器可 以继续执行复制工作的下个步骤</li>\n</ul>\n</li>\n<li>下面的流程图总结了从服务器在发送PING命令时可能遇到的情况，以及各个情况的处理方式</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131558981.png\" alt=\"img\"></p>\n<h4 id=\"步骤4-身份验证\"><a href=\"#步骤4-身份验证\" class=\"headerlink\" title=\"步骤4:身份验证\"></a>步骤4:身份验证</h4><ul>\n<li><p>从服务器在收到主服务器返回的”PONG”回复之后，</p>\n<p>  <strong>下一步要做的就是决定是否进行身份验证：</strong></p>\n<ul>\n<li>如果从服务器设置了masterauth选项，那么进行身份验证</li>\n<li>如果从服务器没有设置masterauth选项，那么不进行身份验证</li>\n</ul>\n</li>\n<li><p>在需要进行身份验证的情况下，<strong>从服务器将向主服务器发送一条AUTH命令</strong>，命令的<strong>参数为从服务器masterauth选项的值</strong></p>\n</li>\n<li><p>举个例子，如果从服务器masterauth选项的值为10086，那么从服务器将向主服务器发送 命令AUTH 10086，如下图所示</p>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131632595.png\" alt=\"img\"></p>\n<h4 id=\"步骤5-发送端口信息\"><a href=\"#步骤5-发送端口信息\" class=\"headerlink\" title=\"步骤5:发送端口信息\"></a>步骤5:发送端口信息</h4><ul>\n<li>在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port ， <strong>向主服务器发送从服务器的监听端口号</strong></li>\n<li>例如在我们的例子中，从服务器的监听端口为12345，那么从服务器将<strong>向主服务器发送命令REPLCONF listening-port 12345</strong>，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113200247.png\" alt=\"img\"></p>\n<h4 id=\"步骤6-同步\"><a href=\"#步骤6-同步\" class=\"headerlink\" title=\"步骤6:同步\"></a>步骤6:同步</h4><ul>\n<li><p>在这一步，从服务器将向主服务器发送PSYNC命令，*<strong>*执行同步操作**</strong>，并<strong>将自己的数据库更新至主服务器数据库当前所处的状态</strong></p>\n</li>\n<li><p>值得一提的是，在同步操作执行之前，只有从服务器是主服务器的客户端，但是</p>\n<p>  <strong>在执行同步操作之后，主服务器也会成为从服务器的客户端：</strong></p>\n<ul>\n<li>如果PSYNC命令执行的是<strong>完整重同步操作</strong>，那么主服务器需要成为从服务器的客户 端，才能将保存在缓冲区里面的写命令发送给从服务器执行。</li>\n<li>如果PSYNC命令执行的是<strong>部分重同步操作</strong>，那么主服务器需要成为从服务器的客户 端，才能向从服务器发送保存在复制积压缓冲区里面的写命令</li>\n</ul>\n</li>\n<li><p>因此，在同步操作执行之后，<strong>主从服务器双方都是对方的客户端</strong>，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复，如下图所示：</p>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113224549.png\" alt=\"img\"></p>\n<ul>\n<li>正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命 令传播操作的基础</li>\n</ul>\n<h4 id=\"步骤7-命令传播\"><a href=\"#步骤7-命令传播\" class=\"headerlink\" title=\"步骤7:命令传播\"></a>步骤7:命令传播</h4><ul>\n<li>当完成了同步之后，<strong>主从服务器就会进入命令传播阶段</strong>，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就<strong>可以保证主从服务器一直保持一致了</strong></li>\n</ul>\n<h2 id=\"心跳检测\"><a href=\"#心跳检测\" class=\"headerlink\" title=\"心跳检测\"></a>心跳检测</h2><ul>\n<li>在命令传播阶段，从服务器默认会<strong>以每秒一次的频率</strong>，向主服务器发送命令：</li>\n</ul>\n<pre><code class=\"bash\">REPLCONF ACK &lt;replication_offset&gt;\n//其中replication_offset是从服务器当前的复制偏移量</code></pre>\n<ul>\n<li><strong>发送REPLCONF ACK命令对于主从服务器有三个作用：</strong><ul>\n<li>①检测主从服务器的网络连接状态</li>\n<li>②辅助实现min-slaves选项</li>\n<li>③检测命令丢失</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"检测主从服务器的网络连接状态（lag标志）\"><a href=\"#检测主从服务器的网络连接状态（lag标志）\" class=\"headerlink\" title=\"检测主从服务器的网络连接状态（lag标志）\"></a>检测主从服务器的网络连接状态（lag标志）</h4><ul>\n<li>主从服务器可以通过发送和接收REPLCONF ACK命令<strong>来检查两者之间的网络连接是否正常：</strong>如果主服务器<strong>超过一秒钟没有收到</strong>从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了</li>\n<li>通过向主服务器发送<strong>INFO replication命令</strong>，在列出的<strong>从服务器列表的lag一栏中</strong>，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令<strong>距离现在过了多少秒。</strong>在一般情况下，<strong>lag的值应该在0秒或者1秒之间跳动</strong>，如果超过1秒的话，那么说明主从 服务器之间的连接出现了故障。</li>\n</ul>\n<h4 id=\"辅助实现min-slaves配置选项\"><a href=\"#辅助实现min-slaves配置选项\" class=\"headerlink\" title=\"辅助实现min-slaves配置选项\"></a>辅助实现min-slaves配置选项</h4><ul>\n<li>Redis的<strong>min-slaves-to-write和min-slaves-max-lag两个选项</strong>可以<strong>防止主服务器在不安全的情况下执行写命令</strong></li>\n<li>举个例子，如果我们向主服务器提供以下设置：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201132859439.png\" alt=\"img\"></p>\n<ul>\n<li>那么在<strong>从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时</strong>，主服务器将<strong>拒绝执行写命令</strong>，这里的延迟值就是上面提到的INFO replication命令的lag 值</li>\n</ul>\n<h4 id=\"检测命令丢失\"><a href=\"#检测命令丢失\" class=\"headerlink\" title=\"检测命令丢失\"></a>检测命令丢失</h4><p>如果因为网络故障，<strong>主服务器传播给从服务器的写命令在半路丢失</strong>，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将<strong>发觉</strong>从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里 面找到从服务器缺少的数据，并<strong>将这些数据重新发送给从服务器</strong></p>\n<h4 id=\"演示案例-1\"><a href=\"#演示案例-1\" class=\"headerlink\" title=\"演示案例\"></a>演示案例</h4><ul>\n<li>举个例子，假设有两个处于一致状态的主从服务器，它们的复制偏移量都是200，如下图所示</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133107682.png\" alt=\"img\"></p>\n<ul>\n<li>如果这时主服务器执行了命令SET key value（协议格式的长度为33字节），将自己的复 制偏移量更新到了233，并尝试向从服务器传播命令SET key value，但这条命令却因为网络 故障而在传播的途中丢失，那么主从服务器之间的复制偏移量就会出现不一致，主服务器的 复制偏移量会被更新为233，而从服务器的复制偏移量仍然为200，如下图所示</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133127229.png\" alt=\"img\"></p>\n<ul>\n<li>在这之后，当从服务器向主服务器发送REPLCONF ACK命令的时候，主服务器会察觉 从服务器的复制偏移量依然为200，而自己的复制偏移量为233，这说明复制积压缓冲区里面 复制偏移量为201至233的数据（也即是命令SET key value）在传播过程中丢失了，于是主服 务器会再次向从服务器传播命令SET key value，从服务器通过接收并执行这个命令可以将自 己更新至主服务器当前所处的状态，如下图所示</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133147307.png\" alt=\"img\"></p>\n<h1 id=\"Redis哨兵\"><a href=\"#Redis哨兵\" class=\"headerlink\" title=\"Redis哨兵\"></a>Redis哨兵</h1><h2 id=\"Sentinel\"><a href=\"#Sentinel\" class=\"headerlink\" title=\"Sentinel\"></a>Sentinel</h2><h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>哨兵模式是主从的升级版，因为主从的出现故障后，不会自动恢复，需要人为干预。</p>\n<p>在主从的基础上，实现哨兵模式就是为了监控主从的运行状况，对主从的健壮进行监控，就好像哨兵一样，只要有异常就发出警告，对异常状况进行处理。</p>\n<p>总的概括来说，哨兵模式有以下的优点(功能点)：</p>\n<ul>\n<li>「监控」：监控master和slave是否正常运行，以及哨兵之间也会相互监控</li>\n<li>「自动故障恢复」：当master出现故障的时候，会自动选举一个slave作为master顶上去。</li>\n<li>哨兵模式是主从模式的升级版，所以在系统层面提高了系统的可用性和性能、稳定性。当master宕机的时候，能够自动进行故障恢复，需不要人为的干预。</li>\n<li>哨兵与哨兵之间、哨兵与master之间能够进行及时的监控，心跳检测，及时发现系统的问题，这都是弥补了主从的缺点。</li>\n</ul>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>哨兵一主多从的模式同样也会遇到写的瓶颈，已经存储瓶颈，若是master宕机了，故障恢复的时间比较长，写的业务就会受到影响。</p>\n<p>增加了哨兵也增加了系统的复杂度，需要同时维护哨兵模式。</p>\n<h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>Sentinel（哨岗、哨兵）是<strong>Redis的高可用性（high availability）解决方案：</strong>由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以<strong>监视任意多个</strong>主服务器，以及这些主服务器属下的所有从服务器，并在被监视的<strong>主服务器进入下线状态时</strong>，自动将下线主服务器属下的某个从服务器<strong>升级为新的主服务器</strong>，然后由新的主服务器代替已下线的主服务器继续处理命令请求</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201213815316.png\" alt=\"img\"></p>\n<ul>\n<li>根据上面的图片，假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对 主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如下图所示（下线的服务器用虚线表示）</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214010487.png\" alt=\"img\"></p>\n<ul>\n<li><p>当server1的<strong>下线时长超过用户设定的下线时长上限时</strong>，Sentinel系统就会对server1执行<strong>故障转移</strong></p>\n<p>  操作：</p>\n<ul>\n<li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器</li>\n<li>之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕</li>\n<li>另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器</li>\n</ul>\n</li>\n<li><p>举个例子，下图展示了Sentinel系统<strong>将server2升级为新的主服务器</strong>，并让服务器server3和server4成为server2的从服务器的过程</p>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214149843.png\" alt=\"img\"></p>\n<ul>\n<li>之后，如果server1<strong>重新上线的话</strong>，它将被Sentinel系统<strong>降级为server2的从服务器</strong>，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214154597.png\" alt=\"img\"></p>\n<h2 id=\"启动并初始化Sentinel\"><a href=\"#启动并初始化Sentinel\" class=\"headerlink\" title=\"启动并初始化Sentinel\"></a>启动并初始化Sentinel</h2><p>启动<code>Sentinel</code>会执行以下操作：</p>\n<ol>\n<li>初始化服务器</li>\n<li>将普通Redis服务器使用的代码替换成<code>Sentinel</code>专用代码</li>\n<li>初始化<code>Sentinel</code>状态</li>\n<li>根据给定的配置文件,初始化<code>Sentinel</code>的监视主服务器列表</li>\n<li>创建连向主服务器的网络连接</li>\n</ol>\n<h4 id=\"初始化Sentinel状态\"><a href=\"#初始化Sentinel状态\" class=\"headerlink\" title=\"初始化Sentinel状态\"></a>初始化Sentinel状态</h4><p>在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个<strong>sentinel.c/sentinelState结构</strong>（后面简称“Sentinel状态”），这个结构<strong>保存了服务器中所有和Sentinel功能有关的状态</strong> （服务器的一般状态仍然由redis.h/redisServer结构保存）</p>\n<pre><code class=\"c\">struct sentinelState {\n    //当前纪元，用于实现故障转移\n    uint64_t current_epoch;\n\n    //保存了所有被这个sentinel 监视的主服务器\n    dict *masters;\n\n    //略\n} sentinel;</code></pre>\n<h4 id=\"初始化Sentinel状态的masters属性\"><a href=\"#初始化Sentinel状态的masters属性\" class=\"headerlink\" title=\"初始化Sentinel状态的masters属性\"></a>初始化Sentinel状态的masters属性</h4><p>Sentinel状态中的<strong>masters字典记录了所有被Sentinel监视的主服务器的相关信息</strong>，其中：</p>\n<ul>\n<li><strong>字典的键</strong>是被监视主服务器的名字</li>\n<li><strong>字典的值</strong>则是被监视主服务器对应的sentinel.c/<strong>sentinelRedisInstance结构</strong></li>\n</ul>\n<ul>\n<li>每个sentinelRedisInstance结构（后面简称“实例结构”）<strong>代表一个被Sentinel监视的Redis服务器实例</strong>（instance），这个实例可以是<strong>主服务器、从服务器，或者另外一个Sentinel</strong></li>\n</ul>\n<pre><code class=\"c\">typedef struct sentinelRedisInstance {\n    //标识值，记录了实例的类型，以及该实例的当前状态\n    int flags;\n\n    //实例的名字\n    //主服务器的名字由用户在配置文件中设置\n    //从服务器以及Sentinel 的名字由Sentinel 自动设置\n    //格式为ip:port ，例如&quot;127.0.0.1:26379&quot;\n    char *name;\n\n    //实例的运行ID\n    char *runid;\n\n    //配置纪元，用于实现故障转移\n    uint64_t config_epoch;\n\n    //实例的地址\n    sentinelAddr *addr;\n} sentinelRedisInstance;</code></pre>\n<pre><code class=\"c\">struct sentinelAddr\n{\n    char * ip;\n    int port;\n}</code></pre>\n<h6 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h6><ul>\n<li>对Sentinel状态的初始化将引发对masters字典的初始化，而masters字典的初始化是<strong>根据被载入的Sentinel配置文件</strong>来进行的</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201220900699.png\" alt=\"img\"></p>\n<h4 id=\"创建连向主服务器的网络连接\"><a href=\"#创建连向主服务器的网络连接\" class=\"headerlink\" title=\"创建连向主服务器的网络连接\"></a>创建连向主服务器的网络连接</h4><ul>\n<li><p>初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，<strong>Sentinel将成为主服务器的客户端</strong>，它可以向主服务器发送命令，并从命令回复中获取相关的信息</p>\n</li>\n<li><p>对于每个被Sentinel监视的主服务器来说，Sentinel会</p>\n<p>  <strong>创建两个连向主服务器的异步网络连接：</strong></p>\n<ul>\n<li>一个是<strong>命令连接</strong>，这个连接专门用于向主服务器发送命令，并接收命令回复</li>\n<li>另一个是<strong>订阅连接</strong>，这个连接专门用于订阅主服务器的<strong>sentinel</strong>:hello频道</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"获取主服务器的信息\"><a href=\"#获取主服务器的信息\" class=\"headerlink\" title=\"获取主服务器的信息\"></a>获取主服务器的信息</h2><ul>\n<li><p>Sentinel默认会以<strong>每十秒一次的频率</strong>，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来<strong>获取主服务器的当前信息</strong></p>\n</li>\n<li><p>通过分析主服务器返回的INFO命令回复，<strong>Sentinel可以获取以下两方面的信息：</strong></p>\n<ul>\n<li>一方面是<strong>关于主服务器本身的信息</strong>，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色</li>\n<li>另一方面是关于主服务器属下<strong>所有从服务器的信息</strong>，每个从服务器都由一个”slave”字符 串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端 口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器</li>\n</ul>\n</li>\n<li><p><strong>根据run_id域和role域记录的信息，Sentinel将对主服务器的实例结构进行更新</strong>，例如， 主服务器重启之后，它的运行ID就会和实例结构之前保存的运行ID不同，Sentinel检测到这 一情况之后，就会对实例结构的运行ID进行更新</p>\n</li>\n<li><p>Sentinel在分析INFO命令中包含的从服务器信息时，<strong>会检查从服务器对应的实例结构是否已经存在于slaves字典：</strong></p>\n<ul>\n<li>如果<strong>从服务器对应的实例结构已经存在</strong>，那么Sentinel对从服务器的实例结构进行更新</li>\n<li>如果<strong>从服务器对应的实例结构不存在</strong>，那么说明这个从服务器是新发现的从服务器， Sentinel会在slaves字典中为这个从服务器新创建一个实例结构</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201223205478.png\" alt=\"img\"></p>\n<h2 id=\"获取从服务器信息\"><a href=\"#获取从服务器信息\" class=\"headerlink\" title=\"获取从服务器信息\"></a>获取从服务器信息</h2><ul>\n<li>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的<strong>从服务器创建相应的实例结构之外</strong>，Sentinel还会创建连接到从服务器的<strong>命令连接和订阅连接</strong></li>\n<li>举个例子，对于上面那张图所示的主从服务器关系来说，Sentinel将对slave0、slave1和 slave2三个从服务器分别创建命令连接和订阅连接，如下图所示：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120122373496.png\" alt=\"img\"></p>\n<p><strong>根据INFO命令的回复，Sentinel会提取出以下信息：</strong></p>\n<ul>\n<li>从服务器的运行ID run_id</li>\n<li>从服务器的角色role</li>\n<li>主服务器的IP地址master_host，以及主服务器的端口号master_port</li>\n<li>主从服务器的连接状态master_link_status</li>\n<li>从服务器的优先级slave_priority</li>\n<li>从服务器的复制偏移量slave_repl_offset</li>\n</ul>\n<h2 id=\"Sentinel向主服务器和从服务器发送信息\"><a href=\"#Sentinel向主服务器和从服务器发送信息\" class=\"headerlink\" title=\"Sentinel向主服务器和从服务器发送信息\"></a>Sentinel向主服务器和从服务器发送信息</h2><p>在默认情况下，Sentinel会以<strong>每两秒一次的频率</strong>，通过命令连接向所有被监视的<strong>主服务器和从服务器</strong>发送命令</p>\n<p>对于监视同一个服务器的多个Sentinel来说，<strong>一个Sentinel发送的信息会被其他Sentinel接收到</strong>，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。</p>\n<h2 id=\"Sentinel接收服务器和从服务器的频道信息\"><a href=\"#Sentinel接收服务器和从服务器的频道信息\" class=\"headerlink\" title=\"Sentinel接收服务器和从服务器的频道信息\"></a>Sentinel接收服务器和从服务器的频道信息</h2><p>当一个Sentinel从<strong>sentinel</strong>:hello频道收到一条信息时，Sentinel会对这条信息进行分 析，<strong>提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：</strong></p>\n<ul>\n<li>如果信息中记录的Sentinel运行ID和接收信息的Sentinel的<strong>运行ID相同</strong>，那么说明这条信 息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理</li>\n<li>相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的<strong>运行ID不相同</strong>，那么 说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，<strong>对相应主服务器的实例结构进行更新</strong></li>\n<li>因为一个Sentinel可以通过分析接收到的频道信息来<strong>获知其他Sentinel的存在</strong>，并通过发送频道信息来<strong>让其他Sentinel知道自己</strong>的存在，所以用户在使用Sentinel的时候并不需要提供各个Sentinel的地址信息，监视同一个主服务器的多个Sentinel<strong>可以自动发现对方</strong></li>\n<li>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，<strong>还会创建一个连向新Sentinel的命令连接</strong>，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的<strong>多个Sentinel将形成相互连接的网络：</strong>Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202184847281.png\" alt=\"img\"></p>\n<h2 id=\"检测主观下线状态\"><a href=\"#检测主观下线状态\" class=\"headerlink\" title=\"检测主观下线状态\"></a>检测主观下线状态</h2><ul>\n<li>在默认情况下，Sentinel会<strong>以每秒一次的频率</strong>向所有与它创建了命令连接的实例（<strong>包括主服务器、从服务器、其他Sentinel在内</strong>）发送<strong>PING命令</strong>，并通过实例返回的PING命令回复来判断实例是否在线</li>\n<li>如果配置文件指定Sentinel1的<strong>down-after-milliseconds选项的值为50000毫秒</strong>，那么当主服务器master连续50000毫秒都向Sentinel1<strong>返回无效回复时</strong>， Sentinel1就会将master标记为主观下线</li>\n</ul>\n<h2 id=\"检测客观下线状态\"><a href=\"#检测客观下线状态\" class=\"headerlink\" title=\"检测客观下线状态\"></a>检测客观下线状态</h2><ul>\n<li>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线 了，它会<strong>向同样监视这一主服务器的其他Sentinel进行询问</strong>，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里<strong>接收到足够数量的已下线判断之后</strong>，Sentinel就会将从服务器判定为客观下线，并对主服务器<strong>执行故障转移操作</strong></li>\n</ul>\n<h2 id=\"选取领头Sentinel\"><a href=\"#选取领头Sentinel\" class=\"headerlink\" title=\"选取领头Sentinel\"></a>选取领头Sentinel</h2><ul>\n<li><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的<strong>各个Sentinel会进行协商</strong>，选举出一个领头Sentinel，并由领头Sentinel<strong>对下线主服务器执行故障转移操作</strong></p>\n</li>\n<li><p>1.<strong>所有在线的Sentinel都有被选为领头Sentinel的资格</strong>，换句话说，监视同一个主服务器的 多个在线Sentinel中的任意一个都有可能成为领头Sentinel</p>\n</li>\n<li><p>2.每次进行领头Sentinel选举之后，<strong>不论选举是否成功，所有Sentinel的配置纪元 （configuration epoch）的值都会自增一次</strong>。配置纪元实际上就是一个计数器，并没有什么特别的</p>\n</li>\n<li><p>3.在一个配置纪元里面，<strong>所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会</strong>，并且局部领头一旦设置，在这个配置每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel</p>\n</li>\n<li><p>4.当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送<strong>SENTINEL ismaster-down-by-addr命令</strong>，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这<strong>表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel</strong></p>\n</li>\n<li><p>5.Sentinel设置局部领头Sentinel的规则是先到先得：<strong>最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头</strong>Sentinel，而<strong>之后接收到的所有设置要求都会被目标Sentinel拒绝</strong></p>\n</li>\n<li><p>6.目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，<strong>将向源Sentinel返回 一条命令回复，</strong>回复中的leader_runid参数和leader_epoch参数分别<strong>记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元</strong></p>\n</li>\n<li><p>7.源Sentinel在接收到目标Sentinel返回的命令回复之后，<strong>会检查回复中leader_epoch参数的值和自己的配置纪元是否相同</strong>，如果相同的话，那么源Sentinel继续取出回复中的 leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标 Sentinel将源Sentinel设置成了局部领头Sentinel</p>\n</li>\n<li><p>8.如果<strong>有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel</strong>。举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于 10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成 为领头Sentine</p>\n</li>\n<li><p>9.因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，<strong>所以在一个配置纪元里面，只会出现一个领头 Sentinel</strong></p>\n</li>\n<li><p>10.如果在给定时限内，<strong>没有一个Sentinel被选举为领头Sentinel</strong>，那么各个Sentinel将在一段时间之后<strong>再次进行选举</strong>，直到选出领头Sentinel为止</p>\n</li>\n</ul>\n<h2 id=\"故障转移\"><a href=\"#故障转移\" class=\"headerlink\" title=\"故障转移\"></a>故障转移</h2><ul>\n<li>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器<strong>执行故障转移操作</strong></li>\n<li><strong>该操作包含下面3个步骤：</strong><ul>\n<li>①在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器</li>\n<li>②让已下线主服务器属下的所有从服务器改为复制新的主服务器</li>\n<li>③将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线 时，它就会成为新的主服务器的从服务器</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"选出新的主服务器\"><a href=\"#选出新的主服务器\" class=\"headerlink\" title=\"选出新的主服务器\"></a>选出新的主服务器</h4><ul>\n<li>故障转移操作第一步要做的就是<strong>在已下线主服务器属下的所有从服务器中</strong>，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送<strong>SLAVEOF no one命令</strong>，将这个<strong>从服务器转换为主服务器</strong></li>\n</ul>\n<h6 id=\"演示案例-2\"><a href=\"#演示案例-2\" class=\"headerlink\" title=\"演示案例\"></a>演示案例</h6><ul>\n<li>下图展示了在一次故障转移操作中，领头Sentinel向<strong>被选中的从服务器server2</strong>发送SLAVEOF no one命令的情形：</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193156859.png\" alt=\"img\"></p>\n<ul>\n<li>在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一 次），向被升级的从服务器<strong>发送INFO命令，</strong>并观察命令回复中的角色（role）信息，<strong>当被升级服务器的role从原来的slave变为master时</strong>，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了</li>\n</ul>\n<h4 id=\"修改从服务器的复制目标\"><a href=\"#修改从服务器的复制目标\" class=\"headerlink\" title=\"修改从服务器的复制目标\"></a>修改从服务器的复制目标</h4><ul>\n<li>当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的<strong>所有从服务器去复制新的主服务器</strong>，这一动作可以<strong>通过向从服务器发送SLAVEOF命令来实现</strong></li>\n</ul>\n<h6 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h6><ul>\n<li>下图展示了在故障转移操作中，领头Sentinel向已下线主服务器server1的两个从服务器server3和server4发送SLAVEOF命令，让<strong>它们复制新的主服务器server2的例子</strong></li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193616934.png\" alt=\"img\"></p>\n<ul>\n<li>下图展示了<strong>server3和server4成为server2的从服务器之后</strong>，各个服务器以及领头Sentinel的样子</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193633254.png\" alt=\"img\"></p>\n<h4 id=\"将旧的主服务器变为从服务器\"><a href=\"#将旧的主服务器变为从服务器\" class=\"headerlink\" title=\"将旧的主服务器变为从服务器\"></a>将旧的主服务器变为从服务器</h4><ul>\n<li>故障转移操作最后要做的是，<strong>将已下线的主服务器设置为新的主服务器的从服务器</strong>。比如说，下图就展示了被领头Sentinel设置为从服务器之后，服务器server1的样子</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193748287.png\" alt=\"img\"></p>\n<ul>\n<li>因为旧的主服务器已经下线，所以这种设置是保存在server1对应的实例结构里面的，当 server1重新上线时，<strong>Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器</strong></li>\n<li>例如，下图就展示了server1重新上线并成为server2的从服务器的例子</li>\n</ul>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193757739.png\" alt=\"img\"></p>\n<h1 id=\"Redis集群\"><a href=\"#Redis集群\" class=\"headerlink\" title=\"Redis集群\"></a>Redis集群</h1><h6 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h6><p>最后，Cluster是真正的集群模式了，哨兵解决和主从不能自动故障恢复的问题，但是同时也存在难以扩容以及单机存储、读写能力受限的问题，并且集群之前都是一台redis都是全量的数据，这样所有的redis都冗余一份，就会大大消耗内存空间。</p>\n<p>集群模式实现了Redis数据的分布式存储，实现数据的分片，每个redis节点存储不同的内容，并且解决了在线的节点收缩(下线)和扩容(上线)问题。</p>\n<p>集群模式真正意义上实现了系统的高可用和高性能，但是集群同时进一步使系统变得越来越复杂，接下来我们来详细的了解集群的运作原理。</p>\n<p>集群模式是一个无中心的架构模式，将数据进行分片，分布到对应的槽中，每个节点存储不同的数据内容，通过路由能够找到对应的节点负责存储的槽，能够实现高效率的查询。</p>\n<p>并且集群模式增加了横向和纵向的扩展能力，实现节点加入和收缩，集群模式是哨兵的升级版，哨兵的优点集群都有。</p>\n<h6 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h6><p>缓存的最大问题就是带来数据一致性问题，在平衡数据一致性的问题时，兼顾性能与业务要求，大多数都是以最终一致性的方案进行解决，而不是强一致性。</p>\n<p>并且集群模式带来节点数量的剧增，一个集群模式最少要6台机，因为要满足半数原则的选举方式，所以也带来了架构的复杂性。</p>\n<p>slave只充当冷备，并不能缓解master的读的压力。</p>\n<h4 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><ul>\n<li><p>Redis Cluster是去中心化的，例如一个集群由三个Redis节点组成，每个节点负责整个集群的一部分数据。这三个节点就相互连接组成一个对等的集群，他们之间通过一种特殊的二进制协议交互集群信息。</p>\n</li>\n<li><p>所有数据划分为16384个槽位，每个节点负责其中一部分槽位，槽位的信息存储在每个节点中</p>\n</li>\n<li><p>客户端为了可以直接定位到某个具体的key所在的节点，需要缓存槽位相关信息，这样才可以准确快速地定位到相应的节点。同时因为可能会存在客户端与服务器存储槽位的信息不一致的情况。还需要纠正机制来实现槽位信息的校验调整</p>\n</li>\n<li><p>当客户端向一个错误的节点发出了指令后，该节点会发现指令的key所在的槽位并不归自己管理，这时他会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连接这个节点以获取数据</p>\n</li>\n<li><pre><code>  GET x\n  -MOVED 3999 127.0.0.1:6381\n  //MOVED的一个参数3999是key对应的槽位编号，后面是目标节点的地址。\n  //MOVED指令前面有一个减号，表示该指令是一个错误消息\n  //客户端收到MOVED指令后，要立即纠正本地的槽位映射表。\n  //后续所有key将使用新的槽位映射表</code></pre>\n</li>\n</ul>\n<ul>\n<li><h4 id=\"理解-1\"><a href=\"#理解-1\" class=\"headerlink\" title=\"理解\"></a>理解</h4></li>\n</ul>\n<p>在Redis主从复制中介绍过利用主从节点实现读写分离来扩展主节点的数据读取能力，那么当主节点的写入能力成为瓶颈时，集群便是性能扩展的解决方案之一。Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。集群设计，本质上来讲是把数据存储在不同的数据节点上，这些节点可以独立的向外提供服务，那么需要解决的最重要几个问题是</p>\n<ul>\n<li>当新的写入数据到达时，该数据应该存储在哪台机器上。即数据分布问题</li>\n<li>当新的查询请求到达时，我们该如何知道这部分数据存储在哪个机器节点上。即查询路由问题。</li>\n<li>当新的节点加入时，我们该如何重新分配数据，让新的节点也对外提供服务。当有节点退出时，我们该如何把存在该节点上的数据分配到其他机器上，让其他机器来提供这部分数据的服务。即集群的扩缩容问题。</li>\n<li>当有节点因故障而不能提供服务时，如何能保证该集群仍然能正常向外提供服务。即高可用问题。</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>对于分布式存储，数据分区规则是核心问题之一，Redis集群中使用的是虚拟槽/虚拟桶分区，使用CRC16函数计算每个键的哈希值，并把所有的键划分到16384个桶中。数据存储在各个结点之后，当客户端访问键时，需要能够知道键所在的节点地址，Redis集群没有采用代理的方案，而是每个节点都保存集群中槽的负责节点信息，客户端可连接任意一个节点，当该节点发现客户端请求的键并不由自己负责时，会向客户端返回重定向，重定向中包含着负责该键的节点地址信息。同路由信息一样，Redis的集群元数据信息也是存储在各个节点上，并使用Gossip协议来完成集群的元数据同步。每个集群节点会每100ms向部分节点随机传输自己视角下的N/10个节点的信息，同时Redis集群节点会努力保证自己与其他的所有节点每node_timeout/2时间内至少通信一次。</p>\n<h4 id=\"数据分布\"><a href=\"#数据分布\" class=\"headerlink\" title=\"数据分布\"></a>数据分布</h4><p>分布式数据库首先要解决地把整个数据集按照分区规则映射到多个节点地问题。即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。如下图所示：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-17d40b36ede8d8c4a3309306370f09f7_1440w.jpg\" alt=\"img\"></p>\n<p>分布式存储数据分区</p>\n<p>Redis采用了虚拟桶分区方法，使用分散度良好地哈希函数把所有的数据均匀地哈希到K个桶中。具体实现中，Redis使用CRC16函数计算键的哈希值并把所有键分到16384个桶中，键的桶编号计算方法如下所示。每个桶<strong>只能</strong>由一个主节点存储，但一个主节点可以负责多个桶。Redis集群中，数据的迁移都是以桶为单位的，集群的扩缩容等价为桶在不同节点间的移动。</p>\n<pre><code class=\"text\">HASH_SLOT = CRC16(key) mod 16384\n//默认对key值使用crc16算法进行hash，得到一个整数值，然后用这个整数值对16384进行取模得到具体槽位</code></pre>\n<h4 id=\"查询路由\"><a href=\"#查询路由\" class=\"headerlink\" title=\"查询路由\"></a>查询路由</h4><p>基于上述的分区方法，集群中的数据存储可能如下图所示。我们有5个节点，每个节点平均存储大约3273个桶（即16384/5）。那么当我们要进行一个键值的查询时，给定一个key，我们如何知道该key的值存储在哪个机器节点上呢？即我们需要一个查询路由，该路由根据给定的key，返回存储该键值的机器地址。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-1fe6033d4997d85449ce6764251923e1_1440w.jpg\" alt=\"img\">5个节点，每个节点负责一部分桶</p>\n<p>常规的实现方式便是采用如下图所示的代理方案，即采用一个中央节点（比如HDFS中的NameNode）来管理所有的元数据，但是这样的方案带来的最大问题就是代理节点很容易成为访问的瓶颈，当读写并发量高的时候，代理节点会严重的拖慢整个系统的性能。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-936c9a100eda3f1a2c79c10901134180_1440w.jpg\" alt=\"img\">采用代理的方案实现路由</p>\n<p>Redis没有选择使用代理，而是客户端直接连接每个节点。Redis的每个节点中都存储着如下所示的整个集群的状态，集群状态中一个重要的信息就是<strong>每个桶的负责节点</strong>。在具体的实现中，Redis用一个大小固定为CLUSTER_SLOTS的clusterNode数组 slots来保存每个桶的负责节点。在集群模式下，Redis接收任何键相关命令时首先<strong>计算键对应的桶编号，再根据桶找出所对应的节点</strong>，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，<strong>通知客户端请求正确的节点，这个过程称为MOVED重定向</strong>。重定向信息包含了键所对应的桶以及负责该桶的节点地址，根据这些信息客户端就可以向正确的节点发起请求。</p>\n<p>这样的话，假设集群中有N个主节点存储数据，那么客户端要查询一个键时，一次就恰好访问到正确节点的概率只有1/N。有(N-1)/N的概率是要请求两次的，第一次随机连接一个节点获得正确的节点地址，第二次从正确的节点中获取数据。当请求并发量比较大时，我们就会浪费大量的节点处理时间。一种较好的方案是在客户端把ClusterState中的slots数据信息缓存起来，这样每次客户端计算出对应的桶之后，根据本地的缓存获得正确的节点位置。这样便可以避免大量不必要的重复请求。当然，如果集群发生了扩缩容或者failover导致客户端缓存的信息过期时，客户端只需要在访问节点得到<strong>MOVED</strong>重定向时，重新更新下本地的缓存信息即可。这种缓存slots信息的客户端就是<strong>Smart Client</strong>。</p>\n<h4 id=\"集群扩容\"><a href=\"#集群扩容\" class=\"headerlink\" title=\"集群扩容\"></a>集群扩容</h4><p>当集群中发生扩缩容时会发生桶的迁移，比如当节点A正在把桶334迁移到节点B，那么在迁移完成之前，桶334的一部分数据存在节点A，一部分数据存在节点B。<strong>在迁移完成之前，集群中的所有节点都仍然会认为桶334由节点A负责</strong>。所以当访问桶334中的数据时，请求会被统一路由到节点A，如果A发现客户端访问的键并不在本地存储（可能已经被迁移到了节点B，或者该键之前就不存在），那么节点A就会向客户端返回<strong>ASK重定向</strong>。ASK重定向同样会返回<strong>槽值和节点B的地址</strong>，客户端会根据ASK返回的重定向地址向B发起请求，看看新节点存不存在数据。对客户端来说，MOVED和ASK重定向的区别在于，<strong>当客户端收到MOVED重定向时会选择更新本地的缓存，但是接收到ASK重定向并不会更新本地缓存。</strong>当节点A和节点B完成了桶334的迁移之后，<strong>节点B会向整个集群广播自己目前负责的桶的信息，之后整个集群的其他节点就会认为桶334由B负责，此时如果客户端再向节点A访问桶334的数据，那么节点A就会返回MOVED重定向。</strong>即ASK重定向只会在数据迁移的时候发生，同时客户端接收到ASK重定向之后并不会更新本地缓存。</p>\n<p>ASK指令只是用来临时纠正槽位的，不会刷新槽位映射关系表，不影响后续指令。</p>\n<h4 id=\"集群节点通信\"><a href=\"#集群节点通信\" class=\"headerlink\" title=\"集群节点通信\"></a>集群节点通信</h4><p><strong>集群中所有节点的状态以及桶-节点映射关系构成集群的元数据</strong>，许多分布式存储系统的元数据管理是采用专门的元数据管理节点的，比如HDFS中的Name Node，但是<strong>Redis集群的元数据是保存在各个Redis节点。如果元数据保存在各个节点上，我们需要解决的最重要的问题是如何保证各个节点的元数据一致性。</strong>第一种方法便是每个节点都向其他所有的节点广播自己的元数据内容及元数据版本。每个节点接收到其他节点的元数据之后，如果发现接收到的数据版本比本地的版本更新，便用接收到的数据来更新本地的数据。这样做的好处，便是元数据同步的速度会很快，一旦一个节点的元数据修改，只要网络不断，可以很快的向其他节点同步数据，但是这样带来的坏处就是通信量的剧增。所有集群中的N个节点构成了一个全连接图，那么如果每个节点每100ms进行一次全局广播，那么每一次广播都会广播N^2条信息，这将占据大量的带宽。</p>\n<p>Redis采用<strong>Gossip通信协议来进行集群元数据的同步</strong>。Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息。每个Redis都会保存自己视角下的集群中其他节点的状态信息，具体实现中所有的节点信息都存储在clusterNode结构体中。那么使用Gossip协议，集群中的每个节点，每次会随机向几个节点传输自己视角下的集群其他节点状态。如果每次都传输所有的节点状态数据，那么数据体量又会过于庞大，于是Redis集群采用的最终的信息同步方式是： 一个大小为N的集群的每一个节点每次向随机K个其他节点传输自己视角下的随机M个节点的状态。其中M和K都远远小于N。</p>\n<p>虽然Gossip协议的信息交换机制具有天然的分布式特性，但它是有成本的。由于内部需要频繁地进行节点信息交换，而ping/pong消息会携带当前节点和其他M个节点的状态数据，势必会加重带宽和计算的负担。Redis集群内节点通信采用固定频率（定时任务每秒执行10次）。因此节点每次选择需要通信的节点列表变得非常重要。通信节点K选择过大虽然可以做到信息及时交换但成本过高。节点选择K过小会降低集群内所有节点彼此信息交换频率，从而影响故障判定、新节点发现等需求的速度。因此Redis集群的Gossip协议需要兼顾信息交换实时性和成本开销。既然M和N最重要，那么我们就需要知道如何确定M和K的值，以及如何选出K个通信节点以及M个传输状态节点。</p>\n<h4 id=\"容错\"><a href=\"#容错\" class=\"headerlink\" title=\"容错\"></a>容错</h4><p>Redis Cluster可以为每个主节点设置若干个从节点，当主节点发生故障时，集群会自动将其中某个从节点提升为主节点。如果某个主节点没有从节点，那么当他发生故障时，集群将完全处于不可用状态。</p>\n<h4 id=\"可能下线（PFail）与确认下线（Fail\"><a href=\"#可能下线（PFail）与确认下线（Fail\" class=\"headerlink\" title=\"可能下线（PFail）与确认下线（Fail)\"></a>可能下线（PFail）与确认下线（Fail)</h4><p>因为Cluster是去中心化的，一个节点认为某个节点失联了并不代表所有的节点都认为他失联了，所以集群还得经过一次协商的过程。只有大多数节点都认定某个节点失联了，集群才认为该节点需要进行主从切换来容错。</p>\n<p>Redis集群节点采用Gossip协议来广播自己的状态以及改变整个集群的认知。比如一个节点发现某个节点失联了（Possibly Fail），他会将这条信息向整个集群广播，其他节点就可以收到这点的失联信息。</p>\n<p>如果收到了某个节点失联的节点数量达到了集群的大多数，就可以标记该失联节点为确认下线状态。然后向整个集群广播，强迫其他节点也接收该节点已经下线的事实，并立即对该失联节点进行主从切换。</p>\n"},{"title":"网络编程基础","author":"tongji4m3","top":true,"cover":false,"coverImg":"/images/1.jpg","toc":true,"mathjax":false,"summary":"学习网络编程所做的笔记，包括基本套记字编程，IO模型、epoll函数、Java IO等。","abbrlink":"adcb768c","date":"2021-05-04T16:00:00.000Z","_content":"\n\n\n# 基本套接字编程\n\n## TCP原理\n\n### 三次握手\n\n1. 服务器必须准备好接受外来的连接。通常是通过调用socket、bind和listen三个函数完成，此时为**被动打开**\n2. 客户通过调用connect发起**主动打开**，这导致客户端TCP发送一个SYN，告诉服务器自己的初始序列号（不带数据）。\n3. 服务器必须确认（ACK）客户的SYN，同时自己也要发送一个SYN，含有服务器将在同一连接中发送数据的初始序列号。\n4. 客户必须确认服务器的SYN\n\n![image-20210603165512924](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165512924.png)\n\n### 四次挥手\n\n1. 某个应用进程（假设是客户端）首先调用close，执行**主动关闭**，于是发送一个FIN，表示数据发送完毕\n2. 接收到这个FIN的对端（假设是服务器）执行**被动关闭**，给客户发送回ACK。FIN的接收意味着服务器端在相应连接上再无额外数据可接收\n3. 一段时间后（这段时间内，服务器端仍然可以向客户端发送数据，称为半关闭状态），服务器端也将调用close关闭他的套接字，它会像客户端也发送一个FIN\n4. 执行主动关闭的那端会发送ACK确认这个FIN\n\n![image-20210603165546769](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165546769.png)\n\n### TCP状态转换图\n\n用粗实线表示客户状态转换，粗虚线表示服务器状态转换。\n\n接收表示该状态转换在接受到什么分节时发生，发送表示该状态转换会发送什么分节\n\n例子1 **客户端建立连接**：\n\n当某个应用程序在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED，这个状态通常是数据传送发生时的状态\n\n例子2 **客户端、服务器断开连接**：\n\n如果某个应用进程在接收到一个FIN之前调用close（主动关闭），则转换到FIN_WAIT_1状态\n\n但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN（被动关闭），那就转换到CLOSE_WAIT状态\n\n![image-20210603170310342](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603170310342.png)\n\n**TIME_WAIT状态**\n\n执行主动关闭的那端会经历该状态，持续时间是2MSL（两倍的最长分节生命期，MSL是任何IP数据报能够在因特网中存活的最长时间）\n\nTIME_WAIT状态存在原因：\n\n1. 可靠地实现TCP全双工连接的终止。假设最终的ACK丢失，服务器将重新发送它的最终FIN，所以客户端必须维护状态信息，以允许它重新发送最终的那个ACK\n2. 允许老的重复分节在网络中消逝。假设关闭了一个TCP连接，过一段时间又在相同的IP地址和端口号之间建立另一个连接（称为前一个连接的化身，因为IP、端口号一样）。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再次出现。为做到这一点，TCP就不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT的持续时间的2MSL，就足以让某个方向上的分组最多存活MSL即被丢弃。通过该规则，就能保证每成功建立一个TCP连接，来自该连接先前化身的老的重复分组都已经在网络中消逝了。\n\n### 完整流程\n\n![image-20210603171012559](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603171012559.png)\n\n\n\n应用进程写数据到一个TCP套接字中时发生的步骤：\n\n![image-20210603185857129](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603185857129.png)\n\n每一个TCP套接字有一个发送缓冲区。当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区，如果该套接字的发送缓冲区容不下该应用进程的所有数据，该应用进程将置于休眠状态。内核将不从write系统调用返回，直到应用进程缓冲区中所有数据都复制到套接字发送缓冲区\n\n因此，从一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据。\n\n这一端的TCP提取套接字发送缓冲区中的数据并把它发送给对端TCP。对端TCP必须确认收到的数据，伴随来自对端的ACK的不断到达，本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止\n\n本端TCP以MSS大小的块把数据传递给IP，同时给每个数据块安上一个TCP首部已构成TCP分节，IP给每个TCP分节安上一个IP首部以构成IP数据报，并按照其目的IP地址查找路由表项以确定外出接口，然后把数据报传递给相应的数据链路。\n\n## 简单案例\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603191611037.png\" alt=\"image-20210603191611037\" style=\"zoom: 67%;\" />\n\n\n\n![image-20210603203304963](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603203304963.png)\n\n**正常终止步骤**\n\n1. 当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回\n2. 当str_cli函数返回到客户的main函数时，main通过调用exit终止\n3. 进程终止处理的部分工作是关闭所有打开的描述符，因此客户打开的套接字由内核关闭，这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应。至此，服务器套接字处于CLOSE_WAIT状态，客户套接字处于FIN_WAIT_2状态\n4. 当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline返回0，这导致str_echo函数返回服务器子进程的main函数\n5. 服务器子进程通过调用exit来终止\n6. 服务器子进程中打开的所有描述符随之关闭，由子进程来关闭已连接套接字会引发TCP连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK。至此连接完全终止，客户端套接字进入TIME_WAIT状态\n\n### 客户端\n\n```c\n#include\t\"unp.h\"\n\nint\nmain(int argc, char **argv)\n{\n\tint\t\t\t\t\tsockfd;\n\tstruct sockaddr_in\tservaddr;\n\n\tif (argc != 2)\n\t\terr_quit(\"usage: tcpcli <IPaddress>\");\n\n    // 创建一个套接字，返回描述符\n\tsockfd = Socket(AF_INET, SOCK_STREAM, 0);\n\n    // 填入服务器的IP地址和端口号\n\tbzero(&servaddr, sizeof(servaddr));\n\tservaddr.sin_family = AF_INET;\n\tservaddr.sin_port = htons(SERV_PORT);\n\tInet_pton(AF_INET, argv[1], &servaddr.sin_addr);\n\n    // 和服务器建立TCP连接\n\tConnect(sockfd, (SA *) &servaddr, sizeof(servaddr));\n\n\tstr_cli(stdin, sockfd);\n\n\texit(0); // 终止程序运行，Unix在进程终止时总是关闭该进程所有打开的描述符\n}\n\nvoid\nstr_cli(FILE *fp, int sockfd)\n{\n    char\tsendline[MAXLINE], recvline[MAXLINE];\n\n    while (Fgets(sendline, MAXLINE, fp) != NULL) {\n\n        Writen(sockfd, sendline, strlen(sendline));\n\n        if (Readline(sockfd, recvline, MAXLINE) == 0)\n            err_quit(\"str_cli: server terminated prematurely\");\n\n        Fputs(recvline, stdout);\n    }\n}\n```\n\n客户调用st_cli函数，该函数将阻塞于fgets调用，因为我们还未输入任何数据。\n\n### 服务器端\n\n```c\n#include\t\"unp.h\"\n\nint main(int argc, char **argv)\n{\n\tint\t\t\t\t\tlistenfd, connfd;\n\tpid_t\t\t\t\tchildpid;\n\tsocklen_t\t\t\tclilen;\n\tstruct sockaddr_in\tcliaddr, servaddr;\n\n    // 创建套接字\n\tlistenfd = Socket(AF_INET, SOCK_STREAM, 0);\n\n\tbzero(&servaddr, sizeof(servaddr));\n\tservaddr.sin_family      = AF_INET;\n\tservaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tservaddr.sin_port        = htons(SERV_PORT);\n\n    // 调用bind函数绑定端口号\n\tBind(listenfd, (SA *) &servaddr, sizeof(servaddr));\n\n    // 把套接字转换成一个监听套接字，这样来自客户端的外来连接可以在该套接字由内核接收\n\tListen(listenfd, LISTENQ);\n\n\tfor ( ; ; ) {\n\t\tclilen = sizeof(cliaddr);\n        // 服务器进程在accept调用中被置于休眠状态，等待某个客户连接的到达并被内核接受\n        // TCP使用三次握手来建立连接，握手完毕后accept返回。一个已连接描述符connfd\n        // 该描述符用于与新连接的那个客户通信\n        // accept为每个连接到本服务器的客户返回一个新描述符\n        // 该服务器一次只能处理一个客户。如果多个客户连接同时到达，系统内核在某个最大数量的限制下把他们排入队列，然后每次返回一个给accept函数\n\t\tconnfd = Accept(listenfd, (SA *) &cliaddr, &clilen);\n\n\t\tif ( (childpid = Fork()) == 0) {\t\n\t\t\tClose(listenfd);\t\n\t\t\tstr_echo(connfd);\t\n\t\t\texit(0);\n\t\t}\n        // 服务器调用close关闭与客户的连接，引发四次挥手操作。（当然这里引用计数不为0，实际close操作在子进程完成）\n\t\tClose(connfd);\t\t\t\n\t}\n}\n\nvoid str_echo(int sockfd)\n{\n    ssize_t\t\tn;\n    char\t\tbuf[MAXLINE];\n\n    again:\n    // 如果客户关闭连接，那么接收到客户的FIN将导致服务器子进程的read函数返回0，将导致str_echo返回，从而终止子进程\n    while ( (n = read(sockfd, buf, MAXLINE)) > 0)\n        Writen(sockfd, buf, n);\n\n    if (n < 0 && errno == EINTR)\n        goto again;\n    else if (n < 0)\n        err_sys(\"str_echo: read error\");\n}\n```\n\n当服务器端accept函数返回时，服务器调用fork，再有子进程调用str_echo。该函数调用readline，readline调用read，而read在等待客户送入一行文本期间阻塞。\n\n另一方面，服务器父进程再次调用accept并阻塞，等待下一个客户连接。\n\n### 并发服务器\n\n主服务器循环通过派生一个子进程来处理每个新的连接\n\n当服务器接收并接受这个客户的连接，它fork一个自身的副本，让子进程来处理该客户的请求\n\n![image-20210603172737267](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603172737267.png)\n\nTCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点，它必须查看套接字对的所有四个元素才能确定由哪个端点接收某个到达的分节\n\n我们必须在服务器主机上区分监听套接字和已连接套接字。已连接套接字使用与监听套接字相同的本地端口（21）\n\n对于同一个本地端口（21）存在三个套接字：\n\n+ 如果一个分节来自客户端端口1500，目的地为服务器端端口21，被传递到第一个子进程\n+ 如果一个分节来自客户端端口1501，目的地为服务器端端口21，被传递到第二个子进程\n+ 所有目的端口为21的其他TCP分节被传递给拥有监听套接字的那个最初服务器（父进程）\n\n\n\n是在同时有大量的客户连接到同一个服务器上时用于提供并发性的一种技术，每个客户连接都迫使服务器为他fork一个新的进程\n\n```c\npid_t pid;\nint listenfd, connfd;\nlistenfd = Socket();\nBind(listenfd);\nListen(listenfd, backlog);\n\nfor(;;) {\n    connfd = Accept(listenfd);\n    // 子进程进入if执行\n    if ((pid == Fork()) == 0) {\n        Close(listenfd);\n        processHandler(connfd); // 处理请求\n        Close(connfd);\n        exit(0);\n    }\n    Close(connfd);\n}\n```\n\n当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户（提供已连接套接字connfd)，父进程则等待另一个连接（通过监听套接字listenfd)。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。\n\n对一个TCP套接字调用close会导致发送一个FIN，随后是正常的四次挥手，那么为什么父进程对connfd调用close没有终止它与客户的连接？因为每个文件或套接字都有一个引用计数（是当前打开着的引用该文件或套接字的描述符的个数）。套接字真正的清理和资源释放要等到引用计数值为0时才发生，即会在子进程也关闭connfd时发生。\n\n![image-20210603200912778](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200912778.png)\n\n![image-20210603200853359](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200853359.png)\n\n![image-20210603200933250](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200933250.png)\n\n## 常见函数\n\n### Socket函数\n\n```c#\nint socket(int family, in type, int protocol);\n```\n\n指定期望的通信协议类型（例如使用IPv4的TCP）\n\nsocket函数在成功时返回一个小的非负整数值，与文件描述符类似，称为套接字描述符，简称sockfd\n\n### connect函数\n\nTCP客户用connect函数来建立与TCP服务器的连接\n\n```c\nint connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);\n```\n\nsockfd是由socket函数返回的套接字描述符\n\nservaddr、addrlen是指向套接字地址结构的指针和该结构的大小（结构中含有服务器的IP地址和端口号）\n\n客户调用connect函数时不需要调用bind函数，因为如果需要，内核会确定源ip地址，并选择一个临时端口作为源端口\n\n如果是TCP套接字，调用connect函数将触发TCP的三次握手过程\n\n### bind函数\n\n```c\nint bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);\n```\n\nmyaddr、addrlen是指向套接字地址结构的指针和该结构的大小（可以指定要绑定的IP地址和端口号），如果要绑定IP地址，则该IP地址必须属于其所在主机的网络接口之一\n\n### listen函数\n\n```c\nint listen(int sockfd, int backlog);\n```\n\nlisten函数仅由TCP服务器调用，作用：\n\n1. 当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是一个调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。即调用listen函数导致套接字从CLOSED状态转换成LISTEN状态\n2. 本函数第二个参数规定内核应该为相应套接字排队的最大连接个数\n\n内核为任何一个给定的监听套接字维护两个队列：\n\n1. **未完成连接队列**。每个这样的SYN分节对应其中的一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三次握手过程。这些套接字处于SYN_RCVD状态（在三次握手正常完成的前提下，未完成连接队列中的任何一项在其中的存留时间就是一个RTT)\n2. **已完成连接队列**。每个已完成TCP三次握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603193151337.png\" alt=\"image-20210603193151337\" style=\"zoom:67%;\" />\n\n每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。\n\n当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项，然后响应三次握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK。这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器SYN的ACK）到达或该项超时为止。如果三次握手正常完成，该项就从未完成连接队列移动到已完成连接队列的队尾。当进程调用accept时，已完成连接队列中的队头项就返回给进程，或者如果该队列为空，那么进程将处于休眠状态，直到TCP在该队列中放入一项才唤醒他\n\n在三次握手完成之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为相应已连接套接字的接受缓冲区大小\n\n### accept函数\n\n```c\nint accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);\n```\n\naccept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程置为休眠状态。\n\n如果accept成功。那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接\n\n称第一个参数为监听套接字描述符，返回值为已连接套接字描述符。一个服务器通常仅仅创建一个监听套接字，他在该服务器的生命周期内一直存在，内核为每个由服务器进程接受的客户连接创建一个已连接套接字（对于他的三次握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。\n\n### close函数\n\n```c\nint close(int sockfd);\n```\n\n关闭套接字，终止TCP连接\n\n默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的参数。\n\n然而TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接四次挥手\n\n### fork函数\n\nfork函数是Unix派生新进程的唯一方法\n\n```c\npid_t fork(void); // 返回在子进程中为0，在父进程中为子进程ID，若出错为-1\n```\n\n调用fork函数一次，它返回两次：\n\n1. 它在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID\n2. 在子进程又返回一次，返回值是0\n\n因此返回值本身告知当前进程是父进程还是子进程\n\n父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享。如果父进程在调用accept之后调用fork，所接受的已连接套接字随后就在父进程和子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字\n\nfork函数典型用法：\n\n1. 一个进程创建一个自身的副本，这样每个副本都可以在来一个副本执行其他任务的同时处理各自的某个操作，这是网络服务器的典型用法。\n2. 一个进程想要执行另一个程序。该进程调用fork创建一个自身的副本，其中一个副本（子进程）调用exec把自身替换成新的程序。是shell等程序的典型用法。\n\n# IO模型\n\n## 概述\n\n首先看看服务端处理网络请求的典型过程：\n\n\n\n![服务端处理网络请求流程图](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396ad36eda)\n\n\n\n可以看到，主要处理步骤包括：\n\n- 1、获取请求数据 客户端与服务器建立连接发出请求，服务器接受请求（1-3）\n- 2、构建响应 当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）\n- 3、返回数据 服务器将已构建好的响应再通过内核空间的网络I/O发还给客户端（5-7）\n\n\n\n输入操作通常包括两个不同的阶段：\n\n1. 等待数据准备好\n2. 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\n**UDP套接字编程**\n\n下面的IO模型拿UDP举例，因为数据准备好读取的概念比较简单：要么整个数据报已经收到，要么还没有。所以先简述UDP套接字编程\n\n客户不与服务器建立连接，而是只使用sendto函数给服务器发送数据报，其中必须指定目的地。类似的，服务器不接受来自客户的连接，而是只管调用recvfrom函数，等待来自某个客户的数据到达。recvfrom将与所接收的数据报一道返回客户的协议地址，因此服务器可以把响应发送给正确的客户。\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604183925749.png\" alt=\"image-20210604183925749\" style=\"zoom:67%;\" />\n\n**阻塞和非阻塞**\n\n描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。阻塞调用会一直等待远程数据就绪再返回，直到读取结束。而非阻塞无论在什么情况下都会立即返回，虽然非阻塞大部分时间不会被block，但是它仍要求进程不断地去主动询问kernel是否准备好数据，也需要进程主动地再次调用recvfrom来将数据拷贝到用户内存。\n\n- 阻塞调用与非阻塞调用\n    - 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回\n    - 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程\n\n两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。阻塞是指调用方一直在等待而且别的事情什么都不做。非阻塞是指调用方先去忙别的事情\n\n**同步和异步**\n\n描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。\n\n- 同步处理与异步处理\n\n    - 同步处理是指被调用方得到最终结果之后才返回给调用方\n    - 异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方\n\n    **阻塞、非阻塞的讨论对象是调用者**\n\n    **同步、异步的讨论对象是被调用者**\n\n### IO模型比较\n\n+ 同步IO操作：导致请求进程阻塞，直到IO操作完成\n+ 异步IO操作：不导致请求进程阻塞\n\n前四种同步IO模型的主要区别在第一阶段，因为他们第二阶段是一样的：在数据从内核复制到调用者缓冲区期间，进程阻塞与recvfrom调用。相反，异步IO模型在这两阶段都要处理\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae2b8fb2a)\n\n阻塞式IO模型、非阻塞式IO模型、IO复用模型、信号驱动IO模型都是同步IO模型，因为其中真正的IO操作(recvfrom)将阻塞进程。\n\n![image-20210207165051430](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207165051430.png)\n\n## 阻塞式IO模型\n\n把recvfrom视为系统调用，因为要区分应用进程和内核。它一般都会从在应用进程空间中运行切换到在内核空间中运行，一段时间后再切换回来\n\n进程调用recvfrom，其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据报。\n\n![阻塞式I/O模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396a811072)\n\n\n\n![image-20210207152811758](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207152811758.png)\n\n\n\n- 同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。\n\n- 用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。\n\n- 服务端采用单线程，当 accept 一个请求后，在read调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理完 ）（无法处理并发）\n\n- 套接字的读写方法，默认是阻塞的。例如read方法要传递进去一个参数n，代表最多读取n个字节后再返回，如果一个字节都没有，则线程卡顿直到新的数据到来或连接关闭，read方法才能返回。\n\n- write方法一般不会阻塞，除非内核为套接字分配的写缓冲区满了，write方法才会阻塞，直到缓冲区中有空间空闲出来\n\n- 即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。\n\n- 阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作\n\n```java\n{\n    read(socket， buffer);\n    process(buffer);\n}\n```\n\n\n\n## 非阻塞式IO模型\n\n进程把一个套接字设置成非阻塞是通知内核：当所请求的IO操作需要把本进程阻塞时，不阻塞了，而是返回一个错误\n\n前三次调用recvfrom时没有数据可返回，因此内核立即返回一个RWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回。我们接着处理数据。\n\n当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，称为轮询。应用程序持续轮询内核，以查看某个操作是否就绪，往往会消耗大量的CPU时间\n\n![非阻塞式I/O模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396af89a4a)\n\n\n\n![image-20210207153315652](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153315652.png)\n\n- 由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。\n- 非阻塞IO通常发生在一个for循环当中，因为每次进行IO操作时要么IO操作成功，要么当IO操作会阻塞时返回错误EWOULDBLOCK/EAGAIN，然后再根据需要进行下一次的for循环操作，这种类似轮询的方式会浪费很多不必要的CPU资源，是一种糟糕的设计。\n- 即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。\n\n```\n{\n    while(read(socket， buffer) != SUCCESS);\n    process(buffer);\n}\n```\n\n## IO复用模型\n\n**比喻** 放了一堆鱼竿，在岸边一直守着这堆鱼竿，没有鱼上钩就玩手机\n\n例子：\n\nRedis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而  **I/O 多路复用** 就是为了解决这个问题而出现的。\n\nredis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。\n\n+ 优先选择时间复杂度为O(1)的IO复用函数作为底层实现，例如epoll\n+ 以select系统调用为保底，时间复杂度O(N)\n+ 基于react设计模式监听IO事件\n\n多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。\n\n**这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。\n\n\n\n**原理**\n\n- IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。\n- IO 多路复用实现一个线程可以监视多个文件句柄；\n- 一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；\n- 没有文件句柄就绪就会阻塞应用程序，交出CPU。\n- 多路是指网络连接，复用指的是同一个线程\n- 服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。\n\n\n\n\n\n多路网络连接复用一个io线程。\n\n单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。\n\n一种可以在单线程/进程中处理多个事件流的方法\n\nI/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作\n\n进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个IO条件就绪（输入已经准备好或描述符已能承接更多的输出），它就通知进程。\n\n适用于：\n\n+ 客户处理多个描述符（通常是交互式输入和网络套接字）\n+ TCP服务器既要处理监听套接字，又要处理已连接套接字\n\nselect, poll, epoll 都是I/O多路复用的具体的实现\n\n阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的IO系统调用上。\n\n我们阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据复制到应用进程缓冲区。\n\n使用select的优势在于我们可以等待多个描述符就绪。\n\n服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。\n\n![I/O复用模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396cc78d98)\n\n![image-20210207153611203](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153611203.png)\n\n用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。\n\n从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在**同一个线程内同时处理多个IO请求的目的**。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。\n\n```java\n//将socket添加到select监视中\nselect(socket);\n\nwhile(1) {\n    sockets = select();\n    //一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。\n    for(socket in sockets) {\n        if(can_read(socket)) {\n            read(socket， buffer);\n            process(buffer);\n        }\n    }\n}\n```\n\n虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。\n\nIO多路复用模型使用了Reactor设计模式实现了这一机制。\n\n![image-20210207154330581](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154330581.png)\n\n**Reactor设计模式**\n\nEventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。\n\n![image-20210207154426634](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154426634.png)\n\n通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。\n\n用户线程使用IO多路复用模型的伪代码描述为：\n\n```c\nvoid UserEventHandler::handle_event() {\n    if(can_read(socket)) {\n        read(socket， buffer);\n        process(buffer);\n    }\n}\n\n//用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。\n{\n\tReactor.register(new UserEventHandler(socket));\n}\n```\n\nReactor中handle_events事件循环的伪代码大致如下。\n\n事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。\n\n```c\nReactor::handle_events() {\n    while(1) {\n        sockets = select();\n        for(socket in sockets) {\n        \tget_event_handler(socket).handle_event();\n        }\n    }\n}\n```\n\n## 信号驱动IO模型\n\n**比喻** 鱼竿上系了个铃铛，当铃铛响，就知道鱼上钩，然后可以专心玩手机\n\n信号驱动IO是利用信号机制，让内核告知应用程序文件描述符的相关事件。\n\n但信号驱动IO在网络编程的时候通常很少用到，因为在网络环境中，和socket相关的读写事件太多了，比如下面的事件都会导致SIGIO信号的产生：\n\n1. TCP连接建立\n2. 一方断开TCP连接请求\n3. 断开TCP连接请求完成\n4. TCP连接半关闭\n5. 数据到达TCP socket\n6. 数据已经发送出去(如：写buffer有空余空间)\n\n上面所有的这些都会产生SIGIO信号，但我们没办法在SIGIO对应的信号处理函数中区分上述不同的事件，SIGIO只应该在IO事件单一情况下使用，比如说用来监听端口的socket，因为只有客户端发起新连接的时候才会产生SIGIO信号。\n\n也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们\n\n首先开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用立即返回，我们进程继续工作，即没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。\n\n无论如何处理SIGIO信号，这种模型优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取\n\n![信号驱动式I/O模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396ceccf52)\n\n**缺点**\n\n- 信号I/O在大量IO操作时可能会因为信号队列溢出导致没法通知\n- 信号驱动I/O尽管对于处理UDP套接字来说有用，即这种信号通知意味着到达一个数据报，或者返回一个异步错误。但是，对于TCP而言，信号驱动的I/O方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源，与前几种方式相比优势尽失\n\n## 异步IO模型\n\n告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。\n\n与信号驱动模型的主要区别在于：信号驱动IO由内核通知我们何时可以启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成。\n\n我们调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。\n\n本例子中我们假设要求内核在操作完成时产生某个信号。该信号直到数据已复制到应用进程缓冲区才产生。\n\n![异步I/O模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae253818f)\n\n“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。\n\n\n\n![image-20210207154623278](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154623278.png)\n\n异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。\n\n目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。\n\n异步IO和信号驱动IO差不多，但它比信号驱动IO可以多做一步：相比信号驱动IO需要在程序中完成数据从用户态到内核态(或反方向)的拷贝，异\t步IO可以把拷贝这一步也帮我们完成之后才通知应用程序。\n\n异步IO是完全完成了数据的拷贝之后才通知程序进行处理，没有阻塞的数据读写过程。\n\n这里面的读取操作的语义与上面的几种模型都不同。这里的读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。\n\n# select、poll、epoll函数\n\n## 概述\n\n### 文件描述符\n\n文件描述符是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。\n\n### 进程阻塞\n\n 正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得了CPU资源），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。\n\n### 缓存I/O\n\n 缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。\n\n### 总结\n\nselect，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。\n\nselect，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。\n\nselect，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。\n\n## select函数\n\n### 概述\n\n该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。\n\n例子：我们可以调用select，告知内核仅在下列情况发生时才返回：\n\n+ 集合{1，4，5}中的任何描述符准备好读；\n+ 集合{2，7}中的任何描述符准备好写；\n+ 集合{1，4}中的任何描述符有异常条件待处理；\n+ 已经历10.2s\n\n也就是说，我们调用select告知内核对哪些描述符（就读、写或异常条件）感兴趣，以及等待多长时间。\n\n```c\nint select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);\n```\n\ntimeout告知内核等待所指定描述符中的任何一个就绪可花多长时间，可赋值为三种情况：\n\n1. 永远等待下去：仅在有一个描述符准备好IO才返回。为此，我们把该参数设置为空指针。\n2. 等待一段固定时间：在有一个描述符准备好IO才返回，但是不超过指定参数的时间。\n3. 根本不等待：检查描述符后立即返回，这称为轮询。参数指定为0.\n\nfd_set可以理解为一个集合，这个集合中存放的是文件描述符，即文件句柄。readset、writeset、exceptset指定我们要让内核测试读、写和异常条件的描述符，如果对某一个条件不感兴趣，就可以把它设为空指针。\n\nmaxfdp1参数指定待测试的描述符个数，它的值是待测试的最大描述符加1。\n\n当函数返回时，结果将指示哪些描述符已就绪。\n\n头文件<sys/select.h>中定义的FD_SETSIZE常量值是数据类型fd_set中的描述符总数（通常是1024）\n\n当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读。\n\n使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。\n\n### 理解\n\n+ 这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于select可以监听多个socket，我们可以用它来处理多个连接。\n+ 在select模型中每个socket一般都设置成non-blocking，虽然等待数据阶段仍然是阻塞状态，但是它是被select调用阻塞的，而不是直接被I/O阻塞的。select底层通过轮询机制来判断每个socket读写是否就绪。\n+ 当然select也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了epoll作为select的改进版本。\n+ select、poll、epoll本质上也都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\n\n### 优缺点\n\n它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。\n\n- 使用事件轮询API的select函数，输入是read_fds & write_fds；输出是与之对应的可读可写事件，同时还提供了timeout参数。\n- 如果期间没有任何事件到来，那么最多等待timeout的值的时间，线程处于阻塞状态。\n- 一旦其间有任何事件到来，就立即返回。时间过了之后还是没有任何事件，就立即返回。\n- 拿到事件后，线程可以继续挨个处理相应事件，处理完了继续轮询，于是线程就进入了一个死循环，我们称循环为时间循环，一个循环为一个周期。\n\n**select缺点**\nselect本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：\n\n- 单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024 ;为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)\n- 每次调用 select，都需要把 fd_set集合从用户态拷贝到内核态，这个开销在 fd_set很多时会很大；需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大\n- 对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发)。当套接字比较多的时候，每次select()都要通过遍历FD_SET中SIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。\n\n### 客户端程序\n\n![image-20210604193654363](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604193654363.png)\n\n8-13行：**调用select**\n\n我们只需要一个用于检查可读性的描述符集。该集合由FD_ZERO初始化，并用FD_SET打开两位：一位对应于标准IO文件指针fp，一位对应于套接字sockfd。fileno函数把标准IO文件指针转换为对应的描述符。因为select函数只工作在描述符上。\n\n计算两个描述符中的较大者后，调用select。在该调用中，写集合指针和异常集合指针都是空指针。最后一个参数（时间限制）也是空指针，因为我们希望本调用阻塞到某个描述符就绪为止。\n\n14-18行：**处理可读套接字**\n\n如果在select返回时套接字是可读的，就执行对应操作\n\n19-23行：**处理可读输入**\n\n如果标准输入可读，就执行相应操作\n\n### 服务器程序\n\n把之前的案例重写为使用select来处理任意个客户的单进程程序。\n\n![image-20210604194813136](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604194813136.png)\n\n服务器只维护一个读描述符集，假设服务器是前台启动的，那么描述符0、1、2分别被置为标准输入、标准输出、标准错误输出。所以监听套接字的第一个可用描述符是3\n\nclient数组中含有每个客户的已连接套接字描述符，初始化为-1\n\n![image-20210604195011425](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195011425.png)\n\n当第一个客户与服务器建立连接时，监听描述符变为可读，我们的服务器于是调用accept\n\n![image-20210604195113032](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195113032.png)\n\n我们的服务器必须在client数组中记住每个新的已连接描述符，并把他加到描述符集中去：\n\n![image-20210604195226480](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195226480.png)\n\n随后第二个客户与服务器建立连接：\n\n![image-20210604195258834](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195258834.png)\n\n接着假设第一个客户终止连接。该客户的TCP发生一个FIN，使得描述符4变得可读。当服务器读这个已连接套接字时，read将返回0。于是关闭该套接字并且把client[0]置为-1，把描述符集中描述符4的位设置位0\n\n![image-20210604195506423](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195506423.png)\n\n总之，有客户到达时，我们在client数组中的第一个可用项（值为-1的项）中记录其已连接套接字的描述符。并且还必须把这个已连接描述符加到读描述符集中\n\n```c\nlistenfd = Socket(AF_INET, SOCK_STREAM, 0);\nBind(listenfd);\nListen(listenfd, LISTENQ);\n\nfor ( ; ; ) {\n    nready = Select(maxfd+1, &rset, NULL, NULL, NULL);\n    // 处理新连接接入\n    if (FD_ISSET(listenfd, &rset)) {\t\n        connfd = Accept(listenfd);\n    }\n    // 检查现有连接\n    for (i = 0; i <= maxi; i++) {\t\n        if (FD_ISSET(sockfd, &rset)) {\n            if ( (n = Read(sockfd, buf, MAXLINE)) == 0) {\n            } else\n                Writen(sockfd, buf, n);\n        }\n    }\n}\n```\n\n- **创建监听套接字并调用select进行初始化**\n- **阻塞于select**：select等待某个事件发生：或是新连接建立，或是数据、FIN或RST到达\n- **accept新的连接**：如果监听套接字变为可读，则已建立一个新的连接。我们调用accept并更新相应的数据结构。\n- **检查现有连接**：对于每个现有的客户连接，我们要测试其描述符是否在select返回的描述集里。\n\n## poll函数\n\n```c\nint poll(struct pollfd *fdarray, unsigned long nfds, int timeout);\n```\n\n- fdarray是指向一个结构数组的指针，每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件。还是三种：处理输入的、处理输出的、处理错误的\n- nfds指定了结构数组中元素的个数\n- timeout指定poll函数返回前等待多长时间\n- 当发生错误时，poll函数返回值是-1、若定时器到时之前没有任何描述符就绪，则返回0、否则返回就绪描述符的个数（即revents成员值非0的描述符个数）\n\n\n\npoll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。\n\n**poll缺点**\n它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有缺点：\n\n- 每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；\n- 对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时）\n\n### 服务器\n\n```c\nint main(int argc, char **argv)\n{\n\tlistenfd = Socket(AF_INET, SOCK_STREAM, 0);\n\tBind();\n\tListen(listenfd, LISTENQ);\n\n    struct pollfd\t\tclient[OPEN_MAX];\n    \n\tclient[0].fd = listenfd;\n\tclient[0].events = POLLRDNORM;\n\tfor (i = 1; i < OPEN_MAX; i++)\n\t\tclient[i].fd = -1;\t\t\t\t\t\t\n\n\tfor ( ; ; ) {\n\t\tnready = Poll(client, maxi+1, INFTIM);\n\n        // 新连接\n\t\tif (client[0].revents & POLLRDNORM) {\t\n\t\t\tfor (i = 1; i < OPEN_MAX; i++)\n\t\t\t\tif (client[i].fd < 0) {\n\t\t\t\t\tclient[i].fd = connfd;\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tclient[i].events = POLLRDNORM;\n\t\t}\n\t\t// 检查某个现有连接上的数据\n\t\tfor (i = 1; i <= maxi; i++) {\t\n\t\t\tif ( (sockfd = client[i].fd) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (client[i].revents & (POLLRDNORM | POLLERR)) {\n\t\t\t\tif ( (n = read(sockfd, buf, MAXLINE)) < 0) {\n\t\t\t\t\t\tClose(sockfd);\n\t\t\t\t\t\tclient[i].fd = -1;\n\t\t\t\t} else if (n == 0) {\n                    // 代表连接关闭\n                    Close(sockfd);\n\t\t\t\t\tclient[i].fd = -1;\n                } else {\n                    Writen(sockfd, buf, n);\n                }\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n+ 分配pollfd结构数组\n+ 初始化。把client数组的第一项用于监听套接字，并把其余各项的描述符成员置为-1\n+ 调用poll，检查新的连接。我们调用poll以等待新的连接或者现有连接上有数据可读。当一个新的连接被接受后，我们在client数组中查找第一个描述符成员为负的可用项。注意，从下标1开始搜索，因为client[0]固定用于监听套接字。\n+ 检查某个现有连接上的数据。\n\n## epoll函数\n\n### 简介\n\nepoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是**事件驱动（每个事件关联上fd）**的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）\n\n**epoll的优点**\n\n- 没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；\n- 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll；\n- 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。\n\n### 了解\n\nepoll 全称 eventpoll，是 linux 内核实现IO多路复用（IO multiplexing）的一个实现。IO多路复用的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。\n\nepoll 监听的 fd（file descriptor）集合是常驻内核的，它有 3 个系统调用 （*epoll_create*, *epoll_wait*, *epoll_ctl*），通过 *epoll_wait* 可以多次监听同一个 fd 集合，只返回可读写那部分\n\nselect 只有一个系统调用，每次要监听都要将其从用户态传到内核，有事件时返回整个集合。\n\n从性能上看，如果 fd 集合很大，用户态和内核态之间数据复制的花销是很大的，所以 select 一般限制 fd 集合最大1024。\n\n从使用上看，epoll 返回的是可用的 fd 子集，select 返回的是全部，哪些可用需要用户遍历判断。\n\n### 原理\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20140911103834_133.jpg)\n\n设想一个场景：有100万用户同时与一个进程保持着TCP连接，而每一时刻只有几十个或几百个TCP连接是活跃的(接收TCP包)，也就是说在每一时刻进程只需要处理这100万连接中的一小部分连接。那么，如何才能高效的处理这种场景呢？进程是否在每次询问操作系统收集有事件发生的TCP连接时，把这100万个连接告诉操作系统，然后由操作系统找出其中有事件发生的几百个连接呢？实际上，在Linux2.4版本以前，那时的select或者poll事件驱动方式是这样做的。\n\n  这里有个非常明显的问题，即在某一时刻，进程收集有事件的连接时，其实这100万连接中的大部分都是没有事件发生的。因此如果每次收集事件时，都把100万连接的套接字传给操作系统(这首先是用户态内存到内核态内存的大量复制)，而由操作系统内核寻找这些连接上有没有未处理的事件，将会是巨大的资源浪费，然后select和poll就是这样做的，因此它们最多只能处理几千个并发连接。而epoll不这样做，它在Linux内核中申请了一个简易的文件系统，把原先的一个select或poll调用分成了3部分：\n\n```c++\nint epoll_create(int size);  \nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  \nint epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);  \n```\n\n1. 调用epoll_create建立一个epoll对象(在epoll文件系统中给这个句柄分配资源)；\n\n2. 调用epoll_ctl向epoll对象中添加这100万个连接的套接字；\n\n3. 调用epoll_wait收集发生事件的连接。\n\n  这样只需要在进程启动时建立1个epoll对象，并在需要的时候向它添加或删除连接就可以了，因此，在实际收集事件时，epoll_wait的效率就会非常高，因为调用epoll_wait时并没有向它传递这100万个连接，内核也不需要去遍历全部的连接。\n\n### epoll_create\n\n当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关，如下所示：\n\n```c\nstruct eventpoll {\n　　...\n　　/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，\n　　也就是这个epoll监控的事件*/\n　　struct rb_root rbr;\n　　/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/\n　　struct list_head rdllist;\n　　...\n};\n```\n\n调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个rdllist双向链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。\n\n  所有添加到epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的rdllist双向链表中。\n在epoll中对于每一个事件都会建立一个epitem结构体，如下所示：\n\n```c\nstruct epitem {\n　　...\n　　//红黑树节点\n　　struct rb_node rbn;\n　　//双向链表节点\n　　struct list_head rdllink;\n　　//事件句柄等信息\n　　struct epoll_filefd ffd;\n　　//指向其所属的eventepoll对象\n　　struct eventpoll *ep;\n　　//期待的事件类型\n　　struct epoll_event event;\n　　...\n}; // 这里包含每一个事件对应着的信息。\n```\n\n当调用epoll_wait检查是否有发生事件的连接时，只是检查eventpoll对象中的rdllist双向链表是否有epitem元素而已，如果rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx效率非常高。epoll_ctl在向epoll对象中添加、修改、删除事件时，从rbr红黑树中查找事件也非常快，也就是说epoll是非常高效的，它可以轻易地处理百万级别的并发连接。\n\n### 原理总结\n\n- 一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。\n\n- 执行epoll_create()时，创建了红黑树和就绪链表；\n\n- 执行epoll_ctl()时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；\n\n- 执行epoll_wait()时立刻返回准备就绪链表里的数据即可。\n\n\n\n\n\n\n\n# JAVA IO\n\n## BIO\n\n### 概述\n\nBIO是一个同步并阻塞的IO模式，**传统的  java.io 包**，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如**File抽象、输入输出流**等。**交互方式是同步、阻塞的方式**，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1890419bbba44f29b0f71f5598c5e111~tplv-k3u1fbpfcp-zoom-1.image)\n\nblocking I/O。同步阻塞模型\n\n由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行处理。\n\n每个线程都需要创建独立的线程，当并发量大时，需要创建大量线程来处理连接，系统资源占用大\n\n代码中的read操作是阻塞操作，如果连接之后，服务端一直不发送数据，将会一直阻塞当前线程，浪费资源。\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603081447596.png\" alt=\"image-20210603081447596\" style=\"zoom: 67%;\" />\n\n### 详解\n\n当服务器进程运行时, 可能会同时监听到多个客户的连接请求。\n\n每当一个客户进程执行以下代码：\n\n```java\nSocket client = new Socket(\"127.0.0.1\", 8848);\n```\n\n就意味着在远程主机的 8848 端口上, 监听到了一个客户的连接请求。管理客户连接请求的任务是由操作系统来完成的。操作系统把这些连接请求存储在一个先进先出的队列中。当队列中的连接请求达到了队列的最大容量时, 服务器进程所在的主机会拒绝新的连接请求。只有当服务器进程通过 ServerSocket 的 accept() 方法从队列中取出连接请求, 使队列腾出空位时，队列才能继续加入新的连接请求。\n\n 对于客户进程, 如果它发出的连接请求被加入到服务器的请求连接队列中, 就意味着客户与服务器的连接建立成功, 客户进程从 Socket 构造方法中正常返回。\n\n当客户进程的 Socket构造方法返回成功, 表示客户进程的连接请求被加入到服务器进程的请求连接队列中。 虽然客户端成功返回 Socket对象， 但是还没跟服务器进程形成一条通信线路。必须在服务器进程通过 ServerSocket 的 accept() 方法从请求连接队列中取出连接请求，并返回一个Socket 对象后，服务器进程这个Socket 对象才与客户端的 Socket 对象形成一条通信线路。\n\nServerSocket 的 accept() 方法从连接请求队列中取出一个客户的连接请求，然后创建与客户连接的 Socket 对象, 并将它返回。如果队列中没有连接请求，accept() 方法就会一直等待，直到接收到了连接请求才返回。\n\n 接下来，服务器从 Socket 对象中获得输入流和输出流，就能与客户交换数据。\n\n服务器的主线程负责接收客户的连接, 每次接收到一个客户连接, 就会创建一个工作线程, 由它负责与客户的通信\n\n### 示例程序\n\n**Server**\n\n```java\npublic class BIOServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8848);\n        while (true) {\n            // 线程在accept调用时处于休眠状态，等待某个客户连接到达并被内核接受\n            Socket socket = serverSocket.accept();\n            new Thread(() -> handler(socket)).start();\n        }\n    }\n\n    public static void handler(Socket socket) {\n        InputStream inputStream = null;\n        try {\n            byte[] bytes = new byte[1024];\n            inputStream = socket.getInputStream();\n            int read;\n            while ((read = inputStream.read(bytes)) != -1) {\n                System.out.println(new String(bytes, 0, read));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n**Client**\n\n```java\npublic class BIOClient {\n    public static void main(String[] args) throws IOException {\n        Socket client = new Socket(\"127.0.0.1\", 8848);\n        OutputStream outputStream = client.getOutputStream();\n        String msg = \"Hello Server!\";\n        outputStream.write(msg.getBytes(StandardCharsets.UTF_8));\n        client.close();\n    }\n}\n```\n\n## NIO\n\n### IO操作\n\n应用程序的IO操作实际上不是物理设备级别的读写，而是缓存的复制。read和write两大系统调用都不负责数据在内核缓冲区和物理设备（如磁盘、网卡等）之间的交换。这个底层的读写交换操作是由操作系统内核（Kernel）来完成的。\n\n外部设备的直接读写涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少底层系统的频繁中断所导致的时间损耗、性能损耗，出现了内核缓冲区。操作系统会对内核缓冲区进行监控，等待缓冲区达到一定数量的时候，再进行IO设备的中断处理，集中执行物理设备的实际IO操作，通过这种机制来提升系统的性能。\n\n上层应用使用read系统调用时，仅仅把数据从内核缓冲区复制到应用的缓冲区（进程缓冲区）；上层应用使用write系统调用时，仅仅把数据从应用的缓冲区复制到内核缓冲区。在大多数情况下，Linux系统中用户程序的IO读写程序并没有进行实际的IO操作，而是在用户缓冲区和内核缓冲区之间直接进行数据的交换。\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605150414935.png\" alt=\"image-20210605150414935\" style=\"zoom: 67%;\" />\n\n一个完整输入流程的两个阶段：\n•应用程序等待数据准备好：第一个阶段，应用程序等待数据通过网络到达网卡，当所等待的分组到达时，数据被操作系统复制到内核缓冲区中。这个工作由操作系统自动完成，用户程序无感知。\n•从内核缓冲区向用户缓冲区复制数据：第二个阶段，内核将数据从内核缓冲区复制到应用的用户缓冲区。\n\n### IO多路复用模型\n\nselect/epoll系统调用。通过该系统调用，一个用户进程（或者线程）可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核就能够将文件描述符的就绪状态返回给用户进程（或者线程），用户空间可以根据文件描述符的就绪状态进行相应的IO系统调用。\nIO多路复用（IO Multiplexing）属于一种经典的Reactor模式实现，有时也称为异步阻塞IO，Java中的Selector属于这种模型。\n\n在IO多路复用模型中通过select/epoll系统调用，单个应用程序的线程可以不断地轮询成百上千的socket连接的就绪状态，当某个或者某些socket网络连接有IO就绪状态时就返回这些就绪的状态（或者说就绪事件）。\n\n（1）选择器注册。首先，将需要read操作的目标文件描述符（socket连接）提前注册到Linux的select/epoll选择器中，在Java中所对应的选择器类是Selector类。然后，开启整个IO多路复用模型的轮询流程。\n\n（2）就绪状态的轮询。通过选择器的查询方法，查询所有提前注册过的目标文件描述符（socket连接）的IO就绪状态。通过查询的系统调用，内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好或者就绪了就说明内核缓冲区有数据了，内核将该socket加入就绪的列表中，并且返回就绪事件。\n\n（3）用户线程获得了就绪状态的列表后，根据其中的socket连接发起read系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区。\n\n（4）复制完成后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行。\n\n![image-20210605151630414](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605151630414.png)\n\n通过JDK的源码可以看出，Java语言的NIO组件在Linux系统上是使用epoll系统调用实现的。所以，Java语言的NIO组件所使用的就是IO多路复用模型。\n\nIO多路复用模型的缺点是，本质上select/epoll系统调用是阻塞式的，属于同步IO，需要在读写事件就绪后由系统调用本身负责读写，也就是说这个读写过程是阻塞的。要彻底地解除线程的阻塞，就必须使用异步IO模型。\n\n\n\n### 介绍\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/f1c9e5d2b37d489e959ccd2d7573a713~tplv-k3u1fbpfcp-zoom-1.image)\n\nnon-blocking I/O或New IO\n\n同步非阻塞，服务端可以开启一个线程处理多个连接，它是非阻塞的，客户端发送的数据都会注册到多路复用器selector上面，当selector（selector的select方法是阻塞的）轮询到有读、写或者连接请求时，才会转发到后端程序进行处理，没有数据的时候，业务程序并不需要阻塞等待。\n\n![image-20210603090056517](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603090056517.png)\n\n### Channel\n\n+ 类比于IO流，但是具有双向性，既可读，又可写\n+ ServerSocketChannel用来监听客户端连接请求并创建SocketChannel与客户端进行通信\n+ 只能通过Buffer读写Channel中数据\n\n### Buffer\n\n本质上是一块内存区域\n\n**字段**\n\n```java\nprivate int mark = -1; // 存储特定position位置，后续通过reset恢复到该位置，依然可以读取这里的数据\nprivate int position = 0; // 读写操作时的索引下标，最大为capacity-1;写模式切换到读模式时，会变为0\nprivate int limit; // 写模式下等于capacity，切换到读模式时，limit表示最多能从buffer中读取多少，等于写模式下的position\nprivate int capacity; // 容量，标识最大能容纳多少字节\n```\n\n**API实例**\n\n```java\nByteBuffer byteBuffer = ByteBuffer.allocate(10); // position = 0,limit = 10,capacity=10\nbyteBuffer.put(\"aaa\".getBytes()); // position = 3, limit = 10, capacity = 10\nbyteBuffer.flip(); // 从写模式切换到读模式 position = 0, limit = 3, capacity = 10\nbyteBuffer.get();  // position = 1, limit = 3, capacity = 10\nbyteBuffer.mark(); // mark = 1, position = 1, limit = 3, capacity = 10\nbyteBuffer.get();  // mark = 1, position = 2, limit = 3, capacity = 10\nbyteBuffer.reset();  // mark = 1, position = 1, limit = 3, capacity = 10\nbyteBuffer.clear(); // 所有属性重置 position = 0, limit = 10, capacity = 10\n```\n\n使用Java NIO Buffer类的基本步骤如下：\n（1）使用创建子类实例对象的allocate()方法创建一个Buffer类的实例对象。\n（2）调用put()方法将数据写入缓冲区中。\n（3）写入完成后，在开始读取数据前调用Buffer.flip()方法，将缓冲区转换为读模式。\n（4）调用get()方法，可以从缓冲区中读取数据。\n（5）读取完成后，调用Buffer.clear()方法或Buffer.compact()方法，将缓冲区转换为写模式，可以继续写入。\n\n### Selector\n\n**选择器** /**多路复用器**。用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels，也就是可以管理多个网络连接。\n\n### 示例程序\n\n**NIOServer**\n\n```java\npackage io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NIOServer {\n    public void start() throws IOException {\n        Selector selector = Selector.open();\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.bind(new InetSocketAddress(8848));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        while (true) {\n            int readyChannels = selector.select(); // 获取可用channel数量\n            if (readyChannels == 0) {\n                continue;\n            }\n            Set<SelectionKey> selectionKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = selectionKeys.iterator();\n            while (iterator.hasNext()) {\n                SelectionKey selectionKey = iterator.next();\n                iterator.remove();\n                if (selectionKey.isReadable()) {\n                    readHandler(selectionKey, selector);\n                } else if (selectionKey.isAcceptable()) {\n                    acceptHandler(serverSocketChannel, selector);\n                }\n            }\n        }\n    }\n\n    private void acceptHandler(ServerSocketChannel serverSocketChannel, \n                               Selector selector) throws IOException {\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        // encode返回的是ByteBuffer\n        socketChannel.write(Charset.defaultCharset().encode(\"成功连上了服务器!\"));\n    }\n\n    private void readHandler(SelectionKey selectionKey, \n                             Selector selector) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        // 读取客户端数据\n        StringBuilder msg = new StringBuilder();\n        while (socketChannel.read(byteBuffer) > 0) {\n            byteBuffer.flip();\n            msg.append(Charset.defaultCharset().decode(byteBuffer));\n        }\n        // 将channel再次注册到selector上,监听它的可读事件\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        if (msg.length() > 0) {\n            System.out.println(msg.toString());\n            broadCast(selector, socketChannel, msg.toString());\n        }\n    }\n\n    private void broadCast(Selector selector, SocketChannel sourceChannel, String msg) {\n        // 获取所有已接入客户端channel\n        Set<SelectionKey> selectionKeys = selector.keys();\n        selectionKeys.forEach(selectionKey -> {\n            Channel targetChannel = selectionKey.channel();\n            // 剔除发消息的那个channel\n            if (targetChannel instanceof SocketChannel \n                && targetChannel != sourceChannel) {\n                try {\n                    // 向所有channel广播信息\n                    ((SocketChannel) targetChannel).write(Charset.defaultCharset().encode(msg));\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n\n    public static void main(String[] args) throws IOException {\n        new NIOServer().start();\n    }\n}\n```\n\n**NIOClient**\n\n```java\npackage io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class NIOClient {\n    static class NIOClientHandler implements Runnable {\n        private final Selector selector;\n\n        public NIOClientHandler(Selector selector) {\n            this.selector = selector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    int readyChannels = selector.select(); // 获取可用channel数量\n                    if (readyChannels == 0) {\n                        continue;\n                    }\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                    while (iterator.hasNext()) {\n                        SelectionKey selectionKey = iterator.next();\n                        iterator.remove();\n                        if (selectionKey.isReadable()) {\n                            readHandler(selectionKey, selector);\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        private void readHandler(SelectionKey selectionKey, \n                                 Selector selector) throws IOException {\n            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n            // 读取服务器端响应数据\n            StringBuilder msg = new StringBuilder();\n            while (socketChannel.read(byteBuffer) > 0) {\n                byteBuffer.flip();\n                msg.append(Charset.defaultCharset().decode(byteBuffer));\n            }\n            // 将channel再次注册到selector上,监听它的可读事件\n            socketChannel.register(selector, SelectionKey.OP_READ);\n            if (msg.length() > 0) {\n                System.out.println(msg.toString());\n            }\n        }\n    }\n\n    public void start() throws IOException {\n        SocketChannel socketChannel = \n            SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 8848));\n        // 新开线程，专门接收服务器端发送的信息\n        Selector selector = Selector.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        new Thread(new NIOClientHandler(selector)).start();\n\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String msg = scanner.nextLine();\n            if (msg != null && msg.length() > 0) {\n                socketChannel.write(Charset.defaultCharset().encode(msg));\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        new NIOClient().start();\n    }\n}\n```\n\n\n\n## AIO\n\nAsynchronous I/O或NIO.2\n\n异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理\n\n**AIO**提供了从建立连接到读、写的全异步操作。**AIO**可用于异步的**文件读写**和**网络通信**。\n\n**Server**\n\n```java\npackage io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousServerSocketChannel;\nimport java.nio.channels.AsynchronousSocketChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.charset.Charset;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\npublic class AIOServer {\n    public static void main(String[] args) {\n        try {\n            final int port = 8848;\n            AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open();\n            serverSocketChannel.bind(new InetSocketAddress(port));\n            // 需要在handler的实现中处理连接请求和监听下一个连接、数据收发，以及通信异常。\n            // 消息处理回调接口，是一个负责消费异步IO操作结果的消息处理器\n            CompletionHandler<AsynchronousSocketChannel, Object> handler = new CompletionHandler<AsynchronousSocketChannel, Object>() {\n                /*\n                当I/O操作成功完成时，会回调到completed方法，failed方法则在I/O操作失败时被回调。\n                需要注意的是：在CompletionHandler的实现中应当及时处理操作结果，以避免一直占用调用线程而不能分发其他的CompletionHandler处理器。\n                 */\n                @Override\n                public void completed(AsynchronousSocketChannel result, Object attachment) {\n                    // 继续监听下一个连接请求\n                    serverSocketChannel.accept(attachment, this);\n                    try {\n                        System.out.println(\"接受了一个连接：\" + result.getRemoteAddress().toString());\n                        // result表示当前接受的客户端的连接会话，与客户端的通信都需要通过该连接会话进行。\n                        result.write(Charset.defaultCharset().encode(\"Server:Hello World\"));\n\n                        ByteBuffer readBuffer = ByteBuffer.allocate(128);\n                        result.read(readBuffer).get();\n                        System.out.println(new String(readBuffer.array()));\n                    } catch (IOException | InterruptedException | ExecutionException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n                @Override\n                public void failed(Throwable exc, Object attachment) {\n                    System.out.println(\"出错了：\" + exc.getMessage());\n                }\n            };\n            // 是一个异步方法，调用会直接返回,为了让子线程能够有时间处理监听客户端的连接会话，这里让主线程休眠一段时间\n            serverSocketChannel.accept(null, handler);\n            TimeUnit.MINUTES.sleep(Integer.MAX_VALUE);\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**Client**\n\n```java\npackage io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousSocketChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.charset.Charset;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\npublic class AIOClient {\n    public static void main(String[] args) {\n        try {\n            AsynchronousSocketChannel client = AsynchronousSocketChannel.open();\n            client.connect(new InetSocketAddress(\"127.0.0.1\", 8848), null, new CompletionHandler<Void, Object>() {\n                @Override\n                public void completed(Void result, Object attachment) {\n                    System.out.println(\"成功连接到服务器!\");\n                    try {\n                        client.write(Charset.defaultCharset().encode(\"Client:Hello World\"));\n                        ByteBuffer readBuffer = ByteBuffer.allocate(128);\n                        client.read(readBuffer).get();\n                        System.out.println(new String(readBuffer.array()));\n                    } catch (InterruptedException | ExecutionException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n                @Override\n                public void failed(Throwable exc, Object attachment) {\n                    exc.printStackTrace();\n                }\n            });\n            TimeUnit.MINUTES.sleep(Integer.MAX_VALUE);\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n","source":"_posts/计算机基础/计算机网络/网络编程基础.md","raw":"---\ntitle: 网络编程基础\nauthor: tongji4m3\ntop: true\ncover: false\ncoverImg: /images/1.jpg\ntoc: true\nmathjax: false\nsummary: 学习网络编程所做的笔记，包括基本套记字编程，IO模型、epoll函数、Java IO等。\ncategories: 计算机网络\ntags:\n  - IO模型\n  - epoll\n  - NIO\nabbrlink: adcb768c\ndate: 2021-05-05 00:00:00\n---\n\n\n\n# 基本套接字编程\n\n## TCP原理\n\n### 三次握手\n\n1. 服务器必须准备好接受外来的连接。通常是通过调用socket、bind和listen三个函数完成，此时为**被动打开**\n2. 客户通过调用connect发起**主动打开**，这导致客户端TCP发送一个SYN，告诉服务器自己的初始序列号（不带数据）。\n3. 服务器必须确认（ACK）客户的SYN，同时自己也要发送一个SYN，含有服务器将在同一连接中发送数据的初始序列号。\n4. 客户必须确认服务器的SYN\n\n![image-20210603165512924](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165512924.png)\n\n### 四次挥手\n\n1. 某个应用进程（假设是客户端）首先调用close，执行**主动关闭**，于是发送一个FIN，表示数据发送完毕\n2. 接收到这个FIN的对端（假设是服务器）执行**被动关闭**，给客户发送回ACK。FIN的接收意味着服务器端在相应连接上再无额外数据可接收\n3. 一段时间后（这段时间内，服务器端仍然可以向客户端发送数据，称为半关闭状态），服务器端也将调用close关闭他的套接字，它会像客户端也发送一个FIN\n4. 执行主动关闭的那端会发送ACK确认这个FIN\n\n![image-20210603165546769](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165546769.png)\n\n### TCP状态转换图\n\n用粗实线表示客户状态转换，粗虚线表示服务器状态转换。\n\n接收表示该状态转换在接受到什么分节时发生，发送表示该状态转换会发送什么分节\n\n例子1 **客户端建立连接**：\n\n当某个应用程序在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED，这个状态通常是数据传送发生时的状态\n\n例子2 **客户端、服务器断开连接**：\n\n如果某个应用进程在接收到一个FIN之前调用close（主动关闭），则转换到FIN_WAIT_1状态\n\n但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN（被动关闭），那就转换到CLOSE_WAIT状态\n\n![image-20210603170310342](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603170310342.png)\n\n**TIME_WAIT状态**\n\n执行主动关闭的那端会经历该状态，持续时间是2MSL（两倍的最长分节生命期，MSL是任何IP数据报能够在因特网中存活的最长时间）\n\nTIME_WAIT状态存在原因：\n\n1. 可靠地实现TCP全双工连接的终止。假设最终的ACK丢失，服务器将重新发送它的最终FIN，所以客户端必须维护状态信息，以允许它重新发送最终的那个ACK\n2. 允许老的重复分节在网络中消逝。假设关闭了一个TCP连接，过一段时间又在相同的IP地址和端口号之间建立另一个连接（称为前一个连接的化身，因为IP、端口号一样）。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再次出现。为做到这一点，TCP就不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT的持续时间的2MSL，就足以让某个方向上的分组最多存活MSL即被丢弃。通过该规则，就能保证每成功建立一个TCP连接，来自该连接先前化身的老的重复分组都已经在网络中消逝了。\n\n### 完整流程\n\n![image-20210603171012559](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603171012559.png)\n\n\n\n应用进程写数据到一个TCP套接字中时发生的步骤：\n\n![image-20210603185857129](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603185857129.png)\n\n每一个TCP套接字有一个发送缓冲区。当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区，如果该套接字的发送缓冲区容不下该应用进程的所有数据，该应用进程将置于休眠状态。内核将不从write系统调用返回，直到应用进程缓冲区中所有数据都复制到套接字发送缓冲区\n\n因此，从一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据。\n\n这一端的TCP提取套接字发送缓冲区中的数据并把它发送给对端TCP。对端TCP必须确认收到的数据，伴随来自对端的ACK的不断到达，本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止\n\n本端TCP以MSS大小的块把数据传递给IP，同时给每个数据块安上一个TCP首部已构成TCP分节，IP给每个TCP分节安上一个IP首部以构成IP数据报，并按照其目的IP地址查找路由表项以确定外出接口，然后把数据报传递给相应的数据链路。\n\n## 简单案例\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603191611037.png\" alt=\"image-20210603191611037\" style=\"zoom: 67%;\" />\n\n\n\n![image-20210603203304963](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603203304963.png)\n\n**正常终止步骤**\n\n1. 当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回\n2. 当str_cli函数返回到客户的main函数时，main通过调用exit终止\n3. 进程终止处理的部分工作是关闭所有打开的描述符，因此客户打开的套接字由内核关闭，这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应。至此，服务器套接字处于CLOSE_WAIT状态，客户套接字处于FIN_WAIT_2状态\n4. 当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline返回0，这导致str_echo函数返回服务器子进程的main函数\n5. 服务器子进程通过调用exit来终止\n6. 服务器子进程中打开的所有描述符随之关闭，由子进程来关闭已连接套接字会引发TCP连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK。至此连接完全终止，客户端套接字进入TIME_WAIT状态\n\n### 客户端\n\n```c\n#include\t\"unp.h\"\n\nint\nmain(int argc, char **argv)\n{\n\tint\t\t\t\t\tsockfd;\n\tstruct sockaddr_in\tservaddr;\n\n\tif (argc != 2)\n\t\terr_quit(\"usage: tcpcli <IPaddress>\");\n\n    // 创建一个套接字，返回描述符\n\tsockfd = Socket(AF_INET, SOCK_STREAM, 0);\n\n    // 填入服务器的IP地址和端口号\n\tbzero(&servaddr, sizeof(servaddr));\n\tservaddr.sin_family = AF_INET;\n\tservaddr.sin_port = htons(SERV_PORT);\n\tInet_pton(AF_INET, argv[1], &servaddr.sin_addr);\n\n    // 和服务器建立TCP连接\n\tConnect(sockfd, (SA *) &servaddr, sizeof(servaddr));\n\n\tstr_cli(stdin, sockfd);\n\n\texit(0); // 终止程序运行，Unix在进程终止时总是关闭该进程所有打开的描述符\n}\n\nvoid\nstr_cli(FILE *fp, int sockfd)\n{\n    char\tsendline[MAXLINE], recvline[MAXLINE];\n\n    while (Fgets(sendline, MAXLINE, fp) != NULL) {\n\n        Writen(sockfd, sendline, strlen(sendline));\n\n        if (Readline(sockfd, recvline, MAXLINE) == 0)\n            err_quit(\"str_cli: server terminated prematurely\");\n\n        Fputs(recvline, stdout);\n    }\n}\n```\n\n客户调用st_cli函数，该函数将阻塞于fgets调用，因为我们还未输入任何数据。\n\n### 服务器端\n\n```c\n#include\t\"unp.h\"\n\nint main(int argc, char **argv)\n{\n\tint\t\t\t\t\tlistenfd, connfd;\n\tpid_t\t\t\t\tchildpid;\n\tsocklen_t\t\t\tclilen;\n\tstruct sockaddr_in\tcliaddr, servaddr;\n\n    // 创建套接字\n\tlistenfd = Socket(AF_INET, SOCK_STREAM, 0);\n\n\tbzero(&servaddr, sizeof(servaddr));\n\tservaddr.sin_family      = AF_INET;\n\tservaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tservaddr.sin_port        = htons(SERV_PORT);\n\n    // 调用bind函数绑定端口号\n\tBind(listenfd, (SA *) &servaddr, sizeof(servaddr));\n\n    // 把套接字转换成一个监听套接字，这样来自客户端的外来连接可以在该套接字由内核接收\n\tListen(listenfd, LISTENQ);\n\n\tfor ( ; ; ) {\n\t\tclilen = sizeof(cliaddr);\n        // 服务器进程在accept调用中被置于休眠状态，等待某个客户连接的到达并被内核接受\n        // TCP使用三次握手来建立连接，握手完毕后accept返回。一个已连接描述符connfd\n        // 该描述符用于与新连接的那个客户通信\n        // accept为每个连接到本服务器的客户返回一个新描述符\n        // 该服务器一次只能处理一个客户。如果多个客户连接同时到达，系统内核在某个最大数量的限制下把他们排入队列，然后每次返回一个给accept函数\n\t\tconnfd = Accept(listenfd, (SA *) &cliaddr, &clilen);\n\n\t\tif ( (childpid = Fork()) == 0) {\t\n\t\t\tClose(listenfd);\t\n\t\t\tstr_echo(connfd);\t\n\t\t\texit(0);\n\t\t}\n        // 服务器调用close关闭与客户的连接，引发四次挥手操作。（当然这里引用计数不为0，实际close操作在子进程完成）\n\t\tClose(connfd);\t\t\t\n\t}\n}\n\nvoid str_echo(int sockfd)\n{\n    ssize_t\t\tn;\n    char\t\tbuf[MAXLINE];\n\n    again:\n    // 如果客户关闭连接，那么接收到客户的FIN将导致服务器子进程的read函数返回0，将导致str_echo返回，从而终止子进程\n    while ( (n = read(sockfd, buf, MAXLINE)) > 0)\n        Writen(sockfd, buf, n);\n\n    if (n < 0 && errno == EINTR)\n        goto again;\n    else if (n < 0)\n        err_sys(\"str_echo: read error\");\n}\n```\n\n当服务器端accept函数返回时，服务器调用fork，再有子进程调用str_echo。该函数调用readline，readline调用read，而read在等待客户送入一行文本期间阻塞。\n\n另一方面，服务器父进程再次调用accept并阻塞，等待下一个客户连接。\n\n### 并发服务器\n\n主服务器循环通过派生一个子进程来处理每个新的连接\n\n当服务器接收并接受这个客户的连接，它fork一个自身的副本，让子进程来处理该客户的请求\n\n![image-20210603172737267](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603172737267.png)\n\nTCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点，它必须查看套接字对的所有四个元素才能确定由哪个端点接收某个到达的分节\n\n我们必须在服务器主机上区分监听套接字和已连接套接字。已连接套接字使用与监听套接字相同的本地端口（21）\n\n对于同一个本地端口（21）存在三个套接字：\n\n+ 如果一个分节来自客户端端口1500，目的地为服务器端端口21，被传递到第一个子进程\n+ 如果一个分节来自客户端端口1501，目的地为服务器端端口21，被传递到第二个子进程\n+ 所有目的端口为21的其他TCP分节被传递给拥有监听套接字的那个最初服务器（父进程）\n\n\n\n是在同时有大量的客户连接到同一个服务器上时用于提供并发性的一种技术，每个客户连接都迫使服务器为他fork一个新的进程\n\n```c\npid_t pid;\nint listenfd, connfd;\nlistenfd = Socket();\nBind(listenfd);\nListen(listenfd, backlog);\n\nfor(;;) {\n    connfd = Accept(listenfd);\n    // 子进程进入if执行\n    if ((pid == Fork()) == 0) {\n        Close(listenfd);\n        processHandler(connfd); // 处理请求\n        Close(connfd);\n        exit(0);\n    }\n    Close(connfd);\n}\n```\n\n当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户（提供已连接套接字connfd)，父进程则等待另一个连接（通过监听套接字listenfd)。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。\n\n对一个TCP套接字调用close会导致发送一个FIN，随后是正常的四次挥手，那么为什么父进程对connfd调用close没有终止它与客户的连接？因为每个文件或套接字都有一个引用计数（是当前打开着的引用该文件或套接字的描述符的个数）。套接字真正的清理和资源释放要等到引用计数值为0时才发生，即会在子进程也关闭connfd时发生。\n\n![image-20210603200912778](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200912778.png)\n\n![image-20210603200853359](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200853359.png)\n\n![image-20210603200933250](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200933250.png)\n\n## 常见函数\n\n### Socket函数\n\n```c#\nint socket(int family, in type, int protocol);\n```\n\n指定期望的通信协议类型（例如使用IPv4的TCP）\n\nsocket函数在成功时返回一个小的非负整数值，与文件描述符类似，称为套接字描述符，简称sockfd\n\n### connect函数\n\nTCP客户用connect函数来建立与TCP服务器的连接\n\n```c\nint connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);\n```\n\nsockfd是由socket函数返回的套接字描述符\n\nservaddr、addrlen是指向套接字地址结构的指针和该结构的大小（结构中含有服务器的IP地址和端口号）\n\n客户调用connect函数时不需要调用bind函数，因为如果需要，内核会确定源ip地址，并选择一个临时端口作为源端口\n\n如果是TCP套接字，调用connect函数将触发TCP的三次握手过程\n\n### bind函数\n\n```c\nint bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);\n```\n\nmyaddr、addrlen是指向套接字地址结构的指针和该结构的大小（可以指定要绑定的IP地址和端口号），如果要绑定IP地址，则该IP地址必须属于其所在主机的网络接口之一\n\n### listen函数\n\n```c\nint listen(int sockfd, int backlog);\n```\n\nlisten函数仅由TCP服务器调用，作用：\n\n1. 当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是一个调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。即调用listen函数导致套接字从CLOSED状态转换成LISTEN状态\n2. 本函数第二个参数规定内核应该为相应套接字排队的最大连接个数\n\n内核为任何一个给定的监听套接字维护两个队列：\n\n1. **未完成连接队列**。每个这样的SYN分节对应其中的一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三次握手过程。这些套接字处于SYN_RCVD状态（在三次握手正常完成的前提下，未完成连接队列中的任何一项在其中的存留时间就是一个RTT)\n2. **已完成连接队列**。每个已完成TCP三次握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603193151337.png\" alt=\"image-20210603193151337\" style=\"zoom:67%;\" />\n\n每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。\n\n当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项，然后响应三次握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK。这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器SYN的ACK）到达或该项超时为止。如果三次握手正常完成，该项就从未完成连接队列移动到已完成连接队列的队尾。当进程调用accept时，已完成连接队列中的队头项就返回给进程，或者如果该队列为空，那么进程将处于休眠状态，直到TCP在该队列中放入一项才唤醒他\n\n在三次握手完成之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为相应已连接套接字的接受缓冲区大小\n\n### accept函数\n\n```c\nint accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);\n```\n\naccept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程置为休眠状态。\n\n如果accept成功。那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接\n\n称第一个参数为监听套接字描述符，返回值为已连接套接字描述符。一个服务器通常仅仅创建一个监听套接字，他在该服务器的生命周期内一直存在，内核为每个由服务器进程接受的客户连接创建一个已连接套接字（对于他的三次握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。\n\n### close函数\n\n```c\nint close(int sockfd);\n```\n\n关闭套接字，终止TCP连接\n\n默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的参数。\n\n然而TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接四次挥手\n\n### fork函数\n\nfork函数是Unix派生新进程的唯一方法\n\n```c\npid_t fork(void); // 返回在子进程中为0，在父进程中为子进程ID，若出错为-1\n```\n\n调用fork函数一次，它返回两次：\n\n1. 它在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID\n2. 在子进程又返回一次，返回值是0\n\n因此返回值本身告知当前进程是父进程还是子进程\n\n父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享。如果父进程在调用accept之后调用fork，所接受的已连接套接字随后就在父进程和子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字\n\nfork函数典型用法：\n\n1. 一个进程创建一个自身的副本，这样每个副本都可以在来一个副本执行其他任务的同时处理各自的某个操作，这是网络服务器的典型用法。\n2. 一个进程想要执行另一个程序。该进程调用fork创建一个自身的副本，其中一个副本（子进程）调用exec把自身替换成新的程序。是shell等程序的典型用法。\n\n# IO模型\n\n## 概述\n\n首先看看服务端处理网络请求的典型过程：\n\n\n\n![服务端处理网络请求流程图](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396ad36eda)\n\n\n\n可以看到，主要处理步骤包括：\n\n- 1、获取请求数据 客户端与服务器建立连接发出请求，服务器接受请求（1-3）\n- 2、构建响应 当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）\n- 3、返回数据 服务器将已构建好的响应再通过内核空间的网络I/O发还给客户端（5-7）\n\n\n\n输入操作通常包括两个不同的阶段：\n\n1. 等待数据准备好\n2. 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\n**UDP套接字编程**\n\n下面的IO模型拿UDP举例，因为数据准备好读取的概念比较简单：要么整个数据报已经收到，要么还没有。所以先简述UDP套接字编程\n\n客户不与服务器建立连接，而是只使用sendto函数给服务器发送数据报，其中必须指定目的地。类似的，服务器不接受来自客户的连接，而是只管调用recvfrom函数，等待来自某个客户的数据到达。recvfrom将与所接收的数据报一道返回客户的协议地址，因此服务器可以把响应发送给正确的客户。\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604183925749.png\" alt=\"image-20210604183925749\" style=\"zoom:67%;\" />\n\n**阻塞和非阻塞**\n\n描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。阻塞调用会一直等待远程数据就绪再返回，直到读取结束。而非阻塞无论在什么情况下都会立即返回，虽然非阻塞大部分时间不会被block，但是它仍要求进程不断地去主动询问kernel是否准备好数据，也需要进程主动地再次调用recvfrom来将数据拷贝到用户内存。\n\n- 阻塞调用与非阻塞调用\n    - 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回\n    - 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程\n\n两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。阻塞是指调用方一直在等待而且别的事情什么都不做。非阻塞是指调用方先去忙别的事情\n\n**同步和异步**\n\n描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。\n\n- 同步处理与异步处理\n\n    - 同步处理是指被调用方得到最终结果之后才返回给调用方\n    - 异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方\n\n    **阻塞、非阻塞的讨论对象是调用者**\n\n    **同步、异步的讨论对象是被调用者**\n\n### IO模型比较\n\n+ 同步IO操作：导致请求进程阻塞，直到IO操作完成\n+ 异步IO操作：不导致请求进程阻塞\n\n前四种同步IO模型的主要区别在第一阶段，因为他们第二阶段是一样的：在数据从内核复制到调用者缓冲区期间，进程阻塞与recvfrom调用。相反，异步IO模型在这两阶段都要处理\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae2b8fb2a)\n\n阻塞式IO模型、非阻塞式IO模型、IO复用模型、信号驱动IO模型都是同步IO模型，因为其中真正的IO操作(recvfrom)将阻塞进程。\n\n![image-20210207165051430](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207165051430.png)\n\n## 阻塞式IO模型\n\n把recvfrom视为系统调用，因为要区分应用进程和内核。它一般都会从在应用进程空间中运行切换到在内核空间中运行，一段时间后再切换回来\n\n进程调用recvfrom，其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据报。\n\n![阻塞式I/O模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396a811072)\n\n\n\n![image-20210207152811758](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207152811758.png)\n\n\n\n- 同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。\n\n- 用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。\n\n- 服务端采用单线程，当 accept 一个请求后，在read调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理完 ）（无法处理并发）\n\n- 套接字的读写方法，默认是阻塞的。例如read方法要传递进去一个参数n，代表最多读取n个字节后再返回，如果一个字节都没有，则线程卡顿直到新的数据到来或连接关闭，read方法才能返回。\n\n- write方法一般不会阻塞，除非内核为套接字分配的写缓冲区满了，write方法才会阻塞，直到缓冲区中有空间空闲出来\n\n- 即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。\n\n- 阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作\n\n```java\n{\n    read(socket， buffer);\n    process(buffer);\n}\n```\n\n\n\n## 非阻塞式IO模型\n\n进程把一个套接字设置成非阻塞是通知内核：当所请求的IO操作需要把本进程阻塞时，不阻塞了，而是返回一个错误\n\n前三次调用recvfrom时没有数据可返回，因此内核立即返回一个RWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回。我们接着处理数据。\n\n当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，称为轮询。应用程序持续轮询内核，以查看某个操作是否就绪，往往会消耗大量的CPU时间\n\n![非阻塞式I/O模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396af89a4a)\n\n\n\n![image-20210207153315652](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153315652.png)\n\n- 由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。\n- 非阻塞IO通常发生在一个for循环当中，因为每次进行IO操作时要么IO操作成功，要么当IO操作会阻塞时返回错误EWOULDBLOCK/EAGAIN，然后再根据需要进行下一次的for循环操作，这种类似轮询的方式会浪费很多不必要的CPU资源，是一种糟糕的设计。\n- 即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。\n\n```\n{\n    while(read(socket， buffer) != SUCCESS);\n    process(buffer);\n}\n```\n\n## IO复用模型\n\n**比喻** 放了一堆鱼竿，在岸边一直守着这堆鱼竿，没有鱼上钩就玩手机\n\n例子：\n\nRedis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而  **I/O 多路复用** 就是为了解决这个问题而出现的。\n\nredis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。\n\n+ 优先选择时间复杂度为O(1)的IO复用函数作为底层实现，例如epoll\n+ 以select系统调用为保底，时间复杂度O(N)\n+ 基于react设计模式监听IO事件\n\n多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。\n\n**这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。\n\n\n\n**原理**\n\n- IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。\n- IO 多路复用实现一个线程可以监视多个文件句柄；\n- 一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；\n- 没有文件句柄就绪就会阻塞应用程序，交出CPU。\n- 多路是指网络连接，复用指的是同一个线程\n- 服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。\n\n\n\n\n\n多路网络连接复用一个io线程。\n\n单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。\n\n一种可以在单线程/进程中处理多个事件流的方法\n\nI/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作\n\n进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个IO条件就绪（输入已经准备好或描述符已能承接更多的输出），它就通知进程。\n\n适用于：\n\n+ 客户处理多个描述符（通常是交互式输入和网络套接字）\n+ TCP服务器既要处理监听套接字，又要处理已连接套接字\n\nselect, poll, epoll 都是I/O多路复用的具体的实现\n\n阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的IO系统调用上。\n\n我们阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据复制到应用进程缓冲区。\n\n使用select的优势在于我们可以等待多个描述符就绪。\n\n服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。\n\n![I/O复用模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396cc78d98)\n\n![image-20210207153611203](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153611203.png)\n\n用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。\n\n从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在**同一个线程内同时处理多个IO请求的目的**。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。\n\n```java\n//将socket添加到select监视中\nselect(socket);\n\nwhile(1) {\n    sockets = select();\n    //一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。\n    for(socket in sockets) {\n        if(can_read(socket)) {\n            read(socket， buffer);\n            process(buffer);\n        }\n    }\n}\n```\n\n虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。\n\nIO多路复用模型使用了Reactor设计模式实现了这一机制。\n\n![image-20210207154330581](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154330581.png)\n\n**Reactor设计模式**\n\nEventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。\n\n![image-20210207154426634](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154426634.png)\n\n通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。\n\n用户线程使用IO多路复用模型的伪代码描述为：\n\n```c\nvoid UserEventHandler::handle_event() {\n    if(can_read(socket)) {\n        read(socket， buffer);\n        process(buffer);\n    }\n}\n\n//用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。\n{\n\tReactor.register(new UserEventHandler(socket));\n}\n```\n\nReactor中handle_events事件循环的伪代码大致如下。\n\n事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。\n\n```c\nReactor::handle_events() {\n    while(1) {\n        sockets = select();\n        for(socket in sockets) {\n        \tget_event_handler(socket).handle_event();\n        }\n    }\n}\n```\n\n## 信号驱动IO模型\n\n**比喻** 鱼竿上系了个铃铛，当铃铛响，就知道鱼上钩，然后可以专心玩手机\n\n信号驱动IO是利用信号机制，让内核告知应用程序文件描述符的相关事件。\n\n但信号驱动IO在网络编程的时候通常很少用到，因为在网络环境中，和socket相关的读写事件太多了，比如下面的事件都会导致SIGIO信号的产生：\n\n1. TCP连接建立\n2. 一方断开TCP连接请求\n3. 断开TCP连接请求完成\n4. TCP连接半关闭\n5. 数据到达TCP socket\n6. 数据已经发送出去(如：写buffer有空余空间)\n\n上面所有的这些都会产生SIGIO信号，但我们没办法在SIGIO对应的信号处理函数中区分上述不同的事件，SIGIO只应该在IO事件单一情况下使用，比如说用来监听端口的socket，因为只有客户端发起新连接的时候才会产生SIGIO信号。\n\n也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们\n\n首先开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用立即返回，我们进程继续工作，即没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。\n\n无论如何处理SIGIO信号，这种模型优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取\n\n![信号驱动式I/O模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396ceccf52)\n\n**缺点**\n\n- 信号I/O在大量IO操作时可能会因为信号队列溢出导致没法通知\n- 信号驱动I/O尽管对于处理UDP套接字来说有用，即这种信号通知意味着到达一个数据报，或者返回一个异步错误。但是，对于TCP而言，信号驱动的I/O方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源，与前几种方式相比优势尽失\n\n## 异步IO模型\n\n告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。\n\n与信号驱动模型的主要区别在于：信号驱动IO由内核通知我们何时可以启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成。\n\n我们调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。\n\n本例子中我们假设要求内核在操作完成时产生某个信号。该信号直到数据已复制到应用进程缓冲区才产生。\n\n![异步I/O模型](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae253818f)\n\n“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。\n\n\n\n![image-20210207154623278](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154623278.png)\n\n异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。\n\n目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。\n\n异步IO和信号驱动IO差不多，但它比信号驱动IO可以多做一步：相比信号驱动IO需要在程序中完成数据从用户态到内核态(或反方向)的拷贝，异\t步IO可以把拷贝这一步也帮我们完成之后才通知应用程序。\n\n异步IO是完全完成了数据的拷贝之后才通知程序进行处理，没有阻塞的数据读写过程。\n\n这里面的读取操作的语义与上面的几种模型都不同。这里的读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。\n\n# select、poll、epoll函数\n\n## 概述\n\n### 文件描述符\n\n文件描述符是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。\n\n### 进程阻塞\n\n 正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得了CPU资源），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。\n\n### 缓存I/O\n\n 缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。\n\n### 总结\n\nselect，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。\n\nselect，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。\n\nselect，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。\n\n## select函数\n\n### 概述\n\n该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。\n\n例子：我们可以调用select，告知内核仅在下列情况发生时才返回：\n\n+ 集合{1，4，5}中的任何描述符准备好读；\n+ 集合{2，7}中的任何描述符准备好写；\n+ 集合{1，4}中的任何描述符有异常条件待处理；\n+ 已经历10.2s\n\n也就是说，我们调用select告知内核对哪些描述符（就读、写或异常条件）感兴趣，以及等待多长时间。\n\n```c\nint select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);\n```\n\ntimeout告知内核等待所指定描述符中的任何一个就绪可花多长时间，可赋值为三种情况：\n\n1. 永远等待下去：仅在有一个描述符准备好IO才返回。为此，我们把该参数设置为空指针。\n2. 等待一段固定时间：在有一个描述符准备好IO才返回，但是不超过指定参数的时间。\n3. 根本不等待：检查描述符后立即返回，这称为轮询。参数指定为0.\n\nfd_set可以理解为一个集合，这个集合中存放的是文件描述符，即文件句柄。readset、writeset、exceptset指定我们要让内核测试读、写和异常条件的描述符，如果对某一个条件不感兴趣，就可以把它设为空指针。\n\nmaxfdp1参数指定待测试的描述符个数，它的值是待测试的最大描述符加1。\n\n当函数返回时，结果将指示哪些描述符已就绪。\n\n头文件<sys/select.h>中定义的FD_SETSIZE常量值是数据类型fd_set中的描述符总数（通常是1024）\n\n当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读。\n\n使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。\n\n### 理解\n\n+ 这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于select可以监听多个socket，我们可以用它来处理多个连接。\n+ 在select模型中每个socket一般都设置成non-blocking，虽然等待数据阶段仍然是阻塞状态，但是它是被select调用阻塞的，而不是直接被I/O阻塞的。select底层通过轮询机制来判断每个socket读写是否就绪。\n+ 当然select也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了epoll作为select的改进版本。\n+ select、poll、epoll本质上也都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\n\n### 优缺点\n\n它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。\n\n- 使用事件轮询API的select函数，输入是read_fds & write_fds；输出是与之对应的可读可写事件，同时还提供了timeout参数。\n- 如果期间没有任何事件到来，那么最多等待timeout的值的时间，线程处于阻塞状态。\n- 一旦其间有任何事件到来，就立即返回。时间过了之后还是没有任何事件，就立即返回。\n- 拿到事件后，线程可以继续挨个处理相应事件，处理完了继续轮询，于是线程就进入了一个死循环，我们称循环为时间循环，一个循环为一个周期。\n\n**select缺点**\nselect本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：\n\n- 单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024 ;为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)\n- 每次调用 select，都需要把 fd_set集合从用户态拷贝到内核态，这个开销在 fd_set很多时会很大；需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大\n- 对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发)。当套接字比较多的时候，每次select()都要通过遍历FD_SET中SIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。\n\n### 客户端程序\n\n![image-20210604193654363](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604193654363.png)\n\n8-13行：**调用select**\n\n我们只需要一个用于检查可读性的描述符集。该集合由FD_ZERO初始化，并用FD_SET打开两位：一位对应于标准IO文件指针fp，一位对应于套接字sockfd。fileno函数把标准IO文件指针转换为对应的描述符。因为select函数只工作在描述符上。\n\n计算两个描述符中的较大者后，调用select。在该调用中，写集合指针和异常集合指针都是空指针。最后一个参数（时间限制）也是空指针，因为我们希望本调用阻塞到某个描述符就绪为止。\n\n14-18行：**处理可读套接字**\n\n如果在select返回时套接字是可读的，就执行对应操作\n\n19-23行：**处理可读输入**\n\n如果标准输入可读，就执行相应操作\n\n### 服务器程序\n\n把之前的案例重写为使用select来处理任意个客户的单进程程序。\n\n![image-20210604194813136](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604194813136.png)\n\n服务器只维护一个读描述符集，假设服务器是前台启动的，那么描述符0、1、2分别被置为标准输入、标准输出、标准错误输出。所以监听套接字的第一个可用描述符是3\n\nclient数组中含有每个客户的已连接套接字描述符，初始化为-1\n\n![image-20210604195011425](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195011425.png)\n\n当第一个客户与服务器建立连接时，监听描述符变为可读，我们的服务器于是调用accept\n\n![image-20210604195113032](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195113032.png)\n\n我们的服务器必须在client数组中记住每个新的已连接描述符，并把他加到描述符集中去：\n\n![image-20210604195226480](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195226480.png)\n\n随后第二个客户与服务器建立连接：\n\n![image-20210604195258834](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195258834.png)\n\n接着假设第一个客户终止连接。该客户的TCP发生一个FIN，使得描述符4变得可读。当服务器读这个已连接套接字时，read将返回0。于是关闭该套接字并且把client[0]置为-1，把描述符集中描述符4的位设置位0\n\n![image-20210604195506423](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195506423.png)\n\n总之，有客户到达时，我们在client数组中的第一个可用项（值为-1的项）中记录其已连接套接字的描述符。并且还必须把这个已连接描述符加到读描述符集中\n\n```c\nlistenfd = Socket(AF_INET, SOCK_STREAM, 0);\nBind(listenfd);\nListen(listenfd, LISTENQ);\n\nfor ( ; ; ) {\n    nready = Select(maxfd+1, &rset, NULL, NULL, NULL);\n    // 处理新连接接入\n    if (FD_ISSET(listenfd, &rset)) {\t\n        connfd = Accept(listenfd);\n    }\n    // 检查现有连接\n    for (i = 0; i <= maxi; i++) {\t\n        if (FD_ISSET(sockfd, &rset)) {\n            if ( (n = Read(sockfd, buf, MAXLINE)) == 0) {\n            } else\n                Writen(sockfd, buf, n);\n        }\n    }\n}\n```\n\n- **创建监听套接字并调用select进行初始化**\n- **阻塞于select**：select等待某个事件发生：或是新连接建立，或是数据、FIN或RST到达\n- **accept新的连接**：如果监听套接字变为可读，则已建立一个新的连接。我们调用accept并更新相应的数据结构。\n- **检查现有连接**：对于每个现有的客户连接，我们要测试其描述符是否在select返回的描述集里。\n\n## poll函数\n\n```c\nint poll(struct pollfd *fdarray, unsigned long nfds, int timeout);\n```\n\n- fdarray是指向一个结构数组的指针，每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件。还是三种：处理输入的、处理输出的、处理错误的\n- nfds指定了结构数组中元素的个数\n- timeout指定poll函数返回前等待多长时间\n- 当发生错误时，poll函数返回值是-1、若定时器到时之前没有任何描述符就绪，则返回0、否则返回就绪描述符的个数（即revents成员值非0的描述符个数）\n\n\n\npoll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。\n\n**poll缺点**\n它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有缺点：\n\n- 每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；\n- 对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时）\n\n### 服务器\n\n```c\nint main(int argc, char **argv)\n{\n\tlistenfd = Socket(AF_INET, SOCK_STREAM, 0);\n\tBind();\n\tListen(listenfd, LISTENQ);\n\n    struct pollfd\t\tclient[OPEN_MAX];\n    \n\tclient[0].fd = listenfd;\n\tclient[0].events = POLLRDNORM;\n\tfor (i = 1; i < OPEN_MAX; i++)\n\t\tclient[i].fd = -1;\t\t\t\t\t\t\n\n\tfor ( ; ; ) {\n\t\tnready = Poll(client, maxi+1, INFTIM);\n\n        // 新连接\n\t\tif (client[0].revents & POLLRDNORM) {\t\n\t\t\tfor (i = 1; i < OPEN_MAX; i++)\n\t\t\t\tif (client[i].fd < 0) {\n\t\t\t\t\tclient[i].fd = connfd;\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tclient[i].events = POLLRDNORM;\n\t\t}\n\t\t// 检查某个现有连接上的数据\n\t\tfor (i = 1; i <= maxi; i++) {\t\n\t\t\tif ( (sockfd = client[i].fd) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (client[i].revents & (POLLRDNORM | POLLERR)) {\n\t\t\t\tif ( (n = read(sockfd, buf, MAXLINE)) < 0) {\n\t\t\t\t\t\tClose(sockfd);\n\t\t\t\t\t\tclient[i].fd = -1;\n\t\t\t\t} else if (n == 0) {\n                    // 代表连接关闭\n                    Close(sockfd);\n\t\t\t\t\tclient[i].fd = -1;\n                } else {\n                    Writen(sockfd, buf, n);\n                }\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n+ 分配pollfd结构数组\n+ 初始化。把client数组的第一项用于监听套接字，并把其余各项的描述符成员置为-1\n+ 调用poll，检查新的连接。我们调用poll以等待新的连接或者现有连接上有数据可读。当一个新的连接被接受后，我们在client数组中查找第一个描述符成员为负的可用项。注意，从下标1开始搜索，因为client[0]固定用于监听套接字。\n+ 检查某个现有连接上的数据。\n\n## epoll函数\n\n### 简介\n\nepoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是**事件驱动（每个事件关联上fd）**的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）\n\n**epoll的优点**\n\n- 没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；\n- 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll；\n- 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。\n\n### 了解\n\nepoll 全称 eventpoll，是 linux 内核实现IO多路复用（IO multiplexing）的一个实现。IO多路复用的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。\n\nepoll 监听的 fd（file descriptor）集合是常驻内核的，它有 3 个系统调用 （*epoll_create*, *epoll_wait*, *epoll_ctl*），通过 *epoll_wait* 可以多次监听同一个 fd 集合，只返回可读写那部分\n\nselect 只有一个系统调用，每次要监听都要将其从用户态传到内核，有事件时返回整个集合。\n\n从性能上看，如果 fd 集合很大，用户态和内核态之间数据复制的花销是很大的，所以 select 一般限制 fd 集合最大1024。\n\n从使用上看，epoll 返回的是可用的 fd 子集，select 返回的是全部，哪些可用需要用户遍历判断。\n\n### 原理\n\n![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20140911103834_133.jpg)\n\n设想一个场景：有100万用户同时与一个进程保持着TCP连接，而每一时刻只有几十个或几百个TCP连接是活跃的(接收TCP包)，也就是说在每一时刻进程只需要处理这100万连接中的一小部分连接。那么，如何才能高效的处理这种场景呢？进程是否在每次询问操作系统收集有事件发生的TCP连接时，把这100万个连接告诉操作系统，然后由操作系统找出其中有事件发生的几百个连接呢？实际上，在Linux2.4版本以前，那时的select或者poll事件驱动方式是这样做的。\n\n  这里有个非常明显的问题，即在某一时刻，进程收集有事件的连接时，其实这100万连接中的大部分都是没有事件发生的。因此如果每次收集事件时，都把100万连接的套接字传给操作系统(这首先是用户态内存到内核态内存的大量复制)，而由操作系统内核寻找这些连接上有没有未处理的事件，将会是巨大的资源浪费，然后select和poll就是这样做的，因此它们最多只能处理几千个并发连接。而epoll不这样做，它在Linux内核中申请了一个简易的文件系统，把原先的一个select或poll调用分成了3部分：\n\n```c++\nint epoll_create(int size);  \nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  \nint epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);  \n```\n\n1. 调用epoll_create建立一个epoll对象(在epoll文件系统中给这个句柄分配资源)；\n\n2. 调用epoll_ctl向epoll对象中添加这100万个连接的套接字；\n\n3. 调用epoll_wait收集发生事件的连接。\n\n  这样只需要在进程启动时建立1个epoll对象，并在需要的时候向它添加或删除连接就可以了，因此，在实际收集事件时，epoll_wait的效率就会非常高，因为调用epoll_wait时并没有向它传递这100万个连接，内核也不需要去遍历全部的连接。\n\n### epoll_create\n\n当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关，如下所示：\n\n```c\nstruct eventpoll {\n　　...\n　　/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，\n　　也就是这个epoll监控的事件*/\n　　struct rb_root rbr;\n　　/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/\n　　struct list_head rdllist;\n　　...\n};\n```\n\n调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个rdllist双向链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。\n\n  所有添加到epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的rdllist双向链表中。\n在epoll中对于每一个事件都会建立一个epitem结构体，如下所示：\n\n```c\nstruct epitem {\n　　...\n　　//红黑树节点\n　　struct rb_node rbn;\n　　//双向链表节点\n　　struct list_head rdllink;\n　　//事件句柄等信息\n　　struct epoll_filefd ffd;\n　　//指向其所属的eventepoll对象\n　　struct eventpoll *ep;\n　　//期待的事件类型\n　　struct epoll_event event;\n　　...\n}; // 这里包含每一个事件对应着的信息。\n```\n\n当调用epoll_wait检查是否有发生事件的连接时，只是检查eventpoll对象中的rdllist双向链表是否有epitem元素而已，如果rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx效率非常高。epoll_ctl在向epoll对象中添加、修改、删除事件时，从rbr红黑树中查找事件也非常快，也就是说epoll是非常高效的，它可以轻易地处理百万级别的并发连接。\n\n### 原理总结\n\n- 一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。\n\n- 执行epoll_create()时，创建了红黑树和就绪链表；\n\n- 执行epoll_ctl()时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；\n\n- 执行epoll_wait()时立刻返回准备就绪链表里的数据即可。\n\n\n\n\n\n\n\n# JAVA IO\n\n## BIO\n\n### 概述\n\nBIO是一个同步并阻塞的IO模式，**传统的  java.io 包**，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如**File抽象、输入输出流**等。**交互方式是同步、阻塞的方式**，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1890419bbba44f29b0f71f5598c5e111~tplv-k3u1fbpfcp-zoom-1.image)\n\nblocking I/O。同步阻塞模型\n\n由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行处理。\n\n每个线程都需要创建独立的线程，当并发量大时，需要创建大量线程来处理连接，系统资源占用大\n\n代码中的read操作是阻塞操作，如果连接之后，服务端一直不发送数据，将会一直阻塞当前线程，浪费资源。\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603081447596.png\" alt=\"image-20210603081447596\" style=\"zoom: 67%;\" />\n\n### 详解\n\n当服务器进程运行时, 可能会同时监听到多个客户的连接请求。\n\n每当一个客户进程执行以下代码：\n\n```java\nSocket client = new Socket(\"127.0.0.1\", 8848);\n```\n\n就意味着在远程主机的 8848 端口上, 监听到了一个客户的连接请求。管理客户连接请求的任务是由操作系统来完成的。操作系统把这些连接请求存储在一个先进先出的队列中。当队列中的连接请求达到了队列的最大容量时, 服务器进程所在的主机会拒绝新的连接请求。只有当服务器进程通过 ServerSocket 的 accept() 方法从队列中取出连接请求, 使队列腾出空位时，队列才能继续加入新的连接请求。\n\n 对于客户进程, 如果它发出的连接请求被加入到服务器的请求连接队列中, 就意味着客户与服务器的连接建立成功, 客户进程从 Socket 构造方法中正常返回。\n\n当客户进程的 Socket构造方法返回成功, 表示客户进程的连接请求被加入到服务器进程的请求连接队列中。 虽然客户端成功返回 Socket对象， 但是还没跟服务器进程形成一条通信线路。必须在服务器进程通过 ServerSocket 的 accept() 方法从请求连接队列中取出连接请求，并返回一个Socket 对象后，服务器进程这个Socket 对象才与客户端的 Socket 对象形成一条通信线路。\n\nServerSocket 的 accept() 方法从连接请求队列中取出一个客户的连接请求，然后创建与客户连接的 Socket 对象, 并将它返回。如果队列中没有连接请求，accept() 方法就会一直等待，直到接收到了连接请求才返回。\n\n 接下来，服务器从 Socket 对象中获得输入流和输出流，就能与客户交换数据。\n\n服务器的主线程负责接收客户的连接, 每次接收到一个客户连接, 就会创建一个工作线程, 由它负责与客户的通信\n\n### 示例程序\n\n**Server**\n\n```java\npublic class BIOServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8848);\n        while (true) {\n            // 线程在accept调用时处于休眠状态，等待某个客户连接到达并被内核接受\n            Socket socket = serverSocket.accept();\n            new Thread(() -> handler(socket)).start();\n        }\n    }\n\n    public static void handler(Socket socket) {\n        InputStream inputStream = null;\n        try {\n            byte[] bytes = new byte[1024];\n            inputStream = socket.getInputStream();\n            int read;\n            while ((read = inputStream.read(bytes)) != -1) {\n                System.out.println(new String(bytes, 0, read));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n**Client**\n\n```java\npublic class BIOClient {\n    public static void main(String[] args) throws IOException {\n        Socket client = new Socket(\"127.0.0.1\", 8848);\n        OutputStream outputStream = client.getOutputStream();\n        String msg = \"Hello Server!\";\n        outputStream.write(msg.getBytes(StandardCharsets.UTF_8));\n        client.close();\n    }\n}\n```\n\n## NIO\n\n### IO操作\n\n应用程序的IO操作实际上不是物理设备级别的读写，而是缓存的复制。read和write两大系统调用都不负责数据在内核缓冲区和物理设备（如磁盘、网卡等）之间的交换。这个底层的读写交换操作是由操作系统内核（Kernel）来完成的。\n\n外部设备的直接读写涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少底层系统的频繁中断所导致的时间损耗、性能损耗，出现了内核缓冲区。操作系统会对内核缓冲区进行监控，等待缓冲区达到一定数量的时候，再进行IO设备的中断处理，集中执行物理设备的实际IO操作，通过这种机制来提升系统的性能。\n\n上层应用使用read系统调用时，仅仅把数据从内核缓冲区复制到应用的缓冲区（进程缓冲区）；上层应用使用write系统调用时，仅仅把数据从应用的缓冲区复制到内核缓冲区。在大多数情况下，Linux系统中用户程序的IO读写程序并没有进行实际的IO操作，而是在用户缓冲区和内核缓冲区之间直接进行数据的交换。\n\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605150414935.png\" alt=\"image-20210605150414935\" style=\"zoom: 67%;\" />\n\n一个完整输入流程的两个阶段：\n•应用程序等待数据准备好：第一个阶段，应用程序等待数据通过网络到达网卡，当所等待的分组到达时，数据被操作系统复制到内核缓冲区中。这个工作由操作系统自动完成，用户程序无感知。\n•从内核缓冲区向用户缓冲区复制数据：第二个阶段，内核将数据从内核缓冲区复制到应用的用户缓冲区。\n\n### IO多路复用模型\n\nselect/epoll系统调用。通过该系统调用，一个用户进程（或者线程）可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核就能够将文件描述符的就绪状态返回给用户进程（或者线程），用户空间可以根据文件描述符的就绪状态进行相应的IO系统调用。\nIO多路复用（IO Multiplexing）属于一种经典的Reactor模式实现，有时也称为异步阻塞IO，Java中的Selector属于这种模型。\n\n在IO多路复用模型中通过select/epoll系统调用，单个应用程序的线程可以不断地轮询成百上千的socket连接的就绪状态，当某个或者某些socket网络连接有IO就绪状态时就返回这些就绪的状态（或者说就绪事件）。\n\n（1）选择器注册。首先，将需要read操作的目标文件描述符（socket连接）提前注册到Linux的select/epoll选择器中，在Java中所对应的选择器类是Selector类。然后，开启整个IO多路复用模型的轮询流程。\n\n（2）就绪状态的轮询。通过选择器的查询方法，查询所有提前注册过的目标文件描述符（socket连接）的IO就绪状态。通过查询的系统调用，内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好或者就绪了就说明内核缓冲区有数据了，内核将该socket加入就绪的列表中，并且返回就绪事件。\n\n（3）用户线程获得了就绪状态的列表后，根据其中的socket连接发起read系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区。\n\n（4）复制完成后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行。\n\n![image-20210605151630414](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605151630414.png)\n\n通过JDK的源码可以看出，Java语言的NIO组件在Linux系统上是使用epoll系统调用实现的。所以，Java语言的NIO组件所使用的就是IO多路复用模型。\n\nIO多路复用模型的缺点是，本质上select/epoll系统调用是阻塞式的，属于同步IO，需要在读写事件就绪后由系统调用本身负责读写，也就是说这个读写过程是阻塞的。要彻底地解除线程的阻塞，就必须使用异步IO模型。\n\n\n\n### 介绍\n\n![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/f1c9e5d2b37d489e959ccd2d7573a713~tplv-k3u1fbpfcp-zoom-1.image)\n\nnon-blocking I/O或New IO\n\n同步非阻塞，服务端可以开启一个线程处理多个连接，它是非阻塞的，客户端发送的数据都会注册到多路复用器selector上面，当selector（selector的select方法是阻塞的）轮询到有读、写或者连接请求时，才会转发到后端程序进行处理，没有数据的时候，业务程序并不需要阻塞等待。\n\n![image-20210603090056517](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603090056517.png)\n\n### Channel\n\n+ 类比于IO流，但是具有双向性，既可读，又可写\n+ ServerSocketChannel用来监听客户端连接请求并创建SocketChannel与客户端进行通信\n+ 只能通过Buffer读写Channel中数据\n\n### Buffer\n\n本质上是一块内存区域\n\n**字段**\n\n```java\nprivate int mark = -1; // 存储特定position位置，后续通过reset恢复到该位置，依然可以读取这里的数据\nprivate int position = 0; // 读写操作时的索引下标，最大为capacity-1;写模式切换到读模式时，会变为0\nprivate int limit; // 写模式下等于capacity，切换到读模式时，limit表示最多能从buffer中读取多少，等于写模式下的position\nprivate int capacity; // 容量，标识最大能容纳多少字节\n```\n\n**API实例**\n\n```java\nByteBuffer byteBuffer = ByteBuffer.allocate(10); // position = 0,limit = 10,capacity=10\nbyteBuffer.put(\"aaa\".getBytes()); // position = 3, limit = 10, capacity = 10\nbyteBuffer.flip(); // 从写模式切换到读模式 position = 0, limit = 3, capacity = 10\nbyteBuffer.get();  // position = 1, limit = 3, capacity = 10\nbyteBuffer.mark(); // mark = 1, position = 1, limit = 3, capacity = 10\nbyteBuffer.get();  // mark = 1, position = 2, limit = 3, capacity = 10\nbyteBuffer.reset();  // mark = 1, position = 1, limit = 3, capacity = 10\nbyteBuffer.clear(); // 所有属性重置 position = 0, limit = 10, capacity = 10\n```\n\n使用Java NIO Buffer类的基本步骤如下：\n（1）使用创建子类实例对象的allocate()方法创建一个Buffer类的实例对象。\n（2）调用put()方法将数据写入缓冲区中。\n（3）写入完成后，在开始读取数据前调用Buffer.flip()方法，将缓冲区转换为读模式。\n（4）调用get()方法，可以从缓冲区中读取数据。\n（5）读取完成后，调用Buffer.clear()方法或Buffer.compact()方法，将缓冲区转换为写模式，可以继续写入。\n\n### Selector\n\n**选择器** /**多路复用器**。用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels，也就是可以管理多个网络连接。\n\n### 示例程序\n\n**NIOServer**\n\n```java\npackage io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NIOServer {\n    public void start() throws IOException {\n        Selector selector = Selector.open();\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.bind(new InetSocketAddress(8848));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        while (true) {\n            int readyChannels = selector.select(); // 获取可用channel数量\n            if (readyChannels == 0) {\n                continue;\n            }\n            Set<SelectionKey> selectionKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = selectionKeys.iterator();\n            while (iterator.hasNext()) {\n                SelectionKey selectionKey = iterator.next();\n                iterator.remove();\n                if (selectionKey.isReadable()) {\n                    readHandler(selectionKey, selector);\n                } else if (selectionKey.isAcceptable()) {\n                    acceptHandler(serverSocketChannel, selector);\n                }\n            }\n        }\n    }\n\n    private void acceptHandler(ServerSocketChannel serverSocketChannel, \n                               Selector selector) throws IOException {\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        // encode返回的是ByteBuffer\n        socketChannel.write(Charset.defaultCharset().encode(\"成功连上了服务器!\"));\n    }\n\n    private void readHandler(SelectionKey selectionKey, \n                             Selector selector) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        // 读取客户端数据\n        StringBuilder msg = new StringBuilder();\n        while (socketChannel.read(byteBuffer) > 0) {\n            byteBuffer.flip();\n            msg.append(Charset.defaultCharset().decode(byteBuffer));\n        }\n        // 将channel再次注册到selector上,监听它的可读事件\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        if (msg.length() > 0) {\n            System.out.println(msg.toString());\n            broadCast(selector, socketChannel, msg.toString());\n        }\n    }\n\n    private void broadCast(Selector selector, SocketChannel sourceChannel, String msg) {\n        // 获取所有已接入客户端channel\n        Set<SelectionKey> selectionKeys = selector.keys();\n        selectionKeys.forEach(selectionKey -> {\n            Channel targetChannel = selectionKey.channel();\n            // 剔除发消息的那个channel\n            if (targetChannel instanceof SocketChannel \n                && targetChannel != sourceChannel) {\n                try {\n                    // 向所有channel广播信息\n                    ((SocketChannel) targetChannel).write(Charset.defaultCharset().encode(msg));\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n\n    public static void main(String[] args) throws IOException {\n        new NIOServer().start();\n    }\n}\n```\n\n**NIOClient**\n\n```java\npackage io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class NIOClient {\n    static class NIOClientHandler implements Runnable {\n        private final Selector selector;\n\n        public NIOClientHandler(Selector selector) {\n            this.selector = selector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    int readyChannels = selector.select(); // 获取可用channel数量\n                    if (readyChannels == 0) {\n                        continue;\n                    }\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                    while (iterator.hasNext()) {\n                        SelectionKey selectionKey = iterator.next();\n                        iterator.remove();\n                        if (selectionKey.isReadable()) {\n                            readHandler(selectionKey, selector);\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        private void readHandler(SelectionKey selectionKey, \n                                 Selector selector) throws IOException {\n            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n            // 读取服务器端响应数据\n            StringBuilder msg = new StringBuilder();\n            while (socketChannel.read(byteBuffer) > 0) {\n                byteBuffer.flip();\n                msg.append(Charset.defaultCharset().decode(byteBuffer));\n            }\n            // 将channel再次注册到selector上,监听它的可读事件\n            socketChannel.register(selector, SelectionKey.OP_READ);\n            if (msg.length() > 0) {\n                System.out.println(msg.toString());\n            }\n        }\n    }\n\n    public void start() throws IOException {\n        SocketChannel socketChannel = \n            SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 8848));\n        // 新开线程，专门接收服务器端发送的信息\n        Selector selector = Selector.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        new Thread(new NIOClientHandler(selector)).start();\n\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String msg = scanner.nextLine();\n            if (msg != null && msg.length() > 0) {\n                socketChannel.write(Charset.defaultCharset().encode(msg));\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        new NIOClient().start();\n    }\n}\n```\n\n\n\n## AIO\n\nAsynchronous I/O或NIO.2\n\n异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理\n\n**AIO**提供了从建立连接到读、写的全异步操作。**AIO**可用于异步的**文件读写**和**网络通信**。\n\n**Server**\n\n```java\npackage io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousServerSocketChannel;\nimport java.nio.channels.AsynchronousSocketChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.charset.Charset;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\npublic class AIOServer {\n    public static void main(String[] args) {\n        try {\n            final int port = 8848;\n            AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open();\n            serverSocketChannel.bind(new InetSocketAddress(port));\n            // 需要在handler的实现中处理连接请求和监听下一个连接、数据收发，以及通信异常。\n            // 消息处理回调接口，是一个负责消费异步IO操作结果的消息处理器\n            CompletionHandler<AsynchronousSocketChannel, Object> handler = new CompletionHandler<AsynchronousSocketChannel, Object>() {\n                /*\n                当I/O操作成功完成时，会回调到completed方法，failed方法则在I/O操作失败时被回调。\n                需要注意的是：在CompletionHandler的实现中应当及时处理操作结果，以避免一直占用调用线程而不能分发其他的CompletionHandler处理器。\n                 */\n                @Override\n                public void completed(AsynchronousSocketChannel result, Object attachment) {\n                    // 继续监听下一个连接请求\n                    serverSocketChannel.accept(attachment, this);\n                    try {\n                        System.out.println(\"接受了一个连接：\" + result.getRemoteAddress().toString());\n                        // result表示当前接受的客户端的连接会话，与客户端的通信都需要通过该连接会话进行。\n                        result.write(Charset.defaultCharset().encode(\"Server:Hello World\"));\n\n                        ByteBuffer readBuffer = ByteBuffer.allocate(128);\n                        result.read(readBuffer).get();\n                        System.out.println(new String(readBuffer.array()));\n                    } catch (IOException | InterruptedException | ExecutionException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n                @Override\n                public void failed(Throwable exc, Object attachment) {\n                    System.out.println(\"出错了：\" + exc.getMessage());\n                }\n            };\n            // 是一个异步方法，调用会直接返回,为了让子线程能够有时间处理监听客户端的连接会话，这里让主线程休眠一段时间\n            serverSocketChannel.accept(null, handler);\n            TimeUnit.MINUTES.sleep(Integer.MAX_VALUE);\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**Client**\n\n```java\npackage io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousSocketChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.charset.Charset;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\npublic class AIOClient {\n    public static void main(String[] args) {\n        try {\n            AsynchronousSocketChannel client = AsynchronousSocketChannel.open();\n            client.connect(new InetSocketAddress(\"127.0.0.1\", 8848), null, new CompletionHandler<Void, Object>() {\n                @Override\n                public void completed(Void result, Object attachment) {\n                    System.out.println(\"成功连接到服务器!\");\n                    try {\n                        client.write(Charset.defaultCharset().encode(\"Client:Hello World\"));\n                        ByteBuffer readBuffer = ByteBuffer.allocate(128);\n                        client.read(readBuffer).get();\n                        System.out.println(new String(readBuffer.array()));\n                    } catch (InterruptedException | ExecutionException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n                @Override\n                public void failed(Throwable exc, Object attachment) {\n                    exc.printStackTrace();\n                }\n            });\n            TimeUnit.MINUTES.sleep(Integer.MAX_VALUE);\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n","slug":"计算机基础/计算机网络/网络编程基础","published":1,"updated":"2021-06-08T03:35:00.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpnqq528004vz0tpcyck7auy","content":"<h1 id=\"基本套接字编程\"><a href=\"#基本套接字编程\" class=\"headerlink\" title=\"基本套接字编程\"></a>基本套接字编程</h1><h2 id=\"TCP原理\"><a href=\"#TCP原理\" class=\"headerlink\" title=\"TCP原理\"></a>TCP原理</h2><h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><ol>\n<li>服务器必须准备好接受外来的连接。通常是通过调用socket、bind和listen三个函数完成，此时为<strong>被动打开</strong></li>\n<li>客户通过调用connect发起<strong>主动打开</strong>，这导致客户端TCP发送一个SYN，告诉服务器自己的初始序列号（不带数据）。</li>\n<li>服务器必须确认（ACK）客户的SYN，同时自己也要发送一个SYN，含有服务器将在同一连接中发送数据的初始序列号。</li>\n<li>客户必须确认服务器的SYN</li>\n</ol>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165512924.png\" alt=\"image-20210603165512924\"></p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><ol>\n<li>某个应用进程（假设是客户端）首先调用close，执行<strong>主动关闭</strong>，于是发送一个FIN，表示数据发送完毕</li>\n<li>接收到这个FIN的对端（假设是服务器）执行<strong>被动关闭</strong>，给客户发送回ACK。FIN的接收意味着服务器端在相应连接上再无额外数据可接收</li>\n<li>一段时间后（这段时间内，服务器端仍然可以向客户端发送数据，称为半关闭状态），服务器端也将调用close关闭他的套接字，它会像客户端也发送一个FIN</li>\n<li>执行主动关闭的那端会发送ACK确认这个FIN</li>\n</ol>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165546769.png\" alt=\"image-20210603165546769\"></p>\n<h3 id=\"TCP状态转换图\"><a href=\"#TCP状态转换图\" class=\"headerlink\" title=\"TCP状态转换图\"></a>TCP状态转换图</h3><p>用粗实线表示客户状态转换，粗虚线表示服务器状态转换。</p>\n<p>接收表示该状态转换在接受到什么分节时发生，发送表示该状态转换会发送什么分节</p>\n<p>例子1 <strong>客户端建立连接</strong>：</p>\n<p>当某个应用程序在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED，这个状态通常是数据传送发生时的状态</p>\n<p>例子2 <strong>客户端、服务器断开连接</strong>：</p>\n<p>如果某个应用进程在接收到一个FIN之前调用close（主动关闭），则转换到FIN_WAIT_1状态</p>\n<p>但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN（被动关闭），那就转换到CLOSE_WAIT状态</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603170310342.png\" alt=\"image-20210603170310342\"></p>\n<p><strong>TIME_WAIT状态</strong></p>\n<p>执行主动关闭的那端会经历该状态，持续时间是2MSL（两倍的最长分节生命期，MSL是任何IP数据报能够在因特网中存活的最长时间）</p>\n<p>TIME_WAIT状态存在原因：</p>\n<ol>\n<li>可靠地实现TCP全双工连接的终止。假设最终的ACK丢失，服务器将重新发送它的最终FIN，所以客户端必须维护状态信息，以允许它重新发送最终的那个ACK</li>\n<li>允许老的重复分节在网络中消逝。假设关闭了一个TCP连接，过一段时间又在相同的IP地址和端口号之间建立另一个连接（称为前一个连接的化身，因为IP、端口号一样）。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再次出现。为做到这一点，TCP就不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT的持续时间的2MSL，就足以让某个方向上的分组最多存活MSL即被丢弃。通过该规则，就能保证每成功建立一个TCP连接，来自该连接先前化身的老的重复分组都已经在网络中消逝了。</li>\n</ol>\n<h3 id=\"完整流程\"><a href=\"#完整流程\" class=\"headerlink\" title=\"完整流程\"></a>完整流程</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603171012559.png\" alt=\"image-20210603171012559\"></p>\n<p>应用进程写数据到一个TCP套接字中时发生的步骤：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603185857129.png\" alt=\"image-20210603185857129\"></p>\n<p>每一个TCP套接字有一个发送缓冲区。当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区，如果该套接字的发送缓冲区容不下该应用进程的所有数据，该应用进程将置于休眠状态。内核将不从write系统调用返回，直到应用进程缓冲区中所有数据都复制到套接字发送缓冲区</p>\n<p>因此，从一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据。</p>\n<p>这一端的TCP提取套接字发送缓冲区中的数据并把它发送给对端TCP。对端TCP必须确认收到的数据，伴随来自对端的ACK的不断到达，本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止</p>\n<p>本端TCP以MSS大小的块把数据传递给IP，同时给每个数据块安上一个TCP首部已构成TCP分节，IP给每个TCP分节安上一个IP首部以构成IP数据报，并按照其目的IP地址查找路由表项以确定外出接口，然后把数据报传递给相应的数据链路。</p>\n<h2 id=\"简单案例\"><a href=\"#简单案例\" class=\"headerlink\" title=\"简单案例\"></a>简单案例</h2><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603191611037.png\" alt=\"image-20210603191611037\" style=\"zoom: 67%;\" />\n\n\n\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603203304963.png\" alt=\"image-20210603203304963\"></p>\n<p><strong>正常终止步骤</strong></p>\n<ol>\n<li>当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回</li>\n<li>当str_cli函数返回到客户的main函数时，main通过调用exit终止</li>\n<li>进程终止处理的部分工作是关闭所有打开的描述符，因此客户打开的套接字由内核关闭，这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应。至此，服务器套接字处于CLOSE_WAIT状态，客户套接字处于FIN_WAIT_2状态</li>\n<li>当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline返回0，这导致str_echo函数返回服务器子进程的main函数</li>\n<li>服务器子进程通过调用exit来终止</li>\n<li>服务器子进程中打开的所有描述符随之关闭，由子进程来关闭已连接套接字会引发TCP连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK。至此连接完全终止，客户端套接字进入TIME_WAIT状态</li>\n</ol>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span>    <span class=\"token string\">\"unp.h\"</span></span>\n\n<span class=\"token keyword\">int</span>\n<span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>argv<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span>                    sockfd<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> sockaddr_in    servaddr<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>argc <span class=\"token operator\">!=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">err_quit</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"usage: tcpcli &lt;IPaddress>\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建一个套接字，返回描述符</span>\n    sockfd <span class=\"token operator\">=</span> <span class=\"token function\">Socket</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> SOCK_STREAM<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 填入服务器的IP地址和端口号</span>\n    <span class=\"token function\">bzero</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>servaddr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>servaddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    servaddr<span class=\"token punctuation\">.</span>sin_family <span class=\"token operator\">=</span> AF_INET<span class=\"token punctuation\">;</span>\n    servaddr<span class=\"token punctuation\">.</span>sin_port <span class=\"token operator\">=</span> <span class=\"token function\">htons</span><span class=\"token punctuation\">(</span>SERV_PORT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Inet_pton</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>servaddr<span class=\"token punctuation\">.</span>sin_addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 和服务器建立TCP连接</span>\n    <span class=\"token function\">Connect</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>SA <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span>servaddr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>servaddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">str_cli</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stdin</span><span class=\"token punctuation\">,</span> sockfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 终止程序运行，Unix在进程终止时总是关闭该进程所有打开的描述符</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">str_cli</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>fp<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> sockfd<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span>    sendline<span class=\"token punctuation\">[</span>MAXLINE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> recvline<span class=\"token punctuation\">[</span>MAXLINE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Fgets</span><span class=\"token punctuation\">(</span>sendline<span class=\"token punctuation\">,</span> MAXLINE<span class=\"token punctuation\">,</span> fp<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token function\">Writen</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">,</span> sendline<span class=\"token punctuation\">,</span> <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>sendline<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Readline</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">,</span> recvline<span class=\"token punctuation\">,</span> MAXLINE<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">err_quit</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"str_cli: server terminated prematurely\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">Fputs</span><span class=\"token punctuation\">(</span>recvline<span class=\"token punctuation\">,</span> <span class=\"token constant\">stdout</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>客户调用st_cli函数，该函数将阻塞于fgets调用，因为我们还未输入任何数据。</p>\n<h3 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span>    <span class=\"token string\">\"unp.h\"</span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>argv<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span>                    listenfd<span class=\"token punctuation\">,</span> connfd<span class=\"token punctuation\">;</span>\n    pid_t                childpid<span class=\"token punctuation\">;</span>\n    socklen_t            clilen<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> sockaddr_in    cliaddr<span class=\"token punctuation\">,</span> servaddr<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建套接字</span>\n    listenfd <span class=\"token operator\">=</span> <span class=\"token function\">Socket</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> SOCK_STREAM<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">bzero</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>servaddr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>servaddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    servaddr<span class=\"token punctuation\">.</span>sin_family      <span class=\"token operator\">=</span> AF_INET<span class=\"token punctuation\">;</span>\n    servaddr<span class=\"token punctuation\">.</span>sin_addr<span class=\"token punctuation\">.</span>s_addr <span class=\"token operator\">=</span> <span class=\"token function\">htonl</span><span class=\"token punctuation\">(</span>INADDR_ANY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    servaddr<span class=\"token punctuation\">.</span>sin_port        <span class=\"token operator\">=</span> <span class=\"token function\">htons</span><span class=\"token punctuation\">(</span>SERV_PORT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 调用bind函数绑定端口号</span>\n    <span class=\"token function\">Bind</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>SA <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span>servaddr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>servaddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 把套接字转换成一个监听套接字，这样来自客户端的外来连接可以在该套接字由内核接收</span>\n    <span class=\"token function\">Listen</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">,</span> LISTENQ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        clilen <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>cliaddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 服务器进程在accept调用中被置于休眠状态，等待某个客户连接的到达并被内核接受</span>\n        <span class=\"token comment\" spellcheck=\"true\">// TCP使用三次握手来建立连接，握手完毕后accept返回。一个已连接描述符connfd</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 该描述符用于与新连接的那个客户通信</span>\n        <span class=\"token comment\" spellcheck=\"true\">// accept为每个连接到本服务器的客户返回一个新描述符</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 该服务器一次只能处理一个客户。如果多个客户连接同时到达，系统内核在某个最大数量的限制下把他们排入队列，然后每次返回一个给accept函数</span>\n        connfd <span class=\"token operator\">=</span> <span class=\"token function\">Accept</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>SA <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span>cliaddr<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>clilen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span>childpid <span class=\"token operator\">=</span> <span class=\"token function\">Fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    \n            <span class=\"token function\">Close</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n            <span class=\"token function\">str_echo</span><span class=\"token punctuation\">(</span>connfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n            <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 服务器调用close关闭与客户的连接，引发四次挥手操作。（当然这里引用计数不为0，实际close操作在子进程完成）</span>\n        <span class=\"token function\">Close</span><span class=\"token punctuation\">(</span>connfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            \n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">str_echo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sockfd<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ssize_t        n<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span>        buf<span class=\"token punctuation\">[</span>MAXLINE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    again<span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果客户关闭连接，那么接收到客户的FIN将导致服务器子进程的read函数返回0，将导致str_echo返回，从而终止子进程</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> MAXLINE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">Writen</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> errno <span class=\"token operator\">==</span> EINTR<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> again<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">err_sys</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"str_echo: read error\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>当服务器端accept函数返回时，服务器调用fork，再有子进程调用str_echo。该函数调用readline，readline调用read，而read在等待客户送入一行文本期间阻塞。</p>\n<p>另一方面，服务器父进程再次调用accept并阻塞，等待下一个客户连接。</p>\n<h3 id=\"并发服务器\"><a href=\"#并发服务器\" class=\"headerlink\" title=\"并发服务器\"></a>并发服务器</h3><p>主服务器循环通过派生一个子进程来处理每个新的连接</p>\n<p>当服务器接收并接受这个客户的连接，它fork一个自身的副本，让子进程来处理该客户的请求</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603172737267.png\" alt=\"image-20210603172737267\"></p>\n<p>TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点，它必须查看套接字对的所有四个元素才能确定由哪个端点接收某个到达的分节</p>\n<p>我们必须在服务器主机上区分监听套接字和已连接套接字。已连接套接字使用与监听套接字相同的本地端口（21）</p>\n<p>对于同一个本地端口（21）存在三个套接字：</p>\n<ul>\n<li>如果一个分节来自客户端端口1500，目的地为服务器端端口21，被传递到第一个子进程</li>\n<li>如果一个分节来自客户端端口1501，目的地为服务器端端口21，被传递到第二个子进程</li>\n<li>所有目的端口为21的其他TCP分节被传递给拥有监听套接字的那个最初服务器（父进程）</li>\n</ul>\n<p>是在同时有大量的客户连接到同一个服务器上时用于提供并发性的一种技术，每个客户连接都迫使服务器为他fork一个新的进程</p>\n<pre class=\" language-c\"><code class=\"language-c\">pid_t pid<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> listenfd<span class=\"token punctuation\">,</span> connfd<span class=\"token punctuation\">;</span>\nlistenfd <span class=\"token operator\">=</span> <span class=\"token function\">Socket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">Bind</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">Listen</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">,</span> backlog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    connfd <span class=\"token operator\">=</span> <span class=\"token function\">Accept</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 子进程进入if执行</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>pid <span class=\"token operator\">==</span> <span class=\"token function\">Fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">Close</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">processHandler</span><span class=\"token punctuation\">(</span>connfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 处理请求</span>\n        <span class=\"token function\">Close</span><span class=\"token punctuation\">(</span>connfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">Close</span><span class=\"token punctuation\">(</span>connfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户（提供已连接套接字connfd)，父进程则等待另一个连接（通过监听套接字listenfd)。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。</p>\n<p>对一个TCP套接字调用close会导致发送一个FIN，随后是正常的四次挥手，那么为什么父进程对connfd调用close没有终止它与客户的连接？因为每个文件或套接字都有一个引用计数（是当前打开着的引用该文件或套接字的描述符的个数）。套接字真正的清理和资源释放要等到引用计数值为0时才发生，即会在子进程也关闭connfd时发生。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200912778.png\" alt=\"image-20210603200912778\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200853359.png\" alt=\"image-20210603200853359\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200933250.png\" alt=\"image-20210603200933250\"></p>\n<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><h3 id=\"Socket函数\"><a href=\"#Socket函数\" class=\"headerlink\" title=\"Socket函数\"></a>Socket函数</h3><pre class=\" language-c#\"><code class=\"language-c#\">int socket(int family, in type, int protocol);</code></pre>\n<p>指定期望的通信协议类型（例如使用IPv4的TCP）</p>\n<p>socket函数在成功时返回一个小的非负整数值，与文件描述符类似，称为套接字描述符，简称sockfd</p>\n<h3 id=\"connect函数\"><a href=\"#connect函数\" class=\"headerlink\" title=\"connect函数\"></a>connect函数</h3><p>TCP客户用connect函数来建立与TCP服务器的连接</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sockfd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> sockaddr <span class=\"token operator\">*</span>servaddr<span class=\"token punctuation\">,</span> socklen_t addrlen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>sockfd是由socket函数返回的套接字描述符</p>\n<p>servaddr、addrlen是指向套接字地址结构的指针和该结构的大小（结构中含有服务器的IP地址和端口号）</p>\n<p>客户调用connect函数时不需要调用bind函数，因为如果需要，内核会确定源ip地址，并选择一个临时端口作为源端口</p>\n<p>如果是TCP套接字，调用connect函数将触发TCP的三次握手过程</p>\n<h3 id=\"bind函数\"><a href=\"#bind函数\" class=\"headerlink\" title=\"bind函数\"></a>bind函数</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sockfd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> sockaddr <span class=\"token operator\">*</span>myaddr<span class=\"token punctuation\">,</span> socklen_t addrlen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>myaddr、addrlen是指向套接字地址结构的指针和该结构的大小（可以指定要绑定的IP地址和端口号），如果要绑定IP地址，则该IP地址必须属于其所在主机的网络接口之一</p>\n<h3 id=\"listen函数\"><a href=\"#listen函数\" class=\"headerlink\" title=\"listen函数\"></a>listen函数</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sockfd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> backlog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>listen函数仅由TCP服务器调用，作用：</p>\n<ol>\n<li>当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是一个调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。即调用listen函数导致套接字从CLOSED状态转换成LISTEN状态</li>\n<li>本函数第二个参数规定内核应该为相应套接字排队的最大连接个数</li>\n</ol>\n<p>内核为任何一个给定的监听套接字维护两个队列：</p>\n<ol>\n<li><strong>未完成连接队列</strong>。每个这样的SYN分节对应其中的一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三次握手过程。这些套接字处于SYN_RCVD状态（在三次握手正常完成的前提下，未完成连接队列中的任何一项在其中的存留时间就是一个RTT)</li>\n<li><strong>已完成连接队列</strong>。每个已完成TCP三次握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态</li>\n</ol>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603193151337.png\" alt=\"image-20210603193151337\" style=\"zoom:67%;\" />\n\n<p>每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。</p>\n<p>当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项，然后响应三次握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK。这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器SYN的ACK）到达或该项超时为止。如果三次握手正常完成，该项就从未完成连接队列移动到已完成连接队列的队尾。当进程调用accept时，已完成连接队列中的队头项就返回给进程，或者如果该队列为空，那么进程将处于休眠状态，直到TCP在该队列中放入一项才唤醒他</p>\n<p>在三次握手完成之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为相应已连接套接字的接受缓冲区大小</p>\n<h3 id=\"accept函数\"><a href=\"#accept函数\" class=\"headerlink\" title=\"accept函数\"></a>accept函数</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sockfd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> sockaddr <span class=\"token operator\">*</span>cliaddr<span class=\"token punctuation\">,</span> socklen_t <span class=\"token operator\">*</span>addrlen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程置为休眠状态。</p>\n<p>如果accept成功。那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接</p>\n<p>称第一个参数为监听套接字描述符，返回值为已连接套接字描述符。一个服务器通常仅仅创建一个监听套接字，他在该服务器的生命周期内一直存在，内核为每个由服务器进程接受的客户连接创建一个已连接套接字（对于他的三次握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。</p>\n<h3 id=\"close函数\"><a href=\"#close函数\" class=\"headerlink\" title=\"close函数\"></a>close函数</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sockfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>关闭套接字，终止TCP连接</p>\n<p>默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的参数。</p>\n<p>然而TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接四次挥手</p>\n<h3 id=\"fork函数\"><a href=\"#fork函数\" class=\"headerlink\" title=\"fork函数\"></a>fork函数</h3><p>fork函数是Unix派生新进程的唯一方法</p>\n<pre class=\" language-c\"><code class=\"language-c\">pid_t <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 返回在子进程中为0，在父进程中为子进程ID，若出错为-1</span></code></pre>\n<p>调用fork函数一次，它返回两次：</p>\n<ol>\n<li>它在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID</li>\n<li>在子进程又返回一次，返回值是0</li>\n</ol>\n<p>因此返回值本身告知当前进程是父进程还是子进程</p>\n<p>父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享。如果父进程在调用accept之后调用fork，所接受的已连接套接字随后就在父进程和子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字</p>\n<p>fork函数典型用法：</p>\n<ol>\n<li>一个进程创建一个自身的副本，这样每个副本都可以在来一个副本执行其他任务的同时处理各自的某个操作，这是网络服务器的典型用法。</li>\n<li>一个进程想要执行另一个程序。该进程调用fork创建一个自身的副本，其中一个副本（子进程）调用exec把自身替换成新的程序。是shell等程序的典型用法。</li>\n</ol>\n<h1 id=\"IO模型\"><a href=\"#IO模型\" class=\"headerlink\" title=\"IO模型\"></a>IO模型</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>首先看看服务端处理网络请求的典型过程：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396ad36eda\" alt=\"服务端处理网络请求流程图\"></p>\n<p>可以看到，主要处理步骤包括：</p>\n<ul>\n<li>1、获取请求数据 客户端与服务器建立连接发出请求，服务器接受请求（1-3）</li>\n<li>2、构建响应 当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）</li>\n<li>3、返回数据 服务器将已构建好的响应再通过内核空间的网络I/O发还给客户端（5-7）</li>\n</ul>\n<p>输入操作通常包括两个不同的阶段：</p>\n<ol>\n<li>等待数据准备好</li>\n<li>从内核向进程复制数据</li>\n</ol>\n<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>\n<p><strong>UDP套接字编程</strong></p>\n<p>下面的IO模型拿UDP举例，因为数据准备好读取的概念比较简单：要么整个数据报已经收到，要么还没有。所以先简述UDP套接字编程</p>\n<p>客户不与服务器建立连接，而是只使用sendto函数给服务器发送数据报，其中必须指定目的地。类似的，服务器不接受来自客户的连接，而是只管调用recvfrom函数，等待来自某个客户的数据到达。recvfrom将与所接收的数据报一道返回客户的协议地址，因此服务器可以把响应发送给正确的客户。</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604183925749.png\" alt=\"image-20210604183925749\" style=\"zoom:67%;\" />\n\n<p><strong>阻塞和非阻塞</strong></p>\n<p>描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。阻塞调用会一直等待远程数据就绪再返回，直到读取结束。而非阻塞无论在什么情况下都会立即返回，虽然非阻塞大部分时间不会被block，但是它仍要求进程不断地去主动询问kernel是否准备好数据，也需要进程主动地再次调用recvfrom来将数据拷贝到用户内存。</p>\n<ul>\n<li>阻塞调用与非阻塞调用<ul>\n<li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回</li>\n<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程</li>\n</ul>\n</li>\n</ul>\n<p>两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。阻塞是指调用方一直在等待而且别的事情什么都不做。非阻塞是指调用方先去忙别的事情</p>\n<p><strong>同步和异步</strong></p>\n<p>描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</p>\n<ul>\n<li><p>同步处理与异步处理</p>\n<ul>\n<li>同步处理是指被调用方得到最终结果之后才返回给调用方</li>\n<li>异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方</li>\n</ul>\n<p>  <strong>阻塞、非阻塞的讨论对象是调用者</strong></p>\n<p>  <strong>同步、异步的讨论对象是被调用者</strong></p>\n</li>\n</ul>\n<h3 id=\"IO模型比较\"><a href=\"#IO模型比较\" class=\"headerlink\" title=\"IO模型比较\"></a>IO模型比较</h3><ul>\n<li>同步IO操作：导致请求进程阻塞，直到IO操作完成</li>\n<li>异步IO操作：不导致请求进程阻塞</li>\n</ul>\n<p>前四种同步IO模型的主要区别在第一阶段，因为他们第二阶段是一样的：在数据从内核复制到调用者缓冲区期间，进程阻塞与recvfrom调用。相反，异步IO模型在这两阶段都要处理</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae2b8fb2a\" alt=\"img\"></p>\n<p>阻塞式IO模型、非阻塞式IO模型、IO复用模型、信号驱动IO模型都是同步IO模型，因为其中真正的IO操作(recvfrom)将阻塞进程。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207165051430.png\" alt=\"image-20210207165051430\"></p>\n<h2 id=\"阻塞式IO模型\"><a href=\"#阻塞式IO模型\" class=\"headerlink\" title=\"阻塞式IO模型\"></a>阻塞式IO模型</h2><p>把recvfrom视为系统调用，因为要区分应用进程和内核。它一般都会从在应用进程空间中运行切换到在内核空间中运行，一段时间后再切换回来</p>\n<p>进程调用recvfrom，其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据报。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396a811072\" alt=\"阻塞式I/O模型\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207152811758.png\" alt=\"image-20210207152811758\"></p>\n<ul>\n<li><p>同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。</p>\n</li>\n<li><p>用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。</p>\n</li>\n<li><p>服务端采用单线程，当 accept 一个请求后，在read调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理完 ）（无法处理并发）</p>\n</li>\n<li><p>套接字的读写方法，默认是阻塞的。例如read方法要传递进去一个参数n，代表最多读取n个字节后再返回，如果一个字节都没有，则线程卡顿直到新的数据到来或连接关闭，read方法才能返回。</p>\n</li>\n<li><p>write方法一般不会阻塞，除非内核为套接字分配的写缓冲区满了，write方法才会阻塞，直到缓冲区中有空间空闲出来</p>\n</li>\n<li><p>即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p>\n</li>\n<li><p>阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作</p>\n</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>socket， buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"非阻塞式IO模型\"><a href=\"#非阻塞式IO模型\" class=\"headerlink\" title=\"非阻塞式IO模型\"></a>非阻塞式IO模型</h2><p>进程把一个套接字设置成非阻塞是通知内核：当所请求的IO操作需要把本进程阻塞时，不阻塞了，而是返回一个错误</p>\n<p>前三次调用recvfrom时没有数据可返回，因此内核立即返回一个RWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回。我们接着处理数据。</p>\n<p>当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，称为轮询。应用程序持续轮询内核，以查看某个操作是否就绪，往往会消耗大量的CPU时间</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396af89a4a\" alt=\"非阻塞式I/O模型\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153315652.png\" alt=\"image-20210207153315652\"></p>\n<ul>\n<li>由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</li>\n<li>非阻塞IO通常发生在一个for循环当中，因为每次进行IO操作时要么IO操作成功，要么当IO操作会阻塞时返回错误EWOULDBLOCK/EAGAIN，然后再根据需要进行下一次的for循环操作，这种类似轮询的方式会浪费很多不必要的CPU资源，是一种糟糕的设计。</li>\n<li>即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。</li>\n</ul>\n<pre><code>{\n    while(read(socket， buffer) != SUCCESS);\n    process(buffer);\n}</code></pre>\n<h2 id=\"IO复用模型\"><a href=\"#IO复用模型\" class=\"headerlink\" title=\"IO复用模型\"></a>IO复用模型</h2><p><strong>比喻</strong> 放了一堆鱼竿，在岸边一直守着这堆鱼竿，没有鱼上钩就玩手机</p>\n<p>例子：</p>\n<p>Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而  <strong>I/O 多路复用</strong> 就是为了解决这个问题而出现的。</p>\n<p>redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p>\n<ul>\n<li>优先选择时间复杂度为O(1)的IO复用函数作为底层实现，例如epoll</li>\n<li>以select系统调用为保底，时间复杂度O(N)</li>\n<li>基于react设计模式监听IO事件</li>\n</ul>\n<p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p>\n<p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p>\n<p><strong>原理</strong></p>\n<ul>\n<li>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。</li>\n<li>IO 多路复用实现一个线程可以监视多个文件句柄；</li>\n<li>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</li>\n<li>没有文件句柄就绪就会阻塞应用程序，交出CPU。</li>\n<li>多路是指网络连接，复用指的是同一个线程</li>\n<li>服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。</li>\n</ul>\n<p>多路网络连接复用一个io线程。</p>\n<p>单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。</p>\n<p>一种可以在单线程/进程中处理多个事件流的方法</p>\n<p>I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作</p>\n<p>进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个IO条件就绪（输入已经准备好或描述符已能承接更多的输出），它就通知进程。</p>\n<p>适用于：</p>\n<ul>\n<li>客户处理多个描述符（通常是交互式输入和网络套接字）</li>\n<li>TCP服务器既要处理监听套接字，又要处理已连接套接字</li>\n</ul>\n<p>select, poll, epoll 都是I/O多路复用的具体的实现</p>\n<p>阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的IO系统调用上。</p>\n<p>我们阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据复制到应用进程缓冲区。</p>\n<p>使用select的优势在于我们可以等待多个描述符就绪。</p>\n<p>服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396cc78d98\" alt=\"I/O复用模型\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153611203.png\" alt=\"image-20210207153611203\"></p>\n<p>用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</p>\n<p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在<strong>同一个线程内同时处理多个IO请求的目的</strong>。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//将socket添加到select监视中</span>\n<span class=\"token function\">select</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    sockets <span class=\"token operator\">=</span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>socket in sockets<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">can_read</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>socket， buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。</p>\n<p>IO多路复用模型使用了Reactor设计模式实现了这一机制。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154330581.png\" alt=\"image-20210207154330581\"></p>\n<p><strong>Reactor设计模式</strong></p>\n<p>EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154426634.png\" alt=\"image-20210207154426634\"></p>\n<p>通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</p>\n<p>用户线程使用IO多路复用模型的伪代码描述为：</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> UserEventHandler<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">handle_event</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">can_read</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>socket， buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。</span>\n<span class=\"token punctuation\">{</span>\n    Reactor<span class=\"token punctuation\">.</span><span class=\"token keyword\">register</span><span class=\"token punctuation\">(</span>new <span class=\"token function\">UserEventHandler</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Reactor中handle_events事件循环的伪代码大致如下。</p>\n<p>事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。</p>\n<pre class=\" language-c\"><code class=\"language-c\">Reactor<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">handle_events</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        sockets <span class=\"token operator\">=</span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>socket in sockets<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">get_event_handler</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">handle_event</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"信号驱动IO模型\"><a href=\"#信号驱动IO模型\" class=\"headerlink\" title=\"信号驱动IO模型\"></a>信号驱动IO模型</h2><p><strong>比喻</strong> 鱼竿上系了个铃铛，当铃铛响，就知道鱼上钩，然后可以专心玩手机</p>\n<p>信号驱动IO是利用信号机制，让内核告知应用程序文件描述符的相关事件。</p>\n<p>但信号驱动IO在网络编程的时候通常很少用到，因为在网络环境中，和socket相关的读写事件太多了，比如下面的事件都会导致SIGIO信号的产生：</p>\n<ol>\n<li>TCP连接建立</li>\n<li>一方断开TCP连接请求</li>\n<li>断开TCP连接请求完成</li>\n<li>TCP连接半关闭</li>\n<li>数据到达TCP socket</li>\n<li>数据已经发送出去(如：写buffer有空余空间)</li>\n</ol>\n<p>上面所有的这些都会产生SIGIO信号，但我们没办法在SIGIO对应的信号处理函数中区分上述不同的事件，SIGIO只应该在IO事件单一情况下使用，比如说用来监听端口的socket，因为只有客户端发起新连接的时候才会产生SIGIO信号。</p>\n<p>也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们</p>\n<p>首先开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用立即返回，我们进程继续工作，即没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。</p>\n<p>无论如何处理SIGIO信号，这种模型优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396ceccf52\" alt=\"信号驱动式I/O模型\"></p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>信号I/O在大量IO操作时可能会因为信号队列溢出导致没法通知</li>\n<li>信号驱动I/O尽管对于处理UDP套接字来说有用，即这种信号通知意味着到达一个数据报，或者返回一个异步错误。但是，对于TCP而言，信号驱动的I/O方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源，与前几种方式相比优势尽失</li>\n</ul>\n<h2 id=\"异步IO模型\"><a href=\"#异步IO模型\" class=\"headerlink\" title=\"异步IO模型\"></a>异步IO模型</h2><p>告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。</p>\n<p>与信号驱动模型的主要区别在于：信号驱动IO由内核通知我们何时可以启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成。</p>\n<p>我们调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。</p>\n<p>本例子中我们假设要求内核在操作完成时产生某个信号。该信号直到数据已复制到应用进程缓冲区才产生。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae253818f\" alt=\"异步I/O模型\"></p>\n<p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154623278.png\" alt=\"image-20210207154623278\"></p>\n<p>异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。</p>\n<p>目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。</p>\n<p>异步IO和信号驱动IO差不多，但它比信号驱动IO可以多做一步：相比信号驱动IO需要在程序中完成数据从用户态到内核态(或反方向)的拷贝，异    步IO可以把拷贝这一步也帮我们完成之后才通知应用程序。</p>\n<p>异步IO是完全完成了数据的拷贝之后才通知程序进行处理，没有阻塞的数据读写过程。</p>\n<p>这里面的读取操作的语义与上面的几种模型都不同。这里的读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。</p>\n<h1 id=\"select、poll、epoll函数\"><a href=\"#select、poll、epoll函数\" class=\"headerlink\" title=\"select、poll、epoll函数\"></a>select、poll、epoll函数</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"文件描述符\"><a href=\"#文件描述符\" class=\"headerlink\" title=\"文件描述符\"></a>文件描述符</h3><p>文件描述符是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>\n<h3 id=\"进程阻塞\"><a href=\"#进程阻塞\" class=\"headerlink\" title=\"进程阻塞\"></a>进程阻塞</h3><p> 正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得了CPU资源），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p>\n<h3 id=\"缓存I-O\"><a href=\"#缓存I-O\" class=\"headerlink\" title=\"缓存I/O\"></a>缓存I/O</h3><p> 缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>\n<p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p>\n<p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>\n<h2 id=\"select函数\"><a href=\"#select函数\" class=\"headerlink\" title=\"select函数\"></a>select函数</h2><h3 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。</p>\n<p>例子：我们可以调用select，告知内核仅在下列情况发生时才返回：</p>\n<ul>\n<li>集合{1，4，5}中的任何描述符准备好读；</li>\n<li>集合{2，7}中的任何描述符准备好写；</li>\n<li>集合{1，4}中的任何描述符有异常条件待处理；</li>\n<li>已经历10.2s</li>\n</ul>\n<p>也就是说，我们调用select告知内核对哪些描述符（就读、写或异常条件）感兴趣，以及等待多长时间。</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> maxfdp1<span class=\"token punctuation\">,</span> fd_set <span class=\"token operator\">*</span>readset<span class=\"token punctuation\">,</span> fd_set <span class=\"token operator\">*</span>writeset<span class=\"token punctuation\">,</span> fd_set <span class=\"token operator\">*</span>exceptset<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> timeval <span class=\"token operator\">*</span>timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>timeout告知内核等待所指定描述符中的任何一个就绪可花多长时间，可赋值为三种情况：</p>\n<ol>\n<li>永远等待下去：仅在有一个描述符准备好IO才返回。为此，我们把该参数设置为空指针。</li>\n<li>等待一段固定时间：在有一个描述符准备好IO才返回，但是不超过指定参数的时间。</li>\n<li>根本不等待：检查描述符后立即返回，这称为轮询。参数指定为0.</li>\n</ol>\n<p>fd_set可以理解为一个集合，这个集合中存放的是文件描述符，即文件句柄。readset、writeset、exceptset指定我们要让内核测试读、写和异常条件的描述符，如果对某一个条件不感兴趣，就可以把它设为空指针。</p>\n<p>maxfdp1参数指定待测试的描述符个数，它的值是待测试的最大描述符加1。</p>\n<p>当函数返回时，结果将指示哪些描述符已就绪。</p>\n<p>头文件&lt;sys/select.h&gt;中定义的FD_SETSIZE常量值是数据类型fd_set中的描述符总数（通常是1024）</p>\n<p>当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读。</p>\n<p>使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>\n<h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><ul>\n<li>这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于select可以监听多个socket，我们可以用它来处理多个连接。</li>\n<li>在select模型中每个socket一般都设置成non-blocking，虽然等待数据阶段仍然是阻塞状态，但是它是被select调用阻塞的，而不是直接被I/O阻塞的。select底层通过轮询机制来判断每个socket读写是否就绪。</li>\n<li>当然select也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了epoll作为select的改进版本。</li>\n<li>select、poll、epoll本质上也都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li>\n</ul>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>\n<ul>\n<li>使用事件轮询API的select函数，输入是read_fds &amp; write_fds；输出是与之对应的可读可写事件，同时还提供了timeout参数。</li>\n<li>如果期间没有任何事件到来，那么最多等待timeout的值的时间，线程处于阻塞状态。</li>\n<li>一旦其间有任何事件到来，就立即返回。时间过了之后还是没有任何事件，就立即返回。</li>\n<li>拿到事件后，线程可以继续挨个处理相应事件，处理完了继续轮询，于是线程就进入了一个死循环，我们称循环为时间循环，一个循环为一个周期。</li>\n</ul>\n<p><strong>select缺点</strong><br>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>\n<ul>\n<li>单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024 ;为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)</li>\n<li>每次调用 select，都需要把 fd_set集合从用户态拷贝到内核态，这个开销在 fd_set很多时会很大；需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</li>\n<li>对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发)。当套接字比较多的时候，每次select()都要通过遍历FD_SET中SIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</li>\n</ul>\n<h3 id=\"客户端程序\"><a href=\"#客户端程序\" class=\"headerlink\" title=\"客户端程序\"></a>客户端程序</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604193654363.png\" alt=\"image-20210604193654363\"></p>\n<p>8-13行：<strong>调用select</strong></p>\n<p>我们只需要一个用于检查可读性的描述符集。该集合由FD_ZERO初始化，并用FD_SET打开两位：一位对应于标准IO文件指针fp，一位对应于套接字sockfd。fileno函数把标准IO文件指针转换为对应的描述符。因为select函数只工作在描述符上。</p>\n<p>计算两个描述符中的较大者后，调用select。在该调用中，写集合指针和异常集合指针都是空指针。最后一个参数（时间限制）也是空指针，因为我们希望本调用阻塞到某个描述符就绪为止。</p>\n<p>14-18行：<strong>处理可读套接字</strong></p>\n<p>如果在select返回时套接字是可读的，就执行对应操作</p>\n<p>19-23行：<strong>处理可读输入</strong></p>\n<p>如果标准输入可读，就执行相应操作</p>\n<h3 id=\"服务器程序\"><a href=\"#服务器程序\" class=\"headerlink\" title=\"服务器程序\"></a>服务器程序</h3><p>把之前的案例重写为使用select来处理任意个客户的单进程程序。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604194813136.png\" alt=\"image-20210604194813136\"></p>\n<p>服务器只维护一个读描述符集，假设服务器是前台启动的，那么描述符0、1、2分别被置为标准输入、标准输出、标准错误输出。所以监听套接字的第一个可用描述符是3</p>\n<p>client数组中含有每个客户的已连接套接字描述符，初始化为-1</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195011425.png\" alt=\"image-20210604195011425\"></p>\n<p>当第一个客户与服务器建立连接时，监听描述符变为可读，我们的服务器于是调用accept</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195113032.png\" alt=\"image-20210604195113032\"></p>\n<p>我们的服务器必须在client数组中记住每个新的已连接描述符，并把他加到描述符集中去：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195226480.png\" alt=\"image-20210604195226480\"></p>\n<p>随后第二个客户与服务器建立连接：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195258834.png\" alt=\"image-20210604195258834\"></p>\n<p>接着假设第一个客户终止连接。该客户的TCP发生一个FIN，使得描述符4变得可读。当服务器读这个已连接套接字时，read将返回0。于是关闭该套接字并且把client[0]置为-1，把描述符集中描述符4的位设置位0</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195506423.png\" alt=\"image-20210604195506423\"></p>\n<p>总之，有客户到达时，我们在client数组中的第一个可用项（值为-1的项）中记录其已连接套接字的描述符。并且还必须把这个已连接描述符加到读描述符集中</p>\n<pre class=\" language-c\"><code class=\"language-c\">listenfd <span class=\"token operator\">=</span> <span class=\"token function\">Socket</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> SOCK_STREAM<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">Bind</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">Listen</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">,</span> LISTENQ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    nready <span class=\"token operator\">=</span> <span class=\"token function\">Select</span><span class=\"token punctuation\">(</span>maxfd<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>rset<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 处理新连接接入</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">FD_ISSET</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>rset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    \n        connfd <span class=\"token operator\">=</span> <span class=\"token function\">Accept</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 检查现有连接</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> maxi<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">FD_ISSET</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>rset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> <span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> MAXLINE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span>\n                <span class=\"token function\">Writen</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li><strong>创建监听套接字并调用select进行初始化</strong></li>\n<li><strong>阻塞于select</strong>：select等待某个事件发生：或是新连接建立，或是数据、FIN或RST到达</li>\n<li><strong>accept新的连接</strong>：如果监听套接字变为可读，则已建立一个新的连接。我们调用accept并更新相应的数据结构。</li>\n<li><strong>检查现有连接</strong>：对于每个现有的客户连接，我们要测试其描述符是否在select返回的描述集里。</li>\n</ul>\n<h2 id=\"poll函数\"><a href=\"#poll函数\" class=\"headerlink\" title=\"poll函数\"></a>poll函数</h2><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> pollfd <span class=\"token operator\">*</span>fdarray<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> nfds<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<ul>\n<li>fdarray是指向一个结构数组的指针，每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件。还是三种：处理输入的、处理输出的、处理错误的</li>\n<li>nfds指定了结构数组中元素的个数</li>\n<li>timeout指定poll函数返回前等待多长时间</li>\n<li>当发生错误时，poll函数返回值是-1、若定时器到时之前没有任何描述符就绪，则返回0、否则返回就绪描述符的个数（即revents成员值非0的描述符个数）</li>\n</ul>\n<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p>\n<p><strong>poll缺点</strong><br>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有缺点：</p>\n<ul>\n<li>每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；</li>\n<li>对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时）</li>\n</ul>\n<h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>argv<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    listenfd <span class=\"token operator\">=</span> <span class=\"token function\">Socket</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> SOCK_STREAM<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Bind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Listen</span><span class=\"token punctuation\">(</span>listenfd<span class=\"token punctuation\">,</span> LISTENQ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">struct</span> pollfd        client<span class=\"token punctuation\">[</span>OPEN_MAX<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    client<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>fd <span class=\"token operator\">=</span> listenfd<span class=\"token punctuation\">;</span>\n    client<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>events <span class=\"token operator\">=</span> POLLRDNORM<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> OPEN_MAX<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        client<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>fd <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>                        \n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        nready <span class=\"token operator\">=</span> <span class=\"token function\">Poll</span><span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">,</span> maxi<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> INFTIM<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 新连接</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>revents <span class=\"token operator\">&amp;</span> POLLRDNORM<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    \n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> OPEN_MAX<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>fd <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    client<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>fd <span class=\"token operator\">=</span> connfd<span class=\"token punctuation\">;</span>    \n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            client<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>events <span class=\"token operator\">=</span> POLLRDNORM<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 检查某个现有连接上的数据</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> maxi<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    \n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span>sockfd <span class=\"token operator\">=</span> client<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>fd<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>revents <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>POLLRDNORM <span class=\"token operator\">|</span> POLLERR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> MAXLINE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token function\">Close</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        client<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>fd <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 代表连接关闭</span>\n                    <span class=\"token function\">Close</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    client<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>fd <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">Writen</span><span class=\"token punctuation\">(</span>sockfd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>分配pollfd结构数组</li>\n<li>初始化。把client数组的第一项用于监听套接字，并把其余各项的描述符成员置为-1</li>\n<li>调用poll，检查新的连接。我们调用poll以等待新的连接或者现有连接上有数据可读。当一个新的连接被接受后，我们在client数组中查找第一个描述符成员为负的可用项。注意，从下标1开始搜索，因为client[0]固定用于监听套接字。</li>\n<li>检查某个现有连接上的数据。</li>\n</ul>\n<h2 id=\"epoll函数\"><a href=\"#epoll函数\" class=\"headerlink\" title=\"epoll函数\"></a>epoll函数</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</p>\n<p><strong>epoll的优点</strong></p>\n<ul>\n<li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</li>\n<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll；</li>\n<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li>\n</ul>\n<h3 id=\"了解\"><a href=\"#了解\" class=\"headerlink\" title=\"了解\"></a>了解</h3><p>epoll 全称 eventpoll，是 linux 内核实现IO多路复用（IO multiplexing）的一个实现。IO多路复用的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。</p>\n<p>epoll 监听的 fd（file descriptor）集合是常驻内核的，它有 3 个系统调用 （<em>epoll_create</em>, <em>epoll_wait</em>, <em>epoll_ctl</em>），通过 <em>epoll_wait</em> 可以多次监听同一个 fd 集合，只返回可读写那部分</p>\n<p>select 只有一个系统调用，每次要监听都要将其从用户态传到内核，有事件时返回整个集合。</p>\n<p>从性能上看，如果 fd 集合很大，用户态和内核态之间数据复制的花销是很大的，所以 select 一般限制 fd 集合最大1024。</p>\n<p>从使用上看，epoll 返回的是可用的 fd 子集，select 返回的是全部，哪些可用需要用户遍历判断。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20140911103834_133.jpg\"></p>\n<p>设想一个场景：有100万用户同时与一个进程保持着TCP连接，而每一时刻只有几十个或几百个TCP连接是活跃的(接收TCP包)，也就是说在每一时刻进程只需要处理这100万连接中的一小部分连接。那么，如何才能高效的处理这种场景呢？进程是否在每次询问操作系统收集有事件发生的TCP连接时，把这100万个连接告诉操作系统，然后由操作系统找出其中有事件发生的几百个连接呢？实际上，在Linux2.4版本以前，那时的select或者poll事件驱动方式是这样做的。</p>\n<p>  这里有个非常明显的问题，即在某一时刻，进程收集有事件的连接时，其实这100万连接中的大部分都是没有事件发生的。因此如果每次收集事件时，都把100万连接的套接字传给操作系统(这首先是用户态内存到内核态内存的大量复制)，而由操作系统内核寻找这些连接上有没有未处理的事件，将会是巨大的资源浪费，然后select和poll就是这样做的，因此它们最多只能处理几千个并发连接。而epoll不这样做，它在Linux内核中申请了一个简易的文件系统，把原先的一个select或poll调用分成了3部分：</p>\n<pre class=\" language-c++\"><code class=\"language-c++\">int epoll_create(int size);  \nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  \nint epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);  </code></pre>\n<ol>\n<li><p>调用epoll_create建立一个epoll对象(在epoll文件系统中给这个句柄分配资源)；</p>\n</li>\n<li><p>调用epoll_ctl向epoll对象中添加这100万个连接的套接字；</p>\n</li>\n<li><p>调用epoll_wait收集发生事件的连接。</p>\n</li>\n</ol>\n<p>  这样只需要在进程启动时建立1个epoll对象，并在需要的时候向它添加或删除连接就可以了，因此，在实际收集事件时，epoll_wait的效率就会非常高，因为调用epoll_wait时并没有向它传递这100万个连接，内核也不需要去遍历全部的连接。</p>\n<h3 id=\"epoll-create\"><a href=\"#epoll-create\" class=\"headerlink\" title=\"epoll_create\"></a>epoll_create</h3><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关，如下所示：</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> eventpoll <span class=\"token punctuation\">{</span>\n　　<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n　　<span class=\"token comment\" spellcheck=\"true\">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，\n　　也就是这个epoll监控的事件*/</span>\n　　<span class=\"token keyword\">struct</span> rb_root rbr<span class=\"token punctuation\">;</span>\n　　<span class=\"token comment\" spellcheck=\"true\">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span>\n　　<span class=\"token keyword\">struct</span> list_head rdllist<span class=\"token punctuation\">;</span>\n　　<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个rdllist双向链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</p>\n<p>  所有添加到epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的rdllist双向链表中。<br>在epoll中对于每一个事件都会建立一个epitem结构体，如下所示：</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> epitem <span class=\"token punctuation\">{</span>\n　　<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n　　<span class=\"token comment\" spellcheck=\"true\">//红黑树节点</span>\n　　<span class=\"token keyword\">struct</span> rb_node rbn<span class=\"token punctuation\">;</span>\n　　<span class=\"token comment\" spellcheck=\"true\">//双向链表节点</span>\n　　<span class=\"token keyword\">struct</span> list_head rdllink<span class=\"token punctuation\">;</span>\n　　<span class=\"token comment\" spellcheck=\"true\">//事件句柄等信息</span>\n　　<span class=\"token keyword\">struct</span> epoll_filefd ffd<span class=\"token punctuation\">;</span>\n　　<span class=\"token comment\" spellcheck=\"true\">//指向其所属的eventepoll对象</span>\n　　<span class=\"token keyword\">struct</span> eventpoll <span class=\"token operator\">*</span>ep<span class=\"token punctuation\">;</span>\n　　<span class=\"token comment\" spellcheck=\"true\">//期待的事件类型</span>\n　　<span class=\"token keyword\">struct</span> epoll_event event<span class=\"token punctuation\">;</span>\n　　<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 这里包含每一个事件对应着的信息。</span></code></pre>\n<p>当调用epoll_wait检查是否有发生事件的连接时，只是检查eventpoll对象中的rdllist双向链表是否有epitem元素而已，如果rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx效率非常高。epoll_ctl在向epoll对象中添加、修改、删除事件时，从rbr红黑树中查找事件也非常快，也就是说epoll是非常高效的，它可以轻易地处理百万级别的并发连接。</p>\n<h3 id=\"原理总结\"><a href=\"#原理总结\" class=\"headerlink\" title=\"原理总结\"></a>原理总结</h3><ul>\n<li><p>一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。</p>\n</li>\n<li><p>执行epoll_create()时，创建了红黑树和就绪链表；</p>\n</li>\n<li><p>执行epoll_ctl()时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；</p>\n</li>\n<li><p>执行epoll_wait()时立刻返回准备就绪链表里的数据即可。</p>\n</li>\n</ul>\n<h1 id=\"JAVA-IO\"><a href=\"#JAVA-IO\" class=\"headerlink\" title=\"JAVA IO\"></a>JAVA IO</h1><h2 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h2><h3 id=\"概述-3\"><a href=\"#概述-3\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>BIO是一个同步并阻塞的IO模式，<strong>传统的  java.io 包</strong>，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如<strong>File抽象、输入输出流</strong>等。<strong>交互方式是同步、阻塞的方式</strong>，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1890419bbba44f29b0f71f5598c5e111~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\"></p>\n<p>blocking I/O。同步阻塞模型</p>\n<p>由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行处理。</p>\n<p>每个线程都需要创建独立的线程，当并发量大时，需要创建大量线程来处理连接，系统资源占用大</p>\n<p>代码中的read操作是阻塞操作，如果连接之后，服务端一直不发送数据，将会一直阻塞当前线程，浪费资源。</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603081447596.png\" alt=\"image-20210603081447596\" style=\"zoom: 67%;\" />\n\n<h3 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h3><p>当服务器进程运行时, 可能会同时监听到多个客户的连接请求。</p>\n<p>每当一个客户进程执行以下代码：</p>\n<pre class=\" language-java\"><code class=\"language-java\">Socket client <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Socket</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8848</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>就意味着在远程主机的 8848 端口上, 监听到了一个客户的连接请求。管理客户连接请求的任务是由操作系统来完成的。操作系统把这些连接请求存储在一个先进先出的队列中。当队列中的连接请求达到了队列的最大容量时, 服务器进程所在的主机会拒绝新的连接请求。只有当服务器进程通过 ServerSocket 的 accept() 方法从队列中取出连接请求, 使队列腾出空位时，队列才能继续加入新的连接请求。</p>\n<p> 对于客户进程, 如果它发出的连接请求被加入到服务器的请求连接队列中, 就意味着客户与服务器的连接建立成功, 客户进程从 Socket 构造方法中正常返回。</p>\n<p>当客户进程的 Socket构造方法返回成功, 表示客户进程的连接请求被加入到服务器进程的请求连接队列中。 虽然客户端成功返回 Socket对象， 但是还没跟服务器进程形成一条通信线路。必须在服务器进程通过 ServerSocket 的 accept() 方法从请求连接队列中取出连接请求，并返回一个Socket 对象后，服务器进程这个Socket 对象才与客户端的 Socket 对象形成一条通信线路。</p>\n<p>ServerSocket 的 accept() 方法从连接请求队列中取出一个客户的连接请求，然后创建与客户连接的 Socket 对象, 并将它返回。如果队列中没有连接请求，accept() 方法就会一直等待，直到接收到了连接请求才返回。</p>\n<p> 接下来，服务器从 Socket 对象中获得输入流和输出流，就能与客户交换数据。</p>\n<p>服务器的主线程负责接收客户的连接, 每次接收到一个客户连接, 就会创建一个工作线程, 由它负责与客户的通信</p>\n<h3 id=\"示例程序\"><a href=\"#示例程序\" class=\"headerlink\" title=\"示例程序\"></a>示例程序</h3><p><strong>Server</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BIOServer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        ServerSocket serverSocket <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServerSocket</span><span class=\"token punctuation\">(</span><span class=\"token number\">8848</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 线程在accept调用时处于休眠状态，等待某个客户连接到达并被内核接受</span>\n            Socket socket <span class=\"token operator\">=</span> serverSocket<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>Socket socket<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        InputStream inputStream <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            inputStream <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">.</span><span class=\"token function\">getInputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> read<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>read <span class=\"token operator\">=</span> inputStream<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> read<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>inputStream <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    inputStream<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>Client</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BIOClient</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        Socket client <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Socket</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8848</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        OutputStream outputStream <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">getOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        String msg <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello Server!\"</span><span class=\"token punctuation\">;</span>\n        outputStream<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span>StandardCharsets<span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        client<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><h3 id=\"IO操作\"><a href=\"#IO操作\" class=\"headerlink\" title=\"IO操作\"></a>IO操作</h3><p>应用程序的IO操作实际上不是物理设备级别的读写，而是缓存的复制。read和write两大系统调用都不负责数据在内核缓冲区和物理设备（如磁盘、网卡等）之间的交换。这个底层的读写交换操作是由操作系统内核（Kernel）来完成的。</p>\n<p>外部设备的直接读写涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少底层系统的频繁中断所导致的时间损耗、性能损耗，出现了内核缓冲区。操作系统会对内核缓冲区进行监控，等待缓冲区达到一定数量的时候，再进行IO设备的中断处理，集中执行物理设备的实际IO操作，通过这种机制来提升系统的性能。</p>\n<p>上层应用使用read系统调用时，仅仅把数据从内核缓冲区复制到应用的缓冲区（进程缓冲区）；上层应用使用write系统调用时，仅仅把数据从应用的缓冲区复制到内核缓冲区。在大多数情况下，Linux系统中用户程序的IO读写程序并没有进行实际的IO操作，而是在用户缓冲区和内核缓冲区之间直接进行数据的交换。</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605150414935.png\" alt=\"image-20210605150414935\" style=\"zoom: 67%;\" />\n\n<p>一个完整输入流程的两个阶段：<br>•应用程序等待数据准备好：第一个阶段，应用程序等待数据通过网络到达网卡，当所等待的分组到达时，数据被操作系统复制到内核缓冲区中。这个工作由操作系统自动完成，用户程序无感知。<br>•从内核缓冲区向用户缓冲区复制数据：第二个阶段，内核将数据从内核缓冲区复制到应用的用户缓冲区。</p>\n<h3 id=\"IO多路复用模型\"><a href=\"#IO多路复用模型\" class=\"headerlink\" title=\"IO多路复用模型\"></a>IO多路复用模型</h3><p>select/epoll系统调用。通过该系统调用，一个用户进程（或者线程）可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核就能够将文件描述符的就绪状态返回给用户进程（或者线程），用户空间可以根据文件描述符的就绪状态进行相应的IO系统调用。<br>IO多路复用（IO Multiplexing）属于一种经典的Reactor模式实现，有时也称为异步阻塞IO，Java中的Selector属于这种模型。</p>\n<p>在IO多路复用模型中通过select/epoll系统调用，单个应用程序的线程可以不断地轮询成百上千的socket连接的就绪状态，当某个或者某些socket网络连接有IO就绪状态时就返回这些就绪的状态（或者说就绪事件）。</p>\n<p>（1）选择器注册。首先，将需要read操作的目标文件描述符（socket连接）提前注册到Linux的select/epoll选择器中，在Java中所对应的选择器类是Selector类。然后，开启整个IO多路复用模型的轮询流程。</p>\n<p>（2）就绪状态的轮询。通过选择器的查询方法，查询所有提前注册过的目标文件描述符（socket连接）的IO就绪状态。通过查询的系统调用，内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好或者就绪了就说明内核缓冲区有数据了，内核将该socket加入就绪的列表中，并且返回就绪事件。</p>\n<p>（3）用户线程获得了就绪状态的列表后，根据其中的socket连接发起read系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区。</p>\n<p>（4）复制完成后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605151630414.png\" alt=\"image-20210605151630414\"></p>\n<p>通过JDK的源码可以看出，Java语言的NIO组件在Linux系统上是使用epoll系统调用实现的。所以，Java语言的NIO组件所使用的就是IO多路复用模型。</p>\n<p>IO多路复用模型的缺点是，本质上select/epoll系统调用是阻塞式的，属于同步IO，需要在读写事件就绪后由系统调用本身负责读写，也就是说这个读写过程是阻塞的。要彻底地解除线程的阻塞，就必须使用异步IO模型。</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/f1c9e5d2b37d489e959ccd2d7573a713~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\"></p>\n<p>non-blocking I/O或New IO</p>\n<p>同步非阻塞，服务端可以开启一个线程处理多个连接，它是非阻塞的，客户端发送的数据都会注册到多路复用器selector上面，当selector（selector的select方法是阻塞的）轮询到有读、写或者连接请求时，才会转发到后端程序进行处理，没有数据的时候，业务程序并不需要阻塞等待。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603090056517.png\" alt=\"image-20210603090056517\"></p>\n<h3 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h3><ul>\n<li>类比于IO流，但是具有双向性，既可读，又可写</li>\n<li>ServerSocketChannel用来监听客户端连接请求并创建SocketChannel与客户端进行通信</li>\n<li>只能通过Buffer读写Channel中数据</li>\n</ul>\n<h3 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h3><p>本质上是一块内存区域</p>\n<p><strong>字段</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> mark <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 存储特定position位置，后续通过reset恢复到该位置，依然可以读取这里的数据</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> position <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 读写操作时的索引下标，最大为capacity-1;写模式切换到读模式时，会变为0</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> limit<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 写模式下等于capacity，切换到读模式时，limit表示最多能从buffer中读取多少，等于写模式下的position</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 容量，标识最大能容纳多少字节</span></code></pre>\n<p><strong>API实例</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\">ByteBuffer byteBuffer <span class=\"token operator\">=</span> ByteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// position = 0,limit = 10,capacity=10</span>\nbyteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"aaa\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// position = 3, limit = 10, capacity = 10</span>\nbyteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">flip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 从写模式切换到读模式 position = 0, limit = 3, capacity = 10</span>\nbyteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// position = 1, limit = 3, capacity = 10</span>\nbyteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">mark</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// mark = 1, position = 1, limit = 3, capacity = 10</span>\nbyteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// mark = 1, position = 2, limit = 3, capacity = 10</span>\nbyteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// mark = 1, position = 1, limit = 3, capacity = 10</span>\nbyteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 所有属性重置 position = 0, limit = 10, capacity = 10</span></code></pre>\n<p>使用Java NIO Buffer类的基本步骤如下：<br>（1）使用创建子类实例对象的allocate()方法创建一个Buffer类的实例对象。<br>（2）调用put()方法将数据写入缓冲区中。<br>（3）写入完成后，在开始读取数据前调用Buffer.flip()方法，将缓冲区转换为读模式。<br>（4）调用get()方法，可以从缓冲区中读取数据。<br>（5）读取完成后，调用Buffer.clear()方法或Buffer.compact()方法，将缓冲区转换为写模式，可以继续写入。</p>\n<h3 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h3><p><strong>选择器</strong> /<strong>多路复用器</strong>。用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels，也就是可以管理多个网络连接。</p>\n<h3 id=\"示例程序-1\"><a href=\"#示例程序-1\" class=\"headerlink\" title=\"示例程序\"></a>示例程序</h3><p><strong>NIOServer</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> io<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span>IOException<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span>InetSocketAddress<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>ByteBuffer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>*<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>charset<span class=\"token punctuation\">.</span>Charset<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Iterator<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Set<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NIOServer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        Selector selector <span class=\"token operator\">=</span> Selector<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ServerSocketChannel serverSocketChannel <span class=\"token operator\">=</span> ServerSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InetSocketAddress</span><span class=\"token punctuation\">(</span><span class=\"token number\">8848</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> SelectionKey<span class=\"token punctuation\">.</span>OP_ACCEPT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> readyChannels <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 获取可用channel数量</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>readyChannels <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            Set<span class=\"token operator\">&lt;</span>SelectionKey<span class=\"token operator\">></span> selectionKeys <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">selectedKeys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Iterator<span class=\"token operator\">&lt;</span>SelectionKey<span class=\"token operator\">></span> iterator <span class=\"token operator\">=</span> selectionKeys<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                SelectionKey selectionKey <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                iterator<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>selectionKey<span class=\"token punctuation\">.</span><span class=\"token function\">isReadable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">readHandler</span><span class=\"token punctuation\">(</span>selectionKey<span class=\"token punctuation\">,</span> selector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>selectionKey<span class=\"token punctuation\">.</span><span class=\"token function\">isAcceptable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">acceptHandler</span><span class=\"token punctuation\">(</span>serverSocketChannel<span class=\"token punctuation\">,</span> selector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">acceptHandler</span><span class=\"token punctuation\">(</span>ServerSocketChannel serverSocketChannel<span class=\"token punctuation\">,</span> \n                               Selector selector<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        SocketChannel socketChannel <span class=\"token operator\">=</span> serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> SelectionKey<span class=\"token punctuation\">.</span>OP_READ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// encode返回的是ByteBuffer</span>\n        socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>Charset<span class=\"token punctuation\">.</span><span class=\"token function\">defaultCharset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"成功连上了服务器!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">readHandler</span><span class=\"token punctuation\">(</span>SelectionKey selectionKey<span class=\"token punctuation\">,</span> \n                             Selector selector<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        SocketChannel socketChannel <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>SocketChannel<span class=\"token punctuation\">)</span> selectionKey<span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ByteBuffer byteBuffer <span class=\"token operator\">=</span> ByteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 读取客户端数据</span>\n        StringBuilder msg <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>byteBuffer<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            byteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">flip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            msg<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>Charset<span class=\"token punctuation\">.</span><span class=\"token function\">defaultCharset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>byteBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 将channel再次注册到selector上,监听它的可读事件</span>\n        socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> SelectionKey<span class=\"token punctuation\">.</span>OP_READ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">broadCast</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> socketChannel<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">broadCast</span><span class=\"token punctuation\">(</span>Selector selector<span class=\"token punctuation\">,</span> SocketChannel sourceChannel<span class=\"token punctuation\">,</span> String msg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 获取所有已接入客户端channel</span>\n        Set<span class=\"token operator\">&lt;</span>SelectionKey<span class=\"token operator\">></span> selectionKeys <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        selectionKeys<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>selectionKey <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            Channel targetChannel <span class=\"token operator\">=</span> selectionKey<span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 剔除发消息的那个channel</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>targetChannel <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">SocketChannel</span> \n                <span class=\"token operator\">&amp;&amp;</span> targetChannel <span class=\"token operator\">!=</span> sourceChannel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 向所有channel广播信息</span>\n                    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>SocketChannel<span class=\"token punctuation\">)</span> targetChannel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>Charset<span class=\"token punctuation\">.</span><span class=\"token function\">defaultCharset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">NIOServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>NIOClient</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> io<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span>IOException<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span>InetSocketAddress<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>ByteBuffer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>SelectionKey<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>Selector<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>SocketChannel<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>charset<span class=\"token punctuation\">.</span>Charset<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Iterator<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Scanner<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Set<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NIOClient</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NIOClientHandler</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Selector selector<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token function\">NIOClientHandler</span><span class=\"token punctuation\">(</span>Selector selector<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>selector <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">int</span> readyChannels <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 获取可用channel数量</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>readyChannels <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    Set<span class=\"token operator\">&lt;</span>SelectionKey<span class=\"token operator\">></span> selectionKeys <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">selectedKeys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    Iterator<span class=\"token operator\">&lt;</span>SelectionKey<span class=\"token operator\">></span> iterator <span class=\"token operator\">=</span> selectionKeys<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        SelectionKey selectionKey <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        iterator<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>selectionKey<span class=\"token punctuation\">.</span><span class=\"token function\">isReadable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            <span class=\"token function\">readHandler</span><span class=\"token punctuation\">(</span>selectionKey<span class=\"token punctuation\">,</span> selector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">readHandler</span><span class=\"token punctuation\">(</span>SelectionKey selectionKey<span class=\"token punctuation\">,</span> \n                                 Selector selector<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n            SocketChannel socketChannel <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>SocketChannel<span class=\"token punctuation\">)</span> selectionKey<span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            ByteBuffer byteBuffer <span class=\"token operator\">=</span> ByteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 读取服务器端响应数据</span>\n            StringBuilder msg <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>byteBuffer<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                byteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">flip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                msg<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>Charset<span class=\"token punctuation\">.</span><span class=\"token function\">defaultCharset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>byteBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 将channel再次注册到selector上,监听它的可读事件</span>\n            socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> SelectionKey<span class=\"token punctuation\">.</span>OP_READ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        SocketChannel socketChannel <span class=\"token operator\">=</span> \n            SocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InetSocketAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8848</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 新开线程，专门接收服务器端发送的信息</span>\n        Selector selector <span class=\"token operator\">=</span> Selector<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> SelectionKey<span class=\"token punctuation\">.</span>OP_READ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">NIOClientHandler</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        Scanner scanner <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Scanner</span><span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>scanner<span class=\"token punctuation\">.</span><span class=\"token function\">hasNextLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            String msg <span class=\"token operator\">=</span> scanner<span class=\"token punctuation\">.</span><span class=\"token function\">nextLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msg <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> msg<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>Charset<span class=\"token punctuation\">.</span><span class=\"token function\">defaultCharset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">NIOClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"AIO\"><a href=\"#AIO\" class=\"headerlink\" title=\"AIO\"></a>AIO</h2><p>Asynchronous I/O或NIO.2</p>\n<p>异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</p>\n<p><strong>AIO</strong>提供了从建立连接到读、写的全异步操作。<strong>AIO</strong>可用于异步的<strong>文件读写</strong>和<strong>网络通信</strong>。</p>\n<p><strong>Server</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> io<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span>IOException<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span>InetSocketAddress<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>ByteBuffer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>AsynchronousServerSocketChannel<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>AsynchronousSocketChannel<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>CompletionHandler<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>charset<span class=\"token punctuation\">.</span>Charset<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>ExecutionException<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AIOServer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> port <span class=\"token operator\">=</span> <span class=\"token number\">8848</span><span class=\"token punctuation\">;</span>\n            AsynchronousServerSocketChannel serverSocketChannel <span class=\"token operator\">=</span> AsynchronousServerSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InetSocketAddress</span><span class=\"token punctuation\">(</span>port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 需要在handler的实现中处理连接请求和监听下一个连接、数据收发，以及通信异常。</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 消息处理回调接口，是一个负责消费异步IO操作结果的消息处理器</span>\n            CompletionHandler<span class=\"token operator\">&lt;</span>AsynchronousSocketChannel<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span> handler <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CompletionHandler</span><span class=\"token operator\">&lt;</span>AsynchronousSocketChannel<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">/*\n                当I/O操作成功完成时，会回调到completed方法，failed方法则在I/O操作失败时被回调。\n                需要注意的是：在CompletionHandler的实现中应当及时处理操作结果，以避免一直占用调用线程而不能分发其他的CompletionHandler处理器。\n                 */</span>\n                <span class=\"token annotation punctuation\">@Override</span>\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">completed</span><span class=\"token punctuation\">(</span>AsynchronousSocketChannel result<span class=\"token punctuation\">,</span> Object attachment<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 继续监听下一个连接请求</span>\n                    serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span>attachment<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"接受了一个连接：\"</span> <span class=\"token operator\">+</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">getRemoteAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token comment\" spellcheck=\"true\">// result表示当前接受的客户端的连接会话，与客户端的通信都需要通过该连接会话进行。</span>\n                        result<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>Charset<span class=\"token punctuation\">.</span><span class=\"token function\">defaultCharset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Server:Hello World\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                        ByteBuffer readBuffer <span class=\"token operator\">=</span> ByteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">128</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        result<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>readBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>readBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> <span class=\"token operator\">|</span> InterruptedException <span class=\"token operator\">|</span> ExecutionException e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n\n                <span class=\"token annotation punctuation\">@Override</span>\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">failed</span><span class=\"token punctuation\">(</span>Throwable exc<span class=\"token punctuation\">,</span> Object attachment<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"出错了：\"</span> <span class=\"token operator\">+</span> exc<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 是一个异步方法，调用会直接返回,为了让子线程能够有时间处理监听客户端的连接会话，这里让主线程休眠一段时间</span>\n            serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TimeUnit<span class=\"token punctuation\">.</span>MINUTES<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>Integer<span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> <span class=\"token operator\">|</span> InterruptedException e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>Client</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> io<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span>IOException<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span>InetSocketAddress<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>ByteBuffer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>AsynchronousSocketChannel<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>CompletionHandler<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>charset<span class=\"token punctuation\">.</span>Charset<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>ExecutionException<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AIOClient</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            AsynchronousSocketChannel client <span class=\"token operator\">=</span> AsynchronousSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            client<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InetSocketAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8848</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CompletionHandler</span><span class=\"token operator\">&lt;</span>Void<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token annotation punctuation\">@Override</span>\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">completed</span><span class=\"token punctuation\">(</span>Void result<span class=\"token punctuation\">,</span> Object attachment<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"成功连接到服务器!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                        client<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>Charset<span class=\"token punctuation\">.</span><span class=\"token function\">defaultCharset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Client:Hello World\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        ByteBuffer readBuffer <span class=\"token operator\">=</span> ByteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">128</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        client<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>readBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>readBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> <span class=\"token operator\">|</span> ExecutionException e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n\n                <span class=\"token annotation punctuation\">@Override</span>\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">failed</span><span class=\"token punctuation\">(</span>Throwable exc<span class=\"token punctuation\">,</span> Object attachment<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    exc<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TimeUnit<span class=\"token punctuation\">.</span>MINUTES<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>Integer<span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> <span class=\"token operator\">|</span> InterruptedException e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/-3ebaf4c753be976f.jpg","name":"tongji4m3","introduction":"种一棵树最好的时间是十年前，其次是现在。","url":"https://github.com/tongji4m3","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/f_f_object_156_s512_f_object_156_0bg.png","name":"icedance","introduction":"只要面对现实,你就能超越现实。","url":"https://github.com/icedancemelody","title":"前去学习"},{"avatar":"https://tongji4m3.oss-cn-beijing.aliyuncs.com/moshuaihaozhe.png","name":"wenjunBZ","introduction":"真正的强者，不是流泪的人，而是含泪奔跑的人。","url":"https://github.com/wenjunBZ","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"基本套接字编程\"><a href=\"#基本套接字编程\" class=\"headerlink\" title=\"基本套接字编程\"></a>基本套接字编程</h1><h2 id=\"TCP原理\"><a href=\"#TCP原理\" class=\"headerlink\" title=\"TCP原理\"></a>TCP原理</h2><h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><ol>\n<li>服务器必须准备好接受外来的连接。通常是通过调用socket、bind和listen三个函数完成，此时为<strong>被动打开</strong></li>\n<li>客户通过调用connect发起<strong>主动打开</strong>，这导致客户端TCP发送一个SYN，告诉服务器自己的初始序列号（不带数据）。</li>\n<li>服务器必须确认（ACK）客户的SYN，同时自己也要发送一个SYN，含有服务器将在同一连接中发送数据的初始序列号。</li>\n<li>客户必须确认服务器的SYN</li>\n</ol>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165512924.png\" alt=\"image-20210603165512924\"></p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><ol>\n<li>某个应用进程（假设是客户端）首先调用close，执行<strong>主动关闭</strong>，于是发送一个FIN，表示数据发送完毕</li>\n<li>接收到这个FIN的对端（假设是服务器）执行<strong>被动关闭</strong>，给客户发送回ACK。FIN的接收意味着服务器端在相应连接上再无额外数据可接收</li>\n<li>一段时间后（这段时间内，服务器端仍然可以向客户端发送数据，称为半关闭状态），服务器端也将调用close关闭他的套接字，它会像客户端也发送一个FIN</li>\n<li>执行主动关闭的那端会发送ACK确认这个FIN</li>\n</ol>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165546769.png\" alt=\"image-20210603165546769\"></p>\n<h3 id=\"TCP状态转换图\"><a href=\"#TCP状态转换图\" class=\"headerlink\" title=\"TCP状态转换图\"></a>TCP状态转换图</h3><p>用粗实线表示客户状态转换，粗虚线表示服务器状态转换。</p>\n<p>接收表示该状态转换在接受到什么分节时发生，发送表示该状态转换会发送什么分节</p>\n<p>例子1 <strong>客户端建立连接</strong>：</p>\n<p>当某个应用程序在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED，这个状态通常是数据传送发生时的状态</p>\n<p>例子2 <strong>客户端、服务器断开连接</strong>：</p>\n<p>如果某个应用进程在接收到一个FIN之前调用close（主动关闭），则转换到FIN_WAIT_1状态</p>\n<p>但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN（被动关闭），那就转换到CLOSE_WAIT状态</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603170310342.png\" alt=\"image-20210603170310342\"></p>\n<p><strong>TIME_WAIT状态</strong></p>\n<p>执行主动关闭的那端会经历该状态，持续时间是2MSL（两倍的最长分节生命期，MSL是任何IP数据报能够在因特网中存活的最长时间）</p>\n<p>TIME_WAIT状态存在原因：</p>\n<ol>\n<li>可靠地实现TCP全双工连接的终止。假设最终的ACK丢失，服务器将重新发送它的最终FIN，所以客户端必须维护状态信息，以允许它重新发送最终的那个ACK</li>\n<li>允许老的重复分节在网络中消逝。假设关闭了一个TCP连接，过一段时间又在相同的IP地址和端口号之间建立另一个连接（称为前一个连接的化身，因为IP、端口号一样）。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再次出现。为做到这一点，TCP就不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT的持续时间的2MSL，就足以让某个方向上的分组最多存活MSL即被丢弃。通过该规则，就能保证每成功建立一个TCP连接，来自该连接先前化身的老的重复分组都已经在网络中消逝了。</li>\n</ol>\n<h3 id=\"完整流程\"><a href=\"#完整流程\" class=\"headerlink\" title=\"完整流程\"></a>完整流程</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603171012559.png\" alt=\"image-20210603171012559\"></p>\n<p>应用进程写数据到一个TCP套接字中时发生的步骤：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603185857129.png\" alt=\"image-20210603185857129\"></p>\n<p>每一个TCP套接字有一个发送缓冲区。当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区，如果该套接字的发送缓冲区容不下该应用进程的所有数据，该应用进程将置于休眠状态。内核将不从write系统调用返回，直到应用进程缓冲区中所有数据都复制到套接字发送缓冲区</p>\n<p>因此，从一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据。</p>\n<p>这一端的TCP提取套接字发送缓冲区中的数据并把它发送给对端TCP。对端TCP必须确认收到的数据，伴随来自对端的ACK的不断到达，本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止</p>\n<p>本端TCP以MSS大小的块把数据传递给IP，同时给每个数据块安上一个TCP首部已构成TCP分节，IP给每个TCP分节安上一个IP首部以构成IP数据报，并按照其目的IP地址查找路由表项以确定外出接口，然后把数据报传递给相应的数据链路。</p>\n<h2 id=\"简单案例\"><a href=\"#简单案例\" class=\"headerlink\" title=\"简单案例\"></a>简单案例</h2><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603191611037.png\" alt=\"image-20210603191611037\" style=\"zoom: 67%;\" />\n\n\n\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603203304963.png\" alt=\"image-20210603203304963\"></p>\n<p><strong>正常终止步骤</strong></p>\n<ol>\n<li>当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回</li>\n<li>当str_cli函数返回到客户的main函数时，main通过调用exit终止</li>\n<li>进程终止处理的部分工作是关闭所有打开的描述符，因此客户打开的套接字由内核关闭，这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应。至此，服务器套接字处于CLOSE_WAIT状态，客户套接字处于FIN_WAIT_2状态</li>\n<li>当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline返回0，这导致str_echo函数返回服务器子进程的main函数</li>\n<li>服务器子进程通过调用exit来终止</li>\n<li>服务器子进程中打开的所有描述符随之关闭，由子进程来关闭已连接套接字会引发TCP连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK。至此连接完全终止，客户端套接字进入TIME_WAIT状态</li>\n</ol>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><pre><code class=\"c\">#include    &quot;unp.h&quot;\n\nint\nmain(int argc, char **argv)\n{\n    int                    sockfd;\n    struct sockaddr_in    servaddr;\n\n    if (argc != 2)\n        err_quit(&quot;usage: tcpcli &lt;IPaddress&gt;&quot;);\n\n    // 创建一个套接字，返回描述符\n    sockfd = Socket(AF_INET, SOCK_STREAM, 0);\n\n    // 填入服务器的IP地址和端口号\n    bzero(&amp;servaddr, sizeof(servaddr));\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(SERV_PORT);\n    Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr);\n\n    // 和服务器建立TCP连接\n    Connect(sockfd, (SA *) &amp;servaddr, sizeof(servaddr));\n\n    str_cli(stdin, sockfd);\n\n    exit(0); // 终止程序运行，Unix在进程终止时总是关闭该进程所有打开的描述符\n}\n\nvoid\nstr_cli(FILE *fp, int sockfd)\n{\n    char    sendline[MAXLINE], recvline[MAXLINE];\n\n    while (Fgets(sendline, MAXLINE, fp) != NULL) {\n\n        Writen(sockfd, sendline, strlen(sendline));\n\n        if (Readline(sockfd, recvline, MAXLINE) == 0)\n            err_quit(&quot;str_cli: server terminated prematurely&quot;);\n\n        Fputs(recvline, stdout);\n    }\n}</code></pre>\n<p>客户调用st_cli函数，该函数将阻塞于fgets调用，因为我们还未输入任何数据。</p>\n<h3 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h3><pre><code class=\"c\">#include    &quot;unp.h&quot;\n\nint main(int argc, char **argv)\n{\n    int                    listenfd, connfd;\n    pid_t                childpid;\n    socklen_t            clilen;\n    struct sockaddr_in    cliaddr, servaddr;\n\n    // 创建套接字\n    listenfd = Socket(AF_INET, SOCK_STREAM, 0);\n\n    bzero(&amp;servaddr, sizeof(servaddr));\n    servaddr.sin_family      = AF_INET;\n    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n    servaddr.sin_port        = htons(SERV_PORT);\n\n    // 调用bind函数绑定端口号\n    Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr));\n\n    // 把套接字转换成一个监听套接字，这样来自客户端的外来连接可以在该套接字由内核接收\n    Listen(listenfd, LISTENQ);\n\n    for ( ; ; ) {\n        clilen = sizeof(cliaddr);\n        // 服务器进程在accept调用中被置于休眠状态，等待某个客户连接的到达并被内核接受\n        // TCP使用三次握手来建立连接，握手完毕后accept返回。一个已连接描述符connfd\n        // 该描述符用于与新连接的那个客户通信\n        // accept为每个连接到本服务器的客户返回一个新描述符\n        // 该服务器一次只能处理一个客户。如果多个客户连接同时到达，系统内核在某个最大数量的限制下把他们排入队列，然后每次返回一个给accept函数\n        connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen);\n\n        if ( (childpid = Fork()) == 0) {    \n            Close(listenfd);    \n            str_echo(connfd);    \n            exit(0);\n        }\n        // 服务器调用close关闭与客户的连接，引发四次挥手操作。（当然这里引用计数不为0，实际close操作在子进程完成）\n        Close(connfd);            \n    }\n}\n\nvoid str_echo(int sockfd)\n{\n    ssize_t        n;\n    char        buf[MAXLINE];\n\n    again:\n    // 如果客户关闭连接，那么接收到客户的FIN将导致服务器子进程的read函数返回0，将导致str_echo返回，从而终止子进程\n    while ( (n = read(sockfd, buf, MAXLINE)) &gt; 0)\n        Writen(sockfd, buf, n);\n\n    if (n &lt; 0 &amp;&amp; errno == EINTR)\n        goto again;\n    else if (n &lt; 0)\n        err_sys(&quot;str_echo: read error&quot;);\n}</code></pre>\n<p>当服务器端accept函数返回时，服务器调用fork，再有子进程调用str_echo。该函数调用readline，readline调用read，而read在等待客户送入一行文本期间阻塞。</p>\n<p>另一方面，服务器父进程再次调用accept并阻塞，等待下一个客户连接。</p>\n<h3 id=\"并发服务器\"><a href=\"#并发服务器\" class=\"headerlink\" title=\"并发服务器\"></a>并发服务器</h3><p>主服务器循环通过派生一个子进程来处理每个新的连接</p>\n<p>当服务器接收并接受这个客户的连接，它fork一个自身的副本，让子进程来处理该客户的请求</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603172737267.png\" alt=\"image-20210603172737267\"></p>\n<p>TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点，它必须查看套接字对的所有四个元素才能确定由哪个端点接收某个到达的分节</p>\n<p>我们必须在服务器主机上区分监听套接字和已连接套接字。已连接套接字使用与监听套接字相同的本地端口（21）</p>\n<p>对于同一个本地端口（21）存在三个套接字：</p>\n<ul>\n<li>如果一个分节来自客户端端口1500，目的地为服务器端端口21，被传递到第一个子进程</li>\n<li>如果一个分节来自客户端端口1501，目的地为服务器端端口21，被传递到第二个子进程</li>\n<li>所有目的端口为21的其他TCP分节被传递给拥有监听套接字的那个最初服务器（父进程）</li>\n</ul>\n<p>是在同时有大量的客户连接到同一个服务器上时用于提供并发性的一种技术，每个客户连接都迫使服务器为他fork一个新的进程</p>\n<pre><code class=\"c\">pid_t pid;\nint listenfd, connfd;\nlistenfd = Socket();\nBind(listenfd);\nListen(listenfd, backlog);\n\nfor(;;) {\n    connfd = Accept(listenfd);\n    // 子进程进入if执行\n    if ((pid == Fork()) == 0) {\n        Close(listenfd);\n        processHandler(connfd); // 处理请求\n        Close(connfd);\n        exit(0);\n    }\n    Close(connfd);\n}</code></pre>\n<p>当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户（提供已连接套接字connfd)，父进程则等待另一个连接（通过监听套接字listenfd)。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。</p>\n<p>对一个TCP套接字调用close会导致发送一个FIN，随后是正常的四次挥手，那么为什么父进程对connfd调用close没有终止它与客户的连接？因为每个文件或套接字都有一个引用计数（是当前打开着的引用该文件或套接字的描述符的个数）。套接字真正的清理和资源释放要等到引用计数值为0时才发生，即会在子进程也关闭connfd时发生。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200912778.png\" alt=\"image-20210603200912778\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200853359.png\" alt=\"image-20210603200853359\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200933250.png\" alt=\"image-20210603200933250\"></p>\n<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><h3 id=\"Socket函数\"><a href=\"#Socket函数\" class=\"headerlink\" title=\"Socket函数\"></a>Socket函数</h3><pre><code class=\"c#\">int socket(int family, in type, int protocol);</code></pre>\n<p>指定期望的通信协议类型（例如使用IPv4的TCP）</p>\n<p>socket函数在成功时返回一个小的非负整数值，与文件描述符类似，称为套接字描述符，简称sockfd</p>\n<h3 id=\"connect函数\"><a href=\"#connect函数\" class=\"headerlink\" title=\"connect函数\"></a>connect函数</h3><p>TCP客户用connect函数来建立与TCP服务器的连接</p>\n<pre><code class=\"c\">int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);</code></pre>\n<p>sockfd是由socket函数返回的套接字描述符</p>\n<p>servaddr、addrlen是指向套接字地址结构的指针和该结构的大小（结构中含有服务器的IP地址和端口号）</p>\n<p>客户调用connect函数时不需要调用bind函数，因为如果需要，内核会确定源ip地址，并选择一个临时端口作为源端口</p>\n<p>如果是TCP套接字，调用connect函数将触发TCP的三次握手过程</p>\n<h3 id=\"bind函数\"><a href=\"#bind函数\" class=\"headerlink\" title=\"bind函数\"></a>bind函数</h3><pre><code class=\"c\">int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);</code></pre>\n<p>myaddr、addrlen是指向套接字地址结构的指针和该结构的大小（可以指定要绑定的IP地址和端口号），如果要绑定IP地址，则该IP地址必须属于其所在主机的网络接口之一</p>\n<h3 id=\"listen函数\"><a href=\"#listen函数\" class=\"headerlink\" title=\"listen函数\"></a>listen函数</h3><pre><code class=\"c\">int listen(int sockfd, int backlog);</code></pre>\n<p>listen函数仅由TCP服务器调用，作用：</p>\n<ol>\n<li>当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是一个调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。即调用listen函数导致套接字从CLOSED状态转换成LISTEN状态</li>\n<li>本函数第二个参数规定内核应该为相应套接字排队的最大连接个数</li>\n</ol>\n<p>内核为任何一个给定的监听套接字维护两个队列：</p>\n<ol>\n<li><strong>未完成连接队列</strong>。每个这样的SYN分节对应其中的一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三次握手过程。这些套接字处于SYN_RCVD状态（在三次握手正常完成的前提下，未完成连接队列中的任何一项在其中的存留时间就是一个RTT)</li>\n<li><strong>已完成连接队列</strong>。每个已完成TCP三次握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态</li>\n</ol>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603193151337.png\" alt=\"image-20210603193151337\" style=\"zoom:67%;\" />\n\n<p>每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。</p>\n<p>当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项，然后响应三次握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK。这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器SYN的ACK）到达或该项超时为止。如果三次握手正常完成，该项就从未完成连接队列移动到已完成连接队列的队尾。当进程调用accept时，已完成连接队列中的队头项就返回给进程，或者如果该队列为空，那么进程将处于休眠状态，直到TCP在该队列中放入一项才唤醒他</p>\n<p>在三次握手完成之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为相应已连接套接字的接受缓冲区大小</p>\n<h3 id=\"accept函数\"><a href=\"#accept函数\" class=\"headerlink\" title=\"accept函数\"></a>accept函数</h3><pre><code class=\"c\">int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);</code></pre>\n<p>accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程置为休眠状态。</p>\n<p>如果accept成功。那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接</p>\n<p>称第一个参数为监听套接字描述符，返回值为已连接套接字描述符。一个服务器通常仅仅创建一个监听套接字，他在该服务器的生命周期内一直存在，内核为每个由服务器进程接受的客户连接创建一个已连接套接字（对于他的三次握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。</p>\n<h3 id=\"close函数\"><a href=\"#close函数\" class=\"headerlink\" title=\"close函数\"></a>close函数</h3><pre><code class=\"c\">int close(int sockfd);</code></pre>\n<p>关闭套接字，终止TCP连接</p>\n<p>默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的参数。</p>\n<p>然而TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接四次挥手</p>\n<h3 id=\"fork函数\"><a href=\"#fork函数\" class=\"headerlink\" title=\"fork函数\"></a>fork函数</h3><p>fork函数是Unix派生新进程的唯一方法</p>\n<pre><code class=\"c\">pid_t fork(void); // 返回在子进程中为0，在父进程中为子进程ID，若出错为-1</code></pre>\n<p>调用fork函数一次，它返回两次：</p>\n<ol>\n<li>它在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID</li>\n<li>在子进程又返回一次，返回值是0</li>\n</ol>\n<p>因此返回值本身告知当前进程是父进程还是子进程</p>\n<p>父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享。如果父进程在调用accept之后调用fork，所接受的已连接套接字随后就在父进程和子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字</p>\n<p>fork函数典型用法：</p>\n<ol>\n<li>一个进程创建一个自身的副本，这样每个副本都可以在来一个副本执行其他任务的同时处理各自的某个操作，这是网络服务器的典型用法。</li>\n<li>一个进程想要执行另一个程序。该进程调用fork创建一个自身的副本，其中一个副本（子进程）调用exec把自身替换成新的程序。是shell等程序的典型用法。</li>\n</ol>\n<h1 id=\"IO模型\"><a href=\"#IO模型\" class=\"headerlink\" title=\"IO模型\"></a>IO模型</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>首先看看服务端处理网络请求的典型过程：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396ad36eda\" alt=\"服务端处理网络请求流程图\"></p>\n<p>可以看到，主要处理步骤包括：</p>\n<ul>\n<li>1、获取请求数据 客户端与服务器建立连接发出请求，服务器接受请求（1-3）</li>\n<li>2、构建响应 当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）</li>\n<li>3、返回数据 服务器将已构建好的响应再通过内核空间的网络I/O发还给客户端（5-7）</li>\n</ul>\n<p>输入操作通常包括两个不同的阶段：</p>\n<ol>\n<li>等待数据准备好</li>\n<li>从内核向进程复制数据</li>\n</ol>\n<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>\n<p><strong>UDP套接字编程</strong></p>\n<p>下面的IO模型拿UDP举例，因为数据准备好读取的概念比较简单：要么整个数据报已经收到，要么还没有。所以先简述UDP套接字编程</p>\n<p>客户不与服务器建立连接，而是只使用sendto函数给服务器发送数据报，其中必须指定目的地。类似的，服务器不接受来自客户的连接，而是只管调用recvfrom函数，等待来自某个客户的数据到达。recvfrom将与所接收的数据报一道返回客户的协议地址，因此服务器可以把响应发送给正确的客户。</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604183925749.png\" alt=\"image-20210604183925749\" style=\"zoom:67%;\" />\n\n<p><strong>阻塞和非阻塞</strong></p>\n<p>描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。阻塞调用会一直等待远程数据就绪再返回，直到读取结束。而非阻塞无论在什么情况下都会立即返回，虽然非阻塞大部分时间不会被block，但是它仍要求进程不断地去主动询问kernel是否准备好数据，也需要进程主动地再次调用recvfrom来将数据拷贝到用户内存。</p>\n<ul>\n<li>阻塞调用与非阻塞调用<ul>\n<li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回</li>\n<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程</li>\n</ul>\n</li>\n</ul>\n<p>两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。阻塞是指调用方一直在等待而且别的事情什么都不做。非阻塞是指调用方先去忙别的事情</p>\n<p><strong>同步和异步</strong></p>\n<p>描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</p>\n<ul>\n<li><p>同步处理与异步处理</p>\n<ul>\n<li>同步处理是指被调用方得到最终结果之后才返回给调用方</li>\n<li>异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方</li>\n</ul>\n<p>  <strong>阻塞、非阻塞的讨论对象是调用者</strong></p>\n<p>  <strong>同步、异步的讨论对象是被调用者</strong></p>\n</li>\n</ul>\n<h3 id=\"IO模型比较\"><a href=\"#IO模型比较\" class=\"headerlink\" title=\"IO模型比较\"></a>IO模型比较</h3><ul>\n<li>同步IO操作：导致请求进程阻塞，直到IO操作完成</li>\n<li>异步IO操作：不导致请求进程阻塞</li>\n</ul>\n<p>前四种同步IO模型的主要区别在第一阶段，因为他们第二阶段是一样的：在数据从内核复制到调用者缓冲区期间，进程阻塞与recvfrom调用。相反，异步IO模型在这两阶段都要处理</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae2b8fb2a\" alt=\"img\"></p>\n<p>阻塞式IO模型、非阻塞式IO模型、IO复用模型、信号驱动IO模型都是同步IO模型，因为其中真正的IO操作(recvfrom)将阻塞进程。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207165051430.png\" alt=\"image-20210207165051430\"></p>\n<h2 id=\"阻塞式IO模型\"><a href=\"#阻塞式IO模型\" class=\"headerlink\" title=\"阻塞式IO模型\"></a>阻塞式IO模型</h2><p>把recvfrom视为系统调用，因为要区分应用进程和内核。它一般都会从在应用进程空间中运行切换到在内核空间中运行，一段时间后再切换回来</p>\n<p>进程调用recvfrom，其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据报。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396a811072\" alt=\"阻塞式I/O模型\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207152811758.png\" alt=\"image-20210207152811758\"></p>\n<ul>\n<li><p>同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。</p>\n</li>\n<li><p>用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。</p>\n</li>\n<li><p>服务端采用单线程，当 accept 一个请求后，在read调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理完 ）（无法处理并发）</p>\n</li>\n<li><p>套接字的读写方法，默认是阻塞的。例如read方法要传递进去一个参数n，代表最多读取n个字节后再返回，如果一个字节都没有，则线程卡顿直到新的数据到来或连接关闭，read方法才能返回。</p>\n</li>\n<li><p>write方法一般不会阻塞，除非内核为套接字分配的写缓冲区满了，write方法才会阻塞，直到缓冲区中有空间空闲出来</p>\n</li>\n<li><p>即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p>\n</li>\n<li><p>阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作</p>\n</li>\n</ul>\n<pre><code class=\"java\">{\n    read(socket， buffer);\n    process(buffer);\n}</code></pre>\n<h2 id=\"非阻塞式IO模型\"><a href=\"#非阻塞式IO模型\" class=\"headerlink\" title=\"非阻塞式IO模型\"></a>非阻塞式IO模型</h2><p>进程把一个套接字设置成非阻塞是通知内核：当所请求的IO操作需要把本进程阻塞时，不阻塞了，而是返回一个错误</p>\n<p>前三次调用recvfrom时没有数据可返回，因此内核立即返回一个RWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回。我们接着处理数据。</p>\n<p>当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，称为轮询。应用程序持续轮询内核，以查看某个操作是否就绪，往往会消耗大量的CPU时间</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396af89a4a\" alt=\"非阻塞式I/O模型\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153315652.png\" alt=\"image-20210207153315652\"></p>\n<ul>\n<li>由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</li>\n<li>非阻塞IO通常发生在一个for循环当中，因为每次进行IO操作时要么IO操作成功，要么当IO操作会阻塞时返回错误EWOULDBLOCK/EAGAIN，然后再根据需要进行下一次的for循环操作，这种类似轮询的方式会浪费很多不必要的CPU资源，是一种糟糕的设计。</li>\n<li>即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。</li>\n</ul>\n<pre><code>{\n    while(read(socket， buffer) != SUCCESS);\n    process(buffer);\n}</code></pre>\n<h2 id=\"IO复用模型\"><a href=\"#IO复用模型\" class=\"headerlink\" title=\"IO复用模型\"></a>IO复用模型</h2><p><strong>比喻</strong> 放了一堆鱼竿，在岸边一直守着这堆鱼竿，没有鱼上钩就玩手机</p>\n<p>例子：</p>\n<p>Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而  <strong>I/O 多路复用</strong> 就是为了解决这个问题而出现的。</p>\n<p>redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p>\n<ul>\n<li>优先选择时间复杂度为O(1)的IO复用函数作为底层实现，例如epoll</li>\n<li>以select系统调用为保底，时间复杂度O(N)</li>\n<li>基于react设计模式监听IO事件</li>\n</ul>\n<p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p>\n<p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p>\n<p><strong>原理</strong></p>\n<ul>\n<li>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。</li>\n<li>IO 多路复用实现一个线程可以监视多个文件句柄；</li>\n<li>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</li>\n<li>没有文件句柄就绪就会阻塞应用程序，交出CPU。</li>\n<li>多路是指网络连接，复用指的是同一个线程</li>\n<li>服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。</li>\n</ul>\n<p>多路网络连接复用一个io线程。</p>\n<p>单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。</p>\n<p>一种可以在单线程/进程中处理多个事件流的方法</p>\n<p>I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作</p>\n<p>进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个IO条件就绪（输入已经准备好或描述符已能承接更多的输出），它就通知进程。</p>\n<p>适用于：</p>\n<ul>\n<li>客户处理多个描述符（通常是交互式输入和网络套接字）</li>\n<li>TCP服务器既要处理监听套接字，又要处理已连接套接字</li>\n</ul>\n<p>select, poll, epoll 都是I/O多路复用的具体的实现</p>\n<p>阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的IO系统调用上。</p>\n<p>我们阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据复制到应用进程缓冲区。</p>\n<p>使用select的优势在于我们可以等待多个描述符就绪。</p>\n<p>服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396cc78d98\" alt=\"I/O复用模型\"></p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207153611203.png\" alt=\"image-20210207153611203\"></p>\n<p>用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</p>\n<p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在<strong>同一个线程内同时处理多个IO请求的目的</strong>。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>\n<pre><code class=\"java\">//将socket添加到select监视中\nselect(socket);\n\nwhile(1) {\n    sockets = select();\n    //一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。\n    for(socket in sockets) {\n        if(can_read(socket)) {\n            read(socket， buffer);\n            process(buffer);\n        }\n    }\n}</code></pre>\n<p>虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。</p>\n<p>IO多路复用模型使用了Reactor设计模式实现了这一机制。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154330581.png\" alt=\"image-20210207154330581\"></p>\n<p><strong>Reactor设计模式</strong></p>\n<p>EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154426634.png\" alt=\"image-20210207154426634\"></p>\n<p>通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</p>\n<p>用户线程使用IO多路复用模型的伪代码描述为：</p>\n<pre><code class=\"c\">void UserEventHandler::handle_event() {\n    if(can_read(socket)) {\n        read(socket， buffer);\n        process(buffer);\n    }\n}\n\n//用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。\n{\n    Reactor.register(new UserEventHandler(socket));\n}</code></pre>\n<p>Reactor中handle_events事件循环的伪代码大致如下。</p>\n<p>事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。</p>\n<pre><code class=\"c\">Reactor::handle_events() {\n    while(1) {\n        sockets = select();\n        for(socket in sockets) {\n            get_event_handler(socket).handle_event();\n        }\n    }\n}</code></pre>\n<h2 id=\"信号驱动IO模型\"><a href=\"#信号驱动IO模型\" class=\"headerlink\" title=\"信号驱动IO模型\"></a>信号驱动IO模型</h2><p><strong>比喻</strong> 鱼竿上系了个铃铛，当铃铛响，就知道鱼上钩，然后可以专心玩手机</p>\n<p>信号驱动IO是利用信号机制，让内核告知应用程序文件描述符的相关事件。</p>\n<p>但信号驱动IO在网络编程的时候通常很少用到，因为在网络环境中，和socket相关的读写事件太多了，比如下面的事件都会导致SIGIO信号的产生：</p>\n<ol>\n<li>TCP连接建立</li>\n<li>一方断开TCP连接请求</li>\n<li>断开TCP连接请求完成</li>\n<li>TCP连接半关闭</li>\n<li>数据到达TCP socket</li>\n<li>数据已经发送出去(如：写buffer有空余空间)</li>\n</ol>\n<p>上面所有的这些都会产生SIGIO信号，但我们没办法在SIGIO对应的信号处理函数中区分上述不同的事件，SIGIO只应该在IO事件单一情况下使用，比如说用来监听端口的socket，因为只有客户端发起新连接的时候才会产生SIGIO信号。</p>\n<p>也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们</p>\n<p>首先开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用立即返回，我们进程继续工作，即没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。</p>\n<p>无论如何处理SIGIO信号，这种模型优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a72396ceccf52\" alt=\"信号驱动式I/O模型\"></p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>信号I/O在大量IO操作时可能会因为信号队列溢出导致没法通知</li>\n<li>信号驱动I/O尽管对于处理UDP套接字来说有用，即这种信号通知意味着到达一个数据报，或者返回一个异步错误。但是，对于TCP而言，信号驱动的I/O方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源，与前几种方式相比优势尽失</li>\n</ul>\n<h2 id=\"异步IO模型\"><a href=\"#异步IO模型\" class=\"headerlink\" title=\"异步IO模型\"></a>异步IO模型</h2><p>告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。</p>\n<p>与信号驱动模型的主要区别在于：信号驱动IO由内核通知我们何时可以启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成。</p>\n<p>我们调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。</p>\n<p>本例子中我们假设要求内核在操作完成时产生某个信号。该信号直到数据已复制到应用进程缓冲区才产生。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/165a723ae253818f\" alt=\"异步I/O模型\"></p>\n<p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207154623278.png\" alt=\"image-20210207154623278\"></p>\n<p>异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。</p>\n<p>目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。</p>\n<p>异步IO和信号驱动IO差不多，但它比信号驱动IO可以多做一步：相比信号驱动IO需要在程序中完成数据从用户态到内核态(或反方向)的拷贝，异    步IO可以把拷贝这一步也帮我们完成之后才通知应用程序。</p>\n<p>异步IO是完全完成了数据的拷贝之后才通知程序进行处理，没有阻塞的数据读写过程。</p>\n<p>这里面的读取操作的语义与上面的几种模型都不同。这里的读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。</p>\n<h1 id=\"select、poll、epoll函数\"><a href=\"#select、poll、epoll函数\" class=\"headerlink\" title=\"select、poll、epoll函数\"></a>select、poll、epoll函数</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"文件描述符\"><a href=\"#文件描述符\" class=\"headerlink\" title=\"文件描述符\"></a>文件描述符</h3><p>文件描述符是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>\n<h3 id=\"进程阻塞\"><a href=\"#进程阻塞\" class=\"headerlink\" title=\"进程阻塞\"></a>进程阻塞</h3><p> 正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得了CPU资源），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p>\n<h3 id=\"缓存I-O\"><a href=\"#缓存I-O\" class=\"headerlink\" title=\"缓存I/O\"></a>缓存I/O</h3><p> 缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>\n<p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p>\n<p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>\n<h2 id=\"select函数\"><a href=\"#select函数\" class=\"headerlink\" title=\"select函数\"></a>select函数</h2><h3 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。</p>\n<p>例子：我们可以调用select，告知内核仅在下列情况发生时才返回：</p>\n<ul>\n<li>集合{1，4，5}中的任何描述符准备好读；</li>\n<li>集合{2，7}中的任何描述符准备好写；</li>\n<li>集合{1，4}中的任何描述符有异常条件待处理；</li>\n<li>已经历10.2s</li>\n</ul>\n<p>也就是说，我们调用select告知内核对哪些描述符（就读、写或异常条件）感兴趣，以及等待多长时间。</p>\n<pre><code class=\"c\">int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);</code></pre>\n<p>timeout告知内核等待所指定描述符中的任何一个就绪可花多长时间，可赋值为三种情况：</p>\n<ol>\n<li>永远等待下去：仅在有一个描述符准备好IO才返回。为此，我们把该参数设置为空指针。</li>\n<li>等待一段固定时间：在有一个描述符准备好IO才返回，但是不超过指定参数的时间。</li>\n<li>根本不等待：检查描述符后立即返回，这称为轮询。参数指定为0.</li>\n</ol>\n<p>fd_set可以理解为一个集合，这个集合中存放的是文件描述符，即文件句柄。readset、writeset、exceptset指定我们要让内核测试读、写和异常条件的描述符，如果对某一个条件不感兴趣，就可以把它设为空指针。</p>\n<p>maxfdp1参数指定待测试的描述符个数，它的值是待测试的最大描述符加1。</p>\n<p>当函数返回时，结果将指示哪些描述符已就绪。</p>\n<p>头文件&lt;sys/select.h&gt;中定义的FD_SETSIZE常量值是数据类型fd_set中的描述符总数（通常是1024）</p>\n<p>当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读。</p>\n<p>使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>\n<h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><ul>\n<li>这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于select可以监听多个socket，我们可以用它来处理多个连接。</li>\n<li>在select模型中每个socket一般都设置成non-blocking，虽然等待数据阶段仍然是阻塞状态，但是它是被select调用阻塞的，而不是直接被I/O阻塞的。select底层通过轮询机制来判断每个socket读写是否就绪。</li>\n<li>当然select也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了epoll作为select的改进版本。</li>\n<li>select、poll、epoll本质上也都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li>\n</ul>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>\n<ul>\n<li>使用事件轮询API的select函数，输入是read_fds &amp; write_fds；输出是与之对应的可读可写事件，同时还提供了timeout参数。</li>\n<li>如果期间没有任何事件到来，那么最多等待timeout的值的时间，线程处于阻塞状态。</li>\n<li>一旦其间有任何事件到来，就立即返回。时间过了之后还是没有任何事件，就立即返回。</li>\n<li>拿到事件后，线程可以继续挨个处理相应事件，处理完了继续轮询，于是线程就进入了一个死循环，我们称循环为时间循环，一个循环为一个周期。</li>\n</ul>\n<p><strong>select缺点</strong><br>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>\n<ul>\n<li>单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024 ;为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)</li>\n<li>每次调用 select，都需要把 fd_set集合从用户态拷贝到内核态，这个开销在 fd_set很多时会很大；需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</li>\n<li>对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发)。当套接字比较多的时候，每次select()都要通过遍历FD_SET中SIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</li>\n</ul>\n<h3 id=\"客户端程序\"><a href=\"#客户端程序\" class=\"headerlink\" title=\"客户端程序\"></a>客户端程序</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604193654363.png\" alt=\"image-20210604193654363\"></p>\n<p>8-13行：<strong>调用select</strong></p>\n<p>我们只需要一个用于检查可读性的描述符集。该集合由FD_ZERO初始化，并用FD_SET打开两位：一位对应于标准IO文件指针fp，一位对应于套接字sockfd。fileno函数把标准IO文件指针转换为对应的描述符。因为select函数只工作在描述符上。</p>\n<p>计算两个描述符中的较大者后，调用select。在该调用中，写集合指针和异常集合指针都是空指针。最后一个参数（时间限制）也是空指针，因为我们希望本调用阻塞到某个描述符就绪为止。</p>\n<p>14-18行：<strong>处理可读套接字</strong></p>\n<p>如果在select返回时套接字是可读的，就执行对应操作</p>\n<p>19-23行：<strong>处理可读输入</strong></p>\n<p>如果标准输入可读，就执行相应操作</p>\n<h3 id=\"服务器程序\"><a href=\"#服务器程序\" class=\"headerlink\" title=\"服务器程序\"></a>服务器程序</h3><p>把之前的案例重写为使用select来处理任意个客户的单进程程序。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604194813136.png\" alt=\"image-20210604194813136\"></p>\n<p>服务器只维护一个读描述符集，假设服务器是前台启动的，那么描述符0、1、2分别被置为标准输入、标准输出、标准错误输出。所以监听套接字的第一个可用描述符是3</p>\n<p>client数组中含有每个客户的已连接套接字描述符，初始化为-1</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195011425.png\" alt=\"image-20210604195011425\"></p>\n<p>当第一个客户与服务器建立连接时，监听描述符变为可读，我们的服务器于是调用accept</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195113032.png\" alt=\"image-20210604195113032\"></p>\n<p>我们的服务器必须在client数组中记住每个新的已连接描述符，并把他加到描述符集中去：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195226480.png\" alt=\"image-20210604195226480\"></p>\n<p>随后第二个客户与服务器建立连接：</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195258834.png\" alt=\"image-20210604195258834\"></p>\n<p>接着假设第一个客户终止连接。该客户的TCP发生一个FIN，使得描述符4变得可读。当服务器读这个已连接套接字时，read将返回0。于是关闭该套接字并且把client[0]置为-1，把描述符集中描述符4的位设置位0</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195506423.png\" alt=\"image-20210604195506423\"></p>\n<p>总之，有客户到达时，我们在client数组中的第一个可用项（值为-1的项）中记录其已连接套接字的描述符。并且还必须把这个已连接描述符加到读描述符集中</p>\n<pre><code class=\"c\">listenfd = Socket(AF_INET, SOCK_STREAM, 0);\nBind(listenfd);\nListen(listenfd, LISTENQ);\n\nfor ( ; ; ) {\n    nready = Select(maxfd+1, &amp;rset, NULL, NULL, NULL);\n    // 处理新连接接入\n    if (FD_ISSET(listenfd, &amp;rset)) {    \n        connfd = Accept(listenfd);\n    }\n    // 检查现有连接\n    for (i = 0; i &lt;= maxi; i++) {    \n        if (FD_ISSET(sockfd, &amp;rset)) {\n            if ( (n = Read(sockfd, buf, MAXLINE)) == 0) {\n            } else\n                Writen(sockfd, buf, n);\n        }\n    }\n}</code></pre>\n<ul>\n<li><strong>创建监听套接字并调用select进行初始化</strong></li>\n<li><strong>阻塞于select</strong>：select等待某个事件发生：或是新连接建立，或是数据、FIN或RST到达</li>\n<li><strong>accept新的连接</strong>：如果监听套接字变为可读，则已建立一个新的连接。我们调用accept并更新相应的数据结构。</li>\n<li><strong>检查现有连接</strong>：对于每个现有的客户连接，我们要测试其描述符是否在select返回的描述集里。</li>\n</ul>\n<h2 id=\"poll函数\"><a href=\"#poll函数\" class=\"headerlink\" title=\"poll函数\"></a>poll函数</h2><pre><code class=\"c\">int poll(struct pollfd *fdarray, unsigned long nfds, int timeout);</code></pre>\n<ul>\n<li>fdarray是指向一个结构数组的指针，每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件。还是三种：处理输入的、处理输出的、处理错误的</li>\n<li>nfds指定了结构数组中元素的个数</li>\n<li>timeout指定poll函数返回前等待多长时间</li>\n<li>当发生错误时，poll函数返回值是-1、若定时器到时之前没有任何描述符就绪，则返回0、否则返回就绪描述符的个数（即revents成员值非0的描述符个数）</li>\n</ul>\n<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p>\n<p><strong>poll缺点</strong><br>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有缺点：</p>\n<ul>\n<li>每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；</li>\n<li>对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时）</li>\n</ul>\n<h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><pre><code class=\"c\">int main(int argc, char **argv)\n{\n    listenfd = Socket(AF_INET, SOCK_STREAM, 0);\n    Bind();\n    Listen(listenfd, LISTENQ);\n\n    struct pollfd        client[OPEN_MAX];\n\n    client[0].fd = listenfd;\n    client[0].events = POLLRDNORM;\n    for (i = 1; i &lt; OPEN_MAX; i++)\n        client[i].fd = -1;                        \n\n    for ( ; ; ) {\n        nready = Poll(client, maxi+1, INFTIM);\n\n        // 新连接\n        if (client[0].revents &amp; POLLRDNORM) {    \n            for (i = 1; i &lt; OPEN_MAX; i++)\n                if (client[i].fd &lt; 0) {\n                    client[i].fd = connfd;    \n                    break;\n                }\n            client[i].events = POLLRDNORM;\n        }\n        // 检查某个现有连接上的数据\n        for (i = 1; i &lt;= maxi; i++) {    \n            if ( (sockfd = client[i].fd) &lt; 0)\n                continue;\n            if (client[i].revents &amp; (POLLRDNORM | POLLERR)) {\n                if ( (n = read(sockfd, buf, MAXLINE)) &lt; 0) {\n                        Close(sockfd);\n                        client[i].fd = -1;\n                } else if (n == 0) {\n                    // 代表连接关闭\n                    Close(sockfd);\n                    client[i].fd = -1;\n                } else {\n                    Writen(sockfd, buf, n);\n                }\n            }\n        }\n    }\n}</code></pre>\n<ul>\n<li>分配pollfd结构数组</li>\n<li>初始化。把client数组的第一项用于监听套接字，并把其余各项的描述符成员置为-1</li>\n<li>调用poll，检查新的连接。我们调用poll以等待新的连接或者现有连接上有数据可读。当一个新的连接被接受后，我们在client数组中查找第一个描述符成员为负的可用项。注意，从下标1开始搜索，因为client[0]固定用于监听套接字。</li>\n<li>检查某个现有连接上的数据。</li>\n</ul>\n<h2 id=\"epoll函数\"><a href=\"#epoll函数\" class=\"headerlink\" title=\"epoll函数\"></a>epoll函数</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</p>\n<p><strong>epoll的优点</strong></p>\n<ul>\n<li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</li>\n<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll；</li>\n<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li>\n</ul>\n<h3 id=\"了解\"><a href=\"#了解\" class=\"headerlink\" title=\"了解\"></a>了解</h3><p>epoll 全称 eventpoll，是 linux 内核实现IO多路复用（IO multiplexing）的一个实现。IO多路复用的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。</p>\n<p>epoll 监听的 fd（file descriptor）集合是常驻内核的，它有 3 个系统调用 （<em>epoll_create</em>, <em>epoll_wait</em>, <em>epoll_ctl</em>），通过 <em>epoll_wait</em> 可以多次监听同一个 fd 集合，只返回可读写那部分</p>\n<p>select 只有一个系统调用，每次要监听都要将其从用户态传到内核，有事件时返回整个集合。</p>\n<p>从性能上看，如果 fd 集合很大，用户态和内核态之间数据复制的花销是很大的，所以 select 一般限制 fd 集合最大1024。</p>\n<p>从使用上看，epoll 返回的是可用的 fd 子集，select 返回的是全部，哪些可用需要用户遍历判断。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20140911103834_133.jpg\"></p>\n<p>设想一个场景：有100万用户同时与一个进程保持着TCP连接，而每一时刻只有几十个或几百个TCP连接是活跃的(接收TCP包)，也就是说在每一时刻进程只需要处理这100万连接中的一小部分连接。那么，如何才能高效的处理这种场景呢？进程是否在每次询问操作系统收集有事件发生的TCP连接时，把这100万个连接告诉操作系统，然后由操作系统找出其中有事件发生的几百个连接呢？实际上，在Linux2.4版本以前，那时的select或者poll事件驱动方式是这样做的。</p>\n<p>  这里有个非常明显的问题，即在某一时刻，进程收集有事件的连接时，其实这100万连接中的大部分都是没有事件发生的。因此如果每次收集事件时，都把100万连接的套接字传给操作系统(这首先是用户态内存到内核态内存的大量复制)，而由操作系统内核寻找这些连接上有没有未处理的事件，将会是巨大的资源浪费，然后select和poll就是这样做的，因此它们最多只能处理几千个并发连接。而epoll不这样做，它在Linux内核中申请了一个简易的文件系统，把原先的一个select或poll调用分成了3部分：</p>\n<pre><code class=\"c++\">int epoll_create(int size);  \nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  \nint epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);  </code></pre>\n<ol>\n<li><p>调用epoll_create建立一个epoll对象(在epoll文件系统中给这个句柄分配资源)；</p>\n</li>\n<li><p>调用epoll_ctl向epoll对象中添加这100万个连接的套接字；</p>\n</li>\n<li><p>调用epoll_wait收集发生事件的连接。</p>\n</li>\n</ol>\n<p>  这样只需要在进程启动时建立1个epoll对象，并在需要的时候向它添加或删除连接就可以了，因此，在实际收集事件时，epoll_wait的效率就会非常高，因为调用epoll_wait时并没有向它传递这100万个连接，内核也不需要去遍历全部的连接。</p>\n<h3 id=\"epoll-create\"><a href=\"#epoll-create\" class=\"headerlink\" title=\"epoll_create\"></a>epoll_create</h3><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关，如下所示：</p>\n<pre><code class=\"c\">struct eventpoll {\n　　...\n　　/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，\n　　也就是这个epoll监控的事件*/\n　　struct rb_root rbr;\n　　/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/\n　　struct list_head rdllist;\n　　...\n};</code></pre>\n<p>调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个rdllist双向链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</p>\n<p>  所有添加到epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的rdllist双向链表中。<br>在epoll中对于每一个事件都会建立一个epitem结构体，如下所示：</p>\n<pre><code class=\"c\">struct epitem {\n　　...\n　　//红黑树节点\n　　struct rb_node rbn;\n　　//双向链表节点\n　　struct list_head rdllink;\n　　//事件句柄等信息\n　　struct epoll_filefd ffd;\n　　//指向其所属的eventepoll对象\n　　struct eventpoll *ep;\n　　//期待的事件类型\n　　struct epoll_event event;\n　　...\n}; // 这里包含每一个事件对应着的信息。</code></pre>\n<p>当调用epoll_wait检查是否有发生事件的连接时，只是检查eventpoll对象中的rdllist双向链表是否有epitem元素而已，如果rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx效率非常高。epoll_ctl在向epoll对象中添加、修改、删除事件时，从rbr红黑树中查找事件也非常快，也就是说epoll是非常高效的，它可以轻易地处理百万级别的并发连接。</p>\n<h3 id=\"原理总结\"><a href=\"#原理总结\" class=\"headerlink\" title=\"原理总结\"></a>原理总结</h3><ul>\n<li><p>一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。</p>\n</li>\n<li><p>执行epoll_create()时，创建了红黑树和就绪链表；</p>\n</li>\n<li><p>执行epoll_ctl()时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；</p>\n</li>\n<li><p>执行epoll_wait()时立刻返回准备就绪链表里的数据即可。</p>\n</li>\n</ul>\n<h1 id=\"JAVA-IO\"><a href=\"#JAVA-IO\" class=\"headerlink\" title=\"JAVA IO\"></a>JAVA IO</h1><h2 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h2><h3 id=\"概述-3\"><a href=\"#概述-3\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>BIO是一个同步并阻塞的IO模式，<strong>传统的  java.io 包</strong>，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如<strong>File抽象、输入输出流</strong>等。<strong>交互方式是同步、阻塞的方式</strong>，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1890419bbba44f29b0f71f5598c5e111~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\"></p>\n<p>blocking I/O。同步阻塞模型</p>\n<p>由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行处理。</p>\n<p>每个线程都需要创建独立的线程，当并发量大时，需要创建大量线程来处理连接，系统资源占用大</p>\n<p>代码中的read操作是阻塞操作，如果连接之后，服务端一直不发送数据，将会一直阻塞当前线程，浪费资源。</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603081447596.png\" alt=\"image-20210603081447596\" style=\"zoom: 67%;\" />\n\n<h3 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h3><p>当服务器进程运行时, 可能会同时监听到多个客户的连接请求。</p>\n<p>每当一个客户进程执行以下代码：</p>\n<pre><code class=\"java\">Socket client = new Socket(&quot;127.0.0.1&quot;, 8848);</code></pre>\n<p>就意味着在远程主机的 8848 端口上, 监听到了一个客户的连接请求。管理客户连接请求的任务是由操作系统来完成的。操作系统把这些连接请求存储在一个先进先出的队列中。当队列中的连接请求达到了队列的最大容量时, 服务器进程所在的主机会拒绝新的连接请求。只有当服务器进程通过 ServerSocket 的 accept() 方法从队列中取出连接请求, 使队列腾出空位时，队列才能继续加入新的连接请求。</p>\n<p> 对于客户进程, 如果它发出的连接请求被加入到服务器的请求连接队列中, 就意味着客户与服务器的连接建立成功, 客户进程从 Socket 构造方法中正常返回。</p>\n<p>当客户进程的 Socket构造方法返回成功, 表示客户进程的连接请求被加入到服务器进程的请求连接队列中。 虽然客户端成功返回 Socket对象， 但是还没跟服务器进程形成一条通信线路。必须在服务器进程通过 ServerSocket 的 accept() 方法从请求连接队列中取出连接请求，并返回一个Socket 对象后，服务器进程这个Socket 对象才与客户端的 Socket 对象形成一条通信线路。</p>\n<p>ServerSocket 的 accept() 方法从连接请求队列中取出一个客户的连接请求，然后创建与客户连接的 Socket 对象, 并将它返回。如果队列中没有连接请求，accept() 方法就会一直等待，直到接收到了连接请求才返回。</p>\n<p> 接下来，服务器从 Socket 对象中获得输入流和输出流，就能与客户交换数据。</p>\n<p>服务器的主线程负责接收客户的连接, 每次接收到一个客户连接, 就会创建一个工作线程, 由它负责与客户的通信</p>\n<h3 id=\"示例程序\"><a href=\"#示例程序\" class=\"headerlink\" title=\"示例程序\"></a>示例程序</h3><p><strong>Server</strong></p>\n<pre><code class=\"java\">public class BIOServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8848);\n        while (true) {\n            // 线程在accept调用时处于休眠状态，等待某个客户连接到达并被内核接受\n            Socket socket = serverSocket.accept();\n            new Thread(() -&gt; handler(socket)).start();\n        }\n    }\n\n    public static void handler(Socket socket) {\n        InputStream inputStream = null;\n        try {\n            byte[] bytes = new byte[1024];\n            inputStream = socket.getInputStream();\n            int read;\n            while ((read = inputStream.read(bytes)) != -1) {\n                System.out.println(new String(bytes, 0, read));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre>\n<p><strong>Client</strong></p>\n<pre><code class=\"java\">public class BIOClient {\n    public static void main(String[] args) throws IOException {\n        Socket client = new Socket(&quot;127.0.0.1&quot;, 8848);\n        OutputStream outputStream = client.getOutputStream();\n        String msg = &quot;Hello Server!&quot;;\n        outputStream.write(msg.getBytes(StandardCharsets.UTF_8));\n        client.close();\n    }\n}</code></pre>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><h3 id=\"IO操作\"><a href=\"#IO操作\" class=\"headerlink\" title=\"IO操作\"></a>IO操作</h3><p>应用程序的IO操作实际上不是物理设备级别的读写，而是缓存的复制。read和write两大系统调用都不负责数据在内核缓冲区和物理设备（如磁盘、网卡等）之间的交换。这个底层的读写交换操作是由操作系统内核（Kernel）来完成的。</p>\n<p>外部设备的直接读写涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少底层系统的频繁中断所导致的时间损耗、性能损耗，出现了内核缓冲区。操作系统会对内核缓冲区进行监控，等待缓冲区达到一定数量的时候，再进行IO设备的中断处理，集中执行物理设备的实际IO操作，通过这种机制来提升系统的性能。</p>\n<p>上层应用使用read系统调用时，仅仅把数据从内核缓冲区复制到应用的缓冲区（进程缓冲区）；上层应用使用write系统调用时，仅仅把数据从应用的缓冲区复制到内核缓冲区。在大多数情况下，Linux系统中用户程序的IO读写程序并没有进行实际的IO操作，而是在用户缓冲区和内核缓冲区之间直接进行数据的交换。</p>\n<img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605150414935.png\" alt=\"image-20210605150414935\" style=\"zoom: 67%;\" />\n\n<p>一个完整输入流程的两个阶段：<br>•应用程序等待数据准备好：第一个阶段，应用程序等待数据通过网络到达网卡，当所等待的分组到达时，数据被操作系统复制到内核缓冲区中。这个工作由操作系统自动完成，用户程序无感知。<br>•从内核缓冲区向用户缓冲区复制数据：第二个阶段，内核将数据从内核缓冲区复制到应用的用户缓冲区。</p>\n<h3 id=\"IO多路复用模型\"><a href=\"#IO多路复用模型\" class=\"headerlink\" title=\"IO多路复用模型\"></a>IO多路复用模型</h3><p>select/epoll系统调用。通过该系统调用，一个用户进程（或者线程）可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核就能够将文件描述符的就绪状态返回给用户进程（或者线程），用户空间可以根据文件描述符的就绪状态进行相应的IO系统调用。<br>IO多路复用（IO Multiplexing）属于一种经典的Reactor模式实现，有时也称为异步阻塞IO，Java中的Selector属于这种模型。</p>\n<p>在IO多路复用模型中通过select/epoll系统调用，单个应用程序的线程可以不断地轮询成百上千的socket连接的就绪状态，当某个或者某些socket网络连接有IO就绪状态时就返回这些就绪的状态（或者说就绪事件）。</p>\n<p>（1）选择器注册。首先，将需要read操作的目标文件描述符（socket连接）提前注册到Linux的select/epoll选择器中，在Java中所对应的选择器类是Selector类。然后，开启整个IO多路复用模型的轮询流程。</p>\n<p>（2）就绪状态的轮询。通过选择器的查询方法，查询所有提前注册过的目标文件描述符（socket连接）的IO就绪状态。通过查询的系统调用，内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好或者就绪了就说明内核缓冲区有数据了，内核将该socket加入就绪的列表中，并且返回就绪事件。</p>\n<p>（3）用户线程获得了就绪状态的列表后，根据其中的socket连接发起read系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区。</p>\n<p>（4）复制完成后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605151630414.png\" alt=\"image-20210605151630414\"></p>\n<p>通过JDK的源码可以看出，Java语言的NIO组件在Linux系统上是使用epoll系统调用实现的。所以，Java语言的NIO组件所使用的就是IO多路复用模型。</p>\n<p>IO多路复用模型的缺点是，本质上select/epoll系统调用是阻塞式的，属于同步IO，需要在读写事件就绪后由系统调用本身负责读写，也就是说这个读写过程是阻塞的。要彻底地解除线程的阻塞，就必须使用异步IO模型。</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/f1c9e5d2b37d489e959ccd2d7573a713~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\"></p>\n<p>non-blocking I/O或New IO</p>\n<p>同步非阻塞，服务端可以开启一个线程处理多个连接，它是非阻塞的，客户端发送的数据都会注册到多路复用器selector上面，当selector（selector的select方法是阻塞的）轮询到有读、写或者连接请求时，才会转发到后端程序进行处理，没有数据的时候，业务程序并不需要阻塞等待。</p>\n<p><img src=\"https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603090056517.png\" alt=\"image-20210603090056517\"></p>\n<h3 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h3><ul>\n<li>类比于IO流，但是具有双向性，既可读，又可写</li>\n<li>ServerSocketChannel用来监听客户端连接请求并创建SocketChannel与客户端进行通信</li>\n<li>只能通过Buffer读写Channel中数据</li>\n</ul>\n<h3 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h3><p>本质上是一块内存区域</p>\n<p><strong>字段</strong></p>\n<pre><code class=\"java\">private int mark = -1; // 存储特定position位置，后续通过reset恢复到该位置，依然可以读取这里的数据\nprivate int position = 0; // 读写操作时的索引下标，最大为capacity-1;写模式切换到读模式时，会变为0\nprivate int limit; // 写模式下等于capacity，切换到读模式时，limit表示最多能从buffer中读取多少，等于写模式下的position\nprivate int capacity; // 容量，标识最大能容纳多少字节</code></pre>\n<p><strong>API实例</strong></p>\n<pre><code class=\"java\">ByteBuffer byteBuffer = ByteBuffer.allocate(10); // position = 0,limit = 10,capacity=10\nbyteBuffer.put(&quot;aaa&quot;.getBytes()); // position = 3, limit = 10, capacity = 10\nbyteBuffer.flip(); // 从写模式切换到读模式 position = 0, limit = 3, capacity = 10\nbyteBuffer.get();  // position = 1, limit = 3, capacity = 10\nbyteBuffer.mark(); // mark = 1, position = 1, limit = 3, capacity = 10\nbyteBuffer.get();  // mark = 1, position = 2, limit = 3, capacity = 10\nbyteBuffer.reset();  // mark = 1, position = 1, limit = 3, capacity = 10\nbyteBuffer.clear(); // 所有属性重置 position = 0, limit = 10, capacity = 10</code></pre>\n<p>使用Java NIO Buffer类的基本步骤如下：<br>（1）使用创建子类实例对象的allocate()方法创建一个Buffer类的实例对象。<br>（2）调用put()方法将数据写入缓冲区中。<br>（3）写入完成后，在开始读取数据前调用Buffer.flip()方法，将缓冲区转换为读模式。<br>（4）调用get()方法，可以从缓冲区中读取数据。<br>（5）读取完成后，调用Buffer.clear()方法或Buffer.compact()方法，将缓冲区转换为写模式，可以继续写入。</p>\n<h3 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h3><p><strong>选择器</strong> /<strong>多路复用器</strong>。用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels，也就是可以管理多个网络连接。</p>\n<h3 id=\"示例程序-1\"><a href=\"#示例程序-1\" class=\"headerlink\" title=\"示例程序\"></a>示例程序</h3><p><strong>NIOServer</strong></p>\n<pre><code class=\"java\">package io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NIOServer {\n    public void start() throws IOException {\n        Selector selector = Selector.open();\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.bind(new InetSocketAddress(8848));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        while (true) {\n            int readyChannels = selector.select(); // 获取可用channel数量\n            if (readyChannels == 0) {\n                continue;\n            }\n            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();\n            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();\n            while (iterator.hasNext()) {\n                SelectionKey selectionKey = iterator.next();\n                iterator.remove();\n                if (selectionKey.isReadable()) {\n                    readHandler(selectionKey, selector);\n                } else if (selectionKey.isAcceptable()) {\n                    acceptHandler(serverSocketChannel, selector);\n                }\n            }\n        }\n    }\n\n    private void acceptHandler(ServerSocketChannel serverSocketChannel, \n                               Selector selector) throws IOException {\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        // encode返回的是ByteBuffer\n        socketChannel.write(Charset.defaultCharset().encode(&quot;成功连上了服务器!&quot;));\n    }\n\n    private void readHandler(SelectionKey selectionKey, \n                             Selector selector) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        // 读取客户端数据\n        StringBuilder msg = new StringBuilder();\n        while (socketChannel.read(byteBuffer) &gt; 0) {\n            byteBuffer.flip();\n            msg.append(Charset.defaultCharset().decode(byteBuffer));\n        }\n        // 将channel再次注册到selector上,监听它的可读事件\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        if (msg.length() &gt; 0) {\n            System.out.println(msg.toString());\n            broadCast(selector, socketChannel, msg.toString());\n        }\n    }\n\n    private void broadCast(Selector selector, SocketChannel sourceChannel, String msg) {\n        // 获取所有已接入客户端channel\n        Set&lt;SelectionKey&gt; selectionKeys = selector.keys();\n        selectionKeys.forEach(selectionKey -&gt; {\n            Channel targetChannel = selectionKey.channel();\n            // 剔除发消息的那个channel\n            if (targetChannel instanceof SocketChannel \n                &amp;&amp; targetChannel != sourceChannel) {\n                try {\n                    // 向所有channel广播信息\n                    ((SocketChannel) targetChannel).write(Charset.defaultCharset().encode(msg));\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n\n    public static void main(String[] args) throws IOException {\n        new NIOServer().start();\n    }\n}</code></pre>\n<p><strong>NIOClient</strong></p>\n<pre><code class=\"java\">package io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class NIOClient {\n    static class NIOClientHandler implements Runnable {\n        private final Selector selector;\n\n        public NIOClientHandler(Selector selector) {\n            this.selector = selector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    int readyChannels = selector.select(); // 获取可用channel数量\n                    if (readyChannels == 0) {\n                        continue;\n                    }\n                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();\n                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();\n                    while (iterator.hasNext()) {\n                        SelectionKey selectionKey = iterator.next();\n                        iterator.remove();\n                        if (selectionKey.isReadable()) {\n                            readHandler(selectionKey, selector);\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        private void readHandler(SelectionKey selectionKey, \n                                 Selector selector) throws IOException {\n            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();\n            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n            // 读取服务器端响应数据\n            StringBuilder msg = new StringBuilder();\n            while (socketChannel.read(byteBuffer) &gt; 0) {\n                byteBuffer.flip();\n                msg.append(Charset.defaultCharset().decode(byteBuffer));\n            }\n            // 将channel再次注册到selector上,监听它的可读事件\n            socketChannel.register(selector, SelectionKey.OP_READ);\n            if (msg.length() &gt; 0) {\n                System.out.println(msg.toString());\n            }\n        }\n    }\n\n    public void start() throws IOException {\n        SocketChannel socketChannel = \n            SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 8848));\n        // 新开线程，专门接收服务器端发送的信息\n        Selector selector = Selector.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        new Thread(new NIOClientHandler(selector)).start();\n\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String msg = scanner.nextLine();\n            if (msg != null &amp;&amp; msg.length() &gt; 0) {\n                socketChannel.write(Charset.defaultCharset().encode(msg));\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        new NIOClient().start();\n    }\n}</code></pre>\n<h2 id=\"AIO\"><a href=\"#AIO\" class=\"headerlink\" title=\"AIO\"></a>AIO</h2><p>Asynchronous I/O或NIO.2</p>\n<p>异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</p>\n<p><strong>AIO</strong>提供了从建立连接到读、写的全异步操作。<strong>AIO</strong>可用于异步的<strong>文件读写</strong>和<strong>网络通信</strong>。</p>\n<p><strong>Server</strong></p>\n<pre><code class=\"java\">package io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousServerSocketChannel;\nimport java.nio.channels.AsynchronousSocketChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.charset.Charset;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\npublic class AIOServer {\n    public static void main(String[] args) {\n        try {\n            final int port = 8848;\n            AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open();\n            serverSocketChannel.bind(new InetSocketAddress(port));\n            // 需要在handler的实现中处理连接请求和监听下一个连接、数据收发，以及通信异常。\n            // 消息处理回调接口，是一个负责消费异步IO操作结果的消息处理器\n            CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; handler = new CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() {\n                /*\n                当I/O操作成功完成时，会回调到completed方法，failed方法则在I/O操作失败时被回调。\n                需要注意的是：在CompletionHandler的实现中应当及时处理操作结果，以避免一直占用调用线程而不能分发其他的CompletionHandler处理器。\n                 */\n                @Override\n                public void completed(AsynchronousSocketChannel result, Object attachment) {\n                    // 继续监听下一个连接请求\n                    serverSocketChannel.accept(attachment, this);\n                    try {\n                        System.out.println(&quot;接受了一个连接：&quot; + result.getRemoteAddress().toString());\n                        // result表示当前接受的客户端的连接会话，与客户端的通信都需要通过该连接会话进行。\n                        result.write(Charset.defaultCharset().encode(&quot;Server:Hello World&quot;));\n\n                        ByteBuffer readBuffer = ByteBuffer.allocate(128);\n                        result.read(readBuffer).get();\n                        System.out.println(new String(readBuffer.array()));\n                    } catch (IOException | InterruptedException | ExecutionException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n                @Override\n                public void failed(Throwable exc, Object attachment) {\n                    System.out.println(&quot;出错了：&quot; + exc.getMessage());\n                }\n            };\n            // 是一个异步方法，调用会直接返回,为了让子线程能够有时间处理监听客户端的连接会话，这里让主线程休眠一段时间\n            serverSocketChannel.accept(null, handler);\n            TimeUnit.MINUTES.sleep(Integer.MAX_VALUE);\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<p><strong>Client</strong></p>\n<pre><code class=\"java\">package io;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousSocketChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.charset.Charset;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\npublic class AIOClient {\n    public static void main(String[] args) {\n        try {\n            AsynchronousSocketChannel client = AsynchronousSocketChannel.open();\n            client.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 8848), null, new CompletionHandler&lt;Void, Object&gt;() {\n                @Override\n                public void completed(Void result, Object attachment) {\n                    System.out.println(&quot;成功连接到服务器!&quot;);\n                    try {\n                        client.write(Charset.defaultCharset().encode(&quot;Client:Hello World&quot;));\n                        ByteBuffer readBuffer = ByteBuffer.allocate(128);\n                        client.read(readBuffer).get();\n                        System.out.println(new String(readBuffer.array()));\n                    } catch (InterruptedException | ExecutionException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n                @Override\n                public void failed(Throwable exc, Object attachment) {\n                    exc.printStackTrace();\n                }\n            });\n            TimeUnit.MINUTES.sleep(Integer.MAX_VALUE);\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckpnqq50l0006z0tpa07vd078","category_id":"ckpnqq50p0008z0tp43yy8yjh","_id":"ckpnqq50x000iz0tp8o68dphv"},{"post_id":"ckpnqq50v000fz0tp6s726hha","category_id":"ckpnqq50p0008z0tp43yy8yjh","_id":"ckpnqq50z000mz0tp17ml1ykt"},{"post_id":"ckpnqq50o0007z0tpcb8eafjh","category_id":"ckpnqq50p0008z0tp43yy8yjh","_id":"ckpnqq511000qz0tp12ribzes"},{"post_id":"ckpnqq50r000az0tp673r1nba","category_id":"ckpnqq50p0008z0tp43yy8yjh","_id":"ckpnqq513000tz0tp1hlr8rog"},{"post_id":"ckpnqq50s000bz0tp4a2hbf8y","category_id":"ckpnqq510000nz0tp2sxt6t31","_id":"ckpnqq5150010z0tp2tvo3fd7"},{"post_id":"ckpnqq50t000cz0tp5g6l84rk","category_id":"ckpnqq513000uz0tp4j4v1jl5","_id":"ckpnqq51b0016z0tpdpvi75mw"},{"post_id":"ckpnqq50w000gz0tp66fg7o2b","category_id":"ckpnqq510000nz0tp2sxt6t31","_id":"ckpnqq51d001cz0tp6h9u0yqn"},{"post_id":"ckpnqq50y000kz0tpayvugbgz","category_id":"ckpnqq510000nz0tp2sxt6t31","_id":"ckpnqq51g001jz0tpfxlffsw4"},{"post_id":"ckpnqq50z000lz0tpdarqenfc","category_id":"ckpnqq513000uz0tp4j4v1jl5","_id":"ckpnqq51h001mz0tp5334e32q"},{"post_id":"ckpnqq511000pz0tp0ix385q4","category_id":"ckpnqq513000uz0tp4j4v1jl5","_id":"ckpnqq51h001oz0tpeki175hz"},{"post_id":"ckpnqq512000sz0tp4s92a678","category_id":"ckpnqq51g001lz0tp4q2t5dlq","_id":"ckpnqq51i001uz0tpetckc0xc"},{"post_id":"ckpnqq513000xz0tpctau5qpn","category_id":"ckpnqq51g001lz0tp4q2t5dlq","_id":"ckpnqq51j001xz0tpgpglevry"},{"post_id":"ckpnqq514000zz0tpf6q7au1y","category_id":"ckpnqq51i001tz0tp5fmkgwqg","_id":"ckpnqq51k0021z0tp2dgr4yem"},{"post_id":"ckpnqq5150012z0tp281w39ia","category_id":"ckpnqq51g001lz0tp4q2t5dlq","_id":"ckpnqq51k0024z0tpeyh8dqlb"},{"post_id":"ckpnqq5190014z0tphoje6a60","category_id":"ckpnqq51j0020z0tpctyeabtv","_id":"ckpnqq51l0029z0tpdsjq466u"},{"post_id":"ckpnqq51b0017z0tp6kosepl6","category_id":"ckpnqq51j0020z0tpctyeabtv","_id":"ckpnqq51m002cz0tp9osk6b2b"},{"post_id":"ckpnqq51c0019z0tp72fi2msl","category_id":"ckpnqq51j0020z0tpctyeabtv","_id":"ckpnqq51m002fz0tpdp2g2l8a"},{"post_id":"ckpnqq51e001dz0tp5nh8d6no","category_id":"ckpnqq51l002bz0tp9yel1zwx","_id":"ckpnqq51n002kz0tpfdob033f"},{"post_id":"ckpnqq51f001gz0tp5ale9leu","category_id":"ckpnqq51l002bz0tp9yel1zwx","_id":"ckpnqq51n002mz0tp6x05a7qp"},{"post_id":"ckpnqq527004uz0tp1evudv3v","category_id":"ckpnqq51l002bz0tp9yel1zwx","_id":"ckpnqq52a004xz0tp60rebx7k"},{"post_id":"ckpnqq528004vz0tpcyck7auy","category_id":"ckpnqq51i001tz0tp5fmkgwqg","_id":"ckpnqq52a004yz0tp9l0u9wxs"}],"PostTag":[{"post_id":"ckpnqq50l0006z0tpa07vd078","tag_id":"ckpnqq50q0009z0tpbh878fwa","_id":"ckpnqq511000rz0tpgv0ff0uo"},{"post_id":"ckpnqq50l0006z0tpa07vd078","tag_id":"ckpnqq50t000ez0tp7f4lgqem","_id":"ckpnqq513000vz0tp1o6yg9z3"},{"post_id":"ckpnqq50l0006z0tpa07vd078","tag_id":"ckpnqq50y000jz0tp2hj48ik1","_id":"ckpnqq514000yz0tp2iew6fr0"},{"post_id":"ckpnqq50o0007z0tpcb8eafjh","tag_id":"ckpnqq510000oz0tp078mfi8w","_id":"ckpnqq51d001az0tp73g71t2t"},{"post_id":"ckpnqq50o0007z0tpcb8eafjh","tag_id":"ckpnqq513000wz0tp4ykxd3kj","_id":"ckpnqq51e001ez0tp6i88ciqg"},{"post_id":"ckpnqq50o0007z0tpcb8eafjh","tag_id":"ckpnqq5190013z0tp21sn1syl","_id":"ckpnqq51f001hz0tp4enm1smm"},{"post_id":"ckpnqq50r000az0tp673r1nba","tag_id":"ckpnqq51c0018z0tpa9iidi22","_id":"ckpnqq51h001qz0tp71avesao"},{"post_id":"ckpnqq50r000az0tp673r1nba","tag_id":"ckpnqq51e001fz0tp26n75vi6","_id":"ckpnqq51i001rz0tp0o1mf1vl"},{"post_id":"ckpnqq50r000az0tp673r1nba","tag_id":"ckpnqq51g001kz0tp176r42b9","_id":"ckpnqq51i001vz0tpdghyheuj"},{"post_id":"ckpnqq50s000bz0tp4a2hbf8y","tag_id":"ckpnqq51h001nz0tp9nb384hh","_id":"ckpnqq51k0022z0tp9hjy5bs8"},{"post_id":"ckpnqq50s000bz0tp4a2hbf8y","tag_id":"ckpnqq51i001sz0tp8pqz77bi","_id":"ckpnqq51k0023z0tp0vl0aswp"},{"post_id":"ckpnqq50s000bz0tp4a2hbf8y","tag_id":"ckpnqq51i001wz0tpd2s13w95","_id":"ckpnqq51l0027z0tp7tuuex4t"},{"post_id":"ckpnqq50t000cz0tp5g6l84rk","tag_id":"ckpnqq51j001zz0tpfw6ffr7q","_id":"ckpnqq51m002ez0tp5r8y3vl9"},{"post_id":"ckpnqq50t000cz0tp5g6l84rk","tag_id":"ckpnqq51k0025z0tp2gxs3n1x","_id":"ckpnqq51m002gz0tpctl3dez9"},{"post_id":"ckpnqq50t000cz0tp5g6l84rk","tag_id":"ckpnqq51l002az0tpanxqdkxi","_id":"ckpnqq51n002jz0tp0ab64qi3"},{"post_id":"ckpnqq50v000fz0tp6s726hha","tag_id":"ckpnqq51m002dz0tp5amch151","_id":"ckpnqq51o002oz0tp7kq40kdm"},{"post_id":"ckpnqq50v000fz0tp6s726hha","tag_id":"ckpnqq51n002iz0tpav9tbx2h","_id":"ckpnqq51o002pz0tp0acg9r7f"},{"post_id":"ckpnqq50v000fz0tp6s726hha","tag_id":"ckpnqq5190013z0tp21sn1syl","_id":"ckpnqq51q002rz0tp9sj4emha"},{"post_id":"ckpnqq50w000gz0tp66fg7o2b","tag_id":"ckpnqq51n002nz0tp57jg9xy3","_id":"ckpnqq51r002uz0tp6glu37cl"},{"post_id":"ckpnqq50w000gz0tp66fg7o2b","tag_id":"ckpnqq51o002qz0tpaycx7ov2","_id":"ckpnqq51r002vz0tp74500adu"},{"post_id":"ckpnqq50w000gz0tp66fg7o2b","tag_id":"ckpnqq51q002sz0tp1aza6jr6","_id":"ckpnqq51r002xz0tp5yx85qts"},{"post_id":"ckpnqq50y000kz0tpayvugbgz","tag_id":"ckpnqq51r002tz0tpaz8506j5","_id":"ckpnqq51s0030z0tp3x0j6oim"},{"post_id":"ckpnqq50y000kz0tpayvugbgz","tag_id":"ckpnqq51r002wz0tp60sa3qeb","_id":"ckpnqq51s0031z0tpaq9kd94e"},{"post_id":"ckpnqq50y000kz0tpayvugbgz","tag_id":"ckpnqq51r002yz0tph19y3zlt","_id":"ckpnqq51s0033z0tp2al516uz"},{"post_id":"ckpnqq50z000lz0tpdarqenfc","tag_id":"ckpnqq51s002zz0tp8e8wgq4j","_id":"ckpnqq51t0036z0tpb3cug9i0"},{"post_id":"ckpnqq50z000lz0tpdarqenfc","tag_id":"ckpnqq51s0032z0tp43badrd2","_id":"ckpnqq51t0037z0tp38fvcrb9"},{"post_id":"ckpnqq50z000lz0tpdarqenfc","tag_id":"ckpnqq51s0034z0tp9gpn7a00","_id":"ckpnqq51t0039z0tpfcb0cps1"},{"post_id":"ckpnqq511000pz0tp0ix385q4","tag_id":"ckpnqq51t0035z0tp7ttghzmq","_id":"ckpnqq51u003cz0tpetplb4ik"},{"post_id":"ckpnqq511000pz0tp0ix385q4","tag_id":"ckpnqq51t0038z0tp3cd03mym","_id":"ckpnqq51u003dz0tp3az31wmw"},{"post_id":"ckpnqq511000pz0tp0ix385q4","tag_id":"ckpnqq51u003az0tp2nohe6cr","_id":"ckpnqq51v003fz0tp4woe5l1i"},{"post_id":"ckpnqq512000sz0tp4s92a678","tag_id":"ckpnqq51u003bz0tpcssmffzu","_id":"ckpnqq51v003iz0tp7tj02qp8"},{"post_id":"ckpnqq512000sz0tp4s92a678","tag_id":"ckpnqq51u003ez0tpaav67w4p","_id":"ckpnqq51v003jz0tp2zfkcf6d"},{"post_id":"ckpnqq512000sz0tp4s92a678","tag_id":"ckpnqq51v003gz0tp8qf6d7al","_id":"ckpnqq51w003lz0tpg38ncys0"},{"post_id":"ckpnqq513000xz0tpctau5qpn","tag_id":"ckpnqq50q0009z0tpbh878fwa","_id":"ckpnqq51w003nz0tpgxztcnb6"},{"post_id":"ckpnqq513000xz0tpctau5qpn","tag_id":"ckpnqq51v003hz0tp1ai872bt","_id":"ckpnqq51w003oz0tphmup9ch1"},{"post_id":"ckpnqq513000xz0tpctau5qpn","tag_id":"ckpnqq51w003kz0tpc1nobmy5","_id":"ckpnqq51x003qz0tp5u2a0790"},{"post_id":"ckpnqq514000zz0tpf6q7au1y","tag_id":"ckpnqq51w003mz0tp18i7goyg","_id":"ckpnqq51x003tz0tp7y3ugjme"},{"post_id":"ckpnqq514000zz0tpf6q7au1y","tag_id":"ckpnqq51w003pz0tp8kio2zqe","_id":"ckpnqq51y003uz0tp3qta9c8l"},{"post_id":"ckpnqq514000zz0tpf6q7au1y","tag_id":"ckpnqq51x003rz0tp9pq572st","_id":"ckpnqq51y003wz0tpcs0mf9vu"},{"post_id":"ckpnqq5150012z0tp281w39ia","tag_id":"ckpnqq51u003bz0tpcssmffzu","_id":"ckpnqq51z003zz0tp7jpc5161"},{"post_id":"ckpnqq5150012z0tp281w39ia","tag_id":"ckpnqq51y003vz0tp8a3zgupr","_id":"ckpnqq51z0040z0tp9kxy7e5j"},{"post_id":"ckpnqq5150012z0tp281w39ia","tag_id":"ckpnqq51y003xz0tpbbrkc1i4","_id":"ckpnqq5200042z0tpgfse5rnl"},{"post_id":"ckpnqq5190014z0tphoje6a60","tag_id":"ckpnqq51z003yz0tpgszfbwc6","_id":"ckpnqq5200045z0tp6e355y95"},{"post_id":"ckpnqq5190014z0tphoje6a60","tag_id":"ckpnqq51z0041z0tpepyxchwq","_id":"ckpnqq5200046z0tpci4717nu"},{"post_id":"ckpnqq5190014z0tphoje6a60","tag_id":"ckpnqq5200043z0tp435k7v7k","_id":"ckpnqq5210048z0tpf88v75vf"},{"post_id":"ckpnqq51b0017z0tp6kosepl6","tag_id":"ckpnqq5200044z0tparalac86","_id":"ckpnqq521004bz0tpg3cmdt3c"},{"post_id":"ckpnqq51b0017z0tp6kosepl6","tag_id":"ckpnqq5200047z0tpelf38ve4","_id":"ckpnqq522004cz0tpgs0e8gj9"},{"post_id":"ckpnqq51b0017z0tp6kosepl6","tag_id":"ckpnqq5210049z0tpdf3i0eg9","_id":"ckpnqq522004ez0tpgc1u4nmk"},{"post_id":"ckpnqq51c0019z0tp72fi2msl","tag_id":"ckpnqq513000wz0tp4ykxd3kj","_id":"ckpnqq523004gz0tpfqiw56rq"},{"post_id":"ckpnqq51c0019z0tp72fi2msl","tag_id":"ckpnqq521004az0tp4xy04686","_id":"ckpnqq523004hz0tp6z9qfbb7"},{"post_id":"ckpnqq51c0019z0tp72fi2msl","tag_id":"ckpnqq522004dz0tpbwy1bmjo","_id":"ckpnqq523004jz0tp7gsnctqy"},{"post_id":"ckpnqq51e001dz0tp5nh8d6no","tag_id":"ckpnqq522004fz0tpbfase069","_id":"ckpnqq524004mz0tpdzigc1bl"},{"post_id":"ckpnqq51e001dz0tp5nh8d6no","tag_id":"ckpnqq523004iz0tp9q7s8ji6","_id":"ckpnqq524004nz0tp2l8i5pse"},{"post_id":"ckpnqq51e001dz0tp5nh8d6no","tag_id":"ckpnqq51x003rz0tp9pq572st","_id":"ckpnqq524004pz0tpa9rq2y4m"},{"post_id":"ckpnqq51f001gz0tp5ale9leu","tag_id":"ckpnqq524004lz0tp03hfg7s5","_id":"ckpnqq525004rz0tp3tks8kj1"},{"post_id":"ckpnqq51f001gz0tp5ale9leu","tag_id":"ckpnqq524004oz0tpbwfw44k7","_id":"ckpnqq525004sz0tpe18w1akj"},{"post_id":"ckpnqq51f001gz0tp5ale9leu","tag_id":"ckpnqq524004qz0tp8ry8fzyh","_id":"ckpnqq525004tz0tpbr07d71k"},{"post_id":"ckpnqq527004uz0tp1evudv3v","tag_id":"ckpnqq529004wz0tpfc991mas","_id":"ckpnqq52b0052z0tpelw00tdy"},{"post_id":"ckpnqq527004uz0tp1evudv3v","tag_id":"ckpnqq52a004zz0tp7ec30aav","_id":"ckpnqq52b0053z0tp38wfg73u"},{"post_id":"ckpnqq527004uz0tp1evudv3v","tag_id":"ckpnqq52a0050z0tp3awb49eb","_id":"ckpnqq52c0055z0tp76tacebl"},{"post_id":"ckpnqq528004vz0tpcyck7auy","tag_id":"ckpnqq52b0051z0tphcpq28yl","_id":"ckpnqq52c0057z0tpgbfafe19"},{"post_id":"ckpnqq528004vz0tpcyck7auy","tag_id":"ckpnqq52b0054z0tpebe4c223","_id":"ckpnqq52c0058z0tpcxjo9q0k"},{"post_id":"ckpnqq528004vz0tpcyck7auy","tag_id":"ckpnqq52c0056z0tpb6q5hflq","_id":"ckpnqq52d0059z0tpeeob9d14"}],"Tag":[{"name":"volatile","_id":"ckpnqq50q0009z0tpbh878fwa"},{"name":"synchronized","_id":"ckpnqq50t000ez0tp7f4lgqem"},{"name":"CAS","_id":"ckpnqq50y000jz0tp2hj48ik1"},{"name":"ReentrantLock","_id":"ckpnqq510000oz0tp078mfi8w"},{"name":"锁","_id":"ckpnqq513000wz0tp4ykxd3kj"},{"name":"AQS","_id":"ckpnqq5190013z0tp21sn1syl"},{"name":"线程","_id":"ckpnqq51c0018z0tpa9iidi22"},{"name":"ThreadLocal","_id":"ckpnqq51e001fz0tp26n75vi6"},{"name":"线程池","_id":"ckpnqq51g001kz0tp176r42b9"},{"name":"引用","_id":"ckpnqq51h001nz0tp9nb384hh"},{"name":"算法","_id":"ckpnqq51i001sz0tp8pqz77bi"},{"name":"垃圾收集器","_id":"ckpnqq51i001wz0tpd2s13w95"},{"name":"集合安全","_id":"ckpnqq51j001zz0tpfw6ffr7q"},{"name":"迭代器机制","_id":"ckpnqq51k0025z0tp2gxs3n1x"},{"name":"LRU算法","_id":"ckpnqq51l002az0tpanxqdkxi"},{"name":"阻塞队列","_id":"ckpnqq51m002dz0tp5amch151"},{"name":"并发","_id":"ckpnqq51n002iz0tpav9tbx2h"},{"name":"运行时数据区","_id":"ckpnqq51n002nz0tp57jg9xy3"},{"name":"异常","_id":"ckpnqq51o002qz0tpaycx7ov2"},{"name":"工具","_id":"ckpnqq51q002sz0tp1aza6jr6"},{"name":"双亲委派模型","_id":"ckpnqq51r002tz0tpaz8506j5"},{"name":"生命周期","_id":"ckpnqq51r002wz0tp60sa3qeb"},{"name":"类加载器","_id":"ckpnqq51r002yz0tph19y3zlt"},{"name":"HashMap","_id":"ckpnqq51s002zz0tp8e8wgq4j"},{"name":"ConcurrentHashMap","_id":"ckpnqq51s0032z0tp43badrd2"},{"name":"Set","_id":"ckpnqq51s0034z0tp9gpn7a00"},{"name":"ArrayList","_id":"ckpnqq51t0035z0tp7ttghzmq"},{"name":"LinkedList","_id":"ckpnqq51t0038z0tp3cd03mym"},{"name":"CopyOnWriteArrayList","_id":"ckpnqq51u003az0tp2nohe6cr"},{"name":"架构","_id":"ckpnqq51u003bz0tpcssmffzu"},{"name":"静态代理","_id":"ckpnqq51u003ez0tpaav67w4p"},{"name":"动态代理","_id":"ckpnqq51v003gz0tp8qf6d7al"},{"name":"枚举","_id":"ckpnqq51v003hz0tp1ai872bt"},{"name":"单例模式","_id":"ckpnqq51w003kz0tpc1nobmy5"},{"name":"线程模型","_id":"ckpnqq51w003mz0tp18i7goyg"},{"name":"设计模式","_id":"ckpnqq51w003pz0tp8kio2zqe"},{"name":"开源框架","_id":"ckpnqq51x003rz0tp9pq572st"},{"name":"IO","_id":"ckpnqq51y003vz0tp8a3zgupr"},{"name":"装饰者模式","_id":"ckpnqq51y003xz0tpbbrkc1i4"},{"name":"优化","_id":"ckpnqq51z003yz0tpgszfbwc6"},{"name":"explain","_id":"ckpnqq51z0041z0tpepyxchwq"},{"name":"慢查询","_id":"ckpnqq5200043z0tp435k7v7k"},{"name":"索引","_id":"ckpnqq5200044z0tparalac86"},{"name":"B+树","_id":"ckpnqq5200047z0tpelf38ve4"},{"name":"MySQL","_id":"ckpnqq5210049z0tpdf3i0eg9"},{"name":"事务","_id":"ckpnqq521004az0tp4xy04686"},{"name":"MVCC","_id":"ckpnqq522004dz0tpbwy1bmjo"},{"name":"数据结构","_id":"ckpnqq522004fz0tpbfase069"},{"name":"对象","_id":"ckpnqq523004iz0tp9q7s8ji6"},{"name":"缓存","_id":"ckpnqq524004lz0tp03hfg7s5"},{"name":"持久化","_id":"ckpnqq524004oz0tpbwfw44k7"},{"name":"删除策略","_id":"ckpnqq524004qz0tp8ry8fzyh"},{"name":"主从复制","_id":"ckpnqq529004wz0tpfc991mas"},{"name":"Sentinel","_id":"ckpnqq52a004zz0tp7ec30aav"},{"name":"集群","_id":"ckpnqq52a0050z0tp3awb49eb"},{"name":"IO模型","_id":"ckpnqq52b0051z0tphcpq28yl"},{"name":"epoll","_id":"ckpnqq52b0054z0tpebe4c223"},{"name":"NIO","_id":"ckpnqq52c0056z0tpb6q5hflq"}]}}