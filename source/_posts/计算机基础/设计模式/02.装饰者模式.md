---
title: 装饰者模式
author: tongji4m3
top: true
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习装饰者模式所做的笔记，包括装饰者模式的设计，在Java IO中应用等。
categories: 设计模式
tags:
  - 架构
  - IO
  - 装饰者模式
abbrlink: a708a60d
date: 2021-01-30 00:00:00
---



# 装饰者模式

## 理解

动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案

开闭原则的应用：类应该对扩展开放,对修改关闭；允许类很容易的进行扩展，在不修改代码的情况下就可以搭配新的行为



![image-20200926170529749](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png)

## 细节

+ 利用继承设计子类的行为，是在编译时静态决定的，而且所有子类都会继承到相同的行为。如果利用组合扩展对象的行为，就能在运行时动态地进行扩展。
+ 装饰者和被装饰者有相同的超类型
+ 可以用一个或多个装饰者包装一个对象
+ 在任何需要原始对象的地方，都可以用装饰过的对象代替它
+ 装饰者模式意味着一群装饰者类，用来包装具体的组件
+ 可以用无数的装饰者包装一个组件

# 应用

## IO流

+ I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。
+ 如果采用装饰者模式，那么类的数目就会大大减少，性能的重复也可以减至最少。
+ 设计既避免了类爆炸，又可以让用户自己去搭配核心类和装饰类。
+ 例如：想以缓存的方式从文件中读取字节流。先创建一个FileInputStream，然后把这个FileInputStream放入BufferedInputStream构造函数中去创建BufferedInputStream

### 架构

![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/720290-36c8d9a6e8f77e51.png)

### 抽象构件(Component)角色

由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。

### 具体构件(ConcreteComponent)角色

+ FileInputStream 从文件读取数据（字节流）
+ ByteArrayInputStream 从字节数组读取数据（字节流）
+ PipedInputStream 处理线程间的输入流
+ StringBufferInputStream 处理StringBuffer
+ ObjectInputStream 处理被序列化的对象

### 抽象装饰(Decorator)角色

由FilterInputStream扮演

### 具体装饰(ConcreteDecorator)角色

+ BufferedInputStream

    + 当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据位置。
    + 缓冲字节输入流
    + 不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多

+ DataInputStream

    + 把byte转换成Java基本类型

    +  double readDouble() 此输入流的下八个字节，将它们解释为一个 double。


# 面试

## 装饰者模式和代理模式的区别

让别人帮助你做你并不关心的事情，叫**代理模式**

为让自己的能力增强，使得增强后的自己能够使用更多的方法，拓展在自己基础之上的功能的，叫**装饰器模式**





代理模式，常常自己内部创建被代理的对象。

装饰器模式，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。



使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。  

代理模式强调的是控制，装饰模式强调的是增强。
代理模式强调的是透明访问，装饰模式强调的是自由构建。

代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制。
装饰，偏重对原对象功能的扩展，扩展后的对象仍是是对象本身。

装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。