---
title: 垃圾收集器
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java虚拟机笔记，包括可达性分析算法、垃圾收集算法、经典垃圾收集器等。
categories: Java虚拟机
tags:
  - 引用
  - 算法
  - 垃圾收集器
abbrlink: 6158ee9c
date: 2021-02-16 00:00:00
---



# 判定对象消亡

## 引用计数算法

无法解决循环引用的问题，即实际上这两个对象已经不可能被访问了，但因为它们互相引用着对方，导致它们的引用计数都不为零，引用计数算法就无法回收它们

## 可达性分析算法

+ 通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链
+ 如果从GC Roots到某个对象不可达，则将把他们判定为可回收对象

### GC Roots

+ 在虚拟机栈(栈帧中的局部变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量
+ 在方法区中类静态属性引用的对象，Java类的引用类型静态变量
+ 在方法区中常量引用的对象，例如字符串常量池(String Table)里的引用
+ 在本地方法栈中JNI(即Native方法)引用的对象
+ 虚拟机内部的引用，如基本数据对应的Class对象、常驻的异常对象如NullPointException、OutOfMemoryError、系统类加载器
+ 被同步锁（synchronized）持有的对象
+ 反映虚拟机内部情况的本地代码缓存等
+ 分代收集和局部回收（Partial GC）。如果只针对Java堆中某块区域发起垃圾收集时（如只针对新生代的垃圾收集），这个区域里的对象有可能被位于堆中其他区域的对象所引用。需要将关联区域的对象也一并加入到GC Roots集合中

## 引用

### 强引用

- 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，那么该reference数据是代表某个对象的引用
- 类似Object object = new Object();
- 只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象

### 软引用

+ 只被软引用关联着的对象，在系统将要发生内存溢出异常之前，会将这些对象纳入回收范围进行二次回收
+ 如果这次回收还没有足够的内存，才会抛出内存溢出异常
+ SoftReference
+ 缓存功能，一类对象，当内存空间足够时，能保存在内存中，如果内存空间在进行垃圾收集时仍然非常紧张，则可以抛弃这些对象

### 弱引用

+ 强度被软引用更弱
+ 只能生存到下一次垃圾收集发生为止
+ 无论内存是否充足，都会回收掉只被弱引用关联的对象

### 虚引用

+ 又称幽灵引用或幻影引用
+ 是否有虚引用完全不会对其生命周期构成影响，也无法通过虚引用获取一个对象实例
+ 唯一目的是为了能在这个对象被回收时收到一个系统通知

## 回收方法区

+ 主要回收废弃的常量和不再使用的类型
+ 回收常量池，例如已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量，如果此时进行内存回收，而且确实有必要，则该常量将被系统清理出常量池
+ 回收类。在大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义类加载器的场景，通常需要JVM具备类型卸载的能力
    + 该类的所有的实例都已经被回收，Java堆中不存在该类及其任何派生子类的实例
    + 加载该类的类加载器已经被回收，除非是精心设计的可替换类加载器的场景，否则很难达成
    + 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问这个类的方法

# 垃圾收集算法

## 分代收集理论

**分代收集**

+ 弱分代假说：绝大多数对象都是朝生夕灭
+ 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡
+ 跨代引用假说：跨代引用相对于同代引用来说仅占极少数

**设计原则**

+ 将Java堆划分出不同的区域，根据回收对象年龄（即熬过垃圾收集的次数）分配到不同的区域中存储
+ 划分不同区域后，垃圾收集器可以每次只回收其中一部分区域，根据不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法

**新生代**

+ 每次垃圾收集时都有大批对象死去，而每次回收后存活的少量对象，将会逐步晋身到老年代中存放
+ 如果只进行Minor GC，但新生代对象可能被老年代引用，为了找出存活对象，不得不再固定GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性
+ 依据假说，不应为了少量的跨带引用去扫描整个老年代，只需要在新生代上建立一个全局的数据结构（记忆集），这个结构把老年代分成若干小块，标识出老年代哪一块内存会存在跨带引用
+ 此后Minor GC，只有包含了跨带引用的小块内存里的对象才会被加入GC Roots中进行扫描

## 算法

### 标记-清除算法

+ 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象
+ 执行效率不稳定，标记和清除两个过程的执行效率都随对象数量增长而降低
+ 会产生大量不连续的内存碎片，导致只会程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作

### 标记-复制算法(针对新生代)

+ 半区复制，将可用内存按容量划分成大小相等的两块，每次只使用其中一块，如果这一块内存用完了，就将存活的对象复制到另外一块上，再把已使用过的内存空间清理掉
+ 对于多数对象是可回收的情况，算法需要复制的只是占少数的存活对象，无碎片空间问题
+ 代价是可用内存缩小为原来一半
+ Appel式回收
    + 把新生代分为Eden，和Survivor0，Survivor1区，大小为8:1:1
    + 每次分配内存只使用Eden和Survivor0区
    + 将Eden和Survivor0中存活对象一次性复制到Survivor1区
    + 当Survivor空间不足以容纳一次Minor GC之后存活的对象，就通过分配担保机制直接进入老年代

现在的商业虚拟机都采用复制收集算法来回收新生代，有研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，并不能保证每次回收都只有10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行**分配担保**（Handle Promotion）。即如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。

### 标记-整理算法(针对老年代)

+ 先标记，然后让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存
+ 移动存活对象并更新所有引用这些对象的地方必须暂停用户应用程序才能进行(Stop the World)
+ 但如果不管空间碎片化问题，则直接影响应用程序的吞吐量
+ 关注吞吐量的Parallel Scavenge基于标记-整理
+ 关注延迟的CMS基于标记-清除：在空间碎片过多，影响到对象分配时，再采用标记整理算法收集一次

# HotSpot算法细节

## 根节点枚举

+ 固定可作为GC Roots的节点主要是全局性的引用(例如常量或类静态属性)与执行上下文(例如堆栈中的本地变量表)
+ 所有收集器在根节点枚举这一步骤都是必须暂停用户线程的
+ 必须在一个能保障一致性的快照中才得以进行，整个枚举期间，执行子系统看起来就像是冻结在某个时间点上
+ 用户线程停顿之后，不需要一个不漏地检查完所有执行上下文和全局的引用位置。可以使用一组称为OopMap的数据结构直接得到哪些地方存在着对象引用

## 安全点

+ 通过OopMap，HotSpot可以快速完成GC Roots的枚举，但不可能每条指令都生成OopMap，只是在特定的地方记录了这些位置，即安全点
+ 用户程序执行时并非在代码指令流的任意位置都能停顿下来开始垃圾收集，而是强制要求必须执行到达安全点才能够暂停
+ 安全点的选择一般是以能否让程序长时间执行的特征为标准选定的，一般是指令序列的复用，例如方法调用、循环跳转、异常跳转等才会产生安全点
+ 还要考虑如何让垃圾收集发生时让所有线程都跑到最近的安全点，并停顿
+ 抢先式中断
    + 在垃圾收集发生时，系统首先把所有线程中断，如果发现用户线程中断地方不再安全点上，就恢复线程继续执行，让它一会再中断，直到跑到安全点。
    + 几乎没有虚拟机使用
+ 主动式中断
    + 设置一个标志位，各个线程执行过程中不停地主动轮询这个标志，一旦发现标志为真就自己在最近的安全点上主动中断挂起
    + 使用内存保护陷阱的方式，把轮询操作精简到只有一条汇编指令
    + 仅通过一条汇编指令就完成安全点轮询和触发线程中断

## 安全区域

+ 如果用户线程处于Sleep状态或Blocked状态，即没有分配处理器时间。此时线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己。
+ 安全区域是指能够确保某一段程序代码中，引用关系不会发生改变，因此，在这个区域从任意地方开始垃圾收集都是安全的
+ 当用户线程执行到安全区域里面的代码，首先标识自己已经进入了安全区域，这段时间如果发生垃圾收集JVM不会管这些已经声明在安全区域里面的代码。当要离开安全区域时，它要检查JVM是否完成了根节点枚举，如果完成则继续执行，如果没完成，则一直等待直到收到可以离开安全区域的信号为止

## 记忆集和卡表

+ 为解决对象跨带引用的问题，使用记忆集来避免把整个老年代加入GC Roots的扫描范围
+ 记忆集是一种用来记录从非收集区域指向收集区域的指针集合的数据结构，最简单是用非收集区域中所有含跨带引用的对象数组来实现，但是空间占用太高
+ 收集者只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可，可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本

### 卡表（card table)

+ 每个记录精确到一块内存区域，该区域内有对象含有跨带引用
+ 卡表是记忆集的一种具体实现
+ 使用字节数组，因为速度上现在计算机硬件是按字节编址
+ CARD_TABLE[this.address >> 9] = 0
+ 每一个元素都对应着其标识的内存区域中一块特定大小的内存块
+ 一个卡页（512字节）的内存中通常不止包含一个对象，只要里面有一个存在跨带指针，就置为1，元素变脏。
+ 在垃圾收集时，只要筛选出变脏的元素，就能知道哪有跨带指针，就加入GC Roots

## 写屏障

+ 变脏时间点应该发生在引用类型字段赋值的那一刻，如何在此时更新维护卡表
+ 必须找到一个在机器码层面的手段，把维护卡表的动作放在每一个赋值操作之中
+ 使用写屏障技术维护卡表状态，可以看作是虚拟机层面对“引用类型赋值”这个动作的AOP切面，在引用对象赋值时产生一个环绕通知，供程序执行额外的操作。应用了写后屏障
+ 伪共享问题
    + 缓存系统以缓存行为单位存储，如果多个线程修改互相独立的变量，而这些变量恰好在共享同一个缓存行，就彼此影响
    + 可以先检查卡表标记，只有当卡表元素没有被标记时才标记为变脏

## 并发的可达性分析

+ 从GC Roots再继续往下遍历对象图的时间与堆容量成正比

+ 三色标记法，如果收集器再对象图上标记颜色，同时用户线程在修改引用关系（对象图的结构）

+ 两种可能：

    + 把原本消亡的对象误标记为存活，可以接受。只是产生了逃过本次收集的浮动垃圾
    + 把原本存活的对象误标记为消亡，非常致命

+ 对象消亡两个条件

    + 新增了黑色到白色对象的新引用。
    + 删除了灰色到该白色对象的所有引用

+ 两种解决，破坏两个条件之一即可。都是通过写屏障实现

    + 增量更新。理解为当黑色对象一旦插入了指向白色对象的引用后，它就变回灰色对象。
    + 原始快照。无论引用对象删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。

    

# 经典垃圾收集器

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/abcd.png)

## Young generation

### Serial收集器

+ 单线程工作的收集器
+ 在进行垃圾收集时，必须先暂停其他所有线程，直到它收集结束
+ 客户端模式下默认的新生代收集器，简单而高效
+ 对于内存资源受限的环境下，是所有收集器里额外内存消耗最小的
+ 对于单核处理器或核心较少的环境收集效率最高

### ParNew收集器

+ 是Serial收集器的多线程并发版本
+ 除了Serial收集器，只有它能和CMS收集器配合
+ 在单线程环境下不比Serial收集器好
+ 也是需要STW，只是多线程一起并发收集罢了

### Parallel Scavenge收集器

+ 同样基于标记-复制算法，同样并行收集的多线程收集器
+ 称作吞吐量优先收集器
+ 可以达到一个可控制的吞吐量，即处理器用于运行用户代码的时间/处理器总消耗时间
+ 垃圾收集的自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或最大吞吐量

## Tenured generation

### Serial Old收集器

+ 单线程收集器，使用标记-整理算法
+ 供客户端模式使用
+ 可作为CMS收集器发生失败时的后备预案
+ 可以配合Parallel Scavenge收集器

### Parallel Old收集器

+ 支持多线程并发收集
+ 使用标记-整理算法
+ 吞吐量优先收集器有了比较好的组合：Parallel Scavenge收集器+ Parallel Old收集器

### CMS收集器

+ Concurrent Mark Sweep
+ 以最短回收停顿时间为目标的收集器
+ 并发收集，低停顿
+ 基于标记-清除算法
+ 互联网网站等Java项目通常较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验

**步骤**

![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/Rc4defd801698e946aa0b9bc91d8fc4f6)

+ 初始标记：标记一下GC Roots能直接关联的对象，速度很快。需要STW
+ 并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长，但不需要停顿用户线程
+ 重新标记：需要STW，修改并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，使用增量更新
+ 并发清除：可以与用户线程同时并发的，清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象。时间较长

**缺点**

+ 对处理器资源非常敏感：并发阶段，占用一部分线程导致应用程序变慢，降低总吞吐量
+ 无法处理浮动垃圾
    + 由于垃圾收集阶段用户线程需要持续运行，程序运行自然还会伴随有新的垃圾对象产生，而且这些垃圾对象是出现在标记过程结束之后，CMS无法在当次收集中处理掉他们，只好留待下一次垃圾收集时再清理掉，即浮动垃圾。
    + 而且用户线程需要持续运行，所以需要预留足够的内存空间给用户线程使用(默认92%)
    + 如果运行期间预留的内存无法满足程序分配新对象的需要，可能出现Concurrent Mode Failure(并发失败)
    + 则不得不启动后背方案：冻结用户线程的执行，临时启用Serial Old收集器来进行老年代的垃圾收集
+ 基于标记清除算法，会产生大量的空间碎片：无法找到足够大的连续空间来分配给当前对象，不得不提前Full GC

## Garbage First收集器

+ 面向局部收集，基于Region的内存布局，全功能垃圾收集器
+ 主要面向服务器应用，服务器模式下默认的垃圾收集器
+ 建立停顿时间模型，支持指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒
+ Mixed GC模式：面向堆的任何部分来组成回收集，衡量哪块内存中存放的垃圾数量最多，回收收益最大
+ 非常精确地控制停顿

### 实现

+ 把连续的Java堆划分为多个大小相等的独立区域
+ 每个Region可以扮演新生代的Eden、Survivor或老年代空间
+ Humongous区域，专门存储大对象：大小超过Region容量一半的对象、超级大对象放在连续的Humongous区域、把Humongous区域看作老年代
+ 将Region作为单位回收的最小单元，每次回收Region的整数倍
+ 让G1去跟踪各个Region里面垃圾的价值大小（回收所获得的空间大小以及回收所需时间的经验值）
+ 在后台维护一个优先级列表，优先处理回收价值收益最大的region

### 细节

+ 跨Region引用对象

    + 每个Region都维护自己的记忆集
    + 记录别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内
    + 是一个哈希表，Key是别的Region起始地址，Value是卡表索引号集合
    + 至少要耗费堆的10%-20%额外内存来维持收集器工作

+ 并发标记阶段

    + 对象引用关系改变，不打破原有对象图。使用原始快照（SATB）算法
    + 新对象创建：设计两个指针，名为TAMS(Top at Mark Start)，把Region中一部分空间划分出来用于并发回收过程中的新对象分配，新分配对象必须在两个指针位置以上，默认这些对象是存活的，如果内存回收速度赶不上内存分配速度，也要STW的Full GC。

+ 建立可靠的停顿预测模型

    + 记录每个Region的回收耗时、记忆集中脏卡数量等成本，计算统计信息

    + 比普通平均值更容易收到新数据的影响，衰减平均值更准确的代表最近的平均状态

    + Region的统计状态越新越能决定其回收价值

    + 通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高收益

        

### 步骤

+ 初始标记
    + 标记GC Roots能直接关联到的对象
    + 修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用Region上分配新对象
    + 需要停顿线程，但耗时短，而且是借用Minor GC同步完成的，没有额外停顿
+ 并发标记
    + 堆中对象的可达性分析，递归扫描整个堆中对象图
    + 耗时长，能与用户线程并发执行
    + 处理在SATB记录下的在并发时有引用变动的对象
+ 最终标记
    + 对用户线程做另一个短暂暂停，处理并发阶段结束后遗留下来的最后那少量的SATB记录
+ 筛选回收
    + 更新Region的统计数据
    + 对Region的回收价值和成本排序
    + 根据用户所期望的停顿时间制定回收计划
    + 把决定回收的Region的存活对象复制到空Region中，清理旧Region的全部空间
    + 必须STW，由多条垃圾收集器线程并发完成

### 特点

+ 在延迟可控的情况下获得尽可能高的吞吐量

+ 取得关注吞吐量和关注延迟之间的最佳平衡

+ 如果停顿时间过短，会导致每次筛选出来的回收集只占堆内存很小一部分，最终占满堆引发Full GC降低性能，停顿时间设置在100-300ms之间比较合理

+ 整体是基于标记-整理的

+ 局部是基于标记-复制的

+ 不会产生内存空间碎片，收集后能提供规整的可用内存

+ 使用写后屏障进行卡表维护操作

+ 使用写前屏障来跟踪并发时的指针变化，实现SATB算法

+ 小内存上CMS大概率优于G1（6-8GB为平衡点）

    

# 垃圾收集实战

+ 实验环境：HotSpot、客户端模式、Serial+Serial Old
+ 对象的内存分配：大部分堆上分配，极小部分经过即时编译后拆散为标量类型并间接栈上分配
+ 新生对象通常分配新生代，少数情况（对象大小超过阈值）直接分配老年代

## 对象优先在Eden分配

+ 大多数情况下，对象在Eden区分配，如果Eden区没有足够空间分配，将发起Minor GC
+ MinGC中，如果Survivor放不下Eden存活的，则通过对象担保机制，把存活的放入老年代
+ -Xms20M -Xmx20M：堆大小20M，不可扩展
+ -Xmn10M：10MB分配给新生代
+ -XX:SurvivorRatio=8：Eden：Survivor = 8：1，新生代总可用区间9216KB(Eden+一个Survivor)
+ -XX:+PrintGCDetails

```
VM参数:
-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:SurvivorRatio=8 
-XX:+PrintGCDetails
```

```java
public class Main{
    private static final int _1MB = 1024 * 1024;

    public static void main(String[] args) {
        byte[] allocation1， allocation2， allocation3， allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB]; //出现Minor GC
    }
}
```

```java
[GC (Allocation Failure) [DefNew: 8159K->626K(9216K)， 0.0041610 secs] 8159K->6770K(19456K)， 0.0042168 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] 
Heap
 def new generation   total 9216K， used 4888K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)
  eden space 8192K，  52% used [0x00000000fec00000， 0x00000000ff029840， 0x00000000ff400000)
  from space 1024K，  61% used [0x00000000ff500000， 0x00000000ff59c960， 0x00000000ff600000)
  to   space 1024K，   0% used [0x00000000ff400000， 0x00000000ff400000， 0x00000000ff500000)
 tenured generation   total 10240K， used 6144K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)
   the space 10240K，  60% used [0x00000000ff600000， 0x00000000ffc00030， 0x00000000ffc00200， 0x0000000100000000)
 Metaspace       used 3253K， capacity 4496K， committed 4864K， reserved 1056768K
  class space    used 353K， capacity 388K， committed 512K， reserved 1048576K

Process finished with exit code 0

```

## 大对象直接进入老年代

+ 大对象就是需要连续内存空间的Java对象
+ 很长的字符串或者元素数量很庞大的数组
+ 在程序中避免出现一群朝生夕灭的短命大对象
+ 他容易导致内存明明还有不少空间就提前触发了垃圾收集，以获取足够的连续空间才能安置好他们
+ 当复制对象时，大对象意味着高额的内存复制开销
+ -XX:PretenureSizeThreshold=3145728
+ 可设置参数，指定大于设定值的对象直接在老年代分配，避免在Eden区以及两个Survivor区来回复制，产生大量的内存复制操作

```java
-XX:PretenureSizeThreshold=3145728 
-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC 
-XX:SurvivorRatio=8 -XX:+PrintGCDetails
```



```java
public class Main{
    private static final int _1MB = 1024 * 1024;

    public static void main(String[] args) {
        byte[] allocation1;
        allocation1 = new byte[4 * _1MB];//直接分配在老年代
    }
}
```

```java
Heap
 def new generation   total 9216K， used 2015K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)
  eden space 8192K，  24% used [0x00000000fec00000， 0x00000000fedf7e90， 0x00000000ff400000)
  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff400000， 0x00000000ff500000)
  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)
 tenured generation   total 10240K， used 4096K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)
   the space 10240K，  40% used [0x00000000ff600000， 0x00000000ffa00010， 0x00000000ffa00200， 0x0000000100000000)
 Metaspace       used 3210K， capacity 4496K， committed 4864K， reserved 1056768K
  class space    used 352K， capacity 388K， committed 512K， reserved 1048576K
```

## 长期存活的对象将进入老年代

+ 每个对象对象头定义了一个对象年龄计数器
+ 对象通常在Eden区诞生，如果经过第一次Minor GC仍然存活，并且能被Survivor容纳，则被移动到Survivor空间中，并且年龄设置为1
+ 对象在Survivor区每熬过一次Minor GC，年龄+1
+ 增长到15时，就会被晋升到老年代，晋升阈值通过-XX:MaxTenuringThreshold设置
+ 当-XX:MaxTenuringThreshold设置为1时，allocation1在第二次GC发生时进入老年代

```java
-XX:+PrintTenuringDistribution -XX:MaxTenuringThreshold=1 
-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC 
-XX:SurvivorRatio=8 -XX:+PrintGCDetails
```

```java
public class Main {
    private static final int _1MB = 1024 * 1024;

    public static void main(String[] args) {
        byte[] allocation1， allocation2， allocation3;
        allocation1 = new byte[_1MB / 4];//什么时候进入老年代决定于-XX:MaxTenuringThreshold设置
        allocation2 = new byte[4 * _1MB];
        allocation3 = new byte[4 * _1MB];
        allocation3 = null;
        allocation3 = new byte[4 * _1MB];
    }
}
```

```java
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes， new threshold 1 (max 1)
- age   1:     886440 bytes，     886440 total
: 6367K->865K(9216K)， 0.0055780 secs] 6367K->4961K(19456K)， 0.0056123 secs] [Times: user=0.00 sys=0.00， real=0.01 secs] 
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes， new threshold 1 (max 1)
- age   1:        680 bytes，        680 total
: 5045K->0K(9216K)， 0.0012428 secs] 9141K->4958K(19456K)， 0.0012696 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] 
Heap
 def new generation   total 9216K， used 4235K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)
  eden space 8192K，  51% used [0x00000000fec00000， 0x00000000ff022a70， 0x00000000ff400000)
  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff4002a8， 0x00000000ff500000)
  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)
 tenured generation   total 10240K， used 4958K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)
   the space 10240K，  48% used [0x00000000ff600000， 0x00000000ffad7800， 0x00000000ffad7800， 0x0000000100000000)
 Metaspace       used 3286K， capacity 4496K， committed 4864K， reserved 1056768K
  class space    used 357K， capacity 388K， committed 512K， reserved 1048576K
```

## 动态对象年龄判断

如果在Survivor空间中相同年龄所有对象大小的总和大于Survovor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代

```java
-XX:+PrintTenuringDistribution -XX:MaxTenuringThreshold=1 
-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC 
-XX:SurvivorRatio=8 -XX:+PrintGCDetails
```

```java
public class Main {
    private static final int _1MB = 1024 * 1024;

    public static void main(String[] args) {
        byte[] allocation1， allocation2， allocation3， allocation4;
        allocation1 = new byte[_1MB / 4];//allocation1 + allocation2 大于 survivor空间的一半了
        allocation2 = new byte[_1MB / 4];
        allocation3 = new byte[4 * _1MB];
        allocation4 = new byte[4 * _1MB];
        allocation4 = null;
        allocation4 = new byte[4 * _1MB];
    }
}
```

```java
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes， new threshold 1 (max 15)
- age   1:    1048576 bytes，    1048576 total
: 6623K->1024K(9216K)， 0.0039616 secs] 6623K->5234K(19456K)， 0.0040033 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] 
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes， new threshold 15 (max 15)
- age   1:        176 bytes，        176 total
: 5204K->0K(9216K)， 0.0011999 secs] 9414K->5234K(19456K)， 0.0012304 secs] [Times: user=0.00 sys=0.00， real=0.00 secs] 
Heap
 def new generation   total 9216K， used 4234K [0x00000000fec00000， 0x00000000ff600000， 0x00000000ff600000)
  eden space 8192K，  51% used [0x00000000fec00000， 0x00000000ff0227f0， 0x00000000ff400000)
  from space 1024K，   0% used [0x00000000ff400000， 0x00000000ff4000b0， 0x00000000ff500000)
  to   space 1024K，   0% used [0x00000000ff500000， 0x00000000ff500000， 0x00000000ff600000)
 tenured generation   total 10240K， used 5234K [0x00000000ff600000， 0x0000000100000000， 0x0000000100000000)
   the space 10240K，  51% used [0x00000000ff600000， 0x00000000ffb1c9a0， 0x00000000ffb1ca00， 0x0000000100000000)
 Metaspace       used 3247K， capacity 4496K， committed 4864K， reserved 1056768K
  class space    used 353K， capacity 388K， committed 512K， reserved 1048576K
```

## 空间分配担保

+ 在Minor GC前，检查老年代最大可用连续空间是否大于新生代的所有对象空间，如果成立，则这次Minor GC安全。
+ 否则要看是否允许担保失败。如果允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的平均大小，如果大于，将尝试进行一次Minor GC。如果小于，或者不允许担保，则Full GC。
+ 新生代中，当出现大量对象在Minor GC后仍然存活的情况，就把Survivor无法容纳的对象直接送入老年代，担保前提是老年代本身有容纳这些对象的剩余空间。
+ 但一共有多少对象会在这次回收中存活下来在实际回收完成之前是无法明确知道的，只能取之前每一次回收晋升老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间
+ 担保失败则又得Full GC，绕的圈子最大，但一般打开，避免Full GC过于频繁
+ 在JDK7及之后。不能设置参数影响空间分配担保策略。只要老年代最大可用连续空间大于新生代的所有对象空间，或者大于历次晋升到老年代的平均大小，就进行Minor GC，负责Full GC（相当于一定会冒险）

