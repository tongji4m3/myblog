---
title: 集合基础
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 'Java集合基础,如HashTable、集合安全、CopyOnWriteArrayList、迭代器机制、快速失败等'
categories: Java集合
tags:
  - 集合
  - 迭代器
  - CopyOnWriteArrayList
abbrlink: ca057823
date: 2020-12-16 00:00:00
---



# 基本知识

+ HashMap快,TreeMap按照比较结果的升序保存键,LinkedHashMap按照插入顺序保存键,还保留了HashMap的查询速度
+ HashSet快,TreeSet按比较结果升序排列,LinkedHashSet按照被添加顺序保存对象
+ ArrayList,LinkedList按照被插入的顺序保存元素,使用LinkedList来实现queue,stack
+ AbstractCollection是提供Collection部分实现的抽象类
+ 如果除了在末尾外不能在其他位置插入或者删除元素，那么ArrayList效率更高，如果需要经常插入或者删除元素，就选择LinkedList

# HashTable

+ 比HashMap多了个线程安全,直接在方法上锁，并发度很低，最多同时允许一个线程访问，效率比较低下

+ HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。也就是说对于Hashtable而言，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占。相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下。

+ Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。

    + Hashtable在我们put 空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理。
    + Hashtable使用的是安全失败机制（fail-safe），这种机制会使你此次读到的数据不⼀定是最新的数据。
    + 如果你使⽤null值，就会使得其⽆法判断对应的key是不存在还是为空，因为你⽆法再调⽤一次contain(key）来对key是否存在进⾏判断，ConcurrentHashMap同理。
    + HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。

+ 初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。

+ 扩容机制不同：当现有容量大于总容量 * 负载因⼦时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。

+ 迭代器不同：HashMap 中的 Iterator 迭代器是 fail-fast 的，⽽ Hashtable 的 Enumerator 不是 failfast 的

+ HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。

+ HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。

    

# Set

## HashSet

### 性质

+ 不保证集合顺序
+ 允许null值
+ HashSet 不允许重复的值

### 实现

+ HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT
+ private transient HashMap<E,Object> map;底层使用HashMap来保存HashSet中所有元素
+ private static final Object PRESENT = new Object();定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final
+ add()；添加成功则返回true

```java
public boolean add(E e) {

    //因为put会返回原Value,如果放入相同的,则返回就不为null

    //则该方法返回false,代表添加不成功,代表已经有了元素

    return map.put(e, PRESENT)==null;

}
```

## TreeSet

红黑树

## LinkedHashSet

+ LinkedHashSet 内部是通过 LinkedHashMap 来实现的。
+ 继承HashSet
+ LinkedHashSet的构造器调用父类HashSet的其中一个构造器，将map初始化为LinkedHashMap,所以再调用方法时,就会有LinkedHashMap的调用效果
+ 用双向链表维持元素的插入顺序
+ 重新插入时不会影响顺序

# Queue

## Deque

### 栈

+ push(E e)，调用addFirst(e);
+ pop()，调用removeFirst();
+ peek()，获取首部元素

### 队列

+ offer(E e)，调用linkLast(e)
+ poll()，获取并删除首部元素
+ peek()，获取首部元素

## BlockingQueue

+ 是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。
+ 主要用于实现生产者-消费者模式。
+ ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等

# 集合安全

+ 提供了包装器工厂方法(例如Collections.synchronizedList等).他们将容器类封装在一个同步的包装器对象中,而包装器能将接口中的每个方法都实现为同步方法,并将调用请求转发到底层的容器对象中,使得每次只有一个线程能访问容器的状态
+ CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ArrayBlockingQueue、LinkedBlockingQueue、ConcurrentLinkedQueue、ConcurrentLinkedDeque
+ 同步容器类是线程安全的,但复合操作仍然需要额外的客户端加锁来保护,例如迭代
+ 尽管Vector线程安全,仍然需要用synchronized保护复合操作

## Collections.synchronizedMap(Map)

+ 在SynchronizedMap内部维护了⼀个普通对象Map，还有排斥锁mutex
+ 我们在调⽤这个⽅法的时候就需要传⼊⼀个Map，可以看到有两个构造器，如果你传⼊了mutex参数，则将对象排斥锁赋值为传⼊的对象。如果没有，则将对象排斥锁赋值为this，即调⽤synchronizedMap的对象，就是上⾯的Map
+ 创建出synchronizedMap之后，再操作map的时候，就会对⽅法上锁

## CopyOnWriteArrayList

+ 写时复制容器,往一个容器中添加元素的时候,不直接往当前容器的`Object[]`添加,而是将当前容器`Object[]`进行`Copy`,复制出一个新的`Object[] newElements`,然后往新的`newElements`中添加元素` setArray(newElements)`
+ 可以对`CopyOnWrite`容器进行并发的读而不需要加锁,因为当前容器不会添加任何元素
+ 是一种读写分离的思想,读和写不同的元素,适用于读多写少
+ 最后再将原容器的引用指向新的容器

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        //拷贝一份进行写操作
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        //通知系统写完成
        return true;
    } finally {
        //释放锁
        lock.unlock();
    }
}
```

# 迭代器机制

+ 用迭代器来表示容器之间的共性,实现Collection就意味着需要提供iterator()方法,因为Collection继承了Iterable接口
+ 创建了任何实现Iterable接口的类,都可以用于foreach语句中
+ 数组也能使用foreach,但是不存在任何从数组到Iterable的自动转换

## 快速失败（fail-fast）

+ 快速失败（fail—fast）是java集合中的一种机制，在用迭代器遍历一个集合对象时，如果遍历过程中有另一个线程对集合对象的内容进行了修改,则会抛出ConcurrentModificationException

+ 迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。

+ 每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。

+ java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）

+ 隐式的迭代器,就是没有显示调用,但是也用到了迭代器，例如直接打印集合System.out.println(set)

+ 会快速失败的方法：put(),remove(),clear(),resize()

+ 解决办法

    + 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized
    + 使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。
    + 如果不希望在迭代过程中加锁,可以选择克隆容器,并在副本上进行迭代,但是克隆时还是要对容器进行加锁
    + List<String> list=Collections.synchronizedList(new ArrayList<>());
    + List<String> list = new CopyOnWriteArrayList<>(); //写时复制 

    

## 安全失败（fail—safe）

+ fail-safe允许在遍历的过程中对容器中的数据进行修改
+ 这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历
+ java.util.concurrent包下的容器都是安全失败的,可以在多线程下并发使用,并发修改。
+ 常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList
+ 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。
+ 基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。
+ 所得到的Iterator中的elements只是CopyOnWriteArrayList中array的拷贝，当对CopyOnWriteArrayList中array操作时并不会影响到Iterator中的elements，因此永远都不会抛出安全失败的异常。但也是因为这个，无法保证读取的数据是目前原始数据结构中的数据。