---
title: HashMap
author: tongji4m3
top: true
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: Java集合HashMap，包括底层实现、初始化、tableSizeFor、resize等
categories: Java集合
tags:
  - 集合
  - HashMap
  - 源码
abbrlink: 3d614825
date: 2020-12-22 00:00:00
---



# HashMap

## 结构

+ HashMap是基于哈希表的Map接口的非同步实现.
+ 采用了（数组 + 链表 + 红黑树）的结构
+ HashMap的table默认初始容量为16（1<<4），默认负载因子为0.75f，容量总是2的n次方
+ 16是一个经验值，既然一定要设置一个默认的2^n 作为初始值，那么就需要在效率和内存使用上做一个权衡.太小了就有可能频繁发生扩容，影响效率.太大了又浪费空间，不划算.

## 特点

+ 允许使用null值和null键
+ 它不保证映射的顺序，特别是它不保证该顺序恒久不变.
+ HashMap查找添加元素的时间复杂度都为O(1)
+ 数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率.
+ 都实现了Comparable时用比较来排序树(用反射实现)，否则用hashcode.这样在hashCode不均匀的情况下表现较好
+ 为它的子类LinkedHashMap提供一些钩子方法
+ 默认null值hash为0

## 树化与反树化

+ 当同一个索引位置的节点在增加后达到8个时，并且此时数组的长度大于等于 64，则则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持.
+ 链表节点转红黑树节点的具体方法为源码中的 treeifyBin 方法.而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容.
+ 链表中节点个数为8时的概率为 0.00000006
+ 当单个桶中元素数量小于6时，进行反树化

## 初始化

+ HashMap 有 threshold 属性和 loadFactor 属性，但是没有 capacity 属性.初始化时，如果传了初始化容量值，该值是存在 threshold 变量
+ Node 数组是在第一次 put 时才会进行初始化
+ 初始化时会将此时的 threshold 值作为新表的 capacity 值，然后用 capacity 和 loadFactor 计算新表的真正 threshold 值.

# 继承体系

```java
public class HashMap<K， V> extends AbstractMap<K， V>
        implements Map<K， V>， Cloneable， Serializable
```



# 参数

```java
 //序列号
private static final long serialVersionUID = 362498820763181265L;

// 默认的初始容量是16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16


static final int MAXIMUM_CAPACITY = 1 << 30;


static final float DEFAULT_LOAD_FACTOR = 0.75f;

//树化至少应该为8
static final int TREEIFY_THRESHOLD = 8;

//反树化阈值
static final int UNTREEIFY_THRESHOLD = 6;

// 桶中结构转化为红黑树对应的table的最小大小
static final int MIN_TREEIFY_CAPACITY = 64;


//第一次put时初始化
//存储元素的数组，总是2的幂次倍
transient Node<K， V>[] table;


//遍历时经常用到的
transient Set<Map.Entry<K， V>> entrySet;


// 存放元素的个数，注意这个不等于数组的长度.
transient int size;


// 每次扩容和更改map结构的计数器
transient int modCount;


//    threshold表示当HashMap的size大于threshold时会执行resize操作.
//    threshold=capacity*loadFactor
int threshold;


final float loadFactor;

```

# Node

```java

//Map.Entry是Map的一个内部接口.表示Map中一个key-value对.接口有getKey()，getValue方法.
static class Node<K， V> implements Map.Entry<K， V> {
    final int hash;
    final K key;
    V value;
    HashMap.Node<K， V> next;

    Node(int hash， K key， V value， HashMap.Node<K， V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }

    public final String toString() {
        return key + "=" + value;
    }

    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry<?， ?> e = (Map.Entry<?， ?>) o;
            if (Objects.equals(key， e.getKey()) &&
                    Objects.equals(value， e.getValue()))
                return true;
        }
        return false;
    }
}
```

# hash

```java
/*
默认null值hash为0
拿到 key 的 hashCode 值
将 hashCode 的高位参与运算，重新计算 hash 值
 */
static final int hash(Object key) {
    int h;
    //源码喜欢在 if/for 等语句中进行赋值并判断
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

# tableSizeFor

```java
/*
    例如10001(17)
    首先cap-1:     10000
    n |= n >>> 1: n=(10000 | 01000) =11000
    n |= n >>> 2: n=(11000 | 00110) =11110
    n |= n >>> 4: n=(11110 | 00001) =11111
    n |= n >>> 8: n=(11111 | 00000) =11111
    n |= n >>> 16: n=(11111 | 00000) =11111
    return n+1:100000(32)
    ...
    因为int为32位，所以为了保证结果，最后右移16位结束
    使得要求的数字1开始的后面全为1
 */
    //大于等于输入参数且最近的2的整数次幂的数
    //无符号右移>>>: 就是右移之后，无论该数为正还是为负，右移之后左边都是补上0
    static final int tableSizeFor(int cap)
    {
        //cap-1是为了例如16这些之后还是16
        //如果没有这一步，10000则会变成11111，最后100000(32)，不符合
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```

# 初始化

```java
    //开始没有赋值给capacity，而是给了threshold
    public HashMap(int initialCapacity， float loadFactor)
    {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                    initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                    loadFactor);
      //此处仅用于接收初始容量大小（capacity）、加载因子(Load factor)，
        //但仍无真正初始化哈希表，即初始化存储数组table
        //此处不是真正的阈值，该阈值后面会重新计算
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);//得到大于他的最小二次幂
    }


    public HashMap(int initialCapacity)
    {
        this(initialCapacity， DEFAULT_LOAD_FACTOR);
    }

    //这里没传入DEFAULT_CAPACITY
    public HashMap()
    {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
```

# HashMap(Map<? extends K， ? extends V> m)

```java
 public HashMap(Map<? extends K， ? extends V> m)
    {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m， false);
    }

    //如果是构造方法，则evict为false
    final void putMapEntries(Map<? extends K， ? extends V> m， boolean evict)
    {
        int s = m.size();
        if (s > 0)
        {
            if (table == null)// 说明是拷贝构造函数来调用的putMapEntries，或者构造后还没放过任何元素
            { // pre-size
                float ft = ((float) s / loadFactor) + 1.0F;//计算出所需容量，因为之后要向下取整，所以再+1
                //始终不能超过最大容量
                int t = ((ft < (float) MAXIMUM_CAPACITY) ?
                        (int) ft : MAXIMUM_CAPACITY);
//                这里的threshold成员实际存放的值是capacity的值.
//                因为在table还没有初始化时（table还是null），用户给定的capacity会暂存到threshold成员上去
                if (t > threshold)
                    threshold = tableSizeFor(t);//大于它的最小的二次幂
            }
            else if (s > threshold)
                resize();//说明原本有，但是原本的位置不够了
            //循环里的putVal可能也会触发resize
            for (Map.Entry<? extends K， ? extends V> e : m.entrySet())
            {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key)， key， value， false， evict);
            }
        }
    }
```

# get

```java
//key为null也可能是本身就是存储null的key
public V get(Object key)
{
    Node<K， V> e;
    return (e = getNode(hash(key)， key)) == null ? null : e.value;
}

final Node<K， V> getNode(int hash， Object key)
{
    Node<K， V>[] tab;
    Node<K， V> first， e;
    int n;
    K k;
    //table不为空，table长度不为0，table相应的索引位置不为空
    if ((tab = table) != null && (n = tab.length) > 0 &&
            (first = tab[(n - 1) & hash]) != null)
    {
        //因为索引相同hash却不一定相同(多个hash映射到同一个槽)
        //hash相同并不一定是键相同，还要检查键是否相同或相等
        if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        if ((e = first.next) != null)
        {
            //如果是红黑树节点，则调用红黑树的查找目标节点方法getTreeNode
            if (first instanceof TreeNode)
                return ((TreeNode<K， V>) first).getTreeNode(hash， key);
            do
            {
                //执行链表节点的查找，向下遍历链表， 直至找到节点的key和入参的key相等时，返回该节点
                if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}


public boolean containsKey(Object key)
{
    return getNode(hash(key)， key) != null;
}
```

# put

## 步骤

+ ①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；
+ ②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；
+ ③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；
+ ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；
+ ⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；
+ ⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容.

## 代码

```java
    /*
    put相同键会替代
    返回被替换的那个key的value或者null
     */
    public V put(K key， V value)
    {
        return putVal(hash(key)， key， value， false， true);
    }


    /*
    onlyIfAbsent 当键相同时，不修改已存在的值
    evict        仅在创建时为false
    返回值 先前的值或null
     */
    final V putVal(int hash， K key， V value， boolean onlyIfAbsent，
                   boolean evict)
    {
        Node<K， V>[] tab;
        Node<K， V> p;//当前节点
        int n， i;
//        校验table是否为空或者length等于0，如果是则调用resize方法进行初始化
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //直接新建节点，多好
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash， key， value， null);
        else
        {
            Node<K， V> e;
            K k;
            //直接覆盖相同的值p
            if (p.hash == hash &&
                    ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
                //调用红黑树的put方法
            else if (p instanceof TreeNode)
                e = ((TreeNode<K， V>) p).putTreeVal(this， tab， hash， key， value);
            else
            {
                //binCount记录是否需要树化
                for (int binCount = 0; ; ++binCount)
                {
                    //1.8采用了尾插法
                    if ((e = p.next) == null)
                    {
                        p.next = newNode(hash， key， value， null);
                        // 校验节点数是否超过TREEIFY_THRESHOLD，如果超过则调用treeifyBin方法将链表节点转为红黑树节点，
                        // 减一是因为前面加了节点，但是binCount没更新
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab， hash);
                        break;//此时break，e==null，不会进入 if (e != null)
                    }
                    //说明存在相同的key，要修改
                    if (e.hash == hash &&
                            ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                    //继续遍历下一个Node
                }
            }
            //代表目标节点存在，使用传入的value覆盖该节点的value，并返回oldValue
            if (e != null)
            {
                //说明要放的位置之前存在了元素
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);// 用于LinkedHashMap
                return oldValue;
            }
        }
        ++modCount;
        //插入则size+1，而且大于threshold则需要扩容了
        if (++size > threshold)
            resize();
        // 用于LinkedHashMap的钩子函数
        afterNodeInsertion(evict);
        return null;
    }
```

# resize

+ 扩容前的table不为空，即正常的扩容操作.将容量变成原来的两倍
+ 如果老表的容量为0， 老表的阈值大于0， 是因为初始容量被放入阈值，则将新表的容量设置为老表的阈值
    + 对应前两种初始化HashMap的方法 例如new HashMap<>(32)
+ 老表的容量为0， 老表的阈值为0，这种情况是没有传初始容量的new方法创建的空表，将阈值和容量设置为默认值
    + 即初始化的第三种情况 new HashMap()
    + 默认容量16，负载因子0.75f
+ Node<K， V>[] newTab = (Node<K， V>[]) new Node[newCap];
    + 说明在第一次调用resize()方法时才进行了tab的初始化
+ 如果老表不为空，则需遍历所有节点，将节点赋值给新表

```java
/*
初始化或扩容
 */
final Node<K， V>[] resize()
{
    Node<K， V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap， newThr = 0;

    //扩容前的table不为空，即正常的扩容操作.将容量变成原来的两倍
    if (oldCap > 0)
    {
        if (oldCap >= MAXIMUM_CAPACITY)
        {
            //阈值设为最大，但是不扩容
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
        //容量和阈值都*2扩容
    }
    //如果老表的容量为0， 老表的阈值大于0， 是因为初始容量被放入阈值，则将新表的容量设置为老表的阈值
    //对应前两种初始化HashMap的方法 例如new HashMap<>(32)
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else
    {
        //老表的容量为0， 老表的阈值为0，这种情况是没有传初始容量的new方法创建的空表，将阈值和容量设置为默认值
        //即初始化的第三种情况 new HashMap()
        // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }

    //对应前两种初始化方法，之前的threshold已经在初始化newCap时用过了
    if (newThr == 0)//计算新的负载因子
    {
        //很合理，假如new HashMap(32)，即ft=32*0.75
        float ft = (float) newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float) MAXIMUM_CAPACITY ?
                (int) ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    //说明在第一次调用resize()方法时才进行了tab的初始化
    @SuppressWarnings({"rawtypes"， "unchecked"})
    Node<K， V>[] newTab = (Node<K， V>[]) new Node[newCap];
    table = newTab;
    //如果老表不为空，则需遍历所有节点，将节点赋值给新表
    if (oldTab != null)
    {
        for (int j = 0; j < oldCap; ++j)
        {
            Node<K， V> e;
                if ((e = oldTab[j]) != null)// 将索引值为j的老表头节点赋值给e
            {
                oldTab[j] = null;// 将老表的节点设置为空， 以便垃圾收集器回收空间
                if (e.next == null)//只有一个节点，直接散列
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)//调用红黑树的重新散列
                    ((TreeNode<K， V>) e).split(this， newTab， j， oldCap);
                else
                { // preserve order
                    Node<K， V> loHead = null， loTail = null;
                    Node<K， V> hiHead = null， hiTail = null;
                    Node<K， V> next;
                    do
                    {
                        next = e.next;
                        /*
                        例如 3和19，00011，10011
                        如果oldCap=10000(16)
                        00011 & 10000 = 0
                        10011 & 10000 = 10000 != 0
                        将原本在一个索引的分成两条链表
                         */
                        //因为扩容为原来两倍，所以根据oldCap的最高位，来把链表区分成两块链表
                        //如果 e 的 hash 值与老表的容量进行位与运算为 0，则说明 e 节点扩容后的索引位置跟老表的索引位置一样
                        if ((e.hash & oldCap) == 0)
                        {
                            //好强的代码，巧妙的构造了链表
                            //还是尾插法，尾插法就要维护一个头部(loHead)，以及当前指针(loTail)
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else
                        {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);//散列开来
                    if (loTail != null)
                    {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null)
                    {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;//放在新的位置
                    }
                }
            }
        }
    }
    return newTab;
}
```

# treeifyBin

```java
//转为红黑树节点后，链表的结构还存在，通过 next 属性维持，红黑树节点在进行操作时都会维护链表的结构
//    在红黑树上，叶子节点也可能有 next 节点，因为红黑树的结构跟链表的结构是互不影响的
    final void treeifyBin(Node<K， V>[] tab， int hash)
    {
        int n， index;
        Node<K， V> e;
        //如果table为空或者table的长度小于64， 调用resize方法进行扩容
        if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
            resize();
        else if ((e = tab[index = (n - 1) & hash]) != null)
        {
            TreeNode<K， V> hd = null， tl = null;
            //这一步只是构造了一个双向链表
            do
            {
                //将链表节点转红黑树节点，但是没有构建成树
                TreeNode<K， V> p = replacementTreeNode(e， null);
                //第一次循环将头节点赋值给hd
                if (tl == null)
                    hd = p;
                else
                {
                    p.prev = tl;//循环只是赋值给了prev，还没构建红黑树
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null);

            //将table该索引位置赋值为新转的TreeNode的头节点，如果该节点不为空，则以以头节点(hd)为根节点， 构建红黑树
            if ((tab[index] = hd) != null)
                hd.treeify(tab);
        }
    }
```

# remove

```java
//返回null可能本来就绑定了null，也可能是找不到key
public V remove(Object key)
{
    Node<K， V> e;
    return (e = removeNode(hash(key)， key， null， false， true)) == null ?
            null : e.value;
}
```

```java
/*
matchValue if true only remove if value is equal
movable    if false do not move other nodes while removing
*/
final Node<K， V> removeNode(int hash， Object key， Object value，
                            boolean matchValue， boolean movable)
{
    Node<K， V>[] tab;
    Node<K， V> p;
    int n， index;
    if ((tab = table) != null && (n = tab.length) > 0 &&
            (p = tab[index = (n - 1) & hash]) != null)
    {
        Node<K， V> node = null， e;
        K k;
        V v;
        //找到要删除的那个节点
        if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
            node = p;
        else if ((e = p.next) != null)
        {
            if (p instanceof TreeNode)
                node = ((TreeNode<K， V>) p).getTreeNode(hash， key);
            else
            {
                do
                {
                    if (e.hash == hash &&
                            ((k = e.key) == key ||
                                    (key != null && key.equals(k))))
                    {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        //是否需要值相同才删除
        if (node != null && (!matchValue || (v = node.value) == value ||
                (value != null && value.equals(v))))
        {
            if (node instanceof TreeNode)
                ((TreeNode<K， V>) node).removeTreeNode(this， tab， movable);
            else if (node == p)//说明删除的是头元素
                tab[index] = node.next;
            else //p是要删除元素的前一个元素(对应上面的else if)
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);//删除后的钩子方法
            return node;
        }
    }
    return null;
}
```

# containsValue

暴力搜索所有节点

```java
public boolean containsValue(Object value)
{
    Node<K， V>[] tab;
    V v;
    if ((tab = table) != null && size > 0)
    {
        for (int i = 0; i < tab.length; ++i)
        {
            for (Node<K， V> e = tab[i]; e != null; e = e.next)
            {
                if ((v = e.value) == value ||
                        (value != null && value.equals(v)))
                    return true;
            }
        }
    }
    return false;
}
```

# HashIterator

+ 初始化记录modCount当前值，并让next指向第一个非空元素，而current=null
+ 
+ nextNode方法，首先查看modCount值以决定是否fail-fast
+ 然后检查当前元素是否为空，为空则抛出NoSuchElementException异常
+ 最后让current等于当前元素，next继续指向下一个非空元素
+ 
+ hasNext方法则简单判断next是否为空即可
+ 

+ remove方法首先判断当前节点是否为空，为空则抛出IllegalStateException异常
+ 随后查看modCount值决定是否fail-fast
+ 删除该节点，且修改expectedModCount，即迭代器中的remove方法不会导致fail-fast

```java
abstract class HashIterator
{
    Node<K， V> next;        // next entry to return
    Node<K， V> current;     // current entry
    int expectedModCount;  // for fast-fail
    int index;             // current slot

    HashIterator()
    {
        expectedModCount = modCount;
        Node<K， V>[] t = table;
        current = next = null;
        index = 0;
        if (t != null && size > 0)
        { // advance to first entry
            do
            {
            } while (index < t.length && (next = t[index++]) == null);
            //让next能指向第一个非空的元素
        }
    }

    public final boolean hasNext()
    {
        return next != null;
    }

    final Node<K， V> nextNode()
    {
        Node<K， V>[] t;
        Node<K， V> e = next;
        if (modCount != expectedModCount)//fail-fast机制
            throw new ConcurrentModificationException();
        if (e == null)
            throw new NoSuchElementException();
        //找到下一个非空元素
        if ((next = (current = e).next) == null && (t = table) != null)
        {
            do
            {
            } while (index < t.length && (next = t[index++]) == null);
        }
        return e;
    }

    public final void remove()
    {
        Node<K， V> p = current;
        if (p == null)
            throw new IllegalStateException();
        //依然是fail-fast
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        current = null;
        K key = p.key;
        //这里导致的modCount+1，所以需要下一条语句
        removeNode(hash(key)， key， null， false， false);
        expectedModCount = modCount;//此处remove不会触发fail-fast
    }
}
```

# 面试问题

## Java7和Java8的区别？

+ 存储结构
    + 拉链法：将链表和数组相结合.也就是说创建一个链表数组，数组中每一格就是一个链表.若遇到哈希冲突，则将冲突的值加到链表中即可.
    + 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间.
+ 插入数据方式
    + 头插法（先讲原位置的数据移到后1位，再插入数据到该位置）
    + 尾插法（直接插入到链表尾部/红黑树），解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题.
        + 导致死循环的主要原因是扩容后，节点的顺序会反掉，即采用头插法造成的
        + JDK7 头插法 死循环 环形链表
        + 使⽤头插会改变链表的上的顺序，但是如果使⽤尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了.
        + Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引⽤关系.
        + Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引⽤关系.

## 扩容

+ 创建一个新的Entry空数组，长度是原数组的2倍.
+ 遍历原Entry数组，把所有的Entry重新Hash到新数组.
+ Hash的公式---> index = HashCode（Key） & （Length - 1）
+ 扩容后节点重 hash 只可能出现在“原索引位置” 与 “原索引 + oldCap 位置”

```
如16->32
即hash & 1111 变成 hash & 11111
可以看到只有最高位可能会改变，即分成 0xxxx 或者 1xxxx，即要不在原索引位置，要不在原索引 + oldCap 位置
```

## hash

### 计算下标

+ 拿到 key 的 hashCode 值
+ 将 hashCode 的高位参与运算，重新计算 hash 值
    + (h = key.hashCode()) ^ (h >>> 16)
    + 将 hashCode 的高 16 位与 hashCode 进行异或运算，主要是为了在 table 的 length 较小的时候，让高位也参与运算
    + 通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；
+ 将计算出来的 hash 值与 (table.length - 1) 进行 & 运算
    + 比取余操作更加有效率
    + 因为x mod 2^n = x & (2^n - 1)，而底层数组长度总是 2 的 n 次方，所以x mod table.length = x & (table.length - 1)

### 解决hash冲突

+ 使用链地址法（使用散列表）来链接拥有相同hash值的数据；
+ 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；
+ 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；