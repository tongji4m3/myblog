---
title: 性能监控、故障处理工具
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习JVM笔记，包括JVM基础与可视化故障处理工具等。
categories: JVM学习笔记
tags:
  - JVM
  - jps
  - JConsole
abbrlink: 9e3f4319
date: 2021-02-16 00:00:00
---



# 基础故障处理工具

+ 这些命令行工具大多仅是一层薄包装，真正的功能代码是实现在JDK的工具类库里
+ 借助这些工具类库，应用程序部署生产环境后，开发者可以选择直接在应用程序中提供功能强大的监控分析功能

## jps

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608769939_1.png)

+ JVM Process Status
+ 虚拟机进程状况工具
+ 是使用频率最高的JDK命令行工具
+ 列出正在运行的虚拟机进程
+ 显示虚拟机执行主类名称（main()方法所在的类）、这些进程的本地虚拟机唯一ID（LVMID） Local Virtual Machine Identifier
+ 其他JDK工具需要他查询到的LVMID来确定要监控的是哪一个虚拟机进程
+ 对于本地虚拟机进程，LVMID与PID一致；ps指令也可以查询到虚拟机进程的LVMID，但如果同时启动多个虚拟机进程，则必须依赖jps命令显示主类的功能

### 参数

jps -l

输出主类的全名，如果进程执行的是JAR包，则输出JAR的路径

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770201_2.png)

jps -v

输出虚拟机进程启动时的JVM参数

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770291_3.png)

## jstat

+ 虚拟机统计信息监视工具
+ JVM Statistics Monitoring Tool
+ 用于监视虚拟机各种运行状态信息的命令行工具
+ 显示本地或远程虚拟机进程中的类加载，内存，垃圾回收，即时编译器等运行时数据
+ 在只提供控制台环境的服务器，他是运行期定位虚拟机性能问题的常用工具

### 参数

+ jstat [ option vmid [interval [s|ms] [count] ] ]
+ 本地虚拟机进程，则VMID与LVMID一致
+ interval和count代表查询间隔和次数，忽略则只查询一次
+ 例如 jstat -gc 4218 250 5
    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770710_4.png)

+ jstat -gcutil 4218
    + 输出已使用空间占总空间百分比
    + Eden使用了78.74%，S0为空，S1使用32.88%
    + 老年代（O）使用了61.65%
    + 元空间（M）使用了94.75
    + 程序运行以来Minor GC（YGC）发生了603次，用了4.85s
    + 发生Full GC(FGC)5次，用了1.611s
    + 所有GC总耗时（GCT）为6.462s
    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608770952_6.png)

## jmap

+ Java内存映像工具
+ Memory Map for Java
+ jmap -dump:live,format=b,file=a.log 4218
    + 用于生成堆转储快照
    + 再把生成的a.log进行分析
+ jmap -heap 4218
    + 显示Java堆详细详细，如使用哪种回收器，参数配置，分代情况等
    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772363_7.png)

## jstack

+ Java堆栈跟踪工具
+ Stack Trace for Java
+ 用于生成虚拟机当前时刻的线程快照
    + 即当前虚拟机内每一条线程正在执行的方法堆栈的集合
    + 目的是定位线程出现长时间停顿的原因
    + 如线程间死锁、死循环、请求外部资源导致的长时间挂起等
    + 线程出现停顿时，通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做什么事情，或者等待什么资源
+ jstack -l 4218 ：-l 除堆栈外，显示关于锁的附加信息
    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608772914_8.png)

# 可视化故障处理工具

## JConsole

+ Java监视与管理控制台
+ 通过JDK/bin命令下的jconsole.exe启动JConsole
+ 他会自动搜索出本机运行的所有虚拟机进程，即完成jps的功能

### 内存监控

+ 相当于可视化的jstat命令
+ 用于监视被收集器管理的虚拟机内存

```java
//-Xms100m -Xmx100m -XX:+UseSerialGC

public class Main {
    //内存占位符对象,一个OOM大约64KB
    static class OOMObject {
        public byte[] placeholder = new byte[64 * 1024];
    }
    public static void fillHeap(int num) throws InterruptedException {
        List<OOMObject> list = new ArrayList<>();
        for (int i = 0; i < num; i++) {
            //让监视曲线变化更加明显
            Thread.sleep(50);
            list.add(new OOMObject());
        }
		System.gc();
    }

    public static void main(String[] args) throws InterruptedException {
        fillHeap(1000);
    }
}
```

+ Eden区的运行趋势呈折现状
+ 整个堆曲线平滑向上增长
+ 在System.GC后，Eden与Survivor区被清空，但是老年代的保持峰值，说明被填充进堆中的数据在System.gc（）后仍然存活
+ 在System.gc();时，list对象仍然处于作用域之内，就不会回收，如果把System.gc();移动到方法外调用即可回收掉全部内存

### 线程监控

+ 相当于jstack，遇到线程停顿的时候用

#### 案例

```java
public class Main {
    //线程死循环演示
    public static void createBusyThread() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) { //第12行

                }
            }
        }, "testBusyThread").start();
    }

    //线程锁等待演示
    public static void createLockThread(final Object lock) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (lock) {
                    try {
                        lock.wait();
                    }
                    catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }, "testLockThread").start();
    }

    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        bufferedReader.readLine();
        createBusyThread();
        bufferedReader.readLine();
        Object object = new Object();
        createLockThread(object);
    }
}
```

+ 首先在线程页签中选择main线程
    + 堆栈追踪显示BufferedReader的readBytes()方法正在等待System.in的键盘输入
    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775371_11.png)
+ 接着监控testBusyThread线程
    + 他一直在执行空循环
    + 一直在第14行停留，即while(true)
    + 线程为Runnable状态，而且没有归还线程执行令牌的动作，所以会在空循环耗尽操作系统分配给他的执行时间，直到线程切换为止
    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775349_10.png)
+ testLockThread
    + 在等待lock对象的notify()或notifyAll()方法的出现
    + 处于WAITING状态，在重新唤醒前不会被分配执行时间
    + 处于正常的活锁等待，lock对象的notify()或notifyAll()方法被调用这个线程便能继续执行
    + ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608775531_12.png)

#### 死锁案例

```java
public class Main {
    static class SynAddRunnable implements Runnable {
        int a, b;

        public SynAddRunnable(int a, int b) {
            this.a = a;
            this.b = b;
        }

        @Override
        public void run() {
            synchronized (Integer.valueOf(a)) {
                synchronized (Integer.valueOf(b)) {
                    System.out.println(a + b);
                }
            }
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            new Thread(new SynAddRunnable(1, 2)).start();
            new Thread(new SynAddRunnable(2, 1)).start();
        }
    }
}
```

根本原因是Integer.valueOf()会对[-128,127]对象进行缓存，如果valueOf()传入的参数在范围内，则直接返回缓存中的对象

假设线程A在两个synchronized块之间发生了一次线程切换，就会出现线程A等待线程B持有的Integer.valueOf(1),线程B又在等待被线程A持有的Integer.valueOf(2)

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608776488_13.png)