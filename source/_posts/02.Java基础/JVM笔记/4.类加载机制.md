---
title: 类加载机制
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习JVM笔记，包括类生命周期、类加载器、双亲委派模型等。
categories: JVM学习笔记
tags:
  - JVM
  - 生命周期
  - 双亲委派模型
abbrlink: cd1d308
date: 2021-02-17 00:00:00
---



# 简介

+ JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程就是类加载机制
+ 在程序运行时完成的
+ 动态扩展的语言特性就是依赖于运行期动态加载和动态连接，例如编写一个面向接口的程序，可以等到运行时再指定其实际的实现类



# 生命周期

+ 解析阶段某些情况可以再初始化阶段之后才开始（为了支持运行时绑定特性）
+ 这些阶段通常相互交叉地混合进行，会在一个阶段执行的过程中调用、激活另一个阶段

## 加载

+ 通过一个类的全限定名获取定义此类的二进制字节流
    + 从ZIP压缩包中读取，JAR的基础
    + 从网络中读取，Web Applet
    + 运行时计算生成，动态代理技术
    + 从加密文件中获取，防Class文件被反编译的保护措施
+ 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
+ 在Java堆内存中实例化生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口
+ 数组加载
    + 数组类本身不通过类加载器创建，由JVM直接在内存中动态构造出来
    + 如果数组的组件类型是引用类型，递归采用加载过程去加载该组件类型，数组将标识在加载该组件类型的类加载器的类名称空间上
    + 如果数组的组件类型是基本类型，数组将标识为与引导类加载器关联

## 连接

### 验证

+ 目的是确保Class文件的字节流中包含的信息符合全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全
+ 文件格式验证
    + 验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理
    + 保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求
    + 基于二进制字节流进行的
    + 后面的三个验证阶段全部基于方法区的存储结构了
+ 元数据验证
    + 对字节码描述的信息进行语义分析
    + 是否有父类（除Object应都有父类）
    + 是否继承了final类
    + 是否实现了父类或接口要求实现的所有方法
    + 类中字段、方法是否与父类产生矛盾
+ 字节码验证
    + 通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的
    + 对类的方法体（Class文件中的Code属性）进行校验分析
    + 保证被校验类的方法在运行时不会做出危害虚拟机安全的行为
    + 保证任何跳转指令都不会跳转到方法体之外的字节码指令
    + 保证类型转换都是有效的
+ 符号引用验证
    + 发生在符号引用转化为直接引用的时候，即解析阶段
    + 验证该类是否缺少或被禁止访问他依赖的某些外部类、方法、字段等
    + 验证符合引用中通过字符串描述的全限定名称是否能找到对应的类
    + 验证在指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段
    + 符号引用中类、字段、方法的可访问性

### 准备

+ 正式为类中静态变量分配内存并设置初始值
+ 概念上是放在方法区，但是方法区是逻辑上的概念
+ JDK8后，类变量随着Class对象一起存放在Java堆中
+ 不包括实例变量，实例变量会在对象实例化时随对象一起分配在java堆中
+ 如果字段属性表中存在ConstantValue属性，则直接被初始化为ConstantValue属性所指定的初始值，例如public static final int value = 123;

### 解析

+ 将常量池内的符号引用转换为直接引用的过程
+ 虚拟机可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，避免重复解析
+ 符号引用
    + 以一组符合来描述所引用的目标，可以是任何形式的字面量
    + 与JVM的内存布局无关
    + 引用的目标不一定是已加载到虚拟机内存的内容
+ 直接引用
    + 可以直接指向目标的指针、相对偏移量或者句柄
    + 和JVM实现的内存布局相关
    + 引用的目标必定已经在虚拟机内存中
+ 类或接口的解析
    + 假设当前代码所处的类为D，要把从未解析过的符号引用N解析为一个类或接口C
    + 如果C不是一个数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C
    + 如果C是一个数组类型，并且数组的元素类型为对象，会先按上面的方法加载数组元素类型，再由虚拟机生成一个代表该数组维度和元素的数组对象
    + 在解析完成之前，要进行符号引用验证，确认D是否具备对C的访问权限

## 初始化

+ ＪＶＭ真正执行类中编写的Java代码，将主导权移交给应用程序

+ 初始化类变量和其他资源，即执行类构造器<clinit>的过程，是编译器自动生成的方法

+ 由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并而成的。收集的顺序由在源文件出现的顺序决定

+ 静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，只能赋值，不能访问

    + ```java
        static {
                i = 0; //给变量赋值可以正常编译通过
                System.out.println(i); //提示非法前向引用
            }
        
            static int i = 1;
        ```

        

+ <clinit>不需要显式调用父类构造器，虚拟机保证父类的已经执行完毕，因此ＪＶＭ第一个被执行的<clinit>方法肯定是Object

+ 父类的`<clinit>()`先执行，所以父类中定义的静态语句块优先于之类的变量赋值操作

+ ```java
    public class Main {
        static class Parent {
            public static int A = 1;
            static{
                A = 2;
            }
        }
    
        static class SubClass extends Parent{
            public static int B = A;
        }
    
        public static void main(String[] args) {
            System.out.println(SubClass.B);
        }
    }
    
    //２
    ```

+ <clinit>()不是必须的，如果没有静态语句块和对变量的赋值操作，就不生成

+ 虚拟机保证一个类的<clinit>()在多线程环境中被正确加锁同步，如果多个线程同时去初始化一个类，那么只有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待

### 初始化触发情况

#### 立即初始化情况

+ 遇到new、getstatic、putstatic、invokestatic字节码指令时
    + 使用new实例化对象
    + 读取一个类型的静态字段（已在编译期把结果放入常量池的静态字段除外）
    + 调用一个类型的静态方法
+ 使用reflect包对类型进行反射调用
+ 初始化类，发现父类还没有进行过初始化
    + 则先触发其父类的初始化
    + 一个接口在初始化时，并不要求其父类全部已经初始化过，只有真正使用到父接口时（如引用接口中定义的常量）才会初始化
+ JVM启动时，指定执行主类则JVM会先初始化这个主类
+ 使用动态语言支持，使用MethodHandle
+ 接口定义了默认方法（default方法)，该接口的实现类初始化，则该接口也要初始化

#### 被动引用

除上面主动引用的情况外，所有引用类型的方式都不会触发初始化

##### 例子1

+ 非主动使用类字段

+ 对于静态字段，只有直接定义这个字段的类才会被初始化

+ 因此通过其子类来引用父类中定义的静态字段，只会触发其父类的初始化而不会触发子类的初始化

    ```java
    public class SuperClass {
        public static int value = 123;
        static {
            System.out.println("SuperClass init!");
        }
    }
    
    public class SubClass extends SuperClass {
        static {
            System.out.println("SubClass init!");
        }
    }
    
    public class Main {
    
        public static void main(String[] args) {
            System.out.println(SubClass.value);
        }
    }
    /*
    SuperClass init!
            123
    */
    ```

##### 例子2

+ SuperClass[] superClasses = new SuperClass[10];
+ 没有触发SuperClass的初始化
+ 触发了[SuperClass的初始化
    + 由虚拟机自动生成的
    + 直接继承Object的子类
    + 由newarray字节码触发
    + 代表了元素类型为SuperClass的一维数组
    + 数组越界则抛出ArrayIndexOutOfBoundsException

##### 例子3

```java
public class ConstClass {
    static {
        System.out.println("ConstClass init");
    }

    public static final String HELLO = "hello world";
}

public class Main {

    public static void main(String[] args) {
        System.out.println(ConstClass.HELLO);
    }
}

//hello world
```

+ 常量在编译阶段会存入调用类的常量池中，本质没有引用到定义常量的类，因此不会触发定义常量的类的初始化
+ 编译阶段的常量传播优化，将常量的值直接存储到Main类的常量池中，对他的引用全部转为对自身常量池的引用
+ Main的Class文件没有ConstClass的符号引用入口，这两个类在编译成Class文件后不存在任何关系了

# 类加载器

## 概念

+ 类加载器：通过一个类的全限定名来获取描述该类的二进制字节流
+ 对于任意一个类，都必须由他的类加载器和这个类的本身一同确立他的唯一性
+ 每一个类加载器，都拥有一个独立的类名称空间
+ 比较两个类是否相等，只有他们在同一个类加载器下才有意义，否则就算他们来自同一个Class文件，被同一个虚拟机加载，只要他们类加载器不同，他们就不是同一个类
+ 所指的相等，包括equals()方法，instanceof关键字的判断
+ 保持着三层类加载器、双亲委派的类加载结构

## 启动类加载器

+ Bootstrap ClassLoader
+ 使用C++语言实现
+ 是虚拟机自身的一部分
+ 负责加载<JAVA_HOME>\lib目录
+ 启动类加载器无法被Java程序直接引用，如果需要把加载请求委派给启动类加载器处理，则用null代替

## 其他所有的类加载器

+ 由Java语言实现
+ 独立在虚拟机外部
+ 全部继承抽象类java.lang.ClassLoader
+ 扩展类加载器(Extension ClassLoader)
    + 负责加载<JAVA_HOME>\lib\ext目录下类库
    + 是一种Java系统类库的扩展机制
    + 允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能

+ 应用程序类加载器(Application ClassLoader)
    + 也称为系统类加载器。
    + 负责加载用户类路径（ClassPath)上所有的类库。如果没有定义自己的类加载器，则它就是程序默认的类加载器

## 双亲委派模型

+ 除了顶层的启动类加载器，其余的类加载器都应有自己的父类加载器，通常使用组合关系来复用父加载器的代码
+ 如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载
+ 类随着他的类加载器一起具备了一种带有优先级的层次关系
+ 例如Object类，无论哪个类加载器去加载他，都会委派到启动类加载器进行执行，因此Object类在不同的类加载器环境下都能保证是同一个类
+ 如果没有双亲委派模型，用户自定义java.lang.Object类，系统就会出现多个不同的Object类，代码将一片混乱
+ 先检查请求加载的类型是否已经被加载过，若没有则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器，如果父类加载器加载失败，抛出异常了，才调用自己的findClass()方法尝试进行加载

```java
protected Class<?> loadClass(String name， boolean resolve)
        throws ClassNotFoundException
    {
            // 首先，检查是否已经被类加载器加载过
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
            // 存在父加载器，递归的交由父加载器
                    if (parent != null) {
                        c = parent.loadClass(name， false);
                    } else {
                // 直到最上面的Bootstrap类加载器
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 如果父类加载器抛出ClassNotFoundException
                    // f说明父类加载器无法完成加载请求
                }

                if (c == null) {
                    // 在父类加载器无法加载时
                    // 再调用自身的findClass方法来进行类加载
                    c = findClass(name);
                }
            }
            return c;
    }
```

## 打破双亲委派机制

+ 重写loadClass方法
    + 双亲委派模型在JDK2才引入，而ClassLoader在第一个版本已经存在
    + 为了兼容已存在的用户自定义类加载器的代码，无法再以技术手段避免loadClass()被子类覆盖的可能，只能添加一个新的方法findClass()，
    + 双亲委派机制就在loadClass方法中实现的，重写该方法就能自己定义用什么加载器了
+ 线程上下文类加载器：解决父类加载器去请求子类加载器完成类加载的行为
+ OSGi实现模块化热部署