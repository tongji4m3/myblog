---
title: 内存区域与内存溢出异常
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习JVM笔记，Java内存区域结构与内存溢出异常测试等。
categories: JVM学习笔记
tags:
  - JVM
  - 运行时数据区域
  - OOM
abbrlink: 1b3d1a0
date: 2021-02-14 00:00:00
---



# 内存区域

## 运行时数据区域

### 程序计数器

+ 当前线程所执行字节码的行号指示器
+ 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令
+ 某一刻，一个处理器只会执行一个线程中的指令
+ 为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器
+ 即线程私有的内存
+ Java方法，则记录正在执行的虚拟机字节码指令的地址
+ Native方法，则计数器值为空
+ 唯一一个没有OutOfMemoryError情况的区域

### 虚拟机栈

+ 线程私有，生命周期与线程相同
+ 每个方法被调用直到执行完毕的过程，就对应一个栈帧从入栈到出栈的过程
+ 每个方法被执行时，JVM都会创建一个栈帧

#### 栈帧

+ 局部变量表
    + 存储编译器可知的数据：基本数据类型、对象引用（可能是一个指向对象起始地址的引用指针、也可能是指向一个代表对象的句柄）、returnAddress类型（指向一条字节码指令的地址）
    + 以局部变量槽存储，其中64位的long和double占用两个变量槽
    + 所需的内存空间在编译期间完成分配
    + 进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间完全确定
+ 操作数栈
+ 动态连接
+ 方法出口

#### 异常

+ StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度
+ OutOfMemoryError异常
    + 如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时
    + HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM

### 本地方法栈

+ 虚拟机栈是为JVM执行Java方法（字节码）服务
+ 本地方法栈是为了使用Native方法服务
+ HotSpot虚拟机把虚拟机栈，本地方法栈合二为一了

### 堆

+ Java堆是被所有线程共享的一块内存区域，在JVM启动时创建
+ 用于存放对象实例
+ 几乎所有对象实例都在这里分配内存
    + 所有的对象实例以及数组都应在堆上分配
    + 由于逃逸分析技术，一些优化手段如栈上分配、标量替换等，使得对象实例都分配在堆上不是这么绝对
+ 是垃圾收集器管理的内存区域
+ 可以划分出多个线程私有的分配缓冲区以提升对象分配时的效率：Thread Local Allocation Buffer(TLAB)
+ 可以处于物理上不连续的内存空间中，但在逻辑上是连续的。但对于大对象，例如数组对象，多数虚拟机都处于实现简单、存储高效的考虑，可能要求连续的内存空间
+ 可扩展，通过参数-Xms、-Xmx设定
+ 如果堆中没有内存完成实例分配，并且堆无法扩展，则OOM异常

#### 字符串常量池

字符串池/字符串常量池/字符串对象池/String Pool/String Table 都可以看作一个东西。

### 方法区

#### 理解

+ 是各个线程共享的内存区域
+ 存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存数据等
+ 内存回收目标主要是针对常量池的回收和类型的卸载
+ 方法区无法满足新的内存分配需求时，抛出OOM异常

#### 结构

+ 运行时常量池
    + 保存Class文件中描述的符号引用
    + 由符号引用翻译出来的直接引用
    + 与Class文件常量池区别是局部动态性。即常量不一定只有编译期产生，即并不是预置于Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以把新的常量放入池中，例如String的intern（）方法。
    + 无法满足新的内存分配需求时，抛出OOM异常
+ class文件信息
    + 类的版本、字段、方法、接口等
    + 常量池表：存放编译期生成的各种字面量与符号引用，在类加载后存放到方法区的运行时常量池中

#### 元空间

+ 元空间” 和 “方法区”，一个是HotSpot 的具体实现技术，一个是JVM规范的抽象定义；
+ 类型信息全部移到元空间中
+ 元空间是使用本地内存（Native Memory）实现的，也就是说它的内存是不在虚拟机内的，所以可以理论上物理机器还有多个内存就可以分配，而不用再受限于JVM本身分配的内存了。

### 直接内存

+ 不是运行时数据区的一部分，但是频繁使用到，也会OOM
+ NIO引入了基于管道与缓冲区的IO方式，可以使用Native函数库直接分配堆外内存
+ 直接内存的分配不会受到堆的大小限制，但受到本机总内存限制

## 对象	

### 对象创建

+ 能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过。没有则执行类加载过程
+ 为新生对象分配内存，类加载完成时即可确定对象所需的内存大小
    + **堆中内存分配**
        + 绝对规整则采用**指针碰撞**，所有被使用过的内存都被放在一边，空闲的内存在另一边，中间放这一个指针作为分界点的指示器。分配内存就是把那个指针向空闲空间方向挪动一段和对象内存大小相等的距离
        + 否则**空闲列表**：在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录
        + 是否规整由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定：Serial、ParNew带压缩整理、CMS基于清除（Sweep）算法，不带压缩整理
    + **分配内存有并发性**
        + 可以对分配内存空间的动作进行同步处理，采用**CAS配上失败重试**来保证更新操作的原子性
        + 或把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在堆中预先分配一小块内存，称为本地线程分配缓存**TLAB**，哪个线程需要分配内存，就在他的TLAB中分配，本地缓冲区用完才需要同步锁定。
+ 为分配到的内存空间（不包括对象头）都初始化为零值，保证了对象的实例字段在代码中可以不赋初始值即可使用
+ 对对象进行相应设置（存放在对象头中）：这个对象是哪个类的实例、如何能找到类的元数据信息、对象的哈希码（延后到真正调用Object::HashCode()方法才计算）、对象的GC分代年龄
+ 构造函数<init>()方法，按照程序员的意愿对对象进行初始化

### 对象的内存布局

+ 对象头(Header)
    + **Mark Word**
        + 存储自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
        + 在32位和64位（未开启压缩指针）虚拟机中分别位32比特和64比特
        + 有着动态定义的数据结构，根据对象的状态复用自己的存储空间
    + **类型指针**
        + 指向对象的类型元数据的指针
        + 查找对象的元数据信息并不一定要经过对象本身
    + **记录数组长度的数据**
        + 虚拟机可以通过元数据信息确定Java对象的大小，但是如果数组的长度不确定，无法通过元数据信息推断数组的大小
+ 实例数据（Instance Data)
    + 对象真正存储的有效信息，即定义的各种类型的字段内容
    + 无论是从父类继承的还是子类中定义的都记录
    + 存储顺序策略
        + longs/doubles、ints、shorts、chars、bytes/booleans、oops（Ordinary Object Pointers）
        + 相同宽度的字段分配在一起存放
        + 满足上面情况下，父类中定义的变量在子类之前
+ 对齐填充（Padding）
    + 对象起始地址必须是8字节的整数倍
    + 对象头已经是8字节的整数倍了（1倍或两倍）

### 对象访问定位

+ 通过栈上的reference数据来操作堆上的具体对象
+ 访问堆对象具体位置
    + 句柄访问
        + 划分一部分为句柄池
        + reference中存储对象的句柄地址
        + 句柄中包含对象实例数据和类型数据各自具体的地址
        + 存储的是稳定句柄地址，对象移动只改变句柄，不需要改变reference
    + 直接指针访问
        + reference中直接存储对象地址
        + 速度更快，节省了一次指针定位的时间开销
        + HotSpot采用直接指针访问



## Java堆异常

只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，总容量触及最大堆容量限制即OOM

设置堆最小值 -Xms参数和堆最大值参数 -Xmx一样即可避免堆自动扩展

-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机再出现内存溢出异常时Dump出当前内存堆存储快照以便事后分析

```
-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
```

```java
package com.tongji.test;

import java.util.ArrayList;
import java.util.List;

public class HeapOOM {
    static class OOMObject{

    }

    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<>();
        while (true) {
            list.add(new OOMObject());
        }
    }
}
```

```java
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```

### 处理方法

+ 通过内存映像分析工具对Dump出来的堆存储快照进行分析
+ 首先确认内存中导致OOM的对象是否有必要存在,即是出现内存泄漏,还是内存溢出
    + 内存泄漏,则查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收他们
    + 内存溢出，则内存中对象确实是必须存活的，就应该检查堆参数设置（-Xms -Xmx），与机器内存对比，是否有向上调整的空间，再从代码中检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设置不合理等，尽量减少程序运行期的内存消耗

## 虚拟机栈和本地方法栈溢出 

### 原理

+ 线程请求的栈深度大于虚拟机所允许的深度抛出StackOverflowError异常，例如调用的方法太多（递归）
+ 如果虚拟机栈容量允许动态扩展，当栈扩展时无法申请到足够的内存时抛出OutOfMemoryError异常
    + HotSpot栈容量不允许动态扩展，所以不会由于虚拟机栈无法动态扩展而导致OOM，只要线程申请栈空间成功就不会OOM，但是申请时就失败则仍然会OOM
    + 否则线程运行时不会因为扩展而导致内存溢出，只会因为栈容量无法容纳新的栈帧导致StackOverflowError异常
+ 写一个死递归程序触发

### 实验

+ 使用-Xss减少栈内存容量
+ 定义大量本地变量，增大次方法帧中本地变量表的长度
+ 无论是栈帧太大还是虚拟机容量太小，当新的栈帧内存无法分配时，抛出的都是StackOverflowError异常
+ 有明确的错误栈帧可供分析，栈深度达到1000-2000完全没问题，对于正常的方法调用完全足够了

### 使用-Xss减少栈内存容量

```
-Xss128k
```

```java
package com.tongji.test;

public class StackSOF {
    private int stackLength = 1;

    private void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) {
        StackSOF oom = new StackSOF();
        try
        {
            oom.stackLeak();
        }
        catch (Throwable e)
        {
            System.out.println("stack length:"+oom.stackLength);
            e.printStackTrace();
        }
    }
}
```

```
stack length:985
java.lang.StackOverflowError
```

### 定义大量本地变量，增大次方法帧中本地变量表的长度

```java
package com.tongji.test;

public class StackSOF {
    private int stackLength = 1;

    private void stackLeak() {
        long unused0, unused1, unused2, unused3;
        long unused10, unused11, unused12, unused13;
        long unused20, unused21, unused22, unused23;
        stackLength++;
        stackLeak();
        unused0 = unused1 = unused2 = unused3 =
                unused10 = unused11 = unused12 = unused13 =
                        unused20 = unused21 = unused22 = unused23 = 0;
    }

    public static void main(String[] args) {
        StackSOF oom = new StackSOF();
        try {
            oom.stackLeak();
        }
        catch (Throwable e) {
            System.out.println("stack length:" + oom.stackLength);
            e.printStackTrace();
        }
    }
}
```

```
stack length:311
java.lang.StackOverflowError
```



## 方法区和运行时常量池的溢出

+ 基本思路是运行时产生大量的类去填满方法区直到溢出为止
+ 许多框架如Spring，都会使用CGLib这类字节码技术
+ 当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存
+ 方法区是常见的内存溢出异常，因为一个类如果要被垃圾收集器回收，要达成的条件比较苛刻。在经常运行生成大量动态类的应用场景中，就应该特别关注这些类的回收状况
+ JDK8后，使用了元空间,正常的动态创建新类型的测试用例很难迫使虚拟机产生方法区的溢出异常了
+ -XX:MaxMetaspaceSize设置元空间最大值，默认是-1，即不限制，或者说只限制与本地内存大小
+ -XX:MetaspaceSize指定元空间初始空间大小，以字节为单位，达到该值则触发垃圾收集进行类型卸载
+ -XX:MinMetaspaceFreeRatio在垃圾收集之后控制最小的元空间剩余容量百分比，可以减少因为元空间不足导致的垃圾收集的频率

```java
package com.tongji.test;

import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;


public class JavaMethodAreaOOM {
    static class OOMObject {

    }

    public static void main(String[] args) {
        while (true) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(OOMObject.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
                @Override
                public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                    return methodProxy.invokeSuper(objects, args);
                }
            });
        }
    }
}
```

## 本地直接内存溢出

+ 容量大小通过-XX:MaxDirectMemorySize指定,默认与Java堆最大值(-Xmx)一致
+ 由直接内存溢出明显特征是Heap Dump中看不见什么异常情况,如果发现内存溢出后Dump文件很小,而又使用了DirectMemory(如NIO),则可以重点检查下直接内存方面的原因
+ 通过反射获取Unsafe类，并不断分配内存给静态常量

```java
package com.tongji.test;

import sun.misc.Unsafe;

import java.lang.reflect.Field;

public class DirectMemoryOOM {
    private static final int _1MB = 1024 * 1024;

    public static void main(String[] args) throws IllegalAccessException {
        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        while (true) {
            unsafe.allocateMemory(_1MB);
        }
    }

}
```

```java
Exception in thread "main" java.lang.OutOfMemoryError
	at sun.misc.Unsafe.allocateMemory(Native Method)
	at com.tongji.test.DirectMemoryOOM.main(DirectMemoryOOM.java:15)
```

