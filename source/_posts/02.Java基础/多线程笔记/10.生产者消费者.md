---
title: 生产者消费者
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java多线程所做的笔记，生产者消费者模型等。
categories: 多线程
tags:
  - 多线程
  - 生产者消费者
  - synchronized
abbrlink: 92d2ba71
date: 2021-02-06 00:00:00
---



# 生产者消费者（等待唤醒三种机制）

当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。

因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。

因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。

同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。

## synchronized wait notify

- wait()、notify()和notifyAll()方法是本地方法，并且为final方法，无法被重写。
- 调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁）
- 调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程；
- 调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程；
- 为何这三个不是Thread类声明中的方法，而是Object类中声明的方法？由于每个对象都拥有monitor（即锁），所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作了。
- 如果调用某个对象的wait()方法，当前线程必须拥有这个对象的monitor（即锁），因此调用wait()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。
- 调用某个对象的wait()方法，相当于让当前线程交出此对象的monitor，然后进入等待状态，等待后续再次获得此对象的锁（Thread类中的sleep方法使当前线程暂停执行一段时间，从而让其他线程有机会继续执行，但它并不释放对象锁）
- 　notify()方法能够唤醒一个正在等待该对象的monitor的线程，当有多个线程都在等待该对象的monitor的话，则只能唤醒其中一个线程，具体唤醒哪个线程则不得而知。
- 同样地，调用某个对象的notify()方法，当前线程也必须拥有这个对象的monitor，因此调用notify()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）
- 举个简单的例子：假如有三个线程Thread1、Thread2和Thread3都在等待对象objectA的monitor，此时Thread4拥有对象objectA的monitor，当在Thread4中调用objectA.notify()方法之后，Thread1、Thread2和Thread3只有一个能被唤醒。注意，被唤醒不等于立刻就获取了objectA的monitor。假若在Thread4中调用objectA.notifyAll()方法，则Thread1、Thread2和Thread3三个线程都会被唤醒，至于哪个线程接下来能够获取到objectA的monitor就具体依赖于操作系统的调度了。
- 一个线程被唤醒不代表立即获取了对象的monitor，只有等调用完notify()或者notifyAll()并退出synchronized块，释放对象锁后，其余线程才可获得锁执行。
- 当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。
- 只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。
- 也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程让其获得锁
- notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。
- notify唤醒沉睡的线程后，**线程会接着上次的执行继续往下执行。**所以在进行条件判断时候，可以先把 wait 语句忽略不计来进行考虑；显然，要确保程序一定要执行，并且要保证程序直到满足一定的条件再执行，要使用while进行等待，直到满足条件才继续往下执行。

**条件**

1. 必须在synchronized中
2. 必须先wait再notify

**虚假唤醒**

+ 等待唤醒机制，就是当一个线程在执行了某一个操作的时候，将其进入等待状态，并释放锁，其他线程执行完指定的操作后，再将其唤醒。
+ 当两个消费者线程同时执行sale方法时，产品售空，那么都将执行wait方法，处于挂起等待状态，并释放锁，然后生产者拿到锁，生产产品，执行notifyAll方法，唤醒了所有消费者线程，那么当第一个消费者执行了消费以后，第二个消费者又进行消费，此时便出现了负数，出现了问题。像这样的情况，就叫做虚假唤醒。

```java
package tongji.util.thread;

/*
用if时四个线程出现了虚假唤醒
    thread2    消费:-1
    thread2    消费:-2
所以使用while
 */

//资源类
class AirCondition {
    private int number = 0;

    public synchronized void increment() throws InterruptedException {
        //有资源时，则不能生产
//        if (number != 0) {
//            this.wait();
//        }
        //需要使用while
        //因为多个线程，有个线程进来阻塞后，之后唤醒的时候，因为是调用this.notifyAll()，所以所有的都唤醒了，而可能只是该increment()想要通知decrement()而已
        //wait是交出控制权的
        while (number != 0) {
            this.wait();
        }
        //生产并且唤醒消费线程
        number++;
        System.out.println(Thread.currentThread().getName() + "\t生产:" + number);
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        //没有资源时，不能消费
        while (number == 0) {
            this.wait();
        }
        //消费并且唤醒生产线程
        number--;
        System.out.println(Thread.currentThread().getName() + "\t消费:" + number);
        this.notifyAll();
    }
}

public class Main {
    public static void main(String[] args) {
        AirCondition airCondition = new AirCondition();
        //生产者
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    airCondition.increment();
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }，"thread1").start();

        //消费者
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    airCondition.decrement();
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }，"thread2").start();

        //生产者2
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    //多个线程自始至终使用的是同一个对象，所以synchronized可以锁住整个对象(不只是锁某个方法)
                    airCondition.increment();
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }，"thread3").start();

        //消费者2
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    airCondition.decrement();
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }，"thread4").start();
    }
}
```

## lock await signal

**条件**

1. 必须在lock中
2. 先await再signal

```java
package tongji.util.thread;


import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

//资源类
class AirCondition {
    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void increment() {
        lock.lock();
        try {
            while (number != 0) {
                condition.await();
            }
            number++;
            System.out.println(Thread.currentThread().getName() + "\t生产:" + number);
            condition.signalAll();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }

    public void decrement() {
        lock.lock();
        try {
            while (number == 0) {
                condition.await();
            }
            number--;
            System.out.println(Thread.currentThread().getName() + "\t消费:" + number);
            condition.signalAll();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        AirCondition airCondition = new AirCondition();
        //生产者
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                airCondition.increment();
            }
        }， "thread1").start();

        //消费者
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                airCondition.decrement();
            }
        }， "thread2").start();

        //生产者2
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                airCondition.increment();
            }
        }， "thread3").start();

        //消费者2
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                airCondition.decrement();
            }
        }， "thread4").start();
    }
}
```

### Condition精确唤醒

- Condition是个接口，基本的方法就是await()和signal()方法；
- Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() 
-  调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用

```java
import jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ShareResource {
    private int number = 1;
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();

    public void print5() {
        lock.lock();

        try
        {
            while (number != 1) {
                condition1.await();
            }

            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " print " + (i + 1));
            }
            //通知
            number = 2;
            condition2.signal();
        }
        catch (RuntimeException | InterruptedException e)
        {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }

    public void print10() {
        lock.lock();

        try
        {
            while (number != 2) {
                condition2.await();
            }

            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " print " + (i + 6));
            }
            //通知
            number = 3;
            condition3.signal();
        }
        catch (RuntimeException | InterruptedException e)
        {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }
    public void print15() {
        lock.lock();

        try
        {
            while (number != 3) {
                condition3.await();
            }

            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " print " + (i + 11));
            }
            //通知
            number = 1;
            condition1.signal();
        }
        catch (RuntimeException | InterruptedException e)
        {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }

}


public class Main {
    public static void main(String[] args) {
        ShareResource shareResource = new ShareResource();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                shareResource.print5();
            }
        }，"t1").start();

        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                shareResource.print10();
            }
        }，"t2").start();

        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                shareResource.print15();
            }
        }，"t3").start();

    }
}
```

## LockSupport park unpark

LockSupport，构建同步组件的基础工具，帮AQS完成相应线程的阻塞或者唤醒的工作。

线程等待唤醒机制wait/notify的改良版本，对应的方法是park/unpark

**优点**

1. 不需要synchronized或lock
2. 先唤醒再等待也可以正常运行

**LockSupport详细了解**

+ 它是一个线程阻塞工具类，所有方法都是静态的，可以让线程在任意位置阻塞
+ 许可证类似于0/1的信号量
+ 它调用的是Unsafe里的native方法
+ 它和每个使用他的线程都有一个permit关联
+ 线程阻塞需要消耗permit，每个permit不可累计，最多一个

```java
package com.tongji;


import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;

public class Main {

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {

            try {
                TimeUnit.SECONDS.sleep(3);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + " 开始");
            LockSupport.park();//被阻塞，要通知需要许可证
            //每次阻塞都需要一个permit
            LockSupport.park();//被阻塞，要通知需要许可证
            //下面执行不了，因为阻塞两次
            System.out.println(Thread.currentThread().getName() + " 唤醒");
        }， "t1");
        thread1.start();

        new Thread(() -> {
            LockSupport.unpark(thread1);
            //permit不可累加
            LockSupport.unpark(thread1);
            //所以执行完permit还是1
            System.out.println(Thread.currentThread().getName() + " 通知");
        }， "t2").start();
    }
}
```

# 应用-生产者消费者

## 传统版

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ShareData{
    //资源类
    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void increment() throws Exception {
        lock.lock();
        try
        {
            //为了防止虚假唤醒，必须使用if
            while (number != 0) {
                //等待，不能生产
                condition.await();
            }
            number++;
            System.out.println(Thread.currentThread().getName()+" 生产");
            //通知唤醒 可以进行消费了
            condition.signalAll();
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }

    public void decrement() throws Exception {
        lock.lock();
        try
        {
            while (number == 0) {
                //等待，不能消费
                condition.await();
            }
            number--;
            System.out.println(Thread.currentThread().getName()+" 消费");
            //通知唤醒 可以进行生产了
            condition.signalAll();
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        ShareData shareData = new ShareData();
        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                try {
                    shareData.increment();
                }
                catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }，"t1").start();


        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                try {
                    shareData.decrement();
                }
                catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }，"t2").start();
    }
}
```

## 阻塞队列版

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

class MyResource{
    private volatile boolean FLAG= true; //默认开启，进行生产+消费
    private AtomicInteger atomicInteger = new AtomicInteger();

    BlockingQueue<String> blockingQueue;

    public MyResource(BlockingQueue<String> blockingQueue) {
        this.blockingQueue = blockingQueue;
        System.out.println(blockingQueue.getClass().getName());
    }

    public void myProd() throws Exception {
        String data = null;
        boolean retValue;
        while(FLAG){
            data = atomicInteger.incrementAndGet() + "";
            retValue = blockingQueue.offer(data， 2L， TimeUnit.SECONDS);
            if (retValue) {
                System.out.println(blockingQueue.getClass().getName() + "插入队列 " + data + " 成功");
            }
            else {
                System.out.println(blockingQueue.getClass().getName()+"插入队列 "+data+" 失败");
            }
            TimeUnit.SECONDS.sleep(1);
        }
        System.out.println("生产动作结束");
    }

    public void myConsumer() throws Exception {
        String result = null;
        while (FLAG) {
            //不因为FLAG影响，因为等待2s
            result = blockingQueue.poll(2L， TimeUnit.SECONDS);
            if (result == null || result.equalsIgnoreCase("")) {
                FLAG = false;
                System.out.println(blockingQueue.getClass().getName()+"超过2s没用取到，消费队列失败");
                return;
            }
            else {
                System.out.println(blockingQueue.getClass().getName() + "消费队列 " + result + " 成功");
            }

        }
    }

    public void stop() {
        this.FLAG = false;
    }
}

public class Main {

    public static void main(String[] args) {
        MyResource myResource = new MyResource(new ArrayBlockingQueue<>(10));
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " 生产线程启动");
            try {
                myResource.myProd();
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }， "Prod").start();

        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " 消费线程启动");
            try {
                myResource.myConsumer();
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }， "Consumer").start();


        try {
            TimeUnit.SECONDS.sleep(5);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("5s后停止生产与消费---");
        myResource.stop();
    }
}
```

