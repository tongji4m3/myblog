---
title: Java基础
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: Java基础知识，包括关键字、操作符、继承多态、数组、异常、枚举等
categories: Java基础
tags:
  - Java
  - 数组
  - 操作符
abbrlink: f7ede91d
date: 2020-12-29 00:00:00
---



# 了解

## Java特点

+ 简单性(不能直接操作指针)
+ 面向对象性
+ 健壮性(GC机制)
+ 多线程并发
+ 可移植性/跨平台性 

## 编译指令

**javac**

+ javac在编译期,将.java文件形成.class文件 
+ javac MainTest.java
+ 相对路径写法，即MainTest.java必须在当前路径下

**java**

+ java在运行期,运行.class文件   

+ java MainTest

    如果指定了classpath则不必，否则MainTest.class也必须在当前路径下

## 环境变量简介

+ 环境变量包括了 系统变量,用户变量
+ 系统变量的范围比较大,会让所有计算机用户都生效
+ 用户变量只会作用与当前用户
+ path环境变量告诉windows可以去哪里找到命令.这样就不用写程序的绝对路径了,如：C:\Program Files\Java\jdk8.0_261\bin\javac.exe可以直接在任何路径下的命令行敲javac
+ 默认情况下classpath只加载当前路径下的class文件
+ classpath给类加载器指定路径,让类加载器去指定路径下加载字节码
+ classpath不区分大小写,如CLASSPATHCLASSPATH配置：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar

## class文件

+ 一个java源文件可以定义多个class
+ 源文件中只要有一个class定义，就会产生一个class文件
+ public类可以没有，但有则必须与源文件名保持一致，且只能有一个
+ 每个类都能有自己的main方法

## 语法特点

+ 局部变量没有初始值，只能手动赋值
+ 常量，静态变量存储在方法区中，在类加载时初始化
+ 若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保他获得一个默认值（对于boolean是false,其他是0）



# 方法

+ 方法名和参数列表唯一标识出某个方法
+ 方法中的局部变量,Java以编译错误的形式来保证所有变量在使用前都能得到恰当的初始化
+ 方法传递参数实际上是传递参数的引用
+ 按值调用：如果是基本数据类型,那么值不变；引用数据类型:引用被拷贝,指向的是原对象,所以仍能改变对象值

# 访问权限修饰符

+ 默认是包访问权限,意味着当前的包中所有其他类对那个成员都有访问权限,但对应这个包之外的所有类,这个成员是private的
+ protected也提供包访问权限
+ 继承可以访问public和protected的,但只有同一个包内,才能访问包访问权限的
+ 类访问权限：类只能是包访问权限或public的

# 操作符

+ 在为对象赋值时,实际上是将引用从一个地方复制到另一个地方,他们都会指向原先引用所指向的对象,指向相同的对象
+ 两边只要有一边是字符串类型，拼接完就还是字符串。遵循从左到右的原则，例如System.out.println(100+200+"300");//300300
+ 所有浮点型默认当作double类型处理，要当作Float，后面加F

## 直接常量

+ 后缀标识标志了他们的类型：大写的L代表long、大写的F代表float、一个字面量，默认当作int类型处理，后面加L则默认为long类型
+ int型中，0x开头代表16进制,如:0xCAFE ，0b开头为二进制，例如int a=0b110,输出结果为6
+ 如果编译器能正确识别类型,则不必在数值后附加字符,例如long n=200
+ 而对于指数标记法,例如1e-43,通常作为双精度数处理.如果没有f,则会有错误提示.float x = 1e-43f;

## 移位操作符

+ 左移位操作符:<<,右边补0
+ 有符号右移位操作符:>>,使用符号扩展,若符号为正,则在高位插入0,否则插入1
+ 无符号右移位操作符:>>>,无论正负,都在高位插入0

## 类型转换

+ 窄化转换:将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型.面临信息丢失的危险.编译器此时就会强制要求我们进行类型转换
+ 扩展转换:不必显式进行类型转换,因为新类型肯定能容纳原来类型的信息
+ 如果对基本数据类型执行算术运算或移位运算,char,byte,short在运算前自动转换成int,最终生成的类型就是int类型
+ 表达式中出现的最大数据类型决定了表达式最终结果的数据类型
+ 不能对布尔值进行其他任何运算
+ 大容量转小容量需要强制类型转换，有可能损失精度
+ 自动类型转换： long b=200; 200字面量首先默认当作int型，但是自动转换为long。而long b=300L,300字面量默认当作long，赋值给b不存在类型转换。
+ long a=200_0000_0000会报错，因为后者默认先为int时，已经超出int，就报错了
+ byte中，当整数型不超过[-128,127]时，该字面量可以直接赋值给byte，不需要类型转换。byte x=127; byte a = (byte)128;short，char也是可以的。只有字面量可以这样转换，例如 short s=a+x则会报错：不兼容的类型：从int转换到short可能会有损失。
+ char ch=97一个整数赋值给char类型变量能自动类型转换
+ byte，short，char混合运算，都会先转换为int再运算
+ 多种数据类型混合运算，最终结果为“最大容量”类型
+ 如果整数型字面量没有超过byte，short,char的取值范围，可以直接将其赋值给他们相应类型的变量
+ 容量比较：byte<short(char)<int<long<float<double  char比short代表更大的正整数

# 关键字

## finally

+ 是try语句中的一个语句体，不能单独使用，用来释放资源
+ 如果catch里面有return语句，此时会先执行return将返回值打包并创建一个返回路径等待，接着往下搜寻有没有finally语句，如果有则需先执行完finally后，再根据已经创建好的返回路径返回。
+ 千万不要在finally内写return 返回语句，因为finally是只要JVM不结束就一定会执行的，那么在try和catch中写的return语句就会毫无意义，因为会被finally的return语句覆盖。

## final

+ final修饰的变量只能赋一次值
+ 引用也是变量，存内存地址。所以final修饰的引用只要指向了一个对象就永远指向那个变量
+ 虽然实例变量如果没有手动赋值，但是系统会赋默认值。但是final修饰实例变量，内部实现让他必须要手动赋值。手动赋值可以在变量后面直接赋值，或者在构造器中赋值
+ 实例对象用final修饰，说明该实例变量值不会随着对象的变化而变化，所以一般加static修饰变成常量
+ 常量代表了永不改变的编译时常量或运行时被初始化后不希望他改变的值,这类常量必须是基本数据类型,并且以关键字final标识,定义时必须赋值
+ 一个既是static,又是final的域只占据一段不能改变的存储空间
+ 对应对象引用,final使引用恒定不变,一旦引用被初始化指向一个对象,就无法再把它改为指向另一个对象.但是对象自身是可以修改的
+ 空白final：指被声明为final但又未给定初值的域，必须在域的定义处或者每个构造器中对final赋值
+ final参数：类似void test(final Date g),无法在方法中更改参数引用所指向的对象
+ final方法：把方法锁定,防止任何继承类修改他的含义；类中所有private方法都是final的
+ final类：禁止继承该类,所有方法隐式指定为final

# 初始化

## 构造器

+ 如果没有写构造器,编译器会自动创建默认构造器;如果已经定义了构造器,则不会默认自动创建
+ 执行类似x.f(1)方法时,编译器把所操作对象的引用作为第一个参数传递给了f(),实际上就形如X.f(x,1).
+ 所以在方法内部,如果想获得对调用方法的那个对象的引用,则用this
+ 在方法内部调用同一个类的另一个方法,不必用this,因为当前方法的this引用会自动应用于同一类中的所有方法
+ 构造器中可以用this来调用另一个构造器,但是只能置于最起始处,而且只能调用一次

## 成员初始化

+ 在类中定义一个对象引用,若没有初始化,则会获得特殊值--null
+ 无法阻止自动初始化的进行,他将会在构造器被调用前发生
+ 变量定义会在任何方法(包括构造器)被调用之前得到初始化
+ 静态初始化只在必要时刻才会进行,且不会再次被初始化

## 初始化过程

+ 当静态方法/静态域首次被访问时，java解释器必须查找类路径,单位Dog.class
+ 载入Dog.class,执行且只执行静态初始化操作一次
+ 当使用new Dog()创建对象时,在堆上为该对象分配足够的存储空间
+ 存储空间清零,就自动的把所有基本类型数据设为默认值,引用设置为null
+ 执行字段定义处的初始化动作
+ 执行构造器



# 继承与多态

## 了解

+ 子类会自动得到基类中所有的域和方法
+ 一般为了继承,会将所有的数据成员指定为private,所有方法指定为public
+ 当创建了一个导出类的对象时,该对象包含了一个基类的子对象
+ Java会自动在导出类的构造器中插入对基类构造器的调用
+ 如果没有默认的基类构造器,或者想要调用一个带参数的基类构造器,则必须用关键词super
+ 父类引用指向子类对象.编译看左边,运行看右边
+ 编译阶段绑定父类的方法，运行阶段绑定子类对象的方法
+ 编译期间只知道引用是父类型的变量
+ 子类继承父类的所有除了构造方法，但是父类私有的属性无法在子类直接访问
+ super不是引用，也不保存内存地址，也不指向一块对象，只是代表当前对象内部的那一块父类型的特征
+ this（），super（）都只能出现在构造方法第一行。为u的是创建子类对象时，先初始化父类的特征
+ protected，就类用户而言,他是private的,但是对于任何继承于此类的导出类或者同一个包的类,他是可访问的(也提供包访问权限)
+ 名称屏蔽：子类可以进行重载或重写,而且重载不会屏蔽父类的重载方法，使用@Override注解可以防止你在不想重载时而意外地进行了重载

## 构造器

+ 基类的构造器总是在导出类的构造过程中被调用,导出类只能访问它自己的成员,不能访问基类的成员(因为通常是private),只有基类构造器才比较恰当的对自己元素进行初始化,因此必须令所有构造器得到调用
+ 如果没有明确指定调用某个基类构造器,他就会默默调用默认构造器

# 数组

## 理解

+ 数组是引用数据类型,数组父类是Object,存储在堆中
+ 数组标识符是一个引用,指向堆中创建的一个真实对象，这个对象用以保存指向其他对象的引用
+ 基本类型数组直接保存基本类型的值
+ 数组元素首地址作为整个数组对象的地址
+ 返回一个数组与返回任何其他对象没区别
+ 不能实例化泛型的数组，因为擦除会移除参数类型信息，而数组必须知道他们所持有的确切类型
+ 在使用任何引用前，必须为其指定一个对象，如果试图使用一个还是null的引用，在运行时将会报错。

## 初始化

+ String [] names=new String[6]每个元素初始化为null
+ 当创建一个数组对象时,实际上就是创建了一个引用数组,并且每个引用都会自动被初始化为一个特定值,该值拥有自己的关键字null,说明没有指向某个对象。
+ 创建用来存放基本数据类型的数组时，会将这种数组所占内存全部置为零

## System.arraycopy

+ 如果复制对象数组，则只是复制了对象的引用，即浅拷贝
+ 而且不会执行自动拆箱，装箱，两个数组必须具有相同的确切类型
+ 源数组，源数组起始处，目的数组，目的数组起始处，需要复制的元素个数

```java
public static void main(String[] args)
{
    int[] array = new int[10];
    Arrays.fill(array,1);
    System.out.println(Arrays.toString(array));

    int[] test=new int[10];
    //源数组，源数组起始处，目的数组，目的数组起始处，需要复制的元素个数
    System.arraycopy(array,0,test,0,array.length);
}
```



# 异常

## 理解

+ 异常通过编译器强制执行的，它往往能够降低错误处理代码的复杂度
+ 使用new在堆上创建异常对象,然后当前的执行路径被终止,并且从当前环境中弹出对异常对象的引用,此时异常处理机制接管程序,将程序从错误状态中恢复,使程序继续运行下去
+ 异常运行我们强制程序停止运行,并告诉我们出现了什么问题,或者强制程序处理问题,并返回到稳定状态
+ 异常处理将错误处理直接置于编程语言中。异常是一种对象，他从出错地点被抛出，并被专门用来处理特定类型错误的相应的异常处理器捕获。
+ 异常处理就像是与程序正常执行路径并行的，在错误发生时执行的另一条路径。因为他是另一条完全分离的执行路径，它不会干扰正常的执行代码。
+ 异常不能被忽略，所以他保证一定会在某处得到处理
+ 异常提供了一种从错误状况进行可靠恢复的途径，可以进行校正，并恢复程序的执行

## 异常限制

+ 当覆盖方法时,子类只能抛出在基类方法的异常说明中列出的那些异常,保证了对象的可替换性
+ 异常限制对构造器不起作用,然而因为基类构造器必须被调用,所有派生类构造器的异常说明必须包含基类构造器的异常说明
+ 派生类可以不抛出任何异常,即使它是基类定义的异常
+ 不能基于异常说明来重载方法
+ 一个出现在基类方法的异常说明中的异常,不一定会出现在派生类的异常说明里,即某个特定方法的异常说明的接口变小了,和继承相反

## 异常声明

+ 如果方法里的代码产生了异常却没有进行处理，编译器会发现这个问题并提醒你:要么处理，要么在异常说明中表明该方法将产生异常
+ 可以声明方法将抛出异常，而实际上不抛出
+ 可以定义接口时预先声明异常，这样接口实现就可以抛出这些预先声明的异常
+ 在编译器被强制检查的异常称为被检查的异常
+ 如果在方法内部抛出异常,它将在抛出异常的过程中结束
+ 异常可以写入标准错误流System.err,他不会被重定向
+ e.printStackTrace()打印从方法调用处直到异常抛出处的方法调用序列,默认是被输出到标准错误流
+ printStackTrace返回一个由栈轨迹中的元素构成的数组,栈顶是调用序列中的最后一个方法调用

```java
public static void main(String[] args)
{
    try
    {
        test();
    }
    catch (Throwable throwable)
    {
        throwable.printStackTrace(System.out);
    }
}

public static void test() throws Throwable
{
    throw new Throwable();
}
/*
    java.lang.Throwable
	at com.tongji.MainTest.test(MainTest.java:22)
	at com.tongji.MainTest.main(MainTest.java:12)
     */
```



## Throwable

### Error 非受查异常

用来表示编译时和系统错误

### Exception

#### IOException等受查异常

+ Exception中除了RuntimeException的其他子类，都是编译时异常，又叫受检异常。即编写程序时必须预先对异常进行处理，否则编译器报错。编译时异常发生概率高。所以未雨绸缪。

+ 编译时异常例子：大雨天，出门不带伞，很大可能会生病（很大可能发生的一种异常）。那就提前带一把伞（对概率较高的异常进行预处理）

+ 编译期，运行期异常都发生在运行阶段。编译阶段异常不会发生。

+ 编译时异常在编写程序时就要预先处理，可以继续向上抛出，或者自行处理。

+ throws ClassNotFoundException交给调用该方法的调用者处理

+ 如果异常一直上抛，main再上抛则上抛到了JVM，则会终止程序

+ 异常堆栈信息从上往下看。先看抛出的异常名。再看自己代码中最顶端报错的代码位置。

+ finally

    + 无论try里执行了return语句、break语句、还是continue语句，finally语句块还会继续执行。

    + 当try或者catch的代码在运行的时候，JVM退出了。那么finally语句块就不会执行。同样，如果线程在运行try或者catch的代码时被中断了或者被杀死了(killed)，那么finally语句可能也不会执行了，即使整个运用还会继续执行。

    + 如果在try语句里有return语句，finally语句还是会执行。它会在把控制权转移到该方法的调用者或者构造器前执行finally语句。也就是说，使用return语句把控制权转移给其他的方法前会执行finally语句。

        

#### RuntimeException 非受查异常

+ 是Java标准运行时检测的一部分,会自动被虚拟机抛出,不必要声明方法将抛出RuntimeException类型的异常
+ 它称为不受检查异常,属于错误,将被自动捕获
+ 该异常通常会穿越所有执行路径直达main方法,并在程序退出前调用异常的printStackTrace方法
+ RuntimeException代表的其实是编程错误,要么是无法预料的错误(如传入null引用),程序员应该在代码中检查的错误(数组越界)
+ 所有的RuntimeException及其子类都属于运行时异常。在编写处理程序阶段可以处理，也可以选择不处理
+ 运行时异常例子：被飞机砸中，发生概率比较低。如果提前预处理，就很麻烦
+ 一个方法必须声明所有可能抛出的受查异常.非受查异常要么不可控制,要么应该避免发生.

# 枚举

+ 可以将枚举看成常规类,他可以有自己的方法
+ 枚举定义结束,编译期不允许我们使用他的构造器来构造任何其他实例
+ 枚举的values()方法是编译期添加的static方法
+ 枚举被标记为了final类,无法继承

```java
public enum Ozwitch
{
    WEST("ABC"),
    NORTH("123"),
    EAST("Hello World"),
    SOUTH("This is my life");

    private String description;

    private Ozwitch(String description)
    {
        this.description = description;
    }

    public String getDescription()
    {
        return description;
    }

    public static void main(String[] args)
    {
        for (Ozwitch ozwitch : Ozwitch.values())
        {
            System.out.println(ozwitch+":"+ozwitch.getDescription());
        }
    }
}
```

