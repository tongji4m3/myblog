---
title: Java面试题
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: Java基础知识，包括基本数据类型、==与equals()与hashcode、内部类和静态内部类的区别等
categories: Java基础
tags:
  - Java
  - equals
  - 重写
abbrlink: a7ef9c4d
date: 2020-09-30 00:00:00
---

# Java和C++的区别

+ 都是面向对象的语⾔，都⽀持封装、继承和多态
+ Java 不提供指针来直接访问内存，程序内存更加安全
+ Java 的类是单继承的，C+⽀持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
+ Java 有自动内存管理机制，不需要程序员手动释放无用内存

# 基本数据类型

+ int 4字节[ -2^31 ， 2^31 - 1]  超过20亿
+ short 2字节
+ long 8字节
+ byte 1字节[-128，127]
+ float 四字节
+ double 8字节
+ char  2字节 因为Java采用16位的Unicode字符集 [0，65535]
+ boolean 只有两个值，但是大小没精确定义

# 接口和抽象类的区别

+ 拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类。抽象类是被用来创建继承层级里子类的模板。
+ 接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。如AbstractMap提供了Map的默认实现，Iterable接口让我知道可以对该类进行for-each遍历
+ 想实现多重继承，那么你必须使用接口。Java不支持多继承，子类不能够继承多个类，但可以实现多个接口
+ 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符
+ 从设计层面来说，抽象是对类的抽象，是⼀种模板设计，用于代码复用。而接口是对行为的抽象，是⼀种行为的规范，用于抽象事物的特性。

# 内部类和静态内部类的区别

## 为什么需要内部类

+ 每个内部类都能独立地继承自一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响
+ 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立
+ 在单个外围类中，可以让多个内部类以不同的方法实现同一个接口

**内部类**

+ 内部类中的变量和方法不能声明为静态的。
+ 内部类实例化：B是A的内部类，实例化B：A.B b = new A().new B()。
+ 内部类秘密捕获一个指向外部类对象的引用，所以可以引用外部类的静态或者非静态属性及方法。
+  在拥有外部类对象之前是不可能创建内部类对象的，因为内部类有指向外部类对象的引用

**静态内部类**

+ 静态内部类属性和方法可以声明为静态的或者非静态的。

+ 实例化静态内部类：B是A的静态内部类，A.B b = new A.B()。

+ 静态内部类只能引用外部类的静态的属性及方法。 创建静态内部类则不需要先创建外部类对象

# 装箱拆箱

包装类对象池是池化技术的应用，是 Java 在类封装里实现的。Integer 对象池在底层实际上就是一个变量名为 cache 的数组，里面包含了 -128 ～ 127 的 Integer 对象实例。

使用对象池的方法就是通过 Integer.valueOf() 返回 cache 中的对象，像 Integer i = 10 这种自动装箱实际上也是调用 Integer.valueOf() 完成的。

如果使用的是 new 构造器，则会跳过 valueOf()，所以不会使用对象池中的实例。

缓存池的初始化在第一次使用的时候已经全部完成，初始化时它已经包含了所有需要缓存的对象。

```java
//Integer i = 100;会自动执行Integer i = Integer.valueOf(100) 操作
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

```java
两个 new Integer() 变量比较 ，永远是 false。因为new生成的是两个对象，其内存地址不同
Integer a = new Integer(10);
Integer b = new Integer(10);
System.out.println(a == b);//false

Integer变量 和 new Integer() 变量比较 ，永远为 false
因为 Integer变量 指向的是 java 常量池 中的对象，
而 new Integer() 的变量指向 堆中 新建的对象，两者在内存中的地址不同。
Integer i = new Integer(100);
Integer j = 100;
System.out.print(i == j);  //false

自动装箱，自动拆箱
Integer类加载时会初始化整数型常量池：256个对象
在[-128，127]之间会被包装到固定的对象，放在整数型常量池里
此区间的数据直接从内存中取出，内存地址相同
如果不在这个范围，则会new出来，(看最上面)
会导致:
两个Integer 变量比较，如果两个变量的值在区间-128到127 之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为 false 。
Integer a=100;
Integer b=100;
if(a==b)//结果为true


int 变量 与 Integer、 new Integer() 比较时，只要两个的值是相等，则为true
因为包装类Integer 和 基本数据类型int 比较时，java会自动拆包装为int ，然后进行比较，实际上就变为两个int变量的比较。
Integer i = new Integer(200); //自动拆箱为 int 2=100; 此时，相当于两个int的比较
int j = 200；
System.out.print(i == j); //true
```

# 重写重载

**方法重写**

+ 重写就是当子类继承自父类的相同方法，输入数据⼀样，但要做出有别于父类的响应时，你就要覆盖父类方法
+ 重写发生在运行期，构造方法不能被继承，所以也不能被重写。如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static修饰的方法能够被再次声明
+ 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。

**方法重载**

+ 重载就是同样的⼀个方法能够根据输⼊数据的不同，做出不同的处理
+ 同一个类中，方法名相同，参数列表不同。只有返回值不同不能算方法重载

# ==与equals()与hashcode

在未重写equals方法我们是继承了Object的equals方法，默认比较两个对象的内存地址

+ 对于值对象，==比较的是两个对象的值
+ 对于引用对象，==比较的是两个对象的地址

```java
默认情况是:
public boolean equals(Object obj) {
        return (this == obj);
    }
一般会重写equals方法以比较两个对象的内容
public boolean equals(Object obj){
	public boolean equals(Object obj){
 		if(this==obj) return true;
 		if(obj==null) return false;
		if(getClass()!=obj.getClass()) return false;

		Person person = (Person) obj;
 		return Objects.equals(name， person.name) &&Objects.equals(age， person.age);
	}
}
所以基本数据类型用==判断相等，引用数据类型都用equals()进行判断(String也是引用类型)
即==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同
==指引用是否相同 equals()指的是值是否相同
```

## 重写hashcode

```java
因为HashSet或HashMap等集合中判断元素是否相等用到了hashcode是否相等，所以为避免我们认为相等但是逻辑判断却不相等的情况出现，自定义类重写equals必须重写hashcode方法
public native int hashCode();

public boolean equals(Object obj) {
        return (this == obj);
    }
无论何时覆盖该方法，通常需要覆盖`hashCode`方法，以便维护`hashCode`方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。

@Override
public int hashCode()
{
    return Objects.hash(username， age);
}
```

+ 如果两个对象相等，则hashcode一定也是相同的

+ 两个对象相等，对两个equals方法返回true

+ 两个对象有相同的hashcode值，它们也不一定是相等的

+ 综上，equals方法被覆盖过，则hashCode方法也必须被覆盖

+ hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。

+ 重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；

    

# 深拷贝与浅拷贝

+ 浅拷贝是对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝
+ 深拷贝是对基本数据类型进行值传递，对引用数据类型，创建⼀个新的对象，并复制其内容

# String

## 定义

```java
public final class String {
    
	private final char value[];
}
```

字符串是常量，不可修改

不仅类定义使用 final 修饰，关键的字符数组同样声明为 private final。

final修饰类定义只能使类不被继承，字符数组被 final 修饰只能保证 value 不能指向其他内存，但我们仍然可以通过 value[0] = 'V' 的方式直接修改 value 的内容。这不能保证字符串的不可修改性

String 是不可变，关键是因为 SUN 公司的工程师，在后面所有 String 的方法里很小心的没有去动数组里的元素，没有暴露内部成员字段。private final char value[] 这一句里，private的私有访问权限的作用都比 final 大。而且设计师还很小心地把整个 String 设成 final 禁止继承，避免被其他人继承后破坏。所以 String 是不可变的关键都在底层的实现，而不是一个 final。

## String a="abc"

+ 判断这个常量是否存在于常量池，如果存在，则直接将该"abc"在常量池中的地址指向s，这个时候，系统没有创建新对象。

+ 如果不存在，则在常量池中新建一个"abc"并放入常量池里面，然后再返回该地址，这个时候，系统创建了一个对象。

## String str = new String(“abc”)

+ 把它拆分成"abc"和new String()
+ 首先在字符串常量池去寻找有没有"abc"这个字符串
    + 没有就创建一个“abc”字符串对象在字符串池中，然后new String把这个字符串对象拷贝一份到堆中，返回这个对象的引用。所以一共产生两个对象（一个驻留在字符串池，一个分配在 Java 堆，str 指向堆上的实例）
    + 如果有的话，则在堆中复制一个该字符串，并且将堆中的引用指向s。（只创建了一个对象，即堆中的对象）



## String a="ab"+"cd"

"ab"和"cd"分别创建了一个对象，它们经过“+”连接后又创建了一个对象"abcd"，因此一共三个，并且它们都被保存在字符串池里了。

```java
String s = "a" + "b";
System.out.println(s == "ab"); // true
//此处虚拟机会做优化，会在常量池里面寻找"a" + "b" 结果后的字符串即"ab"
//所以两者都是对映常量池中"ab"的地址
```

```java
String s1 = "a";
String s2 = "b";
String str = s1 + s2;
System.out.println(str == "ab"); // false
//虽然s1和s2各自指的是常量池里面"a"，"b"的引用，但是string在做加法或者subString、replace等方法的时候
//实际上返回的是new String()的结果，因此str指向的是堆中的地址，所以不相等。
```



常量优化机制：判断这两个常量、相加后的常量在常量池是否存在

+ 如果不存在则在常量池上创建相应的常量（并将常量地址值返回）
+ 如果存在，则直接返回地址值

```java
/*
首先第一句话 String  s1 = new String("123") 以上分析过创建了两个对象（一个堆中，一个常量池 中）此时s1指向堆中
当s1调用.intern()方法之后，发现常量池中已经有了字面量是123的常量，则直接把常量池的地址返回给s1
在执行s2等于123时候，去常量池查看，同上常量池已经存在了，则此时s2不创建对象，直接拿常量池123的地址值使用
所以此时s1 和 s2 都代表是常量池的地址值，则输出为true
 */
String  s1 = new String("123").intern();
String  s2 = "1"+"23";
System.out.println(s1 == s2);//true
```

## String s1 = new String("1")+new String("23");

```java
String s1 = new String("1")+new String("23");

/*
首先堆中会有 1 ，23 ，以及相加之后的123 这三个对象。如果 1，23 这两个对象在常量池中没有相等的字面量
那么还会在常量池中创建2个对象 最大创建了5个对象。最小创建了3个对象，都在堆中。
*/

s1.intern();

String s2 = "123";

System.out.println( s1 == s2);// true
```

- 首先会创建这两个对象（堆中）以及相加后的对象（堆中）
- 然后判断常量池中是否存在这两个对象的字面量常量
- 如果存在则不做任何操作
- 如果不存在则在常量池上创建对应常量



# String::intern()

String::intern()是本地方法，如果字符串常量池中已经包含了一个等于此String对象的字符串，则返回代表池中这个字符串对象的引用，否则会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用

直接使用双引号声明出来的String对象会直接存储在常量池中。

如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。

判断这个常量是否存在于常量池。

+ 如果存在，则直接返回地址值
    + 如果是引用，返回引用地址指向的堆空间对象地址值
    + 如果是常量，则直接返回常量池常量的地址值
+ 如果不存在，将当前对象引用复制到常量池，并且返回的是当前对象的引用

```java
String s1 = new String("1")+new String("23");
s1.intern();
String s2 = "123";
System.out.println( s1 == s2);//true
/*
首先看第一行是两个new String类型的字符串相加，这里创建了堆中有3个对象 一个是1， 一个是23，还有一个是结果 123
由于程序刚启动常量池也没有1，23所以会在常量池创建2个对象（1，23）
当s1执行intern()方法之后，首先去常量池判断有没有123，此时发现没有，所以会把对象加入到常量池，并且返回当前对象的引用（堆中的地址）
当创建s2时候，并且找到常量池中123，并且把常量池的地址值返回给s2
由于常量池的地址值就是s1调用intern（）方法之后得到的堆中的引用，所以此时s1和s2的地址值一样，输出true。
*/
```

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/无标题.png)

```java
String s1 = new String("1")+new String("23");
String s2 = "123";
s1.intern();
System.out.println( s1 == s2);//false

/*
在执行到第二行的时候String s2 = "123"时，发现常量池没有123，所以会先创建一个常量
在当s1调用intern()方法时，会发现常量池已经有了123对象，就会直接把123的常量给返回出去，但是由于返回值并没有接收，所以此时s1还是堆中地址，则输入false；如果代码换成 s1 = s1.intern();那s1就会重新指向常量池了，那输出就为true；
*/
```



```java
public static void main(String[] args) {
    String str1 = new StringBuilder("58").append("tongcheng").toString();
    System.out.println(str1);
    System.out.println(str1.intern());
    System.out.println(str1==str1.intern());//true
/*
既然字符串常量池已经移到了Java堆中，那只需要在常量池中记录一下首次出现的实例引用即可
*/

    System.out.println();

    String str2 = new StringBuilder("ja").append("va").toString();
    System.out.println(str2);
    System.out.println(str2.intern());
    //初始化的字符串java，在加载sum.misc.Version这个类时旧加载进了常量池
    //引导类加载器加载了rt.jar
    System.out.println(str2==str2.intern());//false
}
```



# String、StringBuilder与StringBuffer

## 不可变String

+ String 类中使用 final 关键字修饰字符数组来保存字符串`private final char value[];`
+ String对象是不可变的，任何一个操纵都是创建了一个全新的String对象以包含修改后的字符串内容
+ 由于存放字符的数组被声明为 final 的，因此只能赋值一次，不可再更改。
+ 每当把String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上
+ 所有指向String的任何引用都不可能改变他的值
+ 如果字符串操作比较简单，直接相信编译器会合理的构造，否则还是自己创建一个StringBuilder
+ 在toString方法中，如果要打印出对象的内存地址，应该调用Object.toString()，所以应该调用的是super.toString()，而不能调用this.toString()(会递归)
+ String的操作中，如果需要改变字符串的内容，则会返回一个新的String对象。如果内容没有改变，则返回原对象的引用

## StringBuilder与StringBuffer

+ 他们都继承自AbstractStringBuilder，用了char[] value; 没加final修饰
+ StringBuffer使用synchronized修饰，是线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。
+ 在内部，StringBuilder 对象被当作是一个包含字符序列的变长数组，是非线程安全的

## 三者区别

String 类型和 StringBuffer 的主要性能区别：String 是不可变的对象, 因此在每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，性能就会降低。

使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。所以多数情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。

在某些特别情况下， String 对象的字符串拼接其实是被 Java Compiler 编译成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，例如：

```java
String s1 = “This is only a” + “ simple” + “ test”;
StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);
```

- 基本原则：如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer。
- 不要使用String类的"+"来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类。

# 注解

+ 提供用来完整描述程序所需的信息
+ 注解一旦构造出来，就享有编译期的类型检查保护，是在实际的源代码级别保存所有的信息
+ @SuppressWarnings("checked")关闭不当的编译器警告信息
+ @Deprecated标识已弃用
+ @Override:覆盖超类的方法

## 定义注解

+ 注解会被编译成class文件
+ 需要一些源注解来实现，而且有注解还需要处理注解，即提取出注解的信息
+ @Target(ElementType.METHOD)表明是用于方法
+ @Retention(RetentionPolicy.RUNTIME)表明在运行时可用(共有源代码级别，类文件级别，运行时级别)

# 泛型

## 擦除

+ 在泛型代码内部，无法获得任何有关泛型参数类型的信息
+ List<String>与List<Integer> 都被擦除成他们原生的类型，即List
+ 泛型类型参数将擦除到他的第一个边界
+ 泛型类型只有在静态类型检查期间才出现，之后会擦除替换为他们的非泛型上界
+ 如List<T>擦除为List，未指定边界的将擦除为Object
+ 任何在运行时需要知道确切类型信息的操作都无法继续工作

## 泛型方法

+ 尽量使用泛型方法
+ static方法无法访问泛型类的类型信息，要使用泛型能力，则必须成为泛型方法
+ 泛型方法会使用类型参数推断
+ 如果传入基本类型，则会自动装箱

```java
public class MainTest
{
    public static void main(String[] args)
    {

        MainTest mainTest = new MainTest();
        mainTest.test(1);
        mainTest.test("ABC");
        //java.lang.Integer
        //java.lang.String
    }

    public <T> void test(T x)
    {
        System.out.println(x.getClass().getName());
    }
}
```

## 泛型数组

+ 数组将跟踪他们的实际类型，而这个类型是数组在创建时确定的，因此，尽管array被转型成了List<String>[]，这个信息也只存在于编译期，在运行时，它仍然是一个Object数组
+ 唯一方式是创建一个被擦除类型的新数组，然后对他转型
+ 因为有了擦除，数组的运行时类型只能是Object[]，如果立即转型为T[]，那么编译期数组的实际类型就丢失，所以最好在集合内部使用Object[]，使用数组类型时，才转型为T[]

```java
List<String>[] array = (List<String>[]) new Object[10];
//java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.util.List
```

## 泛型带来的问题

+  不能创建类似ArrayList<int>等，只能改成包装类ArrayList<Integer>
+  不能使用泛型来区分重载方法
+  catch不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型

# 反射

+ Class对象包含了与类有关的信息，用来创建类的所有常规对象的
+ 每个类都有有个Class对象，保存在同名的.class文件中
+ 想要在运行时获得类型信息，就必须首先获取对Class对象的引用

```java
public static void main(String[] args)
{
    try
    {

        //使用全限定名
        Class<?> clazz = Class.forName("com.tongji.Wrapping");

        //使用getClass()方法
        Wrapping wrapping = new Wrapping(1);
        clazz=wrapping.getClass();

        //使用.class创建对Class对象的引用时，不会自动地初始化该Clas对象
        clazz = Wrapping.class;

        //clazz = int.class; 也可用于基本数据类型

        System.out.println(Arrays.toString(clazz.getConstructors()));

        //使用newInstance()则必须具有默认构造器
        //newInstance()返回的只是Object类型
        Object object = clazz.newInstance();
    }
    catch (ClassNotFoundException | IllegalAccessException | InstantiationException e)
    {
        e.printStackTrace();
    }
}
```

# i++、++i

```java
public static void main(String[] args) {
    int i = 1;
    i = i++;//1
    i = ++i;//2
    int j = i++;//3
    int k = ++j;
    int m = i++ * ++i;//3*5
    System.out.println("m: " + m);//15
}
```

# 交换引用

![image-20210218104459116](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218104459116.png)

```java
public static void main(String[] args) {
    Integer i = 10;
    Integer j = 5;
    Test test = new Test();
    System.out.println("i:" + i + " j:" + j);//10 5
    test.doSwap(i， j);
    System.out.println("i:" + i + " j:" + j);//10 5
}

public void doSwap(Integer a， Integer b) {
    Integer temp = a;
    a = b;
    b = temp;
}
```