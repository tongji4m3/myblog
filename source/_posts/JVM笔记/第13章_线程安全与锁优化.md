---
title: 深入理解Java虚拟机--线程安全与锁优化
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第13章--线程安全与锁优化。'
categories: JVM学习笔记
tags:
  - 深入理解Java虚拟机
  - 线程
  - 锁
abbrlink: 27a1f8de
date: 2020-07-26 00:00:00
---

# 线程安全

当多个线程同时访问一个对象时,如果不用考虑这些线程在运行时环境下的调度和交替执行,也不需要进行额外的同步,或者在调用方进行任何其他的协调操作,调用这个对象的行为都可以获得正确的结果,就称他为线程安全的

代码本身封装了所有必要的正确性保证手段(如互斥同步等),令调用者无须关心多线程下的调用问题,更无须自己实现任何措施来保证多线程环境下的正确调用.一般弱化为单次调用



## Java中的线程安全

以多个线程间存在共享数据的访问为前提

### 不可变

不可变对象一定是线程安全的。只要一个不可变对象被正确的创建出来了，那其外部的可见状态让永远不会改变，永远不会看到他在多个线程之中处于不一致的状态。

用final修饰，或者一个对象自行保证其行为不会对其状态产生任何影响，如String

### 绝对线程安全

在Java API中标注自己是线程安全的类，绝大多数都不是绝对的线程安全

### 相对线程安全

通常意义上的线程安全，需要保证对这个对象的单次操作是线程安全的，在调用的时候不需要进行额外的保障操作。

### 线程兼容

对象本身不是线程安全的。如ArrayList，HashMap等

### 线程对立

不管调用端是否采用了同步措施，都无法在多线程环境中并发使用代码。很少出现，通常有害，尽量避免

## 线程安全的实现方法

### 互斥同步

同步：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用

互斥：实现同步的一个手段

synchronized关键字，在经过javac编译后，会在同步块前后分别形成monitorenter,monitorexit两条字节码指令。需要一个reference类型的参数来指明要锁定，解锁的对象。

如果没有明确规定，则如果是实例方法就用对象实例作为锁，否则用该类型的Class对象作为锁

在执行monitorenter指令时，首先要去尝试获取对象的锁。如果该对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加1，而在执行monitorexit指令时会把锁计数器值-1。一旦计数器的值为0，锁立即被释放。如果获取对象锁失败，当前线程就应该被阻塞等待，直到请求锁定的对象被持有他的对象释放为止。

1. 被synchronized关键字修饰的同步块对同一个线程来说是可重入的。

2. 被synchronized关键字修饰的同步块在持有锁的线程释放锁之前，会无条件阻塞后面其他线程的进入。

	

### 重入锁（ReentrantLock)
与synchronized的不同：
1. 等待可中断：正在等待的线程可以放弃等待，改为处理其他事情。
2. 公平锁：可以通过设置，按照申请锁的时间顺序来依次获得锁
3. 锁锁定多个对象：一个ReentrantLock对象可以同时绑定多个Condition对象

在ReentrantLock与synchronized同时满足时优先使用synchronized：
1. synchronized是Java语言层面的同步，足够清晰
2. synchronized由Java虚拟机保证即使出现异常，锁也能被正确释放
3. Java虚拟机更容易针对synchronized进行优化

### 非阻塞同步
互斥同步是一种悲观的并发策略：其总是认为如果不去加锁，就肯定出问题。所以无论是否出现竞争，他都会加锁。
基于冲突检测的乐观并发策略（无锁）：不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。

需要保证操作和冲突检测这两个步骤具有原子性。例如：
测试并设置（TAS），比较和交换（CAS）
CAS（变量的内存地址V，旧的预期值A，准备设置的新值B):仅当V符合A时，处理器才会用B更新V的值，否则就不执行更新。无论是否更新V，都会返回A，整个操作是原子操作
Java提供compareAndSet操作，一般使用逻辑：
```java
for(;;)
{
	int current=get();
	int next=current+1;
	if(compareAndSet(current,next))
	{
		return next;
	}
}
```
可能出现ABA问题，可以通过：提供一个带有标记的原子引用类控制变量值的版本来保证CAS的正确性

### 无同步方案
#### 可重入代码
是线程安全代码的一个子集。如果一个方法的返回结果是可以预测的，只要输入相同的数据，就能返回相同的结果，就满足可重入的要求，就是线程安全的。
#### 线程本地存储
如果一段代码中所需要的数据必须与其他代码共享，但是这些共享数据的代码能保证在同一个线程中执行。如Web交互模型中的“一个请求对应一个服务器线程”

# 锁优化
## 自旋锁与只适应自旋
自旋锁：很多应用上，共享数据的锁定状态只会持续很短一段时间。可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环。自旋有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就会用传统的方式挂起线程。
只适应自旋：自旋的时间不是固定的，而是由前一个在同一个锁上的自旋时间以及锁的拥有者的状态来决定
## 锁消除
即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。来源于逃逸分析技术。如果判断一段代码中所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的
## 锁粗化
原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，就应该把加锁同步的范围粗化到整个操作序列的外部。
## 轻量级锁
在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量造成的性能消耗
### 对象的内存布局
对象头：
第一部分是MarkWord用于存储对象自身的运行时数据，如HashCode，GC分代年龄等
另一部分存储指向方法区对象类型数据的指针。
如果是数组对象，还有一个额外的部分存储数组长度

MarkWord根据对象的状态复用自己的存储空间。
轻量级锁能提升程序同步性能的依据：对于绝大部分的锁，在整个同步期间都是没有竞争的

### 偏向锁
在无竞争的情况下把整个同步都消除掉，这个锁会偏向于第一个获得他的线程