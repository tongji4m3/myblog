---
title: 深入理解Java虚拟机--类文件结构
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第六章--类文件结构。'
categories: JVM学习笔记
tags:
  - 深入理解Java虚拟机
  - JVM
  - Class
abbrlink: b05d8834
date: 2020-07-08 00:00:00
---
# Class类文件的结构

1. 以八个字节为基础单位的二进制流
2. 无符号数为基本数据类型。以u1,u2,u4,u8分别代表1字节，2字节，4字节，8字节的无符号数
3. 表是由多个无符号数或者其他表作为数据项构成的复合数据类型。习惯以_info结尾

## 魔数与Class文件的版本

1. 头四个字节为魔数，标识他为Class文件。值为0xCAFEBABE
2. 后面四个字节为版本号。前两个为次版本号（Minor Version）,后两个为主版本号（Minor Version）。次版本号基本未使用，固定为0。主版本号从45开始。
3. 高版本JDK能向下兼容以前的Class文件但是不能运行之后版本的Class文件
4. 例如JDK1.1能支持的版本号为:`45.0-45.65535`,JDK1.2支持`45.0-46.65535`

## 常量池

1. 主要存放字面量和符号引用。字面量类似常量，如文本字符串，被声明为final的常量值等等。符号引用属于编译原理相关，包括全限定类名，方法字段名称等等
2. 符号引用不经过虚拟机运行期转换就无法得到真正的内存入口地址，就无法被虚拟机直接使用。当虚拟机做类加载时，将从常量池获取相应的符号引用，再在类创建时或运行时解析翻译到具体的内存地址中。

### CONSTANT_Class_info

1. 用u1存储tag，标识常量类型
2. 用u2存储name_index,是常量池的索引值，指向一个CONSTANT_Utf8_info类型常量，代表了该类的全限定名。

### CONSTANT_Utf8_info

1. 用u1存储tag，标识常量类型
2. 用u2存储length，代表字符串长度是多少字节
3. 之后是用u1存储bytes，一共有length个字节

## 访问标志

常量池之后两个字节代表访问标志。例如：是类还是接口，是否是public，是否是abstract等等

## 类索引，父类索引，接口索引集合

1. 类索引，父类索引为u2类型的数据，接口索引集合为u2类型的数据集合。由此确定该类型的继承关系。
2. 类索引，父类索引用u2类型的索引值表示，各自指向一个`CONSTANT_Class_info`的类描述符常量。又通过该常量的`CONSTANT_Utf8_info`找到全限定名字符串。
3. 接口索引集合第一项的u2类型的数据为接口计数器，表示索引表的容量。

## 字段表集合

1. 描述变量，包括类级变量，实例级变量，但不包括方法中的局部变量。
2. 字段包括: 修饰符`（public，private,protected,static,final,volatile,transient）`,字符数据类型（基本类型，对象，数组）,字段名称
3. 修饰符适合用标志位表示，但字符数据类型，字段名称只能引用常量池中的常量来描述
4. 字符修饰符用u2,access_flags表示。之后是u2的name_index,descriptor_index是对常量池的引用，代表了字段的简单名称和方法的描述符。
5. 描述符用来描述字段的数据类型，方法的参数列表和返回值。基本数据类型类型和void用一个大写字符表示。例如C代表char。对象类型用L加对象的全限定名表示，例如Ljava/lang/Object;
6. 数组每一维度用一个`[`表示，如定义了`java.lang.String [][]`则记录为`[[Ljava/lang/String;`
7. 用描述符描述方法，则先参照列表，再返回值的顺序描述。例如`String test(char [] chars)`为   `([C)[Ljava/lang/String;`
8. 字段表集合不会列出从父类或者父接口中继承来的字段。但有可能出现Java代码中不存在的字段。例如编译器为内部类自动添加指向外部类实例的字段。

## 方法表集合

1. 和字段表集合极其相似。没有`volatile,transient`,但多了`synchronized,native,strictfp,abstract`关键字
2. 方法中的代码，存放再方法属性表集合中名为`Code`的属性里面
3. 若子类没有重写父类方法，则不会出现父类方法信息
4. 有可能出现由编译器自动添加的方法，例如类构造器`<cinit>()`,实例构造器`<init>()`方法

## 属性表集合

Class文件，字段表，方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。

### Code属性

1. 方法体中代码经过Javac编译器处理后，变成字节码指令存储在Code属性中
2. `attribute_name_index`是指向`CONSTANT_Utf8_info`的索引，固定为"Code"，代表该属性名称
3. `attribute_length`指示了属性值的长度，为u4
4. `max_stack`代表了操作数栈深度的最大值。根据该值来分配栈帧中的操作数栈深度。
5. `max_locals`代表了局部变量表所需的存储空间。单位是Slot（变量槽），变量槽是虚拟机为局部变量分配内存所使用的最小单位。不超过32位的一个槽，double和long占用两个槽。
6. 方法参数（包括实例方法隐藏参数this），异常参数，方法体中的局部变量都依赖局部变量表存储
7. 虚拟机将局部变量表中的变量槽复用。当代码执行超出了一个局部变量的作用域时，该局部变量所占的变量槽可以被其他局部变量使用。根据同时生成的最大局部变量数量和类型算出`max_locals`的大小
8. `code_length`,`code`存储Java源程序编译后生成的字节码指令。每个指令是u1的单字节。可以对应找出该字节码代表什么指令。
9. Code属性用于描述代码，其他项目用于描述元数据。
10. 任何实例方法里面，都可以通过this访问到该方法所属的对象。是通过编译器编译时把对this关键字的访问转变位对一个普通方法参数的访问，虚拟机在调用实例方法时自动传入此参数。因此任何实例方法的局部变量表至少存在一个指向当前对象实例的局部变量。局部变量表也会预留出第一个变量槽位来存放实例对象的引用。
11. 异常表，当字节码从第`start_pc`到第`end_pc`出现了类型为`catch_type`或其子类的异常，则转到第`handle_pc`行继续处理。

### Exceptions属性

列举出方法中可能抛出的受查异常。即方法中throws后面列举的异常。

### LineNumberTable属性

描述Java源码行号和字节码行号的对应关系。非必须，但如果没有，抛出异常时不会显示出错行号，调试程序也无法按照源码设置断点。

### LocalVariableTable和LocalVariableTypeTable属性

描述栈帧中局部变量表的变量和Java源码中定义的变量之间的关系。非必须，但没有当其他人引用方法，所有参数名称将会丢失，用arg0,arg1等替代参数名。
### SourceFile属性
用于记录生成这个Class文件的源码文件名称.大多数类,类名和文件名一致,但有例外。
### ConstantValue属性
1. 通知虚拟机自动为静态变量赋值。
2. 对实例变量赋值再<init>()方法中。
3. 对于类变量，若是final，static修饰，并且是基本类型或者String的话,用`ConstantValue`进行初始化。否则会选择在`<cinit()`方法初始化。

### InnerClasses属性

用于记录内部类和宿主类之间的关联。

### Deprecated及Synthetic属性

Deprecated属性用于表示某个类，字段或者方法，已经被程序作者定为不再推荐使用。可以用`@deprecated`注解进行设置。

Synthetic属性标识此字段或方法不是由Java源码直接产生的，而是由编译器自行添加的。

### StackMapTable属性

在虚拟机类加载的字节码验证阶段被新类型检查验证器使用。

### Signature属性

若包含了类型变量或参数化类型，则该属性会为他记录泛型签名信息

### BootStrapMethods属性

保存`invokedynamic`指令引用的引导方法限定符

### MethodParameters属性

记录方法的各个形参名称和信息

### 模块化相关属性

支持Java模块化相关功能

### 运行时注解相关属性

记录了类,字段,方法的声明上记录运行时可见注解

# 字节码指令简介

由一个字节长度的操作码和零或多个的操作数构成.是面向操作数栈的,所以大多数指令不包括操作数,只有操作码.指令参数都放在操作数栈中。

## 字节码与数据类型

1. iload指令用于从局部变量表中加载int型的数据到操作数栈中
2. 大多数指令没有支持byte,char,short,boolean。编译器会在编译或者运行期将他们扩展为int型数据

## 加载和存储指令

用于将数据在栈帧中的局部变量表和操作数栈之间来回传输

## 运算指令

用于对操作数栈上的两个值进行某种特定运算，并且把结果重新存入操作栈顶

大致分为两种类型：对整数数据，浮点型数据

不存在直接支持byte,short,char,boolean的运算，都是用操作int类型的指令代替

## 类型转换指令

1. 将两种不同的数据类型相互转换，实现用户代码中的显式类型转换
2. 小范围到大范围类型为安全转换，无须显示的转换指令，如`int 转 long,float,double`,`long转folat,double`,`float转double`
3. int转long，只会简单的将高位抛弃，所以可能导致不同的正负号
4. 转换可能出现上限溢出，下限溢出，精度丢失等等，但永远不可能导致虚拟机抛出运行时异常

## 对象创建与访问指令

Java虚拟机对类实例和数组的创建使用了不同的字节码指令

## 操作数栈管理指令

将操作数栈顶一个或者两个元素出栈：pop,pop2

将栈顶最顶端两个数值交换：swap

## 控制转移指令

有条件或无条件的修改PC寄存器的值，从指定位置指令的下一条指令继续执行程序

各种类型的比较最终都会转化为int类型的比较操作

## 方法调用和返回指令

1. `invokevirtual`:用于调用对象的实例方法,根据对象的实际类型进行分派(虚方法分派)
2. `invokeinterface`:用于调用接口方法,在运行时搜索一个实现了这个接口方法的对象,找出合适的方法调用
3. `invokespecial`:调用一些需要特殊处理的实例方法,例如实例初始化方法,私有方法,父类方法
4. `invokestatic`:用于调用静态方法(static)方法
5. `invokedynamic`:用于在运行时动态解析出调用点限定符所引用的方法
6. 方法返回指令是根据返回值的类型区分的.包括ireturn(返回类型是boolean,byte,char,short,int),lreturn,freturn,dreturn,areturn,return(返回值为void的,实例初始化的,类和接口的类初始化方法)

## 异常处理指令

对显示抛出异常的操作（throw语句）进行处理

而处理异常（catch语句）不由字节码指令实现，是由异常表实现

## 同步指令

Java虚拟机可以支持方法级同步和方法内部一段指令序列的同步,使用管程实现.

执行线程要求先成功持有管程,然后才能执行方法,最后当方法完成时释放管程

使用synchronized语句块表示

无论这个方法是正常结束还是异常退出,方法调用的每条monitorenter指令都必须有其对应的monitorexit指令



# 公有设计，私有实现

<<Java虚拟机规范>>描绘了Java虚拟机应有的共同程序存储格

式：Class文件格式以及字节码指令集

任何一款Java虚拟机都必须能读取Class文件并且精确实现其中的Java虚拟机代码的语义

Java虚拟机只要外部接口与规范描述一致即可，具体实现不规定

# 小结

Class文件格式具备平台中立，紧凑，稳定，可扩展性的特点。是Java技术体系实现平台无关，语言无关的重要支柱

Class文件是Java虚拟机执行引擎的数据入口。