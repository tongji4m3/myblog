---
title: Java基础--Java简介
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 'Java基础知识之Java简介,待完善,之后再看的时候会继续补充。'
categories: Java基础
tags:
  - Java基础
abbrlink: 31c6b392
date: 2020-02-27 00:00:00
---
# java简介
## 主要特性

1. 简单性(不能直接操作指针)
2. 面向对象性
3. 健壮性(GC机制)
4. 多线程并发
5. 可移植性/跨平台性 write once,run everywhere


## JDK,JRE,JVM
1. JDK包括JRE,JRE包括JVM
2. JDK:开发工具包
3. JRE:java运行环境
4. 安装JDK自带JRE,因为开发还需要测试

## javac,java
1. javac在编译期,将.java文件形成.class文件 `javac MainTest.java`
	相对路径写法，即MainTest.java必须在当前路径下
2. java在运行期,运行.class文件   `java MainTest`
	如果指定了classpath则不必，否则MainTest.class也必须在当前路径下

# JAVA配置环境变量解析
## 环境变量简介
环境变量包括了 系统变量,用户变量
系统变量的范围比较大,会让所有计算机用户都生效
用户变量只会作用与当前用户

## path环境变量
path环境变量告诉windows可以去哪里找到命令.这样就不用写程序的绝对路径了,如
`C:\Program Files\Java\jdk1.8.0_261\bin\javac.exe`或者
`%JAVA_HOME%\bin\java`
可以直接在任何路径下的命令行敲javac

## classpath
1. 默认情况下classpath只加载当前路径下的class文件
2. classpath给类加载器指定路径,让类加载器去指定路径下加载字节码
3. 为了程序能找到相应的".class"文件
3. classpath不区分大小写,如CLASSPATH
4. CLASSPATH配置:`.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar`
## JAVA_HOME
1. 方便引用。`C:\Program Files\Java\jdk1.8.0_261`,设置JAVA_HOME为该目录路径, 那么以后你要使用这个路径的时候, 只需输入%JAVA_HOME%即可,避免每次引用都输入很长的路径串;
2. 归一原则。即只需改一处
3. 有些第三方软件例如Tomcat约定要用JAVA_HOME

# 基础
## class文件
1. 一个java源文件可以定义多个class
2. 源文件中只要有一个class定义，就会产生一个class文件
3. public类可以没有，但有则必须与源文件名保持一致，且只能有一个
4. 每个类都能有自己的main方法



## 字符编码

1. ASCII码用byte进行编码。计算机先编码，再解码，如果用的不是同一个编码方法，则乱码。 ‘a' : 97，'A' : 65， space : 32
2. GBK支持中文
3. Unicode支持全世界语言文字。具体实现有UTF-8
4. char可以存储一个汉字，采用Unicode编码，用单引号
5. 计算机只存储二进制的补码

## 转义字符
1. \为转义字符，在输出或者字符串中使用，\加特殊符号则转为普通符号，例如`\"`等等
2. \u 后面跟16进制为输出对应的unicode码。例如`\u 4e2d`可以转为汉字"中"，（注意没有空格，只是因为typora也会转义)

## 类型转换
1. int型中，0x开头代表16进制,如:0xCAFE ，0b开头为二进制，例如int a=0b110,输出结果为6
2. 一个字面量，默认当作int类型处理，后面加L则默认为long类型
3. 自动类型转换： long b=200; 200字面量首先默认当作int型，但是自动转换为long。而long b=300L,300字面量默认当作long，赋值给b不存在类型转换。
4. long a=200_0000_0000会报错，因为后者默认先为int时，已经超出int，就报错了
5. 大容量转小容量需要强制类型转换，有可能损失精度
6. byte中，当整数型不超过[-128,127]时，该字面量可以直接赋值给byte，不需要类型转换。`byte x=127; byte a = (byte)128;`short，char也是可以的。只有字面量可以这样转换，例如 `short s=a+x`则会报错：不兼容的类型：从int转换到short可能会有损失。
7. `char ch=97`一个整数赋值给char类型变量能自动类型转换
8. byte，short，char混合运算，都会先转换为int再运算
9. 多种数据类型混合运算，最终结果为“最大容量”类型
10. boolean类型不能转换
11. 如果整数型字面量没有超过byte，short,char的取值范围，可以直接将其赋值给他们相应类型的变量
12. 容量比较：byte<short(char)<int<long<float<double  char比short代表更大的正整数
13. 
## 浮点型
1. float容量>long容量 `3.4028235E38`与`9223372036854775807`
2. 所有浮点型默认当作double类型处理，要当作Float，后面加F

## 运算符
1. ```java
    byte x=100
    x+=1
    //+=不会改变运算结果类型 
    //x+=1   ====== x=(byte)(x+1)
    ```
2. +两边只要有一边是字符串类型，拼接完就还是字符串。遵循从左到右的原则，例如`System.out.println(100+200+"300");//300300`
## 方法

1. 方法重载：同一个类中，方法名相同，参数列表不同。只有返回值不同不能算方法重载
2. 尽量不使用递归，消耗内存大
3. 方法参数传递只有传值,引用对象也是.不过引用对象传递了地址值过去,所以修改能成功.引用被拷贝,指向的是原对象,所以仍能改变对象值

## 对象相关

1. 在类加载时执行且只执行一次
2. 一个类中可以写多个,代码块有先后顺序,自上而下执行
3. 静态代码块与静态变量有先后顺序
4. 此时其他非静态的还未创建
5. 在构造方法执行之前,执行实例语句块
6. this为指向自己的引用.实例对象只有有引用才能访问.所以类中访问成员变量,方法时,省略了this。即age其实是this.age。即当前对象的成员变量age
7. this不能用于静态方法，因为静态方法调用不需要this


## 数组

数组是引用数据类型,数组父类是Object,存储在堆中

数组元素首地址作为整个数组对象的地址

初始化数组有默认值,如:

`String [] names=new String[6]`每个元素初始化为null

# 继承多态

## 继承

### 基础

1. 只允许单继承
2. 子类继承父类的所有除了构造方法，但是父类私有的属性无法在子类直接访问
3. 都继承了Object
4. this是指向自己的引用
5. super不是引用，也不保存内存地址，也不指向一块对象，只是代表当前对象内部的那一块父类型的特征
6. this（），super（）都只能出现在构造方法第一行。为u的是创建子类对象时，先初始化父类的特征

### 方法覆盖

1. 私有方法无法覆盖

2. 构造方法不能被继承，所以也不能被覆盖

3. 静态方法覆盖没有意义

4. 方法名相同，参数相同，一般来说返回类型也相同。子类的返回值与父类相同或者是父类返回类型的子类型。

5. 子类方法可以具有相同的访问权限或者子类的访问权限大于父类

6. 子类方法不能比父类方法抛出更多的编译时异常（不是运行时异常），即子类方法抛出的编译时异常或者和父类相同或者是父类异常的子类。

	

## 多态

### 基础

多态：编辑阶段是一种状态，运行阶段又是另外一种状态。父类引用指向子类对象

向上转型：子类转为父类。
		向下转型：父类转为子类，需要加强制类型转换符。

编译阶段属于静态绑定
		运行阶段属于动态绑定

### 子类特有方法

1. ` Animal animal=new Cat();`
2. 编译阶段绑定父类的方法，运行阶段绑定子类对象的方法
3. 只有编译通过的代码才能运行，所以直接使用子类的方法编译期间就通不过
4. 编译期间只知道引用是父类型的变量
5. 当一定需要使用子类特有的方法，则要向下转型
6. 为避免ClassCastException异常，使用instanceof语法，可以在运行阶段动态判断引用指向的对象的类型。（引用 instanceof 类型） 结果为true/false

## final

1. final修饰的变量只能赋一次值
2. 引用也是变量,存内存地址.所以final修饰的引用只要指向了一个对象就永远指向那个变量
3. 局部变量没有初始值,只能手动赋值
4. 虽然实例变量如果没有手动赋值,系统会赋默认值。但是final修饰实例变量,内部实现让他必须要手动赋值。手动赋值可以在变量后面直接赋值，或者在构造器中赋值
5. 实例对象用final修饰，说明该实例变量值不会随着对象的变化而变化，所以一般加static修饰变成常量
6. 常量，静态变量存储在方法区中，在类加载时初始化

