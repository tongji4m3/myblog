---
title: 第十五章--泛型
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: '<< Java编程思想 >>读书笔记,第十五章--泛型。泛型的相关问题'
categories: Java编程思想
tags:
  - Java基础
  - 泛型
  - 多态
abbrlink: d2c6f132
date: 2020-11-03 00:00:00
---

> <<Java编程思想>>读书笔记

# 元组

```java
public class TwoTuple<A,B>
{
    public final A first;
    public final A second;

    public TwoTuple(A first, A second)
    {
        this.first = first;
        this.second = second;
    }

    @Override
    public String toString()
    {
        return "TwoTuple{" +
                "first=" + first +
                ", second=" + second +
                '}';
    }
}
```

# 泛型方法

+ 尽量使用泛型方法
+ `static`方法无法访问泛型类的类型信息,要使用泛型能力,则必须成为泛型方法
+ 泛型方法会使用类型参数推断
+ 如果传入基本类型,则会自动装箱

```java
public class MainTest
{
    public static void main(String[] args)
    {

        MainTest mainTest = new MainTest();
        mainTest.test(1);
        mainTest.test("ABC");
        //java.lang.Integer
        //java.lang.String
    }

    public <T> void test(T x)
    {
        System.out.println(x.getClass().getName());
    }
}
```

# 擦除

+ 在泛型代码内部,无法获得任何有关泛型参数类型的信息
+ `List<String>`与`List<Integer> `都被擦除成他们原生的类型,即`List`
+ 泛型类型参数将擦除到他的第一个边界
+ 泛型类型只有在静态类型检查期间才出现,之后会擦除替换为他们的非泛型上界
+ 如`List<T>`擦除为`List`,未指定边界的将擦除为`Object`
+ 任何在运行时需要知道确切类型信息的操作都无法继续工作

## 泛型数组

```java
List<String>[] array = (List<String>[]) new Object[10];
//java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.util.List
```



+ 数组将跟踪他们的实际类型,而这个类型是数组在创建时确定的,因此,尽管`array`被转型成了`List<String>[]`,这个信息也只存在于编译期,在运行时,它仍然是一个`Object`数组
+ 唯一方式是创建一个被擦除类型的新数组,然后对他转型
+ 因为有了擦除,数组的运行时类型只能是`Object[]`,如果立即转型为`T[]`,那么编译期数组的实际类型就丢失,所以最好在集合内部使用`Object[]`,使用数组类型时,才转型为`T[]`

# 问题

1. 不能创建类似`ArrayList<int>`等,只能改成包装类`ArrayList<Integer>`
2. 一个类不能实现同一个泛型接口的两种变体
3. 使用带有泛型类型参数的转型不会有任何其他效果,还是会警告

```java
@SuppressWarnings("unchecked")
public T test()
{
    Object[] objects = new Object[10];
    objects[0] = t;
    return (T) objects[0];//不抑制就有警告
}
```

4. 不能使用泛型来区分重载方法
5. `catch`不能捕获泛型类型的异常,因为在编译期和运行时都必须知道异常的确切类型