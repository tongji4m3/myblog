---
title: 第十章--内部类
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: '<< Java编程思想 >>读书笔记,第十章--内部类。匿名内部类'
categories: Java编程思想
tags:
  - Java基础
  - 内部类
abbrlink: eaca0a57
date: 2020-10-26 00:00:00
---

> <<Java编程思想>>读书笔记



# 创建内部类

```java
public class Parcel
{
    public class Contents
    {
        public Parcel outer()
        {
            return Parcel.this;
        }
    }

    public Contents contents()
    {
        return new Contents();
    }
}
```

```java
public class MainTest
{
    public static void main(String[] args)
    {
        Parcel parcel = new Parcel();
        Parcel.Contents contents = parcel.contents();
        //引用外部类对象
        Parcel outer = contents.outer();
        //使用外部类的对象来创建内部类对象
        Parcel.Contents contents1 = parcel.new Contents();
    }
}
```

# 链接到外部类

1. 内部类能访问其外部对象的所有成员,而不需要任何特殊条件
2. 它秘密捕获一个指向外部类对象的引用
3. 在拥有外部类对象之前是不可能创建内部类对象的,因为内部类有指向外部类对象的引用
4. 创建静态内部类则不需要先创建外部类对象

# 匿名内部类

## 使用带参数构造器

`i`被传递给匿名类的基类的构造器

```java
public class Wrapping
{
    private int i;

    public Wrapping(int i)
    {
        this.i = i;
    }

    public int value()
    {
        return i;
    }
}
```

```java
public class MainTest
{
    public static void main(String[] args)
    {
        Wrapping wrapping = wrapping(2);
        System.out.println(wrapping.value());//94
    }

    public static Wrapping wrapping(int x)
    {
        return new Wrapping(x)
        {
          public int value()
          {
              return super.value() * 47;
          }
        };
    }
}
```

**在JDK8中如果我们在匿名内部类中需要访问局部变量，那么这个局部变量不需要用final修饰符修饰。**看似是一种编译机制的改变，实际上就是一个语法糖（底层还是帮你加了final）。但通过反编译没有看到底层为我们加上final，但我们无法改变这个局部变量的引用值，如果改变就会编译报错。

# 嵌套类

1. 如果不需要内部类对象与其外围类对象之间有联系,那么可以将内部类声明为`static`,称为嵌套类
2. 要创建嵌套类的对象,不需要其外围类的对象
3. 不能从嵌套类的对象中访问其非静态的外围类对象
4. 普通类不能有`static`数据和字段

# 为什么需要内部类

+ 每个内部类都能独立地继承自一个接口的实现,所以无论外围类是否已经继承了某个接口的实现,对于内部类都没有影响
+ 内部类可以有多个实例,每个实例都有自己的状态信息,并且与其外部类对象的信息相互独立
+ 在单个外围类中,可以让多个内部类以不同的方法实现同一个接口