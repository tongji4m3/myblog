---
title: Java基础--常用对象
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 'Java基础知识之常用对象,待完善,之后再看的时候会继续补充。'
categories: Java基础
tags:
  - Java基础
  - 对象
abbrlink: d70d769a
date: 2020-03-11 00:00:00
---
# Object
## toString()

```
public String toString() 
{
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```



返回对象的字符串表示形式,建议所有子类重写此方法.

## equals()

```
public boolean equals(Object obj)
{
    return (this == obj);
}
```

如果是对象引用,那么equals()底层调用==,比较的是对象内存地址是否相等

一般重写它以比较两个对象的内容

无论何时覆盖该方法，通常需要覆盖`hashCode`方法，以便维护`hashCode`方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。

所以基本数据类型用==判断相等,引用数据类型都用equals()进行判断(String也是引用类型)

```java
//idea生成
@Override
public boolean equals(Object o)
{
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Person person = (Person) o;
    return age == person.age &&
        username.equals(person.username);
}

@Override
public int hashCode()
{
    return Objects.hash(username, age);
}
```

## clone

- - - 创建并返回此对象的副本。“复制”的精确含义可能取决于对象的类。一般的意图是，对于任何对象`x` ，表达式：

			> ` x.clone() != x`

			将是真实的，而且表达：

			> ` x.clone().getClass() == x.getClass()`

			将是`true`  ，但这些都不是绝对的要求。通常情况是：

			> ` x.clone().equals(x)`

			将是`true`  ，这不是一个绝对的要求。

- - - 按照惯例，返回的对象应该通过调用`super.clone`获得。  如果一个类和它的所有超类（除了`Object` ）遵守这个惯例，那将是`x.clone().getClass()  == x.getClass()`的情况。 

			按照惯例，此方法返回的对象应该与此对象（正被克隆）无关。  为了实现这一独立性，可能需要修改`super.clone`返回的对象的一个或多个字段。  通常，这意味着复制构成被克隆的对象的内部“深层结构”的任何可变对象，并通过引用该副本替换对这些对象的引用。  如果一个类仅包含原始字段或对不可变对象的引用，则通常情况下，  `super.clone`返回的对象中的字段通常不需要修改。 

- - - `clone`的方法`Object`执行特定的克隆操作。  首先，如果此对象的类不实现接口`Cloneable`  ，则抛出`CloneNotSupportedException` 。  请注意，所有数组都被认为是实现接口`Cloneable`  ，并且数组类型`T[]`的`clone`方法的返回类型是`T[]`  ，其中T是任何引用或原始类型。  否则，该方法将创建该对象的类的新实例，并将其所有字段初始化为完全符合该对象的相应字段的内容，就像通过赋值一样。  这些字段的内容本身不被克隆。 因此，该方法执行该对象的“浅拷贝”，而不是“深度拷贝”操作。 

			`Object`类本身并不实现接口`Cloneable`  ，因此在类别为`Object`的对象上调用`clone`方法将导致运行时抛出异常。 
			
# 八种包装类型

1. Byte,Short,Integer,Long,Float,Double父类都是Number
2. Boolean,Character父类是Object

## Number

提供了六种转换方法
```java
public abstract int intValue();
public abstract long longValue();
```

## 拆箱装箱机制
`Integer i=100` 其实还是相当于`Integer i= new Integer(100)`i还是指向内存地址。只是自动装箱了,只有运算才会自动拆装箱
```
//==永远判断内存地址是否相同
Integer i= new Integer(100);
Integer j= new Integer(100);
if(i==j) //结果为false
```

Integer类加载时会初始化整数型常量池：256个对象
在[-128,127]之间会被包装到固定的对象,放在整数型常量池里
此区间的数据直接从内存中取出，内存地址相同
```java
Integer a=10;
Integer b=10;
if(a==b)//结果为true
```


# 常用类
## 日期

```java
//Date转为String
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
Date date = new Date();
System.out.println(dateFormat.format(date));
   
//String转为Date
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
String s = "2020年08月07日 08:28:23";
Date date = dateFormat.parse(s);

//从1970.1.1至今的总毫秒数
System.currentTimeMillis();
   
```
## BigDecimal
```java
//高精度,如财务处理软件等
BigDecimal bigDecimal1 = new BigDecimal(4);
BigDecimal bigDecimal2 = new BigDecimal(3.5);
BigDecimal add = bigDecimal1.add(bigDecimal2);
System.out.println(add);
//7.5999999999999996447286321199499070644378662109375
BigDecimal divide = bigDecimal1.divide(bigDecimal2);
System.out.println(divide);
//java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.
```
## Random
```java
//构造参数可传入随机种子,每次程序的随机数都一样
Random random = new Random(4);
int i = random.nextInt();//产生int范围内的随机数
int j = random.nextInt(100);//产生[0,100)范围内的随机数
```
# 其他
## 测试

```java
    //junit
    //@Before使得所有测试方法先执行该方法
    @Before
    public void init()
    {
      System.out.println("init..");
    }

    @After
    public void close()
    {
      System.out.println("close..");
    }

    @Test
    public void testIt()
    {
      Demo demo = new Demo();
      demo.test(2,3);
    }
```

## stream流

```java
//stream流式模型 相当于对一个list或者数组进行一系列处理,然后对剩下的集合打印或者其他操作
    public static void main(String[] args)
    {
      List<String> list = new ArrayList<>();
      list.add("AAA");
      list.add("AAB");
      list.stream().
        filter(name->name.startsWith("A")).
        filter(name->name.length()==3).
        forEach(name->System.out.println(name));
    }
```


    //一种数据类型转换为另外一种
    Stream<String> stream = Stream.of("12", "23", "45");
    Stream<Integer> stream1=stream.map((String name) ->
     {
           return Integer.parseInt(name);
     });
    stream1.forEach(i->System.out.println(i));
    
    Stream<String> stream = Stream.of("12", "23", "45","78");
    System.out.println(stream.limit(3).count());
    ```


## 测试

    @Deprecated  代表方法已经过时
    @SuppressWarnings("all")  抑制警告
    @Override 重写方法

端口号 0-65535  1024之前的端口不能使用

idea默认编码UTF-8，win10默认GBK