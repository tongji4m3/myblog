---
title: 设计模式--装饰者模式
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了装饰者模式的原则,类图,代码实现。'
categories: 设计模式笔记
tags:
  - 设计模式
  - Java
  - UML
abbrlink: a5c35f1a
date: 2020-09-23 00:00:00
---

# 装饰者模式
## 装饰者模式定义

动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案

## 设计原则

类应该对扩展开放,对修改关闭.

## 细节

1. 利用继承设计子类的行为,是在编译时静态决定的,而且所有子类都会继承到相同的行为.如果利用组合扩展对象的行为,就能在运行时动态地进行扩展.
2. 装饰者和被装饰者有相同的超类型
3. 可以用一个或多个装饰者包装一个对象
4. 在任何需要原始对象的地方,都可以用装饰过的对象代替它
5. Java.io类就用到了装饰者模式，倒是用来包装InputStream的
6. 装饰者模式意味着一群装饰者类，用来包装具体的组件
7. 可以用无数的装饰者包装一个组件

## 类图

![image-20200926170529749](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200926170529749.png)

# 实现

## Beverage

```java
public abstract class Beverage
{
    protected String description = "Unknown Beverage";

    public String getDescription()
    {
        return description;
    }

    public abstract double cost();
}
```

## 咖啡组件

```java
public class DarkRoast extends Beverage
{
    public DarkRoast()
    {
        description = "DarkRoast";
    }

    @Override
    public double cost()
    {
        return 1.59;
    }
}
```

```java
public class Espresso extends Beverage
{
    public Espresso()
    {
        description = "Espresso";
    }

    @Override
    public double cost()
    {
        return 1.99;
    }
}
```

```java
public class HouseBlend extends Beverage
{
    public HouseBlend()
    {
        description = "HouseBlend";
    }

    @Override
    public double cost()
    {
        return 0.99;
    }
}
```

## 装饰者相关组件

```java
//调料装饰者
public abstract class CondimentDecorator extends Beverage
{
    //所有调料装饰者必须重新实现该方法
    public abstract String getDescription();
}
```

```java
//这样得到的是装饰者,即被Milk这个配料装饰后得到的一杯新咖啡
//它不管之前的咖啡是什么种类,也不管之前之后是否被装饰过
public class Milk extends CondimentDecorator
{
    Beverage beverage;

    public Milk(Beverage beverage)
    {
        this.beverage = beverage;
    }

    @Override
    public String getDescription()
    {
        return beverage.getDescription()+",Milk";
    }

    @Override
    public double cost()
    {
        return 0.50+beverage.cost();
    }
}
```

```java
public class Mocha extends CondimentDecorator
{
    Beverage beverage;

    public Mocha(Beverage beverage)
    {
        this.beverage = beverage;
    }

    @Override
    public String getDescription()
    {
        return beverage.getDescription()+",Mocha";
    }

    @Override
    public double cost()
    {
        return 0.20+beverage.cost();
    }
}
```

```java
public class Soy extends CondimentDecorator
{
    Beverage beverage;

    public Soy(Beverage beverage)
    {
        this.beverage = beverage;
    }

    @Override
    public String getDescription()
    {
        return beverage.getDescription()+",Soy";
    }

    @Override
    public double cost()
    {
        return 0.80+beverage.cost();
    }
}
```

```java
public class Whip extends CondimentDecorator
{
    Beverage beverage;

    public Whip(Beverage beverage)
    {
        this.beverage = beverage;
    }

    @Override
    public String getDescription()
    {
        return beverage.getDescription()+",Whip";
    }

    @Override
    public double cost()
    {
        return 0.10+beverage.cost();
    }
}
```

## MainTest

```java
public class MainTest
{
    public static void main(String[] args)
    {
        Beverage beverage = new Espresso();
        System.out.println(beverage.getDescription()+" $"+beverage.cost());

        System.out.println("---------------------");

        Beverage beverage1 = new DarkRoast();
        beverage1 = new Mocha(beverage1);
        beverage1 = new Mocha(beverage1);
        beverage1 = new Whip(beverage1);
        System.out.println(beverage1.getDescription()+" $"+beverage1.cost());
    }
}
```