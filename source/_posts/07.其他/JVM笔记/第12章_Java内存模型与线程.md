---
title: 深入理解Java虚拟机--Java内存模型与线程
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: '学习<<深入理解Java虚拟机>>所做的笔记,此为书上第12章--Java内存模型与线程。'
categories: JVM学习笔记
tags:
  - 深入理解Java虚拟机
  - 线程
  - 内存模型
abbrlink: ce3193b6
date: 2020-07-23 00:00:00
---

# 概述

多任务处理原因:计算机运算能力强大了,计算机运算速度与他的存储和通信子系统的速度差异大,一个服务端要同时对多个客户端提供服务

# 硬件的效率与一致性

让计算机并发执行若干个计算任务与更充分地利用计算机处理器的效能之间的关系没这么简单

因为绝大多数的运算任务都不可能只靠处理器的计算完成,还需要与内存的交互等。因为CPU和存储设备速度的差异，现代计算机系统加入一层或多层高速缓存作为内存和处理器的缓冲

## 缓存一致性

共享内存多核系统：在多路处理器系统，每个处理器都有自己的高速缓存，而他们又共享同一个主内存

当多个处理器的运算任务都涉及到同一块主内存时，将可能遇到缓存不一致的情况，所以需要遵守一定的协议。

## 指令重排序优化

为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码的顺序是一致的

因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性不能靠代码的先后顺序保证

# Java内存模型

## 主内存和工作内存

定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储在内存和从内存中取出变量值这样的底层细节。

此次变量不包括局部变量和方法参数，因为他们是线程私有的，不会被共享，没有竞争问题

所有变量都存储在主内存中，每个线程还有自己的工作内存。工作内存保存了被改线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，不能直接读取主内存的数据

主内存直接对应于物理硬件的内存，工作内存优先存储于寄存器和高速缓存中

## 内存间交互操作

主内存和工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存这一类的实现细节

下面每个操作都是原子的，不可再分的

1. lock 作用于主内存变量，把变量标识为线程独占
2. unlock 作用于主内存变量，把变量从锁定状态释放
3. read 作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中
4. load 作用于工作内存变量，把read操作从主内存中得到到变量值放入工作内存的变量副本中
5. use 作用于工作内存变量，把工作内存中一个变量的值传递给执行引擎
6. assign 作用于工作内存变量，把一个从执行引擎接收的值赋给工作内存的变量
7. store 作用于工作内存变量，把工作内存中一个变量的值传送到主内存中
8. write 作用于主内存变量，把store操作从工作内存中得到的变量值放入主内存的变量中

之后简化为read,write,lock,unlock,但只是语言描述简化，内存模型的基础设计没变

之后可以采用一个等效的判断原则：先行发生原则，用来确定一个操作在并发情况下是否安全 

## 对于volatile型变量的特殊规则

提供的最轻量级的同步机制

两大特性

### 保证此量对所有线程的可见性

指当一条线程修改了这个变量的值，新值对于其他线程来说是立即得知的

误解：volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的

volatile变量在各个线程的工作内存中是不存在一致性问题，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的

例子：一条race++ 指令，由四条字节码指令构成，当`getstatic`指令把race的值取到操作栈顶时，`volatile`关键字保证此时race的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的race值同步回主内存中

由于volatile只能保证可见性，除了以下两种情况外，其余都要通过加锁解决：

1. 运算结果并不依赖于变量的当前值，或者能够确保只有单一的线程修改变量的值
2. 变量不需要于其他的状态变量共同参与不变约束

### 禁止指令重排序优化

普通变量只能保证结果正确，不能保证变量赋值操作的顺序与程序代码的执行顺序是一致的

即线程内表现为串行的语义

有volatile修饰的变量，赋值后多执行一个`lock addl $0x0,(%esp)`操作，该操作相当于一个内存屏障，指重排序时不能把后面的指令重排序到内存屏障之前的位置

`lock addl $0x0,(%esp)`操作将本处理器的缓存写入到内存，会引发其他处理器无效化他们的缓存，所以可以让volatile变量的修改对其他处理器立即可见

从硬件架构上，指令重排序是指处理器采用了运行将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，他必须能正确处理指令依赖情况，保证能输出正确的结果

在同一个处理器中，重排序后的代码看起来仍然是有序的，`lock addl $0x0,(%esp)`把修改同步到缓存时，意味着所有之前的操作已经完成了，就形成了指令重排序无法越过内存屏障的效果

只有一个处理器访问内存时，不需要内存配置，但是有多个处理器访问同一块内存，且其中一个在观测另一个，就需要内存屏障来保证一致性

### 效率
volatile变量读操作性能消耗和普通变量差不多，写操作因为要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，会慢一些
volatile变量总开销比锁低，在volatile与锁之前选择的唯一依据仅仅是volatile能否满足使用场景的要求
## 针对long和double型变量的特殊规则
long和double的非原子性协定：运行虚拟机将并未声明为volatile的64位数据的读取划分为两次32位的操作进行
如果有多个线程共享一个并未声明为volatile的long和double型变量，并且同时对他们进行读取和修改操作，可能会读取到半个变量的数值
不过非常罕见，64位Java虚拟机不会出现，32位的也通常不会出现。所以在实际开发中，除非该数据有明确可知的线程竞争，否则一般不需要刻意把long和double型变量声明为volatile

## 原子性，可见性，有序性
### 原子性
大致可以认为，基本数据类型的访问读写都是具备原子性的
synchronized块之间的操作也具备原子性
### 可见性
当一个线程修改了共享变量的值时，其他变量能立即得知这个修改。
三种可见性方式：
volatile变量：保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新
synchronized关键字：对一个变量执行unlock之前，必须先把此变量同步回主内存中
final：被final修饰的字段在构造器一旦被初始化完成，并且构造器没有把this的引用参数传递出去，那么在其他线程中就能看到final字段的值
### 有序性
天然的有序性：如果在本线程内观测，所有的操作都是有序的；如果在一个线程中观测另一个线程，所有的操作都是无序的。前半句是指线程内似表现为串行的语义，后半句是指指令重排序和工作内存与主内存同步延迟现象。
volatile，synchronized关键字保证线程之间操作的有序性。前者本身就包含了禁止指令重排序的语义，后者由一个变量同一时刻只允许一条线程对其lock操作获得
synchronized关键字很万能，但是被滥用了，越万能的并发控制，通常会伴随越大的性能影响

## 先行发生原则
是判断数据是否竞争，线程是否安全的非常有用的手段
先行发生：例如说操作A先行发生于操作B，则指发生操作B之前，操作A产生的影响能被操作B观察到
Java语言中无须任何同步手段保障就能成立的先行发生原则如下，如果两个操作之间的关系无法从下述规则推导出来，他们就没有顺序性保证，虚拟机就能对他们随意地重排序
1. 程序次序规则：一个线程内，按照控制流顺序前面的操作比后面的操作先执行
2. 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作
3. volatile变量规则：对一个 volatile变量的写操作先行发生于后面对这个变量的读操作
4. 线程启动规则：Thread的start（）方法先行发生于该线程的每一个动作
5. 线程终止规则：线程的所有操作先行发生于对该线程的终止检测
6. 线程中断规则：对线程interrupt（）方法的调用优先于被中断线程的代码检测到中断事件发生
7. 对象终结规则：一个对象的初始化方法优先于他的finalized（）方法
8. 传递性：A先行发生于B，B先行发生于C，则A先行发生于C

时间先后顺序与先行发生原则之间没有因果关系，所以衡量并发安全问题不要受时间顺序的影响，一切以先行发生原则为准
# Java与线程
## 线程的实现
### 内核线程实现
1：1实现， 内核线程就是直接由操作系统内核支持的线程，由内核来完成线程切换。一般使用内核线程的高级接口-轻量级进程
内核线程的操作都需要进行系统调用，需要在用户态核心态切换，要消耗一定的内核资源。
### 用户线程的实现
用户线程为1：N的实现，完全建立在用户空间的线程库，系统内核不能感知到用户线程的存在与实现，用户线程的操作完全在用户态完成。
比较复杂，一般不倾向使用用户线程
### 混合实现
N：M实现，既存在轻量级进程，又存在用户线程
### java线程的实现
基于操作系统原生线程模型来实现，即1：1的线程模型
每一个Java线程都直接映射到一个操作系统原生线程来实现，线程操作由操作系统全权决定
## Java线程调度
### 协同式
线程的执行时间由线程本身控制。好处是实现简单，切换操作对线程可知，没有线程同步的问题。坏处是执行时间不可控制，使用不当系统崩溃
### 抢占式
由系统来分配线程的执行时间，线程切换不由线程本身控制。
可设置进程优先级，但是不是稳定的调节手段。一是某些操作系统上不同优先级，二是进程优先级可能被系统自行改变
## 状态转换
一共有6种线程状态：
1. 新建：创建后尚未启动
2. 运行：包括操作系统状态的Running和Ready，即可能正在运行，也可能等待操作系统为他分配执行时间
3. 无限期等待：不会被分配处理器执行时间，要等待被其他线程显示唤醒
4. 期限等待：不会被分配处理器执行时间，一定时间后会由操作系统自动唤醒
5. 阻塞状态：在等待着获取一个排它锁。在程序等待进入同步区域时，处于该状态
6. 结束状态：已终止线程的线程状态

# Java与协程
## 内核线程的局限
业务量不断增长，而且为了应对业务复杂化而不断进行服务细分
现代BS系统中一次对外部业务请求的响应，往往需要在不同机器上的大量服务共同协作来实现。增加了服务数量，缩短了留给每个服务的响应时间。要求每个服务都必须在极短的时间内完成计算，能同时处理数量更庞大的请求
Java的1：1线程模型切换，调整成本高昂，系统能容纳的线程数量有限，对这样的情况造成严重浪费。
## 协程的复苏
内核线程的调度成本主要来自于用户态与内核态之间的状态转换，而这两种状态转换的开销主要来自于响应中断，保护和恢复执行现场的成本。涉及一系列数据在各种寄存器，缓存中的来回拷贝，不是一种轻量级的操作。
有栈协程：在内存中划分一片额外空间来模拟调用栈，完整地做调用栈的保护和恢复工作
优势是轻量，缺点是需要在应用层面上实现的内容（调用栈，调度器）特别多
## Java的解决方案
使用纤程，是一种典型的有栈协程。重新提供对用户线程的支持
会有两个并发编程模型在Java虚拟机中并存，可以在程序中同时使用
