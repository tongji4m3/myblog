---
title: 《Redis设计与实现》-------AOF持久化
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: '学习《Redis设计与实现》所做的笔记,此为书上第十一章--AOF持久化。'
categories: Redis学习笔记
tags:
  - Redis
  - AOF
  - 数据库
abbrlink: 7730ae65
date: 2020-09-22 00:00:00
---

# 简介

通过保存`Redis`服务器所执行的写命令来记录数据库状态的

服务器启动时,可以通过载入和执行`AOF文件`中保存的命令来还原服务器关闭之前的数据库状态

# AOF持久化的实现

## 命令追加

服务器在执行完一个写命令后,会将被执行的写命令追加到服务器状态的`aof_buf`缓冲区的末尾:

```c
struct redisServer
{
	// AOF缓冲区
	sds aof_buf;
}
```

## AOF文件的写入与同步

服务器进程是一个事件循环,循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复.时间事件负责执行像serverCron函数这样需要定时运行的函数

```python
def eventLoop()
{
	while True:
		#处理文件事件,接收命令请求以及发送命令回复
		#处理命令请求时可能会有新内容加入到aof_buf缓冲区中
		processFileEvents()
		
		#处理时间事件
		processTimeEvents()
		
		#考虑是否要将aof_buf缓冲区中的内容写入和保存到AOF文件里面
		flushAppendOnlyFile()
}
```

# AOF文件的载入与数据还原

只要读入并重新执行一遍`AOF文件`里面保存的写命令,就可以还原服务器关闭之前的数据库状态

1. 创建一个不带网络连接的伪客户端
2. 从AOF文件中分析并读取出一条写命令
3. 使用伪客户端执行被读出的写命令
4. 一直执行2,3直到AOF文件中的所有写命令都被处理完毕

# AOF重写

服务器创建一个新的AOF文件来**替代**现有的AOF文件,新旧两个AOF文件所保存的数据库状态相同,但是新的AOF文件不会包含任何浪费空间的冗余命令

## AOF文件重写的实现

不需要对现有的AOF文件进行操作,是通过读取服务器当前的数据库状态来实现的

```python
def aof_rewrite(new_aof_file_name):
	#创建新的aof文件
	f=create_file(new_aof_file_name)
	#遍历数据库
	for db in redisServer.db:
		#忽略空数据库
		if db.is_empty():continue
		
		#写入SELECT命令,指定数据库号码
		f.write_command("SELECT"+db.id)
		
		#遍历数据库中所有键
		for key in db:
			#忽略过期的键
			if key.is_expired():continue
			
			#根据键的类型对键进行重写
			if key.type == String:
				rewrite_string(key)
			elif key.type == List:
				rewrite_list(key)
			elif key.type == Hash:
				rewrite_hash(key)
            elif key.type == Set:
				rewrite_set(key)
            elif key.type == SortedSet:
				rewrite_sortedSet(key)
				
			# 如果键带有过期时间,过期时间也要重写
			if key.have_expired_time():
				rewrite_expired_time(key)
	#写入完毕,关闭文件			
	f.close()
	
def rewrite_string(key):
	#使用GET命令获取字符串的值
	value=GET(key)
	#使用SET命令重写字符串键
	f.write_command(SET,key,value)
	
def rewrite_expired_time(key):
	#获取毫秒精度的键过期时间戳
	timestamp=get_expired_time_in_unixstamp(key)
	#使用PEXPIREAT命令重写键的过期时间
	f.write_command(PEXPIREAT,key,timestamp)
```



## AOF后台重写

Redis服务器使用单个线程来处理命令请求,决定将AOF重写程序放到子进程中执行

+ 子进程在进行AOF重写期间,服务器进程可以进行处理命令请求
+ 子进程带有服务器进程的数据副本,使用子进程而不是线程,可以在避免使用锁的情况下,保证数据的安全性

但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库状态不一致



在子进程执行AOF重写期间,服务器进程执行:

1. 执行客户端发来的指令
2. 将执行后的写命令追加到AOF缓冲区
3. 将执行后的写命令追加到AOF重写缓冲区



当子进程完成AOF重写工作后,他会向父进程发送一个信号,父进程将执行:

1. 将AOF重写缓冲区中所有内容写入到新的AOF文件中,这时新的AOF文件所保存的内容就与当前的数据库状态一致
2. 对新的AOF文件进行改名,原子地覆盖现有的AOF文件,完成新旧AOF文件的替换