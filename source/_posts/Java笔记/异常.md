---
title: Java基础--异常
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 'Java基础知识之异常,待完善,之后再看的时候会继续补充。'
categories: Java基础
tags:
  - Java基础
  - 异常
abbrlink: 1a12af4c
date: 2020-03-13 00:00:00
---


# 异常简介
![image-20200807095737682](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200807095737682.png)

1. 所有的RuntimeException及其子类都属于运行时异常。在编写处理程序阶段可用处理，也可用选择不处理
2. Exception中除了RuntimeException的其他子类，都是编译时异常，又叫受检异常。即编写程序时必须预先对异常进行处理，否则编译器报错。编译时异常发生概率高。所以未雨绸缪。
3. 编译时异常例子：大雨天，出门不带伞，很大可能会生病（很大可能发生的一种异常）。那就提前带一把伞（对概率较高的异常进行预处理）
4. 运行时异常例子：被飞机砸中，发生概率比较低。如果提前预处理，就很麻烦
5. 编译期，运行期异常都发生在运行阶段。编译阶段异常不会发生。

# 异常处理

编译时异常在编写程序时就要预先处理，可以继续向上抛出，或者自行处理。

## 抛出异常
1. 如果异常一直上抛，main再上抛则上抛到了JVM，则会终止程序
2. `throws ClassNotFoundException`交给调用该方法的调用者处理
3. 

## 处理异常

异常堆栈信息从上往下看。先看抛出的异常名。再看自己代码中最顶端报错的代码位置。

```java
try
{
    throw new ClassNotFoundException("my_exception");
}
catch (ClassNotFoundException e)
{
    System.out.println(e.getMessage());//my_exception
    e.printStackTrace();//打印异常栈堆信息
}
```

## finally

1. 无论try里执行了return语句、break语句、还是continue语句，finally语句块还会继续执行。
2. 当try或者catch的代码在运行的时候，JVM退出了。那么finally语句块就不会执行。同样，如果线程在运行try或者catch的代码时被中断了或者被杀死了(killed)，那么finally语句可能也不会执行了，即使整个运用还会继续执行。
3. 如果在try语句里有return语句，finally语句还是会执行。它会在把控制权转移到该方法的调用者或者构造器前执行finally语句。也就是说，使用return语句把控制权转移给其他的方法前会执行finally语句。

```java
public static void main(String[] args)
    {
        System.out.println(f());//100
    }
    public static int f()
    {
        int i = 100;
        try
        {
            return i;
        }
        finally
        {
            i++;
        }
    }

//反编译
int i=100;
int j=i;
i++;
return;
```

## 自定义异常

```java
//要定义编译时异常就Exception,运行时异常就RuntimeException
public class MyException extends Exception
{
    public MyException()
    {
    }

    public MyException(String msg)
    {
        super(msg);
    }
}

public static void main(String[] args)
{
    try
    {
        throw new MyException("myExceptionInfo");
    }
    catch (MyException e)
    {
        e.printStackTrace();
    }
    //test.MyException: myExceptionInfo
    //	at demo1.MainTest.main(MainTest.java:21)
}
```

