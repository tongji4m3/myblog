---
title: 第十四章--类型信息
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: '<<Java编程思想>>读书笔记,第十四章--类型信息。'
categories: Java编程思想
tags:
  - Java基础
  - 反射
  - Class
abbrlink: 9deeb220
date: 2020-11-02 00:00:00
---

> <<Java编程思想>>读书笔记

# Class对象

```java
public static void main(String[] args)
{
    try
    {

        //使用全限定名
        Class<?> clazz = Class.forName("com.tongji.Wrapping");

        Wrapping wrapping = new Wrapping(1);
        clazz=wrapping.getClass();

        //使用.class创建对Class对象的引用时,不会自动地初始化该Clas对象
        clazz = Wrapping.class;

        //clazz = int.class; 也可用于基本数据类型

        System.out.println(Arrays.toString(clazz.getConstructors()));

        //使用newInstance()则必须具有默认构造器
        //newInstance()返回的只是Object类型
        Object object = clazz.newInstance();
    }
    catch (ClassNotFoundException | IllegalAccessException | InstantiationException e)
    {
        e.printStackTrace();
    }
}
```





+ `Class`对象包含了与类有关的信息,用来创建类的所有常规对象的
+ 每个类都有有个`Class`对象,保存在同名的`.class`文件中
+ 想要在运行时获得类型信息,就必须首先获取对`Class`对象的引用
+ 访问的`static`域不是`final`时,总是要链接和初始化
+ 这个类型必须在编译时已知,才能用`RTTI`来识别
+ `RTTI`与反射的区别是,`RTTI`在编译时打开和检查`.class`文件,而对于反射机制,`.class`在编译时不可获取,所以是在运行时打开和检查`.class`文件

## 步骤

+ 加载:查找字节码,创建Class对象
+ 链接:为静态域分配存储空间
+ 初始化:对超类初始化,执行静态初始化块.(延迟到了对静态方法的首次引用时)

## 泛化的Class

+ `Class<?>`优于平凡的`Class`,虽然是等价的
+ `Class<? extend Number>`限定了Class引用为某种类型或他的任何子类型

# 反射

+ 能够创建有个编译时完全未知的对象,并调用此对象的方法