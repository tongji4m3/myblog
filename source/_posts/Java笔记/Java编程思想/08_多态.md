---
title: 第八章--多态
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: '<<Java编程思想>>读书笔记,第八章--多态。'
categories: Java编程思想
tags:
  - Java基础
  - 继承
  - 多态
abbrlink: 1ae46459
date: 2020-10-25 00:00:00
---

> <<Java编程思想>>读书笔记

## 后期绑定

在运行时根据对象的类型进行绑定,也叫做动态绑定,运行时绑定

编译器一直不知道对象的类型,但是方法调用机制能找到正确的方法体

除了`static`和`final`方法,其他都是后期绑定的方法

## 构造器

基类的构造器总是在导出类的构造过程中被调用,导出类只能访问它自己的成员,不能访问基类的成员(因为通常是`private`),只有基类构造器才比较恰当的对自己元素进行初始化,因此必须令所有构造器得到调用

如果没有明确指定调用某个基类构造器,他就会默默调用默认构造器

## 构造器内部的多态方法行为

+ 在任何构造器内部,整个对象可能只是部分形成的,只知道基类对象已经初始化
+ 如果调用一个动态绑定方法,则可能调用到了导出类的方法,该方法操纵的成员可能未初始化
+ 所以在构造器内唯一能够安全调用的那些方法是基类中的`private`和`final`方法,因为他们不能被覆盖

```java
class Graph
{
    public Graph()
    {
        System.out.println("----before----");
        draw();
        System.out.println("----after----");
    }

    void draw()
    {
        System.out.println("Graph.draw");
    }
}

class RoundGlyph extends Graph
{
    private int i = 1;

    public RoundGlyph(int i)
    {
        this.i = i;
        System.out.println("RoundGlyph.draw:" + i);
    }

    void draw()
    {
        System.out.println("RoundGlyph.draw:" + i);
    }
}


public class MainTest
{
    public static void main(String[] args)
    {
        new RoundGlyph(5);
    }
}

/*
----before----
RoundGlyph.draw:0
----after----
RoundGlyph.draw:5
 */
```

+ 在最开始,分配给对象的存储空间初始化未二进制的零
+ 调用基类构造器,此时会调用覆盖后的`draw()`方法,由于第一步,此时`i=0`
+ 初始化成员变量调用导出类的构造器主体