---
title: Java——Java多线程------线程基础
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java多线程所做的笔记，线程基础内容，包括创建线程、停止线程、Object相关方法等。
categories: 多线程
tags:
  - 多线程
  - 生命周期
  - interrupt
abbrlink: 7b17139b
date: 2020-12-25 00:00:00
---



# 线程基础

## 进程和线程的区别

+ 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
+ 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
+ 内存分配：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
+ 进程：进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，而 main 函数所在的线程就是这个进程中的⼀个线程，也称主线程。
+ 线程：但线程是⼀个比进程更小的执行单位。⼀个进程在其执行的过程中可以产生多个线程，线程也被称为轻量级进程。多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。

## 线程切换时机

+ CPU时间片用完
+ 垃圾回收
+ 更高优先级线程运行
+ 线程自己调用sleep,yield,wait,join,park,synchronized,lock

## 线程实现

### 内核线程实现

+ 1：1实现
+ 由内核完成线程切换
+ 一般使用内核线程的高级接口-轻量级进程
+ 即使其中某个轻量级进程在系统调用中被阻塞，也不会影响整个进程继续工作
+ 缺点是轻量级进程要消耗一定的内核资源，线程操作需要系统调用
+ Java线程模型基于操作系统原生线程模型实现，即1：1线程模型
+ 每一个Java线程都是直接映射到一个操作系统原生线程来实现，HotSpot不干涉线程调度，交给操作系统管理

### 用户线程实现

+ 1：N实现
+ 完全建立在用户空间的线程库上，系统内核不能感知用户线程的存在
+ 完全由用户态完成，不需要切换到内核态
+ 一般不支持用户线程

### 用户线程和轻量级进程混合实现

+ N:M实现
+ 用户线程还是完全建立在用户空间中，可以支持大规模的用户线程并发
+ 操作系统支持的轻量级进程作为用户线程和内核线程之间的桥梁

## 线程调度

### 协同式

+ 执行时间由线程本身来控制，实现简单，切换操作对自己可知，没有线程同步问题
+ 线程执行时间不可控制，如果坚持不让处理机，可能系统崩溃

### 抢占式

+ 由系统分配执行时间，线程切换不受线程本身决定
+ 线程执行时间可控
+ 线程调度虽然是系统自动完成，但可以设置线程优先级来建议操作系统
+ 线程优先级不稳定，因为java线程是被映射到系统的原生线程上来实现的，可能某些操作系统实际优先级与java的不能一一对应，优先级还可能被系统自行改变



# 创建线程

从原理上看两种方法本质上是一样的

将该Runnable传递给Thread的target成员变量，最终调用target.run()方法

```java
private Runnable target;

public void run() {
    if (target != null) {
        target.run();
    }
}
```



## 继承Thread类

run（）方法整个被重写

```java
//继承Thread类实现多线程
new Thread(() -> {
   System.out.println(Thread.currentThread().getName()+" start");
}, "thread1").start();
```

## 实现Runnable()接口

+ 代码架构角度：代表一个任务，和线程进行区分，解耦
+ 节约资源：新建线程的损耗大，反复利用同一个线程
+ 扩展性，Java不允许多继承，如果继承Thread类，就不能多继承了

```java
//覆写Runnable()接口实现多线程
Runnable runnable = () -> {
   System.out.println(Thread.currentThread().getName()+" start");
};
new Thread(runnable,"thread2").start();
```

## 外在包装

本质上都是新建Thread类

### 通过线程池启动多线程

```java
//通过线程池启动多线程
//创建线程池
ExecutorService executorService = Executors.newFixedThreadPool(10);
//执行
executorService.execute(runnable);
executorService.execute(runnable);
executorService.execute(runnable);
//关闭连接
executorService.shutdown();
```

### 覆写Callable接口实现多线程

```java
//覆写Callable接口实现多线程
FutureTask<Integer> task = new FutureTask<>(new Callable<Integer>() {
    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName() + " start");
        Thread.sleep(1000);
        return 100;
    }
});
new Thread(task,"thread3").start();
//一直阻塞直到结果返回
System.out.println(task.get());
```



可以用于延迟计算,如执行数据库查询

它认为主入口点（call)将返回一个值，并可能抛出一个异常

**与Runnable的区别**

Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果

Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。

Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛

**Future**

表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等

get：如果任务已完成，get立即返回或抛异常，未完成，则阻塞直到任务完成

**FutureTask**

实现了Runnable，可以将他提交给Executor来执行

# 启动线程

## start

- 启动新线程
- 处于就绪(可运行)状态
- 并没有运行，一旦得到cpu时间片，就开始执行run()方法
- 不能重复执行start()方法，抛出异常：IllegalThreadStateException
- Run方法运行结束，此线程随即终止。

## run

run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。

调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。

# 停止线程

## 原理

+ 使用interrupt来通知，而不是强制
+ 被中断的线程拥有如何响应中断的权利，必须等待线程处理完之后主动中止，所以不应该莽撞的使用stop方法
+ 线程就算是sleep状态，也会响应interrupt
+ 想停止线程，要请求方、被停止方、子方法被调用方相互配合

## 情况

### run（）内没有sleep或wait方法时，停止线程

如果不检测线程状态isInterrupted()，则调用thread.interrupt();没有任何影响

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    Runnable runnable = () -> {
        int num = 0;
        //需要检测是否被中断，并且响应
        for (int i = 0; i < Integer.MAX_VALUE / 2; i++) {
            if (i % 10000 == 0) {
                System.out.println("Hello + "+i);
            }
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("被中断了");
                break;
            }
        }
        System.out.println("运行结束了");
    };
    Thread thread = new Thread(runnable);
    thread.start();
    TimeUnit.SECONDS.sleep(1);
    thread.interrupt();

}
```

### 在线程sleep期间interrupt

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    Runnable runnable = () -> {
        int num = 0;
        //需要检测是否被中断，并且响应
        for (int i = 0; i < Integer.MAX_VALUE / 2; i++) {
            System.out.println("Hello + " + i);

            //控制不住，因为调用后中断标志被清除了
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("被中断");
                break;
            }

            //如果在sleep时中断，就会抛出该异常，所以就可以在catch中处理
            //该循环会继续工作，因为catch后就执行下一轮循环
            try {
                TimeUnit.SECONDS.sleep(1);
            }
            catch (InterruptedException e) {
                //sleep interrupted
                e.printStackTrace();
            }
        }
        System.out.println("运行结束了");
    };
    Thread thread = new Thread(runnable);
    thread.start();
    //控制interrupt时线程正在sleep
    TimeUnit.MILLISECONDS.sleep(500);
    thread.interrupt();
}
```



会抛出异常：InterruptedException（sleep interrupted）

会继续执行，不会中断：interrupt中断标记被清除，而且是循环，try-catch后会继续执行下一个循环

## 最佳实践

不应屏蔽中断请求

### 优先选择：传递异常

**反面教材：在try-catch中处理**

```java
public class Thread1 {
    /*
    catch了InterruptedException后优先选择在方法签名中抛出异常

     */
    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = () -> {
            while (true) {
                System.out.println("业务逻辑");
                throwInMethod();

                //如果子方法使用try-catch，则下面不会有效果
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println("break");
                    break;
                }
            }
        };

        //线程使用
        Thread thread = new Thread(runnable);
        thread.start();
        TimeUnit.SECONDS.sleep(1);
        thread.interrupt();
    }

    //最佳是抛出异常到方法签名
    private static void throwInMethod() {
        //如果用这样,则中断的时候会e.printStackTrace();但是会继续运行
        //因为该方法不是run()方法，是底层被run()调用的方法，就导致没能响应中断，run的while循环仍然执行
        //相当于把中断给吞掉了
        try {
            TimeUnit.SECONDS.sleep(2);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



### 推荐：抛出异常到方法签名

```java
public class Thread1 {
    /*
    catch了InterruptedException后优先选择在方法签名中抛出异常

     */
    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = () -> {
            while (true) {
                System.out.println("业务逻辑");
                //run方法不能抛出异常，因为顶层的run方法没有异常，子类自然不能有
                try {
                    throwInMethod();
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                    System.out.println("保存日志");
                    System.out.println("退出");
                    break;
                }
            }
        };

        //线程使用
        Thread thread = new Thread(runnable);
        thread.start();
        TimeUnit.SECONDS.sleep(1);
        thread.interrupt();
    }

    //最佳是抛出异常到方法签名
    private static void throwInMethod() throws InterruptedException {
        TimeUnit.SECONDS.sleep(2);
    }
}
```



### 不想或者无法传递：恢复中断

```java
public class Thread1 {
    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = () -> {
            while (true) {
                System.out.println("业务逻辑");
                throwInMethod();

                //因为重新设置了中断状态，所以是有效的
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println("break");
                    break;
                }
            }
        };

        //线程使用
        Thread thread = new Thread(runnable);
        thread.start();
        TimeUnit.SECONDS.sleep(1);
        thread.interrupt();
    }

    private static void throwInMethod() {
        try {
            TimeUnit.SECONDS.sleep(2);
        }
        catch (InterruptedException e) {
            //恢复设置中断状态，以便于在后续执行时，仍然能够检查到刚刚发生了中断
            Thread.currentThread().interrupt();
            e.printStackTrace();
        }
    }
}
```

## 错误的停止方法

### 被弃用的stop、resume方法等

会导致线程运行一半突然停止，没办法完成一个基本单位的操作

资源分配戛然而止，银行批量转账10个人，只转了8个人，很难排查错误

### 用volatile设置boolean标记位

这样陷入阻塞时，就不会有人去唤醒他，他就不会执行到判断volatile那个变量的标志位的代码，就会一直等待

## 相关方法

### void interrupt()

设置interrupted

如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException,并且打断标记还是false.但是对于正常进程被打断打断标记是true

### static boolean interrupted()

目标对象为当前线程

清除当前线程的中断状态，并返回他之前的值

判断是否被打断,并且清除打断标记(设为false)

由于会清除当前线程的中断状态，如果调用他时返回true，那么除非你想屏蔽这个中断，否则必须对他进行处理。可以抛出InterruptedException，或再调用interrupt来恢复中断状态

### boolean isInterrupted()

判断是否被打断,不会清除打断标记

返回目标线程的中断状态

# 线程生命周期

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1611884091_1.png)

+ NEW：初始状态，线程被构建，但是没有调用start()
+ RUNNABLE：运行状态，将操作系统的就绪和运行状态统称为RUNNABLE；有可能正在运行，也有可能等待CPU资源
+ BLOCKED：阻塞状态，线程阻塞与锁；在程序等待进入同步区域时，将进入这种状态；在等待一个排它锁，该事件在另外一个线程放弃这个锁时发生；只有Synchronized修饰的，而且没有拿到锁，才是BLOCKED状态，其他锁不算
+ WAITING：无限期等待状态，当前线程需要等待其他线程通知或中断；没有设置Timeout的Object::wait()；没有设置Timeout的Thread::join()；LockSupport::park()
+ TIME_WAITING：超时等待状态，可以在指定的时间自行返回；Thread::sleep()；设置Timeout的Object::wait()；设置Timeout的Thread::join()；LockSupport::parkUntil()
+ TERMINATED：终止状态，当前线程已经执行完毕

## 代码查看状态

#### NEW、RUNNABLE、TERMINATED

```java
public static void main(String[] args) throws InterruptedException {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    System.out.println(i);
                }
            }
        };

        Thread thread = new Thread(runnable);

        System.out.println(thread.getState());
        thread.start();
        TimeUnit.MILLISECONDS.sleep(1);//NEW
        System.out.println(thread.getState());//RUNNABLE
        TimeUnit.SECONDS.sleep(1);
        System.out.println(thread.getState());//TERMINATED
    }
```

### WAITING、BLOCKED、TIMED_WAITING

```java
public static void main(String[] args) throws InterruptedException {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                syn();
            }

            private synchronized void syn() {
                try {
                    TimeUnit.SECONDS.sleep(1);
                    wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        };

        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);

        thread1.start();
        thread2.start();
        TimeUnit.MILLISECONDS.sleep(10);
        System.out.println(thread1.getState());//TIMED_WAITING
        System.out.println(thread2.getState());//BLOCKED
        TimeUnit.SECONDS.sleep(1);
        System.out.println(thread1.getState());//WAITING
    }
```

# Object相关方法

+ wait、notify、notifyAll定义在Object中，因为是锁级别的

+ 释放锁
+ wait需要在同步代码块内使用
+ wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)
+ wait(long timeout)让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
+ 因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出IllegalMonitorStateException（正在等待的对象没有锁））

+ notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程
+ notify也要在synchronized使用，应该指定对象，tnotify()，通知t1对象的等待池里的线程使一个线程进入锁定池，然后与锁定池中的线程争夺锁。那么为什么要在synchronized使用呢？ tnotify()需要通知一个等待池中的线程，那么这时我们必须得获得t1的监视器（需要使用synchronized），才能对其操作，tnotify()程序只是知道要对t1操作，但是是否可以操作与是否可以获得t1锁关联的监视器有关。

## 特点

+ 使用wait必须先拥有monitor
+ 使用notify只会唤醒一个，而且取决于JVM
+ 任何对象都拥有这些方法

## 唤醒时机

+ notify()本线程
+ notifyAll()
+ wait(long timeout)超时时间达到
+ 线程自身调用interrupt()

## 简单使用

```java
import java.util.concurrent.TimeUnit;


/*
Thread-0线程开始执行！
Thread-1线程开始执行！
线程Thread-1获取到了锁！
线程Thread-0获取到了锁！
 */
public class MainTest {
    private static Object object = new Object();

    static class Thread1 extends Thread {
        @Override
        public void run() {
            synchronized (object) {
                System.out.println(Thread.currentThread().getName()+"线程开始执行！");
                try {
                    object.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("线程"+Thread.currentThread().getName()+"获取到了锁！");
            }
        }
    }
    static class Thread2 extends Thread {
        @Override
        public void run() {
            synchronized (object) {
                System.out.println(Thread.currentThread().getName()+"线程开始执行！");
                object.notify();
                System.out.println("线程"+Thread.currentThread().getName()+"获取到了锁！");
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread1 thread1 = new Thread1();
        Thread2 thread2 = new Thread2();
        thread1.start();
        TimeUnit.MILLISECONDS.sleep(100);
        thread2.start();
    }
}
```

```java
import java.util.concurrent.TimeUnit;

/*
Thread-1获取到锁
Thread-0获取到锁
线程3唤醒
Thread-0执行结束
Thread-1执行结束
 */
public class MainTest {
    private static Object object = new Object();

    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = () -> {
            synchronized (object) {
                System.out.println(Thread.currentThread().getName()+"获取到锁");
                try {
                    object.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+"执行结束");
            }
        };

        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);
        Thread thread3 = new Thread(() -> {
            synchronized (object) {
                object.notifyAll();
//                object.notify();//只能唤醒一个
                System.out.println("线程3唤醒");
            }
        });
        thread1.start();
        thread2.start();
        TimeUnit.MILLISECONDS.sleep(100);
        thread3.start();
    }
}
```

## 两个线程交替打印[0，100]奇偶数

```java
import java.util.concurrent.TimeUnit;

public class MainTest {
    private static Object lock = new Object();
    private static int count = 0;

    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = () -> {
            while (count <= 100) {
                synchronized (lock) {
                    System.out.println(Thread.currentThread().getName() + ":" + count++);
                    lock.notify();
                    if (count <= 100) {
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        };

        new Thread(runnable, "evenThread").start();
        TimeUnit.MILLISECONDS.sleep(10);
        new Thread(runnable, "oddThread").start();
    }
}
```

# 线程属性

- 线程Id
- 线程名称
- isDaemon(true代表是守护线程）
    - 是给用户线程提供服务的
    - 默认情况下,Java进程会等待所有线程都运行结束,才会结束
    - 守护进程,如果所有非守护进程结束,守护进程也都结束了(垃圾回收器)
    - 如后台记录操作日志,监控内存,垃圾回收
    - thread1.setDaemon(true);
- priority（优先级）
    - 10个优先级，默认是5
    - 优先级高度依赖于操作系统的优先级，Java映射过去的
    - 优先级会被操作系统改变

# Thread方法

## sleep()

+ 让当前执行的线程休眠n毫秒， 休眠时让出 cpu 的时间片给其它线程
+ 可以调用interrupt()方法唤醒,但是会抛出异常：InterruptedException，并且会清除中断状态
+ 不释放锁，规定时间后继续执行

## join()

+ 等待线程运行结束,可以控制线程的同步
+ 因为新的线程加入了我们，所以我们要等他执行完再出发
+ main等待thread1执行完毕
+ 源码调用wait()一直休眠,但每一个线程在执行完run()都会执行notifyAll()
+ 此时主线程在waiting状态

### 简单使用

```java
/*
开始等待所有子线程执行
Thread-0执行
Thread-1执行
所有子线程执行完毕
 */
public class MainTest {
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "执行");
        });
        Thread thread2 = new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "执行");
        });

        thread1.start();
        thread2.start();
        System.out.println("开始等待所有子线程执行");
        thread1.join();
        thread2.join();
        System.out.println("所有子线程执行完毕");
    }
}
```

### 原理分析

```java
import java.util.concurrent.TimeUnit;

public class MainTest {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "执行");
        });

        thread.start();
        System.out.println("开始等待所有子线程执行");
//        thread.join();
        //等价于以下语句：
        /*
        主线程执行到下面语句，会阻塞，直到thread线程执行完，隐式的调用了notifyAll()  
         */
        synchronized (thread){
            thread.wait();
        }
        System.out.println("所有子线程执行完毕");
    }
}
```

## yield()

+ 提示线程调度器 让出当前线程对CPU的使用,具体要看操作系统实现
+ 让当前的线程暂停,但是不阻塞,从运行状态变为就绪状态
+ 让CPU重新调度,但是不能决定CPU
+ 不会释放锁
+ 为了稳定性，实际开发不使用，但是很多并发包使用

## currentThread()

获取当前执行线程的引用

# Callable接口

![image-20210204082438815](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210204082438815.png)



# 线程安全

## 线程安全的定义

+ 讨论的线程安全，以多个线程之间存在共享数据访问为前提
+ 当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果
+ 代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无需关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用
+ 通常将定义弱化，把调用这个对象的行为限定为单次调用
+ 编写业务逻辑时不需要做额外的处理程序就能正常执行

## 竟态条件

+ 当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竟态条件。
+ 最常见的就是“先检查后执行”操作，即通过一个可能失效的观测结果来决定下一步的动作。
+ 竟态条件不是总会发生错误，还需要某种不恰当的执行时序
+ 要避免竟态条件，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中

## 分类

### 不变性

+ 只要一个不可变对象被正确的创建出来了（没有发生this引用逃逸），那其外部的可见状态让永远不会改变，永远不会看到他在多个线程之中处于不一致的状态。
+ 不可变对象一定是线程安全的
+ 不可变条件
    + 对象创建后其状态不能改变
    + 对象的所有域都是final的
    + 对象是正确创建的(this引用没有逸出)
+ 基本数据类型，只要定义时使用final修饰就可以保证不可变
+ 对象
    + 需要对象自行保证其行为不会对其状态产生任何影响
    + 如String对象实例，是典型的不可变对象
    + 保证对象行为不影响自己状态，最简单的就是把对象里面的带有状态的变量声明为final
    + 在构造函数后，就是不可变的
    + Integer不可变：private final int value;

### 绝对线程安全

+ Java API标注是线程安全的，基本都不是绝对线程安全
+ 例如Vector由synchronized修饰，保证了原子性，可见性，有序性。但复合操作仍然不是线程安全的，需要另外添加synchronized修饰



### 相对线程安全

+ 保证该对象单次操作是线程安全的
+ 连续调用则需要使用额外的同步手段确保调用的正确性

### 线程兼容

+ 通常意义上的线程不安全类
+ 如HashMap

### 线程对立

+ 无法在多线程环境中并发使用代码
+ 通常是有害的，应尽量避免

## 活跃性问题（死锁）

两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象

```java
class HoldLockThread implements Runnable{
    private String lockA;
    private String lockB;

    public HoldLockThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA) {
            System.out.println(Thread.currentThread().getName() + " 持有"+lockA+" 尝试持有 "+lockB);
            synchronized (lockB) {
                System.out.println("都持有了");
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";

        new Thread(new HoldLockThread(lockA, lockB), "t1").start();
        new Thread(new HoldLockThread(lockB, lockA), "t2").start();
    }
}
```



## 在构造函数中未初始化完毕就this赋值

```java
import java.util.concurrent.TimeUnit;

public class MainTest {
    public static Point point;

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                new Point(1, 1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread.start();
        TimeUnit.MILLISECONDS.sleep(10);
        if (point != null) {
            System.out.println(point);//Point{x=1, y=0}
        }

    }
}

class Point{
    private final int x, y;

    public Point(int x, int y) throws InterruptedException {
        this.x = x;
        MainTest.point = this;
        TimeUnit.SECONDS.sleep(1);
        this.y = y;
    }

    @Override
    public String toString() {
        return "Point{" +
                "x=" + x +
                ", y=" + y +
                '}';
    }
}
```









