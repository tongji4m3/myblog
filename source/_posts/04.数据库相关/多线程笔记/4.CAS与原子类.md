---
title: Java——Java多线程------CAS与原子类
date: 2021-1-10
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java多线程所做的笔记，CAS与原子类、AtomicReference等。
categories: 多线程
tags:
  - 多线程
  - CAS
  - AtomicReference
abbrlink: 7536122f
---



# CAS

## 理解

+ 基于冲突检测的乐观并发策略
+ 不管风险，先进行操作，如果没有其他线程争用共享数据，就操作成功。否则进行其他补偿操作，如不断地重试，直到出现没有竞争的共享数据为止。
+ 不需要把线程阻塞挂起，非阻塞同步，无锁编程
+ 测试并设置（Test And Set）
+ 比较并交换 Compare and Swap CAS
+ 使用cmpxchg指令完成CAS功能
+ CAS操作通过sun.misc.Unsafe的compareAndSwapInt()和compareAndSwapLong()等提供
+ 使用封装好的JUC下的类，compareAndSet(),getAndIncrement()等
+ 如果CAS失败,则会一直尝试,会给CPU带来很大的开销。
+ 只能保证一个共享变量的原子操作

## 原理

+ 读取当前值E,计算结果值V,比较E和主内存的值E',如果没人动过,则将主内存的值更新为V,结束
+ 不需要加锁,是一种乐观锁
+ 是一条CPU原语
+ 内存位置（变量的内存地址 V),旧的预期值（A),准备设置的新值（B)。
    + 仅当V符合A时，才会用B更新V的值，否则不更新
    + 不管是否更新V值，都会返回V的旧值
    + 是原子操作，执行期间不会被其他线程中断

等价类比：

```java
private volatile int value;

public synchronized int compareAndSwap(int expectValue, int newValue) {
        int oldValue = value;
        if (oldValue == expectValue) {
            value = newValue;
        }
        return oldValue;
    }
```



## ABA问题

其他线程修改数次最后值和原值相同

可以修改版本号，添加时间戳

使用原子引用类AtomicStampedReference，通过控制变量值的版本来保证CAS的正确性

需要解决ABA问题，采用传统互斥同步比原子类更高效

```java
package com.tongji;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicStampedReference;


/*
输出:
t3 第一次版本号: 1
t4 第一次版本号: 1
t3 第二次版本号: 2
t3 第三次版本号: 3
t4 修改成功与否: false
当前最新值:100
 */
public class MainTest {
    //带时间戳的原子引用
    //参数为初始值,版本号
    static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(100,1);

    public static void main(String[] args) {
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+" 第一次版本号: "+atomicStampedReference.getStamp());
            try {
                TimeUnit.SECONDS.sleep(1);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            //模拟了一次ABA问题,但是因为有版本号,所以t4线程并不进行更新
            atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+1);
            System.out.println(Thread.currentThread().getName()+" 第二次版本号: "+atomicStampedReference.getStamp());
            atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+1);
            System.out.println(Thread.currentThread().getName()+" 第三次版本号: "+atomicStampedReference.getStamp());
        },"t3").start();

        new Thread(() -> {
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName()+" 第一次版本号: "+stamp);
            try {
                TimeUnit.SECONDS.sleep(3);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            boolean result = atomicStampedReference.compareAndSet(100, 2019, stamp, stamp + 1);
            System.out.println(Thread.currentThread().getName()+" 修改成功与否: "+result);
            System.out.println("当前最新值:"+atomicStampedReference.getReference());
        },"t4").start();
    }
}

```





# AtomicInteger

AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功

## 方法

+ get()
+ getAndSet(int newValue)
+ getAndIncrement()
+ boolean compareAndSet(int expect, int update)

## 

```java
AtomicInteger atomicInteger = new AtomicInteger();
for (int i = 0; i < 10; i++)
{
    int result = atomicInteger.incrementAndGet();
    System.out.println(result);
}
```

```java
public final int incrementAndGet()
{
    //this当前对象,valueOffset该值的地址偏移量
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
```

```java
public final int getAndAddInt(Object var1, long var2, int var4)
{
    int var5;
    do
    {
        var5 = this.getIntVolatile(var1, var2);
        //因为有可能是这里被挂起,所以获取的值不是最新的
    } while (!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
    
    //可以简化想象var1, var2或var5是当前值,var4是1
}
/*
var1, var2 拼接起来得到主内存的值
var5相当于自己工作内存的值
如果这两个比较相等,则将var5 + var4的值赋给(var1, var2)内存地址里,即实现了i++
this.compareAndSwapInt(var1, var2, var5, var5 + var4)
*/
```

底层:`compareAndSwapInt`是一个`native`方法

跟到c++代码后,调用`lock cmpxchg 指令`,即`CAS`在硬件层面上有指令支持

`cmpxchg`仅仅比较并交换,没有确保原子性,原子性是`lock`保证的

`lock`指令在执行后面指令的时候锁定一个北桥信号

# AtomicReference

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class Main {
    //原子引用线程
    AtomicReference<Thread> atomicReference = new AtomicReference<>();

    public void myLock() {
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName()+" come in");
        /*
        第一个进来的锁发现是null(说明没人锁住),就CAS成功,返回true,就退出循环,不被锁住
        之后进来的,发现不是null,于是CAS不成功,返回false,于是一直卡在循环,直到存储的再次为null
         */
        while (!atomicReference.compareAndSet(null, thread)) {

        }
    }

    public void myUnlock() {
        Thread thread = Thread.currentThread();
        //释放锁,给下一个线程使用
        atomicReference.compareAndSet(thread, null);
        System.out.println(thread.getName()+" come out");
    }

    public static void main(String[] args) {
        Main main = new Main();
        new Thread(()->{
            main.myLock();
            try {
                TimeUnit.SECONDS.sleep(5);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            main.myUnlock();

        },"t1").start();

        //保证t1线程先启动
        try {
            TimeUnit.SECONDS.sleep(1);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }


        new Thread(()->{
            main.myLock();
            main.myUnlock();
        },"t2").start();

        /*
            t1 come in
            t2 come in
            t1 come out
            t2 come out
         */
    }
}
```

