---
title: Java——Java多线程------控制并发流程工具类
date: 2021-1-23
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java多线程所做的笔记，控制并发流程工具类等。
categories: 多线程
tags:
  - 多线程
  - CyclicBarrier
  - Semaphore
abbrlink: 594c9245
---



# JUC

+ java.util.concurrent
+ java.util.concurrent.atomic
+ java.util.concurrent.locks
+ 先写一个资源类(提供一个对外服务的方法,并且使用锁等保证多个线程进来后能正常操作),然后多个线程操作这同一个资源类



# 控制并发流程

![image-20210204061836970](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210204061836970.png)

# CountDownLatch

+ 让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒
+ 当一个或多个线程调用`await`方法时，调用线程会被阻塞
+ 其他线程调用`countDown`方法会将计数器-1(调用`countDown`不会阻塞)
+ 当计数器为零时,因为调用了`await`方法而被阻塞的线程会被唤醒,继续执行
+ CountDownLatch不能重用

![image-20210204062322243](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210204062322243.png)

```java
import java.util.concurrent.CountDownLatch;

//例如启动程序，对外发布服务时，应该所有的都检查完毕（检查数据有没有完毕等前置流程）才进入下一个环节
//主线程等待所有线程都执行完毕才结束
public class Main {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " 离开");
                countDownLatch.countDown();
            }, String.valueOf(i)).start();
        }
        //必须要减到0才能解除
        countDownLatch.await();
        System.out.println("全部结束咯");
    }
}
```



```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;


//例如进行压测，创建很多线程应该先等待，再一个统一的时间再过去
public class MainTest {

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 5; i++) {
            int finalI = i;
            executorService.submit(() -> {
                System.out.println(finalI + "准备完毕");

                try {
                    countDownLatch.await();
                    System.out.println(finalI + "开始跑步");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        //检查场地等
        TimeUnit.SECONDS.sleep(5);
        System.out.println("比赛开始！");
        countDownLatch.countDown();
    }
}

```

## 分析

![image-20210204075136465](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210204075136465.png)

```java
 private final Sync sync;


public CountDownLatch(int count) {
    if (count < 0) throw new IllegalArgumentException("count < 0");
    this.sync = new Sync(count);
}

public long getCount() {
        return sync.getCount();
    }

public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}

public void countDown() {
    sync.releaseShared(1);
}
```



# CyclicBarrier

+ 可循环(`Cyclic`)使用的屏障(`Barrier`)
+ 让一组线程到达一个屏障(同步点)时被阻塞,直到最后一个线程到达屏障时,屏障才会打开,所有被屏障拦截的线程才会继续干活
+ 线程进入屏障是通过`CyclicBarrier`的`await()`方法

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class Main {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
            System.out.println("大威天龙!");
        });
        for (int i = 0; i < 7; i++) {
            int finalI = i+1;
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+ " 收集龙珠"+finalI );
                try {
                    cyclicBarrier.await();
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
                catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            },"thread"+String.valueOf(i)).start();

        }

    }
}
```

# Semaphore

+ 用于多个共享资源的互斥使用
+ 用于并发线程数的控制
+ 当一个线程调用acquire（获取），要么成功获得信号量（信号量-1），要么阻塞到有线程释放信号量
+ release（释放），实际会将信号量的值+1，然后唤醒等待的线程



```java
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class Main {
    public static void main(String[] args) {
        //抢车位
        Semaphore semaphore = new Semaphore(3);
        for (int i = 0; i < 6; i++) {
            new Thread(()->{
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName()+" 抢到车位");
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(Thread.currentThread().getName()+" 离开车位");
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
                finally {
                    semaphore.release();
                }
            },String.valueOf(i)).start();
        }
    }
}
```

## 原理

![image-20210204075438793](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210204075438793.png)

# AQS

![image-20210204074244081](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210204074244081.png)

![image-20210204082155349](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210204082155349.png)