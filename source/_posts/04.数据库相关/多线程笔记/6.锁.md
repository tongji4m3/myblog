---
title: Java——Java多线程------锁
date: 2021-2-8
author: tongji4m3
top: true
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java多线程所做的笔记，ReentrantLock、各种锁的对比、锁粗化、锁消除等。
categories: 多线程
tags:
  - 多线程
  - 锁
  - ReentrantLock
abbrlink: 5d17beaf
---



# ReentrantLock

+ 是Lock的重入锁实现
+ 提供无条件的、可轮询的、定时的、可中断的锁获取操作
+ 与synchronized提供相同的互斥性和内存可见性
+ synchronized无法中断一个正在等待获取锁的线程，或者无法在请求获取一个锁时无限的等待下去
+ 必须在finally中释放锁
+ tryLock方法：如果不能获得所有需要的锁，那么可以使用可定时的或可轮询的锁获取方式；它会释放已经获得的锁，然后重新尝试获取所有锁

![image-20210204080116073](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210204080116073.png)

## 新功能

### 等待可中断

当持有锁的线程长期不释放锁时，正在等待的线程可以放弃等待，改为处理其他事情

### 公平锁

+ 公平锁保证多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁
+ 而非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁
+ synchronized是非公平锁，ReentrantLock默认非公平，可以通过构造函数设置为公平锁
+ 使用公平锁，性能急剧下降，明显影响吞吐量

### 锁绑定多个条件

+ 一个ReentrantLock对象可以绑定多个Condition对象
+ 多次调用newCondition()即可

## Synchronized和ReentrantLock的区别

+ `Synchronized`是关键字,是`JVM`层面的,使用`monitorenter`进入,`monitorexit`退出,而且保证正常于异常都会退出。`Lock`是`JUC`下的具体类,是API层面的锁

+ `Synchronized`不需要手动释放锁,当代码块执行完会自动让线程释放对锁的占用,而`ReentrantLock`需要用户手动释放锁

+ `Synchronized`不可中断,除非抛出异常或者运行结束.`ReentrantLock`可中断,可以通过

    ```java
    reentrantLock.tryLock(1, TimeUnit.SECONDS);
    //或者
    reentrantLock.lockInterruptibly();
    ```

+ `Synchronized`默认非公平锁,`ReentrantLock`默认非公平锁,但是可以调节到公平锁

+ `ReentrantLock`可以绑定多个条件`Condition`,用来实现分组唤醒,或者精确唤醒

# 乐观锁和悲观锁

![image-20210203161903172](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203161903172.png)



![image-20210203162524629](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203162524629.png)

![image-20210203162548746](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203162548746.png)

## 悲观锁

![image-20210203162017379](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203162017379.png)

最典型synchronized、Lock

## 乐观锁

最典型CAS

原子类、并发容器

![image-20210203162107084](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203162107084.png)



# 可重入锁和不可重入锁

## 可重入锁(递归锁)

+ 指的是同一线程外层函数获得锁之后,内层递归函数仍然能获取该锁的代码
+ 线程可以进入任何一个他已经拥有的锁所同步着的代码块
+ `ReentrantLock `,`Synchronized`就是经典的可重入锁
+ 最大作用在于避免死锁
+ 即某个线程可以再次获得一个已经由它自己持有的锁
+ 重入的实现方式是计数（类似引用计数）

```java
public class Main {
    public synchronized void sendSMS() {
        System.out.println(Thread.currentThread().getName() + " invoke sendSMS");
        sendEmail();
    }
    public synchronized void sendEmail() {
        System.out.println(Thread.currentThread().getName() + " invoke sendEmail");
    }

    public static void main(String[] args) {
        Main main = new Main();
        new Thread(() -> {
            main.sendSMS();
        },"t1").start();
    }
}
```

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Main {
    Lock lock = new ReentrantLock();

    public void sendSMS() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " invoke sendSMS");
            sendEmail();
        }
        finally {
            lock.unlock();
        }
    }
    public void sendEmail() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " invoke sendEmail");
        }
        finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        Main main = new Main();
        new Thread(() -> {
            main.sendSMS();
        },"t1").start();
        new Thread(() -> {
            main.sendSMS();
        },"t2").start();
        new Thread(() -> {
            main.sendSMS();
        },"t3").start();
    }
}
```

**例子2**

```java
public class Widget {
    public synchronized void doSomething() {
        System.out.println("Widget");
    }
}



public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        System.out.println("LoggingWidget");
        super.doSomething();
    }

    //(我猜是用了多态,然后每次锁的都是Widget对象)
    public static void main(String[] args) {
        Widget widget = new LoggingWidget();
        widget.doSomething();
    }
}
```


如果没有可重入锁，将发生死锁。因为在每个`doSomething()`执行前，都会获得`Widget`的锁,如果内置锁不是可重入的,那么在调用`super.doSomething();`时,就无法获得`Widget`上的锁(因为它已经被持有),就会死锁

## 原理

![image-20210203165612217](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203165612217.png)



# 公平和非公平锁

公平锁：在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，按照FIFO的规则。

非公平锁：运行加塞。是指多个线程获取锁的顺序并不是按照申请锁的顺序

例如让10个线程分别打印两次，如果是公平锁，就会0-10，0-10，而非公平锁则会每个线程都连续打印两次。原因是他没有陷入阻塞，所以更快的拿到锁

## 对比

![image-20210203171014652](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203171014652.png)

## 特例

![image-20210203171000341](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203171000341.png)

## 源码分析

![image-20210203171045005](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203171045005.png)

## 公平锁

在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，按照FIFO的规则。

优点在于吞吐量大

## 非公平锁

为了提高效率，避免唤醒带来的空档期

运行加塞。是指多个线程获取锁的顺序并不是按照申请锁的顺序

## 实现

+ `ReentrantLock `默认非公平锁，可以指定构造函数决定是公平锁还是非公平锁
+ 对于`Synchronized`是非公平锁



# 共享锁和排他锁

+ 独占锁(写锁)：指该锁一次只能被一个线程所持有。`ReentrantLock `,`Synchronized`就是独占锁
+ 共享锁(读锁)：指该锁可被多个线程所共享，获得共享锁后，可以查看但是无法修改和删除数据，其他线程也还可以获取共享锁
+ ReentrantReadWriteLock的读锁，写锁
+ reentrantReadWriteLock.readLock();
+ reentrantReadWriteLock.writeLock();
+ 



+ 读-读能共存
+ 读-写不能共存
+ 写-写不能共存

```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

class MyCache {
    //保证可见性
    private volatile Map<String, Object> map = new HashMap<>();
    //读写锁,可以在读和写时采取不同策略
    private ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
    //写,读,清空

    //写操作必须独占,原子 中间不允许被打断
    public void put(String key, Object value) {
        reentrantReadWriteLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 正在写入: " + key);

            try {
                TimeUnit.MILLISECONDS.sleep(300);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }

            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + " 写入完成");
        }
        finally {
            reentrantReadWriteLock.writeLock().unlock();
        }
    }

    public Object get(String key) {
        reentrantReadWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 正在读取: " + key);

            try {
                TimeUnit.MILLISECONDS.sleep(300);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }

            Object object = map.get(key);
            System.out.println(Thread.currentThread().getName() + " 读取完成 " + object);
            return object;
        }
        finally {
            reentrantReadWriteLock.readLock().unlock();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();

        for (int i = 0; i < 5; i++) {
            int finalI = i;
            new Thread(() -> {
                myCache.put(String.valueOf(finalI), String.valueOf(finalI));
            }, String.valueOf(i)).start();
        }
        for (int i = 0; i < 5; i++) {
            int finalI = i;
            new Thread(() -> {
                myCache.get(String.valueOf(finalI));
            }, String.valueOf(i+5)).start();
        }
        /*
        0 正在写入: 0
        0 写入完成
        1 正在写入: 1
        1 写入完成
        2 正在写入: 2
        2 写入完成
        3 正在写入: 3
        3 写入完成
        4 正在写入: 4
        4 写入完成
        5 正在读取: 0
        6 正在读取: 1
        7 正在读取: 2
        8 正在读取: 3
        9 正在读取: 4
        9 读取完成 4
        7 读取完成 2
        6 读取完成 1
        8 读取完成 3
        5 读取完成 0
         */
    }
}
```

# 自旋锁与非自旋锁

## 适用场景

![image-20210203175512244](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203175512244.png)

+ 是指尝试获取锁的线程不会立即阻塞,而是采用循环的方式去尝试获取锁
+ 好处是减少线程上下文切换,缺点是锁被占用的时间很长的话，自旋的线程不断循环会白白消耗CPU资源
+ java.util.concurrent的atmoic包下的类基本都是自旋锁的实现
+ 实现的原理是CAS
+ AtomicInteger调用unsafe进行自增操作，如果修改过程中遇到其他线程竞争导致没有修改成功，就在while里死循环，直到修改成功
+ AtomicReference



# 可中断锁和不可中断锁

![image-20210203175554080](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203175554080.png)

# 锁消除

+ 即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。
+ 来源于逃逸分析技术的数据支持。
+ 如果判断一段代码中堆上所有数据都不会被其他线程访问到，就可以当作栈上内存对待，认为是线程私有的
+ 很多同步机制不是程序员自己加的
+ StringBuffer.append()都有同步块，锁sb对象
+ 虚拟机观测变量sb，经过逃逸分析后发现他的动态作用域限制在方法内部，sb的所有引用都不会逃逸到方法外部，其他线程无法访问，所以可以安全消除锁

```java
public String concatString(String s1, String s2, String s3) {
        return s1 + s2 + s3;
    }
//上面的代码在JDK5之前会转换成StringBuffer对象进行连续append
//在JDK5之后会转换成StringBuilder对象
public String concatString(String s1, String s2, String s3) {
        StringBuffer sb = new StringBuffer();
        sb.append(s1);
        sb.append(s2);
        sb.append(s3);
        return sb.toString();
    }
```

# 锁粗化

+ 编写代码时推荐把同步块的作用访问限制得尽量小，只在共享数据的实际作用域进行同步。可以使得需要同步的操作数量尽可能变小，即使存在锁竞争，等待锁的线程也能尽快拿到锁
+ 原则上只在共享数据的实际作用域上进行同步，使等待锁的线程能尽快获得锁。但如果一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环体内部，即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗
+ 例如上述的连续append，如果虚拟机探测到一串零碎的操作对同一个对象加锁。就将会把加锁同步的范围粗化到整个操作序列的外部。例如把操作扩展到三次append（）操作外部，只需要一次加锁









