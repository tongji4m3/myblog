---
title: Java——Java多线程------JMM与Volatile
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java多线程所做的笔记，JMM与Volatile，包括原子性、可见性、重排序等。
categories: 多线程
tags:
  - 多线程
  - JMM
  - Volatile
abbrlink: '10505305'
date: 2020-12-30 00:00:00
---





# 为什么需要JMM

## 背景

+ 缺少同步，一个线程无法看到变量的最新值
    + 在编译器中生成的指令顺序，可以与源代码中的顺序不同，指令重排优化
    + 编译器会把变量保存在寄存器而不是内存中，成熟的全局寄存器分配算法
    + 保存在处理器本地缓存中的值，对于其他处理器是不可见的
+ 单线程环境，只要程序的最终结果与严格串行环境中的执行结果相同，上述所有操作都是允许的，除了提高程序执行速度外，不会产生其他影响
+ 多线程环境，只有当多个线程要共享数据时，才必须协调他们之间的操作
+ 计算机的存储设备与处理器的运算速度有几个数量级的差距,现代计算机加入多层高速缓存。他带来了缓存一致性问题
    + 共享内存多核系统：即每个处理器都有自己的高速缓存，而他们又共享同一主内存
    + 当多个处理器的运算任务都涉及同一块内存区域时，将可能导致各自的缓存数据不一致
    + 解决一致性问题，各个处理器访问缓存时要遵循一些协议，如MSI，MESI
+ 处理器可能会对输入代码进行乱序执行优化
    + 处理器会在计算之后将乱序执行的结果重组，保证改结果与顺序执行的结果是一致的
    + 如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性不能靠代码的先后顺序来保证
    + Java虚拟机的即时编译器也有指令重排序优化

## 平台内存模型

+ 共享内存的对处理器体系结构
    + 每个处理器有自己的缓存
    + 定期与主内存进行协调
    + 提供不同级别的缓存一致性，最小保证是允许不同的处理器在任意时刻从同一个存储位置上看到不同的值
+ 放宽存储一致性保证
    + 不需要在任意时刻知道其他处理器正在进行的工作
    + 定义特殊指令（内存屏障），当需要共享数据时，这些指令能实现额外的存储协调保证
    + JVM通过在恰当位置插入内存屏障来屏蔽JMM和底层平台内存模型的差异
    + 当跨线程共享数据时，需要通过内存屏障防止出现数据不一致情况
+ 串行一致性
    + 任何现代多处理器架构都不保证
    + 想象在程序中只存在唯一的操作执行顺序，而不考虑这些操作在何种处理器上执行，并且每次读取变量时，都能获取在执行序列中最近一次写入该变量的值
+ 重排序
    + 如果每个线程中的各个操作之间不存在数据流依赖性，那么这些操作可以乱序执行



# JMM理解

+ JMM是一组规范，规定了JVM必须遵循一组最小保证，这组保证规定了对变量的写入操作在何时将对于其他线程可见
+ 所有变量都存储在主内存中，主内存是共享内存区域，所有线程都可以访问。主内存直接对应与物理硬件的内存
+ 每个线程都有自己的工作内存
    + 每个线程创建时JVM都会为其创建一个工作内存(栈空间),工作内存是每个线程的私有数据结构，
    + 工作内存优先存储与寄存器和高速缓存中
    + 各个线程中的工作内存都存储着主内存中的变量副本拷贝
    + 但线程对变量的所有操作必须在工作内存中进行，而不能直接读取主内存中的数据。
    + 不同线程不能访问其他线程的工作内存。线程间变量值的传递需要通过主内存来完成
    + 线程首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存

# JMM主要内容

## 重排序

好处：提高处理速度

三种情况：编译器优化、CPU指令重排、内存重排序

## 原子性

默认的原子性操作

除long、double之外的基本类型

所有引用的reference的赋值操作

Atomic包中所有类

## 可见性

+ 保证此变量对所有线程的可见性
+ 当一条线程修改了这个变量的值，新值对于其他线程是立即得知的
+ 普通变量不能保证立即可见，普通变量的值在线程间传递时需要通过主内存完成。只有A线程修改该值，向主内存回写，B线程在A回写完成后再对主内存读取，新变量值才对线程B可见
+ synchronized可见性：对一个变量unlock前，必须先把变量同步回主内存中
+ final可见性：被final修饰的字段在构造器初始化完成后，并且没有把this引用传递出去，那么在其他线程中就能看到final字段的值

## 关于同步的规定

+ 线程解锁前，必须把共享变量的值刷新回主内存
+ 线程加锁前，必须读取主内存的最新值到自己的工作内存
+ 加解锁是同一把锁

## 内存屏障

+ 如果在指令间插入一条`Memory Barrier`，则不管什么指令都不能和该指令重排序。也就是说通过内存屏障禁止在内存屏障前后的指令执行重排序优化。
+ 而且会强制刷出各种CPU缓存数据，因此所有线程都能读取到这些数据的最新版本

# 内存布局

普通对象:

+ `markword`,8字节 记录了锁信息
    + 存储自身的运行时数据，如HashCode，GC分代年龄
    + 占用64比特，根据对象的状态复用自己的存储空间
+ `class pointer` 存储指向方法区对象类型数据的指针，属于哪个类 压缩后4字节
+ 数组对象还有一个额外的部分存储数组长度
+ 
+ `instance data` 对象里面的实例数据  压缩后每个4字节
+ `padding`补成8字节的整数倍

```java
public static void main(String[] args) 
{
    Object object = new Object();//8字节markword,4字节class pointer,4字节补充 一共16字节
    System.out.println(ClassLayout.parseInstance(object).toPrintable());
}
```

```
java.lang.Object object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

```

## 压缩指针

+ 默认64位操作系统应该是八个字节,但是使用压缩指针`UseCompressedClassPointers`,`class pointer`只占了4字节
+ `UseCompressedOops`,使得对象指针也是压缩的

```
C:\code_home\JUC>java -XX:+PrintCommandLineFlags -version
-XX:InitialHeapSize=265782080 -XX:MaxHeapSize=4252513280 -XX:+PrintCommandLineFlags -XX
:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocat
ion -XX:+UseParallelGC
java version "1.8.0_261"
Java(TM) SE Runtime Environment (build 1.8.0_261-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)
```

# 内存布局

markword,8字节 记录了锁信息，且锁升级时存储不同的信息

class pointer 属于哪个类 压缩后4字节，默认64位操作系统应该是八个字节,但是使用压缩指针UseCompressedClassPointers,class pointer只占了4字节

instance data 对象里面的实例数据  压缩后每个4字节，UseCompressedOops,使得对象指针也是压缩的

padding补成8字节的整数倍

# Volatile

+ 是java虚拟机提供的轻量级的同步机制
+ volatile变量读操作的性能消耗与普通变量没区别
+ 写操作需要在本地代码中插入许多内存屏障来保证处理器不发生乱序执行
+ 总开销比锁低，使用场景符合要求则优先用volatile
+ 三个保证
    + 在工作内存中，每次使用V之前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所作的修改
    + 在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改
    + volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同

## 可见性



我们不仅希望防止某个线程正在使用对象状态而另外一个线程在同时修改该状态，而且希望确保当一个状态修改了对象状态后，其他线程能够看到发生的状态变化。

加锁的含义不仅仅局限于互斥行为,还包括了内存可见性,即确保某个线程写入该变量的值对于其他线程来说都是可见的。

没有可见性我们就无法确保执行读操作的线程能适时地看到其他线程写入的值

- 对volatile变量执行写操作时，会在写操作后加入一条store写屏障指令，强制将缓存刷新到主内存中
- 对volatile变量执行读操作时，会在读操作前加入一条load读屏障指令，强制使缓冲区缓存失效，所以会从主内存读取最新值。
- 防止指令重排序。

volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样在任何时刻，不同的线程总能看到该变量的最新值。

```java
package com.tongji;

import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;

class MyData{
    volatile int number = 0;

    public void add() {
        number = 60;
    }
}

public class MainTest {

    public static void main(String[] args) {
        MyData myData = new MyData();
        new Thread(()->{
            System.out.println(Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(3);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            myData.add();
            System.out.println(Thread.currentThread().getName()+": "+myData.number);

        },"thread1").start();
        //main线程
        while (myData.number == 0) {
            //一直等待
        }
        System.out.println(Thread.currentThread().getName()+": "+myData.number);
        /*
        加了volatile才有,不加则一直死循环:
            thread1
            thread1: 60
            main: 60
         */
    }
}
```

## 不保证原子性

### 不需要加锁就能保证原子性的情况

运算结果并不依赖与变量的当前值，或者能保证只有单一的线程修改变量的值

变量不需要与其他的状态变量共同参与不变约束

```java
public class Test
{
    private volatile boolean shutdownRequested;
    
    public void shutdown() {
        //不依赖与变量的当前值
        shutdownRequested = true;    
    }

    public void doWork() {
        while (!shutdownRequested) {
            //业务逻辑
        }
    }
}
```



虽然volatile变量在各个线程的工作内存中不存在一致性问题，但Java里面的运算操作符不是原子操作，依然并发不安全

例如一条race++ 指令，由四条字节码指令构成，当`getstatic`指令把race的值取到操作栈顶时，`volatile`关键字保证此时race的值的正确性，但是在执行接下来的指令的时候，其他线程可能已经将race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能将较小的race值同步回主内存中



`number++`对应的字节码：

+ getfield
+ iconst_1
+ iadd
+ putfield

包含三个操作:

+ 读取value
+ 将value+1
+ 并将计算结果写入value

假设两个线程A，B同时执行到`iadd`,要写回的值是2，然后A执行`putfield`操作，虽然保证了可见性，也就是其他线程此时如果读取该number值，是正确的。但是B此时不需要读取了，他只需要把值写回主内存，即B的操作栈顶的值是过期的数据。

```java
package com.tongji;

import java.util.concurrent.TimeUnit;

class MyData{
    volatile int number = 0;

    public void add() {
        number++;
    }
}

public class MainTest {

    public static void main(String[] args) {
        MyData myData = new MyData();
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    myData.add();
                }
            }
        };
        for (int i = 0; i < 20; i++) {
            new Thread(runnable).start();
        }

        while (Thread.activeCount() > 2) {
            //使当前线程从执行状态（运行状态）变为可执行态（就绪状态）.cpu会从众多的可执行态里选择，
            // 当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。
            Thread.yield();
        }
        //18801
        System.out.println(myData.number);
    }
}
```

使用`AtomicInteger`来解决

```java
public class MainTest {

    public static void main(String[] args) {

        AtomicInteger atomicInteger = new AtomicInteger();

        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    atomicInteger.incrementAndGet();
                }
            }
        };
        for (int i = 0; i < 20; i++) {
            new Thread(runnable).start();
        }

        while (Thread.activeCount() > 2) {
            //使当前线程从执行状态（运行状态）变为可执行态（就绪状态）.cpu会从众多的可执行态里选择，
            // 当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。
            Thread.yield();
        }
        //18801
        System.out.println(atomicInteger.get());
    }
}
```



## 禁止指令重排

保证变量赋值操作的顺序与程序代码中的执行顺序一致

```java
//该例子不好，后续换一个
public class MainTest {
    int a = 0;
    boolean flag = false;

    /*
    由于指令重排,可能导致执行顺序是:
    flag = true;
    a = 1;
    而多线程环境下,就会导致错误的情况
     */
    public void method1() {
        a = 1;
        flag = true;
    }

    public void method2() {
        if (flag) {
            a = a + 5;
        }
    }
}
```

### 配置读取并发

如果定义initialized变量没有使用volatile变量修饰，可能由于指令重排序优化，导致线程A的最后一行代码“initialized = true;”被提前执行。这样在线程B中使用配置信息的代码就可能出现错误

```java
import java.util.concurrent.TimeUnit;

public class Test
{
    private volatile boolean initialized = false;

    //假设以下代码在线程A中执行
    public void A() {
        //读取配置信息,进行初始化等
        
        //当配置完成时,通知其他线程配置可用
        initialized = true;
    }

    //假设以下代码在线程B中执行
    public void B() throws InterruptedException {
        //等待initialized = true,代表线程A已经把配置信息初始化完成
        while (!initialized) {
            TimeUnit.MILLISECONDS.sleep(100);
        }
        //使用线程A中已初始化的配置信息
    }
}
```



## 应用：单例模式

### 不安全的延迟初始化

将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次

```java
public class LazyInitRace {
    private ExpensiveObject instance = null;

    public ExpensiveObject getInstance() {
        if (instance == null) {
            instance = new ExpensiveObject();
        }
        return instance;
    }
}
```

如果线程A、线程B同时执行`getInstance()`,可能会同时进入循环`if (instance == null) {}`里，则会创建两个实例

如果用于初始化注册表，可能就会丢失部分注册信息，或者多个行为对同一组注册对象变现出不一致的视图

### 双重检测机制

有volatile修饰，则赋值后多执行了一个lock 操作，即内存屏障。lock作用是将本处理器的缓存写入内存中，而且引发别的内核无效后其缓存，通过这样一个空操作，可让前面volatile变量的修改对其他处理器立即可见。在同一个处理器中，重排序过的代码看起来仍然是有序的，因此lock指令把修改同步到内存时，意味着所有之前的操作已经执行完成。所以指令重排序无法越过内存屏障

重排序时不能把后面的指令重排序到内存配置之前的位置

只有一个处理器访问内存时，不需要内存配置，但是有多个处理器访问同一块内存，且其中一个在观测另一个，就需要内存屏障来保证一致性

用volatile来防止指令重排序：新建对象有三个步骤，可能进行了指令重排序，即先提供了对象引用，然而此时的对象可能没成功的构建，让其他的线程拿到了一个空引用，之后就出现NPE

+ 构建对象：首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧。然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。
+ 初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法
+ 引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。



用volatile保证可见性：赋值时可能其他线程看不见，又重新赋值了一遍

```java
public class MainTest {
    //必须要加 volatile !!
    private static volatile MainTest instance = null;

    private MainTest() {
        System.out.println(Thread.currentThread().getName());
    }

    //DCL (Double Check Lock 双重检测机制)
    /*
    没加volatile:出现几率很小,但是还是有可能的
    因为指令重排的问题:

    instance = new MainTest();分为三步完成:
    memory=allocate(); //分配对象内存空间
    instance(memory); //初始化对象
    instance=memory; //设置instance指向刚分配的内存地址,此时instance!=null

    但是他们不存在数据依赖关系,在单线程下执行结果不变.所以有可能发生指令重排序

    所以某个线程在最外层的 if (instance == null) 时,由于指令重排序,他看到的instance!=null
    但是instance实际上尚未初始化完成,所以出现了线程安全问题
     */
    public static MainTest getInstance() {
        if (instance == null) {
            synchronized (MainTest.class) {
                if (instance == null) {
                     // A线程被指令重排了，刚好先赋值了；但还没执行完构造函数。
                    instance = new MainTest();
                }
            }
        }
        // 后面B线程执行时将引发：对象尚未初始化错误。
        return instance;
    }

    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                MainTest.getInstance();
            }
        };
        for (int i = 0; i < 100000; i++) {
            new Thread(runnable).start();
        }
    }
}
```

## 使用推荐

+ 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值
+ 该变量不会与其他状态变量一起纳入不变性条件中
+ 在访问变量时不需要加锁















