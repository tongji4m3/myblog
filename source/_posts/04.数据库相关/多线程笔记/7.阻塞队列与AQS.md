---
title: Java——Java多线程------阻塞队列与AQS
date: 2021-1-19
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java多线程所做的笔记，阻塞队列与AQS、LinkedBlockingQueue等。
categories: 多线程
tags:
  - 多线程
  - 阻塞队列
  - LinkedBlockingQueue
abbrlink: 83bfd605
---



# 阻塞队列架构

在某些情况下会挂起线程(阻塞),一旦条件满足,被挂起的线程又会自动被唤醒

![image-20201202165228930](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201202165228930.png)

`ArrayBlockingQueue`:有界阻塞队列

`LinkedBlockingQueue`:有界阻塞队列,但是最大是`Integer.MAX_VALUE`

`SynchronousQueue`:只存储一个元素,相当于定制的

# 核心方法

## 抛出异常方法

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class Main {
    public static void main(String[] args) {
        //该队列最大为3
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
        System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("b"));
        System.out.println(blockingQueue.add("c"));

        //抛出异常:java.lang.IllegalStateException: Queue full
//        System.out.println(blockingQueue.add("x"));

        //检查队首元素
        System.out.println(blockingQueue.element());

        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());

//        java.util.NoSuchElementException
//        System.out.println(blockingQueue.remove());

//        java.util.NoSuchElementException
//        System.out.println(blockingQueue.element());
    }
}
```

## 返回特殊值方法

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class Main {
    public static void main(String[] args) {
        //该队列最大为3
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
        System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("b"));
        System.out.println(blockingQueue.offer("c"));
        //false
        System.out.println(blockingQueue.offer("d"));

        System.out.println(blockingQueue.peek());

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        //null
        System.out.println(blockingQueue.poll());
    }
}
```

## 阻塞方法

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        //该队列最大为3
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
        blockingQueue.put("a");
        blockingQueue.put("b");
        blockingQueue.put("c");
        //队列满了,该线程会等待
//        blockingQueue.put("d");
        blockingQueue.take();
        blockingQueue.take();
        blockingQueue.take();
        //不消费完线程,就阻塞掉
        blockingQueue.take();

    }
}
```

## 超时方法

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        //该队列最大为3
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
        System.out.println(blockingQueue.offer("a", 2L, TimeUnit.SECONDS));
        System.out.println(blockingQueue.offer("a", 2L, TimeUnit.SECONDS));
        System.out.println(blockingQueue.offer("a", 2L, TimeUnit.SECONDS));
        //只阻塞2s,就会返回false
        System.out.println(blockingQueue.offer("a", 2L, TimeUnit.SECONDS));

    }
}
```

# ArrayBlockingQueue

有界阻塞队列

# LinkedBlockingQueue

有界阻塞队列,但是最大是Integer.MAX_VALUE



# SynchronousQueue

容量为0

![image-20210204061232883](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210204061232883.png)

![image-20210204061257644](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210204061257644.png)

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

public class Main{
    public static void main(String[] args) {
        //同步队列不存储,只能生产一个就消费一个
        BlockingQueue<String> blockingQueue = new SynchronousQueue<>();
        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName()+" put");
                blockingQueue.put("1");
                System.out.println(Thread.currentThread().getName()+" put");
                blockingQueue.put("2");
                System.out.println(Thread.currentThread().getName()+" put");
                blockingQueue.put("3");
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t1").start();
        new Thread(()->{
            try {
                TimeUnit.SECONDS.sleep(3);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            try {
                System.out.println(blockingQueue.take());
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t2").start();
    }
}
```



# LockSupport

+ 构建同步组件的基础工具，帮AQS完成相应线程的阻塞或者唤醒的工作
+ 不需要synchronized或lock
+ 先唤醒再等待也可以正常运行
+ 它是一个线程阻塞工具类,所有方法都是静态的,可以让线程在任意位置阻塞
+ 它调用的是Unsafe里的native方法
+ 它和每个使用他的线程都有一个permit关联
+ 线程阻塞需要消耗permit,每个permit不可累计,最多一个

# AQS

抽象的队列同步器

是用来构建锁或者其他同步器组件的重量级基础框架及整个`JUC`体系的基石。通过内置的`FIFO`队列来完成资源获取线程的排队工作,并通过一个int类型变量表示持有锁的状态

## 作用

基本上`CountDownLatch`、`ReentrantLock`、`Semaphore信号量`、`ReentrantReadWriteLock`、`CyclicBarrier`都和`AQS`有关

+ **锁**是面对锁的使用者,定义了程序员和锁交互的使用层`API`
+ **同步器**,提出统一规范并简化锁的实现,屏蔽了同步状态管理,阻塞线程排队和通知,唤醒机制等



















