---
title: Java——Java多线程------ThreadLocal
date: 2021-1-15
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java多线程所做的笔记，ThreadLocal的原理与应用场景等。
categories: 多线程
tags:
  - 多线程
  - ThreadLocal
  - 内存泄漏
abbrlink: 23db7312
---



# 理解

- ThreadLocal叫做线程本地变量或线程本地存储。为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。

- ThreadLocal提供的方法为每个使用该变量的线程都存有一份独立的副本,因此get总是返回由当前执行线程在调用set时设置的最新值

- 可以用于防止可变的单实例对象或全局变量进行共享

- 让某个需要使用的对象在线程间隔离（每个线程都有自己的独立的对象）

- 在任何方法中都可以轻松获取到该对象

- initialValue：在ThreadLocal第一次get时就把对象给初始化出来，对象的初始化时机可以由我们控制

- set：如果需要保存到ThreadLocal里的对象的时机不由我们随意控制，例如拦截器里的用户信息，就用set存放

    

# 应用场景

## 每个线程需要一个独享的对象

+ 每个Thread内有自己的实例副本，不共享
+ 例如教材只有一本，一起做笔记有线程安全问题，复印后就没有问题
+ 通常是一个工具类，典型需要使用的类有SimpleDateFormat和Random，主要解决线程不安全的问题

## 每个线程内需要保存全局变量

（例如在拦截器中获取用户信息），可以让不同的方法直接使用，避免参数传递的麻烦

# 场景1：SimpleDateFormat

## 初始版本：使用线程池

创建了1000个SimpleDateFormat

```java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadLocalUsage00 {
    public static ExecutorService executorService = Executors.newFixedThreadPool(10);

    public String date(int seconds) {
        //参数单位是ms，从1970.1.1 00:00:00 GMT计时
        Date date = new Date(1000L * seconds);
        return new SimpleDateFormat("yyyy-MM-dd hh:mm:ss").format(date);
    }

    public static void main(String[] args) {
        //这样的缺点是，创建了1000个SimpleDateFormat
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            executorService.submit(() -> {
                //从1970-01-01 08:00:00开始
                String date = new ThreadLocalUsage00().date(finalI);
                System.out.println(date);
            });
        }
        executorService.shutdown();
    }
}

```

## 把SimpleDateFormat当静态使用

```java
/*
1970-01-01 08:16:04
1970-01-01 08:16:04
按道理用i递增，不应该出现一样的
可以用synchronized解决，但是效率低
*/
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadLocalUsage01 {
    public static ExecutorService executorService = Executors.newFixedThreadPool(10);
    public static SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");


    public String date(int seconds) {
        //参数单位是ms，从1970.1.1 00:00:00 GMT计时
        Date date = new Date(1000L * seconds);
        return simpleDateFormat.format(date);
    }

    public static void main(String[] args) {
        //这样的缺点是，创建了1000个SimpleDateFormat
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            executorService.submit(() -> {
                //从1970-01-01 08:00:00开始
                String date = new ThreadLocalUsage01().date(finalI);
                System.out.println(date);
            });
        }
        executorService.shutdown();
    }
}

```

## 用ThreadLocal实现

```java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;



public class ThreadLocalUsage03 {
    public static ThreadLocal<SimpleDateFormat> simpleDateFormatThreadLocal = new ThreadLocal<SimpleDateFormat>(){
        @Override
        protected SimpleDateFormat initialValue() {
            return new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        }
    };

    public static ExecutorService executorService = Executors.newFixedThreadPool(10);

    public String date(int seconds) {
        //参数单位是ms，从1970.1.1 00:00:00 GMT计时
        Date date = new Date(1000L * seconds);
        return simpleDateFormatThreadLocal.get().format(date);
    }

    public static void main(String[] args) {
        //这样的缺点是，创建了1000个SimpleDateFormat
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            executorService.submit(() -> {
                //从1970-01-01 08:00:00开始
                String date = new ThreadLocalUsage03().date(finalI);
                System.out.println(date);
            });
        }
        executorService.shutdown();
    }
}

```



## 场景2：需要用户信息

不同请求（不同线程）user对象不同

即这些信息在同一个线程中相同，但是不同线程中使用的业务内容是不同的

在线程生命周期内，都可以通过这个静态ThreadLocal实例的get()方法取得自己set过的那个对象，避免了将这个对象（例如user对象）作为参数传递的麻烦

例子：

```java
public class UserContextHolder {
    public static ThreadLocal<User> holder = new ThreadLocal<>();
    public static void main(String[] args) {
        new Service1().process();
    }
}

class Service1 {
    public void process() {
        User user = new User("张三", "123456");
        UserContextHolder.holder.set(user);
        System.out.println("Service1:"+user);
        new Service2().process();
    }
}

class Service2 {
    public void process() {
        User user = UserContextHolder.holder.get();
        System.out.println("Service2:"+user);
        new Service3().process();
    }
}
class Service3 {
    public void process() {
        User user = UserContextHolder.holder.get();
        System.out.println("Service3:"+user);
    }
}
```



实际使用：

```java
UserDetails userDetails = loadUserByUsername(user.getUsername());
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authentication);
        


//获取当前用户
BoyingUserDetails userDetails  = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
return userDetails.getUser();
```



# 原理

## ThreadLocalMap 

遇到冲突采取的是线性探测法

![image-20210203153558223](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203153558223.png)

每个Thread中都有一个ThreadLocalMap 

![image-20210203152718142](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203152718142.png)

## initialValue()

一般来说重写该方法

```java
protected T initialValue() {
    return null;
}
```

## set()

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    //键值对：(this, value)
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

## get()

```java
public T get() {
    //先找到当前线程 再找到当前线程的ThreadLocalMap
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        //key是当前threadLocal引用
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

//如果get为null，则initialValue()
private T setInitialValue() {
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        return value;
    }
```

## remove()

```java
public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        m.remove(this);
}
```

# 可能导致内存泄漏

内存泄漏：某个对象不再有用，但是占用的内存却不能被回收

```java
static class ThreadLocalMap {

    /**
     * The entries in this hash map extend WeakReference, using
     * its main ref field as the key (which is always a
     * ThreadLocal object).  Note that null keys (i.e. entry.get()
     * == null) mean that the key is no longer referenced, so the
     * entry can be expunged from table.  Such entries are referred to
     * as "stale entries" in the code that follows.
     */
    static class Entry extends WeakReference<ThreadLocal<?>> {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal<?> k, Object v) {
            super(k);
            value = v;
        }
    }

    /**
     * The initial capacity -- MUST be a power of two.
     */
    private static final int INITIAL_CAPACITY = 16;

    /**
     * The table, resized as necessary.
     * table.length MUST always be a power of two.
     */
    private Entry[] table;
```

+ ThreadLocalMap中的每个Entry都是一个对key的弱引用，对value的强引用
+ 正常情况下，线程终止，则保存在ThreadLocalMap里的value会被回收
+ 但是线程不终止（例如线程池），那么value就不会被回收：value->ThreadLocalMap->Entry(key为null)->value
+ JDK考虑过了，在set、remove、rehash方法中会扫描key为null的Entry，并把value设置为null，但如果一个线程中ThreadLocal不被调用，就不会执行上述操作
+ 阿里规约：在使用完ThreadLocal之后，主动调用remove方法：UserContextHolder.holder.remove();

# 存储共享对象问题

不应该共享静态对象

线程少时，不需要强行使用ThreadLocal

一般使用Spring框架即可，不需要自己创建

![image-20210203155018556](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203155018556.png)

# 代码

下述代码中,通过将JDBC的连接保存在`ThreadLocal`对象中,每个线程都会拥有属于自己的连接

当某个频繁执行的操作需要一个临时对象,例如一个缓冲区,而同时又希望避免在每次执行时都重新分配该临时对象,就可以使用该技术

当某个线程初次调用`ThreadLocal.get()`方法时,就会调用`initValue()`来获取初始值,概念上可以看作`ThreadLocal`包含了`Map<Thread,T>`对象,其中保存了特定于该线程的值

因为`ThreadLocal`在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。

假如需将一个单线程应用移植到多线程环境中,通过将共享的全局变量转换为`ThreadLocal`对象,即可维持线程安全性

```java
public static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {

    public Connection initValue() throws SQLException {

        return DriverManager.getConnection("DB_URL");

    }

};



public static Connection getConnection() {

    return connectionHolder.get();

}
```







