---
title: Java——Java多线程------Synchronized
date: 2021-1-3
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java多线程所做的笔记，Synchronized关键字的了解、锁升级等。
categories: 多线程
tags:
  - 多线程
  - Synchronized
  - 锁升级
abbrlink: 373af1d4
---



# synchronized

有进行线程唤醒和阻塞带来的性能开销，是阻塞同步

是悲观的并发策略，认为不去做同步措施，就肯定出问题，所以无论共享数据是否出现竞争，都会进行加锁

互斥同步：指多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用，互斥是实现同步的一个手段

## 基本含义

它包含两部分：一是作为锁的对象引用，二是由这个锁保护的代码块。

它保证无论是通过正常的控制路径退出，还是通过从代码块抛出异常退出，都会在退出同步代码块时自动释放锁

java的内置锁是互斥锁，最多只有一个线程持有该锁，所以由这个锁保护的同步代码块会以原子的方式执行。

在编译后，会在同步块前后形成monitorenter,monitorexit两条字节码指令

需要一个reference类型的参数来指明要锁定和解锁的对象

如果明确指定了对象参数，就以这个对象的引用作为reference

如果没有明确指定，则根据synchronized修饰的方法类型决定线程要持有的锁，作用于实例方法上,则锁住的是该类的实例对象。作用于静态方法上，则锁住的是类对象（Class对象）

## 理解

一个对象中如果有多个synchronized方法，则某一时刻内，只要一个线程调用了其中一个synchronized方法，其他线程就只能等待。也就是同一时刻内，只有唯一一个线程能访问这些synchronized方法，锁住的是当前对象this，其他线程都不能进入到当前对象的其他synchronized方法（同一个手机（对象）中的多个应用（方法），一次只能由一个人（线程）用手机）

在执行monitorenter时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有这个对象的锁，则把锁的计数器+1，执行monitorexit时将锁计数器-1。一旦计数器为0，则释放锁。如果获取对象锁失败，当前线程就应被阻塞等待，直到请求锁定的对象被持有他的线程释放为止

被synchronized修饰的同步块对同一条线程是可重入的

被synchronized关键字修饰的同步块在持有锁的线程释放锁之前，会无条件阻塞后面其他线程的进入。

# synchronized锁升级

## 流程

+ 正常状态-偏向锁-轻量级锁(无锁,自旋锁,自适应自旋)-重量级锁
+ 正常状态-偏向锁:即用54位的thread指向了当前线程的指针,下一个如果是那个线程则可以直接进去
+ 偏向锁-轻量级锁:如果另外一个线程访问了该锁,则升级,即首先把thread中指针记录清空,然后大家使用CAS操作把自己的线程信息写到ptr_to_lock_record上
+ 轻量级锁-重量级锁:默认自旋超过10次,或者等待的线程超过CPU核数的1/2,或者JVM自适应判断后升级

## 偏向锁

+ 消除数据在无竞争情况下的同步原语，连CAS操作也不做了
+ 这个锁会偏向于第一个获得他的线程，执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步
+ 当锁对象第一次被线程获取的时候，虚拟机会将对象头中的标志位设置为01,把偏向模式设置为1，表示进入偏向模式
+ 同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word中
+ 如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁的相关同步块时，JVM都可以不再进行任何同步操作
+ 一旦出现另一个线程去尝试获取这个锁，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定状态决定是否撤销偏向，撤销后恢复到未锁定或轻量级锁定状态
+ 可以提高带有同步但无竞争的程序性能，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式是多余的

### HashCode

+ 如果一个对象计算过HashCode，则应该保持该值不变
+ 而绝大多数对象哈希码的来源Object::hashCode()返回的是对象的一致性哈希码，能强制保持不变
+ 他通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取得的哈希码值永远不会再发生改变。
+ 因此，当一个对象已经计算过一致性哈希码后，他就再也无法进入偏向状态
+ 如果一个对象正处于偏向状态，又需要计算一致性哈希码，则会立刻撤销偏向状态，锁膨胀为重量级锁



## 自旋锁

+ 很多应用上，共享数据的锁定状态只会持续很短一段时间。可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环。
+ 虽然避免了线程切换的开销，但是占用处理器时间，如果占用时间长，会白白消耗处理器资源。所以自旋等待时间有一定限度
+ 如果自旋超过了限定次数仍然没有获得锁（默认10次），则挂起线程

### 轻量级锁

+ 在没有多线程竞争的前提下，尽量减少传统的重量级锁使用操作系统互斥量产生的性能消耗
+ 在代码即将进入同步块的时候，如果此对象没有被锁定（01），虚拟机将在当前线程的栈帧中建立一个名为锁记录（Lock Record)的空间，用于存储锁对象目前MarkWord的拷贝
+ 将使用CAS操作尝试把对象的MarkWord更新为指向LockRecord的指针。如果更新成功，则代表该线程拥有这个对象的锁
+ 并且Mark Word的锁标志位变为00,代表对象处于轻量级锁定状态
+ 如果更新操作失败，就意味着至少有一个线程与当前线程竞争获取该对象的锁
    + 检查此对象的Mark Word是否指向当前线程的栈帧，是则说明该线程已经拥有该对象的锁，直接进入同步块执行即可
    + 否则说明这个锁对象已经被其他线程抢占了
    + 如果CAS 替换失败则说明当前时间锁对象已被某个线程占有，那么此时当前线程只有通过自旋的方式去获取锁。如果在自旋一定次数后仍为获得锁，那么轻量级锁将会升级成重量级锁。
    + 如果出现两条以上的线程争用同一个锁，则膨胀为重量级锁，状态变为10，Mark Word存储指向重量级锁的指针，后面等待锁的线程必须进入阻塞状态
+ 解锁过程同样通过CAS操作，如果对象的Mark Word仍然指向线程的锁记录，就用CAS操作把对象当前Mark Word和复制的Displaced Mark Word替换回来。如果替换成功，则整个同步过程顺利完成。如果替换失败，则说明其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程
+ 对于绝大部分的锁，在整个同步周期内都是不存在竞争的。如果没有竞争，轻量级锁通过CAS操作成功避免了使用互斥量的开销。但如果确实有竞争，轻量级锁反而比重量级锁更慢

### 自适应自旋

+ 自旋的时间不是固定的，而是由前一个在同一个锁上的自旋时间以及锁的拥有者的状态来决定
+ 如果对同一个锁对象，自旋等待刚刚成功获取过锁，则运行等待更久（例如100次忙循环）
+ 如果自旋很水获得过锁，则可能直接忽略自旋
+ 随着程序运行时间的增长与性能监控信息的不断完善，虚拟机对程序锁的状况就会越来越精确



# 锁升级

## 过程

+ 正常状态-偏向锁-轻量级锁(无锁,自旋锁,自适应自旋)-重量级锁
+ 正常状态-偏向锁:即用54位的`thread`指向了当前线程的指针,下一个如果是那个线程则可以直接进去
+ 偏向锁-轻量级锁:如果另外一个线程访问了该锁,则升级,即首先把`thread`中指针记录清空,然后大家使用`CAS`操作把自己的线程信息写到`ptr_to_lock_record`上
+ 轻量级锁-重量级锁:默认自旋超过10次,或者等待的线程超过CPU核数的1/2,或者JVM自适应判断后升级

## 存储信息

+ 正常状态:`hashCode`,分代年龄4位,默认值为15,是否是偏向锁
+ `thread`指向了锁住的线程的指针

![20201019165828801](https://tongji4m3.oss-cn-beijing.aliyuncs.com/20201019165828801.jpg)



