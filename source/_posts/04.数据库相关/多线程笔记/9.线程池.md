---
title: Java——Java多线程------线程池
date: 2021-2-03
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java多线程所做的笔记，线程池相关知识、七大参数等。
categories: 多线程
tags:
  - 多线程
  - 线程池
  - Executor
abbrlink: 749e4d85
---



# 线程池理解

## Thread缺点

+ 线程生命周期的开销非常高，如果为每一个请求创建一个新线程将消耗大量的计算资源
+ 资源消耗：活跃的线程活消耗系统资源,尤其是内存、如果可运行的线程数量多于可用处理器的数量,有些线程会闲置、大量线程在竞争CPU资源时还将产生其他的性能开销
+ 稳定性：在可创建线程的数量上存在一个限制

## 问题和解决

反复创建线程开销大——>让这部分线程都保持工作，且可以反复执行任务，避免生命周期的损耗

过多的线程会占用太多内存——>用少量的线程避免内存占用过多

## 使用线程池好处

+ 重用现有的线程,可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销
+ 当请求到达时,工作线程已经存在,不会由于等待创建线程而延迟任务的执行
+ 通过适当调整线程池的大小,可以创建足够多的线程使处理器保存忙碌状态,又可以防止过多线程相互竞争资源使得应用程序耗尽内存

## 适用场合

+ 服务器接受大量请求时，使用线程池技术可以大大减少线程的创建和销毁次数，提高服务器的工作效率
+ 实际开发中，如果需要创建5个以上的线程，就可以利用线程池来管理

# 线程池继承关系

![image-20201202211516638](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201202211516638.png)



## 理解

+ 任务执行的主要抽象是Executor,并用Runnable表示任务
+ 基于生产者-消费者模式,提交任务相当于生产者,执行任务的线程相当于消费者
+ 只有当任务都是同类型而且相互独立时，线程池的性能才能达到最佳
+ JVM只有在所有非守护线程全部终止才会退出,如果无法正确关闭Executor,JVM就无法结束

## ExecutorService

## ThreadPoolExecutor

通过他的构造函数来实例化一个对象，并根据自己需求定制

允许提供一个BlockingQueue来保存等待执行的任务

# 基本使用

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) {
        //固定数量的线程
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
//        ExecutorService threadPool = Executors.newSingleThreadExecutor();
//        ExecutorService threadPool2 = Executors.newCachedThreadPool();
        
        //ScheduledExecutorService executorService = Executors.newScheduledThreadPool(10);
        //executorService.schedule(()->{System.out.println(Thread.currentThread().getName());}, 5, TimeUnit.SECONDS);

        //模拟十个用户办理业务
        try {
            for (int i = 0; i < 10; i++) {
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName()+" 办理业务");
                });
            }
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            threadPool.shutdown();
        }
    }
}
```

# 底层是ThreadPoolExecutor

![image-20210203091924755](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203091924755.png)

```java
//适用于长期执行的任务,性能好很多 阻塞队列可能很大，会OOM
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

```java
//适用于一个任务一个任务执行的场景 阻塞队列可能很大，会OOM
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

```java
//适用执行很多短期异步的小程序或负载较轻的服务器
//任务数量特别多时，就会创建很多的线程，会OOM
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

```java
//ScheduledExecutorService executorService = Executors.newScheduledThreadPool(10);
        //executorService.schedule(()->{System.out.println(Thread.currentThread().getName());}, 5, TimeUnit.SECONDS);
public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }
```



# 关闭线程池

## shutdown

将执行平缓的关闭过程，不再接受新的任务，同时等待已提交任务执行完成,包括那些还未开始执行的任务

## isShutdown

检验上面那个

## isTerminated

检验是否完全停止了

## shutdownNow

执行粗暴给关闭过程，立刻关闭！

对正在执行的线程执行中断interrupt

不再启动队列中尚未开始的任务，返回在等待中的队列列表

# 线程池七大参数

传入的是5参数,但是调用的是`this`的7大参数

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
```

```java

/*
int corePoolSize,  线程池中的常驻核心线程数,当线程池数量到达corePoolSize后,就会把到达的任务放到缓存队列当中
int maximumPoolSize, 线程池能够容纳同时执行的最大线程数,必须大于等于1(当corePoolSize满了,workQueue也满了,则会扩容)
long keepAliveTime,多余的空闲线程的存活时间,当前线程池数量超过corePoolSize时,当空闲时间到达keepAliveTime值时,会将线程销毁到corePoolSize数量
TimeUnit unit,设置时间单位
BlockingQueue<Runnable> workQueue,阻塞队列
ThreadFactory threadFactory,表示生成线程池中工作线程的线程工厂 一般默认即可
RejectedExecutionHandler handler 拒绝策略,当maximumPoolSize已经满了,则拒绝                             
*/
public ThreadPoolExecutor(int corePoolSize,  
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
            null :
            AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

# 原理

![image-20201203085215679](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20201203085215679.png)

+ 创建了线程池中,等待提交过来的任务请求
+ 当调用execute()方法添加一个请求任务时,线程池会做如下判断
	1. 如果正在运行的线程数量小于corePoolSize,那么马上创建线程运行这个任务
	2. 如果正在运行的线程数量大于等于corePoolSize,接着进来的任务到blockQueue去阻塞
	3. 当阻塞队列满了而正在运行的线程数量小于maximumPoolSize,则创建非核心线程立刻执行该任务
	4. 当大于maximumPoolSize,就开启拒绝策略
+ 当一个线程完成任务,它会从队列中取一个任务来执行
+ 当一个线程无事可做,而且超过keepAliveTime,而且当前运行线程数大于corePoolSize则该线程停止。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小

# 添加线程规则

+ 如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务

+ 如果线程数大于等于corePoolSize，但小于maximumPoolSize，则将任务放入阻塞队列

+ 如果阻塞队列已满，并且线程数小于maxPoolSize，则会创建一个新线程来运行任务

+ 如果队列已满，并且线程数大于等于maxPoolSize则拒绝该任务

    

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612312498_1.png)

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612312567_3.png)

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612312661_4.png)

# 线程池状态

![image-20210203100616797](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210203100616797.png)



# 执行任务四个生命周期

创建、提交、开始、完成

# 自定义线程池

不允许在应用中显示创建线程,都是得使用线程池

生产实践中不允许适用`Executors`去创建,因为他底层是`new LinkedBlockingQueue<Runnable>())`是无界队列,如果所有工作行程都处于忙碌状态，那么任务将在队列中等候，如果任务持续快速地到达，并且超过了线程池处理他们的速度，那么队列将无限制增加，可能会堆积大量请求,导致`OOM`



```java
import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        //因为任务数量超过了5+3,抛出异常java.util.concurrent.RejectedExecutionException
//        ExecutorService executorService = new ThreadPoolExecutor(2,5,1L, TimeUnit.SECONDS
//                ,new LinkedBlockingQueue<>(3), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());

        //main 办理业务  会将业务回退给调用者
        ExecutorService executorService = new ThreadPoolExecutor(2,5,1L, TimeUnit.SECONDS
                ,new LinkedBlockingQueue<>(3), Executors.defaultThreadFactory(),new ThreadPoolExecutor.CallerRunsPolicy());
        try
        {
            for (int i = 0; i < 10; i++) {
                executorService.execute(()->{
                    System.out.println(Thread.currentThread().getName()+" 办理业务");
                });
            }
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally {
            executorService.shutdown();
        }
    }
}
```

## 设置maximumPoolSize

首先分析计算环境、资源预算，例如部署的系统有多少CPU：

```
System.out.println(Runtime.getRuntime().availableProcessors());
```

系统有多大的内存：计算每个任务对内存的需求量，用总内存/需求量，就得到线程池上限

是否需像JDBC连接等稀缺资源：如果每个任务都需要一个数据库连接，那么连接池大小限制了线程池的大小

### CPU密集型

线程池大小应该为处理器个数+1，能实现最优的使用率

即使线程偶尔由于缺页故障等原因暂停时，额外的线程也能保证CPU的时钟周期不会被浪费

### IO密集型

并不是一直在执行任务,则应该配置尽可能多的线程,如CPU核数*2

线程不会一直执行，线程池规模应更大

必须估算任务的等待时间与计算时间的比值

线程池最优大小= CPU核数 * CPU利用率 * （1 + 任务等待时间/运行时间）