---
title: Java——Java多线程------生产者消费者
date: 2021-1-30
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Java多线程所做的笔记，生产者消费者模型等。
categories: 多线程
tags:
  - 多线程
  - 生产者消费者
  - synchronized
abbrlink: a5ad41d6
---



# 生产者消费者（等待唤醒三种机制）

## synchronized wait notify

**条件**

1. 必须在`synchronized`中
2. 必须先`wait `再`notify`

**虚假唤醒**

+ 等待唤醒机制，就是当一个线程在执行了某一个操作的时候，将其进入等待状态，并释放锁，其他线程执行完指定的操作后，再将其唤醒。
+ 当两个消费者线程同时执行sale方法时，产品售空，那么都将执行wait方法，处于挂起等待状态，并释放锁，然后生产者拿到锁，生产产品，执行notifyAll方法，唤醒了所有消费者线程，那么当第一个消费者执行了消费以后，第二个消费者又进行消费，此时便出现了负数，出现了问题。像这样的情况，就叫做虚假唤醒。

```java
package tongji.util.thread;

/*
用if时四个线程出现了虚假唤醒
    thread2    消费:-1
    thread2    消费:-2
所以使用while
 */

//资源类
class AirCondition {
    private int number = 0;

    public synchronized void increment() throws InterruptedException {
        //有资源时,则不能生产
//        if (number != 0) {
//            this.wait();
//        }
        //需要使用while
        //因为多个线程,有个线程进来阻塞后,之后唤醒的时候,因为是调用this.notifyAll(),所以所有的都唤醒了,而可能只是该increment()想要通知decrement()而已
        //wait是交出控制权的
        while (number != 0) {
            this.wait();
        }
        //生产并且唤醒消费线程
        number++;
        System.out.println(Thread.currentThread().getName() + "\t生产:" + number);
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        //没有资源时,不能消费
        while (number == 0) {
            this.wait();
        }
        //消费并且唤醒生产线程
        number--;
        System.out.println(Thread.currentThread().getName() + "\t消费:" + number);
        this.notifyAll();
    }
}

public class Main {
    public static void main(String[] args) {
        AirCondition airCondition = new AirCondition();
        //生产者
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    airCondition.increment();
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"thread1").start();

        //消费者
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    airCondition.decrement();
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"thread2").start();

        //生产者2
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    //多个线程自始至终使用的是同一个对象,所以synchronized可以锁住整个对象(不只是锁某个方法)
                    airCondition.increment();
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"thread3").start();

        //消费者2
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    airCondition.decrement();
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"thread4").start();
    }
}
```

## lock await signal

**条件**

1. 必须在`lock`中
2. 先`await`再`signal`

```java
package tongji.util.thread;


import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

//资源类
class AirCondition {
    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void increment() {
        lock.lock();
        try {
            while (number != 0) {
                condition.await();
            }
            number++;
            System.out.println(Thread.currentThread().getName() + "\t生产:" + number);
            condition.signalAll();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }

    public void decrement() {
        lock.lock();
        try {
            while (number == 0) {
                condition.await();
            }
            number--;
            System.out.println(Thread.currentThread().getName() + "\t消费:" + number);
            condition.signalAll();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        AirCondition airCondition = new AirCondition();
        //生产者
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                airCondition.increment();
            }
        }, "thread1").start();

        //消费者
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                airCondition.decrement();
            }
        }, "thread2").start();

        //生产者2
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                airCondition.increment();
            }
        }, "thread3").start();

        //消费者2
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                airCondition.decrement();
            }
        }, "thread4").start();
    }
}
```

### Condition精确唤醒

```java
import jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ShareResource {
    private int number = 1;
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();

    public void print5() {
        lock.lock();

        try
        {
            while (number != 1) {
                condition1.await();
            }

            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " print " + (i + 1));
            }
            //通知
            number = 2;
            condition2.signal();
        }
        catch (RuntimeException | InterruptedException e)
        {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }

    public void print10() {
        lock.lock();

        try
        {
            while (number != 2) {
                condition2.await();
            }

            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " print " + (i + 6));
            }
            //通知
            number = 3;
            condition3.signal();
        }
        catch (RuntimeException | InterruptedException e)
        {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }
    public void print15() {
        lock.lock();

        try
        {
            while (number != 3) {
                condition3.await();
            }

            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " print " + (i + 11));
            }
            //通知
            number = 1;
            condition1.signal();
        }
        catch (RuntimeException | InterruptedException e)
        {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }

}


public class Main {
    public static void main(String[] args) {
        ShareResource shareResource = new ShareResource();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                shareResource.print5();
            }
        },"t1").start();

        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                shareResource.print10();
            }
        },"t2").start();

        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                shareResource.print15();
            }
        },"t3").start();

    }
}
```

## LockSupport park unpark

LockSupport，构建同步组件的基础工具，帮AQS完成相应线程的阻塞或者唤醒的工作。

线程等待唤醒机制`wait/notify`的改良版本,对应的方法是`park/unpark`

**优点**

1. 不需要`synchronized`或`lock`
2. 先唤醒再等待也可以正常运行

**LockSupport详细了解**

+ 它是一个线程阻塞工具类,所有方法都是静态的,可以让线程在任意位置阻塞
+ 许可证类似于0/1的信号量
+ 它调用的是`Unsafe`里的`native`方法
+ 它和每个使用他的线程都有一个`permit`关联
+ 线程阻塞需要消耗`permit`,每个`permit`不可累计,最多一个

```java
package com.tongji;


import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;

public class Main {

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {

            try {
                TimeUnit.SECONDS.sleep(3);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + " 开始");
            LockSupport.park();//被阻塞,要通知需要许可证
            //每次阻塞都需要一个permit
            LockSupport.park();//被阻塞,要通知需要许可证
            //下面执行不了,因为阻塞两次
            System.out.println(Thread.currentThread().getName() + " 唤醒");
        }, "t1");
        thread1.start();

        new Thread(() -> {
            LockSupport.unpark(thread1);
            //permit不可累加
            LockSupport.unpark(thread1);
            //所以执行完permit还是1
            System.out.println(Thread.currentThread().getName() + " 通知");
        }, "t2").start();
    }
}
```

# 应用-生产者消费者

## 传统版

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ShareData{
    //资源类
    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void increment() throws Exception {
        lock.lock();
        try
        {
            //为了防止虚假唤醒,必须使用if
            while (number != 0) {
                //等待,不能生产
                condition.await();
            }
            number++;
            System.out.println(Thread.currentThread().getName()+" 生产");
            //通知唤醒 可以进行消费了
            condition.signalAll();
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }

    public void decrement() throws Exception {
        lock.lock();
        try
        {
            while (number == 0) {
                //等待,不能消费
                condition.await();
            }
            number--;
            System.out.println(Thread.currentThread().getName()+" 消费");
            //通知唤醒 可以进行生产了
            condition.signalAll();
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        ShareData shareData = new ShareData();
        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                try {
                    shareData.increment();
                }
                catch (Exception e) {
                    e.printStackTrace();
                }
            }
        },"t1").start();


        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                try {
                    shareData.decrement();
                }
                catch (Exception e) {
                    e.printStackTrace();
                }
            }
        },"t2").start();
    }
}
```

## 阻塞队列版

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

class MyResource{
    private volatile boolean FLAG= true; //默认开启,进行生产+消费
    private AtomicInteger atomicInteger = new AtomicInteger();

    BlockingQueue<String> blockingQueue;

    public MyResource(BlockingQueue<String> blockingQueue) {
        this.blockingQueue = blockingQueue;
        System.out.println(blockingQueue.getClass().getName());
    }

    public void myProd() throws Exception {
        String data = null;
        boolean retValue;
        while(FLAG){
            data = atomicInteger.incrementAndGet() + "";
            retValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);
            if (retValue) {
                System.out.println(blockingQueue.getClass().getName() + "插入队列 " + data + " 成功");
            }
            else {
                System.out.println(blockingQueue.getClass().getName()+"插入队列 "+data+" 失败");
            }
            TimeUnit.SECONDS.sleep(1);
        }
        System.out.println("生产动作结束");
    }

    public void myConsumer() throws Exception {
        String result = null;
        while (FLAG) {
            //不因为FLAG影响,因为等待2s
            result = blockingQueue.poll(2L, TimeUnit.SECONDS);
            if (result == null || result.equalsIgnoreCase("")) {
                FLAG = false;
                System.out.println(blockingQueue.getClass().getName()+"超过2s没用取到,消费队列失败");
                return;
            }
            else {
                System.out.println(blockingQueue.getClass().getName() + "消费队列 " + result + " 成功");
            }

        }
    }

    public void stop() {
        this.FLAG = false;
    }
}

public class Main {

    public static void main(String[] args) {
        MyResource myResource = new MyResource(new ArrayBlockingQueue<>(10));
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " 生产线程启动");
            try {
                myResource.myProd();
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }, "Prod").start();

        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " 消费线程启动");
            try {
                myResource.myConsumer();
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }, "Consumer").start();


        try {
            TimeUnit.SECONDS.sleep(5);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("5s后停止生产与消费---");
        myResource.stop();
    }
}
```

