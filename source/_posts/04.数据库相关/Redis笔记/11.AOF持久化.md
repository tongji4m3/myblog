---
title: 数据库——Redis相关笔记------AOF重写
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Redis所做的笔记，此为Redis的AOF持久化，包括AOF持久化过程、AOF重写等。
categories: Redis
tags:
  - Redis
  - AOF持久化
  - AOF重写
abbrlink: 561ee1df
date: 2020-11-30 00:00:00
---

# 简介

- AOF（Append Only File)
- 通过保存`Redis`服务器所执行的写命令来记录数据库状态的
- 被写入AOF文件的所有命令都是以Redis的命令请求协议格式（纯文本）保存的。
- 服务器启动时，可以通过载入和执行`AOF文件`中保存的命令来还原服务器关闭之前的数据库状态


# AOF持久化的实现

## 命令追加

服务器在执行完一个写命令后，会将被执行的写命令追加到服务器状态的`aof_buf`缓冲区的末尾:

```c
struct redisServer
{
	// AOF缓冲区
	sds aof_buf;
}
```

## AOF文件的写入与同步

服务器进程是一个事件循环，循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。时间事件负责执行像serverCron函数这样需要定时运行的函数

```python
def eventLoop()
{
	while True:
		#处理文件事件，接收命令请求以及发送命令回复
		#处理命令请求时可能会有新内容加入到aof_buf缓冲区中
		processFileEvents()
		
		#处理时间事件
		processTimeEvents()
		
		#考虑是否要将aof_buf缓冲区中的内容写入和保存到AOF文件里面
		flushAppendOnlyFile()
}
```

**写入**：在现代操作系统中，当数据写入到文件中时，会调用write函数。操作系统会将写入数据暂时保存在一个内存缓存区中，等到缓冲区空间满的时候，才真正将缓冲区中的数据写入到磁盘中。

**同步**：同时系统也提供了同步函数（例如fsync)，它可以强制让操作系统立即将缓冲区中的数据写入到磁盘中。



在每个事件循环都会调用flushAppendOnlyFile函数，flushAppendOnlyFile函数的行为由**appendfsync**的值决定：

**always**：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中，并同步AOF文件（把aof_buf数据写入并同步到AOF文件中）

**everysec**：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，并且每隔一秒就在子线程中对AOF文件进行一次同步(每隔一秒同步)。

**no**：服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中(先写入)，至于什么时候同步，由操作系统控制（不知道啥时候同步）。在该模式下的flushAppendOnlyFile的调用不需要同步执行。



上述配置的值，直接决定服务器的效率与安全性，当always时，安全性最高，但是效率最低；no时效率最高，安全性最低；everysec居中：从效率上来讲，everysec模式足够快，并且就算出现了故障停机，数据库也只丢失一秒钟的命令数据。系统默认配置是everysec。

# AOF文件的载入与数据还原

只要读入并重新执行一遍`AOF文件`里面保存的写命令，就可以还原服务器关闭之前的数据库状态

1. 创建一个不带网络连接的伪客户端
2. 从AOF文件中分析并读取出一条写命令
3. 使用伪客户端执行被读出的写命令
4. 一直执行2，3直到AOF文件中的所有写命令都被处理完毕

![image-20210207113554356](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207113554356.png)

# AOF重写

为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。

服务器创建一个新的AOF文件来**替代**现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但是新的AOF文件不会包含任何浪费空间的冗余命令

## AOF文件重写的实现

不需要对现有的AOF文件进行操作，是通过读取服务器当前的数据库状态来实现的

首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。

```python
def aof_rewrite(new_aof_file_name):
	#创建新的aof文件
	f=create_file(new_aof_file_name)
	#遍历数据库
	for db in redisServer.db:
		#忽略空数据库
		if db.is_empty():continue
		
		#写入SELECT命令，指定数据库号码
		f.write_command("SELECT"+db.id)
		
		#遍历数据库中所有键
		for key in db:
			#忽略过期的键
			if key.is_expired():continue
			
			#根据键的类型对键进行重写
			if key.type == String:
				rewrite_string(key)
			elif key.type == List:
				rewrite_list(key)
			elif key.type == Hash:
				rewrite_hash(key)
            elif key.type == Set:
				rewrite_set(key)
            elif key.type == SortedSet:
				rewrite_sortedSet(key)
				
			# 如果键带有过期时间，过期时间也要重写
			if key.have_expired_time():
				rewrite_expired_time(key)
	#写入完毕，关闭文件			
	f.close()
	
def rewrite_string(key):
	#使用GET命令获取字符串的值
	value=GET(key)
	#使用SET命令重写字符串键
	f.write_command(SET，key，value)
	
def rewrite_expired_time(key):
	#获取毫秒精度的键过期时间戳
	timestamp=get_expired_time_in_unixstamp(key)
	#使用PEXPIREAT命令重写键的过期时间
	f.write_command(PEXPIREAT，key，timestamp)
```



## AOF后台重写

因为aof_rewrite函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞

因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求。

所以决定将AOF重写程序放到**子进程**中执行

+ 子进程在进行AOF重写期间，服务器进程可以进行处理命令请求
+ 子进程带有服务器进程的**数据副本**，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性

但是有可能导致当前数据库状态和重写后的AOF文件所保存的数据库**状态不一致**



### AOF重写缓冲区

为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，会同时将这个命令发送给**AOF缓冲区和AOF重写缓冲区**

![image-20210207114138147](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207114138147.png)

在子进程执行AOF重写期间，服务器进程执行:

1. 执行客户端发来的指令
2. 将执行后的写命令追加到AOF缓冲区
3. 将执行后的写命令追加到AOF重写缓冲区



这样一来可以**保证**

- AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。
- 从创建子进程开始，服务器执行的所有写命都会被记录到AOF重写缓冲区里面。



当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：

- 将AOF重写缓冲区中的所有内容重写到新AOF文件中，这时新AOF文件保存的数据库状态将**和服务器当前的数据库状态一致**。
- 对新的AOF文件进行改名，原子地(atomic)覆盖现有地AOF文件，完成**新旧两个AOF文件地替换**。

这个信号处理函数执行完毕后，父进程可以继续像往常一样接收命令请求了



在整个AOF后台重写过程中，只有**信号处理函数执行时会对服务器进程（父进程）造成阻塞**，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。