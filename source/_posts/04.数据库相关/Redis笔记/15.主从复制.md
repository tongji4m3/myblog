---
title: 数据库——Redis相关笔记------Redis主从复制
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Redis所做的笔记，此为Redis主从复制，包括主从复制的过程、心跳检测等。
categories: Redis
tags:
  - Redis
  - 主从复制
  - 心跳检测
abbrlink: 24fe6464
date: 2020-12-01 00:00:00
---

# 简介

被复制的服务器称为主服务器,对主服务器进行复制的服务器称为从服务器

进行复制中的主从服务器双方的数据库将保存相同的数据

# 旧版复制功能的实现

- **同步操作**（sync）**：**用于将从服务器的数据库状态**更新至**主服务器当前所处的数据库状态
- **命令传播操作**（command propagate）**：**则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库**重新回到一致状态**

## 同步

- **概念：**当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，**将从服务器的数据库状态更新至主服务器当前所处的数据库状态**

- **SYNC命令：**

    从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：

    - ①从服务器向主服务器**发送SYNC命令**
    - ②收到SYNC命令的主服务器**执行BGSAVE命令，在后台生成一个RDB文件**，并使用一 个缓冲区记录从现在开始执行的所有写命令
    - ③当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的**RDB文件发送给从服务器**，从服务器**接收并载入**这个RDB文件，将自己的数据库状态更新至主服务器 执行BGSAVE命令时的数据库状态
    - ④主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写 命令，将自己的数据库状态更新至主服务器数据库当前所处的状态

- 下图展示了SYNC命令执行期间，主从服务器的通信过程：

![20191201105150863](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105150863.png)

## 命令传播

- 在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并**导致主从服务器状态不再一致**
- 为了让主从服务器再次回到一致状态，**主服务器需要对从服务器执行命令传播操作：**主 服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态
- 例如，主服务器执行了DEL k3的命令，那么主服务器将向从服务器发送相同的命令DEL k3，当从服务器执行完这个命令之后，主从服务器将再次回到一致状态，现在主从服务器两者的数据库都不再包含键k3了。

## 缺陷

旧版复制功能在处理断线重复制情况时低效

在Redis中，**从服务器对主服务器的复制可以分为以下两种情况：**

- **初次复制：**从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务 器和上一次复制的主服务器不同。
- **断线后重复制：**处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务 器通过自动重连接重新连上了主服务器，并继续复制主服务器

![20191201105727757](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105727757.png)

**为什么网络断开之后重新复制效率低，以上面的演示案例为例：**

- 主从服务器在时间T0至时间T10086中一直处于一致状态，这两个服务器保存的数据**大部分都是相同的**
- 从服务器想要将自己更新至主服务器当前所处的状态，**真正需要的是主从服务器连接中断期间**，主服务器新添加的k10087、k10088、k10089三个键的数据
- 可惜的是，旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键k1至键k10089的RDB文件，但实际上RDB文件包含的键k1至键k10086的数据对于从服务器来说都是不必要的

主从服务器断开的时 间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数 据，**却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的**

# 新版复制功能的实现

- 为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，**使用PSYNC命令代替SYNC命令**来执行复制时的同步操作
- **PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：**
    - **完整重同步：**用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步 骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓 冲区里面的写命令来进行同步
    - **部分重同步：**则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器 时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务 器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态
- PSYNC命令的部分重同步模式**解决了旧版复制功能在处理断线后重复制时出现的低效情况**

**执行部分重同步所需的资源比起执行SYNC命令所需的资源要少得多**，完成同步的速度也快得多。执行SYNC命令需要生成、传送和载入整个RDB文件，而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了

# 部分重同步的实现

**同步功能由以下三个部分构成：**

- 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量
- 主服务器的复制积压缓冲区（replication backlog）
- 服务器的运行ID（run ID）

## 复制偏移量

- 执行复制的双方——主服务器和从服务器会**分别维护一个复制偏移量：**

    - 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N
    - 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N

- 通过对比主从服务器的复制偏移量，

    **程序可以很容易地知道主从服务器是否处于一致状态：**

    - 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的
    - 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态

在下图所示的例子中，主从服务器的复制偏移量的值都为10086

![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121350757.png)

如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121359413.png)

## 复制积压缓冲区

- 复制积压缓冲区是由主服务器维护的一个**固定长度（fixed-size）先进先出（FIFO）队列**，默认大小为1MB
- 当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会**将写命令入队到复制积压缓冲区里面**，如下图所示：
- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121909779.png)
- 因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会**为队列中的每个字节记录相应的复制偏移量**
- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121943503.png)
- 当从服务器重新连上主服务器时，从服务器会通过PSYNC命令**将自己的复制偏移量offset发送给主服务器**，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操 作：
    - 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）**仍然存在于复制积压缓冲区里面**，那么主服务器将对从服务器执行部分重同步操作
    - 相反，如果offset偏移量之后的数据**已经不存在于复制积压缓冲区**，那么主服务器将对从服务器执行完整重同步操作

**演示案例：**

- 回到之前上面图片所展示的断线后重连接例子：
- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121522212.png)
- 当从服务器A断线之后，它立即重新连接主服务器，并**向主服务器发送PSYNC命令，报告自己的复制偏移量为10086**
- 主服务器收到从服务器发来的PSYNC命令以及偏移量10086之后，主服务器将**检查偏移量10086之后的数据是否存在于复制积压缓冲区里面**，结果发现**这些数据仍然存在**，于是主服务器向从服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行
- 接着主服务器会将复制积压缓冲区10086偏移量之后的**所有数据（偏移量为10087至 10119）都发送给从服务器**
- 从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态，如下图所示
- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201122209306.png)

## 服务器运行ID

- 除了复制偏移量和复制积压缓冲区之外，

    **实现部分重同步还需要用到服务器运行ID（run ID）：**

    - 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID
    - 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3

- 当从服务器对主服务器**进行初次复制时**，主服务器会**将自己的运行ID传送给从服务器**， 而从服务器则会将**这个运行ID保存起来**

- 当从服务器断线并重新连上一个主服务器时，**从服务器将向当前连接的主服务器发送之前保存的运行ID：**

    - 如果从服务器保存的运行ID和当前连接的主服务器的**运行ID相同**，那么说明从服务器 断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作
    - 相反地，如果从服务器保存的运行ID和当前连接的主服务器的**运行ID并不相同**，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作

- 举个例子，假设从服务器原本正在复制一个运行ID为 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3的主服务器，那么在网络断开，从服务器重新连 接上主服务器之后，从服务器将向主服务器发送这个运行ID，主服务器根据自己的运行ID是 否53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3来判断是执行部分重同步还是执行完整重同步

# PSYNC命令的实现

## PSYNC命令的调用方法有两种：

- 如果从服务器**以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令：**那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器**进行完整重同步**（因为这时不可能执行部分重同步）

- 如果从服务器**已经复制过某个主服务器**

    ，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC <runid> <offset>命令：

    - 其中runid是上一次复制的主服务器的运行 ID，而offset则是从服务器当前的复制偏移量
    - 接收到这个命令的主服务器会**通过这两个参数来判断应该对从服务器执行哪种同步操作**



## 接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：

- 如果**主服务器返回+FULLRESYNC  回复**，那么**表示主服务器将与从服务器执行完整重同步操作：**其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起 来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器 会将这个值作为自己的初始化偏移量
- 如果**主服务器返回+CONTINUE回复**，那么表示**主服务器将与从服务器执行部分重同步操作**，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了
- 如果**主服务器返回-ERR回复**，那么表示主服务器的版本低于Redis 2.8，**它识别不了PSYNC命令**，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作



## 流程图

- 下面的流程图总结了PSYNC命令执行完整重同步和部分重同步时可能遇上的情况：
- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201123546284.png)



## 演示案例

为了熟悉PSYNC命令的用法，让我们来看一个完整的复制——网络中断——重复制例 子

- 首先，假设有两个Redis服务器，它们的版本都是Redis 2.8，其中主服务器的地址为 127.0.0.1:6379，从服务器的地址为127.0.0.1:12345
- 如果客户端向从服务器发送命令SLAVEOF 127.0.0.1 6379，并且假设从服务器是第一次 执行复制操作，那么从服务器将向主服务器发送PSYNC ? -1命令，请求主服务器执行完整重 同步操作
- 主服务器在收到完整重同步请求之后，将在后台执行BGSAVE命令，并向从服务器返回 +FULLRESYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 10086回复，其中 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3是主服务器的运行ID，而10086则是主服务器当 前的复制偏移量
- 假设完整重同步成功执行，并且主从服务器在一段时间之后仍然保持一致，但是在复制 偏移量为20000的时候，主从服务器之间的网络连接中断了，这时从服务器将重新连接主服 务器，并再次对主服务器进行复制。
- 因为之前曾经对主服务器进行过复制，所以从服务器将向主服务器发送命令PSYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 20000，请求进行部分重同步
- 主服务器在接收到从服务器的PSYNC命令之后，首先对比从服务器传来的运行 ID53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3和主服务器自身的运行ID，结果显示该ID和 主服务器的运行ID相同，于是主服务器继续读取从服务器传来的偏移量20000，检查偏移量 为20000之后的数据是否存在于复制积压缓冲区里面，结果发现数据仍然存在
- 确认运行ID相同并且数据存在之后，主服务器将向从服务器返回+CONTINUE回复，表 示将与从服务器执行部分重同步操作，之后主服务器会将保存在复制积压缓冲区20000偏移 量之后的所有数据发送给从服务器，主从服务器将再次回到一致状态



# 复制的实现

## 步骤1:设置主服务器的地址和端口

当客户端向从服务器发送以下命令时:`SLAVEOF 127.0.0.1 6379`

从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379**保存到服务器状态的masterhost属性和masterport属性里面**

```c
struct redisServer
{
	char * masterhost;//主服务器的地址
	int masterport;//主服务器的端口号
};
```

**SLAVEOF命令是一个异步命令**，在完成masterhost属性和masterport属性的设置工作之 后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而**实际的复制工作将在OK返回之后才真正开始执行**

## 步骤2:建立套接字连接

- 在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，**创建连向主服务器的套接字连接**，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131155414.png)

- 如果**从服务器创建的套接字能成功连接（connect）到主服务器**，那么从服务器将为这个套接字关联一个专门**用于处理复制工作的文件事件处理器**，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类
- 而**主服务器在接受（accept）从服务器的套接字连接之后**，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器（server）和客户端（client）两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131243941.png)

- 因为复制工作接下来的几个步骤都会以从服务器向主服务器发送命令请求的形式来进 行，所以**理解“从服务器是主服务器的客户端”这一点非常重要**

## 步骤3:发送PING命令

- 从服务器成为主服务器的客户端之后，做的第一件事就是**向主服务器发送一个PING命令**，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131333757.png)

- **这个PING命令有两个作用：**
    - 虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信， 通过发送PING命令可以**检查套接字的读写状态是否正常**
    - 因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以**检查主服务器能否正常处理命令请求**
- **从服务器在发送PING命令之后将遇到以下三种情况的其中一种：**
    - 如果主服务器向从服务器返回了一个命令回复，但从服务器却**不能在规定的时限 （timeout）内读取出命令回复的内容**，那么表示主从服务器之间的网络连接状态不佳，不能 继续执行复制工作的后续步骤。当出现这种情况时，从服务器**断开并重新创建**连向主服务器 的套接字
    - 如果主服务器**向从服务器返回一个错误**，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，**从服务器断开并重新创建连向主服务器的套接字**。比如说，如果主服务器正在处理一个超时运行的脚本，那么当从 服务器向主服务器发送PING命令时，从服务器将收到主服务器返回的BUSY Redisis busy running a script.You can only call SCRIPT KILL or SHUTDOWN NOSAVE.错误
    - 如果从服务器**读取到"PONG"回复**，那么表示主从服务器之间的网络连接状态正常，并 且主服务器可以正常处理从服务器（客户端）发送的命令请求，在这种情况下，从服务器可 以继续执行复制工作的下个步骤
- 下面的流程图总结了从服务器在发送PING命令时可能遇到的情况，以及各个情况的处理方式

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131558981.png)

## 步骤4:身份验证

- 从服务器在收到主服务器返回的"PONG"回复之后，

    **下一步要做的就是决定是否进行身份验证：**

    - 如果从服务器设置了masterauth选项，那么进行身份验证
    - 如果从服务器没有设置masterauth选项，那么不进行身份验证

- 在需要进行身份验证的情况下，**从服务器将向主服务器发送一条AUTH命令**，命令的**参数为从服务器masterauth选项的值**

- 举个例子，如果从服务器masterauth选项的值为10086，那么从服务器将向主服务器发送 命令AUTH 10086，如下图所示

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131632595.png)

## 步骤5:发送端口信息

- 在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port ， **向主服务器发送从服务器的监听端口号**
- 例如在我们的例子中，从服务器的监听端口为12345，那么从服务器将**向主服务器发送命令REPLCONF listening-port 12345**，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113200247.png)

## 步骤6:同步

- 在这一步，从服务器将向主服务器发送PSYNC命令，***\*执行同步操作\****，并**将自己的数据库更新至主服务器数据库当前所处的状态**

- 值得一提的是，在同步操作执行之前，只有从服务器是主服务器的客户端，但是

    **在执行同步操作之后，主服务器也会成为从服务器的客户端：**

    - 如果PSYNC命令执行的是**完整重同步操作**，那么主服务器需要成为从服务器的客户 端，才能将保存在缓冲区里面的写命令发送给从服务器执行。
    - 如果PSYNC命令执行的是**部分重同步操作**，那么主服务器需要成为从服务器的客户 端，才能向从服务器发送保存在复制积压缓冲区里面的写命令

- 因此，在同步操作执行之后，**主从服务器双方都是对方的客户端**，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113224549.png)

- 正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命 令传播操作的基础

## 步骤7:命令传播

- 当完成了同步之后，**主从服务器就会进入命令传播阶段**，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就**可以保证主从服务器一直保持一致了**



# 心跳检测

- 在命令传播阶段，从服务器默认会**以每秒一次的频率**，向主服务器发送命令：

```bash
REPLCONF ACK <replication_offset>
//其中replication_offset是从服务器当前的复制偏移量
```

- **发送REPLCONF ACK命令对于主从服务器有三个作用：**
    - ①检测主从服务器的网络连接状态
    - ②辅助实现min-slaves选项
    - ③检测命令丢失

## 检测主从服务器的网络连接状态（lag标志）

- 主从服务器可以通过发送和接收REPLCONF ACK命令**来检查两者之间的网络连接是否正常：**如果主服务器**超过一秒钟没有收到**从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了
- 通过向主服务器发送**INFO replication命令**，在列出的**从服务器列表的lag一栏中**，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令**距离现在过了多少秒。**在一般情况下，**lag的值应该在0秒或者1秒之间跳动**，如果超过1秒的话，那么说明主从 服务器之间的连接出现了故障。

## 辅助实现min-slaves配置选项

- Redis的**min-slaves-to-write和min-slaves-max-lag两个选项**可以**防止主服务器在不安全的情况下执行写命令**
- 举个例子，如果我们向主服务器提供以下设置：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201132859439.png)

- 那么在**从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时**，主服务器将**拒绝执行写命令**，这里的延迟值就是上面提到的INFO replication命令的lag 值

## 检测命令丢失

如果因为网络故障，**主服务器传播给从服务器的写命令在半路丢失**，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将**发觉**从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里 面找到从服务器缺少的数据，并**将这些数据重新发送给从服务器**

## 演示案例

- 举个例子，假设有两个处于一致状态的主从服务器，它们的复制偏移量都是200，如下图所示

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133107682.png)

- 如果这时主服务器执行了命令SET key value（协议格式的长度为33字节），将自己的复 制偏移量更新到了233，并尝试向从服务器传播命令SET key value，但这条命令却因为网络 故障而在传播的途中丢失，那么主从服务器之间的复制偏移量就会出现不一致，主服务器的 复制偏移量会被更新为233，而从服务器的复制偏移量仍然为200，如下图所示

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133127229.png)

- 在这之后，当从服务器向主服务器发送REPLCONF ACK命令的时候，主服务器会察觉 从服务器的复制偏移量依然为200，而自己的复制偏移量为233，这说明复制积压缓冲区里面 复制偏移量为201至233的数据（也即是命令SET key value）在传播过程中丢失了，于是主服 务器会再次向从服务器传播命令SET key value，从服务器通过接收并执行这个命令可以将自 己更新至主服务器当前所处的状态，如下图所示

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133147307.png)