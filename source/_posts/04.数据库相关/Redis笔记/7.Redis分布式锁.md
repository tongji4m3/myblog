---
title: Redis分布式锁
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Redis所做的笔记，此为Redis分布式锁，包括分布式锁整个解决方案等。
categories: Redis
tags:
  - Redis
  - setnx
  - 分布式锁
abbrlink: cc4d73b2
date: 2020-11-25 00:00:00
---



# 分布式锁

## 背景

在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。

一个应用往往会部署在多台机器上（多节点），在某些场景中，多个进程必须以互斥的方式独占共享资源。因此需要使用分布式锁

## setnx（set if not exists)

```
SETNX key value
```

SET if Not eXists(如果不存在，则 SET)

命令在设置成功时返回 1 ，设置失败时返回 0 。

用来实现Redis锁机制，一个进程进来占坑，用完后再调用del指令释放坑

只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作。



**中间代码异常**

如果逻辑执行到中间出现异常，可能导致del指令没有被调用，就会陷入死锁，锁永远得不到释放

可以再拿到锁以后再给锁加上一个过期时间，比如5s，这样即使中间出现异常也可以保证5s后锁会自动释放

```redis
setnx tongji4m3 true

expire tongji4m3 5

del tongji4m3
```



**expire异常**

如果在setnx和expire之间服务器出现问题，导致expire得不到执行，也会死锁

根源在于setnx和expire不是一条原子指令，但又不能用事务解决，因为expire依赖与setnx的执行结果，如果setnx没抢到锁，expire是不应该执行的，而事务没有if-else分支逻辑

Redis支持set指令的扩展参数，使得setnx和expire指令可以一起执行，形成原子指令

```
SETEX key seconds value

SET key value [EX seconds] [PX milliseconds] [NX|XX]
set tongji4m3 true ex 5 nx
NX:只在键不存在时， 才对键进行设置操作。
XX:只在键已经存在时， 才对键进行设置操作。
```

将值 `value` 关联到 `key` ，并将 `key` 的生存时间设为 `seconds` (以秒为单位)。

如果 `key` 已经存在，`setex`命令将覆写旧值。

有小伙伴肯定会疑惑万一set value 成功 set time失败，那不就傻了么，这啊Redis官网想到了。

`setex`是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成。

单机加锁或synchronized就够了

但如果线程挂了,那锁就一直在那无法得到释放，后面的线程也永远得不到锁，又死锁了。

setex设置一个过期时间，就算线程1挂了，也会在失效时间到了，自动释放。



**超时问题**

如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，会导致第一个线程持有的锁过期了而临界区的逻辑还没执行完

Redis分布式锁不能用于较长时间的任务

将set指令的value参数设置为随机数，释放锁时先匹配随机数是否一致，然后再删除key，确保当前线程持有的锁不会被其他线程释放，除非这个锁是因为过期了而被服务器自己释放的

但是匹配value和删除key不是一个原子操作，需要要Lua脚本处理，他保证多个指令的原子性执行



**可重入性**

线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，就是可重入锁

分布式锁要支持可重入，则要使用线程的Threadlocal变量存储当前持有锁的计数

## redisson

redisson的锁，就实现了可重入

```java
ThreadPoolExecutor threadPoolExecutor =
        new ThreadPoolExecutor(inventory, inventory, 10L, SECONDS, linkedBlockingQueue);
long start = System.currentTimeMillis();
Config config = new Config();
config.useSingleServer().setAddress("redis://127.0.0.1:6379");
final RedissonClient client = Redisson.create(config);
final RLock lock = client.getLock("lock1");

for (int i = 0; i <= NUM; i++) {
    threadPoolExecutor.execute(new Runnable() {
        public void run() {
            lock.lock();
            inventory--;
            System.out.println(inventory);
            lock.unlock();
        }
    });
}
long end = System.currentTimeMillis();
System.out.println("执行线程数:" + NUM + "   总耗时:" + (end - start) + "  库存数为:" + inventory);
```


### 初始化

```java
public RLock getLock(String name) {
    return new RedissonLock(connectionManager.getCommandExecutor(), name);
}

public RedissonLock(CommandAsyncExecutor commandExecutor, String name) {
    super(commandExecutor, name);
    //命令执行器
    this.commandExecutor = commandExecutor;
    //UUID字符串
    this.id = commandExecutor.getConnectionManager().getId();
    //内部锁过期时间
    this.internalLockLeaseTime = commandExecutor.
                getConnectionManager().getCfg().getLockWatchdogTimeout();
    this.entryName = id + ":" + name;
```

### 加锁

```java
public void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException {
    
    //当前线程ID
    long threadId = Thread.currentThread().getId();
    //尝试获取锁
    Long ttl = tryAcquire(leaseTime, unit, threadId);
    // 如果ttl为空，则证明获取锁成功
    if (ttl == null) {
        return;
    }
    //如果获取锁失败，则订阅到对应这个锁的channel
    RFuture<RedissonLockEntry> future = subscribe(threadId);
    commandExecutor.syncSubscription(future);

    try {
        while (true) {
            //再次尝试获取锁
            ttl = tryAcquire(leaseTime, unit, threadId);
            //ttl为空，说明成功获取锁，返回
            if (ttl == null) {
                break;
            }
            //ttl大于0 则等待ttl时间后继续尝试获取
            if (ttl >= 0) {
                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
            } else {
                getEntry(threadId).getLatch().acquire();
            }
        }
    } finally {
        //取消对channel的订阅
        unsubscribe(future, threadId);
    }
    //get(lockAsync(leaseTime, unit));
}
```

### 获取锁

```java
private <T> RFuture<Long> tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) {

    //如果带有过期时间，则按照普通方式获取锁
    if (leaseTime != -1) {
        return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);
    }
    
    //先按照30秒的过期时间来执行获取锁的方法
    RFuture<Long> ttlRemainingFuture = tryLockInnerAsync(
        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),
        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);
        
    //如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间
    ttlRemainingFuture.addListener(new FutureListener<Long>() {
        @Override
        public void operationComplete(Future<Long> future) throws Exception {
            if (!future.isSuccess()) {
                return;
            }

            Long ttlRemaining = future.getNow();
            // lock acquired
            if (ttlRemaining == null) {
                scheduleExpirationRenewal(threadId);
            }
        }
    });
    return ttlRemainingFuture;
}
```

### 底层加锁逻辑

你可能会想这么多操作，在一起不是原子性不还是有问题么？

大佬们肯定想得到呀，所以还是LUA，他使用了Hash的数据结构。

主要是判断锁是否存在，存在就设置过期时间，如果锁已经存在了，那对比一下线程，线程是一个那就证明可以重入，锁在了，但是不是当前线程，证明别人还没释放，那就把剩余时间返回，加锁失败。

```java
<T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit,     
                            long threadId, RedisStrictCommand<T> command) {

        //过期时间
        internalLockLeaseTime = unit.toMillis(leaseTime);

        return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,
                  //如果锁不存在，则通过hset设置它的值，并设置过期时间
                  "if (redis.call('exists', KEYS[1]) == 0) then " +
                      "redis.call('hset', KEYS[1], ARGV[2], 1); " +
                      "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                      "return nil; " +
                  "end; " +
                  //如果锁已存在，并且锁的是当前线程，则通过hincrby给数值递增1
                  "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
                      "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
                      "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                      "return nil; " +
                  "end; " +
                  //如果锁已存在，但并非本线程，则返回过期时间ttl
                  "return redis.call('pttl', KEYS[1]);",
        Collections.<Object>singletonList(getName()), 
                internalLockLeaseTime, getLockName(threadId));
    }
```



### 解锁

锁的释放主要是publish释放锁的信息，然后做校验，一样会判断是否当前线程，成功就释放锁，还有个**hincrby**递减的操作，锁的值大于0说明是可重入锁，那就刷新过期时间。

如果值小于0了，那删掉Key释放锁。

是不是又和AQS很像了？

AQS就是通过一个volatile修饰status去看锁的状态，也会看数值判断是否是可重入的。



```java
public RFuture<Void> unlockAsync(final long threadId) {
    final RPromise<Void> result = new RedissonPromise<Void>();
    
    //解锁方法
    RFuture<Boolean> future = unlockInnerAsync(threadId);

    future.addListener(new FutureListener<Boolean>() {
        @Override
        public void operationComplete(Future<Boolean> future) throws Exception {
            if (!future.isSuccess()) {
                cancelExpirationRenewal(threadId);
                result.tryFailure(future.cause());
                return;
            }
            //获取返回值
            Boolean opStatus = future.getNow();
            //如果返回空，则证明解锁的线程和当前锁不是同一个线程，抛出异常
            if (opStatus == null) {
                IllegalMonitorStateException cause = 
                    new IllegalMonitorStateException("
                        attempt to unlock lock, not locked by current thread by node id: "
                        + id + " thread-id: " + threadId);
                result.tryFailure(cause);
                return;
            }
            //解锁成功，取消刷新过期时间的那个定时任务
            if (opStatus) {
                cancelExpirationRenewal(null);
            }
            result.trySuccess(null);
        }
    });

    return result;
}


protected RFuture<Boolean> unlockInnerAsync(long threadId) {
    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, EVAL,
    
            //如果锁已经不存在， 发布锁释放的消息
            "if (redis.call('exists', KEYS[1]) == 0) then " +
                "redis.call('publish', KEYS[2], ARGV[1]); " +
                "return 1; " +
            "end;" +
            //如果释放锁的线程和已存在锁的线程不是同一个线程，返回null
            "if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then " +
                "return nil;" +
            "end; " +
            //通过hincrby递减1的方式，释放一次锁
            //若剩余次数大于0 ，则刷新过期时间
            "local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); " +
            "if (counter > 0) then " +
                "redis.call('pexpire', KEYS[1], ARGV[2]); " +
                "return 0; " +
            //否则证明锁已经释放，删除key并发布锁释放的消息
            "else " +
                "redis.call('del', KEYS[1]); " +
                "redis.call('publish', KEYS[2], ARGV[1]); " +
                "return 1; "+
            "end; " +
            "return nil;",
    Arrays.<Object>asList(getName(), getChannelName()), 
        LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));

}
```







# 分布式事务

要在分布式系统中实现事务，它其实是由多个本地事务组合⽽成。

## 2PC

(Two-phase commit protocol),⼆阶段提交,是⼀种强⼀致性设计

2PC 引 ⼊⼀个事务协调者的⻆⾊来协调管理各参与者（也可称之为各本地资源）的提交和回滚，⼆阶段分别指 的是准备（投票）和提交两个阶段。



准备阶段协调者会给各参与者发送准备命令，你可以把准备命令理解成除了提交事务之外啥事都做完 了。

同步等待所有资源的响应之后就进⼊第⼆阶段即提交阶段（注意提交阶段不⼀定是提交事务，也可能是 回滚事务）。

假如在第⼀阶段所有参与者都返回准备成功，那么协调者则向所有参与者发送提交事务命令，然后等待 所有事务都提交成功之后，返回事务执⾏成功。



假如在第⼀阶段有⼀个参与者返回失败，那么协调者就会向所有参与者发送回滚事务的请求，即分布式 事务执⾏失败。

，那第⼆阶段提交失败,是不断重试，直到所有参与者都回滚/提交成功了，因为有可能⼀些参与者的事务已经 提交成功,



 2PC 是⼀个同步阻塞协议，像第⼀阶段协调者会等待所有参与者响应才会进⾏下⼀步操作，当然 第⼀阶段的协调者有超时机制，假设因为⽹络原因没有收到某参与者的响应或某参与者挂了，那么超时 后就会判断事务失败，向所有参与者发送回滚命令。

在第⼆阶段协调者的没法超时，因为按照我们上⾯分析只能不断重试！

### 总结

2PC 是⼀种尽量保证强⼀致性的分布式事务，因此它是同步阻塞的，⽽同步阻塞就导致⻓久的资源锁定 问题，总体⽽⾔效率低，并且存在单点故障问题，在极端条件下存在数据不⼀致的⻛险。

2PC 适⽤于数据库层⾯的分布式事务场景，⽽我们业务需求有时候不仅 仅关乎数据库，也有可能是上传⼀张图⽚或者发送⼀条短信。

## 3PC

3PC 的出现是为了解决 2PC 的⼀些问题，相⽐于 2PC 它在参与者中也引⼊了超时机制，并且新增了⼀ 个阶段使得参与者可以利⽤这⼀个阶段统⼀各⾃的状态。

3PC 包含了三个阶段，分别是准备阶段、预提交阶段和提交阶段，对应的英⽂就是： CanCommit、 PreCommit 和 DoCommit 。

是把 2PC 的提交阶段变成了预提交阶段和提交阶段

## TCC

2PC 和 3PC 都是数据库层⾯的，⽽ TCC 是业务层⾯的分布式事务

Try - Confirm - Cancel 。

Try 指的是预留，即资源的预留和锁定，注意是预留。 

Confirm 指的是确认操作，这⼀步其实就是真正的执⾏了。 

Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。



先试探性的执⾏，如果都可以那就真正的执⾏，如果不⾏就回 滚。

⽐如说⼀个事务要执⾏A、B、C三个操作，那么先对三个操作执⾏预留动作。如果都预留成功了那么就 执⾏确认操作，如果有⼀个预留失败那就都执⾏撤销动作。

TCC 对业务的侵⼊较⼤和业务紧耦合，需要根据特定的场景和业务逻辑来设计相应的操作