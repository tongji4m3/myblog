---
title: Redis数据库
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Redis所做的笔记，此为Redis数据库的设计，包括过期键的删除策略等。
categories: Redis
tags:
  - Redis
  - 删除过期键
  - 数据库
abbrlink: eb52a7b2
date: 2020-11-27 00:00:00
---

# 服务器中的数据库

```c
struct redisServer
{
	int dbnum;//服务器的数据库数量
	redisDb *db; //一个数组，保存着服务器中的所有数据库 默认16
}
```

# 切换数据库

每个Redis客户端都有个目标数据库，每当客户端执行数据库读写命令时，目标数据库就成为这些命令的操作对象.默认目标数据库为0号数据库

```c
typedef struct redisClient
{
	redisDb * db;//记录客户端当前使用的数据库
}redisClient;
```

# 数据库键空间

```c
typedef struct redisDb
{
	dict *dict;//数据库键空间，保存着数据库中的所有键值对
} redisDb;
```

键空间的键是一个字符串对象，值可以是字符串对象，列表对象，哈希表对象，集合对象，有序集合对象

所有针对数据库的操作，都是通过对键空间字典进行操作实现的

## 添加新键

就是将新键值对添加到键空间字典里面

## 读写键空间时的维护操作

+ 在读取一个键后(读写操作都要对键进行读取)，服务器会根据键是否存在来更新服务器的键空间命中次数
+ 在读取一个键后，会更新LRU时间，可以计算键的闲置时间
+ 在读取一个键若发现该键已过期，则会先删除过期键
+ 在对被监视的键进行修改后，会标记为脏，让事务程序注意该键已经被修改

# 设置键的生存时间或过期时间

## 设置过期时间

1. EXPIRE 设置过期时间，单位为秒
2. PEXPIRE 设置过期时间，单位为毫秒
3. EXPIREAT 设置过期时间为秒数时间戳
4. PEXPIREAT 设置过期时间为毫秒数时间戳

最后都是转换为PEXPIREAT来执行的

## 保存过期时间

```c
typedef struct redisDb
{
	dict *dict;//数据库键空间，保存着数据库中的所有键值对
	dict *expires;//保存了数据库中所有键的过期时间，过期字典
	//key是一个指针，指向键空间某个键
	//value为long long类型的过期时间，一个毫秒精度的UNIX时间戳
} redisDb;
```

键空间的键和过期字典的键都指向同一个键对象，不会出现任何重复对象，也不会浪费任何空间

```python
def PEXPIREAT(key，expire_time_in_ms)
{
 	#如果给定的键不存在键空间，那么不能设置过期时间
    if key not in redisDb.dict:
    	return 0
    #在过期字典中关联键和过期时间
    redisDb.expires[key] = expire_time_in_ms
    # 过期时间设置成功
    return 1
}
```

## 移除过期时间

```python
def PERSIST(key):
    #如果给定的键不存在或没设置过期时间，那么直接返回
     if key not in redisDb.expires:
    	return 0
    #移除过期字典中给定键的键值对关联
    redisDb.expires.remove(key)
    #移除成功
    return 1
```

## 计算并返回剩余生存时间

```python
def PTTL(key):
    #如果给定的键不存在数据库
    if key not in redisDb.dict:
    	return -2
    #尝试获取过期时间
    #没有则为None
    expire_time_in_ms=redisDb.expires.get(key)
    
    if expire_time_in_ms is None:
        return -1
    # 获取当前时间时间戳
    now_ms=get_current_unix_timestamp_in_ms()
    return (expire_time_in_ms - now_ms)
```

```python
def TTL(key):
    ttl_in_ms = PTTL(key)
    if ttl_in_ms<0:
        //处理为-2，-1的异常情况
        return ttl_in_ms
    else:
        #将毫秒转为秒
        return ms_to_sec(ttl_in_ms)
    
```

## 过期键的判断

```python
def is_expired(key):
    #尝试获取过期时间
    #没有则为None
    expire_time_in_ms=redisDb.expires.get(key)
    
    if expire_time_in_ms is None:
        return False
    
    # 获取当前时间时间戳
    now_ms=get_current_unix_timestamp_in_ms()
    
    if  now_ms>expire_time_in_ms:
        return True # 已过期
    else:
        return False
```



# 过期键删除策略

## 定时删除

- 在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作

- 可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存

- 对CPU时间最不友好，在内存不紧张而CPU非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，对服务器的响应时间和吞吐量造成影响

- 不太现实


## 惰性删除

- 每次取出键都会检查是否过期，过期则删除

- 只有在取出键时才会对键进行过期检查，对CPU时间最友好

- 对内存最不友好：如果一个键已过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。

- 会导致内存泄漏，无用的垃圾数据占用了大量内存。如日志，当不再使用时，会大量积压在数据库，用户以为自动删除了，其实还存在，则它们不会被删除，所占用的内存就不会释放。


## 定期删除

- 每隔一段时间进行检查，删除里面的过期键
- 通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响；定期删除策略有效减少了因为过期键而带来的内存浪费。是前两种的整合与折中。
- 必须合理地设置删除操作的执行时间和执行效率：太频繁或执行时间太长会退化为定时删除策略，反之则出现浪费内存的情况


# Redis过期键删除策略

配合使用**惰性删除**和**定期删除**两种

## 惰性删除策略的实现

所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查，如果输入键已过期，则将输入键从数据库中删除

采用expireIfNeeded函数，如果过期则将键删除。就像过滤器，在命令真正执行前，过滤掉过期的输入键，避免命令接触到过期键

所以每个命令的实现函数必须能同时处理键存在和不存在两种情况

![image-20210207104150550](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104150550.png)

![image-20210207104206293](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207104206293.png)

## 定期删除策略实现

每当Redis服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键

```python
# coding=utf-8
# 默认每次检查的数据库数量
DEFAULT_DB_NUMBERS = 16

# 默认每个数据库检查的键数量
DEFAULT_KEY_NUMBERS = 20

# 全局变量，记录检查进度
# 如果当前的activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数时，将从11号数据库开始查找并删除过期键
current_db = 0

# 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键
def activeExpireCycle():
    # 初始化要检查的数据库数量
    # 以服务器的数据库数量为主
    if serer.dbnum < DEFAULT_DB_NUMBERS:
        db_numbers = serer.dbnum
    else:
        db_numbers = DEFAULT_DB_NUMBERS

    #遍历每个数据库
    for i in range(db_numbers):
        #如果current_db=服务器的数据库数量
        #则表示已经遍历了服务器的所有数据库一次
        #将current_db=重置为0，开始新一轮
        if current_db==server.dbnum:
            current_db=0
        
        #获取当前要处理的数据库
        redisDb=server.db[current_db]
        
        #指向下一个要处理的数据库
        current_db+=1
        
        #检查数据库的键
        for j in range(DEFAULT_KEY_NUMBERS):
            #如果数据库中没有一个键带有过期时间，则跳过该数据库
            if redisDb.expires.size()==0:
                break
            
            #随机获取一个带过期时间的键
            key_with_ttl=redisDb.expires.get_random_key()
            
            if is_expired(key_with_ttl):
                delete_key(key_with_ttl)
                
            # 已到达时间上限，停止处理
            if reach_time_limit():
                return 
```

# AOF、RDB和复制功能对过期键的处理

## 生成RDB文件

在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中

因此，数据库中包含过期键不会对生成新的RDB文件造成影响

## 载入RDB文件

在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：

- 如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响；
- 如果服务器以从服务器模式运行，那么在载入RDB文件时，**文件中保存的所有键，不论是否过期，都会被载入到数据库中**。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响

## AOF文件写入

当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。

**当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。**
举个例子，如果客户端使用GET message命令，试图访问过期的message键，那么服务器将执行以下三个动作：
1）从数据库中删除message键。
2）追加一条DEL message命令到AOF文件。（根据AOF文件增加的特点，AOF只有在客户端进行请求的时候才会有这个DEL操作）
3）向执行GET命令的客户端返回空回复。

##  AOF重写

和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。

举个例子，如果数据库中包含三个键k1、k2、k3，并且k2已经过期，那么在进行重写工作时，程序只会对k1和k3进行重写，而k2则会被忽略。

## 复制

当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：

- 主服务器在删除一个过期键之后，**会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键**；
- **从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除**，而是继续像处理未过期的键一样来处理过期键；
- **从服务器只有在接到主服务器发来的DEL命令之后**，才会删除过期键。

举个例子，有一对主从服务器，它们的数据库中都保存着同样的三个键message、xxx和yyy，其中message为过期键，如图所示

![image-20210207105328925](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207105328925.png)

如果这时有客户端向从服务器发送命令GET message，那么从服务器将发现message键已经过期，但从服务器并不会删除message键，而是继续将message键的值返回给客户端，就好像message键并没有过期一样。

假设在此之后，有客户端向主服务器发送命令GET message，那么主服务器将发现键message已经过期：主服务器会删除message键，向客户端返回空回复，并向从服务器发送DEL message命令，如图所示：

![image-20210207105343364](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207105343364.png)

从服务器在接收到主服务器发来的DEL message命令之后，也会从数据库中删除message键，在这之后，主从服务器都不再保存过期键message了，如图所示：

![image-20210207105359103](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210207105359103.png)