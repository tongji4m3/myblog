---
title: Redis应用场景
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Redis所做的笔记，此为Redis应用场景，包括key同时过期、使用scan等等。
categories: Redis
tags:
  - Redis
  - Redis应用
  - scan
abbrlink: b695f16b
date: 2020-11-23 00:00:00
---



# 大量的key需要设置同一时间过期

如果⼤量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，我们⼀般需要在时间上加⼀个随机值，使得过期时间分散⼀些。

电商⾸⻚经常会使⽤定时任务刷新缓存，可能⼤量的数据失效时间都⼗分集中，如果失效时间⼀样，⼜刚好在失效的时间点⼤量⽤户涌⼊，就有可能造成缓存雪崩

集中过期，由于清除大量的key很耗时，会出现暂时的卡顿现象

解决方案：在设置key的过期时间时，给每个key加上随即值





# scan

## 背景：海量数据筛选固定前缀的key

使⽤keys指令可以扫出指定模式的key列表。

缺点：

没有limit参数，会一次性吐出所有满足条件的key

复杂度O(N)，而且Redis是单线程，顺序执行所有指令，如果实例中有千万条指令会导致Redis服务卡顿

## 理解

+ 复杂度也是O(N)，但通过游标分步进行，不会阻塞线程
+ 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
+ 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历
+ 不保证每次执行都返回某个给定数量的元素，支持模糊查询
+ 一次返回的count的数量不可控，只能是大概率符合count参数

## 特点

+ 不会阻塞线程
+ 提供count参数，但是count不是限定返回结果的数量，而是限定服务器单次遍历的字典槽位数量。
+ 提供模式匹配功能
+ 服务器不需要为游标保存状态，游标唯一状态是scan返回给客户端的游标整数
+ 返回结果有重复，需要客户端去重
+ 改动后的数据不确定能否遍历到
+ 返回的游标为0才代表遍历结束

## 命令

+ scan 0 match key99* count 1000
+ 第一个参数是cursor整数值
+ 第二个是key的正则模式
+ 第三个是限制数量，限定的只是单次遍历的字典槽位数量，不是返回的结果数量 
+ 第一次遍历时，cursor为0，然后可以将返回结果中的第一个整数作为下一个遍历的cursor，一直遍历到返回的cursor值为0

## 原理

+ 遍历的是hash的槽位，count表示需要遍历的槽位数。因为不是所有的槽位都会挂接链表，有些槽位也可能是空的，有些槽位可能挂接链表的元素有多个，所以返回结果数量不定
+ 遍历顺序
    + 高位进位加法，从左边开始加，进位往右边移动，采用此方法，rehash后槽位在遍历顺序上是相邻的
    + 避免字典扩容、缩容时遍历重复和遗漏

## 应用

+ 如果在Redis中形成了很大的对象（例如hash），会对集群数据的迁移带来卡顿，扩容空间、回收内存都可能卡顿，所以在平时业务开发，要尽量避免大key的产生。
+ 如果Redis内存变化大，则很可能是由于大Key引起的，需要定位大key。而为了避免给线上Redis卡顿，使用scan命令
+ 过程
    + 对于扫描出来的key，使用type获取类型
    + 针对每种数据结构，使用对应的size或len获取大小
    + 将大小排名的前若干名作为扫描结果展示
    + redis-cli -h 127.0.0.1 -p 7001 --bigkeys -i 0.1 每隔100条scan指令就休眠0.1s，不会大幅抬升Redis的ops