---
title: 数据库——Redis相关笔记------Sentinel
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习Redis所做的笔记，此为Sentinel相关，包括检测下线状态、故障转移等。
categories: Redis
tags:
  - Redis
  - Sentinel
  - 数据库
abbrlink: d32d732b
date: 2020-12-03 00:00:00
---

# Sentinel简介

Sentinel（哨岗、哨兵）是**Redis的高可用性（high availability）解决方案：**由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以**监视任意多个**主服务器，以及这些主服务器属下的所有从服务器，并在被监视的**主服务器进入下线状态时**，自动将下线主服务器属下的某个从服务器**升级为新的主服务器**，然后由新的主服务器代替已下线的主服务器继续处理命令请求



![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201213815316.png)



- 根据上面的图片，假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对 主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如下图所示（下线的服务器用虚线表示）

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214010487.png)

- 当server1的**下线时长超过用户设定的下线时长上限时**，Sentinel系统就会对server1执行**故障转移**

    操作：

    - 首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务 器升级为新的主服务器
    - 之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新 的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完 毕
    - 另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主 服务器的从服务器

- 举个例子，下图展示了Sentinel系统**将server2升级为新的主服务器**，并让服务器server3和server4成为server2的从服务器的过程

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214149843.png)

- 之后，如果server1**重新上线的话**，它将被Sentinel系统**降级为server2的从服务器**，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214154597.png)

# 启动并初始化Sentinel

启动`Sentinel`会执行以下操作：

1. 初始化服务器
2. 将普通Redis服务器使用的代码替换成`Sentinel`专用代码
3. 初始化`Sentinel`状态
4. 根据给定的配置文件,初始化`Sentinel`的监视主服务器列表
5. 创建连向主服务器的网络连接

## 初始化Sentinel状态

在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个**sentinel.c/sentinelState结构**（后面简称“Sentinel状态”），这个结构**保存了服务器中所有和Sentinel功能有关的状态** （服务器的一般状态仍然由redis.h/redisServer结构保存）

```c
struct sentinelState {
    //当前纪元，用于实现故障转移
    uint64_t current_epoch;
 
    //保存了所有被这个sentinel 监视的主服务器
    dict *masters;
    
    //略
} sentinel;
```


## 初始化Sentinel状态的masters属性

Sentinel状态中的**masters字典记录了所有被Sentinel监视的主服务器的相关信息**，其中：

- **字典的键**是被监视主服务器的名字
- **字典的值**则是被监视主服务器对应的sentinel.c/**sentinelRedisInstance结构**



- 每个sentinelRedisInstance结构（后面简称“实例结构”）**代表一个被Sentinel监视的Redis服务器实例**（instance），这个实例可以是**主服务器、从服务器，或者另外一个Sentinel**

```c
typedef struct sentinelRedisInstance {
    //标识值，记录了实例的类型，以及该实例的当前状态
    int flags;
 
    //实例的名字
    //主服务器的名字由用户在配置文件中设置
    //从服务器以及Sentinel 的名字由Sentinel 自动设置
    //格式为ip:port ，例如"127.0.0.1:26379"
    char *name;
 
    //实例的运行ID
    char *runid;
 
    //配置纪元，用于实现故障转移
    uint64_t config_epoch;
 
    //实例的地址
    sentinelAddr *addr;
} sentinelRedisInstance;
```

```c
struct sentinelAddr
{
	char * ip;
	int port;
}
```

### 例子

- 对Sentinel状态的初始化将引发对masters字典的初始化，而masters字典的初始化是**根据被载入的Sentinel配置文件**来进行的

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201220900699.png)

## 创建连向主服务器的网络连接

- 初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，**Sentinel将成为主服务器的客户端**，它可以向主服务器发送命令，并从命令回复中获取相关的信息

- 对于每个被Sentinel监视的主服务器来说，Sentinel会

    **创建两个连向主服务器的异步网络连接：**

    - 一个是**命令连接**，这个连接专门用于向主服务器发送命令，并接收命令回复
    - 另一个是**订阅连接**，这个连接专门用于订阅主服务器的__sentinel__:hello频道



# 获取主服务器的信息

- Sentinel默认会以**每十秒一次的频率**，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来**获取主服务器的当前信息**

- 通过分析主服务器返回的INFO命令回复，**Sentinel可以获取以下两方面的信息：**
    - 一方面是**关于主服务器本身的信息**，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色
    - 另一方面是关于主服务器属下**所有从服务器的信息**，每个从服务器都由一个"slave"字符 串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端 口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器
- **根据run_id域和role域记录的信息，Sentinel将对主服务器的实例结构进行更新**，例如， 主服务器重启之后，它的运行ID就会和实例结构之前保存的运行ID不同，Sentinel检测到这 一情况之后，就会对实例结构的运行ID进行更新
- Sentinel在分析INFO命令中包含的从服务器信息时，**会检查从服务器对应的实例结构是否已经存在于slaves字典：**
    - 如果**从服务器对应的实例结构已经存在**，那么Sentinel对从服务器的实例结构进行更新
    - 如果**从服务器对应的实例结构不存在**，那么说明这个从服务器是新发现的从服务器， Sentinel会在slaves字典中为这个从服务器新创建一个实例结构

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201223205478.png)

# 获取从服务器信息

- 当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的**从服务器创建相应的实例结构之外**，Sentinel还会创建连接到从服务器的**命令连接和订阅连接**
- 举个例子，对于上面那张图所示的主从服务器关系来说，Sentinel将对slave0、slave1和 slave2三个从服务器分别创建命令连接和订阅连接，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120122373496.png)

**根据INFO命令的回复，Sentinel会提取出以下信息：**

- 从服务器的运行ID run_id
- 从服务器的角色role
- 主服务器的IP地址master_host，以及主服务器的端口号master_port
- 主从服务器的连接状态master_link_status
- 从服务器的优先级slave_priority
- 从服务器的复制偏移量slave_repl_offset

# Sentinel向主服务器和从服务器发送信息

在默认情况下，Sentinel会以**每两秒一次的频率**，通过命令连接向所有被监视的**主服务器和从服务器**发送命令

对于监视同一个服务器的多个Sentinel来说，**一个Sentinel发送的信息会被其他Sentinel接收到**，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。

# Sentinel接收服务器和从服务器的频道信息

当一个Sentinel从__sentinel__:hello频道收到一条信息时，Sentinel会对这条信息进行分 析，**提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：**

- 如果信息中记录的Sentinel运行ID和接收信息的Sentinel的**运行ID相同**，那么说明这条信 息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理
- 相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的**运行ID不相同**，那么 说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，**对相应主服务器的实例结构进行更新**
- 因为一个Sentinel可以通过分析接收到的频道信息来**获知其他Sentinel的存在**，并通过发送频道信息来**让其他Sentinel知道自己**的存在，所以用户在使用Sentinel的时候并不需要提供各个Sentinel的地址信息，监视同一个主服务器的多个Sentinel**可以自动发现对方**
- 当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，**还会创建一个连向新Sentinel的命令连接**，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的**多个Sentinel将形成相互连接的网络：**Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202184847281.png)

# 检测主观下线状态

- 在默认情况下，Sentinel会**以每秒一次的频率**向所有与它创建了命令连接的实例（**包括主服务器、从服务器、其他Sentinel在内**）发送**PING命令**，并通过实例返回的PING命令回复来判断实例是否在线
- 如果配置文件指定Sentinel1的**down-after-milliseconds选项的值为50000毫秒**，那么当主服务器master连续50000毫秒都向Sentinel1**返回无效回复时**， Sentinel1就会将master标记为主观下线

# 检测客观下线状态

- 当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线 了，它会**向同样监视这一主服务器的其他Sentinel进行询问**，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里**接收到足够数量的已下线判断之后**，Sentinel就会将从服务器判定为客观下线，并对主服务器**执行故障转移操作**

# 选取领头Sentinel

- 当一个主服务器被判断为客观下线时，监视这个下线主服务器的**各个Sentinel会进行协商**，选举出一个领头Sentinel，并由领头Sentinel**对下线主服务器执行故障转移操作**

- 1.**所有在线的Sentinel都有被选为领头Sentinel的资格**，换句话说，监视同一个主服务器的 多个在线Sentinel中的任意一个都有可能成为领头Sentinel
- 2.每次进行领头Sentinel选举之后，**不论选举是否成功，所有Sentinel的配置纪元 （configuration epoch）的值都会自增一次**。配置纪元实际上就是一个计数器，并没有什么特别的
- 3.在一个配置纪元里面，**所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会**，并且局部领头一旦设置，在这个配置每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel
- 4.当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送**SENTINEL ismaster-down-by-addr命令**，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这**表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel**
- 5.Sentinel设置局部领头Sentinel的规则是先到先得：**最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头**Sentinel，而**之后接收到的所有设置要求都会被目标Sentinel拒绝**
- 6.目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，**将向源Sentinel返回 一条命令回复，**回复中的leader_runid参数和leader_epoch参数分别**记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元**
- 7.源Sentinel在接收到目标Sentinel返回的命令回复之后，**会检查回复中leader_epoch参数的值和自己的配置纪元是否相同**，如果相同的话，那么源Sentinel继续取出回复中的 leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标 Sentinel将源Sentinel设置成了局部领头Sentinel
- 8.如果**有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel**。举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于 10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成 为领头Sentine
- 9.因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，**所以在一个配置纪元里面，只会出现一个领头 Sentinel**
- 10.如果在给定时限内，**没有一个Sentinel被选举为领头Sentinel**，那么各个Sentinel将在一段时间之后**再次进行选举**，直到选出领头Sentinel为止

# 故障转移

- 在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器**执行故障转移操作**
- **该操作包含下面3个步骤：**
    - ①在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器
    - ②让已下线主服务器属下的所有从服务器改为复制新的主服务器
    - ③将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线 时，它就会成为新的主服务器的从服务器

## 选出新的主服务器

- 故障转移操作第一步要做的就是**在已下线主服务器属下的所有从服务器中**，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送**SLAVEOF no one命令**，将这个**从服务器转换为主服务器**

### 演示案例

- 下图展示了在一次故障转移操作中，领头Sentinel向**被选中的从服务器server2**发送SLAVEOF no one命令的情形：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193156859.png)

- 在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一 次），向被升级的从服务器**发送INFO命令，**并观察命令回复中的角色（role）信息，**当被升级服务器的role从原来的slave变为master时**，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了

## 修改从服务器的复制目标

- 当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的**所有从服务器去复制新的主服务器**，这一动作可以**通过向从服务器发送SLAVEOF命令来实现**

### 图示

- 下图展示了在故障转移操作中，领头Sentinel向已下线主服务器server1的两个从服务器server3和server4发送SLAVEOF命令，让**它们复制新的主服务器server2的例子**

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193616934.png)

- 下图展示了**server3和server4成为server2的从服务器之后**，各个服务器以及领头Sentinel的样子

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193633254.png)

## 将旧的主服务器变为从服务器

- 故障转移操作最后要做的是，**将已下线的主服务器设置为新的主服务器的从服务器**。比如说，下图就展示了被领头Sentinel设置为从服务器之后，服务器server1的样子

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193748287.png)

- 因为旧的主服务器已经下线，所以这种设置是保存在server1对应的实例结构里面的，当 server1重新上线时，**Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器**
- 例如，下图就展示了server1重新上线并成为server2的从服务器的例子

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193757739.png)