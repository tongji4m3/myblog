---
title: 数据库——MySQL相关笔记------MySQL日志相关
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习MySQL所做的笔记，此为MySQL日志相关，包括redo日志、bin日志、undo日志等。
categories: MySQL
tags:
  - MySQL
  - redo日志
  - undo日志
abbrlink: 94e0411a
date: 2020-12-13 00:00:00
---



# redo log

+ WAL技术(Write Ahead Logging)：先写日志,再写磁盘
+ 是循环写的，写到末尾就又回到开头循环写。空间固定会用完
+ crash-safe：保证即使数据库发生异常重启，之前提交的记录不会丢失
+ InnoDB引擎特有的日志
+ 主要用于系统崩溃后恢复
+ 是物理日志，记录的是“在某个数据页上做了什么修改”
+ 设置参数可以让每次事务的redo log都直接持久化到磁盘



对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。那么如何保证持久性？

一个很简单的做法就是在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘。问题是刷新一个完整的数据页太浪费、随机IO刷起来比较慢。

如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。

既然我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。只需要把修改了哪些东西记录一下就好

这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所

做的修改又可以被恢复出来，也就意味着满足持久性的要求。因为在系统崩溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为重做日志，英文名为redo log

优点

redo日志占用的空间非常小、redo日志是顺序写入磁盘的

# binlog

+ 是MySQL的Server层实现的，所有引擎都可以使用

+ 只能用于归档

+ 是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”

+ binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。binlog会记录所有的逻辑操作

+ 主要用于备份日志

+ 扩容：用全量备份加上应用binlog实现，如果没有两阶段提交，这个“不一致”就会导致你的线上出现主从数据库不一致的情况

+ 设置参数可以让每次事务的binlog都持久化到磁盘。

+ 就会发现在正式的生产库上，binlog都是开着的。因为binlog有着redo log无法替代的功能.一个是归档。redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log也就起不到归档的作用。一个就是MySQL系统依赖于binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中，MySQL系统高可用的基础，就是binlog复制。

    

# undo log

+ 事务回滚的需求
+ 把回滚时所需的东西都给记下

# 两阶段提交

+ 将redo log的写入拆成了两个步骤：prepare和commit，这就是"两阶段提交"。
+ redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。
+ 如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。
+ 两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案