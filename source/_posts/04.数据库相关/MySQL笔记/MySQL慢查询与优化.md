---
title: 数据库——MySQL相关笔记------MySQL慢查询与优化
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习MySQL所做的笔记，此为MySQL慢查询与优化，包括如何定义慢SQL、explain用法等。
categories: MySQL
tags:
  - MySQL
  - 慢SQL
  - explain
abbrlink: c418bdbd
date: 2020-12-10 00:00:00
---





# 如何定位并优化慢查询SQL

## 根据慢日志定位查询sql

```mysql
SHOW VARIABLES LIKE 'slow_query_log'; //查看慢查询日志是否打开
SHOW VARIABLES LIKE 'slow_query_log_file';//查看慢查询日志位置
SHOW VARIABLES LIKE 'long_query_time';//多慢会记录到慢查询日志
show status like '%slow_queries%';//有多少条慢查询日志 只是本次连接的

//重启服务器则会失效，需要改配置文件
//需要重新连接数据库
set global slow_query_log = on;
set global long_query_time = 1;
```



## 使用explain分析sql

```
explain select * from boying_seat;
```



## 尽量让sql走索引





# 特殊优化

## 自增id用完

+ 下次插入拿到相同的自增id值，再试图执行插入语句，报主键冲突错误。
+ 达到上限则应该建成8个字节的bigint unsigned。

## count(*)

+ 而InnoDB引擎需要把数据一行一行地从引擎里面读出来，然后累积计数。

+ 是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。所以InnoDB不跟MyISAM一样，也把数字存起来

+ 可重复读是它默认的隔离级别，在代码上就是通过多版本并发

    控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。

+ InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。

+ count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。

+ 所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。

### 性能差别

- server层要什么就给什么、InnoDB只给必要的值
- 现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。
- `按照效率排序的话，count(字段)<count(主键id)<count(1)≈count(*)，尽量使用count(*)。`
- 对于count(主键id)来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。
- 对于count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
- count(字段)。如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。
- 但是`count(*)`是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。

## MySQL抖一下

+ 当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。
+ MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。
+ 对应的就是InnoDB的redo log写满了。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。要flush脏页	这种情况是InnoDB要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为0。
+ 系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：
    + 一种是内存里存在，内存里就肯定是正确的结果，直接返回；
    + 另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。
+ 对应的就是MySQL认为系统“空闲”的时候。见缝插针地找时间，只要有机会就刷一点“脏页”。
+ 对应的就是MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。