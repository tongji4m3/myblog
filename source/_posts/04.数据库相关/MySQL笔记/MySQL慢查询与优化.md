---
title: MySQL慢查询与优化
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习MySQL所做的笔记，此为MySQL慢查询与优化，包括如何定义慢SQL、explain用法等。
categories: MySQL
tags:
  - MySQL
  - 慢SQL
  - explain
abbrlink: 1cb7ab34
date: 2020-12-10 00:00:00
---





# 如何定位并优化慢查询SQL

## 根据慢日志定位查询sql

```mysql
SHOW VARIABLES LIKE 'slow_query_log'; //查看慢查询日志是否打开
SHOW VARIABLES LIKE 'slow_query_log_file';//查看慢查询日志位置
SHOW VARIABLES LIKE 'long_query_time';//多慢会记录到慢查询日志
show status like '%slow_queries%';//有多少条慢查询日志 只是本次连接的

//重启服务器则会失效，需要改配置文件
//需要重新连接数据库
set global slow_query_log = on;
set global long_query_time = 1;
```



## 使用explain分析sql

一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，从而可以有针对性的提升我们查询语句的性能。

![image-20210218170118879](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170118879.png)

EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table列代表着该表的表名



### id 

+ 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id

+ 查询语句中每出现一个SELECT关键字，就会为它分配一个唯一的id值。

+ 对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的

+ 在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表

    ![image-20210218170813309](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170813309.png)

### select_type   

SELECT关键字对应的那个查询的类型

查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型

![image-20210218170932915](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218170932915.png)

对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY

### table 

表名

### partitions 

匹配的分区信息

### type 

着MySQL对某个表的执行查询时的访问方法

+ system 当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system
+ const 当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const
+ eq_ref 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问
+ ref 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref
+ range 如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法
+ index 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index
+ ALL 最熟悉的全表扫描

### possible_keys

表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些

possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。

### key

key列表示实际用到的索引有哪些

### key_len

key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度

它是由这三个部分构成的：

+  对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是utf8， 那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。 
+ 如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。 
+ 对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。

### ref 

当使用索引列等值查询时，与索引列进行等值匹配的对象信息 

![image-20210218173701880](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218173701880.png)

### rows 预估的需要读取的记录条数 

如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。

### filtered 某个表经过搜索条件过滤后剩余记录条数的百分比

如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。 

如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。 

### Extra 一些额外的信息

我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。

**Using index** 

当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在Extra列将会提示该额外信息。比方说下边这个查询中只需要用到idx_key1而不需要回表操作：

![image-20210218180232658](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180232658.png)

**Using where**

当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时，在Extra列中会提示上述额外信息。

![image-20210218180202646](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210218180202646.png)

## 尽量让sql走索引





# 特殊优化

## 自增id用完

+ 下次插入拿到相同的自增id值，再试图执行插入语句，报主键冲突错误。
+ 达到上限则应该建成8个字节的bigint unsigned。

## count(*)

+ 而InnoDB引擎需要把数据一行一行地从引擎里面读出来，然后累积计数。

+ 是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。所以InnoDB不跟MyISAM一样，也把数字存起来

+ 可重复读是它默认的隔离级别，在代码上就是通过多版本并发

    控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。

+ InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。

+ count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。

+ 所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。

### 性能差别

- server层要什么就给什么、InnoDB只给必要的值
- 现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。
- `按照效率排序的话，count(字段)<count(主键id)<count(1)≈count(*)，尽量使用count(*)。`
- 对于count(主键id)来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。
- 对于count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
- count(字段)。如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。
- 但是`count(*)`是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。

## MySQL抖一下

+ 当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。
+ MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。
+ 对应的就是InnoDB的redo log写满了。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。要flush脏页	这种情况是InnoDB要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为0。
+ 系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：
    + 一种是内存里存在，内存里就肯定是正确的结果，直接返回；
    + 另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。
+ 对应的就是MySQL认为系统“空闲”的时候。见缝插针地找时间，只要有机会就刷一点“脏页”。
+ 对应的就是MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。