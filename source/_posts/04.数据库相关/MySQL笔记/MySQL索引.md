---
title: MySQL索引
author: tongji4m3
top: true
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习MySQL所做的笔记，此为MySQL索引相关，包括索引类型、索引模型、索引实践原则等。
categories: MySQL
tags:
  - MySQL
  - 索引
  - InnoDB
abbrlink: 43a71ae4
date: 2020-12-21 00:00:00
---

# 简介

+ 索引是存储引擎用于快速找到记录的一种数据结构
+ 索引是帮助MySQL高效获取数据的数据结构，索引存储在硬盘中
+ 索引优化是对查询性能优化最有效的手段
+ 存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行

## 索引理解

+ 每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。
+ InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。
+ 可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。
+ B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。
+ 通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。
+ 尽量少地访问资源是数据库设计的重要原则之一。

## 页结构

+ 各个数据页可以组成⼀个双向链表
+ ⽽每个数据页中的记录又可以组成⼀个单向链表
+ 每个数据页都会为存储在它里面的记录⽣成⼀个页⽬录，在通过主键查找某条记录的时候可以在页目录中使用⼆分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
+ 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。

## 索引代价

+ 空间代价
+ 时间代价：对数据增删改查要修改B+树的索引

## 例子

一个市的公民信息系统等身份证号前6位区分度很低

+ 倒序存储
+ 使用hash字段。你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。

它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X， ID_Y]的所有市民了。同样地，hash字段的方式也只能支持等值查询。

从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。

在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU资源会更小些。

从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。





# 索引模型

## 哈希表

+ 只有Memory引擎显示支持，且是Memory引擎的默认索引类型，支持非唯一哈希索引(即冲突的以链表存储).只适用特定场合，但是性能显著

+ 因为不是有序的，所以哈希索引做区间查询很慢，不支持排序

+ 只适用于只有等值查询的场景

+ 不能利用部分索引键查询，始终使用索引列的全部内容计算Hash，即如果有索引(A，B)，查询只有数据列A，则无法使用索引。

+ Hash冲突时，必须遍历链表中所有行指针，逐行比较

+ Hash在内存中，但是有几千万的数据时不行

+ 可以快速的精确查询，但是不⽀持范围查询。

+ 无法被用来避免数据的排序操作

+ 不能避免表扫描

    

## 有序数组

+ 在等值查询和范围查询场景中的性能就都非常优秀
+ 只适用于静态存储引擎
+ 往中间插入一个记录就必须得挪动后面所有的记录，成本太高



## 二叉搜索树

+ 一般来说索引非常大，尤其是关系型数据库这种，当数据量比较大的时候，索引的大小有可能几个G甚至更多，数据量大的索引能达到亿级别，所以为了减少内存的占用，**数据库索引是存储在外部磁盘上的**。
+ 因为索引不止存在内存中，还要写到磁盘上。一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块
+ 为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。
+ 运行瓶颈在IO。IO次数太多，而且造成IO浪费
+ 二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。
+ 当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载每个磁盘页，磁盘页对应索引树的节点。那么Mysql衡量查询效率的标准就是磁盘IO次数。如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。那么为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好，因此B树正好符合我们的要求，这也是B-树的特征之一。

## B树

+ B树⼀个节点可以存储多个元素，相对于完全平衡⼆叉树整体的树⾼降低了，磁盘IO效率提⾼了。
+ ⽽B+树是B树的升级版，只是把非叶子节点冗余⼀下，这么做的好处是为了提⾼范围查找的效率。
+ 需要遵循一些约束，目的是尽可能存储更多的信息



## B+树

+ B+树很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数，磁盘读写代价更低
+ B+树的查询效率更加稳定
+ B+树更有利于对数据库的扫描（范围查询）

![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/5824016-540158230f76f9cc.png)

+ 根节点至少一个元素
+ 非根节点元素范围：m/2 <= k <= m-1
+ 父节点存有右孩子的第一个元素的索引。
+ B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。
+ 有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。
+ 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
+ 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

**区别**

+ B+树中间节点没有存储数据，只有叶节点存放数据，其余节点用来索引，所以同样大小的磁盘页可以容纳更多的节点元素，而B-树是每个索引节点都会有Data域。这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询是IO次数也更少。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。
+ 其次，B+树的查询必须最终查询到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。因此，B-树的查询性能并不稳定（最好情况是只查根节点，最坏情况是查到叶子节点）。而B+树每一次查找都是稳定的。
+ B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。对于**范围查询**，比如查询范围为3~11的元素，B-树只能依靠繁琐的中序遍历，首先自顶向下查找范围的下限，然后中序遍历找到上限。B+树的范围查询则要简单的多，首先自顶向下查找范围的下限，然后只需要在叶子节点所在的链表上做遍历即可。

**优势**

1.单一节点存储更多的元素，使得查询的IO次数更少。

2.所有查询都要查找到叶子节点，查询性能稳定。

3.所有叶子节点形成有序链表，便于范围查询。

### 插入操作

对于插入操作很简单，只需要记住一个技巧即可：**当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的**。

下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。

- 插入5，10，15，20

![img](https:////upload-images.jianshu.io/upload_images/5824016-d382af5adae64c9a.png?imageMogr2/auto-orient/strip|imageView2/2/w/352/format/webp)

- 插入25，此时元素数量大于4个了，分裂

![img](https:////upload-images.jianshu.io/upload_images/5824016-0fdf67534b398b14.png?imageMogr2/auto-orient/strip|imageView2/2/w/542/format/webp)

- 接着插入26，30，继续分裂

![img](https:////upload-images.jianshu.io/upload_images/5824016-5c335f386d0d7518.png?imageMogr2/auto-orient/strip|imageView2/2/w/602/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/5824016-0f74727e08f5a45d.png?imageMogr2/auto-orient/strip|imageView2/2/w/687/format/webp)

### 删除操作

**叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key**，下面我们看看具体的实例。

- 初始状态

![img](https:////upload-images.jianshu.io/upload_images/5824016-8b1c2a995b8da6b9.png?imageMogr2/auto-orient/strip|imageView2/2/w/963/format/webp)

- 删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引

![img](https:////upload-images.jianshu.io/upload_images/5824016-3363541b1c6a0765.png?imageMogr2/auto-orient/strip|imageView2/2/w/995/format/webp)

- 删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引

![img](https:////upload-images.jianshu.io/upload_images/5824016-4ea5c178a3435518.png?imageMogr2/auto-orient/strip|imageView2/2/w/944/format/webp)

- 发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作

![img](https:////upload-images.jianshu.io/upload_images/5824016-091103cefce92d4e.png?imageMogr2/auto-orient/strip|imageView2/2/w/919/format/webp)

# 索引分类

## 主键索引

+ 也称为聚簇索引，主键索引的叶子节点存的是整行数据。
+ 所有完整的用户记录都存放在这个聚簇索引的叶子节点处
+ 会自动的为我们创建聚簇索引
+ 一般是通过主键聚集数据，但是如果没有定义主键，则回选取唯一非空索引替代。若没有这样的索引，则会隐式定义一个主键作为聚簇索引
+ 只有主键索引是聚集索引，其他的索引都是非聚集索引。数据区挂载在主键索引上

## 二级索引

+ 也叫非聚簇索引
+ 按照该索引列的大小顺序排成一个单向链表
+ 非主键索引的叶子节点内容是该索引列、主键的值。
+ 由于查询结果所需要的数据只在主键索引上有，所以不得不回表。回到主键索引树搜索的过程，即回表查询
+ 没有唯一性约束，所以索引列值为4的记录可能分布在多个数据页中
+ 对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。

## 唯一索引

+ 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。
+ 普通索引和唯一索引对更新语句性能影响的差别
+ 因为change buffer，尽量选择普通索引。

## 联合索引

+ 时以多个列的大小作为排序规则，也就是同时为多个列建立索引
+ 索引（c2，c3），先把各个记录和页按照c2列进行排序。在记录的c2列相同的情况下，采用c3列进行排序

## 覆盖索引

+ 索引k已经“覆盖了”我们的查询需求，不需要使用回表
+ 覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。
+ 最好在查询列表里只包含索引列，很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明

## 前缀索引

+ 使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中
+ 要选择足够长的前缀以保证较高的选择性
+ 索引的选择性:不重复的索引值和数据表的记录总数。索引的选择性越高则查询效率越高，因为索引的选择性高则可以在查找时过滤更多的行。唯一索引的选择性是1，是最好的索引选择性，性能最好
+ 一般情况下某个列前缀的选择性也足够高，足以满足查询性能，大大节约索引空间
+ 如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。
+ alter table user add index index2(email(6));
+ 使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。
+ 在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。
+ select count(distinct left(email，4)) as L4 from user;
+ 使用前缀索引就用不上覆盖索引对查询性能的优化

# 索引适用场景

+ 全值匹配（顺序颠倒也有查询优化器帮忙）
+ 匹配左边的列
+ 匹配列前缀（tongji%能，%tongji则不能使用索引）
+ 匹配范围值：先找范围左边，再找范围右边，取中间的。如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引，例如中通过name进行范围查找的记录中可能并不是按照birthday列进行排序的
+ 精确匹配某一列并范围匹配另外一列
+ 用于排序
+ 用于分组

# 实践原则

## 普通索引与唯一索引

尽量选择普通索引：这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响

普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。

### 查询操作

查询性能差距微乎其微：InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。数据页的大小默认是16KB。因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。

流程：对于普通索引来说，查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

### 更新操作

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4，400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。

因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。

## 自增主键

+ 每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
+ 由于每个非主键索引的叶子节点上都是主键的值。所以主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

## 最左前缀原则

+ 不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。
+ 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
+ 索引可以简单如⼀个列 (a)，也可以复杂如多个列 (a，b，c，d)，即联合索引。
+ 如果是联合索引，那么key也由多个列组成，同时，索引只能⽤于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进⼀步匹配了，后续退化为线性查找。
+ 因此，列的排列顺序决定了可命中索引的列数。
+ MySQL会⼀直向右匹配直到遇到范围查询 （>，<，BETWEEN，LIKE）就停⽌匹配。

## 索引下推优化

可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

## 只为用于搜索、排序或分组的列创建索引

只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引

## 考虑列的基数

+ 指的是某一列中不重复数据的个数
+ 且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了

## 索引列的类型尽量小

+ 在表示的整数范围允许的情况下，尽量让索引列使用较小的类型
+ 对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O

## 索引字符串值的前缀

只对字符串的前几个字符进行索引	

## 让索引列在比较表达式中单独出现

如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。

## 避免冗余和重复索引

重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免这样创建重复索引，发现后也应该立即移除

## 选择合适的索引列顺序

正确的顺序依赖于使用该索引的查询，同时需要考虑如何更好地满足排序和分组的需求将选择性最高的列放到索引的最前列