---
title: MySQL基础知识
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 学习MySQL所做的笔记，此为MySQL基础知识，包括各种引擎的对比、三大范式等。
categories: MySQL
tags:
  - MySQL
  - 存储引擎
  - 三大范式
abbrlink: 9d61f8d3
date: 2020-12-07 00:00:00
---





# MySQL设计

+ 存储管理
+ 缓存机制
+ SQL解析
+ 日志管理
+ 权限划分
+ 容灾机制
+ 索引管理
+ 锁管理



# MySQL各种引擎的区别

## MyISAM存储引擎

插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率

+ 适用频繁执行全表count语句，因为InnoDB没有存储的字段
+ 对数据进行增删改的频率不高，查询非常频繁
+ 没有事务

## InnoDB存储引擎

支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。

+ 增删改查都相当频繁
+ 对可靠性要求高

## MEMORY存储引擎

所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果

默认情况下，MEMORY数据表使用散列索引，利用这种索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了。因此，散列索引值适合使用在"="和"<=>"的操作符中，不适合使用在"<"或">"操作符中，也同样不适合用在order by字句里。如果确实要使用"<"或">"或betwen操作符，可以使用btree索引来加快速度。

## MyISAM和InnoDB区别

MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，⽽且提供了⼤量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。

5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为 InnoDB。 

大多数时候我们使⽤的都是 InnoDB 存储引擎，但是在某些情况下使⽤ MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。

![image-20210206075525367](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206075525367.png)

# MySQL服务器

## Server层

### 连接器

+ 连接器负责跟客户端建立连接、获取权限、维持和管理连接。
+ 经过TCP握⼿，然后身份验证
+ 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。
+ 短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。
+ 建立连接的过程通常是比较复杂的，尽量使用长连接。
+ 通过执行mysql_reset_connection来重新初始化连接资源。将连接恢复到刚刚创建完时的状态。避免长连接累积导致内存占用太大

### 查询缓存（通常不用）

+ 两次查询任何字符不同都会失效
+ 只要有对一个表的更新，这个表上所有的查询缓存都会被清空
+ 查询缓存的命中率会非常低

### 分析器

#### 词法分析

你的语句有这么多单词、空格，MySQL就需要识别每个字符串所代表的是什么，是关键字，还是表名，还是列名等等。

#### 语法分析

根据词法分析的结果，语法分析会判断你sql的对错，错了会提醒你的，并且会提

示你哪⾥错了。

### 优化器

+ 执行计划

+ EXPLAIN

+ 要确认使用哪个索引，⽐如使⽤你的主键索引，联合索引还是什么索引更好。而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。

+ 根据统计信息来估算记录数。这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。

+ 采样统计得到索引的基数：默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。使用普通索引需要把回表的代价算进去

+ 是对执行顺序进⾏优化，条件那么多，先查哪个表，还是先关联，会出现很多⽅案，最后由优化器决定选用哪种方案。

    
    
    

### 执行器

+ 检查权限
+ 调用存储引擎

## 存储引擎层

+ InnoDB：具备外键支持功能的事务存储引擎，默认的存储引擎

+ Memory：置于内存的表

+ MyISAM：主要的非事务处理存储引擎

    

# 三大范式

**闭包**

![image-20210206085950120](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206085950120.png)



**超码**

![image-20210206090053252](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206090053252.png)



**函数依赖**

![image-20210206090123972](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206090123972.png)



**超码superkey**

- 可能包含无关属性
- 超码的任意超集也是超码。
- 一张表（一个关系）一定有超码，因为至少所有属性的组合一定是超码，能唯一确定一个元组
- 不唯一



**候选码candidate key**

- 是超码的一个子集
- 任意真子集都不可能是超码，候选码就是最小的超码
- 没有无关属性
- 不唯一



**主码primary key**

- 是候选码之一
- 唯一或没有
- 由数据库设计者指定，不指定的话表就没有主码

## 第一范式（1NF)

一个关系模式R中的所有属性的域都是原子的（该域的元素是不可再分单元）

- 第一范式是对关系模式的最起码的要求，不满足第一范式的数据库模式不能称为关系数据库
- 强调的是**列的原子性**，即列不能够再分成其他几列。 



### 例子

考虑这样一个表：【联系人】（姓名，性别，电话） 

如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即：【联系人】（姓名，性别，家庭电话，公司电话）





## 第二范式（2NF)

若关系模式R∈1NF，并且每一个非主属性都完全依赖于R的主码，则R∈2NF。

所谓完全依赖是指不能存在仅依赖主关键字一部分的属性

+ 满足1NF
+ 表必须有主键
+ 没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 

### 例子

| 学号  | 课程 | 成绩 | 课程学分 |
| ----- | ---- | ---- | -------- |
| 10001 | 数学 | 100  | 6        |
| 10001 | 语文 | 90   | 2        |
| 10001 | 英语 | 85   | 3        |
| 10002 | 数学 | 90   | 6        |
| 10003 | 数学 | 99   | 6        |
| 10004 | 语文 | 89   | 2        |

表中主键为 （学号，课程），我们可以表示为 (学号，课程) -> (成绩，课程学分)， 表示所有非主键列 (成绩，课程学分)都依赖于主键 (学号，课程)。 但是，表中还存在另外一个依赖：（课程）->(课程学分）。这样非主键列 ‘课程学分‘ 依赖于部分主键列 ’课程‘， 所以上表是不满足第二范式的。

拆分为**学生选课表**、 **课程信息表**



## 第三范式（3NF)

![image-20210206091536431](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206091536431.png)

### 例子

满足第二范式，并且表中的列不存在对非主键列的传递依赖。

| 学号  | 姓名   | 性别 | 班级 | 班主任 |
| :---- | :----- | :--- | :--- | :----- |
| 10001 | 张三   | 男   | 一班 | 小王   |
| 10002 | 李四   | 男   | 一班 | 小王   |
| 10003 | 王五   | 男   | 二班 | 小李   |
| 10004 | 张小三 | 男   | 二班 | 小李   |

主键为：（学号），所有字段 （姓名，性别，班级，班主任）都依赖与主键（学号），不存在对主键的部分依赖。所以是满足第二范式。

虽然满足第二范式，所有字段都依赖主键（学号），但是，表中存在一个传力依赖，(学号）->(班级）->（班主任）。也就是说，（班主任）这个非主键列依赖与另外一个非主键列 （班级）。所以不符合第三范式。

拆分为：**学生信息表**、**班级信息表**



## BC范式（BCNF)

### 定义

![image-20210206085215574](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206085215574.png)

### 例子

![image-20210206091108929](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210206091108929.png)

**问题：**

先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。

某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。

如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。

仓库名——》管理员

管理员——》仓库名

仓库名、物品名——》数量

管理员、物品名——》数量



候选码：（管理员、物品名）、（仓库名、物品名）

符合第三范式：管理员包含在候选码中

但是不符合BC范式

**拆分为：**

仓库（仓库名，管理员）

库存（仓库名，物品名，数量）




