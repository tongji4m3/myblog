---
title: 设计模式--模板方法模式
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: '学习《Head Frist 设计模式》所做的笔记,主要介绍了模板方法模式的原则,类图,代码实现。'
categories: 设计模式笔记
tags:
  - 设计模式
  - Java
  - UML
abbrlink: 3c67b570
date: 2020-10-13 00:00:00
---

# 模板方法模式
## 模板方法模式定义

模板方法模式在一个方法中定义一个算法的骨架,而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

## 细节

+ 模板就是一个方法，将算法定义成一组步骤，其中任何步骤都可以是抽象的，由子类负责实现。这可以确保算法的结构保持不变，同时由子类提供部分实现。
+ 钩子是一种被声明在抽象类中的方法，只有空或者默认的实现，他可以让子类有能力对算法的不同点进行挂钩。如果算法的某部分是可选的，就用钩子
+ 与策略模式的区别是策略模式组合的类中实现了整个算法，而模板方法模式可能只实现了算法中的部分步骤。
+ 为了防止子类改变模板方法中的算法，可以将模板方法声明为final


## 设计原则

+ 好莱坞原则：别调用我们，我们会调用你。即低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。例如模板方法中`CaffeineBeverageWithHook`为高层组件，只有在需要子类实现某个方法时，才调用子类。

## 用途

+ Java排序，需要实现`Comparable接口`，实现`compareTo()`方法进行两个元素大小的比较。
+ Swing窗口中，通过继承`JFrame`，再覆盖父类中不做事的`paint()`方法来在窗口绘制。
+ Applet是能在网页上运行的小程序，它提供了很多个钩子方法。通过继承`Applet`，再覆盖他的几个接口可以方便进行开发,例如：

```java
public class MyApplet extends Applet
{
    private String message;

    //init钩子用来进行applet初始化动作,他会在applet一开始被调用一次
    public void init()
    {
        message = "init";
        //通知上层组件重绘该applet
        repaint();
    }

    //stop钩子在用户跳转到别的网页时调用
    public void stop()
    {
        message = "stop";
        //通知上层组件重绘该applet
        repaint();
    }

    public void paint(Graphics graphics)
    {
        graphics.drawString(message, 5, 15);
    }
}
```

# 类图

 ![1603594324(https://tongji4m3.oss-cn-beijing.aliyuncs.com/1603594324(1).jpg)](https://tongji4m3.oss-cn-beijing.aliyuncs.com/1603594324(1).jpg)



# 实现 

## CaffeineBeverageWithHook

```java
public abstract class CaffeineBeverageWithHook
{
    void prepareRecipe()
    {
        boilWater();
        brew();
        pourInCup();
        //钩子方法改变的行为
        if(customerWantsCondiments())
        {
            addCondiments();
        }
    }

    abstract void brew();

    abstract void addCondiments();

    void boilWater()
    {
        System.out.println("boilWater");
    }

    void pourInCup()
    {
        System.out.println("pourInCup");
    }

    //一个钩子方法,子类可以通过他改变模板的行为
    boolean customerWantsCondiments()
    {
        return true;
    }
}
```

## CoffeeWithHook

```java
package TemplatePattern;

public class CoffeeWithHook extends CaffeineBeverageWithHook
{
    @Override
    void brew()
    {
        System.out.println("CoffeeWithHook brew");
    }

    @Override
    void addCondiments()
    {
        System.out.println("CoffeeWithHook addCondiments");
    }

    @Override
    boolean customerWantsCondiments()
    {
        //这里可以用一些逻辑来控制该钩子,此处省略
        return true;
    }
}
```

## MainTest

```java
package TemplatePattern;

public class MainTest
{
    public static void main(String[] args)
    {
        CoffeeWithHook coffeeWithHook = new CoffeeWithHook();
        coffeeWithHook.prepareRecipe();
        //boilWater
        //CoffeeWithHook brew
        //pourInCup
        //CoffeeWithHook addCondiments
    }
}
```