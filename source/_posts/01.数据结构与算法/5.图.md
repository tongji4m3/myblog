---
title: 图
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 《算法4》笔记与相关代码，无环图、有向图、最小生成树、最短路径等
categories: 《算法4》笔记
tags:
  - 图
  - 最小生成树
  - 最短路径
abbrlink: ee040603
date: 2021-01-18 00:00:00
---



# 无环图

## Graph

```java
package offer.chapter4;

import offer.chapter1.Bag;

public class Graph {
    private final int V;
    private int E;
    private Bag<Integer>[] adj;

    public Graph(int V) {
        this.V = V;
        this.E = 0;
        adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<>();
        }
    }
    
    public int V() {
        return V;
    }

    public int E() {
        return E;
    }

    public void addEdge(int v, int w) {
        adj[v].add(w);
        adj[w].add(v);
        E++;
    }

    public Iterable<Integer> adj(int v) {
        return adj[v];
    }
}
```

## 深度优先搜索

```java
package offer.chapter4;

public class DepthFirstSearch {
    private boolean[] marked;
    private int count;

    public DepthFirstSearch(Graph G, int s) {
        marked = new boolean[G.V()];
        dfs(G, s);
    }

    private void dfs(Graph G, int v) {
        marked[v] = true;
        count++;
        for (Integer w : G.adj(v)) {
            if(!marked[w]) dfs(G, w);
        }
    }

    public boolean marked(int w) {
        return marked[w];
    }

    public int count() {
        return count;
    }
}
```

## 深度优先搜索-路径

```java
package offer.chapter4;

import java.util.LinkedList;

public class DepthFirstPaths {
    private boolean[] marked;
    private int[] edgeTo;
    private final int s;

    public DepthFirstPaths(Graph G, int s) {
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        this.s = s;
        dfs(G, s);
    }

    private void dfs(Graph G, int v) {
        marked[v] = true;
        for (Integer w : G.adj(v)) {
            if (!marked[w]) {
                edgeTo[w] = v;
                dfs(G, w);
            }
        }
    }

    public boolean hasPathTo(int v) {
        return marked[v];
    }

    public Iterable<Integer> pathTo(int v) {
        if (!hasPathTo(v)) return null;
        LinkedList<Integer> path = new LinkedList<>();
        for (int x = v; x != s; x = edgeTo[x]) {
            path.push(x);
        }
        path.push(s);
        return path;
    }
}
```

## 广度优先搜索

```java
package offer.chapter4;

import java.util.LinkedList;

public class BreadthFirstPaths {
    private boolean[] marked;
    private int[] edgeTo;
    private final int s;

    public BreadthFirstPaths(Graph G, int s) {
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        this.s = s;
        bfs(G, s);
    }

    private void bfs(Graph G, int s) {
        LinkedList<Integer> queue = new LinkedList<>();
        marked[s] = true;
        queue.offer(s);
        while (!queue.isEmpty()) {
            int v = queue.poll();
            for (Integer w : G.adj(v)) {
                if (!marked[w]) {
                    edgeTo[w] = v;
                    marked[w] = true;
                    queue.offer(w);
                }
            }
        }
    }

    public boolean hasPathTo(int v) {
        return marked[v];
    }
}
```

# 有向图

## Digraph

```java
package offer.chapter4.section2;

import offer.chapter1.Bag;

public class Digraph {
    private final int V;
    private int E;
    private Bag<Integer>[] adj;

    public Digraph(int V) {
        this.V = V;
        this.E = 0;
        adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<>();
        }
    }

    public int V() {
        return V;
    }

    public int E() {
        return E;
    }

    public void addEdge(int v, int w) {
        adj[v].add(w);
        E++;
    }

    public Iterable<Integer> adj(int v) {
        return adj[v];
    }
}
```

## DirectedCycle

```java
package offer.chapter4.section2;

import chapter1.section3.Stack;

public class DirectedCycle {
    private boolean[] marked;
    private int[] edgeTo;
    private Stack<Integer> cycle;
    private boolean[] onStack;

    public DirectedCycle(Digraph G) {
        onStack = new boolean[G.V()];
        edgeTo = new int[G.V()];
        marked = new boolean[G.V()];
        for (int v = 0; v < G.V(); v++) {
            if(!marked[v]) dfs(G, v);
        }
    }

    private void dfs(Digraph G, int v) {
        onStack[v] = true;
        marked[v] = true;
        for (Integer w : G.adj(v)) {
            if (this.hasCycle()) {
                return;
            } else if (!marked[w]) {
                edgeTo[w] = v;
                dfs(G, w);
            } else if (onStack[w]) {
                cycle = new Stack<>();
                for (int x = v; x != w; x = edgeTo[x]) {
                    cycle.push(x);
                }
                cycle.push(w);
                cycle.push(v);
            }
        }
        onStack[v] = false;
    }

    private boolean hasCycle() {
        return cycle != null;
    }

    public Iterable<Integer> cycle() {
        return cycle;
    }
}
```

## DepthFirstOrder

```java
package offer.chapter4.section2;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class DepthFirstOrder {
    private boolean[] marked;
    private Queue<Integer> pre;
    private Queue<Integer> post;
    private Stack<Integer> reversePost; //逆后序

    public DepthFirstOrder(Digraph G) {
        pre = new LinkedList<>();
        post = new LinkedList<>();
        reversePost = new Stack<>();
        marked = new boolean[G.V()];

        for (int v = 0; v < G.V(); v++) {
            if(!marked[v]) dfs(G, v);
        }
    }

    private void dfs(Digraph G, int v) {
        pre.offer(v);

        marked[v] = true;
        for (Integer w : G.adj(v)) {
            if (!marked[w]) {
                dfs(G, w);
            }
        }

        post.offer(v);
        reversePost.push(v);
    }

    public Stack<Integer> getReversePost() {
        return reversePost;
    }
}
```

## 拓扑排序

给定一个有向图，将所有顶点排序，使得所有有向边均从排在前面的元素指向排在后面的元素

按照这个顺序，可以在满足先导课程限制的条件下修完所有课程

```java
package offer.chapter4.section2;

public class Topological {
    private Iterable<Integer> order;

    public Topological(Digraph G) {
        DirectedCycle cycle = new DirectedCycle(G);
        if (!cycle.hasCycle()) {
            DepthFirstOrder depthFirstOrder = new DepthFirstOrder(G);
            order = depthFirstOrder.getReversePost();
        }
    }

    public Iterable<Integer> getOrder() {
        return order;
    }

    public static void main(String[] args) {
        int V = 10;
        Digraph G = new Digraph(V);
        Topological topological = new Topological(G);
        for (Integer v : topological.order) {
            System.out.println(v);
        }
    }
}
```

# 最小生成树

## Edge

```java
package offer.chapter4.section3;

public class Edge implements Comparable<Edge> {
    private final int v;
    private final int w;
    private final double weight;

    public Edge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    public double weight() {
        return weight;
    }

    public int either() {
        return v;
    }

    public int other(int vertex) {
        if (vertex == v) {
            return w;
        } else if (vertex == w) {
            return v;
        } else {
            throw new RuntimeException("Inconsistent edge");
        }
    }

    @Override
    public int compareTo(Edge that) {
        if(this.weight() < that.weight()) return -1;
        else if(this.weight() > that.weight()) return +1;
        else return 0;
    }

    @Override
    public String toString() {
        return String.format("%d-%d %.2f", v, w, weight);
    }
}
```

## EdgeWeightedGraph

```java
package offer.chapter4.section3;

import offer.chapter1.Bag;

public class EdgeWeightedGraph {
    private final int V;
    private int E;
    private Bag<Edge>[] adj;


    public EdgeWeightedGraph(int V) {
        this.V = V;
        this.E = 0;
        adj = (Bag<Edge>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<>();
        }
    }

    public int V() {
        return V;
    }

    public int E() {
        return E;
    }

    public void addEdge(Edge e) {
        int v = e.either(), w = e.other(v);
        adj[v].add(e);
        adj[w].add(e);
        E++;
    }

    public Iterable<Edge> adj(int v) {
        return adj[v];
    }
    
    public Iterable<Edge> edges() {
        Bag<Edge> edges = new Bag<>();

        for (int v = 0; v < V; v++) {
            for (Edge edge : adj[v]) {
                edges.add(edge);
            }
        }
        return edges;
    }
}
```



最小生成树即含有所有顶点的所有边权重最小的连通子图，是用贪心算法实现的

## Prim算法-选点法

Prim算法的速度最坏情况下可以达到ElogV，因为它维护的是一个关于顶点的优先队列，所以一次最坏速度为 logV，算法进行过程中需要V次插入，V次删除最小值，以及最坏情况下E次改变权重，而每次改变权重都需要重新使堆有序，也就是又一次logV，所以总共的最坏速度为ElogV

![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20171125214733268)

- Prim算法每次将不在树中的顶点且权重最小的边加入树中，是**选点法**
- 开始把所有顶点到生成树的距离设为最大值。随后选择一个顶点设置它到生成树的距离为0，并把他加入维护有效横切边的优先队列中。
- 然后开始循环，不断弹出优先队列中到生成树最小的那个顶点，加入生成树中。并把把该顶点相连接的所有不在树中的顶点且距离生成树更小的节点和他们到生成树的距离（该距离初始化为最大值）加入优先队列中。当优先队列为空，停止循环，此时生成了最小生成树。

```java
package offer.chapter4.section3;



public class PrimMST {
    //距离树最近的边
    private Edge[] edgeTo;
    private double[] distTo;
    private boolean[] marked;
    //存储有效的横切边
    private IndexMinPQ<Double> pq;

    public PrimMST(EdgeWeightedGraph G) {
        edgeTo = new Edge[G.V()];
        distTo = new double[G.V()];
        marked = new boolean[G.V()];
        for (int v = 0; v < G.V(); v++) {
            distTo[v] = Double.POSITIVE_INFINITY;
        }
        //用0顶点做生成树的起点
        distTo[0] = 0.0;
        pq.insert(0, 0.0);

        //pq每次删除都往最小生成树中加入一个节点，为空时最小生成树就已经构成了
        while (!pq.isEmpty()) {
            visit(G, pq.delMin());
        }
    }

    private void visit(EdgeWeightedGraph G, int v) {
        marked[v] = true;
        //把该顶点相连接的所有不在树中的顶点且距离生成树更小的节点加入
        for (Edge e : G.adj(v)) {
            int w = e.other(v);

            if(marked[w]) continue;

            if (e.weight() < distTo[w]) {
                edgeTo[w] = e;
                distTo[w] = e.weight();

                if(pq.contains(w)) pq.change(w, distTo[w]);
                else pq.insert(w, distTo[w]);
            }
        }
    }
}
```

## Kruskal算法-选边法

最坏情况下速度为ElogE，主要是因为它维护了一个所有边的优先队列，那每次对优先队列操作成本为logE，而最坏情况下需要遍历所有边才能够得到我们需要的V-1条边，其他的UnionFound的操作因为是对顶点进行的，所以乘的是logV，量级比较小，所以忽略。

![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20171126102742349)

- 先将所有边加入最小堆
- 不断删除最小边直到堆为空，或者最小生成树中边的大小为V-1
- 删除的最小边对应的两个顶点如果已经是连通的，则忽略，否则将之加入生成树，并使得这两个顶点连通

```java
package offer.chapter4.section3;

import offer.chapter1.UF;

import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;

public class KruskalMST {
    //存储最小生成树
    private Queue<Edge> mst;

    public KruskalMST(EdgeWeightedGraph G) {
        mst = new LinkedList<>();

        PriorityQueue<Edge> minPQ = new PriorityQueue<>();
        for (Edge edge : G.edges()) {
            minPQ.offer(edge);
        }

        UF uf = new UF(G.V());
        while (!minPQ.isEmpty() && mst.size() < G.V() - 1) {
            Edge e = minPQ.poll();
            int v = e.either(), w = e.other(v);
            if (uf.connected(v, w)) {
                continue;
            }
            uf.union(v, w);
            mst.offer(e);
        }
    }

    public Iterable<Edge> edges() {
        return mst;
    }
}
```

# 最短路径

## DirectedEdge

```java
package offer.chapter4.section4;

public class DirectedEdge {
    private final int v;
    private final int w;
    private final double weight;

    public DirectedEdge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    public double weight() {
        return weight;
    }

    public int from() {
        return v;
    }

    public int to() {
        return w;
    }

    @Override
    public String toString() {
        return String.format("%d->%d %.2f", v, w, weight);
    }
}
```
## EdgeWeightedDigraph

```java
package offer.chapter4.section4;

import offer.chapter1.Bag;

public class EdgeWeightedDigraph {
    private final int V;
    private int E;
    private Bag<DirectedEdge>[] adj;


    public EdgeWeightedDigraph(int V) {
        this.V = V;
        this.E = 0;
        adj = (Bag<DirectedEdge>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<>();
        }
    }

    public int V() {
        return V;
    }

    public int E() {
        return E;
    }

    public void addEdge(DirectedEdge e) {
        adj[e.from()].add(e);
        E++;
    }

    public Iterable<DirectedEdge> adj(int v) {
        return adj[v];
    }

    public Iterable<DirectedEdge> edges() {
        Bag<DirectedEdge> edges = new Bag<>();

        for (int v = 0; v < V; v++) {
            for (DirectedEdge e : adj[v]) {
                edges.add(e);
            }
        }
        return edges;
    }
}
```

## Dijkstra算法

+ Dijkstra和Prim算法都是用贪婪和线性规划算法，每一步选择权重最小的边
+ Dijkstra的松弛操作加上了到起点的距离，而Prim算法只有到树的距离（相邻节点的权值）

```java
package offer.chapter4.section4;

public class DijkstraSP {
    private DirectedEdge[] edgeTo;
    private double[] distTo;
    private IndexMinPQ<Double> pq;

    public DijkstraSP(EdgeWeightedDigraph G, int s) {
        edgeTo = new DirectedEdge[G.V()];
        distTo = new double[G.V()];
        pq = new IndexMinPQ<>();

        for (int v = 0; v < G.V(); v++) {
            distTo[v] = Double.POSITIVE_INFINITY;
        }

        distTo[s] = 0.0;

        pq.insert(s, 0.0);
        while (!pq.isEmpty()) {
            relax(G, pq.delMin());
        }
    }

    private void relax(EdgeWeightedDigraph G, int v) {
        for (DirectedEdge e : G.adj(v)) {
            int w = e.to();
            if (distTo[w] > distTo[v] + e.weight()) {
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;
                if (pq.contains(w)) pq.change(w, distTo[w]);
                else pq.insert(w, distTo[w]);
            }
        }
    }
}
```