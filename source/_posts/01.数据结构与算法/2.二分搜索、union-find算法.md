---
title: 二分搜索、union-find算法
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 《算法4》笔记与相关代码，常见算法如二分搜索、ThreeSum、连通性算法等
categories: 《算法4》笔记
tags:
  - 二分搜索
  - 连通性算法
  - ThreeSum
abbrlink: 16b3d50
date: 2021-01-13 00:00:00
---



# 二分搜索

```java
package offer;

public class BinarySearch {
    //默认情况下，如果没有找到，那么hi对应元素第一个小于他，lo对应元素第一个大于他
    public static int rank1(int key, int[] a) {
        int lo = 0, hi = a.length - 1;
        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;
            if (key < a[mid]) {
                hi = mid - 1;
            } else if (key > a[mid]) {
                lo = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;
    }

    //递归方式
    public static int rank(int key, int[] a) {
        return rank(key, a, 0, a.length - 1);
    }

    private static int rank(int key, int[] a, int lo, int hi) {
        if (hi < lo) return -1;
        int mid = lo + (hi - lo) / 2;
        if (key < a[mid]) return rank(key, a, lo, mid - 1);
        else if (key > a[mid]) return rank(key, a, mid + 1, hi);
        else return mid;
    }
}
```

# TwoSum

统计一个数组中所有和为0的二元组数量

```java
package offer;

import java.util.Arrays;

public class TwoSumFast {
    public static int count(int[] a) {
        Arrays.sort(a);
        int cnt = 0;

        for (int i = 0; i < a.length; i++) {
            //避免重复计数
            if (BinarySearch.rank(-a[i], a) > i) {
                cnt++;
            }
        }

        return cnt;
    }
}
```

# ThreeSum

```java
package offer;

import java.util.Arrays;

public class ThreeSumFast {
    public static int count(int[] a) {
        Arrays.sort(a);
        int cnt = 0;

        for (int i = 0; i < a.length; i++) {
            for (int j = i + 1; j < a.length; j++) {
                if (BinarySearch.rank(-a[i] - a[j], a) > j) {
                    ++cnt;
                }
            }
        }

        return cnt;
    }
}
```

# 连通性算法

## quick-find

```java
package offer;

public class UF {
    private int[] id;
    private int count;

    public UF(int N) {
        this.count = N;
        id = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
        }
    }

    public int count() {
        return count;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public int find(int p) {
        return id[p];
    }

    public void union(int p, int q) {
        int pID = find(p);
        int qID = find(q);
        
        if(pID == qID) return;

        for (int i = 0; i < id.length; i++) {
            if(id[i] == pID) id[i] = qID;
        }
        count--;
    }


}
```

## quick-union

```java
package offer;

public class UF {
    private int[] id;
    private int count;

    public UF(int N) {
        this.count = N;
        id = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
        }
    }

    public int count() {
        return count;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public int find(int p) {
        while (p != id[p]) {
            p = id[p];
        }
        return p;
    }

    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);

        if(pRoot == qRoot) return;

        id[pRoot] = qRoot;
        count--;
    }
}
```

## 加权quick-union

```java
package offer;

public class WeightedQuickUnionUF {
    private int[] id;
    private int[] size; //size代表规模，不是高度
    private int count;

    public WeightedQuickUnionUF(int N) {
        this.count = N;
        id = new int[N];
        size = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
            size[i] = 1;
        }
    }

    public int count() {
        return count;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public int find(int p) {
        while (p != id[p]) {
            p = id[p];
        }
        return p;
    }

    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);

        if (pRoot == qRoot) return;

        if (size[pRoot] < size[qRoot]) {
            id[pRoot] = qRoot;
            size[qRoot] += size[pRoot];
        } else {
            id[qRoot] = pRoot;
            size[pRoot] += size[qRoot];
        }
        count--;
    }
}
```