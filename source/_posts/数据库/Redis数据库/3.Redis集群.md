# 主从复制

## 简介

#### 理解

被复制的服务器称为主服务器，对主服务器进行复制的服务器称为从服务器

进行复制中的主从服务器双方的数据库将保存相同的数据

#### 优点

+ 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。减轻主数据库的压力
+ 一主多从，「主数据库(master)可以读也可以写(read/write)，从数据库仅读(only read)」。
+ 主从一定程度上解决了单机版并发量大，导致请求延迟或者redis宕机服务停止的问题。
+ 从数据库分担主数据库的读压力，若是主数据库是只写模式，那么实现读写分离，主数据库就没有了读压力了。
+ 另一方面解决了单机版单点故障的问题，若是主数据库挂了，那么从数据库可以随时顶上来，综上来说，主从模式一定程度上提高了系统的可用性和性能，是实现哨兵和集群的基础。
+ 主从同步以异步方式进行同步，期间Redis仍然可以响应客户端提交的查询和更新的请求。

###### 缺点

比如数据的一致性问题，假如主数据库写操作完成，那么他的数据会被复制到从数据库，若是还没有即使复制到从数据库，读请求又来了，此时读取的数据就不是最新的数据。

若是从主同步的过程网络出故障了，导致主从同步失败，也会出现问题数据一致性的问题。

主从模式不具备自动容错和恢复的功能，一旦主数据库，从节点晋升为主数据库的过程需要人为操作，维护的成本就会升高，并且主节点的写能力、存储能力都会受到限制。

## 旧版复制功能的实现

- **同步操作**（sync）**：**用于将从服务器的数据库状态**更新至**主服务器当前所处的数据库状态
- **命令传播操作**（command propagate）**：**则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库**重新回到一致状态**

#### 同步

- **概念：**当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，**将从服务器的数据库状态更新至主服务器当前所处的数据库状态**

- **SYNC命令：**

    从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：

    - ①从服务器向主服务器**发送SYNC命令**
    - ②收到SYNC命令的主服务器**执行BGSAVE命令，在后台生成一个RDB文件**，并使用一 个缓冲区记录从现在开始执行的所有写命令
    - ③当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的**RDB文件发送给从服务器**，从服务器**接收并载入**这个RDB文件，将自己的数据库状态更新至主服务器 执行BGSAVE命令时的数据库状态
    - ④主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写 命令，将自己的数据库状态更新至主服务器数据库当前所处的状态

- 下图展示了SYNC命令执行期间，主从服务器的通信过程：

![20191201105150863](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105150863.png)

#### 命令传播

- 在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并**导致主从服务器状态不再一致**
- 为了让主从服务器再次回到一致状态，**主服务器需要对从服务器执行命令传播操作：**主 服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态
- 例如，主服务器执行了DEL k3的命令，那么主服务器将向从服务器发送相同的命令DEL k3，当从服务器执行完这个命令之后，主从服务器将再次回到一致状态，现在主从服务器两者的数据库都不再包含键k3了。

#### 缺陷

旧版复制功能在处理断线重复制情况时低效

在Redis中，**从服务器对主服务器的复制可以分为以下两种情况：**

- **初次复制：**从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务 器和上一次复制的主服务器不同。
- **断线后重复制：**处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务 器通过自动重连接重新连上了主服务器，并继续复制主服务器

![20191201105727757](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201105727757.png)

**为什么网络断开之后重新复制效率低，以上面的演示案例为例：**

- 主从服务器在时间T0至时间T10086中一直处于一致状态，这两个服务器保存的数据**大部分都是相同的**
- 从服务器想要将自己更新至主服务器当前所处的状态，**真正需要的是主从服务器连接中断期间**，主服务器新添加的k10087、k10088、k10089三个键的数据
- 可惜的是，旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键k1至键k10089的RDB文件，但实际上RDB文件包含的键k1至键k10086的数据对于从服务器来说都是不必要的

主从服务器断开的时 间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数 据，**却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的**

## 新版复制功能的实现

- 为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，**使用PSYNC命令代替SYNC命令**来执行复制时的同步操作
- **PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：**
    - **完整重同步：**用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步 骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步
    - **部分重同步：**则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态
- PSYNC命令的部分重同步模式**解决了旧版复制功能在处理断线后重复制时出现的低效情况**

**执行部分重同步所需的资源比起执行SYNC命令所需的资源要少得多**，完成同步的速度也快得多。执行SYNC命令需要生成、传送和载入整个RDB文件，而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了

## 部分重同步的实现

**同步功能由以下三个部分构成：**

- 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量
- 主服务器的复制积压缓冲区（replication backlog）
- 服务器的运行ID（run ID）

#### 复制偏移量

- 执行复制的双方——主服务器和从服务器会**分别维护一个复制偏移量：**

    - 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N
    - 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N

- 通过对比主从服务器的复制偏移量，

    **程序可以很容易地知道主从服务器是否处于一致状态：**

    - 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的
    - 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态

在下图所示的例子中，主从服务器的复制偏移量的值都为10086

![](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121350757.png)

如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121359413.png)

#### 复制积压缓冲区

- 复制积压缓冲区是由主服务器维护的一个**固定长度（fixed-size）先进先出（FIFO）队列**，默认大小为1MB
- 当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会**将写命令入队到复制积压缓冲区里面**，如下图所示：
- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121909779.png)
- 因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会**为队列中的每个字节记录相应的复制偏移量**
- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121943503.png)
- 当从服务器重新连上主服务器时，从服务器会通过PSYNC命令**将自己的复制偏移量offset发送给主服务器**，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操 作：
    - 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）**仍然存在于复制积压缓冲区里面**，那么主服务器将对从服务器执行部分重同步操作
    - 相反，如果offset偏移量之后的数据**已经不存在于复制积压缓冲区**，那么主服务器将对从服务器执行完整重同步操作

**演示案例：**

- 回到之前上面图片所展示的断线后重连接例子：
- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201121522212.png)
- 当从服务器A断线之后，它立即重新连接主服务器，并**向主服务器发送PSYNC命令，报告自己的复制偏移量为10086**
- 主服务器收到从服务器发来的PSYNC命令以及偏移量10086之后，主服务器将**检查偏移量10086之后的数据是否存在于复制积压缓冲区里面**，结果发现**这些数据仍然存在**，于是主服务器向从服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行
- 接着主服务器会将复制积压缓冲区10086偏移量之后的**所有数据（偏移量为10087至 10119）都发送给从服务器**
- 从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态，如下图所示
- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201122209306.png)

#### 服务器运行ID

- 除了复制偏移量和复制积压缓冲区之外，

    **实现部分重同步还需要用到服务器运行ID（run ID）：**

    - 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID
    - 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3

- 当从服务器对主服务器**进行初次复制时**，主服务器会**将自己的运行ID传送给从服务器**， 而从服务器则会将**这个运行ID保存起来**

- 当从服务器断线并重新连上一个主服务器时，**从服务器将向当前连接的主服务器发送之前保存的运行ID：**

    - 如果从服务器保存的运行ID和当前连接的主服务器的**运行ID相同**，那么说明从服务器 断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作
    - 相反地，如果从服务器保存的运行ID和当前连接的主服务器的**运行ID并不相同**，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作

- 举个例子，假设从服务器原本正在复制一个运行ID为 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3的主服务器，那么在网络断开，从服务器重新连 接上主服务器之后，从服务器将向主服务器发送这个运行ID，主服务器根据自己的运行ID是 否53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3来判断是执行部分重同步还是执行完整重同步

## PSYNC命令的实现

#### PSYNC命令的调用方法有两种：

- 如果从服务器**以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令：**那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器**进行完整重同步**（因为这时不可能执行部分重同步）

- 如果从服务器**已经复制过某个主服务器**

    ，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC <runid> <offset>命令：

    - 其中runid是上一次复制的主服务器的运行 ID，而offset则是从服务器当前的复制偏移量
    - 接收到这个命令的主服务器会**通过这两个参数来判断应该对从服务器执行哪种同步操作**



#### 接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：

- 如果**主服务器返回+FULLRESYNC  回复**，那么**表示主服务器将与从服务器执行完整重同步操作：**其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起 来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器 会将这个值作为自己的初始化偏移量
- 如果**主服务器返回+CONTINUE回复**，那么表示**主服务器将与从服务器执行部分重同步操作**，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了
- 如果**主服务器返回-ERR回复**，那么表示主服务器的版本低于Redis 2.8，**它识别不了PSYNC命令**，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作



#### 流程图

- 下面的流程图总结了PSYNC命令执行完整重同步和部分重同步时可能遇上的情况：
- ![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201123546284.png)



#### 演示案例

为了熟悉PSYNC命令的用法，让我们来看一个完整的复制——网络中断——重复制例 子

- 首先，假设有两个Redis服务器，它们的版本都是Redis 2.8，其中主服务器的地址为 127.0.0.1:6379，从服务器的地址为127.0.0.1:12345
- 如果客户端向从服务器发送命令SLAVEOF 127.0.0.1 6379，并且假设从服务器是第一次 执行复制操作，那么从服务器将向主服务器发送PSYNC ? -1命令，请求主服务器执行完整重 同步操作
- 主服务器在收到完整重同步请求之后，将在后台执行BGSAVE命令，并向从服务器返回 +FULLRESYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 10086回复，其中 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3是主服务器的运行ID，而10086则是主服务器当 前的复制偏移量
- 假设完整重同步成功执行，并且主从服务器在一段时间之后仍然保持一致，但是在复制 偏移量为20000的时候，主从服务器之间的网络连接中断了，这时从服务器将重新连接主服 务器，并再次对主服务器进行复制。
- 因为之前曾经对主服务器进行过复制，所以从服务器将向主服务器发送命令PSYNC 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3 20000，请求进行部分重同步
- 主服务器在接收到从服务器的PSYNC命令之后，首先对比从服务器传来的运行 ID53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3和主服务器自身的运行ID，结果显示该ID和 主服务器的运行ID相同，于是主服务器继续读取从服务器传来的偏移量20000，检查偏移量 为20000之后的数据是否存在于复制积压缓冲区里面，结果发现数据仍然存在
- 确认运行ID相同并且数据存在之后，主服务器将向从服务器返回+CONTINUE回复，表 示将与从服务器执行部分重同步操作，之后主服务器会将保存在复制积压缓冲区20000偏移 量之后的所有数据发送给从服务器，主从服务器将再次回到一致状态



## 复制的实现

#### 步骤1:设置主服务器的地址和端口

当客户端向从服务器发送以下命令时:`SLAVEOF 127.0.0.1 6379`

从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379**保存到服务器状态的masterhost属性和masterport属性里面**

```c
struct redisServer
{
	char * masterhost;//主服务器的地址
	int masterport;//主服务器的端口号
};
```

**SLAVEOF命令是一个异步命令**，在完成masterhost属性和masterport属性的设置工作之 后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而**实际的复制工作将在OK返回之后才真正开始执行**

#### 步骤2:建立套接字连接

- 在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，**创建连向主服务器的套接字连接**，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131155414.png)

- 如果**从服务器创建的套接字能成功连接（connect）到主服务器**，那么从服务器将为这个套接字关联一个专门**用于处理复制工作的文件事件处理器**，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类
- 而**主服务器在接受（accept）从服务器的套接字连接之后**，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器（server）和客户端（client）两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131243941.png)

- 因为复制工作接下来的几个步骤都会以从服务器向主服务器发送命令请求的形式来进 行，所以**理解“从服务器是主服务器的客户端”这一点非常重要**

#### 步骤3:发送PING命令

- 从服务器成为主服务器的客户端之后，做的第一件事就是**向主服务器发送一个PING命令**，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131333757.png)

- **这个PING命令有两个作用：**
    - 虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信， 通过发送PING命令可以**检查套接字的读写状态是否正常**
    - 因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以**检查主服务器能否正常处理命令请求**
- **从服务器在发送PING命令之后将遇到以下三种情况的其中一种：**
    - 如果主服务器向从服务器返回了一个命令回复，但从服务器却**不能在规定的时限 （timeout）内读取出命令回复的内容**，那么表示主从服务器之间的网络连接状态不佳，不能 继续执行复制工作的后续步骤。当出现这种情况时，从服务器**断开并重新创建**连向主服务器 的套接字
    - 如果主服务器**向从服务器返回一个错误**，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，**从服务器断开并重新创建连向主服务器的套接字**。比如说，如果主服务器正在处理一个超时运行的脚本，那么当从 服务器向主服务器发送PING命令时，从服务器将收到主服务器返回的BUSY Redisis busy running a script.You can only call SCRIPT KILL or SHUTDOWN NOSAVE.错误
    - 如果从服务器**读取到"PONG"回复**，那么表示主从服务器之间的网络连接状态正常，并 且主服务器可以正常处理从服务器（客户端）发送的命令请求，在这种情况下，从服务器可 以继续执行复制工作的下个步骤
- 下面的流程图总结了从服务器在发送PING命令时可能遇到的情况，以及各个情况的处理方式

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131558981.png)

#### 步骤4:身份验证

- 从服务器在收到主服务器返回的"PONG"回复之后，

    **下一步要做的就是决定是否进行身份验证：**

    - 如果从服务器设置了masterauth选项，那么进行身份验证
    - 如果从服务器没有设置masterauth选项，那么不进行身份验证

- 在需要进行身份验证的情况下，**从服务器将向主服务器发送一条AUTH命令**，命令的**参数为从服务器masterauth选项的值**

- 举个例子，如果从服务器masterauth选项的值为10086，那么从服务器将向主服务器发送 命令AUTH 10086，如下图所示

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201131632595.png)

#### 步骤5:发送端口信息

- 在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port ， **向主服务器发送从服务器的监听端口号**
- 例如在我们的例子中，从服务器的监听端口为12345，那么从服务器将**向主服务器发送命令REPLCONF listening-port 12345**，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113200247.png)

#### 步骤6:同步

- 在这一步，从服务器将向主服务器发送PSYNC命令，***\*执行同步操作\****，并**将自己的数据库更新至主服务器数据库当前所处的状态**

- 值得一提的是，在同步操作执行之前，只有从服务器是主服务器的客户端，但是

    **在执行同步操作之后，主服务器也会成为从服务器的客户端：**

    - 如果PSYNC命令执行的是**完整重同步操作**，那么主服务器需要成为从服务器的客户 端，才能将保存在缓冲区里面的写命令发送给从服务器执行。
    - 如果PSYNC命令执行的是**部分重同步操作**，那么主服务器需要成为从服务器的客户 端，才能向从服务器发送保存在复制积压缓冲区里面的写命令

- 因此，在同步操作执行之后，**主从服务器双方都是对方的客户端**，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120113224549.png)

- 正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命 令传播操作的基础

#### 步骤7:命令传播

- 当完成了同步之后，**主从服务器就会进入命令传播阶段**，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就**可以保证主从服务器一直保持一致了**



## 心跳检测

- 在命令传播阶段，从服务器默认会**以每秒一次的频率**，向主服务器发送命令：

```bash
REPLCONF ACK <replication_offset>
//其中replication_offset是从服务器当前的复制偏移量
```

- **发送REPLCONF ACK命令对于主从服务器有三个作用：**
    - ①检测主从服务器的网络连接状态
    - ②辅助实现min-slaves选项
    - ③检测命令丢失

#### 检测主从服务器的网络连接状态（lag标志）

- 主从服务器可以通过发送和接收REPLCONF ACK命令**来检查两者之间的网络连接是否正常：**如果主服务器**超过一秒钟没有收到**从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了
- 通过向主服务器发送**INFO replication命令**，在列出的**从服务器列表的lag一栏中**，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令**距离现在过了多少秒。**在一般情况下，**lag的值应该在0秒或者1秒之间跳动**，如果超过1秒的话，那么说明主从 服务器之间的连接出现了故障。

#### 辅助实现min-slaves配置选项

- Redis的**min-slaves-to-write和min-slaves-max-lag两个选项**可以**防止主服务器在不安全的情况下执行写命令**
- 举个例子，如果我们向主服务器提供以下设置：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201132859439.png)

- 那么在**从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时**，主服务器将**拒绝执行写命令**，这里的延迟值就是上面提到的INFO replication命令的lag 值

#### 检测命令丢失

如果因为网络故障，**主服务器传播给从服务器的写命令在半路丢失**，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将**发觉**从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里 面找到从服务器缺少的数据，并**将这些数据重新发送给从服务器**

#### 演示案例

- 举个例子，假设有两个处于一致状态的主从服务器，它们的复制偏移量都是200，如下图所示

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133107682.png)

- 如果这时主服务器执行了命令SET key value（协议格式的长度为33字节），将自己的复 制偏移量更新到了233，并尝试向从服务器传播命令SET key value，但这条命令却因为网络 故障而在传播的途中丢失，那么主从服务器之间的复制偏移量就会出现不一致，主服务器的 复制偏移量会被更新为233，而从服务器的复制偏移量仍然为200，如下图所示

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133127229.png)

- 在这之后，当从服务器向主服务器发送REPLCONF ACK命令的时候，主服务器会察觉 从服务器的复制偏移量依然为200，而自己的复制偏移量为233，这说明复制积压缓冲区里面 复制偏移量为201至233的数据（也即是命令SET key value）在传播过程中丢失了，于是主服 务器会再次向从服务器传播命令SET key value，从服务器通过接收并执行这个命令可以将自 己更新至主服务器当前所处的状态，如下图所示

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201133147307.png)

# Redis哨兵

## Sentinel

#### 优点

哨兵模式是主从的升级版，因为主从的出现故障后，不会自动恢复，需要人为干预。

在主从的基础上，实现哨兵模式就是为了监控主从的运行状况，对主从的健壮进行监控，就好像哨兵一样，只要有异常就发出警告，对异常状况进行处理。

总的概括来说，哨兵模式有以下的优点(功能点)：

- 「监控」：监控master和slave是否正常运行，以及哨兵之间也会相互监控
- 「自动故障恢复」：当master出现故障的时候，会自动选举一个slave作为master顶上去。
- 哨兵模式是主从模式的升级版，所以在系统层面提高了系统的可用性和性能、稳定性。当master宕机的时候，能够自动进行故障恢复，需不要人为的干预。
- 哨兵与哨兵之间、哨兵与master之间能够进行及时的监控，心跳检测，及时发现系统的问题，这都是弥补了主从的缺点。

#### 缺点

哨兵一主多从的模式同样也会遇到写的瓶颈，已经存储瓶颈，若是master宕机了，故障恢复的时间比较长，写的业务就会受到影响。

增加了哨兵也增加了系统的复杂度，需要同时维护哨兵模式。

#### 简介

Sentinel（哨岗、哨兵）是**Redis的高可用性（high availability）解决方案：**由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以**监视任意多个**主服务器，以及这些主服务器属下的所有从服务器，并在被监视的**主服务器进入下线状态时**，自动将下线主服务器属下的某个从服务器**升级为新的主服务器**，然后由新的主服务器代替已下线的主服务器继续处理命令请求



![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201213815316.png)



- 根据上面的图片，假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对 主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如下图所示（下线的服务器用虚线表示）

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214010487.png)

- 当server1的**下线时长超过用户设定的下线时长上限时**，Sentinel系统就会对server1执行**故障转移**

    操作：

    - 首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器
    - 之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕
    - 另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器

- 举个例子，下图展示了Sentinel系统**将server2升级为新的主服务器**，并让服务器server3和server4成为server2的从服务器的过程

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214149843.png)

- 之后，如果server1**重新上线的话**，它将被Sentinel系统**降级为server2的从服务器**，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201214154597.png)

## 启动并初始化Sentinel

启动`Sentinel`会执行以下操作：

1. 初始化服务器
2. 将普通Redis服务器使用的代码替换成`Sentinel`专用代码
3. 初始化`Sentinel`状态
4. 根据给定的配置文件,初始化`Sentinel`的监视主服务器列表
5. 创建连向主服务器的网络连接

#### 初始化Sentinel状态

在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个**sentinel.c/sentinelState结构**（后面简称“Sentinel状态”），这个结构**保存了服务器中所有和Sentinel功能有关的状态** （服务器的一般状态仍然由redis.h/redisServer结构保存）

```c
struct sentinelState {
    //当前纪元，用于实现故障转移
    uint64_t current_epoch;
 
    //保存了所有被这个sentinel 监视的主服务器
    dict *masters;
    
    //略
} sentinel;
```


#### 初始化Sentinel状态的masters属性

Sentinel状态中的**masters字典记录了所有被Sentinel监视的主服务器的相关信息**，其中：

- **字典的键**是被监视主服务器的名字
- **字典的值**则是被监视主服务器对应的sentinel.c/**sentinelRedisInstance结构**



- 每个sentinelRedisInstance结构（后面简称“实例结构”）**代表一个被Sentinel监视的Redis服务器实例**（instance），这个实例可以是**主服务器、从服务器，或者另外一个Sentinel**

```c
typedef struct sentinelRedisInstance {
    //标识值，记录了实例的类型，以及该实例的当前状态
    int flags;
 
    //实例的名字
    //主服务器的名字由用户在配置文件中设置
    //从服务器以及Sentinel 的名字由Sentinel 自动设置
    //格式为ip:port ，例如"127.0.0.1:26379"
    char *name;
 
    //实例的运行ID
    char *runid;
 
    //配置纪元，用于实现故障转移
    uint64_t config_epoch;
 
    //实例的地址
    sentinelAddr *addr;
} sentinelRedisInstance;
```

```c
struct sentinelAddr
{
	char * ip;
	int port;
}
```

###### 例子

- 对Sentinel状态的初始化将引发对masters字典的初始化，而masters字典的初始化是**根据被载入的Sentinel配置文件**来进行的

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201220900699.png)

#### 创建连向主服务器的网络连接

- 初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，**Sentinel将成为主服务器的客户端**，它可以向主服务器发送命令，并从命令回复中获取相关的信息

- 对于每个被Sentinel监视的主服务器来说，Sentinel会

    **创建两个连向主服务器的异步网络连接：**

    - 一个是**命令连接**，这个连接专门用于向主服务器发送命令，并接收命令回复
    - 另一个是**订阅连接**，这个连接专门用于订阅主服务器的__sentinel__:hello频道



## 获取主服务器的信息

- Sentinel默认会以**每十秒一次的频率**，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来**获取主服务器的当前信息**

- 通过分析主服务器返回的INFO命令回复，**Sentinel可以获取以下两方面的信息：**
    - 一方面是**关于主服务器本身的信息**，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色
    - 另一方面是关于主服务器属下**所有从服务器的信息**，每个从服务器都由一个"slave"字符 串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端 口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器
- **根据run_id域和role域记录的信息，Sentinel将对主服务器的实例结构进行更新**，例如， 主服务器重启之后，它的运行ID就会和实例结构之前保存的运行ID不同，Sentinel检测到这 一情况之后，就会对实例结构的运行ID进行更新
- Sentinel在分析INFO命令中包含的从服务器信息时，**会检查从服务器对应的实例结构是否已经存在于slaves字典：**
    - 如果**从服务器对应的实例结构已经存在**，那么Sentinel对从服务器的实例结构进行更新
    - 如果**从服务器对应的实例结构不存在**，那么说明这个从服务器是新发现的从服务器， Sentinel会在slaves字典中为这个从服务器新创建一个实例结构

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191201223205478.png)

## 获取从服务器信息

- 当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的**从服务器创建相应的实例结构之外**，Sentinel还会创建连接到从服务器的**命令连接和订阅连接**
- 举个例子，对于上面那张图所示的主从服务器关系来说，Sentinel将对slave0、slave1和 slave2三个从服务器分别创建命令连接和订阅连接，如下图所示：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019120122373496.png)

**根据INFO命令的回复，Sentinel会提取出以下信息：**

- 从服务器的运行ID run_id
- 从服务器的角色role
- 主服务器的IP地址master_host，以及主服务器的端口号master_port
- 主从服务器的连接状态master_link_status
- 从服务器的优先级slave_priority
- 从服务器的复制偏移量slave_repl_offset

## Sentinel向主服务器和从服务器发送信息

在默认情况下，Sentinel会以**每两秒一次的频率**，通过命令连接向所有被监视的**主服务器和从服务器**发送命令

对于监视同一个服务器的多个Sentinel来说，**一个Sentinel发送的信息会被其他Sentinel接收到**，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。

## Sentinel接收服务器和从服务器的频道信息

当一个Sentinel从__sentinel__:hello频道收到一条信息时，Sentinel会对这条信息进行分 析，**提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：**

- 如果信息中记录的Sentinel运行ID和接收信息的Sentinel的**运行ID相同**，那么说明这条信 息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理
- 相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的**运行ID不相同**，那么 说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，**对相应主服务器的实例结构进行更新**
- 因为一个Sentinel可以通过分析接收到的频道信息来**获知其他Sentinel的存在**，并通过发送频道信息来**让其他Sentinel知道自己**的存在，所以用户在使用Sentinel的时候并不需要提供各个Sentinel的地址信息，监视同一个主服务器的多个Sentinel**可以自动发现对方**
- 当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，**还会创建一个连向新Sentinel的命令连接**，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的**多个Sentinel将形成相互连接的网络：**Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202184847281.png)

## 检测主观下线状态

- 在默认情况下，Sentinel会**以每秒一次的频率**向所有与它创建了命令连接的实例（**包括主服务器、从服务器、其他Sentinel在内**）发送**PING命令**，并通过实例返回的PING命令回复来判断实例是否在线
- 如果配置文件指定Sentinel1的**down-after-milliseconds选项的值为50000毫秒**，那么当主服务器master连续50000毫秒都向Sentinel1**返回无效回复时**， Sentinel1就会将master标记为主观下线

## 检测客观下线状态

- 当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线 了，它会**向同样监视这一主服务器的其他Sentinel进行询问**，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里**接收到足够数量的已下线判断之后**，Sentinel就会将从服务器判定为客观下线，并对主服务器**执行故障转移操作**

## 选取领头Sentinel

- 当一个主服务器被判断为客观下线时，监视这个下线主服务器的**各个Sentinel会进行协商**，选举出一个领头Sentinel，并由领头Sentinel**对下线主服务器执行故障转移操作**

- 1.**所有在线的Sentinel都有被选为领头Sentinel的资格**，换句话说，监视同一个主服务器的 多个在线Sentinel中的任意一个都有可能成为领头Sentinel
- 2.每次进行领头Sentinel选举之后，**不论选举是否成功，所有Sentinel的配置纪元 （configuration epoch）的值都会自增一次**。配置纪元实际上就是一个计数器，并没有什么特别的
- 3.在一个配置纪元里面，**所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会**，并且局部领头一旦设置，在这个配置每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel
- 4.当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送**SENTINEL ismaster-down-by-addr命令**，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这**表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel**
- 5.Sentinel设置局部领头Sentinel的规则是先到先得：**最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头**Sentinel，而**之后接收到的所有设置要求都会被目标Sentinel拒绝**
- 6.目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，**将向源Sentinel返回 一条命令回复，**回复中的leader_runid参数和leader_epoch参数分别**记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元**
- 7.源Sentinel在接收到目标Sentinel返回的命令回复之后，**会检查回复中leader_epoch参数的值和自己的配置纪元是否相同**，如果相同的话，那么源Sentinel继续取出回复中的 leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标 Sentinel将源Sentinel设置成了局部领头Sentinel
- 8.如果**有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel**。举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于 10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成 为领头Sentine
- 9.因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，**所以在一个配置纪元里面，只会出现一个领头 Sentinel**
- 10.如果在给定时限内，**没有一个Sentinel被选举为领头Sentinel**，那么各个Sentinel将在一段时间之后**再次进行选举**，直到选出领头Sentinel为止

## 故障转移

- 在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器**执行故障转移操作**
- **该操作包含下面3个步骤：**
    - ①在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器
    - ②让已下线主服务器属下的所有从服务器改为复制新的主服务器
    - ③将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线 时，它就会成为新的主服务器的从服务器

#### 选出新的主服务器

- 故障转移操作第一步要做的就是**在已下线主服务器属下的所有从服务器中**，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送**SLAVEOF no one命令**，将这个**从服务器转换为主服务器**

###### 演示案例

- 下图展示了在一次故障转移操作中，领头Sentinel向**被选中的从服务器server2**发送SLAVEOF no one命令的情形：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193156859.png)

- 在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一 次），向被升级的从服务器**发送INFO命令，**并观察命令回复中的角色（role）信息，**当被升级服务器的role从原来的slave变为master时**，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了

#### 修改从服务器的复制目标

- 当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的**所有从服务器去复制新的主服务器**，这一动作可以**通过向从服务器发送SLAVEOF命令来实现**

###### 图示

- 下图展示了在故障转移操作中，领头Sentinel向已下线主服务器server1的两个从服务器server3和server4发送SLAVEOF命令，让**它们复制新的主服务器server2的例子**

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193616934.png)

- 下图展示了**server3和server4成为server2的从服务器之后**，各个服务器以及领头Sentinel的样子

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193633254.png)

#### 将旧的主服务器变为从服务器

- 故障转移操作最后要做的是，**将已下线的主服务器设置为新的主服务器的从服务器**。比如说，下图就展示了被领头Sentinel设置为从服务器之后，服务器server1的样子

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193748287.png)

- 因为旧的主服务器已经下线，所以这种设置是保存在server1对应的实例结构里面的，当 server1重新上线时，**Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器**
- 例如，下图就展示了server1重新上线并成为server2的从服务器的例子

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20191202193757739.png)



# Redis集群

###### 优点

最后，Cluster是真正的集群模式了，哨兵解决和主从不能自动故障恢复的问题，但是同时也存在难以扩容以及单机存储、读写能力受限的问题，并且集群之前都是一台redis都是全量的数据，这样所有的redis都冗余一份，就会大大消耗内存空间。

集群模式实现了Redis数据的分布式存储，实现数据的分片，每个redis节点存储不同的内容，并且解决了在线的节点收缩(下线)和扩容(上线)问题。

集群模式真正意义上实现了系统的高可用和高性能，但是集群同时进一步使系统变得越来越复杂，接下来我们来详细的了解集群的运作原理。

集群模式是一个无中心的架构模式，将数据进行分片，分布到对应的槽中，每个节点存储不同的数据内容，通过路由能够找到对应的节点负责存储的槽，能够实现高效率的查询。

并且集群模式增加了横向和纵向的扩展能力，实现节点加入和收缩，集群模式是哨兵的升级版，哨兵的优点集群都有。

###### 缺点

缓存的最大问题就是带来数据一致性问题，在平衡数据一致性的问题时，兼顾性能与业务要求，大多数都是以最终一致性的方案进行解决，而不是强一致性。

并且集群模式带来节点数量的剧增，一个集群模式最少要6台机，因为要满足半数原则的选举方式，所以也带来了架构的复杂性。

slave只充当冷备，并不能缓解master的读的压力。

#### 基本信息

- Redis Cluster是去中心化的，例如一个集群由三个Redis节点组成，每个节点负责整个集群的一部分数据。这三个节点就相互连接组成一个对等的集群，他们之间通过一种特殊的二进制协议交互集群信息。

- 所有数据划分为16384个槽位，每个节点负责其中一部分槽位，槽位的信息存储在每个节点中

- 客户端为了可以直接定位到某个具体的key所在的节点，需要缓存槽位相关信息，这样才可以准确快速地定位到相应的节点。同时因为可能会存在客户端与服务器存储槽位的信息不一致的情况。还需要纠正机制来实现槽位信息的校验调整

- 当客户端向一个错误的节点发出了指令后，该节点会发现指令的key所在的槽位并不归自己管理，这时他会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连接这个节点以获取数据

- ```
    GET x
    -MOVED 3999 127.0.0.1:6381
    //MOVED的一个参数3999是key对应的槽位编号，后面是目标节点的地址。
    //MOVED指令前面有一个减号，表示该指令是一个错误消息
    //客户端收到MOVED指令后，要立即纠正本地的槽位映射表。
    //后续所有key将使用新的槽位映射表
    ```

    

- 

#### 理解

在Redis主从复制中介绍过利用主从节点实现读写分离来扩展主节点的数据读取能力，那么当主节点的写入能力成为瓶颈时，集群便是性能扩展的解决方案之一。Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。集群设计，本质上来讲是把数据存储在不同的数据节点上，这些节点可以独立的向外提供服务，那么需要解决的最重要几个问题是

- 当新的写入数据到达时，该数据应该存储在哪台机器上。即数据分布问题
- 当新的查询请求到达时，我们该如何知道这部分数据存储在哪个机器节点上。即查询路由问题。
- 当新的节点加入时，我们该如何重新分配数据，让新的节点也对外提供服务。当有节点退出时，我们该如何把存在该节点上的数据分配到其他机器上，让其他机器来提供这部分数据的服务。即集群的扩缩容问题。
- 当有节点因故障而不能提供服务时，如何能保证该集群仍然能正常向外提供服务。即高可用问题。

#### 总结

对于分布式存储，数据分区规则是核心问题之一，Redis集群中使用的是虚拟槽/虚拟桶分区，使用CRC16函数计算每个键的哈希值，并把所有的键划分到16384个桶中。数据存储在各个结点之后，当客户端访问键时，需要能够知道键所在的节点地址，Redis集群没有采用代理的方案，而是每个节点都保存集群中槽的负责节点信息，客户端可连接任意一个节点，当该节点发现客户端请求的键并不由自己负责时，会向客户端返回重定向，重定向中包含着负责该键的节点地址信息。同路由信息一样，Redis的集群元数据信息也是存储在各个节点上，并使用Gossip协议来完成集群的元数据同步。每个集群节点会每100ms向部分节点随机传输自己视角下的N/10个节点的信息，同时Redis集群节点会努力保证自己与其他的所有节点每node_timeout/2时间内至少通信一次。

#### 数据分布

分布式数据库首先要解决地把整个数据集按照分区规则映射到多个节点地问题。即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。如下图所示：

![img](https://pic4.zhimg.com/80/v2-17d40b36ede8d8c4a3309306370f09f7_1440w.jpg)

分布式存储数据分区

Redis采用了虚拟桶分区方法，使用分散度良好地哈希函数把所有的数据均匀地哈希到K个桶中。具体实现中，Redis使用CRC16函数计算键的哈希值并把所有键分到16384个桶中，键的桶编号计算方法如下所示。每个桶**只能**由一个主节点存储，但一个主节点可以负责多个桶。Redis集群中，数据的迁移都是以桶为单位的，集群的扩缩容等价为桶在不同节点间的移动。

```text
HASH_SLOT = CRC16(key) mod 16384
//默认对key值使用crc16算法进行hash，得到一个整数值，然后用这个整数值对16384进行取模得到具体槽位
```

#### 查询路由

基于上述的分区方法，集群中的数据存储可能如下图所示。我们有5个节点，每个节点平均存储大约3273个桶（即16384/5）。那么当我们要进行一个键值的查询时，给定一个key，我们如何知道该key的值存储在哪个机器节点上呢？即我们需要一个查询路由，该路由根据给定的key，返回存储该键值的机器地址。

![img](https://pic2.zhimg.com/80/v2-1fe6033d4997d85449ce6764251923e1_1440w.jpg)5个节点，每个节点负责一部分桶

常规的实现方式便是采用如下图所示的代理方案，即采用一个中央节点（比如HDFS中的NameNode）来管理所有的元数据，但是这样的方案带来的最大问题就是代理节点很容易成为访问的瓶颈，当读写并发量高的时候，代理节点会严重的拖慢整个系统的性能。

![img](https://pic1.zhimg.com/80/v2-936c9a100eda3f1a2c79c10901134180_1440w.jpg)采用代理的方案实现路由

Redis没有选择使用代理，而是客户端直接连接每个节点。Redis的每个节点中都存储着如下所示的整个集群的状态，集群状态中一个重要的信息就是**每个桶的负责节点**。在具体的实现中，Redis用一个大小固定为CLUSTER_SLOTS的clusterNode数组 slots来保存每个桶的负责节点。在集群模式下，Redis接收任何键相关命令时首先**计算键对应的桶编号，再根据桶找出所对应的节点**，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，**通知客户端请求正确的节点，这个过程称为MOVED重定向**。重定向信息包含了键所对应的桶以及负责该桶的节点地址，根据这些信息客户端就可以向正确的节点发起请求。

这样的话，假设集群中有N个主节点存储数据，那么客户端要查询一个键时，一次就恰好访问到正确节点的概率只有1/N。有(N-1)/N的概率是要请求两次的，第一次随机连接一个节点获得正确的节点地址，第二次从正确的节点中获取数据。当请求并发量比较大时，我们就会浪费大量的节点处理时间。一种较好的方案是在客户端把ClusterState中的slots数据信息缓存起来，这样每次客户端计算出对应的桶之后，根据本地的缓存获得正确的节点位置。这样便可以避免大量不必要的重复请求。当然，如果集群发生了扩缩容或者failover导致客户端缓存的信息过期时，客户端只需要在访问节点得到**MOVED**重定向时，重新更新下本地的缓存信息即可。这种缓存slots信息的客户端就是**Smart Client**。

#### 集群扩容

当集群中发生扩缩容时会发生桶的迁移，比如当节点A正在把桶334迁移到节点B，那么在迁移完成之前，桶334的一部分数据存在节点A，一部分数据存在节点B。**在迁移完成之前，集群中的所有节点都仍然会认为桶334由节点A负责**。所以当访问桶334中的数据时，请求会被统一路由到节点A，如果A发现客户端访问的键并不在本地存储（可能已经被迁移到了节点B，或者该键之前就不存在），那么节点A就会向客户端返回**ASK重定向**。ASK重定向同样会返回**槽值和节点B的地址**，客户端会根据ASK返回的重定向地址向B发起请求，看看新节点存不存在数据。对客户端来说，MOVED和ASK重定向的区别在于，**当客户端收到MOVED重定向时会选择更新本地的缓存，但是接收到ASK重定向并不会更新本地缓存。**当节点A和节点B完成了桶334的迁移之后，**节点B会向整个集群广播自己目前负责的桶的信息，之后整个集群的其他节点就会认为桶334由B负责，此时如果客户端再向节点A访问桶334的数据，那么节点A就会返回MOVED重定向。**即ASK重定向只会在数据迁移的时候发生，同时客户端接收到ASK重定向之后并不会更新本地缓存。

ASK指令只是用来临时纠正槽位的，不会刷新槽位映射关系表，不影响后续指令。

#### 集群节点通信

**集群中所有节点的状态以及桶-节点映射关系构成集群的元数据**，许多分布式存储系统的元数据管理是采用专门的元数据管理节点的，比如HDFS中的Name Node，但是**Redis集群的元数据是保存在各个Redis节点。如果元数据保存在各个节点上，我们需要解决的最重要的问题是如何保证各个节点的元数据一致性。**第一种方法便是每个节点都向其他所有的节点广播自己的元数据内容及元数据版本。每个节点接收到其他节点的元数据之后，如果发现接收到的数据版本比本地的版本更新，便用接收到的数据来更新本地的数据。这样做的好处，便是元数据同步的速度会很快，一旦一个节点的元数据修改，只要网络不断，可以很快的向其他节点同步数据，但是这样带来的坏处就是通信量的剧增。所有集群中的N个节点构成了一个全连接图，那么如果每个节点每100ms进行一次全局广播，那么每一次广播都会广播N^2条信息，这将占据大量的带宽。

Redis采用**Gossip通信协议来进行集群元数据的同步**。Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息。每个Redis都会保存自己视角下的集群中其他节点的状态信息，具体实现中所有的节点信息都存储在clusterNode结构体中。那么使用Gossip协议，集群中的每个节点，每次会随机向几个节点传输自己视角下的集群其他节点状态。如果每次都传输所有的节点状态数据，那么数据体量又会过于庞大，于是Redis集群采用的最终的信息同步方式是： 一个大小为N的集群的每一个节点每次向随机K个其他节点传输自己视角下的随机M个节点的状态。其中M和K都远远小于N。

虽然Gossip协议的信息交换机制具有天然的分布式特性，但它是有成本的。由于内部需要频繁地进行节点信息交换，而ping/pong消息会携带当前节点和其他M个节点的状态数据，势必会加重带宽和计算的负担。Redis集群内节点通信采用固定频率（定时任务每秒执行10次）。因此节点每次选择需要通信的节点列表变得非常重要。通信节点K选择过大虽然可以做到信息及时交换但成本过高。节点选择K过小会降低集群内所有节点彼此信息交换频率，从而影响故障判定、新节点发现等需求的速度。因此Redis集群的Gossip协议需要兼顾信息交换实时性和成本开销。既然M和N最重要，那么我们就需要知道如何确定M和K的值，以及如何选出K个通信节点以及M个传输状态节点。

#### 容错

Redis Cluster可以为每个主节点设置若干个从节点，当主节点发生故障时，集群会自动将其中某个从节点提升为主节点。如果某个主节点没有从节点，那么当他发生故障时，集群将完全处于不可用状态。

#### 可能下线（PFail）与确认下线（Fail)

因为Cluster是去中心化的，一个节点认为某个节点失联了并不代表所有的节点都认为他失联了，所以集群还得经过一次协商的过程。只有大多数节点都认定某个节点失联了，集群才认为该节点需要进行主从切换来容错。

Redis集群节点采用Gossip协议来广播自己的状态以及改变整个集群的认知。比如一个节点发现某个节点失联了（Possibly Fail），他会将这条信息向整个集群广播，其他节点就可以收到这点的失联信息。

如果收到了某个节点失联的节点数量达到了集群的大多数，就可以标记该失联节点为确认下线状态。然后向整个集群广播，强迫其他节点也接收该节点已经下线的事实，并立即对该失联节点进行主从切换。