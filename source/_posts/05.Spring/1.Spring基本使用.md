---
title: Spring学习笔记
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: Spring学习笔记
categories: Spring学习笔记
tags:
  - Spring
  - 框架
  - Bean
abbrlink: 52ba89f4
date: 2020-08-04 00:00:00
---

# Spring概述

![image-20200818165454094](https://tongji4m3.oss-cn-beijing.aliyuncs.com/image-20200818165454094.png)

## 优点

**1.方便解耦，简化开发**

**2.AOP编程的支持**

**3.声明式事务的支持**

**4.方便程序的测试**

**5.方便集成各种优秀框架**

**6.降低Java EE API的使用难度**

**7.Java 源码是经典学习范例**

## Spring各个包
+ spring-core:包含Spring 框架基本的核心工具类，主要提供IOC依赖注入功能
+ spring-beans:IOC容器必备jar包，包含(IoC/DI）操作相关的所有类
+ spring-expression:表达式解析，支持在运行时动态的解析表达式给对象赋值
+ spring-aop:使用Spring 的AOP 特性时所需的类和源码级元数据支持
+ spring-context:可以找到使用Spring ApplicationContext特性时所需的全部类，会自动将 spring-core、spring-beans、spring-aop、spring-expression

# 设计模式

## 单例模式

Spring 通过 `ConcurrentHashMap` 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下:

```java
// 通过 ConcurrentHashMap（线程安全） 实现单例注册表
private final Map<String， Object> singletonObjects = new ConcurrentHashMap<String， Object>(64);

public Object getSingleton(String beanName， ObjectFactory<?> singletonFactory) {
        synchronized (this.singletonObjects) {
            // 检查缓存中是否存在实例  
            Object singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
                try {
                    singletonObject = singletonFactory.getObject();
                }
                // 如果实例对象在不存在，我们注册到单例注册表中。
                addSingleton(beanName， singletonObject);
            }
            return (singletonObject != NULL_OBJECT ? singletonObject : null);
        }
    }
    //将对象添加到单例注册表
    protected void addSingleton(String beanName， Object singletonObject) {
            synchronized (this.singletonObjects) {
                this.singletonObjects.put(beanName， (singletonObject != null ? singletonObject : NULL_OBJECT));
            }
        }
}
```

# 事务

在没有Spring帮我们管理事务之前，做法:

```java
Connection conn = DriverManager.getConnection();
try {  
    conn.setAutoCommit(false);  //将自动提交设置为false                         
    执行CRUD操作 
    conn.commit();      //当两个操作成功后手动提交  
} catch (Exception e) {  
    conn.rollback();    //一旦其中一个操作出错都将回滚，所有操作都不成功
    e.printStackTrace();  
} finally {
    conn.colse();
}
```

事务是一系列的动作，一旦其中有一个动作出现错误，必须全部回滚，系统将事务中对数据库的所有已完成的操作全部撤消，滚回到事务开始的状态，避免出现由于数据不一致而导致的接下来一系列的错误。事务的出现是为了确保数据的完整性和一致性，在目前企业级应用开发中，事务管理是必不可少的。

Spring事务的本质其实就是数据库对事务的支持，使用JDBC的事务管理机制,就是利用java.sql.Connection对象完成对事务的提交

声明式事务基于 AOP,将具体业务逻辑与事务处理解耦。声明式事务管理使业务代码逻辑不受污染, 因此在实际使用中声明式事务用的比较多。

## @Transactional 注解管理事务的实现步骤

使用@Transactional 注解管理事务的实现步骤分为两步。第一步，@EnableTransactionManagement 注解启用事务管理功能。第二步，将@Transactional 注解添加到合适的方法上

例如:

在配置中开启事务支持

```java
@Configuration
@EnableTransactionManagement
@MapperScan({"com.tongji.boying.mapper", "com.tongji.boying.dao"})
public class MyBatisConfig {
}
```
添加订单时开启事务
```java
public interface BoyingOrderService {
    @Transactional
    void add(UserOrderParam param);
}
```
