---
title: Schema与数据类型优化
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: Mysql学习笔记--Schema与数据类型优化
categories: Mysql学习笔记
tags:
  - Mysql
  - 数据类型
  - VARCHAR
abbrlink: 26ac1f1c
date: 2020-06-13 00:00:00
---

# 选择优化的数据类型

1. 尽量使用可以正确存储数据的最小数据类型
2. 尽量使用简单的数据类型.应使用内建的类型而不是字符串存储日期和时间,用整型存储IP地址
3. 尽量避免NULL,通常情况最好指定为NOT NULL

## 整数类型

TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT 分别占8位,16位,24位,32位,64位

整数计算一般采用64位的BIGINT整数

INT(11)这些为整数类型指定宽度对大多数应用没有意义

## 实数类型

1. FLOAT,DOUBLE类型支持使用标准的浮点运算进行近似运算.DECIMAL类型用于存储精确的小数
2. DECIMAL可以指定小数点前后所允许的最大位数,例如DECIMAL(18,9)
3. 建议只指定数据类型,不指定精度
4. FLOAT占用4字节,DOUBLE占用8字节.尽量只在对小数进行精确计算时才采用DECIMAL

## 字符串类型

### VARCHAR,CHAR类型
1. VARCHAR存储可变长字符串,只使用必要的空间,比定长类型节省空间。字符串列的最大长度比平均长度大很多，列的更新很小采用VARCHAR比较合适。只分配需要的空间，例如VARCHAR（5），VARCHAR（200），能用前者就不要用后者了
2. CHAR为定长类型，适合存储很短的字符串，或者所有值接近一个长度，或者经常变动的数据
### BLOB和TEXT类型
为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。
## 日期和时间类型
### DATETIME
保存大范围的值，精度为秒。把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，一般显示为:"2008-01-16 22:37:08"
### TIMESTAMP
保存从1970.1.1以来的秒数，尽量使用它，因为他比DATETIME空间效率更高
## 位数据类型
### BIT
谨慎使用，如果想用一个bit存储false/true，可以创建CHAR(0),该列可以保存空值或者空字符串
### ENUM和SET
小心使用，不要滥用，有时会变成陷阱

## 选择标识列

1. 一旦选定了一种类型,要确保在所有关联表中使用同样的类型
2. 在满足值的范围的需求,并且预留未来的增长空间的前提下,应该选择最小的数据类型
3. 一般标识列选整数类型,很快而且可以`AUTO_INCREMENT`.
4. 标识列避免使用字符串类型,消耗空间而且很慢.用UUID就更慢

# MySQL schema设计中的陷阱

## 太多的列

如果计划使用数千个字段,必须意识到服务器的性能运行特征会有一些不同

## 太多的关联

如果希望查询执行得快速而且并发性好,单个查询最好在12个表之内做关联

## Not Invent Here Null

虽然尽量避免使用Null,有时可以用0,特殊值,空字符串代替,但是别走极端

# 范式与反范式

在范式化数据库中,每个事实数据有且仅有出现一次.相反,在反范式数据库中,信息是冗余的,可能会存储在多个地方

## 范式优缺点

### 优点

1. 更新操作快
2. 只有很少或者没有重复数据,只需要修改很少的数据
3. 表通常更小,更好放在内存里,执行操作更快
4. 很少有多余数据,检索列表数据时更少需要`DISTINCT`,`GROUP BY`

### 缺点

通常需要关联,代价昂贵,也可能使得一些索引策略失效

## 反范式优缺点

数据都在一张表中,可以很好的避免关联

## 混用范式化与反范式化
最常见的反范式化数据是复制和缓存,在不同表中存储相同的特定列
# 缓存表和汇总表
有时调高性能最好的办法是在同一张表中保存衍生的冗余数据。然而有时也需要创建一张完全独立的缓存表或汇总表。
缓存表：存储那些可以笔记简单地从schema其他表获取数据的表（但是每次获取的速度很慢）。
汇总表：保存使用`GROUP BY`语句聚合数据的表
更快地读，更慢地写
## 物化视图
预先计算并且存储在磁盘中的表，可以通过各种各样的策略刷新和更新
## 计数器表 


# 总结
1. 尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列
2. 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存
3. 尽量使用整形定义标识列
4. 避免使用已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度