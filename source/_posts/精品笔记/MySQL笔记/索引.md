---
title: Mysql学习笔记
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: Mysql学习笔记
categories: Mysql学习笔记
tags:
  - Mysql
  - 索引
  - B-TREE
abbrlink: 7f3b056
date: 2020-06-15 00:00:00
---

# 索引简介

索引是存储引擎用于快速找到记录的一种数据结构

索引是帮助MySQL高效获取数据的数据结构,索引存储在硬盘中

索引优化是对查询性能优化最有效的手段



# 索引基础

存储引擎先在索引中找到对应值,然后根据匹配的索引记录找到对应的数据行

## 索引类型

### B-TREE索引

1. 通常意味着所有的值按顺序存储,并且每一个叶子叶到根的距离相同
2. 绝对平衡,都在同一水平线上,每个节点的关键字有一个到N个,解决了IO浪费.,Degree-1=最多的关键字个数
3. 适合查找范围数据
4. 索引列的顺序很重要, B-TREE的限制都和索引列的顺序有关

#### 不用二叉搜索树的原因

不是平衡二叉树
#### 不用AVL树的原因

1. 每个父节点只有两个子节点,树的高度决定查找的次数,速度
2. IO次数太多,而且造成IO浪费

#### B-TREE索引的限制
1. 如果不是按照索引的最左列开始查找,则无法使用索引
2. 不能跳过索引的列
3. 如果查询中有某个列的范围查询,则其右边所有列都无法使用索引优化查找

### 哈希索引
只有Memory引擎显示支持,且是Memory引擎的默认索引类型,支持非唯一哈希索引(即冲突的以链表存储).
只适用特定场合,但是性能显著
#### 限制
1. 哈希索引只包含哈希值和行指针,不存储字段值,不能使用索引中的值来避免读取行
2. 不按照索引值的顺序排序,所有无法用于排序
3. 不支持所有列匹配查找,始终使用索引列的全部内容计算Hash,即如果有索引(A,B),查询只有数据列A,则无法使用索引
4. 只支持等值比较查询,也不支持任何范围查询
5. Hash冲突时,必须遍历链表中所有行指针,逐行比较
6. Hash在内存中,但是有几千万的数据时不行



# 索引优点

1. 让服务器快速地定位到表的指定位置
2. B-TREE索引是按照顺序存储数据，可以用来做ORDER BY,GROUP BY操作。
3. 索引存储了实际的列值,某些查询只使用索引就能完成全部查询







# 三星索引

一星:索引将相关的记录放在一起

二星:索引中的数据顺序和查找中的排列顺序一致

三星:索引中的列包含查询中需要的全部列



# 高性能的索引策略

## 独立的列

索引列不能是表达式的一部分,也不能是函数的参数

## 前缀索引和索引选择性

索引的选择性:不重复的索引值和数据表的记录总数.索引的选择性越高则查询效率越高,因为索引的选择性高则可以在查找时过滤更多的行。唯一索引的选择性是1，是最好的索引选择性，性能最好。

一般情况下某个列前缀的选择性也足够高，足以满足查询性能，大大节约索引空间

要选择足够长的前缀以保证较高的选择性，但是又不能太长（节约空间）。前缀要足够长以使得前缀索引的选择性接近于索引的整个列

完整列的选择性：该列不重复的数据总数、总数 



## 多列索引

## 选择合适的索引列顺序

正确的顺序依赖于使用该索引的查询，同时需要考虑如何更好地满足排序和分组的需求

将选择性最高的列放到索引的最前列

## 聚簇索引

是一种数据存储方式

在同一个结构保存了B-Tree索引和数据行

一般是通过主键聚集数据，但是如果没有定义主键，则回选取唯一非空索引替代。若没有这样的索引，则会隐式定义一个主键作为聚簇索引

## 覆盖索引

覆盖索引：一个索引包含（覆盖）所有需要查询的字段和值

### 优点

1. 索引条目通常远小于数据行大小，所以如果只读取索引，就会极大地减小数据访问量
2. 索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比从磁盘读取每一行数据的IO要少得多

### 要求

必须存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引

## 使用索引扫描来做排序

如果索引不能覆盖查询所需的全部列，就不得不每扫描一条索引记录都回表查询一次对应的行，基本是随机IO

所以，如果可能，尽量设计索引使得它既满足排序，又用于查找行

## 压缩（前缀压缩）索引

使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中

 ## 冗余和重复索引

重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免这样创建重复索引，发现后也应该立即移除

冗余索引：如创建了(A,B),又创建索引A





通过索引筛选出来的数据越少越好

避免再次排序

尽可能应用覆盖索引,减少回表操作



B+Tree:关键字:路数=1:1,只有叶节点有数据区,数据区间划分有区别,左闭右开

1 28 66

[1,28),[28,66),[66,无穷)

IO更小,稳定,每次查询消耗更小



Myisam:

InnoDB:只有主键索引是聚集索引,其他的索引都是非聚集索引.数据区挂载在主键索引上



如果一个表没有任何索引,会隐式创建_rowid,开销大,所以要主动创建索引



列的离散性:要找选择性,离散性最好的做索引



联合索引:(A,B,C),则相当于有A,(A,B),(A,B,C)三个索引

最左匹配原则



索引优化:

范围条件放最后



尽量使用覆盖索引,避免查了两张表.

例如在name建立了索引,根据它查询,会查询到name,id,但是其他要找就得再去查找id的B+树