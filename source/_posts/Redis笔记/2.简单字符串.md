---
title: 《Redis设计与实现》-------简单字符串
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: '学习《Redis设计与实现》所做的笔记,此为书上第二章--简单字符串。'
categories: Redis学习笔记
tags:
  - Redis
  - 数据结构
  - 字符串
abbrlink: 303ff37b
date: 2020-08-16 00:00:00
---




# SDS简介

+ 使用**简单动态字符串**(simple dynamic string SDS)作为默认字符串
+ c字符串只作为字符串字面量,用在无需对字符串值进行修改的地方
+ 包含字符串值的键值对在底层都是用`SDS`实现的

# SDS的定义

```c
struct sdshdr
{
	int len;//记录buf数组中已使用字节的数量 为字符串长度
	int free;//未使用的数量
	char buf[];//字节数组,用来保存字符串
}
```

1. `buf数组`以空字符结尾,且最后的空字符不算在len里面
2. 该空字符由`SDS`函数自动完成,对`SDS`用户透明

# SDS与C字符串的区别

## 1.获取字符串长度所需复杂度从O(N)降低到​O(1)​

## 2.杜绝了缓冲区溢出
例如c进行字符串拼接,需要假设已经为字符串分配了足够的内存以容纳要拼接的字符串,否则就会溢出。
**SDS空间分配策略**完全杜绝了发生缓冲区溢出的可能性.当要对SDS进行修改时,会先检查空间是否满足修改所需的要求,如果不满足,则会自动将**SDS的空间扩展**,然后再执行实际的修改操作

## 减少修改字符串时带来的内存重分配次数

C字符串底层实现总是一个`N+1`个字符长的数组,每次对该数组进行增加或缩短,总要进行一次**内存重分配**操作。如果是增长,则要内存重分配扩展底层数组的空间大小。如果是缩短，则执行操作后，需要内存重分配来释放空间，避免内存泄漏.

Redis通过**未使用空间**解除了字符串长度和底层数组长度之间的关联

### 空间预分配

用于优化`SDS`的字符串增长操作，在扩展SDS空间之前，会先检查未使用的空间是否足够，如果足够，则直接使用未使用空间，无需进行内存重分配。

在对一个SDS进行修改，并且需要对SDS进行空间扩展时，不仅为SDS分配修改所需要的空间，还会分配额外的未使用空间。

如果修改后 `SDS.len < 1MB`,程序会分配给和len一样的长度给free

如果修改后 `SDS.len >= 1MB`,程序会分配1MB给free

### 惰性空间释放

用于优化`SDS字符串`缩短操作：不立即回收缩短后多出来的字节，而是用`free`记录。避免了缩短字符串时所需的内存重分配操作，并且为将来可能的增长提供了优化

API也让我们在需要时，真正释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费

## 二进制安全

1. C字符串并且符合特定的编码，并且除字符串的末尾外，不能包含空字符，使得他只能保存文本数据
2. Redis以处理二进制的方式处理SDS存放在`buf数组`的数据，使用`len`而不是空字符判断字符串是否结束。所以他可以保存**任意格式**的二进制数据。

## 兼容部分C字符串函数

SDS保存数据的末尾总是为空字符，所以让那些保存文本数据的SDS可以重用一部分`<string.h>库`定义的函数



